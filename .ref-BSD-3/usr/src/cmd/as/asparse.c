begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_include
include|#
directive|include
file|"assyms.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|exp
name|usedot
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*information on the dot for each seg*/
end_comment

begin_decl_stmt
name|struct
name|exp
modifier|*
name|dotp
init|=
operator|&
name|usedot
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*current dot*/
end_comment

begin_decl_stmt
name|int
name|anyerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|passno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|tmpfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|relfil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*relocation info sent here*/
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|txtfil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*text (for any text #) sent here*/
end_comment

begin_decl_stmt
name|int
name|hshused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*hash slots consumed */
end_comment

begin_decl_stmt
name|long
name|tsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bitfield
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bitoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	The following three variables are communication between various  *	modules to special case a number of things.  They are properly  *	categorized as hacks.  */
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|lastnam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*last name seen by the lexical analyzer*/
end_comment

begin_decl_stmt
name|int
name|exprisname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*last factor in an expression was a name*/
end_comment

begin_decl_stmt
name|int
name|droppedLP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*one is analyzing an expression beginning with*/
end_comment

begin_comment
comment|/*a left parenthesis, which has already been*/
end_comment

begin_comment
comment|/*shifted. (Used to parse (<expr>)(rn)*/
end_comment

begin_decl_stmt
name|char
name|yytext
index|[
name|NCPS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Dotsname
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next free expression slot, used by expr.c*/
end_comment

begin_decl_stmt
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the lexical value; sloppy typing*/
end_comment

begin_decl_stmt
specifier|extern
name|ptrall
name|tokptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*points to current token being eaten*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|d124
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|yyparse
parameter_list|()
block|{
specifier|register
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
comment|/* 			 *	loc1xp and ptrloc1xp are used in the 			 * 	expression lookahead 			 */
name|struct
name|exp
modifier|*
name|loc1xp
decl_stmt|;
comment|/*must be non register*/
name|struct
name|exp
modifier|*
modifier|*
name|ptrloc1xp
init|=
operator|&
name|loc1xp
decl_stmt|;
name|struct
name|exp
modifier|*
name|pval
decl_stmt|;
comment|/*hacking expr:expr*/
specifier|register
name|struct
name|symtab
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|argcnt
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
comment|/*what yylex gives*/
specifier|register
name|int
name|auxval
decl_stmt|;
comment|/*saves val*/
specifier|register
name|struct
name|arg
modifier|*
name|ap
decl_stmt|;
comment|/*first free argument*/
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|stpt
decl_stmt|;
name|struct
name|strdesc
modifier|*
name|stringp
decl_stmt|;
comment|/*handles string lists*/
name|int
name|regno
decl_stmt|;
comment|/*handles arguments*/
name|int
modifier|*
name|ptrregno
init|=
operator|&
name|regno
decl_stmt|;
name|int
name|sawmul
decl_stmt|;
comment|/*saw * */
name|int
name|sawindex
decl_stmt|;
comment|/*saw [rn]*/
name|int
name|sawsize
decl_stmt|;
name|int
name|seg_type
decl_stmt|;
comment|/*the kind of segment: data or text*/
name|int
name|seg_number
decl_stmt|;
comment|/*the segment number*/
name|long
name|space_value
decl_stmt|;
comment|/*how much .space needs*/
name|int
name|field_width
decl_stmt|;
comment|/*how wide a field is to be*/
name|int
name|field_value
decl_stmt|;
comment|/*the value to stuff in a field*/
name|char
modifier|*
name|stabname
decl_stmt|;
comment|/*name of stab dealing with*/
name|ptrall
name|stabstart
decl_stmt|;
comment|/*where the stab starts in the buffer*/
name|xp
operator|=
name|explist
expr_stmt|;
name|ap
operator|=
name|arglist
expr_stmt|;
name|val
operator|=
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|val
operator|!=
name|PARSEEOF
condition|)
block|{
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|LINSTBEGIN
argument_list|)
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|NL
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|SEMI
condition|)
name|shift
expr_stmt|;
else|else
block|{
comment|/*its a name, so we have a label (hopefully*/
if|if
condition|(
name|val
operator|!=
name|NAME
condition|)
block|{
name|ERROR
argument_list|(
literal|"Name expected for a label"
argument_list|)
expr_stmt|;
block|}
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|COLON
argument_list|)
expr_stmt|;
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|!=
name|XUNDEF
condition|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|!=
name|dotp
operator|->
name|xtype
operator|||
name|np
operator|->
name|value
operator|!=
name|dotp
operator|->
name|xvalue
operator|||
operator|(
operator|(
name|passno
operator|==
literal|1
operator|)
operator|&&
operator|(
name|np
operator|->
name|index
operator|!=
name|dotp
operator|->
name|xloc
operator|)
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|np
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'L'
condition|)
endif|#
directive|endif
block|{
name|yyerror
argument_list|(
literal|"%.8s redefined"
argument_list|,
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"name.value=%d, dotp->xvalue=%d\n"
argument_list|,
name|np
operator|->
name|value
argument_list|,
name|dotp
operator|->
name|xvalue
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
name|np
operator|->
name|type
operator|&=
operator|~
operator|(
name|XTYPE
operator||
name|XFORW
operator|)
expr_stmt|;
name|np
operator|->
name|type
operator||=
name|dotp
operator|->
name|xtype
expr_stmt|;
name|np
operator|->
name|value
operator|=
name|dotp
operator|->
name|xvalue
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|np
operator|->
name|index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|nlabels
operator|++
expr_stmt|;
block|}
name|np
operator|->
name|tag
operator|=
name|LABELID
expr_stmt|;
block|}
block|}
comment|/*end of this being a label*/
block|}
comment|/*end of to consuming all labels, NLs and SEMIS */
name|xp
operator|=
name|explist
expr_stmt|;
name|ap
operator|=
name|arglist
expr_stmt|;
comment|/* 		 *	process the INSTRUCTION body 		 */
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
name|ERROR
argument_list|(
literal|"Unrecognized instruction or directive"
argument_list|)
expr_stmt|;
case|case
name|IABORT
case|:
name|shift
expr_stmt|;
name|sawabort
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
break|break;
case|case
name|PARSEEOF
case|:
name|tokptr
operator|-=
sizeof|sizeof
argument_list|(
name|toktype
argument_list|)
expr_stmt|;
operator|*
name|tokptr
operator|++
operator|=
name|VOID
expr_stmt|;
name|tokptr
index|[
literal|1
index|]
operator|=
name|VOID
expr_stmt|;
name|tokptr
index|[
literal|2
index|]
operator|=
name|PARSEEOF
expr_stmt|;
break|break;
case|case
name|IFILE
case|:
name|shift
expr_stmt|;
name|stringp
operator|=
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|STRING
argument_list|)
expr_stmt|;
name|dotsname
operator|=
operator|&
name|Dotsname
index|[
literal|0
index|]
expr_stmt|;
name|movestr
argument_list|(
name|dotsname
argument_list|,
name|stringp
operator|->
name|str
argument_list|,
name|stringp
operator|->
name|str_lg
operator|>=
literal|32
condition|?
literal|32
else|:
name|stringp
operator|->
name|str_lg
argument_list|)
expr_stmt|;
name|dotsname
index|[
name|stringp
operator|->
name|str_lg
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"(from parser) Now considered to be in file %s\n"
argument_list|,
name|dotsname
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ILINENO
case|:
name|shift
expr_stmt|;
comment|/*over the ILINENO*/
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Now considered to be on line number %d\n"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ISET
case|:
block|{
comment|/* .set<name> ,<expr> */
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|np
operator|->
name|type
operator|&=
operator|(
name|XXTRN
operator||
name|XFORW
operator|)
expr_stmt|;
name|np
operator|->
name|type
operator||=
name|locxp
operator|->
name|xtype
operator|&
operator|(
name|XTYPE
operator||
name|XFORW
operator|)
expr_stmt|;
name|np
operator|->
name|value
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
name|np
operator|->
name|index
operator|=
name|locxp
operator|->
name|xloc
expr_stmt|;
if|if
condition|(
operator|(
name|locxp
operator|->
name|xtype
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Illegal set?"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of case ISET*/
case|case
name|ILSYM
case|:
block|{
comment|/*.lsym name , expr */
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 			 *	Build the unique occurance of the 			 *	symbol. 			 *	The character scanner will have 			 *	already entered it into the symbol 			 *	table, but we should remove it 			 */
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|symalloc
argument_list|()
expr_stmt|;
name|movestr
argument_list|(
name|stpt
operator|->
name|name
argument_list|,
name|np
operator|->
name|name
argument_list|,
name|NCPS
argument_list|)
expr_stmt|;
name|np
operator|->
name|tag
operator|=
name|OBSOLETE
expr_stmt|;
comment|/*invalidate original */
name|nforgotten
operator|++
expr_stmt|;
name|np
operator|=
name|stpt
expr_stmt|;
if|if
condition|(
name|locxp
operator|->
name|xtype
operator|!=
name|XABS
condition|)
operator|(
literal|"Illegal lsym"
operator|)
expr_stmt|;
name|np
operator|->
name|value
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|np
operator|->
name|type
operator|=
name|XABS
expr_stmt|;
name|np
operator|->
name|tag
operator|=
name|ILSYM
expr_stmt|;
block|}
break|break;
block|}
comment|/*end of case ILSYM*/
case|case
name|IGLOBAL
case|:
block|{
comment|/*.globl<name> */
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|np
operator|->
name|type
operator||=
name|XXTRN
expr_stmt|;
break|break;
block|}
comment|/*end of case IGLOBAL*/
case|case
name|IDATA
case|:
comment|/*.data [<expr> ] */
case|case
name|ITEXT
case|:
block|{
comment|/*.text [<expr> ] */
name|seg_type
operator|=
operator|-
name|val
expr_stmt|;
name|shift
expr_stmt|;
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|seg_type
operator|=
operator|-
name|seg_type
expr_stmt|;
comment|/*now, it is positive*/
block|}
if|if
condition|(
name|seg_type
operator|<
literal|0
condition|)
block|{
comment|/*there wasn't an associated expr*/
name|seg_number
operator|=
literal|0
expr_stmt|;
name|seg_type
operator|=
operator|-
name|seg_type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|locxp
operator|->
name|xtype
operator|!=
name|XABS
operator|||
operator|(
name|seg_number
operator|=
name|locxp
operator|->
name|xvalue
operator|)
operator|>=
name|NLOC
condition|)
block|{
name|yyerror
argument_list|(
literal|"illegal location counter"
argument_list|)
expr_stmt|;
name|seg_number
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|seg_type
operator|==
name|IDATA
condition|)
name|seg_number
operator|+=
name|NLOC
expr_stmt|;
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
name|seg_number
index|]
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
block|{
comment|/* go salt away in pass 2*/
if|if
condition|(
name|usefile
index|[
name|seg_number
index|]
operator|==
name|NULL
condition|)
block|{
name|tmpn2
index|[
name|TMPC
index|]
operator|=
literal|'a'
operator|+
name|seg_number
expr_stmt|;
if|if
condition|(
operator|(
name|usefile
index|[
name|seg_number
index|]
operator|=
name|fopen
argument_list|(
name|tmpn2
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"cannot create temp %s"
argument_list|,
name|tmpn2
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|tmpn3
index|[
name|TMPC
index|]
operator|=
literal|'a'
operator|+
name|seg_number
expr_stmt|;
if|if
condition|(
operator|(
name|rusefile
index|[
name|seg_number
index|]
operator|=
name|fopen
argument_list|(
name|tmpn3
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"cannot create temp %s"
argument_list|,
name|tmpn3
argument_list|)
expr_stmt|;
block|}
block|}
name|txtfil
operator|=
name|usefile
index|[
name|seg_number
index|]
expr_stmt|;
name|relfil
operator|=
name|rusefile
index|[
name|seg_number
index|]
expr_stmt|;
block|}
break|break;
block|}
comment|/*end of case .TEXT and .DATA*/
comment|/* 		 *	Storage filler directives: 		 * 		 *	.byte	[<exprlist>] 		 * 		 *	exprlist:  empty | exprlist outexpr 		 *	outexpr:<expr> |<expr> :<expr> 		 */
case|case
name|IBYTE
case|:
name|curlen
operator|=
name|NBPW
operator|/
literal|4
expr_stmt|;
goto|goto
name|elist
goto|;
case|case
name|IINT
case|:
case|case
name|ILONG
case|:
name|curlen
operator|=
name|NBPW
expr_stmt|;
goto|goto
name|elist
goto|;
case|case
name|IWORD
case|:
block|{
name|curlen
operator|=
name|NBPW
operator|/
literal|2
expr_stmt|;
name|elist
label|:
name|seg_type
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
comment|/* 			 *	This processes an expression list  			 */
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
do|do
block|{
comment|/* 					 *	expression list consists of a list of : 					 *<expr> 					 *<expr> :<expr>  					 *		(pack expr2 into expr1 bits 					 */
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 					 *	now, pointing at the next token 					 */
if|if
condition|(
name|val
operator|==
name|COLON
condition|)
block|{
name|shiftover
argument_list|(
name|COLON
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|pval
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|locxp
operator|->
name|xtype
operator|!=
name|XABS
condition|)
name|yyerror
argument_list|(
literal|"Width not absolute"
argument_list|)
expr_stmt|;
name|field_width
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|locxp
operator|=
name|pval
expr_stmt|;
if|if
condition|(
name|bitoff
operator|+
name|field_width
operator|>
name|curlen
condition|)
name|flushfield
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_width
operator|>
name|curlen
condition|)
name|yyerror
argument_list|(
literal|"Expression crosses field boundary"
argument_list|)
expr_stmt|;
block|}
comment|/*value being colon*/
else|else
block|{
name|field_width
operator|=
name|curlen
expr_stmt|;
name|flushfield
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|locxp
operator|->
name|xtype
operator|&
name|XTYPE
operator|)
operator|!=
name|XABS
condition|)
block|{
if|if
condition|(
name|bitoff
condition|)
name|yyerror
argument_list|(
literal|"Illegal relocation in field"
argument_list|)
expr_stmt|;
name|field_width
operator|=
name|LEN1
operator|+
operator|!
name|PCREL
expr_stmt|;
if|if
condition|(
name|curlen
operator|==
name|NBPW
condition|)
name|field_width
operator|=
name|LEN4
operator|+
operator|!
name|PCREL
expr_stmt|;
if|if
condition|(
name|curlen
operator|==
name|NBPW
operator|/
literal|2
condition|)
name|field_width
operator|=
name|LEN2
operator|+
operator|!
name|PCREL
expr_stmt|;
comment|/* 						 *	Save relocation information for this non absolute 						 *	symbol: 						 *	pass 1:	saves enough space for the value, and 						 *		fixes dotp. 						 *	pass 2:	writes the address info in ld compatable 						 *		format onto one of the relfiles 						 */
name|outrel
argument_list|(
operator|&
name|locxp
operator|->
name|xvalue
argument_list|,
name|field_width
argument_list|,
name|locxp
operator|->
name|xtype
argument_list|,
name|locxp
operator|->
name|xname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field_value
operator|=
name|locxp
operator|->
name|xvalue
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|field_width
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bitfield
operator||=
name|field_value
operator|<<
name|bitoff
expr_stmt|;
name|bitoff
operator|+=
name|field_width
expr_stmt|;
block|}
if|if
condition|(
name|auxval
operator|=
operator|(
name|val
operator|==
name|CM
operator|)
condition|)
name|shift
expr_stmt|;
block|}
do|while
condition|(
name|auxval
condition|)
do|;
block|}
comment|/*existed an expression  at all*/
name|flushfield
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curlen
operator|==
name|NBPW
operator|/
literal|4
operator|)
operator|&&
name|bitoff
condition|)
name|dotp
operator|->
name|xvalue
operator|++
expr_stmt|;
break|break;
block|}
comment|/*end of case IBYTE, IWORD, ILONG, IINT*/
case|case
name|ISPACE
case|:
block|{
comment|/* .space<expr> */
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|locxp
operator|->
name|xtype
operator|!=
name|XABS
condition|)
name|yyerror
argument_list|(
literal|"Space size not absolute"
argument_list|)
expr_stmt|;
name|space_value
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|ospace
label|:
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|space_value
operator|>
literal|96
condition|)
block|{
name|outs
argument_list|(
name|strbuf
index|[
literal|2
index|]
operator|.
name|str
argument_list|,
literal|96
argument_list|)
expr_stmt|;
name|space_value
operator|-=
literal|96
expr_stmt|;
block|}
name|outs
argument_list|(
name|strbuf
index|[
literal|2
index|]
operator|.
name|str
argument_list|,
name|space_value
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of case ISPACE*/
case|case
name|IASCII
case|:
comment|/* .ascii [<stringlist> ] */
case|case
name|IASCIZ
case|:
block|{
comment|/* .asciz [<stringlist> ] */
name|auxval
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
comment|/* 			 *	Code to consume a string list 			 * 			 *	stringlist: empty | STRING | stringlist STRING 			 */
while|while
condition|(
name|val
operator|==
name|STRING
condition|)
block|{
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitoff
condition|)
name|dotp
operator|->
name|xvalue
operator|++
expr_stmt|;
name|stringp
operator|=
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
expr_stmt|;
name|outs
argument_list|(
name|stringp
operator|->
name|str
argument_list|,
name|stringp
operator|->
name|str_lg
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
comment|/*over the STRING*/
if|if
condition|(
name|val
operator|==
name|CM
condition|)
comment|/*could be a split string*/
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|auxval
operator|==
name|IASCIZ
condition|)
block|{
name|flushfield
argument_list|(
name|NBPW
operator|/
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*end of case IASCII and IASIZ*/
case|case
name|IORG
case|:
block|{
comment|/* .org<expr> */
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|locxp
operator|->
name|xtype
operator|==
name|XABS
condition|)
name|orgwarn
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|locxp
operator|->
name|xtype
operator|!=
name|dotp
operator|->
name|xtype
condition|)
name|yyerror
argument_list|(
literal|"Illegal expression to set origin"
argument_list|)
expr_stmt|;
name|space_value
operator|=
name|locxp
operator|->
name|xvalue
operator|-
name|dotp
operator|->
name|xvalue
expr_stmt|;
if|if
condition|(
name|space_value
operator|<
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Backwards 'org'"
argument_list|)
expr_stmt|;
goto|goto
name|ospace
goto|;
break|break;
block|}
comment|/*end of case IORG*/
comment|/* 		 * 		 *	Process stabs.  Stabs are created only by the f77 		 *	and the C compiler with the -g flag set. 		 *	We only look at the stab ONCE, during pass 1, and 		 *	virtually remove the stab from the intermediate file 		 *	so it isn't seen during pass2.  This makes for some 		 *	hairy processing to handle labels occuring in 		 *	stab entries, but since most expressions in the 		 *	stab are integral we save lots of time in the second 		 *	pass by not looking at the stabs. 		 *	A stab that is tagged floating will be bumped during 		 *	the jxxx resolution phase.  A stab tagged fixed will 		 *	not be be bumped. 		 * 		 *	.stab:	Old fashioned stabs 		 *	.stabn: For stabs without names 		 *	.stabs:	For stabs with string names 		 *	.stabd: For stabs for line numbers or bracketing, 		 *		without a string name, without 		 *		a final expression.  The value of the 		 *		final expression is taken to be  the current 		 *		location counter, and is patched by the 2nd pass 		 * 		 *	.stab{<expr>,}*8,<expr>,<expr>,<expr>,<expr> 		 *	.stabn<expr>,<expr>,<expr>,<expr> 		 *	.stabs   STRING,<expr>,<expr>,<expr>,<expr> 		 *	.stabd<expr>,<expr>,<expr> # .  		 */
case|case
name|ISTAB
case|:
block|{
name|stabname
operator|=
literal|".stab"
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
goto|goto
name|errorfix
goto|;
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
comment|/* 			 *	Make a pointer to the .stab slot. 			 *	There is a pointer in the way (stpt), and 			 *	tokptr points to the next token. 			 */
name|stabstart
operator|=
name|tokptr
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|stabstart
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
operator|*
argument_list|)
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|stabstart
operator|-=
sizeof|sizeof
argument_list|(
name|toktype
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
for|for
control|(
name|argcnt
operator|=
literal|0
init|;
name|argcnt
operator|<
literal|8
condition|;
name|argcnt
operator|++
control|)
block|{
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|name
index|[
name|argcnt
index|]
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
block|}
name|tailstab
label|:
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|locxp
operator|->
name|xvalue
operator|&
name|STABTYPS
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Invalid type in %s"
argument_list|,
name|stabname
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
name|stpt
operator|->
name|ptype
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|other
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|desc
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|exprisname
operator|=
literal|0
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|p
operator|=
name|locxp
operator|->
name|xname
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/*absolute expr to begin with*/
name|stpt
operator|->
name|value
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|stpt
operator|->
name|index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
if|if
condition|(
name|exprisname
condition|)
block|{
switch|switch
condition|(
name|stpt
operator|->
name|ptype
condition|)
block|{
case|case
name|N_GSYM
case|:
case|case
name|N_FNAME
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_SSYM
case|:
case|case
name|N_LSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_BCOMM
case|:
case|case
name|N_ECOMM
case|:
case|case
name|N_LENG
case|:
name|stpt
operator|->
name|tag
operator|=
name|STABFIXED
expr_stmt|;
break|break;
default|default:
name|stpt
operator|->
name|tag
operator|=
name|STABFLOATING
expr_stmt|;
break|break;
block|}
block|}
else|else
name|stpt
operator|->
name|tag
operator|=
name|STABFIXED
expr_stmt|;
block|}
else|else
block|{
comment|/*really have a name*/
name|stpt
operator|->
name|dest
operator|=
name|locxp
operator|->
name|xname
expr_stmt|;
name|stpt
operator|->
name|index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|stpt
operator|->
name|type
operator|=
name|p
operator|->
name|type
operator||
name|STABFLAG
expr_stmt|;
comment|/* 				 *	We will assign a more accruate 				 *	guess of locxp's location when 				 *	we sort the symbol table 				 *	The final value of value is 				 *	given by stabfix() 				 */
name|stpt
operator|->
name|tag
operator|=
name|STABFLOAT
expr_stmt|;
ifdef|#
directive|ifdef
name|DSTAB
name|printf
argument_list|(
literal|"FORWARD REF FOR %s...\n"
argument_list|,
name|stabname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"value (xname) = %x value(value(xname) = %x\n"
argument_list|,
name|stpt
operator|->
name|dest
argument_list|,
name|stpt
operator|->
name|dest
operator|->
name|value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"name: %.8s\n\n"
argument_list|,
operator|(
name|stpt
operator|->
name|dest
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 			 *	tokptr now points at one token beyond 			 *	the current token stored in val and yylval, 			 *	which are the next tokens after the end of 			 *	this .stab directive.  This next token must 			 *	be either a SEMI or NL, so is of width just 			 *	one.  Therefore, to point to the next token 			 *	after the end of this stab, just back up one.. 			 */
name|buildskip
argument_list|(
name|stabstart
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tokptr
operator|-
sizeof|sizeof
argument_list|(
name|toktype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*end of the .stab*/
block|}
comment|/*end of ISTAB*/
case|case
name|ISTABDOT
case|:
block|{
name|stabname
operator|=
literal|".stabd"
expr_stmt|;
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
comment|/* 			 *	We clobber everything after the 			 *	.stabd and its pointer... we MUST 			 *	be able to get back to this .stabd 			 *	so that we can resolve its final value 			 */
name|stabstart
operator|=
name|tokptr
expr_stmt|;
name|shift
expr_stmt|;
comment|/*over the ISTABDOT*/
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|locxp
operator|->
name|xvalue
operator|&
name|STABTYPS
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Invalid type in .stabd"
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
name|stpt
operator|->
name|ptype
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|other
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|stpt
operator|->
name|desc
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
comment|/* 				 * 				 *	Now, clobber everything but the 				 *	.stabd pseudo and the pointer 				 *	to its symbol table entry 				 *	tokptr points to the next token, 				 *	build the skip up to this 				 */
name|buildskip
argument_list|(
name|stabstart
argument_list|,
operator|(
name|toktype
operator|*
operator|)
name|tokptr
operator|-
sizeof|sizeof
argument_list|(
name|toktype
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *	pass 1:	Assign a good guess for its position 			 *		(ensures they are sorted into right place)/ 			 *	pass 2:	Fix the actual value 			 */
name|stpt
operator|->
name|value
operator|=
name|dotp
operator|->
name|xvalue
expr_stmt|;
name|stpt
operator|->
name|index
operator|=
name|dotp
operator|-
name|usedot
expr_stmt|;
name|stpt
operator|->
name|tag
operator|=
name|STABFLOAT
expr_stmt|;
comment|/*although it has no effect in pass 2*/
break|break;
block|}
comment|/*end of case ISTABDOT*/
case|case
name|ISTABNONE
case|:
name|stabname
operator|=
literal|".stabn"
expr_stmt|;
goto|goto
name|shortstab
goto|;
case|case
name|ISTABSTR
case|:
block|{
name|stabname
operator|=
literal|".stabs"
expr_stmt|;
name|shortstab
label|:
name|auxval
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
goto|goto
name|errorfix
goto|;
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|stabstart
operator|=
name|tokptr
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|stabstart
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
operator|*
argument_list|)
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|stabstart
operator|-=
sizeof|sizeof
argument_list|(
name|toktype
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
if|if
condition|(
name|auxval
operator|==
name|ISTABSTR
condition|)
block|{
name|stringp
operator|=
operator|(
expr|struct
name|strdesc
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|STRING
argument_list|)
expr_stmt|;
name|auxval
operator|=
name|stringp
operator|->
name|str_lg
operator|>
name|NCPS
condition|?
name|NCPS
else|:
name|stringp
operator|->
name|str_lg
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stringp
operator|=
operator|&
operator|(
name|strbuf
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|auxval
operator|=
name|NCPS
expr_stmt|;
block|}
name|movestr
argument_list|(
name|stpt
operator|->
name|name
argument_list|,
name|stringp
operator|->
name|str
argument_list|,
name|auxval
argument_list|)
expr_stmt|;
goto|goto
name|tailstab
goto|;
break|break;
block|}
comment|/*end of case ISTABSTR and ISTABN*/
case|case
name|ICOMM
case|:
comment|/* .comm<name> ,<expr> */
case|case
name|ILCOMM
case|:
block|{
comment|/* .lcomm<name> ,<expr> */
name|auxval
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|np
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shiftover
argument_list|(
name|NAME
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|locxp
operator|->
name|xtype
operator|!=
name|XABS
condition|)
name|yyerror
argument_list|(
literal|"comm size not absolute"
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
operator|&&
operator|(
name|np
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|!=
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Redefinition of %.8s"
argument_list|,
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
block|{
name|np
operator|->
name|value
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
if|if
condition|(
name|auxval
operator|==
name|ICOMM
condition|)
name|np
operator|->
name|type
operator||=
name|XXTRN
expr_stmt|;
else|else
block|{
name|np
operator|->
name|type
operator|&=
operator|~
name|XTYPE
expr_stmt|;
name|np
operator|->
name|type
operator||=
name|XBSS
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/*end of case ICOMM and ILCOMM*/
case|case
name|IALIGN
case|:
block|{
comment|/* .align<expr> */
name|stpt
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|jalign
argument_list|(
name|locxp
argument_list|,
name|stpt
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of case IALIGN*/
case|case
name|INST0
case|:
block|{
comment|/* instructions w/o arguments*/
name|insout
argument_list|(
name|yylval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
break|break;
block|}
comment|/*end of case INST0*/
case|case
name|INSTn
case|:
comment|/* instructions with arguments*/
case|case
name|IJXXX
case|:
block|{
comment|/* UNIX style jump instructions */
name|auxval
operator|=
name|val
expr_stmt|;
name|seg_type
operator|=
name|yylval
expr_stmt|;
comment|/* 			 *	Code to process an argument list 			 */
name|ap
operator|=
name|arglist
expr_stmt|;
name|xp
operator|=
name|explist
expr_stmt|;
comment|/*must be set before bring in the first token*/
name|shift
expr_stmt|;
comment|/*and bring in the first token for the arg list*/
for|for
control|(
name|argcnt
operator|=
literal|1
init|;
name|argcnt
operator|<=
literal|6
condition|;
name|argcnt
operator|++
operator|,
name|ap
operator|++
control|)
block|{
comment|/* 				 *	code to process an argument proper 				 */
name|sawindex
operator|=
name|sawmul
operator|=
name|sawsize
operator|=
literal|0
expr_stmt|;
block|{
switch|switch
condition|(
name|val
condition|)
block|{
default|default:
block|{
name|disp
label|:
if|if
condition|(
operator|!
operator|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
operator|)
condition|)
block|{
name|ERROR
argument_list|(
literal|"expression expected"
argument_list|)
expr_stmt|;
block|}
name|expr
argument_list|(
name|ap
operator|->
name|xp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|overdisp
label|:
if|if
condition|(
name|val
operator|==
name|LP
operator|||
name|sawsize
condition|)
block|{
name|shiftover
argument_list|(
name|LP
argument_list|)
expr_stmt|;
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RP
argument_list|)
expr_stmt|;
name|ap
operator|->
name|atype
operator|=
name|ADISP
expr_stmt|;
name|ap
operator|->
name|areg1
operator|=
name|regno
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|atype
operator|=
name|AEXP
expr_stmt|;
name|ap
operator|->
name|areg1
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|index
goto|;
block|}
comment|/*end of the default action*/
case|case
name|SIZESPEC
case|:
block|{
name|sizespec
label|:
name|sawsize
operator|=
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
goto|goto
name|disp
goto|;
block|}
case|case
name|REG
case|:
case|case
name|REGOP
case|:
block|{
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|ap
operator|->
name|atype
operator|=
name|AREG
expr_stmt|;
name|ap
operator|->
name|areg1
operator|=
name|regno
expr_stmt|;
break|break;
block|}
comment|/*end of case REG*/
case|case
name|MUL
case|:
block|{
name|sawmul
operator|=
literal|1
expr_stmt|;
name|shift
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|LP
condition|)
goto|goto
name|base
goto|;
if|if
condition|(
name|val
operator|==
name|LITOP
condition|)
goto|goto
name|imm
goto|;
if|if
condition|(
name|val
operator|==
name|SIZESPEC
condition|)
goto|goto
name|sizespec
goto|;
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|EBEGOPS
operator|+
name|YUKKYEXPRBEG
operator|+
name|SAFEEXPRBEG
argument_list|)
condition|)
goto|goto
name|disp
goto|;
name|ERROR
argument_list|(
literal|"expression, '(' or '$' expected"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of case MUL*/
case|case
name|LP
case|:
block|{
name|base
label|:
name|shift
expr_stmt|;
comment|/*consume the LP*/
comment|/* 					 *	hack the ambiguity of 					 *	movl (expr) (rn), ... 					 *	note that (expr) could also 					 *	be (rn) (by special hole in the 					 *	grammar), which we ensure 					 *	means register indirection, instead 					 *	of an expression with value n 					 */
if|if
condition|(
name|val
operator|!=
name|REG
operator|&&
name|val
operator|!=
name|REGOP
condition|)
block|{
name|droppedLP
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|exprparse
argument_list|(
name|val
argument_list|,
operator|&
operator|(
name|ap
operator|->
name|xp
operator|)
argument_list|)
expr_stmt|;
name|droppedLP
operator|=
literal|0
expr_stmt|;
goto|goto
name|overdisp
goto|;
block|}
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RP
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|PLUS
condition|)
block|{
name|shift
expr_stmt|;
name|ap
operator|->
name|atype
operator|=
name|AINCR
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|atype
operator|=
name|ABASE
expr_stmt|;
name|ap
operator|->
name|areg1
operator|=
name|regno
expr_stmt|;
goto|goto
name|index
goto|;
block|}
comment|/*end of case LP*/
case|case
name|LITOP
case|:
block|{
name|imm
label|:
name|shift
expr_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ap
operator|->
name|atype
operator|=
name|AIMM
expr_stmt|;
name|ap
operator|->
name|areg1
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|xp
operator|=
name|locxp
expr_stmt|;
goto|goto
name|index
goto|;
block|}
comment|/*end of case LITOP*/
case|case
name|MP
case|:
block|{
name|shift
expr_stmt|;
comment|/* -(reg) */
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RP
argument_list|)
expr_stmt|;
name|ap
operator|->
name|atype
operator|=
name|ADECR
expr_stmt|;
name|ap
operator|->
name|areg1
operator|=
name|regno
expr_stmt|;
name|index
label|:
comment|/*look for [reg] */
if|if
condition|(
name|val
operator|==
name|LB
condition|)
block|{
name|shift
expr_stmt|;
name|findreg
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|shiftover
argument_list|(
name|RB
argument_list|)
expr_stmt|;
name|sawindex
operator|=
literal|1
expr_stmt|;
name|ap
operator|->
name|areg2
operator|=
name|regno
expr_stmt|;
block|}
break|break;
block|}
comment|/*end of case MP*/
block|}
comment|/*end of the switch to process an arg*/
block|}
comment|/*end of processing an argument*/
if|if
condition|(
name|sawmul
condition|)
block|{
comment|/* 					 * Make a concession for *(%r) 					 * meaning *0(%r)  					 */
if|if
condition|(
name|ap
operator|->
name|atype
operator|==
name|ABASE
condition|)
block|{
name|ap
operator|->
name|atype
operator|=
name|ADISP
expr_stmt|;
name|xp
operator|->
name|xtype
operator|=
name|XABS
expr_stmt|;
name|xp
operator|->
name|xvalue
operator|=
literal|0
expr_stmt|;
name|xp
operator|->
name|xloc
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|xp
operator|=
name|xp
operator|++
expr_stmt|;
block|}
name|ap
operator|->
name|atype
operator||=
name|ASTAR
expr_stmt|;
name|sawmul
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sawindex
condition|)
block|{
name|ap
operator|->
name|atype
operator||=
name|AINDX
expr_stmt|;
name|sawindex
operator|=
literal|0
expr_stmt|;
block|}
name|ap
operator|->
name|dispsize
operator|=
name|sawsize
operator|==
literal|0
condition|?
name|d124
else|:
name|sawsize
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|CM
condition|)
break|break;
name|shiftover
argument_list|(
name|CM
argument_list|)
expr_stmt|;
block|}
comment|/*processing all the arguments*/
if|if
condition|(
name|argcnt
operator|>
literal|6
condition|)
block|{
name|yyerror
argument_list|(
literal|"More than 6 arguments"
argument_list|)
expr_stmt|;
goto|goto
name|errorfix
goto|;
block|}
name|insout
argument_list|(
name|seg_type
argument_list|,
name|arglist
argument_list|,
name|auxval
operator|==
name|INSTn
condition|?
name|argcnt
else|:
operator|-
name|argcnt
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end of case INSTn and IJXXX*/
case|case
name|IFLOAT
case|:
name|curlen
operator|=
literal|4
expr_stmt|;
goto|goto
name|floatlist
goto|;
case|case
name|IDOUBLE
case|:
block|{
name|curlen
operator|=
literal|8
expr_stmt|;
name|floatlist
label|:
comment|/* 			 *	eat a list of floating point numbers 			 */
name|shift
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|FLTNUM
condition|)
block|{
do|do
block|{
if|if
condition|(
name|val
operator|==
name|CM
condition|)
name|shift
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|FLTNUM
condition|)
block|{
name|ERROR
argument_list|(
literal|"floating number expected"
argument_list|)
expr_stmt|;
block|}
name|dotp
operator|->
name|xvalue
operator|+=
name|curlen
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|fwrite
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
operator|)
operator|->
name|doubval
operator|.
name|dvalue
operator|)
argument_list|,
literal|1
argument_list|,
name|curlen
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
block|}
do|while
condition|(
name|val
operator|==
name|CM
condition|)
do|;
block|}
break|break;
block|}
comment|/*end of case IFLOAT and IDOUBLE*/
block|}
comment|/*end of the switch for looking at each reserved word*/
comment|/* 		 *	If got here, then one has no syntax errors! 		 */
continue|continue;
comment|/* 		 *	got here by either requesting to skip to the 		 *	end of this statement, or by erroring out and 		 *	wanting to apply panic mode recovery 		 */
name|errorfix
label|:
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Discarding tokens from here:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|val
operator|!=
name|NL
operator|)
operator|&&
operator|(
name|val
operator|!=
name|SEMI
operator|)
operator|&&
operator|(
name|val
operator|!=
name|PARSEEOF
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"****>>>>\t"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|NL
condition|)
name|lineno
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"To here.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|shift
expr_stmt|;
block|}
block|}
comment|/*end of the loop to read the entire file, line by line*/
block|}
end_function

begin_comment
comment|/*end of yyparse*/
end_comment

begin_comment
comment|/*  *	Process a register declaration of the form  *	%<expr>  *  *	Note:  *		The scanner has already processed funny registers of the form  *	%dd[+-]*, where dd is a decimal number in the range 00 to 15 (optional  *	preceding zero digit).  If there was any space between the % and  *	the digit, the scanner wouldn't have recognized it, so we  *	hack it out here.  */
end_comment

begin_function
name|int
name|funnyreg
parameter_list|(
name|val
parameter_list|,
name|regnoback
parameter_list|)
comment|/*what the read head will sit on*/
name|int
name|val
decl_stmt|;
comment|/*what the read head is sitting on*/
name|int
modifier|*
name|regnoback
decl_stmt|;
comment|/*call by return*/
block|{
specifier|register
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
name|struct
name|exp
modifier|*
name|loc1xp
decl_stmt|;
name|struct
name|exp
modifier|*
modifier|*
name|ptrloc1xp
init|=
operator|&
name|loc1xp
decl_stmt|;
name|expr
argument_list|(
name|locxp
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/*and leave the current read head with value*/
if|if
condition|(
operator|(
name|passno
operator|==
literal|2
operator|)
operator|&&
operator|(
name|locxp
operator|->
name|xtype
operator|&
name|XTYPE
operator|!=
name|XABS
operator|||
name|locxp
operator|->
name|xvalue
operator|<
literal|0
operator|||
name|locxp
operator|->
name|xvalue
operator|>=
literal|16
operator|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Illegal register"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|regnoback
operator|=
name|locxp
operator|->
name|xvalue
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VARARGS 1*/
end_comment

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|sink
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|sink
operator|=
name|stdout
expr_stmt|;
else|#
directive|else
name|sink
operator|=
name|stderr
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|anyerrs
operator|==
literal|0
operator|&&
operator|!
name|silent
condition|)
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"Assembler:\n"
argument_list|)
expr_stmt|;
name|anyerrs
operator|++
expr_stmt|;
if|if
condition|(
name|silent
condition|)
return|return;
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"\"%s\", line %d: "
argument_list|,
name|dotsname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sink
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|sink
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

