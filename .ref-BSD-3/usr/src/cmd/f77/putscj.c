begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* INTERMEDIATE CODE GENERATION FOR S C JOHNSON C COMPILERS */
end_comment

begin_comment
comment|/* NEW VERSION USING BINARY POLISH POSTFIX INTERMEDIATE */
end_comment

begin_if
if|#
directive|if
name|FAMILY
operator|!=
name|SCJ
end_if

begin_expr_stmt
name|WRONG
name|put
name|FULE
operator|!
operator|!
operator|!
operator|!
endif|#
directive|endif
include|#
directive|include
file|"defs"
include|#
directive|include
file|"scjdefs"
expr|struct
name|Addrblock
operator|*
name|imagpart
argument_list|()
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|FOUR
value|4
end_define

begin_decl_stmt
specifier|extern
name|int
name|ops2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|types2
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|P2BUFFMAX
value|128
end_define

begin_decl_stmt
specifier|static
name|long
name|int
name|p2buff
index|[
name|P2BUFFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|p2bufp
init|=
operator|&
name|p2buff
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|p2bufend
init|=
operator|&
name|p2buff
index|[
name|P2BUFFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|puthead
argument_list|(
argument|s
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|VAX
if|if
condition|(
name|s
condition|)
name|p2ps
argument_list|(
literal|"\t.globl\t_%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* put out fake copy of left bracket line, to be redone later */
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
if|#
directive|if
name|FAMILY
operator|==
name|SCJ
operator|&&
name|OUTPUT
operator|==
name|BINARY
name|p2flush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|headoffset
operator|=
name|ftell
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|prhead
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|headerdone
operator|=
name|YES
expr_stmt|;
name|p2triple
argument_list|(
name|P2STMT
argument_list|,
operator|(
name|strlen
argument_list|(
name|infname
argument_list|)
operator|+
name|FOUR
operator|-
literal|1
operator|)
operator|/
name|FOUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|infname
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
comment|/* fake jump to start the optimizer */
if|if
condition|(
name|class
operator|!=
name|CLBLOCK
condition|)
name|putgoto
argument_list|(
name|fudgelabel
operator|=
name|newlabel
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/* It is necessary to precede each procedure with a "left bracket"  * line that tells pass 2 how many register variables and how  * much automatic space is required for the function.  This compiler  * does not know how much automatic space is needed until the  * entire procedure has been processed.  Therefore, "puthead"  * is called at the begining to record the current location in textfile,  * then to put out a placeholder left bracket line.  This procedure  * repositions the file and rewrites that line, then puts the  * file pointer back to the end of the file.  */
end_comment

begin_macro
name|putbracket
argument_list|()
end_macro

begin_block
block|{
name|long
name|int
name|hereoffset
decl_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|SCJ
operator|&&
name|OUTPUT
operator|==
name|BINARY
name|p2flush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|hereoffset
operator|=
name|ftell
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|textfile
argument_list|,
name|headoffset
argument_list|,
literal|0
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"fseek failed"
argument_list|)
expr_stmt|;
name|prhead
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|textfile
argument_list|,
name|hereoffset
argument_list|,
literal|0
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"fseek failed 2"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putrbrack
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op
argument_list|(
name|P2RBRACKET
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putnreg
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|puteof
argument_list|()
end_macro

begin_block
block|{
name|p2op
argument_list|(
name|P2EOF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|putstmt
argument_list|()
end_macro

begin_block
block|{
name|p2triple
argument_list|(
name|P2STMT
argument_list|,
literal|0
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* put out code for if( ! p) goto l  */
end_comment

begin_expr_stmt
name|putif
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
specifier|register
name|expptr
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
operator|(
name|p
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|headblock
operator|.
name|vtype
operator|)
operator|!=
name|TYLOGICAL
condition|)
block|{
if|if
condition|(
name|k
operator|!=
name|TYERROR
condition|)
name|err
argument_list|(
literal|"non-logical expression in IF statement"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putex1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2icon
argument_list|(
operator|(
name|long
name|int
operator|)
name|l
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2CBRANCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* put out code for  goto l   */
end_comment

begin_macro
name|putgoto
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|int
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|P2GOTO
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* branch to address constant or integer variable */
end_comment

begin_expr_stmt
name|putbranch
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|Addrblock
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putex1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2GOTO
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* put out label  l:     */
end_comment

begin_macro
name|putlabel
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|int
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op
argument_list|(
name|P2LABEL
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putexpr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putex1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|putcmgo
argument_list|(
argument|index
argument_list|,
argument|nlab
argument_list|,
argument|labs
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Labelblock
modifier|*
name|labs
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|labarray
decl_stmt|,
name|skiplabel
decl_stmt|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|index
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|execerr
argument_list|(
literal|"computed goto index must be integer"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|TARGET
operator|==
name|VAX
comment|/* use special case instruction */
name|vaxgoto
argument_list|(
name|index
argument_list|,
name|nlab
argument_list|,
name|labs
argument_list|)
expr_stmt|;
else|#
directive|else
name|labarray
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|preven
argument_list|(
name|ALIADDR
argument_list|)
expr_stmt|;
name|prlabel
argument_list|(
name|asmfile
argument_list|,
name|labarray
argument_list|)
expr_stmt|;
name|prcona
argument_list|(
name|asmfile
argument_list|,
call|(
name|ftnint
call|)
argument_list|(
name|skiplabel
operator|=
name|newlabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlab
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|labs
index|[
name|i
index|]
condition|)
name|prcona
argument_list|(
name|asmfile
argument_list|,
call|(
name|ftnint
call|)
argument_list|(
name|labs
index|[
name|i
index|]
operator|->
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
name|prcmgoto
argument_list|(
name|index
argument_list|,
name|nlab
argument_list|,
name|skiplabel
argument_list|,
name|labarray
argument_list|)
expr_stmt|;
name|putlabel
argument_list|(
name|skiplabel
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_macro
name|putx
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Addrblock
modifier|*
name|putcall
argument_list|()
decl_stmt|,
modifier|*
name|putcx1
argument_list|()
decl_stmt|,
modifier|*
name|realpart
argument_list|()
decl_stmt|;
name|char
modifier|*
name|memname
parameter_list|()
function_decl|;
name|int
name|opc
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|int
name|type
decl_stmt|,
name|k
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
condition|)
block|{
case|case
name|TERROR
case|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCONST
case|:
switch|switch
condition|(
name|type
operator|=
name|p
operator|->
name|constblock
operator|.
name|vtype
condition|)
block|{
case|case
name|TYLOGICAL
case|:
name|type
operator|=
name|tyint
expr_stmt|;
case|case
name|TYLONG
case|:
case|case
name|TYSHORT
case|:
name|p2icon
argument_list|(
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|,
name|types2
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYADDR
case|:
name|p2triple
argument_list|(
name|P2ICON
argument_list|,
literal|1
argument_list|,
name|P2INT
operator||
name|P2PTR
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|memname
argument_list|(
name|STGCONST
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putx
argument_list|(
name|putconst
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|opc
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|putcall
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
name|putmnmx
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPASSIGN
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|frexpr
argument_list|(
name|putcxeq
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
argument_list|)
condition|)
name|putcheq
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|putcxcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
condition|)
name|putchcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPPOWER
case|:
name|putpower
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
if|#
directive|if
name|FAMILY
operator|==
name|SCJ
comment|/*   m * (2**k) -> m<<k   */
if|if
condition|(
name|INT
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|&&
operator|(
operator|(
name|k
operator|=
name|log2
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPLSHIFT
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|ICON
argument_list|(
name|k
argument_list|)
expr_stmt|;
goto|goto
name|putopp
goto|;
block|}
endif|#
directive|endif
case|case
name|OPMOD
case|:
goto|goto
name|putopp
goto|;
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSLASH
case|:
case|case
name|OPNEG
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putx
argument_list|(
name|mkconv
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|realpart
argument_list|(
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPNOT
case|:
case|case
name|OPOR
case|:
case|case
name|OPAND
case|:
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
case|case
name|OPADDR
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPLSHIFT
case|:
case|case
name|OPRSHIFT
case|:
name|putopp
label|:
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"putx: invalid opcode %d"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
name|putaddr
argument_list|(
name|p
argument_list|,
name|YES
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"putx: impossible tag %d"
argument_list|,
name|p
operator|->
name|headblock
operator|.
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|putop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|expptr
name|lp
decl_stmt|,
name|tp
decl_stmt|;
name|int
name|pt
decl_stmt|,
name|lt
decl_stmt|;
name|int
name|comma
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
comment|/* check for special cases and rewrite */
block|{
case|case
name|OPCONV
case|:
name|pt
operator|=
name|p
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|lt
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
operator|&&
operator|(
operator|(
name|ISREAL
argument_list|(
name|pt
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|lt
argument_list|)
operator|)
operator|||
operator|(
name|INT
argument_list|(
name|pt
argument_list|)
operator|&&
operator|(
name|ONEOF
argument_list|(
name|lt
argument_list|,
name|MSKINT
operator||
name|MSKADDR
operator||
name|MSKCHAR
operator||
name|M
argument_list|(
name|TYSUBR
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
if|if
condition|(
name|lp
operator|->
name|headblock
operator|.
name|tag
operator|!=
name|TEXPR
condition|)
block|{
if|if
condition|(
name|pt
operator|==
name|TYINT
operator|&&
name|lt
operator|==
name|TYLONG
condition|)
break|break;
if|if
condition|(
name|lt
operator|==
name|TYINT
operator|&&
name|pt
operator|==
name|TYLONG
condition|)
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
if|if
condition|(
name|pt
operator|==
name|TYDREAL
operator|&&
name|lt
operator|==
name|TYREAL
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|lp
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCALL
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putcall
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
literal|1
argument_list|,
name|pt
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|lp
expr_stmt|;
name|pt
operator|=
name|lt
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|lt
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
condition|)
break|break;
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPADDR
case|:
name|comma
operator|=
name|NO
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|headblock
operator|.
name|tag
operator|!=
name|TADDR
condition|)
block|{
name|tp
operator|=
name|mktemp
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|=
name|tp
expr_stmt|;
name|comma
operator|=
name|YES
expr_stmt|;
block|}
name|putaddr
argument_list|(
name|lp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
name|putcomma
argument_list|(
literal|1
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|ops2
index|[
name|p
operator|->
name|exprblock
operator|.
name|opcode
index|]
operator|)
operator|<=
literal|0
condition|)
name|fatali
argument_list|(
literal|"putop: invalid opcode %d"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
condition|)
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|k
argument_list|,
name|types2
index|[
name|p
operator|->
name|exprblock
operator|.
name|vtype
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
condition|)
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|putforce
argument_list|(
argument|t
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|=
name|mkconv
argument_list|(
name|t
argument_list|,
name|fixtype
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2FORCE
argument_list|,
operator|(
name|t
operator|==
name|TYSHORT
condition|?
name|P2SHORT
else|:
operator|(
name|t
operator|==
name|TYLONG
condition|?
name|P2LONG
else|:
name|P2DREAL
operator|)
operator|)
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|putpower
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|expptr
name|base
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|ftnint
name|k
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|||
operator|(
name|k
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|)
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"putpower: bad call"
argument_list|)
expr_stmt|;
name|base
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|type
operator|=
name|base
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|t1
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t2
operator|=
name|NULL
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|k
operator|>
literal|2
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|2
condition|)
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|t2
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|>>=
literal|1
init|;
name|k
operator|>
literal|1
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&
literal|1
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
block|}
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|frexpr
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|struct
name|Addrblock
modifier|*
name|intdouble
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
name|struct
name|Addrblock
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|struct
name|Addrblock
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|mktemp
argument_list|(
name|TYDREAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxeq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Exprblock
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|Addrblock
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|struct
name|Addrblock
modifier|*
name|putcx1
parameter_list|()
function_decl|;
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putcx1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|struct
name|Addrblock
modifier|*
name|putcx1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
name|struct
name|Addrblock
modifier|*
name|q
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|Addrblock
modifier|*
name|resp
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|struct
name|Constblock
modifier|*
name|mkrealcon
parameter_list|()
function_decl|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|=
name|putconst
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TADDR
case|:
if|if
condition|(
operator|!
name|addressable
argument_list|(
name|p
argument_list|)
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mktemp
argument_list|(
name|tyint
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|resp
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
break|break;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mktemp
argument_list|(
name|TYDREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
default|default:
name|fatali
argument_list|(
literal|"putcx1: bad tag %d"
argument_list|,
name|p
operator|->
name|headblock
operator|.
name|tag
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPCALL
operator|||
name|opcode
operator|==
name|OPCCALL
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcall
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OPASSIGN
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcxeq
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
name|resp
operator|=
name|mktemp
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|rightp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPCOMMA
case|:
name|frexpr
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPNEG
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OPPLUS
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
name|lp
operator|=
name|intdouble
argument_list|(
name|lp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
comment|/* fixexpr has already replaced all divisions 		 * by a complex by a function call 		 */
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lp
operator|->
name|vtype
argument_list|)
condition|)
name|q
operator|=
name|imagpart
argument_list|(
name|lp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
name|q
operator|=
name|realpart
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|mkrealcon
argument_list|(
name|TYDREAL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"putcx1 of invalid opcode %d"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|opcode
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
specifier|register
name|struct
name|Addrblock
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|q
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
name|p
operator|->
name|opcode
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|opcode
operator|==
name|OPEQ
condition|?
name|OPAND
else|:
name|OPOR
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|fixexpr
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|struct
name|Addrblock
modifier|*
name|putch1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|struct
name|Addrblock
modifier|*
name|t
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|mktemp
argument_list|()
decl_stmt|,
modifier|*
name|putconst
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|putconst
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|TADDR
case|:
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
operator|++
operator|*
name|ncommap
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|t
operator|=
name|putcall
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
name|t
operator|=
name|mktemp
argument_list|(
name|TYCHAR
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|putcat
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
operator|||
name|p
operator|->
name|exprblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|!=
literal|1
operator|||
operator|!
name|INT
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"putch1: bad character conversion"
argument_list|)
expr_stmt|;
name|t
operator|=
name|mktemp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"putch1: invalid opcode %d"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
default|default:
name|fatali
argument_list|(
literal|"putch1: bad tag %d"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|putchop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYCHAR
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putcheq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|rightp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
name|putcat
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISONE
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|p
operator|->
name|rightp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2ASSIGN
argument_list|,
name|P2CHAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putx
argument_list|(
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_copy"
argument_list|,
name|p
operator|->
name|leftp
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putchcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISONE
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|p
operator|->
name|rightp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|ops2
index|[
name|p
operator|->
name|opcode
index|]
argument_list|,
name|P2CHAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|leftp
operator|=
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_cmp"
argument_list|,
name|p
operator|->
name|leftp
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|putcat
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
specifier|register
name|struct
name|Addrblock
modifier|*
name|lhs
decl_stmt|;
specifier|register
name|expptr
name|rhs
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|ncomma
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|lp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|ncat
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|lp
operator|=
name|mktmpn
argument_list|(
name|n
argument_list|,
name|TYLENG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|mktmpn
argument_list|(
name|n
argument_list|,
name|TYADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|putct1
argument_list|(
name|rhs
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|call4
argument_list|(
name|TYSUBR
argument_list|,
literal|"s_cat"
argument_list|,
name|lhs
argument_list|,
name|cp
argument_list|,
name|lp
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|ICON
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|ncat
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
return|return
operator|(
name|ncat
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|+
name|ncat
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putct1
parameter_list|(
name|q
parameter_list|,
name|lp
parameter_list|,
name|cp
parameter_list|,
name|ip
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|struct
name|Addrblock
modifier|*
name|lp
decl_stmt|,
decl|*
name|cp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|ncommap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|lp1
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
block|{
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|*
name|ip
operator|)
operator|++
expr_stmt|;
name|lp1
operator|=
name|cpexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|lp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZLENG
argument_list|)
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|cpexpr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|cp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZADDR
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|lp1
argument_list|,
name|cpexpr
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cp1
argument_list|,
name|addrof
argument_list|(
name|putch1
argument_list|(
name|q
argument_list|,
name|ncommap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|putaddr
parameter_list|(
name|p
parameter_list|,
name|indir
parameter_list|)
specifier|register
name|struct
name|Addrblock
modifier|*
name|p
decl_stmt|;
name|int
name|indir
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|funct
decl_stmt|;
name|ftnint
name|offset
decl_stmt|,
name|simoffset
argument_list|()
decl_stmt|;
name|expptr
name|offp
decl_stmt|,
name|shorten
argument_list|()
decl_stmt|;
if|if
condition|(
name|ISERROR
argument_list|(
name|p
argument_list|)
operator|||
name|ISERROR
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
name|funct
operator|=
operator|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
condition|?
name|P2FUNCT
operator|<<
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|offp
operator|=
operator|(
name|p
operator|->
name|memoffset
condition|?
name|cpexpr
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|FUDGEOFFSET
operator|!=
literal|1
operator|)
if|if
condition|(
name|offp
condition|)
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|ICON
argument_list|(
name|FUDGEOFFSET
argument_list|)
argument_list|,
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|simoffset
argument_list|(
operator|&
name|offp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
if|if
condition|(
name|offp
condition|)
if|if
condition|(
name|shortsubs
condition|)
name|offp
operator|=
name|shorten
argument_list|(
name|offp
argument_list|)
expr_stmt|;
else|else
name|offp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|offp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|offp
condition|)
name|offp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|p
operator|->
name|vstg
condition|)
block|{
case|case
name|STGAUTO
case|:
if|if
condition|(
name|indir
operator|&&
operator|!
name|offp
condition|)
block|{
name|p2oreg
argument_list|(
name|offset
argument_list|,
name|AUTOREG
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|indir
operator|&&
operator|!
name|offp
operator|&&
operator|!
name|offset
condition|)
block|{
name|p2reg
argument_list|(
name|AUTOREG
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
break|break;
block|}
name|p2reg
argument_list|(
name|AUTOREG
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|p2icon
argument_list|(
name|offset
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
block|}
else|else
name|p2icon
argument_list|(
name|offset
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
operator|&&
name|offset
condition|)
name|p2op
argument_list|(
name|P2PLUS
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2PLUS
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|P2INDIRECT
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGARG
case|:
name|p2oreg
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|ARGREG
argument_list|,
name|type2
operator||
name|P2PTR
operator||
name|funct
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
condition|)
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|p2icon
argument_list|(
name|offset
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
operator|&&
name|offset
condition|)
name|p2op
argument_list|(
name|P2PLUS
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
operator|||
name|offset
condition|)
name|p2op
argument_list|(
name|P2PLUS
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|P2INDIRECT
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGLENG
case|:
if|if
condition|(
name|indir
condition|)
block|{
name|p2oreg
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|ARGREG
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2reg
argument_list|(
name|ARGREG
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
name|p2icon
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2PLUS
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STGBSS
case|:
case|case
name|STGINIT
case|:
case|case
name|STGEXT
case|:
case|case
name|STGCOMMON
case|:
case|case
name|STGEQUIV
case|:
case|case
name|STGCONST
case|:
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|putmem
argument_list|(
name|p
argument_list|,
name|P2ICON
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2PLUS
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|P2INDIRECT
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
else|else
name|putmem
argument_list|(
name|p
argument_list|,
operator|(
name|indir
condition|?
name|P2NAME
else|:
name|P2ICON
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGREG
case|:
if|if
condition|(
name|indir
condition|)
name|p2reg
argument_list|(
name|p
operator|->
name|memno
argument_list|,
name|type2
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"attempt to take address of a register"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"putaddr: invalid vstg %d"
argument_list|,
name|p
operator|->
name|vstg
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putmem
parameter_list|(
name|p
parameter_list|,
name|class
parameter_list|,
name|offset
parameter_list|)
name|expptr
name|p
decl_stmt|;
name|int
name|class
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
block|{
name|int
name|type2
decl_stmt|;
name|int
name|funct
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|memname
argument_list|()
decl_stmt|;
name|funct
operator|=
operator|(
name|p
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPROC
condition|?
name|P2FUNCT
operator|<<
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|p
operator|->
name|headblock
operator|.
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPROC
condition|)
name|type2
operator||=
operator|(
name|P2FUNCT
operator|<<
literal|2
operator|)
expr_stmt|;
name|name
operator|=
name|memname
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|P2ICON
condition|)
block|{
name|p2triple
argument_list|(
name|P2ICON
argument_list|,
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
condition|)
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2triple
argument_list|(
name|P2NAME
argument_list|,
name|offset
operator|!=
literal|0
argument_list|,
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|struct
name|Addrblock
modifier|*
name|putcall
parameter_list|(
name|p
parameter_list|)
name|struct
name|Exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|chainp
name|arglist
decl_stmt|,
name|charsp
decl_stmt|,
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|first
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|t
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|q
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|fval
decl_stmt|;
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|ctype
decl_stmt|,
name|indir
decl_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
operator|=
name|p
operator|->
name|vtype
index|]
expr_stmt|;
name|charsp
operator|=
name|NULL
expr_stmt|;
name|indir
operator|=
operator|(
name|p
operator|->
name|opcode
operator|==
name|OPCCALL
operator|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
condition|)
block|{
name|arglist
operator|=
name|p
operator|->
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
if|if
condition|(
name|indir
condition|)
operator|++
name|n
expr_stmt|;
else|else
block|{
name|q
operator|=
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TCONST
condition|)
name|cp
operator|->
name|datap
operator|=
name|q
operator|=
name|putconst
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|charsp
operator|=
name|hookup
argument_list|(
name|charsp
argument_list|,
name|mkchain
argument_list|(
name|cpexpr
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
block|{
name|charsp
operator|=
name|hookup
argument_list|(
name|charsp
argument_list|,
name|mkchain
argument_list|(
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|n
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISICON
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
condition|)
block|{
name|fval
operator|=
name|mktemp
argument_list|(
name|TYCHAR
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"adjustable character function"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fval
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|fval
operator|=
name|NULL
expr_stmt|;
name|ctype
operator|=
operator|(
name|fval
condition|?
name|P2INT
else|:
name|type2
operator|)
expr_stmt|;
name|putaddr
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
condition|)
block|{
name|first
operator|=
name|NO
expr_stmt|;
name|putaddr
argument_list|(
name|cpexpr
argument_list|(
name|fval
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2LISTOP
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
operator|(
name|indir
operator|||
name|q
operator|->
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
name|putaddr
argument_list|(
name|q
argument_list|,
name|indir
operator|&&
name|q
operator|->
name|vtype
operator|!=
name|TYCHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
name|putchop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISERROR
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|indir
condition|)
name|putx
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|mktemp
argument_list|(
name|q
operator|->
name|vtype
argument_list|,
name|q
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|t
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
literal|1
argument_list|,
name|q
operator|->
name|vtype
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|NO
expr_stmt|;
else|else
name|p2op
argument_list|(
name|P2LISTOP
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
condition|)
name|frchain
argument_list|(
operator|&
name|arglist
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|charsp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2LISTOP
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
name|charsp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|n
operator|>
literal|0
condition|?
name|P2CALL
else|:
name|P2CALL0
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|fval
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putmnmx
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|qp
decl_stmt|;
name|chainp
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|op
operator|=
operator|(
name|p
operator|->
name|opcode
operator|==
name|OPMIN
condition|?
name|OPLT
else|:
name|OPGT
operator|)
expr_stmt|;
name|p0
operator|=
name|p
operator|->
name|leftp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sp
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPCOLON
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPQUEST
argument_list|,
name|mkexpr
argument_list|(
name|op
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qp
operator|=
name|fixexpr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|p0
operator|->
name|datap
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p0
operator|->
name|nextp
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|nextp
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|p1
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|nextp
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putx
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frtemp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|frtemp
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putcomma
parameter_list|(
name|n
parameter_list|,
name|type
parameter_list|,
name|indir
parameter_list|)
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|indir
decl_stmt|;
block|{
name|type
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|type
operator||=
name|P2PTR
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|p2op
argument_list|(
name|P2COMOP
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ftnint
name|simoffset
parameter_list|(
name|p0
parameter_list|)
name|expptr
modifier|*
name|p0
decl_stmt|;
block|{
name|ftnint
name|offset
decl_stmt|,
name|prod
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|*
name|p0
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPSTAR
condition|)
block|{
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
operator|&&
name|lp
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPPLUS
expr_stmt|;
name|lp
operator|->
name|opcode
operator|=
name|OPSTAR
expr_stmt|;
name|prod
operator|=
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|*
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|=
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|=
name|prod
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|offset
operator|+=
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
name|lp
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TCONST
condition|)
block|{
name|offset
operator|+=
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|p2op
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2icon
argument_list|(
argument|offset
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|ftnint
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|P2ICON
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2oreg
argument_list|(
argument|offset
argument_list|,
argument|reg
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|ftnint
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|P2OREG
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2reg
argument_list|(
argument|reg
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|P2REG
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2pi
argument_list|(
argument|s
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2pij
argument_list|(
argument|s
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2ps
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2pass
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2triple
argument_list|(
name|P2PASS
argument_list|,
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|FOUR
operator|-
literal|1
operator|)
operator|/
name|FOUR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|p2str
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
union|union
block|{
name|long
name|int
name|word
decl_stmt|;
name|char
name|str
index|[
name|FOUR
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|word
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|u
operator|.
name|str
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FOUR
condition|)
block|{
name|p2word
argument_list|(
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
name|u
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|p2word
argument_list|(
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2triple
argument_list|(
argument|op
argument_list|,
argument|var
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|var
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|word
decl_stmt|;
name|word
operator|=
name|op
operator||
operator|(
name|var
operator|<<
literal|8
operator|)
expr_stmt|;
name|word
operator||=
operator|(
operator|(
name|long
name|int
operator|)
name|type
operator|)
operator|<<
literal|16
expr_stmt|;
name|p2word
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2name
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|long
name|int
name|word
index|[
literal|2
index|]
decl_stmt|;
name|char
name|str
index|[
literal|8
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|word
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|word
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
operator|*
name|s
condition|;
operator|++
name|i
control|)
name|u
operator|.
name|str
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|p2word
argument_list|(
name|u
operator|.
name|word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|u
operator|.
name|word
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2word
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|long
name|int
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|p2bufp
operator|++
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|p2bufp
operator|>=
name|p2bufend
condition|)
name|p2flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|p2flush
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|p2bufp
operator|>
name|p2buff
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|textfile
argument_list|)
argument_list|,
name|p2buff
argument_list|,
operator|(
name|p2bufp
operator|-
name|p2buff
operator|)
operator|*
expr|sizeof
operator|(
name|long
name|int
operator|)
argument_list|)
expr_stmt|;
name|p2bufp
operator|=
name|p2buff
expr_stmt|;
block|}
end_block

end_unit

