begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"signal.h"
end_include

begin_include
include|#
directive|include
file|"h00vars.h"
end_include

begin_include
include|#
directive|include
file|"h01errs.h"
end_include

begin_comment
comment|/*  * Routine error is called from the interpreter when a runtime error occurs.  * Its argument is the internal number of the error which occurred.  * See Edata, Emake etc.  */
end_comment

begin_macro
name|error
argument_list|(
argument|errnum
argument_list|)
end_macro

begin_decl_stmt
name|long
name|errnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|i
decl_stmt|;
specifier|extern
name|long
name|errno
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|i
operator|=
name|errno
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|errno
operator|=
name|i
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errnum
condition|)
block|{
case|case
name|EINTR
case|:
break|break;
case|case
name|ECHR
case|:
name|fputs
argument_list|(
literal|"Argument to chr out of range\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EASSIGN
case|:
name|fputs
argument_list|(
literal|"Overflow during assignment conversion\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFIXADD
case|:
name|fputs
argument_list|(
literal|"Overflow in fixed point addition\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFLTADD
case|:
name|fputs
argument_list|(
literal|"Floating point addition out of range\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFIXSUB
case|:
name|fputs
argument_list|(
literal|"Overflow in fixed point subtraction\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFLTSUB
case|:
name|fputs
argument_list|(
literal|"Floating point subtraction out of range\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFIXMUL
case|:
name|fputs
argument_list|(
literal|"Overflow in fixed point multiplication\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFLTMUL
case|:
name|fputs
argument_list|(
literal|"Floating point multiplication out of range\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFIXDIV
case|:
name|fputs
argument_list|(
literal|"Fixed point division by zero\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFLTDIV
case|:
name|fputs
argument_list|(
literal|"Floating point division error\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EMODDIV
case|:
name|fputs
argument_list|(
literal|"Fixed point modulo by zero\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFIXNEG
case|:
name|fputs
argument_list|(
literal|"Overflow in fixed point negation\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESYSTEM
case|:
name|fputs
argument_list|(
literal|"Panic: Computational error in interpreter\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBUILTIN
case|:
name|fputs
argument_list|(
literal|"Overflow in builtin function\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EHALT
case|:
comment|/* 		nodump = 0; */
name|fputs
argument_list|(
literal|"Call to procedure halt\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENILPTR
case|:
name|fputs
argument_list|(
literal|"Reference through a nil pointer\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPASTEOF
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Tried to read past end of file\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EREADIT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Attempt to read, but open for writing\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EWRITEIT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Attempt to write, but open for reading\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECLOSE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Close failed\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELLIMIT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Line limit exceeded\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESQRT
case|:
name|fputs
argument_list|(
literal|"Negative argument to sqrt\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESTKNEMP
case|:
name|fputs
argument_list|(
literal|"Panic: stack not empty between statements\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESUBSCR
case|:
name|fputs
argument_list|(
literal|"Subscript out of range\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EREFINAF
case|:
name|fputs
argument_list|(
literal|"Reference to an inactive file\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EWRITE
case|:
name|fputs
argument_list|(
literal|"Could not write to "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOPEN
case|:
name|fputs
argument_list|(
literal|"Could not open "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECREATE
case|:
name|fputs
argument_list|(
literal|"Could not create "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|EREMOVE
case|:
name|fputs
argument_list|(
literal|"Could not remove "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESEEK
case|:
name|fputs
argument_list|(
literal|"Could not reset "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENAMESIZE
case|:
name|fputs
argument_list|(
literal|"File name too long\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELN
case|:
name|fputs
argument_list|(
literal|"Non-positive argument to ln\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBADOP
case|:
name|fputs
argument_list|(
literal|"Panic: bad op code\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBADINUM
case|:
name|fputs
argument_list|(
literal|"Bad data found on integer read\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EBADFNUM
case|:
name|fputs
argument_list|(
literal|"Bad data found on real read\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EGOTO
case|:
name|fputs
argument_list|(
literal|"Panic: active frame not found in goto\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECASE
case|:
name|fputs
argument_list|(
literal|"Label not found in case\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOUTOFMEM
case|:
name|fputs
argument_list|(
literal|"Ran out of memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETRASHHEAP
case|:
name|fputs
argument_list|(
literal|"Attempt to dispose of previously deallocated memory\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECTTOT
case|:
name|fputs
argument_list|(
literal|"Constructed set argument exceeds set bounds\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EARGV
case|:
name|fputs
argument_list|(
literal|"Argument to argv out of range\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPACK
case|:
name|fputs
argument_list|(
literal|"Bad i to pack(a,i,z)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EUNPACK
case|:
name|fputs
argument_list|(
literal|"Bad i to unpack(z,a,i)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERANGE
case|:
name|fputs
argument_list|(
literal|"Value out of range\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EASRT
case|:
name|fputs
argument_list|(
literal|"Assertion failed\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESTLIM
case|:
name|fputs
argument_list|(
literal|"Statement count limit exceeded\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESTKOVFLO
case|:
name|fputs
argument_list|(
literal|"Runtime stack overflow\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFRAMESIZE
case|:
name|fputs
argument_list|(
literal|"Compiler restricts declarations to 32768 bytes per block\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs
argument_list|(
literal|"Panic: unknown error\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nodump
operator|==
literal|0
condition|)
name|backtrace
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
name|psexit
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

