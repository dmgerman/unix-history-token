begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*    Mmail is a berkeley network internal command.    It is executed locally by the mwrite command,    and from a remote machine by the sendberkmail command.    Its purpose is to send mail to a user on this    machine using the system mail program.  Archaic Usage:     mmail [-commandsent -timesent] fromuser frommach touser  Correct Usage:    mmail [-c commandsent] [-e timesent] [-f fromaddress] [-t toaddress]  	[-h hopcnt] [-r rc] [-z]     The mwrite command uses all the options.    The sendberkmail command does not use the commandsend, timesent and rc     options.    Timesent is time in seconds since 1901 in decimal, as returned by time().    Frommach is a multi-character name, not a single letter.    Rc is the return code (exit code>>8) of the command.  Assumptions about the system mail command: 1. We assume there is an optional argument "-r" which can be added to mail.    Mail argument format (two choices):     (ROPTION) 		mail -f fromaddress toaddress 	which becomes mail from "fromaddress" instead of "network".     (ROPTION2) 		mail -r frommach fromuser toaddress 	which becomes mail from "fromach:fromuser" instead of "network".     ROPTION is to be preferred.  2. We assume that mail accepts the "-h hopcnt" flag, and passes it thru    unchanged to the sendberkmail program.  The hopcnt is incremented everytime    it passes thru mmail, so inifinite mail forwarding is detected.    Since both the from and to addresses cycle, it there is infinite looping    we simply mail to root to that effect and throw away the mail.      If this argument scheme looks flakey it is because I screwed up    in the argument design.  With the network now up to 10 machines,    I can't add another parameter to the internal commands of the network    like mmail and mwrite.  If I had used labeled parms instead of    positional parms, I would be able to add more options/info    without having to recompile all code...     exit codes: 	normally returns the exit code from the mail program 	returns 101 if unable to exec the mail program 	returns 102 if infinite mail forwarding loop is detected.     NUID is the value returned from getuid for "network" account. */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|pip
index|[
literal|2
index|]
decl_stmt|,
name|n
decl_stmt|,
name|ret
decl_stmt|,
name|i
decl_stmt|,
name|uid
decl_stmt|,
name|roption
init|=
literal|0
decl_stmt|,
name|hopcnt
init|=
literal|0
decl_stmt|,
name|pid
decl_stmt|;
name|char
modifier|*
name|sargv
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|cmdstr
init|=
name|NULL
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|timestr
decl_stmt|,
name|fromaddress
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|toaddress
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|src
index|[
literal|20
index|]
decl_stmt|,
name|snFrom
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|snto
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mchFrom
decl_stmt|,
name|mchto
decl_stmt|,
modifier|*
name|sn
decl_stmt|,
name|stemp
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|fisresponse
init|=
literal|0
decl_stmt|;
name|long
name|timesent
init|=
name|TIMEBASE
decl_stmt|,
name|el
decl_stmt|;
name|debugflg
operator|=
name|DBV
expr_stmt|;
name|src
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* parse old format positional parms */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|cmdstr
operator|=
name|argv
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|timesent
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fromaddress
argument_list|,
literal|"%s:%s"
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|fromaddress
argument_list|,
literal|"%s:%s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
comment|/* parse labeled parameters */
comment|/*  prob because of -cmd in arg1 and arg2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|strcpy
argument_list|(
name|fromaddress
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cmdstr
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|timesent
operator|=
name|atol
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hopcnt
operator|=
name|atoi
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|strcpy
argument_list|(
name|src
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|fisresponse
operator|++
expr_stmt|;
break|break;
comment|/* it is important there be no error if an unknown 		   flag is encountered */
block|}
block|}
name|mchFrom
operator|=
name|MchSFromAddr
argument_list|(
name|snFrom
argument_list|,
name|fromaddress
argument_list|)
expr_stmt|;
comment|/* compute time send */
name|timestr
operator|=
name|ctime
argument_list|(
operator|&
name|timesent
argument_list|)
expr_stmt|;
name|timestr
index|[
name|strlen
argument_list|(
name|timestr
argument_list|)
operator|-
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|el
operator|=
name|gettime
argument_list|()
operator|-
name|timesent
expr_stmt|;
ifdef|#
directive|ifdef
name|ROPTION
comment|/* only use roption if super-user or "network" */
comment|/* 	uid = getuid(); 	uid = uidmask(uid); 	if(uid == SUPERUSER || uid == NUID)roption++; */
comment|/* or if mail is to the same user who is sending it */
comment|/* 	sn = SnCurrent(); 	if(sn != NULL){ 		stemp[0] = 0; 		mchfrom = MchSFromAddr(stemp,fromaddress); 		if(strcmp(stemp,????) == 0)roption++; 	} 	uid = geteuid(); 	uid = uidmask(uid); 	if(uid == SUPERUSER || uid == NUID)roption++; */
name|roption
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ROPTION2
comment|/* only use roption if super-user or "network" */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|uid
operator|=
name|uidmask
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
name|SUPERUSER
operator|||
name|uid
operator|==
name|NUID
condition|)
name|roption
operator|++
expr_stmt|;
comment|/* or if mail is to the same user who is sending it */
comment|/* disabled since mail must accept this  and it does not now */
comment|/* if(strcmp(SnCurrent(),argv[3]) == 0)roption++; */
name|uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|uid
operator|=
name|uidmask
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
name|SUPERUSER
operator|||
name|uid
operator|==
name|NUID
condition|)
name|roption
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* check the hopcnt */
name|hopcnt
operator|++
expr_stmt|;
if|if
condition|(
name|hopcnt
operator|>
name|MAXHOPS
condition|)
name|hopcnterr
argument_list|(
name|toaddress
argument_list|,
name|hopcnt
argument_list|)
expr_stmt|;
comment|/* analyze the dest, if local, strip off mach name, otherwise ok */
name|mchto
operator|=
name|MchSFromAddr
argument_list|(
name|snto
argument_list|,
name|toaddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|mchto
operator|==
name|local
condition|)
name|strcpy
argument_list|(
name|toaddress
argument_list|,
name|snto
argument_list|)
expr_stmt|;
comment|/* add the hopcnt here */
if|if
condition|(
name|roption
condition|)
block|{
name|sargv
index|[
literal|1
index|]
operator|=
literal|"-r"
expr_stmt|;
ifdef|#
directive|ifdef
name|ROPTION2
name|sargv
index|[
literal|2
index|]
operator|=
name|longname
argument_list|(
name|mchFrom
argument_list|)
expr_stmt|;
name|sargv
index|[
literal|3
index|]
operator|=
name|snFrom
expr_stmt|;
name|sargv
index|[
literal|4
index|]
operator|=
name|toaddress
expr_stmt|;
name|sargv
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ROPTION
name|sargv
index|[
literal|2
index|]
operator|=
name|fromaddress
expr_stmt|;
name|sargv
index|[
literal|3
index|]
operator|=
name|toaddress
expr_stmt|;
name|sargv
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|sargv
index|[
literal|1
index|]
operator|=
name|toaddress
expr_stmt|;
name|sargv
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sargv
index|[
literal|0
index|]
operator|=
literal|"mail"
expr_stmt|;
name|pipe
argument_list|(
name|pip
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* by convention, SYSMAIL1 may forward this mail 		   and response messages shouldn't be forwarded */
if|if
condition|(
operator|!
name|fisresponse
condition|)
name|execv
argument_list|(
name|SYSMAIL1
argument_list|,
name|sargv
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|SYSMAIL2
argument_list|,
name|sargv
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|SYSMAIL3
argument_list|,
name|sargv
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|SYSMAIL4
argument_list|,
name|sargv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|101
argument_list|)
expr_stmt|;
comment|/* mexecv is not used because it gives a diagnostic */
block|}
name|close
argument_list|(
name|pip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|roption
condition|)
name|printf
argument_list|(
literal|"(from %s)\n"
argument_list|,
name|fromaddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdstr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|stemp
argument_list|,
literal|", R: %s"
argument_list|,
name|src
argument_list|)
expr_stmt|;
else|else
name|stemp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"(command: %s%s, sent %s, took %s)\n"
argument_list|,
name|cmdstr
argument_list|,
name|stemp
argument_list|,
name|timestr
argument_list|,
name|comptime
argument_list|(
name|el
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|wait
argument_list|(
operator|&
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Non-zero return code (%d) from the mail program.\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 	hopcnterr()  	there appears to be infinite mail forwarding - 	as detected by the hop count.  Mail to root and give up. 	Both the from and to addresses are cycling, so mail  	can't be sent there. */
end_comment

begin_macro
name|hopcnterr
argument_list|(
argument|toaddress
argument_list|,
argument|hopcnt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|toaddress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hopcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdstr
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|rcode
decl_stmt|;
name|sprintf
argument_list|(
name|cmdstr
argument_list|,
literal|"echo infinite mail loop for %s hops %d | mail root"
argument_list|,
name|toaddress
argument_list|,
name|hopcnt
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|system
argument_list|(
name|cmdstr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|102
argument_list|)
expr_stmt|;
comment|/*UNREACHED*/
block|}
end_block

end_unit

