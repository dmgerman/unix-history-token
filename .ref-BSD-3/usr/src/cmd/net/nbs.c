begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* file nbs.c    This file has the necessary procedures to use the NBS algorithm    to encrypt and decrypt strings of arbitrary length.     Basically  		ciphertext = nbsencrypt(cleartext,secretkey,ciphertext);     yields a string ciphertext from string cleartext using    the secret string secretkey.    Then  		cleartext = nbsdecrypt(ciphertext,secretkey,cleartext); 		    yields the original string cleartext IF the string secretkey    is the same for both calls.    The third parameter is filled with the result of the call-    it must be (11/8)*size(firstarg).    The first and third areguments must be different.    The cleartext must be ASCII - the top eighth bit is ignored,    so binary data won't work.    The plaintext is broken into 8 character sections,    encrypted, and concatenated separated by $'s to make the ciphertext.    The first 8 letter section uses the secretkey, subsequent    sections use the cleartext of the previous section as    the key.    Thus the ciphertext depends on itself, except for    the first section, which depends on the key.    This means that sections of the ciphertext, except the first,    may not stand alone.    Only the first 8 characters of the key matter. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|deblknot
argument_list|()
decl_stmt|,
modifier|*
name|deblkclr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|nbs8decrypt
argument_list|()
decl_stmt|,
modifier|*
name|nbs8encrypt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|E
index|[
literal|48
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|e
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|nbsencrypt
parameter_list|(
name|str
parameter_list|,
name|key
parameter_list|,
name|result
parameter_list|)
name|char
modifier|*
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|key
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|,
name|oldbuf
index|[
literal|20
index|]
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|oldbuf
argument_list|,
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
name|buf
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
operator|&&
operator|*
name|str
condition|;
name|j
operator|++
control|)
name|buf
index|[
name|j
index|]
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|nbs8encrypt
argument_list|(
name|buf
argument_list|,
name|oldbuf
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oldbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|nbsdecrypt
parameter_list|(
name|cpt
parameter_list|,
name|key
parameter_list|,
name|result
parameter_list|)
name|char
modifier|*
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|cpt
decl_stmt|,
decl|*
name|key
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|,
name|oldbuf
index|[
literal|20
index|]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|oldbuf
argument_list|,
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cpt
condition|)
block|{
for|for
control|(
name|s
operator|=
name|cpt
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'$'
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|oldbuf
argument_list|,
name|nbs8decrypt
argument_list|(
name|cpt
argument_list|,
name|oldbuf
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|oldbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|cpt
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* all other calls are private */
end_comment

begin_comment
comment|/* testing(){ 	static char stbuf[BUFSIZ],res[BUFSIZ]; 	register char *s; 	char str[BUFSIZ]; 	setbuf(stdout,stbuf); 	while(!feof(stdin)){ 		fprintf(stderr,"String:\n"); 		fgets(str,BUFSIZ,stdin); 		if(feof(stdin))break; 		strcat(str,"\n"); 		s = nbsencrypt(str,"hellothere",res); 		fprintf(stderr,"encrypted:\n%s\n",s); 		fprintf(stderr,"decrypted:\n"); 		printf("%s",nbsdecrypt(s,"hellothere",str)); 		fprintf(stderr,"\n"); 		} 	} */
end_comment

begin_comment
comment|/* 	To encrypt: 	The first level of call splits the input strings into strings 	no longer than 8 characters, for encryption. 	Then the encryption of 8 characters breaks all but the top bit 	of each character into a 64-character block, each character 	with 1 or 0 corresponding to binary. 	The key is set likewise. 	The encrypted form is then converted, 6 bits at a time, 	into an ASCII string.  	To decrypt: 	We take the result of the encryption, 6 significant bits 	per character, and convert it to the block(64-char) fmt. 	This is decrypted by running the nbs algorithm in reverse, 	and transformed back into 7bit ASCII.  	The subroutines to do ASCII blocking and deblocking 	are .....clr and the funny 6-bit code are .....not.  */
end_comment

begin_function
name|char
modifier|*
name|nbs8encrypt
parameter_list|(
name|str
parameter_list|,
name|key
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|key
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|keyblk
index|[
literal|100
index|]
decl_stmt|,
name|blk
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|enblkclr
argument_list|(
name|keyblk
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|nbssetkey
argument_list|(
name|keyblk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|48
condition|;
name|i
operator|++
control|)
name|E
index|[
name|i
index|]
operator|=
name|e
index|[
name|i
index|]
expr_stmt|;
name|enblkclr
argument_list|(
name|blk
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|blkencrypt
argument_list|(
name|blk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* forward dir */
return|return
operator|(
name|deblknot
argument_list|(
name|blk
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|nbs8decrypt
parameter_list|(
name|crp
parameter_list|,
name|key
parameter_list|)
specifier|register
name|char
modifier|*
name|crp
decl_stmt|,
decl|*
name|key
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|keyblk
index|[
literal|100
index|]
decl_stmt|,
name|blk
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|enblkclr
argument_list|(
name|keyblk
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|nbssetkey
argument_list|(
name|keyblk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|48
condition|;
name|i
operator|++
control|)
name|E
index|[
name|i
index|]
operator|=
name|e
index|[
name|i
index|]
expr_stmt|;
name|enblknot
argument_list|(
name|blk
argument_list|,
name|crp
argument_list|)
expr_stmt|;
name|blkencrypt
argument_list|(
name|blk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* backward dir */
return|return
operator|(
name|deblkclr
argument_list|(
name|blk
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|enblkclr
argument_list|(
argument|blk
argument_list|,
argument|str
argument_list|)
end_macro

begin_comment
comment|/* ignores top bit of chars in string str */
end_comment

begin_decl_stmt
name|char
modifier|*
name|blk
decl_stmt|,
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|70
condition|;
name|i
operator|++
control|)
name|blk
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|str
operator|)
operator|&&
name|i
operator|<
literal|64
condition|;
name|str
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
name|blk
index|[
name|i
index|]
operator|=
operator|(
name|c
operator|>>
operator|(
literal|6
operator|-
name|j
operator|)
operator|)
operator|&
literal|01
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|deblkclr
parameter_list|(
name|blk
parameter_list|)
name|char
modifier|*
name|blk
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|static
name|char
name|iobuf
index|[
literal|30
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|<<=
literal|1
expr_stmt|;
name|c
operator||=
name|blk
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
expr_stmt|;
block|}
name|iobuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|iobuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iobuf
operator|)
return|;
block|}
end_function

begin_macro
name|enblknot
argument_list|(
argument|blk
argument_list|,
argument|crp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|crp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|70
condition|;
name|i
operator|++
control|)
name|blk
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|crp
operator|)
operator|&&
name|i
operator|<
literal|64
condition|;
name|crp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|>
literal|'Z'
condition|)
name|c
operator|-=
literal|6
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'9'
condition|)
name|c
operator|-=
literal|7
expr_stmt|;
name|c
operator|-=
literal|'.'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
name|blk
index|[
name|i
index|]
operator|=
operator|(
name|c
operator|>>
operator|(
literal|5
operator|-
name|j
operator|)
operator|)
operator|&
literal|01
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|deblknot
parameter_list|(
name|blk
parameter_list|)
name|char
modifier|*
name|blk
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|static
name|char
name|iobuf
index|[
literal|30
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|<<=
literal|1
expr_stmt|;
name|c
operator||=
name|blk
index|[
literal|6
operator|*
name|i
operator|+
name|j
index|]
expr_stmt|;
block|}
name|c
operator|+=
literal|'.'
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'9'
condition|)
name|c
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'Z'
condition|)
name|c
operator|+=
literal|6
expr_stmt|;
name|iobuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|iobuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iobuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This program implements the  * Proposed Federal Information Processing  *  Data Encryption Standard.  * See Federal Register, March 17, 1975 (40FR12134)  */
end_comment

begin_comment
comment|/*  * Initial permutation,  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|IP
index|[]
init|=
block|{
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|64
block|,
literal|56
block|,
literal|48
block|,
literal|40
block|,
literal|32
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Final permutation, FP = IP^(-1)  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|FP
index|[]
init|=
block|{
literal|40
block|,
literal|8
block|,
literal|48
block|,
literal|16
block|,
literal|56
block|,
literal|24
block|,
literal|64
block|,
literal|32
block|,
literal|39
block|,
literal|7
block|,
literal|47
block|,
literal|15
block|,
literal|55
block|,
literal|23
block|,
literal|63
block|,
literal|31
block|,
literal|38
block|,
literal|6
block|,
literal|46
block|,
literal|14
block|,
literal|54
block|,
literal|22
block|,
literal|62
block|,
literal|30
block|,
literal|37
block|,
literal|5
block|,
literal|45
block|,
literal|13
block|,
literal|53
block|,
literal|21
block|,
literal|61
block|,
literal|29
block|,
literal|36
block|,
literal|4
block|,
literal|44
block|,
literal|12
block|,
literal|52
block|,
literal|20
block|,
literal|60
block|,
literal|28
block|,
literal|35
block|,
literal|3
block|,
literal|43
block|,
literal|11
block|,
literal|51
block|,
literal|19
block|,
literal|59
block|,
literal|27
block|,
literal|34
block|,
literal|2
block|,
literal|42
block|,
literal|10
block|,
literal|50
block|,
literal|18
block|,
literal|58
block|,
literal|26
block|,
literal|33
block|,
literal|1
block|,
literal|41
block|,
literal|9
block|,
literal|49
block|,
literal|17
block|,
literal|57
block|,
literal|25
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Permuted-choice 1 from the key bits  * to yield C and D.  * Note that bits 8,16... are left out:  * They are intended for a parity check.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|PC1_C
index|[]
init|=
block|{
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|PC1_D
index|[]
init|=
block|{
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Sequence of shifts used for the key schedule. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|shifts
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Permuted-choice 2, to pick out the bits from  * the CD array that generate the key schedule.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|PC2_C
index|[]
init|=
block|{
literal|14
block|,
literal|17
block|,
literal|11
block|,
literal|24
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|28
block|,
literal|15
block|,
literal|6
block|,
literal|21
block|,
literal|10
block|,
literal|23
block|,
literal|19
block|,
literal|12
block|,
literal|4
block|,
literal|26
block|,
literal|8
block|,
literal|16
block|,
literal|7
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|PC2_D
index|[]
init|=
block|{
literal|41
block|,
literal|52
block|,
literal|31
block|,
literal|37
block|,
literal|47
block|,
literal|55
block|,
literal|30
block|,
literal|40
block|,
literal|51
block|,
literal|45
block|,
literal|33
block|,
literal|48
block|,
literal|44
block|,
literal|49
block|,
literal|39
block|,
literal|56
block|,
literal|34
block|,
literal|53
block|,
literal|46
block|,
literal|42
block|,
literal|50
block|,
literal|36
block|,
literal|29
block|,
literal|32
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The C and D arrays used to calculate the key schedule.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|C
index|[
literal|28
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|D
index|[
literal|28
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The key schedule.  * Generated from the key.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|KS
index|[
literal|16
index|]
index|[
literal|48
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up the key schedule from the key.  */
end_comment

begin_macro
name|nbssetkey
argument_list|(
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|k
expr_stmt|;
name|int
name|t
decl_stmt|;
comment|/* 	 * First, generate C and D by permuting 	 * the key.  The low order bit of each 	 * 8-bit char is not used, so C and D are only 28 	 * bits apiece. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|28
condition|;
name|i
operator|++
control|)
block|{
name|C
index|[
name|i
index|]
operator|=
name|key
index|[
name|PC1_C
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|D
index|[
name|i
index|]
operator|=
name|key
index|[
name|PC1_D
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* 	 * To generate Ki, rotate C and D according 	 * to schedule and pick up a permutation 	 * using PC2. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * rotate. 		 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|shifts
index|[
name|i
index|]
condition|;
name|k
operator|++
control|)
block|{
name|t
operator|=
name|C
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|28
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|C
index|[
name|j
index|]
operator|=
name|C
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|C
index|[
literal|27
index|]
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|D
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|28
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|D
index|[
name|j
index|]
operator|=
name|D
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|D
index|[
literal|27
index|]
operator|=
name|t
expr_stmt|;
block|}
comment|/* 		 * get Ki. Note C and D are concatenated. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|24
condition|;
name|j
operator|++
control|)
block|{
name|KS
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|C
index|[
name|PC2_C
index|[
name|j
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|KS
index|[
name|i
index|]
index|[
name|j
operator|+
literal|24
index|]
operator|=
name|D
index|[
name|PC2_D
index|[
name|j
index|]
operator|-
literal|28
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * The E bit-selection table.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|e
index|[]
init|=
block|{
literal|32
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The 8 selection functions.  * For some reason, they give a 0-origin  * index, unlike everything else.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|S
index|[
literal|8
index|]
index|[
literal|64
index|]
init|=
block|{
literal|14
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|2
block|,
literal|15
block|,
literal|11
block|,
literal|8
block|,
literal|3
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|5
block|,
literal|9
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|15
block|,
literal|7
block|,
literal|4
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|11
block|,
literal|9
block|,
literal|5
block|,
literal|3
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|14
block|,
literal|8
block|,
literal|13
block|,
literal|6
block|,
literal|2
block|,
literal|11
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|12
block|,
literal|8
block|,
literal|2
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|3
block|,
literal|14
block|,
literal|10
block|,
literal|0
block|,
literal|6
block|,
literal|13
block|,
literal|15
block|,
literal|1
block|,
literal|8
block|,
literal|14
block|,
literal|6
block|,
literal|11
block|,
literal|3
block|,
literal|4
block|,
literal|9
block|,
literal|7
block|,
literal|2
block|,
literal|13
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|10
block|,
literal|3
block|,
literal|13
block|,
literal|4
block|,
literal|7
block|,
literal|15
block|,
literal|2
block|,
literal|8
block|,
literal|14
block|,
literal|12
block|,
literal|0
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|11
block|,
literal|5
block|,
literal|0
block|,
literal|14
block|,
literal|7
block|,
literal|11
block|,
literal|10
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|8
block|,
literal|12
block|,
literal|6
block|,
literal|9
block|,
literal|3
block|,
literal|2
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|1
block|,
literal|3
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|14
block|,
literal|9
block|,
literal|10
block|,
literal|0
block|,
literal|9
block|,
literal|14
block|,
literal|6
block|,
literal|3
block|,
literal|15
block|,
literal|5
block|,
literal|1
block|,
literal|13
block|,
literal|12
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|2
block|,
literal|8
block|,
literal|13
block|,
literal|7
block|,
literal|0
block|,
literal|9
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|14
block|,
literal|12
block|,
literal|11
block|,
literal|15
block|,
literal|1
block|,
literal|13
block|,
literal|6
block|,
literal|4
block|,
literal|9
block|,
literal|8
block|,
literal|15
block|,
literal|3
block|,
literal|0
block|,
literal|11
block|,
literal|1
block|,
literal|2
block|,
literal|12
block|,
literal|5
block|,
literal|10
block|,
literal|14
block|,
literal|7
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|8
block|,
literal|7
block|,
literal|4
block|,
literal|15
block|,
literal|14
block|,
literal|3
block|,
literal|11
block|,
literal|5
block|,
literal|2
block|,
literal|12
block|,
literal|7
block|,
literal|13
block|,
literal|14
block|,
literal|3
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|10
block|,
literal|1
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|4
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|11
block|,
literal|5
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|2
block|,
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|0
block|,
literal|12
block|,
literal|11
block|,
literal|7
block|,
literal|13
block|,
literal|15
block|,
literal|1
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|3
block|,
literal|15
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|8
block|,
literal|9
block|,
literal|4
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|7
block|,
literal|2
block|,
literal|14
block|,
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|1
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|6
block|,
literal|8
block|,
literal|5
block|,
literal|3
block|,
literal|15
block|,
literal|13
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|14
block|,
literal|11
block|,
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|10
block|,
literal|3
block|,
literal|9
block|,
literal|8
block|,
literal|6
block|,
literal|4
block|,
literal|2
block|,
literal|1
block|,
literal|11
block|,
literal|10
block|,
literal|13
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|9
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|0
block|,
literal|14
block|,
literal|11
block|,
literal|8
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|9
block|,
literal|10
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|15
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|13
block|,
literal|3
block|,
literal|4
block|,
literal|14
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|10
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|14
block|,
literal|0
block|,
literal|11
block|,
literal|3
block|,
literal|8
block|,
literal|9
block|,
literal|14
block|,
literal|15
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|0
block|,
literal|4
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|11
block|,
literal|6
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|15
block|,
literal|10
block|,
literal|11
block|,
literal|14
block|,
literal|1
block|,
literal|7
block|,
literal|6
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
literal|4
block|,
literal|11
block|,
literal|2
block|,
literal|14
block|,
literal|15
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
literal|3
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|5
block|,
literal|10
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|0
block|,
literal|11
block|,
literal|7
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|3
block|,
literal|5
block|,
literal|12
block|,
literal|2
block|,
literal|15
block|,
literal|8
block|,
literal|6
block|,
literal|1
block|,
literal|4
block|,
literal|11
block|,
literal|13
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|14
block|,
literal|10
block|,
literal|15
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|5
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|11
block|,
literal|13
block|,
literal|8
block|,
literal|1
block|,
literal|4
block|,
literal|10
block|,
literal|7
block|,
literal|9
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|14
block|,
literal|2
block|,
literal|3
block|,
literal|12
block|,
literal|13
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|6
block|,
literal|15
block|,
literal|11
block|,
literal|1
block|,
literal|10
block|,
literal|9
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|0
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|3
block|,
literal|7
block|,
literal|4
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|2
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|1
block|,
literal|9
block|,
literal|12
block|,
literal|14
block|,
literal|2
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|15
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|14
block|,
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|8
block|,
literal|13
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * P is a permutation on the selected combination  * of the current L and key.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|P
index|[]
init|=
block|{
literal|16
block|,
literal|7
block|,
literal|20
block|,
literal|21
block|,
literal|29
block|,
literal|12
block|,
literal|28
block|,
literal|17
block|,
literal|1
block|,
literal|15
block|,
literal|23
block|,
literal|26
block|,
literal|5
block|,
literal|18
block|,
literal|31
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|24
block|,
literal|14
block|,
literal|32
block|,
literal|27
block|,
literal|3
block|,
literal|9
block|,
literal|19
block|,
literal|13
block|,
literal|30
block|,
literal|6
block|,
literal|22
block|,
literal|11
block|,
literal|4
block|,
literal|25
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The current block, divided into 2 halves.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|L
index|[
literal|32
index|]
decl_stmt|,
name|R
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tempL
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|f
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The combination of the key and the input, before selection.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|preS
index|[
literal|48
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The payoff: encrypt a block.  */
end_comment

begin_macro
name|blkencrypt
argument_list|(
argument|block
argument_list|,
argument|edflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|block
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|ii
decl_stmt|;
specifier|register
name|t
operator|,
name|j
operator|,
name|k
expr_stmt|;
comment|/* 	 * First, permute the bits in the input 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|L
index|[
name|j
index|]
operator|=
name|block
index|[
name|IP
index|[
name|j
index|]
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 	 * Perform an encryption operation 16 times. 	 */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|16
condition|;
name|ii
operator|++
control|)
block|{
comment|/* 		 * Set direction 		 */
if|if
condition|(
name|edflag
condition|)
name|i
operator|=
literal|15
operator|-
name|ii
expr_stmt|;
else|else
name|i
operator|=
name|ii
expr_stmt|;
comment|/* 		 * Save the R array, 		 * which will be the new L. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|tempL
index|[
name|j
index|]
operator|=
name|R
index|[
name|j
index|]
expr_stmt|;
comment|/* 		 * Expand R to 48 bits using the E selector; 		 * exclusive-or with the current key bits. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|48
condition|;
name|j
operator|++
control|)
name|preS
index|[
name|j
index|]
operator|=
name|R
index|[
name|E
index|[
name|j
index|]
operator|-
literal|1
index|]
operator|^
name|KS
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
comment|/* 		 * The pre-select bits are now considered 		 * in 8 groups of 6 bits each. 		 * The 8 selection functions map these 		 * 6-bit quantities into 4-bit quantities 		 * and the results permuted 		 * to make an f(R, K). 		 * The indexing into the selection functions 		 * is peculiar; it could be simplified by 		 * rewriting the tables. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
literal|6
operator|*
name|j
expr_stmt|;
name|k
operator|=
name|S
index|[
name|j
index|]
index|[
operator|(
name|preS
index|[
name|t
operator|+
literal|0
index|]
operator|<<
literal|5
operator|)
operator|+
operator|(
name|preS
index|[
name|t
operator|+
literal|1
index|]
operator|<<
literal|3
operator|)
operator|+
operator|(
name|preS
index|[
name|t
operator|+
literal|2
index|]
operator|<<
literal|2
operator|)
operator|+
operator|(
name|preS
index|[
name|t
operator|+
literal|3
index|]
operator|<<
literal|1
operator|)
operator|+
operator|(
name|preS
index|[
name|t
operator|+
literal|4
index|]
operator|<<
literal|0
operator|)
operator|+
operator|(
name|preS
index|[
name|t
operator|+
literal|5
index|]
operator|<<
literal|4
operator|)
index|]
expr_stmt|;
name|t
operator|=
literal|4
operator|*
name|j
expr_stmt|;
name|f
index|[
name|t
operator|+
literal|0
index|]
operator|=
operator|(
name|k
operator|>>
literal|3
operator|)
operator|&
literal|01
expr_stmt|;
name|f
index|[
name|t
operator|+
literal|1
index|]
operator|=
operator|(
name|k
operator|>>
literal|2
operator|)
operator|&
literal|01
expr_stmt|;
name|f
index|[
name|t
operator|+
literal|2
index|]
operator|=
operator|(
name|k
operator|>>
literal|1
operator|)
operator|&
literal|01
expr_stmt|;
name|f
index|[
name|t
operator|+
literal|3
index|]
operator|=
operator|(
name|k
operator|>>
literal|0
operator|)
operator|&
literal|01
expr_stmt|;
block|}
comment|/* 		 * The new R is L ^ f(R, K). 		 * The f here has to be permuted first, though. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|R
index|[
name|j
index|]
operator|=
name|L
index|[
name|j
index|]
operator|^
name|f
index|[
name|P
index|[
name|j
index|]
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 		 * Finally, the new L (the original R) 		 * is copied back. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|L
index|[
name|j
index|]
operator|=
name|tempL
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* 	 * The output L and R are reversed. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
name|L
index|[
name|j
index|]
expr_stmt|;
name|L
index|[
name|j
index|]
operator|=
name|R
index|[
name|j
index|]
expr_stmt|;
name|R
index|[
name|j
index|]
operator|=
name|t
expr_stmt|;
block|}
comment|/* 	 * The final output 	 * gets the inverse permutation of the very original. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|block
index|[
name|j
index|]
operator|=
name|L
index|[
name|FP
index|[
name|j
index|]
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_block

end_unit

