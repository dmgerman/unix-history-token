begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CORY
end_ifdef

begin_define
define|#
directive|define
name|MBIT
value|RAW
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|MBIT
value|CBREAK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TBUFSIZ
value|1024
end_define

begin_define
define|#
directive|define
name|LINSIZ
value|256
end_define

begin_define
define|#
directive|define
name|ctrl
parameter_list|(
name|letter
parameter_list|)
value|('letter'& 077)
end_define

begin_define
define|#
directive|define
name|RUBOUT
value|'\177'
end_define

begin_define
define|#
directive|define
name|ESC
value|'\033'
end_define

begin_define
define|#
directive|define
name|QUIT
value|'\034'
end_define

begin_decl_stmt
name|struct
name|sgttyb
name|otty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fnum
decl_stmt|,
name|no_intty
decl_stmt|,
name|no_tty
decl_stmt|,
name|slow_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dum_opt
decl_stmt|,
name|dlines
decl_stmt|,
name|onquit
argument_list|()
decl_stmt|,
name|end_it
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop_opt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|promptlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|startup
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|firstf
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|notell
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inwait
decl_stmt|,
name|pause
decl_stmt|,
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|within
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we are within a file, 			false if we are between files */
end_comment

begin_decl_stmt
name|int
name|hard
decl_stmt|,
name|dumb
decl_stmt|,
name|noscroll
decl_stmt|,
name|hardtabs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|fnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|shell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|restore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdout buffer */
end_comment

begin_decl_stmt
name|char
name|Line
index|[
name|LINSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Lpp
init|=
literal|24
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lines per page */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Clear
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clear screen */
end_comment

begin_decl_stmt
name|char
modifier|*
name|eraseln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* erase line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Senter
decl_stmt|,
modifier|*
name|Sexit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enter and exit standout mode */
end_comment

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|Mcol
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of columns */
end_comment

begin_decl_stmt
name|int
name|Wrap
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if automargins */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pad character */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|left
decl_stmt|;
name|int
name|prnames
init|=
literal|0
decl_stmt|;
name|int
name|initopt
init|=
literal|0
decl_stmt|;
name|int
name|srchopt
init|=
literal|0
decl_stmt|;
name|int
name|initline
decl_stmt|;
name|char
name|buf
index|[
name|TBUFSIZ
index|]
decl_stmt|;
name|char
name|clearbuf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|initbuf
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|clearptr
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|checkf
parameter_list|()
function_decl|;
name|nfiles
operator|=
name|argc
expr_stmt|;
name|fnames
operator|=
name|argv
expr_stmt|;
comment|/* Put terminal setup stuff in separate procedure ?? (From here...) */
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|no_tty
operator|=
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|otty
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tgetent
argument_list|(
name|buf
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|dumb
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|Lpp
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
name|tgetflag
argument_list|(
literal|"hc"
argument_list|)
condition|)
block|{
name|hard
operator|++
expr_stmt|;
comment|/* Hard copy terminal */
name|Lpp
operator|=
literal|24
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hard
operator|&&
name|tgetflag
argument_list|(
literal|"ns"
argument_list|)
condition|)
name|noscroll
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|Mcol
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Mcol
operator|=
literal|80
expr_stmt|;
name|Wrap
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|clearptr
operator|=
name|clearbuf
expr_stmt|;
name|eraseln
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Clear
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Senter
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Sexit
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|PC
operator|=
operator|*
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|"/bin/sh"
expr_stmt|;
block|}
name|no_intty
operator|=
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|gtty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|otty
operator|.
name|sg_ospeed
expr_stmt|;
name|slow_tty
operator|=
name|ospeed
operator|<
name|B1200
expr_stmt|;
name|hardtabs
operator|=
operator|!
operator|(
name|otty
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|CBREAK
operator|||
operator|!
name|slow_tty
condition|)
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
block|}
comment|/* ... until here or so */
while|while
condition|(
operator|--
name|nfiles
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|(
operator|*
operator|++
name|fnames
operator|)
index|[
literal|0
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|s
operator|=
name|fnames
index|[
literal|0
index|]
operator|+
literal|1
operator|,
name|dlines
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|dlines
operator|=
name|dlines
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'d'
condition|)
name|dum_opt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'l'
condition|)
name|stop_opt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|s
operator|=
operator|*
name|fnames
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'/'
condition|)
block|{
name|srchopt
operator|++
expr_stmt|;
for|for
control|(
operator|++
name|s
operator|,
name|p
operator|=
name|initbuf
init|;
name|p
operator|<
name|initbuf
operator|+
literal|79
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|initopt
operator|++
expr_stmt|;
for|for
control|(
name|initline
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|initline
operator|=
name|initline
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|--
name|initline
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|dlines
operator|==
literal|0
condition|)
name|dlines
operator|=
name|Lpp
operator|-
literal|2
expr_stmt|;
name|left
operator|=
name|dlines
expr_stmt|;
if|if
condition|(
name|nfiles
operator|>
literal|1
condition|)
name|prnames
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|no_intty
operator|&&
name|nfiles
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"Usage: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" [-dn] name1 name2 ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|no_tty
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|end_it
argument_list|)
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|no_intty
condition|)
block|{
if|if
condition|(
name|no_tty
condition|)
name|copy_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|srchopt
condition|)
name|search
argument_list|(
name|initbuf
argument_list|,
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initopt
condition|)
name|skiplns
argument_list|(
name|initline
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|stdin
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
name|end_it
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|fnum
operator|<
name|nfiles
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|checkf
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|firstf
condition|)
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstf
condition|)
block|{
name|firstf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|srchopt
condition|)
name|search
argument_list|(
name|initbuf
argument_list|,
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initopt
condition|)
name|skiplns
argument_list|(
name|initline
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fnum
operator|<
name|nfiles
operator|&&
operator|!
name|no_tty
condition|)
block|{
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|left
operator|=
name|command
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prnames
condition|)
block|{
name|pr
argument_list|(
literal|"::::::::::::::"
argument_list|)
expr_stmt|;
if|if
condition|(
name|promptlen
operator|>
literal|14
condition|)
name|erase
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"\n::::::::::::::\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|Lpp
operator|-
literal|4
condition|)
name|left
operator|=
name|Lpp
operator|-
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|no_tty
condition|)
name|copy_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|within
operator|++
expr_stmt|;
name|screen
argument_list|(
name|f
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|within
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|fnum
operator|++
expr_stmt|;
name|firstf
operator|=
literal|0
expr_stmt|;
block|}
name|otty
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Check whether the file named by fs is an ASCII file which the user may ** access.  If it is, return the opened file. Otherwise return NULL. */
end_comment

begin_function
name|FILE
modifier|*
name|checkf
parameter_list|(
name|fs
parameter_list|)
specifier|register
name|char
modifier|*
name|fs
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CORY
name|int
name|space
index|[
literal|3
index|]
decl_stmt|;
comment|/* Why doesn't libretro have a V7 stat? */
endif|#
directive|endif
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fs
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFDIR
condition|)
block|{
name|pr
argument_list|(
literal|"\n*** "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|": directory ***\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|fs
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Try to see whether it is an ASCII file */
switch|switch
condition|(
operator|(
name|c
operator||
operator|*
name|f
operator|->
name|_ptr
operator|<<
literal|8
operator|)
operator|&
literal|0177777
condition|)
block|{
case|case
literal|0405
case|:
case|case
literal|0407
case|:
case|case
literal|0410
case|:
case|case
literal|0411
case|:
case|case
literal|0177545
case|:
name|pr
argument_list|(
literal|"\n******** "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|": Not a text file ********\n\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\f'
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
name|doclear
argument_list|()
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** A real function, for the tputs routine in termlib */
end_comment

begin_expr_stmt
name|putch
argument_list|(
name|ch
argument_list|)
specifier|register
name|char
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Print out the contents of the file f, one screenful at a time. */
end_comment

begin_define
define|#
directive|define
name|STOP
value|-10
end_define

begin_expr_stmt
name|screen
argument_list|(
name|f
argument_list|,
name|num_lines
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|num_lines
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|nchars
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|num_lines
operator|>
literal|0
operator|&&
operator|!
name|pause
condition|)
block|{
if|if
condition|(
operator|(
name|nchars
operator|=
name|getline
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
name|Senter
operator|&&
operator|*
name|Senter
operator|==
literal|' '
operator|&&
name|promptlen
operator|>
literal|0
condition|)
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|Line
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
name|promptlen
condition|)
name|erase
argument_list|(
name|nchars
argument_list|)
expr_stmt|;
comment|/* erase () sets promptlen to 0 */
else|else
name|promptlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
name|Mcol
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|==
name|STOP
condition|)
break|break;
name|num_lines
operator|--
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|noscroll
condition|)
name|doclear
argument_list|()
expr_stmt|;
else|else
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|pause
operator|=
literal|0
expr_stmt|;
name|startup
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|num_lines
operator|=
name|command
argument_list|(
name|NULL
argument_list|,
name|f
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
block|}
end_block

begin_comment
comment|/* ** Come here if a quit signal is received */
end_comment

begin_macro
name|onquit
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inwait
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|startup
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|pause
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dum_opt
operator|&&
name|notell
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"[Use q or Q to quit]"
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|promptlen
operator|+=
literal|20
expr_stmt|;
name|notell
operator|=
literal|0
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Clean up terminal state and exit. Also come here if interrupt signal received */
end_comment

begin_macro
name|end_it
argument_list|()
end_macro

begin_block
block|{
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
if|if
condition|(
name|promptlen
operator|>
literal|0
condition|)
name|kill_line
argument_list|()
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|copy_file
argument_list|(
name|f
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|printd
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|=
name|n
operator|/
literal|10
condition|)
name|printd
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|n
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|bell
init|=
name|ctrl
argument_list|(
name|G
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|strlen
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|p
operator|-
name|s
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|prompt
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|promptlen
operator|>
literal|0
condition|)
name|kill_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hard
condition|)
block|{
name|promptlen
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
name|tputs
argument_list|(
name|Senter
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"--More--"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
block|{
name|pr
argument_list|(
literal|"(Next file: "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|promptlen
operator|+=
literal|13
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dum_opt
condition|)
block|{
name|pr
argument_list|(
literal|"[Hit space to continue, Rubout to abort]"
argument_list|)
expr_stmt|;
name|promptlen
operator|+=
literal|40
expr_stmt|;
block|}
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
name|tputs
argument_list|(
name|Sexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inwait
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Get a logical line */
end_comment

begin_expr_stmt
name|getline
argument_list|(
name|f
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|column
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|colflg
decl_stmt|;
name|p
operator|=
name|Line
expr_stmt|;
name|i
operator|=
name|column
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|colflg
operator|&&
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|LINSIZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|Line
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|column
operator|)
return|;
block|}
return|return
operator|(
name|EOF
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
if|if
condition|(
name|hardtabs
operator|&&
name|column
operator|<
name|promptlen
operator|&&
operator|!
name|hard
condition|)
block|{
if|if
condition|(
name|eraseln
operator|&&
operator|!
name|dumb
condition|)
block|{
name|tputs
argument_list|(
name|eraseln
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
operator|--
name|p
init|;
name|column
operator|&
literal|7
condition|;
name|column
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|column
operator|>=
name|promptlen
condition|)
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|column
operator|=
literal|1
operator|+
operator|(
name|column
operator||
literal|7
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|column
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|column
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\f'
operator|&&
name|stop_opt
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|column
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
condition|)
name|column
operator|++
expr_stmt|;
if|if
condition|(
name|column
operator|>=
name|Mcol
condition|)
break|break;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Mcol
operator|>
literal|0
operator|&&
name|column
operator|>=
name|Mcol
condition|)
block|{
if|if
condition|(
operator|!
name|Wrap
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|colflg
operator|=
operator|(
name|column
operator|==
name|Mcol
operator|)
operator|||
name|c
operator|==
literal|'\f'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\f'
operator|&&
name|stop_opt
condition|)
return|return
operator|(
name|STOP
operator|)
return|;
return|return
operator|(
name|column
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Erase the rest of the prompt, assuming we are starting column col. */
end_comment

begin_expr_stmt
name|erase
argument_list|(
name|col
argument_list|)
specifier|register
name|int
name|col
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|hard
operator|||
name|promptlen
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumb
operator|&&
name|eraseln
condition|)
name|tputs
argument_list|(
name|eraseln
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|col
operator|=
name|promptlen
operator|-
name|col
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Erase the current line entirely */
end_comment

begin_macro
name|kill_line
argument_list|()
end_macro

begin_block
block|{
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eraseln
operator|||
name|dumb
condition|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  Print string */
end_comment

begin_macro
name|pr
argument_list|(
argument|s1
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|s
operator|=
name|s1
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  Clear the screen */
end_comment

begin_macro
name|doclear
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Clear
operator|&&
name|Lpp
operator|>
literal|0
condition|)
name|tputs
argument_list|(
name|Clear
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Read a command and do it. A command consists of an optional integer ** argument followed by the command character.  Return the number of lines ** to display in the next screenful.  If there is nothing more to display ** in the current file, zero is returned. */
end_comment

begin_macro
name|command
argument_list|(
argument|filename
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nlines
decl_stmt|;
specifier|register
name|int
name|retval
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|id
decl_stmt|,
name|done
decl_stmt|;
name|char
name|comchar
decl_stmt|,
name|cmdbuf
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|ret
parameter_list|(
name|val
parameter_list|)
value|retval=val;done++;break
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
condition|)
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
name|errors
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|RAW
operator|&&
name|slow_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|nlines
operator|=
name|number
argument_list|(
operator|&
name|comchar
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comchar
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'z'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|=
name|dlines
expr_stmt|;
elseif|else
if|if
condition|(
name|comchar
operator|==
literal|'z'
condition|)
name|dlines
operator|=
name|nlines
expr_stmt|;
name|ret
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
case|case
name|ctrl
argument_list|(
name|D
argument_list|)
case|:
name|ret
argument_list|(
literal|11
argument_list|)
expr_stmt|;
case|case
name|RUBOUT
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|end_it
argument_list|()
expr_stmt|;
case|case
literal|'s'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
name|comchar
operator|==
literal|'f'
condition|)
name|nlines
operator|*=
name|dlines
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"\n...skipping "
argument_list|)
expr_stmt|;
name|printd
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|" line"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|>
literal|1
condition|)
name|pr
argument_list|(
literal|"s\n\n"
argument_list|)
expr_stmt|;
else|else
name|pr
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|done
operator|++
expr_stmt|;
goto|goto
name|endsw
goto|;
block|}
name|nlines
operator|--
expr_stmt|;
block|}
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|ret
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skipf
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
name|ret
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'p'
case|:
if|if
condition|(
name|no_intty
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|skipf
argument_list|(
operator|-
name|nlines
argument_list|)
expr_stmt|;
name|ret
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ttyin
argument_list|(
name|cmdbuf
argument_list|,
literal|78
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|cmdbuf
argument_list|,
name|f
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ttyin
argument_list|(
name|cmdbuf
argument_list|,
literal|78
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
literal|"-c"
argument_list|,
name|cmdbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"exec failed\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|end_it
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"----------\n(continue)\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|done
condition|)
break|break;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|endsw
label|:
name|inwait
operator|=
literal|0
expr_stmt|;
name|notell
operator|++
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|RAW
operator|&&
name|slow_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Read a decimal number from the terminal. Set cmd to the non-digit which ** terminates the number. */
end_comment

begin_macro
name|number
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|otty
operator|.
name|sg_kill
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|read
argument_list|(
literal|2
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|cmd
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Skip n lines in the file f */
end_comment

begin_expr_stmt
name|skiplns
argument_list|(
name|n
argument_list|,
name|f
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
name|n
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** Skip nskip files in the file list (from the command line). Nskip may be ** negative. */
end_comment

begin_expr_stmt
name|skipf
argument_list|(
name|nskip
argument_list|)
specifier|register
name|int
name|nskip
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|nskip
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|nskip
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fnum
operator|>
name|nfiles
operator|-
literal|1
condition|)
name|end_it
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|within
condition|)
operator|++
name|fnum
expr_stmt|;
name|fnum
operator|+=
name|nskip
expr_stmt|;
if|if
condition|(
name|fnum
operator|<
literal|0
condition|)
name|fnum
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|fnum
operator|>
name|nfiles
operator|-
literal|1
condition|)
name|fnum
operator|=
name|nfiles
operator|-
literal|1
expr_stmt|;
name|pr
argument_list|(
literal|"\n...Skipping "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|nskip
operator|>
literal|0
condition|?
literal|"to file "
else|:
literal|"back to file "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
operator|--
name|fnum
expr_stmt|;
block|}
end_block

begin_macro
name|readch
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
name|read
argument_list|(
literal|2
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|BS
init|=
literal|'\b'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|CARAT
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_macro
name|ttyin
argument_list|(
argument|buf
argument_list|,
argument|nmax
argument_list|,
argument|pchar
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|nmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|slash
init|=
literal|0
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|char
name|cbuf
decl_stmt|;
name|sptr
operator|=
name|buf
expr_stmt|;
name|maxlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sptr
operator|-
name|buf
operator|<
name|nmax
condition|)
block|{
if|if
condition|(
name|promptlen
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|promptlen
expr_stmt|;
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|slash
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|otty
operator|.
name|sg_erase
operator|&&
operator|!
name|slash
condition|)
block|{
if|if
condition|(
name|sptr
operator|>
name|buf
condition|)
block|{
operator|--
name|promptlen
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|BS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|--
name|sptr
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|<
literal|' '
operator|&&
operator|*
name|sptr
operator|!=
literal|'\n'
condition|)
block|{
operator|--
name|promptlen
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|BS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|eraseln
condition|)
name|promptlen
operator|=
name|maxlen
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
operator|&&
operator|!
name|slash
condition|)
block|{
if|if
condition|(
name|hard
condition|)
name|pr
argument_list|(
literal|" XXX\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|pchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|eraseln
condition|)
name|erase
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
name|sptr
operator|=
name|buf
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|slash
operator|&&
operator|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
operator|||
name|ch
operator|==
name|otty
operator|.
name|sg_erase
operator|)
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|BS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|--
name|sptr
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'\\'
condition|)
name|slash
operator|=
literal|0
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|' '
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
condition|)
block|{
name|ch
operator|+=
literal|0100
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|CARAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
name|cbuf
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|cbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
operator|*
operator|--
name|sptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|eraseln
condition|)
name|promptlen
operator|=
name|maxlen
expr_stmt|;
if|if
condition|(
name|sptr
operator|-
name|buf
operator|>=
name|nmax
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Line too long"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Search for nth ocurrence of regular expression contained in buf in the file */
end_comment

begin_macro
name|search
argument_list|(
argument|buf
argument_list|,
argument|file
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|startline
init|=
name|ftell
argument_list|(
name|file
argument_list|)
decl_stmt|;
specifier|register
name|long
name|line1
init|=
name|startline
decl_stmt|;
specifier|register
name|long
name|line2
init|=
name|startline
decl_stmt|;
specifier|register
name|long
name|line3
init|=
name|startline
decl_stmt|;
specifier|register
name|int
name|lncount
decl_stmt|;
name|lncount
operator|=
literal|0
expr_stmt|;
name|compile
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|line3
operator|=
name|line2
expr_stmt|;
name|line2
operator|=
name|line1
expr_stmt|;
name|line1
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|rdline
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|lncount
operator|++
expr_stmt|;
if|if
condition|(
name|execute
argument_list|(
name|Line
argument_list|)
condition|)
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lncount
operator|>
literal|3
operator|||
operator|(
name|lncount
operator|>
literal|1
operator|&&
name|no_intty
operator|)
condition|)
name|pr
argument_list|(
literal|"\n...skipping\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_intty
condition|)
name|fseek
argument_list|(
name|file
argument_list|,
name|line3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
name|Line
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
ifdef|#
directive|ifdef
name|CORY
name|file
operator|->
name|_flag
operator|&=
operator|~
name|_IOEOF
expr_stmt|;
comment|/* why doesn't fseek do this ??!!??! */
endif|#
directive|endif
name|fseek
argument_list|(
name|file
argument_list|,
name|startline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr
argument_list|(
literal|"\nPattern not found\n"
argument_list|)
expr_stmt|;
name|end_it
argument_list|()
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Pattern not found"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * The following are adapted from the editor  */
end_comment

begin_comment
comment|/*  * Internal form of regular expressions.  */
end_comment

begin_define
define|#
directive|define
name|CBRA
value|1
end_define

begin_comment
comment|/* left \( bracket */
end_comment

begin_define
define|#
directive|define
name|CCHR
value|2
end_define

begin_comment
comment|/* a particular character */
end_comment

begin_define
define|#
directive|define
name|CDOT
value|4
end_define

begin_comment
comment|/* any char (.) */
end_comment

begin_define
define|#
directive|define
name|CCL
value|6
end_define

begin_comment
comment|/* begin class ([) */
end_comment

begin_define
define|#
directive|define
name|NCCL
value|8
end_define

begin_comment
comment|/* begin not class ([^) */
end_comment

begin_define
define|#
directive|define
name|CDOL
value|10
end_define

begin_comment
comment|/* end of line ($) */
end_comment

begin_define
define|#
directive|define
name|CEOF
value|11
end_define

begin_comment
comment|/* end of pattern */
end_comment

begin_define
define|#
directive|define
name|CKET
value|12
end_define

begin_comment
comment|/* right \) bracket */
end_comment

begin_define
define|#
directive|define
name|CBACK
value|14
end_define

begin_comment
comment|/* repeat previous match (\1, etc on lhs) */
end_comment

begin_define
define|#
directive|define
name|STAR
value|01
end_define

begin_comment
comment|/* or'ed with some symbols to indicate * suffix */
end_comment

begin_define
define|#
directive|define
name|NBRA
value|5
end_define

begin_comment
comment|/* max # of \( \) pairs */
end_comment

begin_decl_stmt
name|char
name|expbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|braslist
index|[
name|NBRA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|braelist
index|[
name|NBRA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|circfl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|loc1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|loc2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|locs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * compile: convert typed in regular expression into internal form.  * eof is the char that delimits the r.e.  * General structure of compiled r.e. in expbuf: A sequence of codes  * from #defines above (CCHR, CDOT, etc). Some of these take arguments  * which follow in line (e.g. CCHR is followed by the particular character  * it is required to match.) CEOF terminates the r.e.  */
end_comment

begin_macro
name|compile
argument_list|(
argument|inbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
name|inbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|inbuf
decl_stmt|;
name|char
modifier|*
name|lastep
decl_stmt|;
name|char
name|bracket
index|[
name|NBRA
index|]
decl_stmt|,
modifier|*
name|bracketp
decl_stmt|;
name|int
name|cclcnt
decl_stmt|;
comment|/* comerr: compilation error. Don't leave half baked r.e. around. */
define|#
directive|define
name|comerr
parameter_list|(
name|msg
parameter_list|)
value|{expbuf[0] = 0; nbra = 0; error(msg); }
name|ep
operator|=
name|expbuf
expr_stmt|;
name|bracketp
operator|=
name|bracket
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* null r.e.: just re-use last r.e., which is still there */
if|if
condition|(
operator|*
name|ep
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nbra
operator|=
literal|0
expr_stmt|;
comment|/* circfl: true if have ^ (anchored search). */
name|circfl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|circfl
operator|++
expr_stmt|;
block|}
name|lastep
operator|=
literal|0
expr_stmt|;
operator|--
name|bp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* for each character in the r.e. */
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|BUFSIZ
index|]
condition|)
name|comerr
argument_list|(
literal|"r.e. too long"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* Hit trailing delim: clean up and quit */
if|if
condition|(
name|bracketp
operator|!=
name|bracket
condition|)
name|comerr
argument_list|(
literal|"unmatched \\("
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CEOF
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|==
literal|'('
condition|)
block|{
comment|/* \(: start of subexpression */
if|if
condition|(
name|nbra
operator|>=
name|NBRA
condition|)
name|comerr
argument_list|(
literal|"too many \\(\\) pairs"
argument_list|)
expr_stmt|;
operator|*
name|bracketp
operator|++
operator|=
name|nbra
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CBRA
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|nbra
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
comment|/* \): end of sub exp */
if|if
condition|(
name|bracketp
operator|<=
name|bracket
condition|)
name|comerr
argument_list|(
literal|"unmatched \\)"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CKET
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
operator|--
name|bracketp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|>=
literal|'1'
operator|&&
name|c
operator|<
literal|'1'
operator|+
name|NBRA
condition|)
block|{
comment|/* \1, \2, ...: rematch previous subexp */
operator|*
name|ep
operator|++
operator|=
name|CBACK
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
operator|-
literal|'1'
expr_stmt|;
continue|continue;
block|}
comment|/* Otherwise just force that char, not specially */
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
comment|/* Newlines can't possibly be in lines */
name|comerr
argument_list|(
literal|"multi line r.e. not allowed"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'.'
case|:
comment|/* .: match any character */
operator|*
name|ep
operator|++
operator|=
name|CDOT
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
comment|/* *: Repeat last char indefinitely */
if|if
condition|(
name|lastep
operator|==
literal|0
operator|||
operator|*
name|lastep
operator|==
name|CBRA
operator|||
operator|*
name|lastep
operator|==
name|CKET
condition|)
comment|/* Not that smart, so treat * as nonspecial */
goto|goto
name|defchar
goto|;
operator|*
name|lastep
operator||=
name|STAR
expr_stmt|;
continue|continue;
case|case
literal|'$'
case|:
comment|/* $: match end of line */
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'\0'
condition|)
comment|/* $ only special at end of r.e. */
goto|goto
name|defchar
goto|;
operator|*
name|ep
operator|++
operator|=
name|CDOL
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
comment|/* 			 * [...]: any of chars enclosed in brackets. 			 * Compiled form: CCL or NCCL, # of possible chars, 			 * then each char. -'s are expanded. 			 */
operator|*
name|ep
operator|++
operator|=
name|CCL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
name|cclcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|==
literal|'^'
condition|)
block|{
comment|/* [^...]: reverse sense of match */
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|ep
index|[
operator|-
literal|2
index|]
operator|=
name|NCCL
expr_stmt|;
block|}
do|do
block|{
comment|/* for each char in brackets */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|comerr
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|ep
index|[
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* form ...a-z... but [- not special */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|==
literal|']'
condition|)
block|{
comment|/* -] not special either */
operator|*
name|ep
operator|++
operator|=
literal|'-'
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|ep
index|[
operator|-
literal|1
index|]
operator|<
name|c
condition|)
block|{
comment|/* insert all chars between */
operator|*
name|ep
operator|=
name|ep
index|[
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|ep
operator|++
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|BUFSIZ
index|]
condition|)
name|comerr
argument_list|(
literal|"Too long"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|BUFSIZ
index|]
condition|)
name|comerr
argument_list|(
literal|"Too long"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|']'
condition|)
do|;
name|lastep
index|[
literal|1
index|]
operator|=
name|cclcnt
expr_stmt|;
comment|/* backpatch count */
continue|continue;
name|defchar
label|:
default|default:
comment|/* 			 * An ordinary char or one treated as ordinary. 			 * Store CCHR followed by that char, rather than 			 * just the char. This causes most r.e.'s to take 			 * up about twice the space you would expect. 			 * On the other hand, it makes r.e.'s beautifully 			 * portable, even though the codes could be real 			 * characters. 			 */
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * execute: look for the compiled r.e. on line addr.  * gf is 0 if this is the first time on this line, otherwise nonzero.  * If not first, start looking at locs, otherwise at beg of linebuf.  * loc1 and loc2 are set to the ends of the pattern found, if any.  * 1 is returned if successful, otherwise 0.  */
end_comment

begin_macro
name|execute
argument_list|(
argument|lptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NBRA
condition|;
name|c
operator|++
control|)
block|{
name|braslist
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
name|braelist
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|p1
operator|=
name|lptr
expr_stmt|;
name|p2
operator|=
name|expbuf
expr_stmt|;
if|if
condition|(
name|circfl
condition|)
block|{
comment|/* anchored search (^): just try one advance. */
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|)
return|;
block|}
comment|/* fast check for first character */
if|if
condition|(
operator|*
name|p2
operator|==
name|CCHR
condition|)
block|{
name|c
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
name|c
condition|)
continue|continue;
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* regular algorithm, try advance starting at each char position. */
do|do
block|{
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * advance: does an anchored search for expression starting at ep,  * looking in line starting at lp. Returns 1 if matches, else 0.  * If found, loc2 is set to end of pattern.  */
end_comment

begin_expr_stmt
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
specifier|register
name|char
operator|*
name|ep
operator|,
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|curlp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|ep
operator|++
condition|)
block|{
comment|/* for each code in r.e., look at it..*/
case|case
name|CCHR
case|:
if|if
condition|(
operator|*
name|ep
operator|++
operator|==
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOT
case|:
if|if
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOL
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|0
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CEOF
case|:
name|loc2
operator|=
name|lp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|CCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NCCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBRA
case|:
name|braslist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CKET
case|:
name|braelist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CBACK
case|:
if|if
condition|(
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"bad back reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|+=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBACK
operator||
name|STAR
case|:
if|if
condition|(
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"bad back reference"
argument_list|)
expr_stmt|;
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
condition|)
name|lp
operator|+=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|lp
operator|>=
name|curlp
condition|)
block|{
if|if
condition|(
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|lp
operator|-=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
block|}
continue|continue;
case|case
name|CDOT
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCHR
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|==
operator|*
name|ep
condition|)
empty_stmt|;
name|ep
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCL
operator||
name|STAR
case|:
case|case
name|NCCL
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|CCL
operator||
name|STAR
operator|)
argument_list|)
condition|)
empty_stmt|;
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
goto|goto
name|star
goto|;
name|star
label|:
comment|/* 		 * star: special treatment. We have found as many of them 		 * as there are to find. Maybe this was too many, as dictated 		 * by what follows in the pattern. Try, starting from the 		 * end, to recursively advance after each char found, 		 * and return after first successful advance (thus finding 		 * largest possible string that matches). 		 */
do|do
block|{
name|lp
operator|--
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|locs
condition|)
break|break;
if|if
condition|(
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|lp
operator|>
name|curlp
condition|)
do|;
comment|/* star failed at all attempts, so whole pattern fails. */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * backref: checks to see that text starting at lp matches previous  * sub-expression #i. Returns 1 if successful, else 0. (Used for \k  * on lhs.)  */
end_comment

begin_expr_stmt
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|braslist
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|++
operator|==
operator|*
name|lp
operator|++
condition|)
if|if
condition|(
name|bp
operator|>=
name|braelist
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * cclass: check to see if character c is in class starting at set.  * ([...] construction on lhs of r.e.) af is sense of success/failure:  * af=1 is normal (success returns 1), af=0 is reversed for [^ (success  * returns 0).  */
end_comment

begin_function
name|int
name|cclass
parameter_list|(
name|set
parameter_list|,
name|c
parameter_list|,
name|af
parameter_list|)
specifier|register
name|char
modifier|*
name|set
decl_stmt|,
name|c
decl_stmt|;
name|int
name|af
decl_stmt|;
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
operator|*
name|set
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
if|if
condition|(
operator|*
name|set
operator|++
operator|==
name|c
condition|)
return|return
operator|(
name|af
operator|)
return|;
return|return
operator|(
operator|!
name|af
operator|)
return|;
block|}
end_function

begin_macro
name|error
argument_list|(
argument|mess
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mess
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|promptlen
operator|>
literal|0
condition|)
if|if
condition|(
name|hard
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|kill_line
argument_list|()
expr_stmt|;
name|promptlen
operator|+=
name|strlen
argument_list|(
name|mess
argument_list|)
expr_stmt|;
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
block|{
name|tputs
argument_list|(
name|Senter
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|Sexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
else|else
name|pr
argument_list|(
name|mess
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdline
argument_list|(
name|f
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|Line
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
operator|&&
name|p
operator|-
name|Line
operator|<
name|LINSIZ
operator|-
literal|1
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

end_unit

