begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  *	This program examines each of its arguments for C function  * definitions, and puts them in a file "tags" for use by the editor  * (and anyone else who wants to).  */
end_comment

begin_comment
comment|/*  *	program history:  *	ken arnold wrote this program.  ask him.  *	brought over to the vax by peter b. kessler 7/79  *	who disavows any knowledge of its actions,  *	except for the stuff related to the construction  *	of the search patterns.  *	Some additional enhancements made by Mark Horton, involving  *	the options and special treatment of "main", "}" at beginning  *	of line, and a few bug fixes.  */
end_comment

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_define
define|#
directive|define
name|logical
value|char
end_define

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|arg
parameter_list|)
value|(_wht[arg])
end_define

begin_comment
comment|/* T if char is white		*/
end_comment

begin_define
define|#
directive|define
name|begtoken
parameter_list|(
name|arg
parameter_list|)
value|(_btk[arg])
end_define

begin_comment
comment|/* T if char can start token	*/
end_comment

begin_define
define|#
directive|define
name|intoken
parameter_list|(
name|arg
parameter_list|)
value|(_itk[arg])
end_define

begin_comment
comment|/* T if char can be in token	*/
end_comment

begin_define
define|#
directive|define
name|endtoken
parameter_list|(
name|arg
parameter_list|)
value|(_etk[arg])
end_define

begin_comment
comment|/* T if char ends tokens	*/
end_comment

begin_define
define|#
directive|define
name|isgood
parameter_list|(
name|arg
parameter_list|)
value|(_gd[arg])
end_define

begin_comment
comment|/* T if char can be after ')'	*/
end_comment

begin_define
define|#
directive|define
name|max
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
value|(I1> I2 ? I1 : I2)
end_define

begin_struct
struct|struct
name|nd_st
block|{
comment|/* sorting structure			*/
name|char
modifier|*
name|func
decl_stmt|;
comment|/* function name		*/
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name			*/
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* search pattern		*/
name|logical
name|been_warned
decl_stmt|;
comment|/* set if noticed dup		*/
name|struct
name|nd_st
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* left and right sons		*/
block|}
struct|;
end_struct

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|char
modifier|*
name|unctrl
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|nd_st
name|NODE
typedef|;
end_typedef

begin_decl_stmt
name|logical
name|number
decl_stmt|,
comment|/* T if on line starting with #	*/
name|term
init|=
name|FALSE
decl_stmt|,
comment|/* T if print on terminal	*/
name|makefile
init|=
name|TRUE
decl_stmt|,
comment|/* T if to creat "tags" file	*/
name|gotone
decl_stmt|,
comment|/* found a func already on line	*/
comment|/* boolean "func" (see init)	*/
name|_wht
index|[
literal|0177
index|]
decl_stmt|,
name|_etk
index|[
literal|0177
index|]
decl_stmt|,
name|_itk
index|[
literal|0177
index|]
decl_stmt|,
name|_btk
index|[
literal|0177
index|]
decl_stmt|,
name|_gd
index|[
literal|0177
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|searchar
init|=
literal|'?'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use ?...? searches 		*/
end_comment

begin_define
define|#
directive|define
name|MAXPATTERN
value|50
end_define

begin_comment
comment|/* according to bill		*/
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current line */
end_comment

begin_decl_stmt
name|char
name|line
index|[
literal|256
index|]
decl_stmt|,
comment|/* current input line			*/
modifier|*
name|curfile
decl_stmt|,
comment|/* current input file name		*/
modifier|*
name|outfile
init|=
literal|"tags"
decl_stmt|,
comment|/* output file				*/
modifier|*
name|white
init|=
literal|" \f\t\n"
decl_stmt|,
comment|/* white chars				*/
modifier|*
name|endtk
init|=
literal|" \t\n\"'#()[]{}=-+%*/&|^~!<>;,.:?"
decl_stmt|,
comment|/* token ending chars			*/
modifier|*
name|begtk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
decl_stmt|,
comment|/* token starting chars			*/
modifier|*
name|intk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|,
comment|/* valid in-token chars			*/
modifier|*
name|notgd
init|=
literal|",;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-valid after-function chars	*/
end_comment

begin_decl_stmt
name|int
name|file_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file number			*/
end_comment

begin_decl_stmt
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a: append to tags */
end_comment

begin_decl_stmt
name|int
name|uflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -u: update tags */
end_comment

begin_decl_stmt
name|int
name|wflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w: suppress warnings */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|inf
decl_stmt|,
comment|/* ioptr for current input file		*/
modifier|*
name|outf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioptr for tags file			*/
end_comment

begin_decl_stmt
name|long
name|lineftell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ftell after getc( inf ) == '\n' 	*/
end_comment

begin_decl_stmt
name|NODE
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the head of the sorted binary tree	*/
end_comment

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|ac
operator|>
literal|1
operator|&&
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|aflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|uflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wflag
operator|++
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|<=
literal|1
condition|)
block|{
name|usage
label|:
name|printf
argument_list|(
literal|"Usage: ctags [-au] file ...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
comment|/* set up boolean "functions"		*/
comment|/* 	 * loop through files finding functions 	 */
for|for
control|(
name|file_num
operator|=
literal|1
init|;
name|file_num
operator|<
name|ac
condition|;
name|file_num
operator|++
control|)
name|find_funcs
argument_list|(
name|av
index|[
name|file_num
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"mv %s OTAGS ; fgrep -v '\t%s\t' OTAGS> %s ; rm OTAGS"
argument_list|,
name|outfile
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|aflag
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|aflag
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|put_funcs
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* put the data in "tags"		*/
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	This routine sets up the boolean psuedo-functions which work  * by seting boolean flags dependent upon the corresponding character   * Every char which is NOT in that string is not a white char.  Therefore,  * all of the array "_wht" is set to FALSE, and then the elements  * subscripted by the chars in "white" are set to TRUE.  Thus "_wht"  * of a char is TRUE if it is the string "white", else FALSE.  * It also open up the "tags" output file.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0177
condition|;
name|i
operator|++
control|)
block|{
name|_wht
index|[
name|i
index|]
operator|=
name|_etk
index|[
name|i
index|]
operator|=
name|_itk
index|[
name|i
index|]
operator|=
name|_btk
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|_gd
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|white
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_wht
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|endtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_etk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|intk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_itk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|begtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_btk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|notgd
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_gd
index|[
operator|*
name|sp
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	This program opens the specified file and calls the function  * which finds the function defenitions.  */
end_comment

begin_macro
name|find_funcs
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|curfile
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|curfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|C_funcs
argument_list|()
expr_stmt|;
comment|/* find the C-style functions		*/
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	This routine finds functions in C syntax and adds them  * to the list.  */
end_comment

begin_macro
name|C_funcs
argument_list|()
end_macro

begin_block
block|{
name|reg
name|char
name|c
decl_stmt|,
comment|/* current input char		*/
modifier|*
name|token
decl_stmt|,
comment|/* start of current token	*/
modifier|*
name|tp
decl_stmt|;
comment|/* end of current token		*/
name|logical
name|incom
decl_stmt|,
comment|/* T if inside a comment	*/
name|inquote
decl_stmt|,
comment|/* T if inside a quoted string	*/
name|inchar
decl_stmt|,
comment|/* T if inside a single char '	*/
name|midtoken
decl_stmt|;
comment|/* T if in middle of token	*/
name|char
modifier|*
name|sp
decl_stmt|;
comment|/* current input char		*/
name|char
name|tok
index|[
literal|100
index|]
decl_stmt|;
name|long
name|insub
decl_stmt|;
comment|/* level of "{}"s deep		*/
comment|/* 	 * init boolean flags, counters, and pointers 	 */
name|number
operator|=
name|gotone
operator|=
name|midtoken
operator|=
name|inquote
operator|=
name|inchar
operator|=
name|incom
operator|=
name|FALSE
expr_stmt|;
name|insub
operator|=
literal|0L
expr_stmt|;
name|sp
operator|=
name|tp
operator|=
name|token
operator|=
name|line
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"           t  s c m q c g n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     s  t  k  u o i u h o u\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" c   p  p  n  b m d o r t m\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
operator|*
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s: "
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %d %d %d %d %d %d\n"
argument_list|,
name|insub
argument_list|,
name|incom
argument_list|,
name|midtoken
argument_list|,
name|inquote
argument_list|,
name|inchar
argument_list|,
name|gotone
argument_list|,
name|number
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * action based on mixture of character type, *sp, 		 * and logical flags 		 */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|sp
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* 			 * Handling of backslash is very naive. 			 * We do, however, turn escaped newlines 			 * into spaces. 			 */
if|if
condition|(
name|c
operator|=
literal|'\n'
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incom
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
operator|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'*'
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s- "
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %d %d %d %d %d %d\n"
argument_list|,
name|insub
argument_list|,
name|incom
argument_list|,
name|midtoken
argument_list|,
name|inquote
argument_list|,
name|inchar
argument_list|,
name|gotone
argument_list|,
name|number
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s- "
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2.2s "
argument_list|,
name|unctrl
argument_list|(
operator|*
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %d %d %d %d %d %d\n"
argument_list|,
name|insub
argument_list|,
name|incom
argument_list|,
name|midtoken
argument_list|,
name|inquote
argument_list|,
name|inchar
argument_list|,
name|gotone
argument_list|,
name|number
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|incom
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inquote
condition|)
block|{
comment|/* 			 * Too dumb to know about \" not being magic, but 			 * they usually occur in pairs anyway. 			 */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|inquote
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inchar
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inchar
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|inquote
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inchar
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
if|if
condition|(
operator|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'*'
condition|)
name|incom
operator|=
name|TRUE
expr_stmt|;
else|else
name|ungetc
argument_list|(
operator|*
name|sp
argument_list|,
name|inf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
operator|&&
name|sp
operator|==
name|line
condition|)
name|number
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|insub
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
if|if
condition|(
name|sp
operator|==
name|line
condition|)
comment|/* 				 * Kludge to get back in sync after getting confused. 				 * We really shouldn't be looking at indenting style, 				 * but tricking with the preprocessor can get us off, 				 * and most people indent this way anyway. 				 * This resets level of indenting to zero if '}' is 				 * found at beginning of line. 				 */
name|insub
operator|=
literal|0
expr_stmt|;
else|else
name|insub
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|insub
operator|&&
operator|!
name|inquote
operator|&&
operator|!
name|inchar
operator|&&
operator|!
name|gotone
condition|)
block|{
if|if
condition|(
name|midtoken
condition|)
block|{
if|if
condition|(
name|endtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_func
argument_list|(
operator|&
name|sp
argument_list|,
name|token
argument_list|,
name|tp
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|tok
argument_list|,
name|token
argument_list|,
name|tp
operator|-
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tok
index|[
name|tp
operator|-
name|token
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|add_func
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|gotone
operator|=
name|TRUE
expr_stmt|;
block|}
name|midtoken
operator|=
name|FALSE
expr_stmt|;
name|token
operator|=
name|sp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
name|tp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|token
operator|=
name|tp
operator|=
name|sp
expr_stmt|;
name|midtoken
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* 		 * move on to next char, and set flags accordingly 		 */
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|tp
operator|=
name|token
operator|=
name|sp
operator|=
name|line
expr_stmt|;
name|lineftell
operator|=
name|ftell
argument_list|(
name|inf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"lineftell saved as %ld\n"
argument_list|,
name|lineftell
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|number
operator|=
name|gotone
operator|=
name|midtoken
operator|=
name|inquote
operator|=
name|inchar
operator|=
name|FALSE
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	This routine  checks to see if the current token is  * at the start of a function.  It updates the input line  * so that the '(' will be in it when it returns.  */
end_comment

begin_macro
name|start_func
argument_list|(
argument|lp
argument_list|,
argument|token
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|lp
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
name|c
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
specifier|static
name|logical
name|found
decl_stmt|;
name|logical
name|firsttok
decl_stmt|;
comment|/* T if have seen first token in ()'s */
name|int
name|bad
decl_stmt|;
name|sp
operator|=
operator|*
name|lp
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|number
condition|)
comment|/* space is not allowed in macro defs	*/
while|while
condition|(
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s:\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* the following tries to make it so that a #define a b(c)	*/
comment|/* doesn't count as a define of b.				*/
else|else
block|{
name|logical
name|define
decl_stmt|;
name|define
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|tsp
operator|=
literal|"define"
init|;
operator|*
name|tsp
operator|&&
name|token
operator|<
name|tp
condition|;
name|tsp
operator|++
control|)
if|if
condition|(
operator|*
name|tsp
operator|!=
operator|*
name|token
operator|++
condition|)
block|{
name|define
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|define
condition|)
name|found
operator|=
literal|0
expr_stmt|;
else|else
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|>=
literal|2
condition|)
block|{
name|gotone
operator|=
name|TRUE
expr_stmt|;
name|badone
label|:
name|bad
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
goto|goto
name|badone
goto|;
name|firsttok
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
literal|')'
condition|)
block|{
comment|/* 		 * This line used to confuse ctags: 		 *	int	(*oldhup)(); 		 * This fixes it. A nonwhite char before the first 		 * token, other than a / (in case of a comment in there) 		 * makes this not a declaration. 		 */
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'/'
condition|)
name|firsttok
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|firsttok
condition|)
goto|goto
name|badone
goto|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s:\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s:\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|iswhite
argument_list|(
operator|*
operator|++
name|sp
operator|=
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s:\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
endif|#
directive|endif
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%2.2s:\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
label|:
operator|*
name|lp
operator|=
operator|--
name|sp
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|inf
argument_list|)
expr_stmt|;
return|return
operator|!
name|bad
operator|&&
name|isgood
argument_list|(
name|c
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  *	This routine adds a function to the list  */
end_comment

begin_macro
name|add_func
argument_list|(
argument|token
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|token
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|reg
name|NODE
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"too many functions to sort\n"
argument_list|)
expr_stmt|;
name|put_funcs
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Since there are so many directories with lots of 		 * misc. complete programs in them, main tends to get 		 * redefined a lot. So we change all mains to instead 		 * refer to the name of the file, without leading 		 * pathname components and without a trailing .c. 		 */
name|fp
operator|=
name|curfile
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|curfile
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
operator|==
literal|'/'
condition|)
name|fp
operator|=
name|pp
operator|+
literal|1
expr_stmt|;
operator|*
name|token
operator|=
literal|'M'
expr_stmt|;
name|strcpy
argument_list|(
name|token
operator|+
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|token
index|[
name|strlen
argument_list|(
name|token
argument_list|)
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
literal|'.'
condition|)
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
block|}
name|fp
operator|=
name|np
operator|->
name|func
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|file
operator|=
name|curfile
expr_stmt|;
name|strcpy
argument_list|(
name|fp
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|{
comment|/* 		 * this change to make the whole line the pattern 		 */
name|long
name|saveftell
init|=
name|ftell
argument_list|(
name|inf
argument_list|)
decl_stmt|;
name|int
name|patlen
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|patlen
operator|=
literal|0
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|lineftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"saveftell=%ld, lseek back to %ld\n"
argument_list|,
name|saveftell
argument_list|,
name|lineftell
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ch
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|searchar
operator|&&
name|patlen
operator|<
name|MAXPATTERN
condition|)
block|{
name|patlen
operator|++
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
name|pp
operator|=
name|np
operator|->
name|pat
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|patlen
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|lineftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
while|while
condition|(
name|patlen
operator|--
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|ch
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
operator|*
name|pp
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|*
name|pp
operator|=
literal|'\0'
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|saveftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"seek back to %ld, ftell is now %ld\n"
argument_list|,
name|saveftell
argument_list|,
name|ftell
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\"%s\"\t\"%s\"\t\"%s\"\n"
argument_list|,
name|np
operator|->
name|func
argument_list|,
name|np
operator|->
name|file
argument_list|,
name|np
operator|->
name|pat
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|np
expr_stmt|;
else|else
name|add_node
argument_list|(
name|np
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	This routine cfrees the entire tree from the node down.  */
end_comment

begin_macro
name|free_tree
argument_list|(
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|node
condition|)
block|{
name|free_tree
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	This routine finds the node where the new function node  * should be added.  */
end_comment

begin_macro
name|add_node
argument_list|(
argument|node
argument_list|,
argument|cur_node
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|,
modifier|*
name|cur_node
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|strcmp
argument_list|(
name|node
operator|->
name|func
argument_list|,
name|cur_node
operator|->
name|func
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"strcmp(\"%s\",\"%s\") == %d\n"
argument_list|,
name|node
operator|->
name|func
argument_list|,
name|cur_node
operator|->
name|func
argument_list|,
name|dif
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dif
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|file
operator|==
name|cur_node
operator|->
name|file
condition|)
block|{
if|if
condition|(
operator|!
name|wflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate function in file \"%s\", line %d: %s\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|lineno
argument_list|,
name|node
operator|->
name|func
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Second entry ignored\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cur_node
operator|->
name|been_warned
condition|)
if|if
condition|(
operator|!
name|wflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate function name in files %s and %s: %s (Warning only)\n"
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|cur_node
operator|->
name|file
argument_list|,
name|node
operator|->
name|func
argument_list|)
expr_stmt|;
name|cur_node
operator|->
name|been_warned
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dif
operator|<
literal|0
condition|)
if|if
condition|(
name|cur_node
operator|->
name|left
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|left
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"adding to left branch\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cur_node
operator|->
name|left
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cur_node
operator|->
name|right
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|right
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"adding to right branch\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cur_node
operator|->
name|right
operator|=
name|node
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	This routine puts the functions in the file.  */
end_comment

begin_macro
name|put_funcs
argument_list|(
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|put_funcs
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\t%s\t%c^%s%c\n"
argument_list|,
name|node
operator|->
name|func
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|searchar
argument_list|,
name|node
operator|->
name|pat
argument_list|,
name|searchar
argument_list|)
expr_stmt|;
name|put_funcs
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|char
modifier|*
name|unctrl
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|'~'
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'?'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
operator|=
literal|'?'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\b'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|buf
index|[
literal|1
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
default|default:
name|buf
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|c
operator|+
literal|64
expr_stmt|;
block|}
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

