begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_comment
comment|/*copylet flags */
end_comment

begin_comment
comment|/*remote mail, add rmtmsg */
end_comment

begin_define
define|#
directive|define
name|REMOTE
value|1
end_define

begin_comment
comment|/* zap header and trailing empty line */
end_comment

begin_define
define|#
directive|define
name|ZAP
value|3
end_define

begin_define
define|#
directive|define
name|ORDINARY
value|2
end_define

begin_define
define|#
directive|define
name|FORWARD
value|4
end_define

begin_define
define|#
directive|define
name|LSIZE
value|256
end_define

begin_define
define|#
directive|define
name|MAXLET
value|300
end_define

begin_comment
comment|/* maximum number of letters */
end_comment

begin_define
define|#
directive|define
name|MAILMODE
value|(~0644)
end_define

begin_comment
comment|/* mode of created mail */
end_comment

begin_define
define|#
directive|define
name|RMAIL
value|"/usr/net/bin/sendmail"
end_define

begin_decl_stmt
name|char
name|line
index|[
name|LSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|resp
index|[
name|LSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|let
block|{
name|long
name|adr
decl_stmt|;
name|char
name|change
decl_stmt|;
block|}
name|let
index|[
name|MAXLET
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|nlet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|iop
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|lettmp
index|[]
init|=
literal|"/tmp/maXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|maildir
index|[]
init|=
literal|"/usr/spool/mail/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mailfile
index|[]
init|=
literal|"/usr/spool/mail/xxxxxxxxxxxxxxxxxxxxxxx"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dead
index|[]
init|=
literal|"dead.letter"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|thissys
init|=
name|sysname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netname
init|=
literal|"vax"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|forwmsg
index|[]
init|=
literal|" forwarded\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|curlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lockerror
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|tmpf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|malf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|my_name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|locked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forward
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|from
index|[]
init|=
literal|"From "
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|delete
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|flgf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flgp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|char
name|sobuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|sobuf
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|my_name
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|my_name
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|my_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|pwent
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
operator|==
name|NULL
condition|)
name|my_name
operator|=
literal|"???"
expr_stmt|;
else|else
name|my_name
operator|=
name|pwent
operator|->
name|pw_name
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
name|done
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|setsig
argument_list|(
name|i
argument_list|,
name|delete
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: cannot open %s for writing\n"
argument_list|,
name|lettmp
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
comment|/* no favors for rmail*/
operator|(
name|argc
operator|==
literal|1
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|!=
literal|'r'
operator|)
condition|)
name|printmail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|sendmail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|setsig
argument_list|(
argument|i
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|printmail
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flg
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|print
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|getarg
argument_list|()
decl_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|mailfile
argument_list|,
name|maildir
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|argc
operator|>
literal|1
condition|;
name|argv
operator|++
operator|,
name|argc
operator|--
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'q'
condition|)
name|delflg
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
name|flgp
operator|++
expr_stmt|;
name|delflg
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|argc
operator|>=
literal|3
condition|)
block|{
name|strcpy
argument_list|(
name|mailfile
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
name|forward
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: unknown option %c\n"
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|malf
operator|=
name|fopen
argument_list|(
name|mailfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"No mail.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lock
argument_list|(
name|mailfile
argument_list|)
expr_stmt|;
name|copymt
argument_list|(
name|malf
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|print
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlet
condition|;
control|)
block|{
name|j
operator|=
name|forward
condition|?
name|i
else|:
name|nlet
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
block|{
name|print
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|print
condition|)
name|copylet
argument_list|(
name|j
argument_list|,
name|stdout
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|print
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flgp
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|resp
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|resp
index|[
literal|0
index|]
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage\n"
argument_list|)
expr_stmt|;
case|case
literal|'?'
case|:
name|print
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"q\tquit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"x\texit without changing mail\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"p\tprint\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s[file]\tsave (default mbox)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"w[file]\tsame without header\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-\tprint previous\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"d\tdelete\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+\tnext (no delete)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"m user\tmail to user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"! cmd\texecute cmd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'n'
case|:
case|case
literal|'\n'
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|changed
operator|=
literal|0
expr_stmt|;
case|case
literal|'q'
case|:
goto|goto
name|donep
goto|;
case|case
literal|'p'
case|:
break|break;
case|case
literal|'^'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
case|case
literal|'s'
case|:
name|flg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|!=
literal|'\n'
operator|&&
name|resp
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"illegal\n"
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|resp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
name|cat
argument_list|(
name|resp
operator|+
literal|1
argument_list|,
name|p
argument_list|,
literal|"/mbox"
argument_list|)
expr_stmt|;
else|else
name|cat
argument_list|(
name|resp
operator|+
literal|1
argument_list|,
literal|""
argument_list|,
literal|"mbox"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|resp
operator|+
literal|1
init|;
operator|(
name|p
operator|=
name|getarg
argument_list|(
name|lfil
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|malf
operator|=
name|fopen
argument_list|(
name|lfil
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: cannot append to %s\n"
argument_list|,
name|lfil
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
continue|continue;
block|}
name|copylet
argument_list|(
name|j
argument_list|,
name|malf
argument_list|,
name|resp
index|[
literal|0
index|]
operator|==
literal|'w'
condition|?
name|ZAP
else|:
name|ORDINARY
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flg
condition|)
name|print
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
name|flg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|resp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"invalid command\n"
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|p
operator|=
name|resp
operator|+
literal|1
init|;
operator|(
name|p
operator|=
name|getarg
argument_list|(
name|lfil
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|!
name|sendrmt
argument_list|(
name|j
argument_list|,
name|lfil
argument_list|,
literal|"/bin/mail"
argument_list|)
condition|)
comment|/* couldn't send it */
name|flg
operator|++
expr_stmt|;
if|if
condition|(
name|flg
condition|)
name|print
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
name|system
argument_list|(
name|resp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"!\n"
argument_list|)
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'q'
condition|)
goto|goto
name|donep
goto|;
break|break;
block|}
block|}
name|donep
label|:
if|if
condition|(
name|changed
condition|)
name|copyback
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|copyback
argument_list|()
end_macro

begin_comment
comment|/* copy temp or whatever back to /usr/spool/mail */
end_comment

begin_block
block|{
specifier|register
name|i
operator|,
name|n
operator|,
name|c
expr_stmt|;
name|int
name|new
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|lock
argument_list|(
name|mailfile
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|mailfile
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_size
operator|!=
name|let
index|[
name|nlet
index|]
operator|.
name|adr
condition|)
block|{
comment|/* new mail has arrived */
name|malf
operator|=
name|fopen
argument_list|(
name|mailfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: can't re-read %s\n"
argument_list|,
name|mailfile
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|fseek
argument_list|(
name|malf
argument_list|,
name|let
index|[
name|nlet
index|]
operator|.
name|adr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|tmpf
argument_list|,
name|let
index|[
name|nlet
index|]
operator|.
name|adr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|malf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|let
index|[
operator|++
name|nlet
index|]
operator|.
name|adr
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
block|}
name|malf
operator|=
name|fopen
argument_list|(
name|mailfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: can't rewrite %s\n"
argument_list|,
name|lfil
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlet
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|let
index|[
name|i
index|]
operator|.
name|change
operator|!=
literal|'d'
condition|)
block|{
name|copylet
argument_list|(
name|i
argument_list|,
name|malf
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"new mail arrived\n"
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|copymt
argument_list|(
argument|f1
argument_list|,
argument|f2
argument_list|)
end_macro

begin_comment
comment|/* copy mail (f1) to temp (f2) */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|nextadr
decl_stmt|;
name|nlet
operator|=
name|nextadr
operator|=
literal|0
expr_stmt|;
name|let
index|[
literal|0
index|]
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|f1
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isfrom
argument_list|(
name|line
argument_list|)
condition|)
name|let
index|[
name|nlet
operator|++
index|]
operator|.
name|adr
operator|=
name|nextadr
expr_stmt|;
name|nextadr
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|f2
argument_list|)
expr_stmt|;
block|}
name|let
index|[
name|nlet
index|]
operator|.
name|adr
operator|=
name|nextadr
expr_stmt|;
comment|/* last plus 1 */
block|}
end_block

begin_macro
name|copylet
argument_list|(
argument|n
argument_list|,
argument|f
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ch
decl_stmt|,
name|k
decl_stmt|;
name|fseek
argument_list|(
name|tmpf
argument_list|,
name|let
index|[
name|n
index|]
operator|.
name|adr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|let
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|adr
operator|-
name|let
index|[
name|n
index|]
operator|.
name|adr
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
operator|&&
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|tmpf
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|type
operator|!=
name|ZAP
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|REMOTE
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" remote from %s\n"
argument_list|,
name|thissys
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|FORWARD
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|forwmsg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ORDINARY
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
condition|)
name|fputc
argument_list|(
name|ch
operator|=
name|fgetc
argument_list|(
name|tmpf
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ZAP
operator|||
name|ch
operator|!=
literal|'\n'
condition|)
name|fputc
argument_list|(
name|fgetc
argument_list|(
name|tmpf
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|isfrom
argument_list|(
name|lp
argument_list|)
specifier|register
name|char
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|from
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|lp
operator|++
operator|!=
operator|*
name|p
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|sendmail
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|truename
index|[
literal|100
index|]
decl_stmt|;
name|int
name|first
decl_stmt|;
name|truename
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|4
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|truename
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|truename
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|truename
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|argc
operator|-=
literal|3
expr_stmt|;
name|argv
operator|+=
literal|3
expr_stmt|;
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmpn
argument_list|(
literal|"From"
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|truename
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmpf
argument_list|,
literal|"%s%s %s"
argument_list|,
name|from
argument_list|,
name|truename
argument_list|,
name|ctime
argument_list|(
operator|&
name|iop
argument_list|)
argument_list|)
expr_stmt|;
name|iop
operator|=
name|ftell
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|flgf
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|first
operator|=
literal|1
init|;
condition|;
name|first
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|first
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|first
operator|&&
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|line
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isfrom
argument_list|(
name|line
argument_list|)
condition|)
name|fputs
argument_list|(
literal|">"
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|flgf
operator|=
literal|0
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|nlet
operator|=
literal|1
expr_stmt|;
name|let
index|[
literal|0
index|]
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
name|let
index|[
literal|1
index|]
operator|.
name|adr
operator|=
name|ftell
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flgf
condition|)
return|return;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: cannot reopen %s for reading\n"
argument_list|,
name|lettmp
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|send
argument_list|(
literal|0
argument_list|,
operator|*
operator|++
name|argv
argument_list|)
condition|)
comment|/* couldn't send to him */
name|error
operator|++
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|malf
operator|=
name|fopen
argument_list|(
name|dead
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: cannot open %s\n"
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
return|return;
block|}
name|copylet
argument_list|(
literal|0
argument_list|,
name|malf
argument_list|,
name|ZAP
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Mail saved in %s\n"
argument_list|,
name|dead
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sendrmt
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|,
argument|rcmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rcmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|rmf
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|rsys
index|[
literal|64
index|]
decl_stmt|,
name|cmd
index|[
literal|64
index|]
decl_stmt|;
specifier|register
name|local
operator|,
name|pid
expr_stmt|;
name|int
name|sts
decl_stmt|;
name|local
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'!'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"researc"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|rsys
argument_list|,
literal|"research"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'!'
condition|)
operator|--
name|name
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'!'
condition|)
name|name
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|rsys
init|;
operator|*
name|name
operator|!=
literal|'!'
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|name
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|local
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|local
operator|&&
operator|*
name|name
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|local
operator|&&
operator|*
name|rsys
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"null name\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|skip
label|:
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: can't create proc for remote\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pid
condition|)
block|{
while|while
condition|(
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|!
name|sts
operator|)
return|;
block|}
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s %s"
argument_list|,
name|rcmd
argument_list|,
name|rsys
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|index
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|'!'
argument_list|)
condition|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"uux - %s!rmail \\(%s\\)"
argument_list|,
name|rsys
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"uux - %s!rmail %s"
argument_list|,
name|rsys
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rmf
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copylet
argument_list|(
name|n
argument_list|,
name|rmf
argument_list|,
name|local
condition|?
operator|!
name|strcmp
argument_list|(
name|rcmd
argument_list|,
literal|"/bin/mail"
argument_list|)
condition|?
name|FORWARD
else|:
name|ORDINARY
else|:
name|REMOTE
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|rmf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|send
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|)
end_macro

begin_comment
comment|/* send letter n to name */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|file
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|mask
expr_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|,
modifier|*
name|getpwnam
argument_list|()
decl_stmt|;
name|stripfx
argument_list|(
name|netname
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
return|return
operator|(
name|sendrmt
argument_list|(
name|n
argument_list|,
name|name
argument_list|,
name|RMAIL
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"msgs"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sendrmt
argument_list|(
name|n
argument_list|,
literal|"-s"
argument_list|,
literal|"/usr/ucb/msgs"
argument_list|)
operator|)
return|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'^'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
operator|||
operator|*
name|p
operator|==
literal|'^'
condition|)
return|return
operator|(
name|sendrmt
argument_list|(
name|n
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: can't send to %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cat
argument_list|(
name|file
argument_list|,
name|maildir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mask
operator|=
name|umask
argument_list|(
name|MAILMODE
argument_list|)
expr_stmt|;
name|malf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: cannot append to %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lock
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|file
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|copylet
argument_list|(
name|n
argument_list|,
name|malf
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|delete
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|setsig
argument_list|(
name|i
argument_list|,
name|delete
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delflg
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|lockerror
condition|)
name|unlock
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
operator|+
name|lockerror
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lock
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|locked
operator|||
name|flgf
condition|)
return|return;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|stbuf
operator|.
name|st_mode
operator|&
literal|01
condition|)
block|{
comment|/* user x bit is the lock */
if|if
condition|(
name|stbuf
operator|.
name|st_ctime
operator|+
literal|60
operator|>=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s busy; try again in a minute\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|lockerror
operator|++
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
name|locked
operator|=
name|stbuf
operator|.
name|st_mode
operator|&
operator|~
literal|01
expr_stmt|;
name|curlock
operator|=
name|file
expr_stmt|;
name|chmod
argument_list|(
name|file
argument_list|,
name|stbuf
operator|.
name|st_mode
operator||
literal|01
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|unlock
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|locked
condition|)
name|chmod
argument_list|(
name|curlock
argument_list|,
name|locked
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|cat
argument_list|(
argument|to
argument_list|,
argument|from1
argument_list|,
argument|from2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from1
decl_stmt|,
modifier|*
name|from2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|from1
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from1
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|from2
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from2
index|[
name|i
index|]
expr_stmt|;
name|to
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|getarg
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
comment|/* copy p... into s, update p */
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|stripfx
argument_list|(
argument|pfx
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pfx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|*
name|name
decl_stmt|;
while|while
condition|(
operator|*
name|pfx
operator|&&
operator|(
operator|*
name|cp
operator|==
operator|*
name|pfx
operator|||
operator|*
name|cp
operator|==
name|toupper
argument_list|(
operator|*
name|pfx
argument_list|)
operator|)
condition|)
name|cp
operator|++
operator|,
name|pfx
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
condition|)
return|return;
operator|*
name|name
operator|=
name|cp
expr_stmt|;
block|}
end_block

end_unit

