begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	vmpt.c	2.5	2/14/80	*/
end_comment

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/proc.h"
end_include

begin_include
include|#
directive|include
file|"../h/map.h"
end_include

begin_include
include|#
directive|include
file|"../h/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"../h/pte.h"
end_include

begin_include
include|#
directive|include
file|"../h/cmap.h"
end_include

begin_include
include|#
directive|include
file|"../h/vm.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/text.h"
end_include

begin_comment
comment|/*  * Get page tables for process p.  Allocator  * for memory is argument; process must be locked  * from swapping if vmemall is used; if memall is  * used, caller must be prepared for an error return.  */
end_comment

begin_expr_stmt
name|vgetpt
argument_list|(
name|p
argument_list|,
name|pmemall
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|pmemall
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|int
name|a
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_szpt
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|a
operator|=
name|malloc
argument_list|(
name|kernelmap
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
call|(
modifier|*
name|pmemall
call|)
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|,
name|p
argument_list|,
name|MSYS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mfree
argument_list|(
name|kernelmap
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|->
name|p_p0br
operator|=
name|kmxtob
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|vmaccess
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_p0br
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|p_szpt
condition|;
name|i
operator|++
control|)
name|clearseg
argument_list|(
name|Usrptmap
index|[
name|a
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initialize text portion of page table.  */
end_comment

begin_macro
name|vinitpt
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|pte
name|proto
decl_stmt|;
name|xp
operator|=
name|p
operator|->
name|p_textp
expr_stmt|;
if|if
condition|(
name|xp
operator|==
literal|0
condition|)
return|return;
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|=
name|xp
operator|->
name|x_caddr
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tptopte
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|pte
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
operator|*
name|xp
operator|->
name|x_size
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|proto
operator|=
name|PG_URKR
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
condition|)
block|{
name|proto
operator|.
name|pg_fod
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|fpte
operator|*
operator|)
operator|&
name|proto
operator|)
operator|->
name|pg_fileno
operator|=
name|PG_FZERO
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xp
operator|->
name|x_size
condition|;
name|i
operator|++
control|)
operator|*
name|pte
operator|++
operator|=
name|proto
expr_stmt|;
if|if
condition|(
operator|(
name|xp
operator|->
name|x_flag
operator|&
name|XPAGI
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
condition|)
name|vinifod
argument_list|(
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PG_FTEXT
argument_list|,
name|xp
operator|->
name|x_iptr
argument_list|,
literal|1
argument_list|,
name|xp
operator|->
name|x_size
argument_list|)
expr_stmt|;
else|else
name|swap
argument_list|(
name|p
argument_list|,
name|xp
operator|->
name|x_daddr
operator|+
name|ctod
argument_list|(
name|xp
operator|->
name|x_size
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|tptopte
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xp
operator|->
name|x_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|,
name|B_READ
argument_list|,
name|B_PAGET
argument_list|,
name|swapdev
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Update the page tables of all processes linked  * to a particular text segment, by distributing  * dpte to the the text page at virtual frame v.  */
end_comment

begin_macro
name|distpte
argument_list|(
argument|xp
argument_list|,
argument|tp
argument_list|,
argument|dpte
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|size_t
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|dpte
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
name|xp
operator|->
name|x_caddr
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p_xlink
control|)
block|{
name|pte
operator|=
name|tptopte
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|dpte
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLSIZE
condition|;
name|i
operator|++
control|)
name|pte
index|[
name|i
index|]
operator|=
name|dpte
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Release page tables of process p.  */
end_comment

begin_expr_stmt
name|vrelpt
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|a
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_szpt
operator|==
literal|0
condition|)
return|return;
name|a
operator|=
name|btokmx
argument_list|(
name|p
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
name|VOID
name|vmemfree
argument_list|(
operator|&
name|Usrptmap
index|[
name|a
index|]
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|)
decl_stmt|;
name|mfree
argument_list|(
name|kernelmap
argument_list|,
name|p
operator|->
name|p_szpt
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pass the page tables of process p to process q.  * Used during vfork().  */
end_comment

begin_expr_stmt
name|vpasspt
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|up
argument_list|,
name|uq
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|user
modifier|*
name|up
decl_stmt|,
modifier|*
name|uq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|uq
operator|->
name|u_pcb
operator|.
name|pcb_p0br
operator|=
name|q
operator|->
name|p_p0br
operator|=
name|p
operator|->
name|p_p0br
expr_stmt|;
name|uq
operator|->
name|u_pcb
operator|.
name|pcb_p1br
operator|=
name|up
operator|->
name|u_pcb
operator|.
name|pcb_p1br
expr_stmt|;
name|up
operator|->
name|u_pcb
operator|.
name|pcb_p1br
operator|=
name|up
operator|->
name|u_pcb
operator|.
name|pcb_p0br
operator|-
name|P1TOP
expr_stmt|;
name|uq
operator|->
name|u_pcb
operator|.
name|pcb_p0lr
operator|=
name|up
operator|->
name|u_pcb
operator|.
name|pcb_p0lr
expr_stmt|;
name|up
operator|->
name|u_pcb
operator|.
name|pcb_p0lr
operator|=
name|AST
expr_stmt|;
name|uq
operator|->
name|u_pcb
operator|.
name|pcb_p1lr
operator|=
name|up
operator|->
name|u_pcb
operator|.
name|pcb_p1lr
expr_stmt|;
name|up
operator|->
name|u_pcb
operator|.
name|pcb_p1lr
operator|=
name|P1TOP
expr_stmt|;
name|uq
operator|->
name|u_pcb
operator|.
name|pcb_szpt
operator|=
name|q
operator|->
name|p_szpt
operator|=
name|p
operator|->
name|p_szpt
expr_stmt|;
name|up
operator|->
name|u_pcb
operator|.
name|pcb_szpt
operator|=
name|p
operator|->
name|p_szpt
operator|=
literal|0
expr_stmt|;
name|mtpr
argument_list|(
name|P0BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P1BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P0LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0lr
operator|&
operator|~
name|AST
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P1LR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1lr
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Compute number of pages to be allocated to the u. area  * and initialized data page tables.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|vusize
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tsz
init|=
name|p
operator|->
name|p_tsize
operator|/
name|NPTEPG
decl_stmt|;
return|return
operator|(
name|clrnd
argument_list|(
name|UPAGES
operator|+
name|clrnd
argument_list|(
name|ctopt
argument_list|(
name|p
operator|->
name|p_tsize
operator|+
name|p
operator|->
name|p_dsize
operator|+
name|p
operator|->
name|p_ssize
argument_list|)
argument_list|)
operator|-
name|tsz
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get u area for process p.  If a old u area is given,  * then copy the new area from the old, else  * swap in as specified in the proc structure.  *  * Since argument map/newu is potentially shared,  * we have to be careful not to block after beginning  * to use them.  */
end_comment

begin_expr_stmt
name|vgetu
argument_list|(
name|p
argument_list|,
name|palloc
argument_list|,
name|map
argument_list|,
name|newu
argument_list|,
name|oldu
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|palloc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|user
modifier|*
name|newu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|oldu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|pte
name|temp
index|[
name|clrnd
argument_list|(
name|UPAGES
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|palloc
call|)
argument_list|(
name|temp
argument_list|,
name|clrnd
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|p
argument_list|,
name|MSYS
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|map
index|[
name|i
index|]
operator|=
name|temp
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|p_addr
index|[
name|i
index|]
operator|=
name|map
index|[
name|i
index|]
operator|.
name|pg_pfnum
expr_stmt|;
block|}
name|vmaccess
argument_list|(
name|map
argument_list|,
operator|(
name|caddr_t
operator|)
name|newu
argument_list|,
name|UPAGES
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldu
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|oldu
argument_list|,
operator|(
name|caddr_t
operator|)
name|newu
argument_list|,
name|UPAGES
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|newu
operator|->
name|u_procp
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|swap
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_swaddr
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|B_READ
argument_list|,
name|B_UAREA
argument_list|,
name|swapdev
argument_list|)
expr_stmt|;
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_szpt
operator|=
name|p
operator|->
name|p_szpt
expr_stmt|;
block|}
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_p0br
operator|=
name|p
operator|->
name|p_p0br
expr_stmt|;
name|newu
operator|->
name|u_pcb
operator|.
name|pcb_p1br
operator|=
name|p
operator|->
name|p_p0br
operator|+
name|p
operator|->
name|p_szpt
operator|*
name|NPTEPG
operator|-
name|P1TOP
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|vrelswu
argument_list|(
argument|p
argument_list|,
argument|utl
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mfree
argument_list|(
name|swapmap
argument_list|,
name|ctod
argument_list|(
name|vusize
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
argument_list|)
argument_list|,
name|p
operator|->
name|p_swaddr
argument_list|)
expr_stmt|;
comment|/* p->p_swaddr = 0; */
comment|/* leave for post-mortems */
block|}
end_block

begin_macro
name|vgetswu
argument_list|(
argument|p
argument_list|,
argument|utl
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|user
modifier|*
name|utl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|->
name|p_swaddr
operator|=
name|malloc
argument_list|(
name|swapmap
argument_list|,
name|ctod
argument_list|(
name|vusize
argument_list|(
name|p
argument_list|,
name|utl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|p_swaddr
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Release u. area.  *  * Note: we run on the mapping established by Umap for a while after  * the call to vmemfree... hence we (should!) run spl6() until we  * we swtch()... currently we are safe only since interrupt code  * doesn't allocate/free memory.  */
end_comment

begin_expr_stmt
name|vrelu
argument_list|(
name|p
argument_list|,
name|swapu
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|pte
name|uu
index|[
name|UPAGES
index|]
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|up
decl_stmt|;
if|if
condition|(
name|swapu
condition|)
name|swap
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_swaddr
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|,
name|B_WRITE
argument_list|,
name|B_UAREA
argument_list|,
name|swapdev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
block|{
name|up
operator|=
operator|&
name|uu
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|up
operator|=
literal|0
expr_stmt|;
name|up
operator|->
name|pg_pfnum
operator|=
name|p
operator|->
name|p_addr
index|[
name|i
index|]
expr_stmt|;
name|up
operator|->
name|pg_v
operator|=
literal|1
expr_stmt|;
block|}
name|VOID
name|vmemfree
argument_list|(
name|uu
argument_list|,
name|clrnd
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_block

begin_comment
comment|/*  * Expand a page table.  */
end_comment

begin_expr_stmt
name|ptexpand
argument_list|(
name|change
argument_list|)
specifier|register
name|int
name|change
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|spages
decl_stmt|,
name|ss
init|=
name|P1TOP
operator|-
name|mfpr
argument_list|(
name|P1LR
argument_list|)
decl_stmt|;
specifier|register
name|int
name|kold
init|=
name|btokmx
argument_list|(
operator|(
expr|struct
name|pte
operator|*
operator|)
name|mfpr
argument_list|(
name|P0BR
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|knew
decl_stmt|,
name|tdpages
decl_stmt|;
name|int
name|szpt
init|=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_szpt
decl_stmt|;
if|if
condition|(
name|change
operator|<=
literal|0
operator|||
name|change
operator|%
name|CLSIZE
condition|)
name|panic
argument_list|(
literal|"ptexpand"
argument_list|)
expr_stmt|;
name|top
label|:
if|if
condition|(
operator|(
name|knew
operator|=
name|malloc
argument_list|(
name|kernelmap
argument_list|,
name|szpt
operator|+
name|change
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|spages
operator|=
name|ss
operator|/
name|NPTEPG
expr_stmt|;
name|tdpages
operator|=
name|szpt
operator|-
name|spages
expr_stmt|;
if|if
condition|(
name|memall
argument_list|(
operator|&
name|Usrptmap
index|[
name|knew
operator|+
name|tdpages
index|]
argument_list|,
name|change
argument_list|,
name|u
operator|.
name|u_procp
argument_list|,
name|MSYS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mfree
argument_list|(
name|kernelmap
argument_list|,
name|szpt
operator|+
name|change
argument_list|,
name|knew
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|kmcopy
argument_list|(
name|knew
argument_list|,
name|kold
argument_list|,
name|tdpages
argument_list|)
expr_stmt|;
name|kmcopy
argument_list|(
name|knew
operator|+
name|tdpages
operator|+
name|change
argument_list|,
name|kold
operator|+
name|tdpages
argument_list|,
name|spages
argument_list|)
expr_stmt|;
name|i
operator|=
name|knew
operator|+
name|tdpages
expr_stmt|;
name|p1
operator|=
operator|&
name|Usrptmap
index|[
name|i
index|]
expr_stmt|;
name|p2
operator|=
name|p1
operator|+
name|change
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|p2
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|p1
operator||=
name|PG_V
operator||
name|PG_KW
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|kmxtob
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|clearseg
argument_list|(
name|p1
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
name|p1
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* copy stack entries to new page */
name|p1
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|mfpr
argument_list|(
name|P1BR
argument_list|)
operator|+
name|mfpr
argument_list|(
name|P1LR
argument_list|)
expr_stmt|;
name|p2
operator|=
name|kmxtob
argument_list|(
name|knew
operator|+
name|szpt
operator|+
name|change
argument_list|)
operator|-
name|ss
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ss
operator|-
name|NPTEPG
operator|*
name|spages
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|p1
operator|++
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update u area and proc entries */
name|u
operator|.
name|u_procp
operator|->
name|p_p0br
operator|=
name|kmxtob
argument_list|(
name|knew
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p0br
operator|=
name|kmxtob
argument_list|(
name|knew
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
operator|=
name|kmxtob
argument_list|(
name|knew
operator|+
name|szpt
operator|+
name|change
argument_list|)
operator|-
name|P1TOP
expr_stmt|;
name|u
operator|.
name|u_pcb
operator|.
name|pcb_szpt
operator|+=
name|change
expr_stmt|;
name|u
operator|.
name|u_procp
operator|->
name|p_szpt
operator|+=
name|change
expr_stmt|;
name|mtpr
argument_list|(
name|P0BR
argument_list|,
name|u
operator|.
name|u_procp
operator|->
name|p_p0br
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|P1BR
argument_list|,
name|u
operator|.
name|u_pcb
operator|.
name|pcb_p1br
argument_list|)
expr_stmt|;
if|if
condition|(
name|szpt
condition|)
name|mfree
argument_list|(
name|kernelmap
argument_list|,
name|szpt
argument_list|,
name|kold
argument_list|)
expr_stmt|;
name|mtpr
argument_list|(
name|TBIA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 * Swap out the process so that the unavailable  	 * resource will be allocated upon swapin. 	 * 	 * When resume is executed for the process,  	 * here is where it will resume. 	 */
name|bad
label|:
if|if
condition|(
name|save
argument_list|(
name|u
operator|.
name|u_ssav
argument_list|)
condition|)
return|return;
if|if
condition|(
name|swapout
argument_list|(
name|u
operator|.
name|u_procp
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|mfpr
argument_list|(
name|P0LR
argument_list|)
operator|-
name|u
operator|.
name|u_tsize
argument_list|)
argument_list|,
name|ss
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No space to swap... it is inconvenient to try 		 * to exit, so just wait a bit and hope something 		 * turns up.  Could deadlock here. 		 * 		 * SOMEDAY REFLECT ERROR BACK THROUGH expand TO CALLERS 		 * (grow, sbreak) SO CAN'T DEADLOCK HERE. 		 */
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|u
operator|.
name|u_procp
operator|->
name|p_flag
operator||=
name|SSWAP
expr_stmt|;
name|qswtch
argument_list|()
expr_stmt|;
comment|/* no return */
block|}
end_block

begin_expr_stmt
name|kmcopy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|count
argument_list|)
specifier|register
name|int
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|tp
init|=
operator|&
name|Usrptmap
index|[
name|to
index|]
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|fp
init|=
operator|&
name|Usrptmap
index|[
name|from
index|]
decl_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
name|mtpr
argument_list|(
name|TBIS
argument_list|,
name|kmxtob
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Change protection codes of text segment.  */
end_comment

begin_macro
name|chgprot
argument_list|(
argument|tprot
argument_list|)
end_macro

begin_decl_stmt
name|long
name|tprot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|ptaddr
decl_stmt|,
name|i
decl_stmt|;
name|ptaddr
operator|=
operator|(
name|int
operator|*
operator|)
name|mfpr
argument_list|(
name|P0BR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|u
operator|.
name|u_tsize
condition|;
name|i
operator|++
control|)
block|{
name|ptaddr
index|[
name|i
index|]
operator|&=
operator|~
name|PG_PROT
expr_stmt|;
name|ptaddr
index|[
name|i
index|]
operator||=
name|tprot
expr_stmt|;
block|}
block|}
end_block

end_unit

