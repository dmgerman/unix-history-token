begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file implements decoding of ZeroMQ network protocol(s).  *  *  * Copyright (c) 2013 The TCPDUMP project  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_comment
comment|/* Maximum number of ZMTP/1.0 frame body bytes (without the flags) to dump in  * hex and ASCII under a single "-v" flag.  */
end_comment

begin_define
define|#
directive|define
name|VBYTES
value|128
end_define

begin_comment
comment|/*  * Below is an excerpt from the "13/ZMTP" specification:  *  * A ZMTP message consists of 1 or more frames.  *  * A ZMTP frame consists of a length, followed by a flags field and a frame  * body of (length - 1) octets. Note: the length includes the flags field, so  * an empty frame has a length of 1.  *  * For frames with a length of 1 to 254 octets, the length SHOULD BE encoded  * as a single octet. The minimum valid length of a frame is 1 octet, thus a  * length of 0 is invalid and such frames SHOULD be discarded silently.  *  * For frames with lengths of 255 and greater, the length SHALL BE encoded as  * a single octet with the value 255, followed by the length encoded as a  * 64-bit unsigned integer in network byte order. For frames with lengths of  * 1 to 254 octets this encoding MAY be also used.  *  * The flags field consists of a single octet containing various control  * flags. Bit 0 is the least significant bit.  *  * - Bit 0 (MORE): More frames to follow. A value of 0 indicates that there  *   are no more frames to follow. A value of 1 indicates that more frames  *   will follow. On messages consisting of a single frame the MORE flag MUST  *   be 0.  *  * - Bits 1-7: Reserved. Bits 1-7 are reserved for future use and SHOULD be  *   zero.  */
end_comment

begin_function
specifier|static
specifier|const
name|u_char
modifier|*
name|zmtp1_print_frame
parameter_list|(
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|ep
parameter_list|)
block|{
name|u_int64_t
name|body_len_declared
decl_stmt|,
name|body_len_captured
decl_stmt|,
name|header_len
decl_stmt|;
name|u_int8_t
name|flags
decl_stmt|;
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* length/0xFF */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
name|header_len
operator|=
literal|1
expr_stmt|;
comment|/* length */
name|body_len_declared
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|body_len_declared
operator|==
literal|0
condition|)
return|return
name|cp
operator|+
name|header_len
return|;
comment|/* skip to next frame */
name|printf
argument_list|(
literal|" frame flags+body  (8-bit) length %"
name|PRIu8
literal|""
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* length, flags */
name|flags
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|header_len
operator|=
literal|1
operator|+
literal|8
expr_stmt|;
comment|/* 0xFF, length */
name|printf
argument_list|(
literal|" frame flags+body (64-bit) length"
argument_list|)
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
argument_list|)
expr_stmt|;
comment|/* 0xFF, length */
name|body_len_declared
operator|=
name|EXTRACT_64BITS
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|body_len_declared
operator|==
literal|0
condition|)
return|return
name|cp
operator|+
name|header_len
return|;
comment|/* skip to next frame */
name|printf
argument_list|(
literal|" %"
name|PRIu64
literal|""
argument_list|,
name|body_len_declared
argument_list|)
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 0xFF, length, flags */
name|flags
operator|=
name|cp
index|[
literal|9
index|]
expr_stmt|;
block|}
name|body_len_captured
operator|=
name|ep
operator|-
name|cp
operator|-
name|header_len
expr_stmt|;
if|if
condition|(
name|body_len_declared
operator|>
name|body_len_captured
condition|)
name|printf
argument_list|(
literal|" (%"
name|PRIu64
literal|" captured)"
argument_list|,
name|body_len_captured
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", flags 0x%02"
name|PRIx8
literal|""
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
block|{
name|u_int64_t
name|body_len_printed
init|=
name|MIN
argument_list|(
name|body_len_captured
argument_list|,
name|body_len_declared
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|" (%s|%s|%s|%s|%s|%s|%s|%s)"
argument_list|,
name|flags
operator|&
literal|0x80
condition|?
literal|"MBZ"
else|:
literal|"-"
argument_list|,
name|flags
operator|&
literal|0x40
condition|?
literal|"MBZ"
else|:
literal|"-"
argument_list|,
name|flags
operator|&
literal|0x20
condition|?
literal|"MBZ"
else|:
literal|"-"
argument_list|,
name|flags
operator|&
literal|0x10
condition|?
literal|"MBZ"
else|:
literal|"-"
argument_list|,
name|flags
operator|&
literal|0x08
condition|?
literal|"MBZ"
else|:
literal|"-"
argument_list|,
name|flags
operator|&
literal|0x04
condition|?
literal|"MBZ"
else|:
literal|"-"
argument_list|,
name|flags
operator|&
literal|0x02
condition|?
literal|"MBZ"
else|:
literal|"-"
argument_list|,
name|flags
operator|&
literal|0x01
condition|?
literal|"MORE"
else|:
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|==
literal|1
condition|)
name|body_len_printed
operator|=
name|MIN
argument_list|(
name|VBYTES
operator|+
literal|1
argument_list|,
name|body_len_printed
argument_list|)
expr_stmt|;
if|if
condition|(
name|body_len_printed
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|", first %"
name|PRIu64
literal|" byte(s) of body:"
argument_list|,
name|body_len_printed
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hex_and_ascii_print
argument_list|(
literal|"\n\t "
argument_list|,
name|cp
operator|+
name|header_len
operator|+
literal|1
argument_list|,
name|body_len_printed
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
operator|+
name|body_len_declared
argument_list|)
expr_stmt|;
comment|/* Next frame within the buffer ? */
return|return
name|cp
operator|+
name|header_len
operator|+
name|body_len_declared
return|;
name|trunc
label|:
name|printf
argument_list|(
literal|" [|zmtp1]"
argument_list|)
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_function
name|void
name|zmtp1_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|ep
init|=
name|MIN
argument_list|(
name|snapend
argument_list|,
name|cp
operator|+
name|len
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|": ZMTP/1.0"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
name|cp
operator|=
name|zmtp1_print_frame
argument_list|(
name|cp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

