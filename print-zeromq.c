begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file implements decoding of ZeroMQ network protocol(s).  *  *  * Copyright (c) 2013 The TCPDUMP project  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|NETDISSECT_REWORKED
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tstr
index|[]
init|=
literal|" [|zmtp1]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of ZMTP/1.0 frame body bytes (without the flags) to dump in  * hex and ASCII under a single "-v" flag.  */
end_comment

begin_define
define|#
directive|define
name|VBYTES
value|128
end_define

begin_comment
comment|/*  * Below is an excerpt from the "13/ZMTP" specification:  *  * A ZMTP message consists of 1 or more frames.  *  * A ZMTP frame consists of a length, followed by a flags field and a frame  * body of (length - 1) octets. Note: the length includes the flags field, so  * an empty frame has a length of 1.  *  * For frames with a length of 1 to 254 octets, the length SHOULD BE encoded  * as a single octet. The minimum valid length of a frame is 1 octet, thus a  * length of 0 is invalid and such frames SHOULD be discarded silently.  *  * For frames with lengths of 255 and greater, the length SHALL BE encoded as  * a single octet with the value 255, followed by the length encoded as a  * 64-bit unsigned integer in network byte order. For frames with lengths of  * 1 to 254 octets this encoding MAY be also used.  *  * The flags field consists of a single octet containing various control  * flags. Bit 0 is the least significant bit.  *  * - Bit 0 (MORE): More frames to follow. A value of 0 indicates that there  *   are no more frames to follow. A value of 1 indicates that more frames  *   will follow. On messages consisting of a single frame the MORE flag MUST  *   be 0.  *  * - Bits 1-7: Reserved. Bits 1-7 are reserved for future use and SHOULD be  *   zero.  */
end_comment

begin_function
specifier|static
specifier|const
name|u_char
modifier|*
name|zmtp1_print_frame
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|ep
parameter_list|)
block|{
name|uint64_t
name|body_len_declared
decl_stmt|,
name|body_len_captured
decl_stmt|,
name|header_len
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t"
operator|)
argument_list|)
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* length/0xFF */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
name|header_len
operator|=
literal|1
expr_stmt|;
comment|/* length */
name|body_len_declared
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|body_len_declared
operator|==
literal|0
condition|)
return|return
name|cp
operator|+
name|header_len
return|;
comment|/* skip to next frame */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" frame flags+body  (8-bit) length %u"
operator|,
name|cp
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* length, flags */
name|flags
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|header_len
operator|=
literal|1
operator|+
literal|8
expr_stmt|;
comment|/* 0xFF, length */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" frame flags+body (64-bit) length"
operator|)
argument_list|)
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
argument_list|)
expr_stmt|;
comment|/* 0xFF, length */
name|body_len_declared
operator|=
name|EXTRACT_64BITS
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|body_len_declared
operator|==
literal|0
condition|)
return|return
name|cp
operator|+
name|header_len
return|;
comment|/* skip to next frame */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" %"
name|PRIu64
operator|,
name|body_len_declared
operator|)
argument_list|)
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 0xFF, length, flags */
name|flags
operator|=
name|cp
index|[
literal|9
index|]
expr_stmt|;
block|}
name|body_len_captured
operator|=
name|ep
operator|-
name|cp
operator|-
name|header_len
expr_stmt|;
if|if
condition|(
name|body_len_declared
operator|>
name|body_len_captured
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" (%"
name|PRIu64
literal|" captured)"
operator|,
name|body_len_captured
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|", flags 0x%02x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|uint64_t
name|body_len_printed
init|=
name|min
argument_list|(
name|body_len_captured
argument_list|,
name|body_len_declared
argument_list|)
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" (%s|%s|%s|%s|%s|%s|%s|%s)"
operator|,
name|flags
operator|&
literal|0x80
condition|?
literal|"MBZ"
else|:
literal|"-"
operator|,
name|flags
operator|&
literal|0x40
condition|?
literal|"MBZ"
else|:
literal|"-"
operator|,
name|flags
operator|&
literal|0x20
condition|?
literal|"MBZ"
else|:
literal|"-"
operator|,
name|flags
operator|&
literal|0x10
condition|?
literal|"MBZ"
else|:
literal|"-"
operator|,
name|flags
operator|&
literal|0x08
condition|?
literal|"MBZ"
else|:
literal|"-"
operator|,
name|flags
operator|&
literal|0x04
condition|?
literal|"MBZ"
else|:
literal|"-"
operator|,
name|flags
operator|&
literal|0x02
condition|?
literal|"MBZ"
else|:
literal|"-"
operator|,
name|flags
operator|&
literal|0x01
condition|?
literal|"MORE"
else|:
literal|"-"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|==
literal|1
condition|)
name|body_len_printed
operator|=
name|min
argument_list|(
name|VBYTES
operator|+
literal|1
argument_list|,
name|body_len_printed
argument_list|)
expr_stmt|;
if|if
condition|(
name|body_len_printed
operator|>
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|", first %"
name|PRIu64
literal|" byte(s) of body:"
operator|,
name|body_len_printed
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|hex_and_ascii_print
argument_list|(
name|ndo
argument_list|,
literal|"\n\t "
argument_list|,
name|cp
operator|+
name|header_len
operator|+
literal|1
argument_list|,
name|body_len_printed
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ND_TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
name|header_len
operator|+
name|body_len_declared
argument_list|)
expr_stmt|;
comment|/* Next frame within the buffer ? */
return|return
name|cp
operator|+
name|header_len
operator|+
name|body_len_declared
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_function
name|void
name|zmtp1_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|ep
init|=
name|min
argument_list|(
name|ndo
operator|->
name|ndo_snapend
argument_list|,
name|cp
operator|+
name|len
argument_list|)
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|": ZMTP/1.0"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
name|cp
operator|=
name|zmtp1_print_frame
argument_list|(
name|ndo
argument_list|,
name|cp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions below decode a ZeroMQ datagram, supposedly stored in the "Data"  * field of an ODATA/RDATA [E]PGM packet. An excerpt from zmq_pgm(7) man page  * follows.  *  * In order for late joining consumers to be able to identify message  * boundaries, each PGM datagram payload starts with a 16-bit unsigned integer  * in network byte order specifying either the offset of the first message frame  * in the datagram or containing the value 0xFFFF if the datagram contains  * solely an intermediate part of a larger message.  *  * Note that offset specifies where the first message begins rather than the  * first message part. Thus, if there are trailing message parts at the  * beginning of the packet the offset ignores them and points to first initial  * message part in the packet.  */
end_comment

begin_function
specifier|static
specifier|const
name|u_char
modifier|*
name|zmtp1_print_intermediate_part
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_int
name|len
parameter_list|)
block|{
name|u_int
name|frame_offset
decl_stmt|;
name|uint64_t
name|remaining_len
decl_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|frame_offset
operator|=
name|EXTRACT_16BITS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t frame offset 0x%04x"
operator|,
name|frame_offset
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
name|remaining_len
operator|=
name|ndo
operator|->
name|ndo_snapend
operator|-
name|cp
expr_stmt|;
comment|/* without the frame length */
if|if
condition|(
name|frame_offset
operator|==
literal|0xFFFF
condition|)
name|frame_offset
operator|=
name|len
operator|-
literal|2
expr_stmt|;
comment|/* always within the declared length */
elseif|else
if|if
condition|(
literal|2
operator|+
name|frame_offset
operator|>
name|len
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" (exceeds datagram declared length)"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|trunc
goto|;
block|}
comment|/* offset within declared length of the datagram */
if|if
condition|(
name|frame_offset
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t frame intermediate part, %u bytes"
operator|,
name|frame_offset
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_offset
operator|>
name|remaining_len
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" (%"
name|PRIu64
literal|" captured)"
operator|,
name|remaining_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
condition|)
block|{
name|uint64_t
name|len_printed
init|=
name|min
argument_list|(
name|frame_offset
argument_list|,
name|remaining_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|==
literal|1
condition|)
name|len_printed
operator|=
name|min
argument_list|(
name|VBYTES
argument_list|,
name|len_printed
argument_list|)
expr_stmt|;
if|if
condition|(
name|len_printed
operator|>
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|", first %"
name|PRIu64
literal|" byte(s):"
operator|,
name|len_printed
operator|)
argument_list|)
expr_stmt|;
name|hex_and_ascii_print
argument_list|(
name|ndo
argument_list|,
literal|"\n\t "
argument_list|,
name|cp
argument_list|,
name|len_printed
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|cp
operator|+
name|frame_offset
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
name|cp
operator|+
name|len
return|;
block|}
end_function

begin_function
name|void
name|zmtp1_print_datagram
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|ep
init|=
name|min
argument_list|(
name|ndo
operator|->
name|ndo_snapend
argument_list|,
name|cp
operator|+
name|len
argument_list|)
decl_stmt|;
name|cp
operator|=
name|zmtp1_print_intermediate_part
argument_list|(
name|ndo
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
name|cp
operator|=
name|zmtp1_print_frame
argument_list|(
name|ndo
argument_list|,
name|cp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

