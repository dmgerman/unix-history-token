begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|NAME
value|2
end_define

begin_define
define|#
directive|define
name|STRING
value|3
end_define

begin_define
define|#
directive|define
name|ICON
value|4
end_define

begin_define
define|#
directive|define
name|FCON
value|5
end_define

begin_define
define|#
directive|define
name|PLUS
value|6
end_define

begin_define
define|#
directive|define
name|MINUS
value|8
end_define

begin_define
define|#
directive|define
name|MUL
value|11
end_define

begin_define
define|#
directive|define
name|AND
value|14
end_define

begin_define
define|#
directive|define
name|OR
value|17
end_define

begin_define
define|#
directive|define
name|ER
value|19
end_define

begin_define
define|#
directive|define
name|QUEST
value|21
end_define

begin_define
define|#
directive|define
name|COLON
value|22
end_define

begin_define
define|#
directive|define
name|ANDAND
value|23
end_define

begin_define
define|#
directive|define
name|OROR
value|24
end_define

begin_define
define|#
directive|define
name|ASOP
value|25
end_define

begin_define
define|#
directive|define
name|RELOP
value|26
end_define

begin_define
define|#
directive|define
name|EQUOP
value|27
end_define

begin_define
define|#
directive|define
name|DIVOP
value|28
end_define

begin_define
define|#
directive|define
name|SHIFTOP
value|29
end_define

begin_define
define|#
directive|define
name|INCOP
value|30
end_define

begin_define
define|#
directive|define
name|UNOP
value|31
end_define

begin_define
define|#
directive|define
name|STROP
value|32
end_define

begin_define
define|#
directive|define
name|TYPE
value|33
end_define

begin_define
define|#
directive|define
name|CLASS
value|34
end_define

begin_define
define|#
directive|define
name|STRUCT
value|35
end_define

begin_define
define|#
directive|define
name|RETURN
value|36
end_define

begin_define
define|#
directive|define
name|GOTO
value|37
end_define

begin_define
define|#
directive|define
name|IF
value|38
end_define

begin_define
define|#
directive|define
name|ELSE
value|39
end_define

begin_define
define|#
directive|define
name|SWITCH
value|40
end_define

begin_define
define|#
directive|define
name|BREAK
value|41
end_define

begin_define
define|#
directive|define
name|CONTINUE
value|42
end_define

begin_define
define|#
directive|define
name|WHILE
value|43
end_define

begin_define
define|#
directive|define
name|DO
value|44
end_define

begin_define
define|#
directive|define
name|FOR
value|45
end_define

begin_define
define|#
directive|define
name|DEFAULT
value|46
end_define

begin_define
define|#
directive|define
name|CASE
value|47
end_define

begin_define
define|#
directive|define
name|SIZEOF
value|48
end_define

begin_define
define|#
directive|define
name|ENUM
value|49
end_define

begin_define
define|#
directive|define
name|LP
value|50
end_define

begin_define
define|#
directive|define
name|RP
value|51
end_define

begin_define
define|#
directive|define
name|LC
value|52
end_define

begin_define
define|#
directive|define
name|RC
value|53
end_define

begin_define
define|#
directive|define
name|LB
value|54
end_define

begin_define
define|#
directive|define
name|RB
value|55
end_define

begin_define
define|#
directive|define
name|CM
value|56
end_define

begin_define
define|#
directive|define
name|SM
value|57
end_define

begin_define
define|#
directive|define
name|ASSIGN
value|58
end_define

begin_line
line|#
directive|line
number|108
file|"../mip/cgram.y"
end_line

begin_include
include|#
directive|include
file|"mfile1"
end_include

begin_define
define|#
directive|define
name|yyclearin
value|yychar = -1
end_define

begin_define
define|#
directive|define
name|yyerrok
value|yyerrflag = 0
end_define

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yyerrflag
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|150
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|,
name|yyval
decl_stmt|;
end_decl_stmt

begin_line
line|#
directive|line
number|127
file|"../mip/cgram.y"
end_line

begin_decl_stmt
specifier|static
name|int
name|fake
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fakename
index|[
name|NCHNAM
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_line
line|#
directive|line
number|814
file|"../mip/cgram.y"
end_line

begin_function
name|NODE
modifier|*
name|mkty
parameter_list|(
name|t
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
name|unsigned
name|t
decl_stmt|;
block|{
return|return
operator|(
name|block
argument_list|(
name|TYPE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|bdty
parameter_list|(
name|op
parameter_list|,
name|p
parameter_list|,
name|v
parameter_list|)
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|block
argument_list|(
name|op
argument_list|,
name|p
argument_list|,
name|NIL
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNARY
name|MUL
case|:
case|case
name|UNARY
name|CALL
case|:
break|break;
case|case
name|LB
case|:
name|q
operator|->
name|right
operator|=
name|bcon
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
name|q
operator|->
name|rval
operator|=
name|v
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"bad bdty"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_macro
name|dstash
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* put n into the dimension table */
if|if
condition|(
name|curdim
operator|>=
name|DIMTABSZ
operator|-
literal|1
condition|)
block|{
name|cerror
argument_list|(
literal|"dimension table overflow"
argument_list|)
expr_stmt|;
block|}
name|dimtab
index|[
name|curdim
operator|++
index|]
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|savebc
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|psavbc
operator|>
operator|&
name|asavbc
index|[
name|BCSZ
operator|-
literal|4
index|]
condition|)
block|{
name|cerror
argument_list|(
literal|"whiles, fors, etc. too deeply nested"
argument_list|)
expr_stmt|;
block|}
operator|*
name|psavbc
operator|++
operator|=
name|brklab
expr_stmt|;
operator|*
name|psavbc
operator|++
operator|=
name|contlab
expr_stmt|;
operator|*
name|psavbc
operator|++
operator|=
name|flostat
expr_stmt|;
operator|*
name|psavbc
operator|++
operator|=
name|swx
expr_stmt|;
name|flostat
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|resetbc
argument_list|(
argument|mask
argument_list|)
end_macro

begin_block
block|{
name|swx
operator|=
operator|*
operator|--
name|psavbc
expr_stmt|;
name|flostat
operator|=
operator|*
operator|--
name|psavbc
operator||
operator|(
name|flostat
operator|&
name|mask
operator|)
expr_stmt|;
name|contlab
operator|=
operator|*
operator|--
name|psavbc
expr_stmt|;
name|brklab
operator|=
operator|*
operator|--
name|psavbc
expr_stmt|;
block|}
end_block

begin_macro
name|addcase
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* add case to switch */
name|p
operator|=
name|optim
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* change enum to ints */
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|ICON
condition|)
block|{
name|uerror
argument_list|(
literal|"non-constant case expression"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swp
operator|==
name|swtab
condition|)
block|{
name|uerror
argument_list|(
literal|"case not in switch"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swp
operator|>=
operator|&
name|swtab
index|[
name|SWITSZ
index|]
condition|)
block|{
name|cerror
argument_list|(
literal|"switch table overflow"
argument_list|)
expr_stmt|;
block|}
name|swp
operator|->
name|sval
operator|=
name|p
operator|->
name|lval
expr_stmt|;
name|deflab
argument_list|(
name|swp
operator|->
name|slab
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|swp
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|adddef
argument_list|()
end_macro

begin_block
block|{
comment|/* add default case to switch */
if|if
condition|(
name|swtab
index|[
name|swx
index|]
operator|.
name|slab
operator|>=
literal|0
condition|)
block|{
name|uerror
argument_list|(
literal|"duplicate default in switch"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|swp
operator|==
name|swtab
condition|)
block|{
name|uerror
argument_list|(
literal|"default not inside switch"
argument_list|)
expr_stmt|;
return|return;
block|}
name|deflab
argument_list|(
name|swtab
index|[
name|swx
index|]
operator|.
name|slab
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|swstart
argument_list|()
end_macro

begin_block
block|{
comment|/* begin a switch block */
if|if
condition|(
name|swp
operator|>=
operator|&
name|swtab
index|[
name|SWITSZ
index|]
condition|)
block|{
name|cerror
argument_list|(
literal|"switch table overflow"
argument_list|)
expr_stmt|;
block|}
name|swx
operator|=
name|swp
operator|-
name|swtab
expr_stmt|;
name|swp
operator|->
name|slab
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|swp
expr_stmt|;
block|}
end_block

begin_macro
name|swend
argument_list|()
end_macro

begin_block
block|{
comment|/* end a switch block */
specifier|register
name|struct
name|sw
modifier|*
name|swbeg
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|r1
decl_stmt|;
name|CONSZ
name|temp
decl_stmt|;
name|int
name|tempi
decl_stmt|;
name|swbeg
operator|=
operator|&
name|swtab
index|[
name|swx
operator|+
literal|1
index|]
expr_stmt|;
comment|/* sort */
name|r1
operator|=
name|swbeg
expr_stmt|;
name|r
operator|=
name|swp
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|swbeg
operator|<
name|r
condition|)
block|{
comment|/* bubble largest to end */
for|for
control|(
name|q
operator|=
name|swbeg
init|;
name|q
operator|<
name|r
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|sval
operator|>
operator|(
name|q
operator|+
literal|1
operator|)
operator|->
name|sval
condition|)
block|{
comment|/* swap */
name|r1
operator|=
name|q
operator|+
literal|1
expr_stmt|;
name|temp
operator|=
name|q
operator|->
name|sval
expr_stmt|;
name|q
operator|->
name|sval
operator|=
name|r1
operator|->
name|sval
expr_stmt|;
name|r1
operator|->
name|sval
operator|=
name|temp
expr_stmt|;
name|tempi
operator|=
name|q
operator|->
name|slab
expr_stmt|;
name|q
operator|->
name|slab
operator|=
name|r1
operator|->
name|slab
expr_stmt|;
name|r1
operator|->
name|slab
operator|=
name|tempi
expr_stmt|;
block|}
block|}
name|r
operator|=
name|r1
expr_stmt|;
name|r1
operator|=
name|swbeg
expr_stmt|;
block|}
comment|/* it is now sorted */
for|for
control|(
name|p
operator|=
name|swbeg
operator|+
literal|1
init|;
name|p
operator|<
name|swp
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|p
operator|->
name|sval
operator|==
operator|(
name|p
operator|-
literal|1
operator|)
operator|->
name|sval
condition|)
block|{
name|uerror
argument_list|(
literal|"duplicate case in switch, %d"
argument_list|,
name|tempi
operator|=
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|genswitch
argument_list|(
name|swbeg
operator|-
literal|1
argument_list|,
name|swp
operator|-
name|swbeg
argument_list|)
expr_stmt|;
name|swp
operator|=
name|swbeg
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|short
name|yyexca
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYNPROD
value|184
end_define

begin_define
define|#
directive|define
name|YYLAST
value|1232
end_define

begin_decl_stmt
specifier|extern
name|short
name|yyact
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yypact
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yypgo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yyr1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yyr2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yychk
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yydef
index|[]
decl_stmt|;
end_decl_stmt

begin_empty
empty|#
end_empty

begin_define
define|#
directive|define
name|YYFLAG
value|-1000
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|return(0)
end_define

begin_define
define|#
directive|define
name|YYABORT
value|return(1)
end_define

begin_comment
comment|/*	parser for yacc output	*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYDEBUG
end_ifdef

begin_decl_stmt
name|int
name|yydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for debugging */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|YYSTYPE
name|yyv
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where the values are stored */
end_comment

begin_decl_stmt
name|int
name|yychar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input token number */
end_comment

begin_decl_stmt
name|int
name|yynerrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors */
end_comment

begin_decl_stmt
name|short
name|yyerrflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error recovery flag */
end_comment

begin_macro
name|yyparse
argument_list|()
end_macro

begin_block
block|{
name|short
name|yys
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
name|short
name|yyj
decl_stmt|,
name|yym
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yypvt
decl_stmt|;
specifier|register
name|short
name|yystate
decl_stmt|,
modifier|*
name|yyps
decl_stmt|,
name|yyn
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yypv
decl_stmt|;
specifier|register
name|short
modifier|*
name|yyxi
decl_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yyerrflag
operator|=
literal|0
expr_stmt|;
name|yyps
operator|=
operator|&
name|yys
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|yypv
operator|=
operator|&
name|yyv
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|yystack
label|:
comment|/* put a state and value onto the stack */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"state %d, char 0%o\n"
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|yyps
operator|>
operator|&
name|yys
index|[
name|YYMAXDEPTH
index|]
condition|)
block|{
name|yyerror
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|yyps
operator|=
name|yystate
expr_stmt|;
operator|++
name|yypv
expr_stmt|;
operator|*
name|yypv
operator|=
name|yyval
expr_stmt|;
name|yynewstate
label|:
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|<=
name|YYFLAG
condition|)
goto|goto
name|yydefault
goto|;
comment|/* simple state */
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|<
literal|0
operator|||
name|yyn
operator|>=
name|YYLAST
condition|)
goto|goto
name|yydefault
goto|;
if|if
condition|(
name|yychk
index|[
name|yyn
operator|=
name|yyact
index|[
name|yyn
index|]
index|]
operator|==
name|yychar
condition|)
block|{
comment|/* valid shift */
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
name|yyval
operator|=
name|yylval
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yystack
goto|;
block|}
name|yydefault
label|:
comment|/* default state action */
if|if
condition|(
operator|(
name|yyn
operator|=
name|yydef
index|[
name|yystate
index|]
operator|)
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
comment|/* look through exception table */
for|for
control|(
name|yyxi
operator|=
name|yyexca
init|;
operator|(
operator|*
name|yyxi
operator|!=
operator|(
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|yyxi
index|[
literal|1
index|]
operator|!=
name|yystate
operator|)
condition|;
name|yyxi
operator|+=
literal|2
control|)
empty_stmt|;
comment|/* VOID */
while|while
condition|(
operator|*
operator|(
name|yyxi
operator|+=
literal|2
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|yyxi
operator|==
name|yychar
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yyxi
index|[
literal|1
index|]
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* accept */
block|}
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
block|{
comment|/* error */
comment|/* error ... attempt to resume parsing */
switch|switch
condition|(
name|yyerrflag
condition|)
block|{
case|case
literal|0
case|:
comment|/* brand new error */
name|yyerror
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
name|yyerrlab
label|:
operator|++
name|yynerrs
expr_stmt|;
case|case
literal|1
case|:
case|case
literal|2
case|:
comment|/* incompletely recovered error ... try again */
name|yyerrflag
operator|=
literal|3
expr_stmt|;
comment|/* find a state where "error" is a legal shift action */
while|while
condition|(
name|yyps
operator|>=
name|yys
condition|)
block|{
name|yyn
operator|=
name|yypact
index|[
operator|*
name|yyps
index|]
operator|+
name|YYERRCODE
expr_stmt|;
if|if
condition|(
name|yyn
operator|>=
literal|0
operator|&&
name|yyn
operator|<
name|YYLAST
operator|&&
name|yychk
index|[
name|yyact
index|[
name|yyn
index|]
index|]
operator|==
name|YYERRCODE
condition|)
block|{
name|yystate
operator|=
name|yyact
index|[
name|yyn
index|]
expr_stmt|;
comment|/* simulate a shift of "error" */
goto|goto
name|yystack
goto|;
block|}
name|yyn
operator|=
name|yypact
index|[
operator|*
name|yyps
index|]
expr_stmt|;
comment|/* the current yyps has no shift onn "error", pop stack */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"error recovery pops state %d, uncovers %d\n"
argument_list|,
operator|*
name|yyps
argument_list|,
name|yyps
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|yyps
expr_stmt|;
operator|--
name|yypv
expr_stmt|;
block|}
comment|/* there is no state on the stack with an error shift ... abort */
name|yyabort
label|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|3
case|:
comment|/* no shift yet; clobber input char */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"error recovery discards char %d\n"
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yychar
operator|==
literal|0
condition|)
goto|goto
name|yyabort
goto|;
comment|/* don't discard EOF, quit */
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/* try again in the same state */
block|}
block|}
comment|/* reduction by production yyn */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"reduce %d\n"
argument_list|,
name|yyn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyps
operator|-=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
name|yypvt
operator|=
name|yypv
expr_stmt|;
name|yypv
operator|-=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
name|yyval
operator|=
name|yypv
index|[
literal|1
index|]
expr_stmt|;
name|yym
operator|=
name|yyn
expr_stmt|;
comment|/* consult goto table to find next state */
name|yyn
operator|=
name|yyr1
index|[
name|yyn
index|]
expr_stmt|;
name|yyj
operator|=
name|yypgo
index|[
name|yyn
index|]
operator|+
operator|*
name|yyps
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|yyj
operator|>=
name|YYLAST
operator|||
name|yychk
index|[
name|yystate
operator|=
name|yyact
index|[
name|yyj
index|]
index|]
operator|!=
operator|-
name|yyn
condition|)
name|yystate
operator|=
name|yyact
index|[
name|yypgo
index|[
name|yyn
index|]
index|]
expr_stmt|;
switch|switch
condition|(
name|yym
condition|)
block|{
case|case
literal|2
case|:
line|#
directive|line
number|133
file|"../mip/cgram.y"
name|ftnend
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
line|#
directive|line
number|136
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
name|blevel
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
line|#
directive|line
number|138
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
name|blevel
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
line|#
directive|line
number|142
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
line|#
directive|line
number|144
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
line|#
directive|line
number|145
file|"../mip/cgram.y"
block|{
name|defid
argument_list|(
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
argument_list|,
name|curclass
operator|==
name|STATIC
condition|?
name|STATIC
else|:
name|EXTDEF
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LINT
name|pfstab
argument_list|(
name|stab
index|[
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|rval
index|]
operator|.
name|sname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
literal|8
case|:
line|#
directive|line
number|151
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|blevel
condition|)
name|cerror
argument_list|(
literal|"function level error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reached
condition|)
name|retstat
operator||=
name|NRETVAL
expr_stmt|;
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|ftnend
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
line|#
directive|line
number|162
file|"../mip/cgram.y"
block|{
name|blevel
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|13
case|:
line|#
directive|line
number|167
file|"../mip/cgram.y"
block|{
name|bccode
argument_list|()
expr_stmt|;
name|locctr
argument_list|(
name|PROG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|14
case|:
line|#
directive|line
number|173
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
ifndef|#
directive|ifndef
name|LINT
name|plcstab
argument_list|(
name|blevel
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
literal|15
case|:
line|#
directive|line
number|179
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
ifndef|#
directive|ifndef
name|LINT
name|plcstab
argument_list|(
name|blevel
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
literal|16
case|:
line|#
directive|line
number|187
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|17
case|:
line|#
directive|line
number|189
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|19
case|:
line|#
directive|line
number|193
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
line|#
directive|line
number|195
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|21
case|:
line|#
directive|line
number|197
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
block|}
break|break;
case|case
literal|23
case|:
line|#
directive|line
number|201
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|mkty
argument_list|(
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|curclass
operator|=
name|SNULL
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
line|#
directive|line
number|204
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
expr_stmt|;
block|}
break|break;
case|case
literal|26
case|:
line|#
directive|line
number|207
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|mkty
argument_list|(
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|27
case|:
line|#
directive|line
number|209
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
block|}
break|break;
case|case
literal|28
case|:
line|#
directive|line
number|214
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
expr_stmt|;
block|}
break|break;
case|case
literal|30
case|:
line|#
directive|line
number|219
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|type
operator|=
name|types
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|type
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|type
argument_list|,
name|UNDEF
argument_list|)
expr_stmt|;
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|31
case|:
line|#
directive|line
number|223
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
operator|->
name|type
operator|=
name|types
argument_list|(
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
operator|->
name|type
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|type
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|type
argument_list|)
expr_stmt|;
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|34
case|:
line|#
directive|line
number|231
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|dclstruct
argument_list|(
name|yypvt
index|[
operator|-
literal|4
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|35
case|:
line|#
directive|line
number|233
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|rstruct
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stwart
operator|=
name|instruct
expr_stmt|;
block|}
break|break;
case|case
literal|36
case|:
line|#
directive|line
number|237
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|bstruct
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|37
case|:
line|#
directive|line
number|239
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|bstruct
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|40
case|:
line|#
directive|line
number|247
file|"../mip/cgram.y"
block|{
name|moedef
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|41
case|:
line|#
directive|line
number|249
file|"../mip/cgram.y"
block|{
name|strucoff
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
expr_stmt|;
name|moedef
argument_list|(
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|42
case|:
line|#
directive|line
number|253
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|dclstruct
argument_list|(
name|yypvt
index|[
operator|-
literal|4
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|43
case|:
line|#
directive|line
number|255
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|rstruct
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|44
case|:
line|#
directive|line
number|259
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|bstruct
argument_list|(
operator|-
literal|1
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|stwart
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|45
case|:
line|#
directive|line
number|261
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|bstruct
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|stwart
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|48
case|:
line|#
directive|line
number|269
file|"../mip/cgram.y"
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
name|stwart
operator|=
literal|0
expr_stmt|;
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|49
case|:
line|#
directive|line
number|271
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|curclass
operator|!=
name|MOU
condition|)
block|{
name|curclass
operator|=
name|SNULL
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|fakename
argument_list|,
literal|"$%dFAKE"
argument_list|,
name|fake
operator|++
argument_list|)
expr_stmt|;
name|defid
argument_list|(
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|,
name|bdty
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|lookup
argument_list|(
name|fakename
argument_list|,
name|SMOS
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|curclass
argument_list|)
expr_stmt|;
block|}
name|stwart
operator|=
literal|0
expr_stmt|;
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|50
case|:
line|#
directive|line
number|285
file|"../mip/cgram.y"
block|{
name|defid
argument_list|(
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
argument_list|,
name|curclass
argument_list|)
expr_stmt|;
name|stwart
operator|=
name|instruct
expr_stmt|;
block|}
break|break;
case|case
literal|51
case|:
line|#
directive|line
number|286
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
expr_stmt|;
block|}
break|break;
case|case
literal|52
case|:
line|#
directive|line
number|287
file|"../mip/cgram.y"
block|{
name|defid
argument_list|(
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|4
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
argument_list|,
name|curclass
argument_list|)
expr_stmt|;
name|stwart
operator|=
name|instruct
expr_stmt|;
block|}
break|break;
case|case
literal|55
case|:
line|#
directive|line
number|293
file|"../mip/cgram.y"
block|{
if|if
condition|(
operator|!
operator|(
name|instruct
operator|&
name|INSTRUCT
operator|)
condition|)
name|uerror
argument_list|(
literal|"field outside of structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
operator|<
literal|0
operator|||
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
operator|>=
name|FIELD
condition|)
block|{
name|uerror
argument_list|(
literal|"illegal field size"
argument_list|)
expr_stmt|;
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
operator|=
literal|1
expr_stmt|;
block|}
name|defid
argument_list|(
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|)
argument_list|,
name|FIELD
operator||
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|=
name|NIL
expr_stmt|;
block|}
break|break;
case|case
literal|56
case|:
line|#
directive|line
number|303
file|"../mip/cgram.y"
block|{
if|if
condition|(
operator|!
operator|(
name|instruct
operator|&
name|INSTRUCT
operator|)
condition|)
name|uerror
argument_list|(
literal|"field outside of structure"
argument_list|)
expr_stmt|;
name|falloc
argument_list|(
name|stab
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|,
operator|-
literal|1
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
comment|/* alignment or hole */
name|yyval
operator|.
name|nodep
operator|=
name|NIL
expr_stmt|;
block|}
break|break;
case|case
literal|57
case|:
line|#
directive|line
number|308
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|NIL
expr_stmt|;
block|}
break|break;
case|case
literal|58
case|:
line|#
directive|line
number|313
file|"../mip/cgram.y"
block|{
name|umul
label|:
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
argument|UNARY MUL
argument_list|,
argument|yypvt[-
literal|0
argument|].nodep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|59
case|:
line|#
directive|line
number|316
file|"../mip/cgram.y"
block|{
name|uftn
label|:
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
argument|UNARY CALL
argument_list|,
argument|yypvt[-
literal|2
argument|].nodep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|60
case|:
line|#
directive|line
number|319
file|"../mip/cgram.y"
block|{
name|uary
label|:
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
name|LB
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|61
case|:
line|#
directive|line
number|322
file|"../mip/cgram.y"
block|{
name|bary
label|:
if|if
condition|(
operator|(
name|int
operator|)
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
operator|<=
literal|0
condition|)
name|werror
argument_list|(
literal|"zero or negative subscript"
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
name|LB
argument_list|,
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|62
case|:
line|#
directive|line
number|326
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|63
case|:
line|#
directive|line
number|328
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
expr_stmt|;
block|}
break|break;
case|case
literal|64
case|:
line|#
directive|line
number|331
file|"../mip/cgram.y"
block|{
goto|goto
name|umul
goto|;
block|}
break|break;
case|case
literal|65
case|:
line|#
directive|line
number|333
file|"../mip/cgram.y"
block|{
goto|goto
name|uftn
goto|;
block|}
break|break;
case|case
literal|66
case|:
line|#
directive|line
number|335
file|"../mip/cgram.y"
block|{
goto|goto
name|uary
goto|;
block|}
break|break;
case|case
literal|67
case|:
line|#
directive|line
number|337
file|"../mip/cgram.y"
block|{
goto|goto
name|bary
goto|;
block|}
break|break;
case|case
literal|68
case|:
line|#
directive|line
number|339
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
expr_stmt|;
block|}
break|break;
case|case
literal|69
case|:
line|#
directive|line
number|341
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|blevel
operator|!=
literal|0
condition|)
name|uerror
argument_list|(
literal|"function declaration in bad context"
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
argument|UNARY CALL
argument_list|,
argument|bdty(NAME,NIL,yypvt[-
literal|2
argument|].intval)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stwart
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|70
case|:
line|#
directive|line
number|347
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
argument|UNARY CALL
argument_list|,
argument|bdty(NAME,NIL,yypvt[-
literal|1
argument|].intval)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stwart
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|71
case|:
line|#
directive|line
number|354
file|"../mip/cgram.y"
block|{
comment|/* turn off typedefs for argument names */
name|stwart
operator|=
name|SEENAME
expr_stmt|;
block|}
break|break;
case|case
literal|72
case|:
line|#
directive|line
number|361
file|"../mip/cgram.y"
block|{
name|ftnarg
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|stwart
operator|=
name|SEENAME
expr_stmt|;
block|}
break|break;
case|case
literal|73
case|:
line|#
directive|line
number|363
file|"../mip/cgram.y"
block|{
name|ftnarg
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|stwart
operator|=
name|SEENAME
expr_stmt|;
block|}
break|break;
case|case
literal|75
case|:
line|#
directive|line
number|368
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
expr_stmt|;
block|}
break|break;
case|case
literal|77
case|:
line|#
directive|line
number|372
file|"../mip/cgram.y"
block|{
name|defid
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|=
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
argument_list|,
name|curclass
argument_list|)
expr_stmt|;
name|beginit
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|rval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|79
case|:
line|#
directive|line
number|379
file|"../mip/cgram.y"
block|{
name|nidcl
argument_list|(
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|80
case|:
line|#
directive|line
number|381
file|"../mip/cgram.y"
block|{
name|defid
argument_list|(
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
argument_list|,
name|uclass
argument_list|(
name|curclass
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|81
case|:
line|#
directive|line
number|385
file|"../mip/cgram.y"
block|{
name|doinit
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
name|endinit
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|82
case|:
line|#
directive|line
number|388
file|"../mip/cgram.y"
block|{
name|endinit
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|85
case|:
line|#
directive|line
number|397
file|"../mip/cgram.y"
block|{
name|doinit
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|86
case|:
line|#
directive|line
number|399
file|"../mip/cgram.y"
block|{
name|irbrace
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|91
case|:
line|#
directive|line
number|411
file|"../mip/cgram.y"
block|{
name|werror
argument_list|(
literal|"old-fashioned initialization: use ="
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|93
case|:
line|#
directive|line
number|416
file|"../mip/cgram.y"
block|{
name|ilbrace
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|96
case|:
line|#
directive|line
number|426
file|"../mip/cgram.y"
block|{
ifndef|#
directive|ifndef
name|LINT
name|prcstab
argument_list|(
name|blevel
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|blevel
expr_stmt|;
if|if
condition|(
name|blevel
operator|==
literal|1
condition|)
name|blevel
operator|=
literal|0
expr_stmt|;
name|clearst
argument_list|(
name|blevel
argument_list|)
expr_stmt|;
name|checkst
argument_list|(
name|blevel
argument_list|)
expr_stmt|;
name|autooff
operator|=
operator|*
operator|--
name|psavbc
expr_stmt|;
name|regvar
operator|=
operator|*
operator|--
name|psavbc
expr_stmt|;
block|}
break|break;
case|case
literal|97
case|:
line|#
directive|line
number|440
file|"../mip/cgram.y"
block|{
operator|--
name|blevel
expr_stmt|;
if|if
condition|(
name|blevel
operator|==
literal|1
condition|)
name|blevel
operator|=
literal|0
expr_stmt|;
name|clearst
argument_list|(
name|blevel
argument_list|)
expr_stmt|;
name|checkst
argument_list|(
name|blevel
argument_list|)
expr_stmt|;
name|autooff
operator|=
operator|*
operator|--
name|psavbc
expr_stmt|;
name|regvar
operator|=
operator|*
operator|--
name|psavbc
expr_stmt|;
block|}
break|break;
case|case
literal|98
case|:
line|#
directive|line
number|450
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|blevel
operator|==
literal|1
condition|)
name|dclargs
argument_list|()
expr_stmt|;
operator|++
name|blevel
expr_stmt|;
if|if
condition|(
name|psavbc
operator|>
operator|&
name|asavbc
index|[
name|BCSZ
operator|-
literal|2
index|]
condition|)
name|cerror
argument_list|(
literal|"nesting too deep"
argument_list|)
expr_stmt|;
operator|*
name|psavbc
operator|++
operator|=
name|regvar
expr_stmt|;
operator|*
name|psavbc
operator|++
operator|=
name|autooff
expr_stmt|;
block|}
break|break;
case|case
literal|99
case|:
line|#
directive|line
number|459
file|"../mip/cgram.y"
block|{
name|ecomp
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|101
case|:
line|#
directive|line
number|462
file|"../mip/cgram.y"
block|{
name|deflab
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|102
case|:
line|#
directive|line
number|466
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
operator|!=
name|NOLAB
condition|)
block|{
name|deflab
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|103
case|:
line|#
directive|line
number|472
file|"../mip/cgram.y"
block|{
name|branch
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flostat
operator|&
name|FBRK
operator|)
operator|||
operator|!
operator|(
name|flostat
operator|&
name|FLOOP
operator|)
condition|)
name|reached
operator|=
literal|1
expr_stmt|;
else|else
name|reached
operator|=
literal|0
expr_stmt|;
name|resetbc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|104
case|:
line|#
directive|line
number|479
file|"../mip/cgram.y"
block|{
name|deflab
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
if|if
condition|(
name|flostat
operator|&
name|FCONT
condition|)
name|reached
operator|=
literal|1
expr_stmt|;
name|ecomp
argument_list|(
name|buildtree
argument_list|(
name|CBRANCH
argument_list|,
name|buildtree
argument_list|(
name|NOT
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|bcon
argument_list|(
name|yypvt
index|[
operator|-
literal|6
index|]
operator|.
name|intval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
name|resetbc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|105
case|:
line|#
directive|line
number|487
file|"../mip/cgram.y"
block|{
name|deflab
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
if|if
condition|(
name|flostat
operator|&
name|FCONT
condition|)
name|reached
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
condition|)
name|ecomp
argument_list|(
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flostat
operator|&
name|FBRK
operator|)
operator|||
operator|!
operator|(
name|flostat
operator|&
name|FLOOP
operator|)
condition|)
name|reached
operator|=
literal|1
expr_stmt|;
else|else
name|reached
operator|=
literal|0
expr_stmt|;
name|resetbc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|106
case|:
line|#
directive|line
number|497
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|reached
condition|)
name|branch
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|swend
argument_list|()
expr_stmt|;
name|deflab
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flostat
operator|&
name|FBRK
operator|)
operator|||
operator|!
operator|(
name|flostat
operator|&
name|FDEF
operator|)
condition|)
name|reached
operator|=
literal|1
expr_stmt|;
name|resetbc
argument_list|(
name|FCONT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|107
case|:
line|#
directive|line
number|505
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|brklab
operator|==
name|NOLAB
condition|)
name|uerror
argument_list|(
literal|"illegal break"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reached
condition|)
name|branch
argument_list|(
name|brklab
argument_list|)
expr_stmt|;
name|flostat
operator||=
name|FBRK
expr_stmt|;
if|if
condition|(
name|brkflag
condition|)
goto|goto
name|rch
goto|;
name|reached
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|108
case|:
line|#
directive|line
number|512
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|contlab
operator|==
name|NOLAB
condition|)
name|uerror
argument_list|(
literal|"illegal continue"
argument_list|)
expr_stmt|;
else|else
name|branch
argument_list|(
name|contlab
argument_list|)
expr_stmt|;
name|flostat
operator||=
name|FCONT
expr_stmt|;
goto|goto
name|rch
goto|;
block|}
break|break;
case|case
literal|109
case|:
line|#
directive|line
number|518
file|"../mip/cgram.y"
block|{
name|retstat
operator||=
name|NRETVAL
expr_stmt|;
name|branch
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
name|rch
label|:
if|if
condition|(
operator|!
name|reached
condition|)
name|werror
argument_list|(
literal|"statement not reached"
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|110
case|:
line|#
directive|line
number|525
file|"../mip/cgram.y"
block|{
specifier|register
name|NODE
modifier|*
name|temp
decl_stmt|;
name|idname
operator|=
name|curftn
expr_stmt|;
name|temp
operator|=
name|buildtree
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|DECREF
argument_list|(
name|temp
operator|->
name|type
argument_list|)
expr_stmt|;
name|temp
operator|=
name|buildtree
argument_list|(
name|RETURN
argument_list|,
name|temp
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
comment|/* now, we have the type of the RHS correct */
name|temp
operator|->
name|left
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|temp
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|ecomp
argument_list|(
name|buildtree
argument_list|(
name|FORCE
argument_list|,
name|temp
operator|->
name|right
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
name|retstat
operator||=
name|RETVAL
expr_stmt|;
name|branch
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|111
case|:
line|#
directive|line
number|539
file|"../mip/cgram.y"
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|INT
operator||
name|ARY
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|idname
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
name|defid
argument_list|(
name|q
argument_list|,
name|ULABEL
argument_list|)
expr_stmt|;
name|stab
index|[
name|idname
index|]
operator|.
name|suse
operator|=
operator|-
name|lineno
expr_stmt|;
name|branch
argument_list|(
name|stab
index|[
name|idname
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|rch
goto|;
block|}
break|break;
case|case
literal|116
case|:
line|#
directive|line
number|553
file|"../mip/cgram.y"
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|INT
operator||
name|ARY
argument_list|,
literal|0
argument_list|,
name|LABEL
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
name|defid
argument_list|(
name|q
argument_list|,
name|LABEL
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|117
case|:
line|#
directive|line
number|560
file|"../mip/cgram.y"
block|{
name|addcase
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|118
case|:
line|#
directive|line
number|564
file|"../mip/cgram.y"
block|{
name|reached
operator|=
literal|1
expr_stmt|;
name|adddef
argument_list|()
expr_stmt|;
name|flostat
operator||=
name|FDEF
expr_stmt|;
block|}
break|break;
case|case
literal|119
case|:
line|#
directive|line
number|570
file|"../mip/cgram.y"
block|{
name|savebc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reached
condition|)
name|werror
argument_list|(
literal|"loop not entered at top"
argument_list|)
expr_stmt|;
name|brklab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|contlab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|deflab
argument_list|(
name|yyval
operator|.
name|intval
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|120
case|:
line|#
directive|line
number|579
file|"../mip/cgram.y"
block|{
name|ecomp
argument_list|(
name|buildtree
argument_list|(
name|CBRANCH
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|bcon
argument_list|(
name|yyval
operator|.
name|intval
operator|=
name|getlab
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|121
case|:
line|#
directive|line
number|584
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|reached
condition|)
name|branch
argument_list|(
name|yyval
operator|.
name|intval
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|yyval
operator|.
name|intval
operator|=
name|NOLAB
expr_stmt|;
name|deflab
argument_list|(
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|intval
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|122
case|:
line|#
directive|line
number|592
file|"../mip/cgram.y"
block|{
name|savebc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reached
condition|)
name|werror
argument_list|(
literal|"loop not entered at top"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|==
name|ICON
operator|&&
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|lval
operator|!=
literal|0
condition|)
name|flostat
operator|=
name|FLOOP
expr_stmt|;
name|deflab
argument_list|(
name|contlab
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
name|brklab
operator|=
name|getlab
argument_list|()
expr_stmt|;
if|if
condition|(
name|flostat
operator|==
name|FLOOP
condition|)
name|tfree
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
else|else
name|ecomp
argument_list|(
name|buildtree
argument_list|(
name|CBRANCH
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|bcon
argument_list|(
name|brklab
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|123
case|:
line|#
directive|line
number|603
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|nodep
condition|)
name|ecomp
argument_list|(
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|reached
condition|)
name|werror
argument_list|(
literal|"loop not entered at top"
argument_list|)
expr_stmt|;
name|savebc
argument_list|()
expr_stmt|;
name|contlab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|brklab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|deflab
argument_list|(
name|yyval
operator|.
name|intval
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
condition|)
name|ecomp
argument_list|(
name|buildtree
argument_list|(
name|CBRANCH
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|bcon
argument_list|(
name|brklab
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|flostat
operator||=
name|FLOOP
expr_stmt|;
block|}
break|break;
case|case
literal|124
case|:
line|#
directive|line
number|615
file|"../mip/cgram.y"
block|{
name|savebc
argument_list|()
expr_stmt|;
name|brklab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|ecomp
argument_list|(
name|buildtree
argument_list|(
name|FORCE
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|yyval
operator|.
name|intval
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|swstart
argument_list|()
expr_stmt|;
name|reached
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|125
case|:
line|#
directive|line
number|624
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|instruct
expr_stmt|;
name|stwart
operator|=
name|instruct
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|126
case|:
line|#
directive|line
number|626
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|intval
operator|=
name|icons
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
name|instruct
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
block|}
break|break;
case|case
literal|128
case|:
line|#
directive|line
number|630
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|130
case|:
line|#
directive|line
number|635
file|"../mip/cgram.y"
block|{
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|131
case|:
line|#
directive|line
number|639
file|"../mip/cgram.y"
block|{
name|preconf
label|:
if|if
condition|(
name|yychar
operator|==
name|RELOP
operator|||
name|yychar
operator|==
name|EQUOP
operator|||
name|yychar
operator|==
name|AND
operator|||
name|yychar
operator|==
name|OR
operator|||
name|yychar
operator|==
name|ER
condition|)
block|{
name|precplaint
label|:
if|if
condition|(
name|hflag
condition|)
name|werror
argument_list|(
literal|"precedence confusion possible: parenthesize!"
argument_list|)
expr_stmt|;
block|}
name|bop
label|:
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|132
case|:
line|#
directive|line
number|649
file|"../mip/cgram.y"
block|{
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
operator|=
name|COMOP
expr_stmt|;
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|133
case|:
line|#
directive|line
number|653
file|"../mip/cgram.y"
block|{
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|134
case|:
line|#
directive|line
number|655
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yychar
operator|==
name|SHIFTOP
condition|)
goto|goto
name|precplaint
goto|;
else|else
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|135
case|:
line|#
directive|line
number|657
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yychar
operator|==
name|SHIFTOP
condition|)
goto|goto
name|precplaint
goto|;
else|else
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|136
case|:
line|#
directive|line
number|659
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yychar
operator|==
name|PLUS
operator|||
name|yychar
operator|==
name|MINUS
condition|)
goto|goto
name|precplaint
goto|;
else|else
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|137
case|:
line|#
directive|line
number|661
file|"../mip/cgram.y"
block|{
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|138
case|:
line|#
directive|line
number|663
file|"../mip/cgram.y"
block|{
goto|goto
name|preconf
goto|;
block|}
break|break;
case|case
literal|139
case|:
line|#
directive|line
number|665
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yychar
operator|==
name|RELOP
operator|||
name|yychar
operator|==
name|EQUOP
condition|)
goto|goto
name|preconf
goto|;
else|else
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|140
case|:
line|#
directive|line
number|667
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yychar
operator|==
name|RELOP
operator|||
name|yychar
operator|==
name|EQUOP
condition|)
goto|goto
name|preconf
goto|;
else|else
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|141
case|:
line|#
directive|line
number|669
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yychar
operator|==
name|RELOP
operator|||
name|yychar
operator|==
name|EQUOP
condition|)
goto|goto
name|preconf
goto|;
else|else
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|142
case|:
line|#
directive|line
number|671
file|"../mip/cgram.y"
block|{
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|143
case|:
line|#
directive|line
number|673
file|"../mip/cgram.y"
block|{
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|144
case|:
line|#
directive|line
number|675
file|"../mip/cgram.y"
block|{
name|abop
label|:
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
argument|ASG yypvt[-
literal|2
argument|].intval
argument_list|,
argument|yypvt[-
literal|3
argument|].nodep
argument_list|,
argument|yypvt[-
literal|0
argument|].nodep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|145
case|:
line|#
directive|line
number|679
file|"../mip/cgram.y"
block|{
goto|goto
name|abop
goto|;
block|}
break|break;
case|case
literal|146
case|:
line|#
directive|line
number|681
file|"../mip/cgram.y"
block|{
goto|goto
name|abop
goto|;
block|}
break|break;
case|case
literal|147
case|:
line|#
directive|line
number|683
file|"../mip/cgram.y"
block|{
goto|goto
name|abop
goto|;
block|}
break|break;
case|case
literal|148
case|:
line|#
directive|line
number|685
file|"../mip/cgram.y"
block|{
goto|goto
name|abop
goto|;
block|}
break|break;
case|case
literal|149
case|:
line|#
directive|line
number|687
file|"../mip/cgram.y"
block|{
goto|goto
name|abop
goto|;
block|}
break|break;
case|case
literal|150
case|:
line|#
directive|line
number|689
file|"../mip/cgram.y"
block|{
goto|goto
name|abop
goto|;
block|}
break|break;
case|case
literal|151
case|:
line|#
directive|line
number|691
file|"../mip/cgram.y"
block|{
goto|goto
name|abop
goto|;
block|}
break|break;
case|case
literal|152
case|:
line|#
directive|line
number|693
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|QUEST
argument_list|,
name|yypvt
index|[
operator|-
literal|4
index|]
operator|.
name|nodep
argument_list|,
name|buildtree
argument_list|(
name|COLON
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|153
case|:
line|#
directive|line
number|696
file|"../mip/cgram.y"
block|{
name|werror
argument_list|(
literal|"old-fashioned assignment operator"
argument_list|)
expr_stmt|;
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|154
case|:
line|#
directive|line
number|698
file|"../mip/cgram.y"
block|{
goto|goto
name|bop
goto|;
block|}
break|break;
case|case
literal|156
case|:
line|#
directive|line
number|702
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|bcon
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|157
case|:
line|#
directive|line
number|704
file|"../mip/cgram.y"
block|{
name|ubop
label|:
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
argument|UNARY yypvt[-
literal|1
argument|].intval
argument_list|,
argument|yypvt[-
literal|0
argument|].nodep
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|158
case|:
line|#
directive|line
number|708
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|ISFTN
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|type
argument_list|)
operator|||
name|ISARY
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
operator|->
name|type
argument_list|)
condition|)
block|{
name|werror
argument_list|(
literal|"& before array or function: ignored"
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
expr_stmt|;
block|}
else|else
goto|goto
name|ubop
goto|;
block|}
break|break;
case|case
literal|159
case|:
line|#
directive|line
number|715
file|"../mip/cgram.y"
block|{
goto|goto
name|ubop
goto|;
block|}
break|break;
case|case
literal|160
case|:
line|#
directive|line
number|717
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|161
case|:
line|#
directive|line
number|721
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
argument|yypvt[-
literal|1
argument|].intval==INCR ? ASG PLUS : ASG MINUS
argument_list|,
argument|yypvt[-
literal|0
argument|].nodep
argument_list|,
argument|bcon(
literal|1
argument|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|162
case|:
line|#
directive|line
number|726
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|doszof
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|163
case|:
line|#
directive|line
number|728
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|CAST
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|->
name|left
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|=
name|yyval
operator|.
name|nodep
operator|->
name|right
expr_stmt|;
block|}
break|break;
case|case
literal|164
case|:
line|#
directive|line
number|734
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|doszof
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|165
case|:
line|#
directive|line
number|736
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
argument|UNARY MUL
argument_list|,
argument|buildtree( PLUS, yypvt[-
literal|3
argument|].nodep, yypvt[-
literal|1
argument|].nodep )
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|166
case|:
line|#
directive|line
number|738
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
argument|UNARY CALL
argument_list|,
argument|yypvt[-
literal|1
argument|].nodep
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|167
case|:
line|#
directive|line
number|740
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|CALL
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|168
case|:
line|#
directive|line
number|742
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
operator|==
name|DOT
condition|)
block|{
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
argument|UNARY AND
argument_list|,
argument|yypvt[-
literal|2
argument|].nodep
argument_list|,
argument|NIL
argument_list|)
expr_stmt|;
block|}
name|idname
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|STREF
argument_list|,
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|nodep
argument_list|,
name|buildtree
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|169
case|:
line|#
directive|line
number|749
file|"../mip/cgram.y"
block|{
name|idname
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
expr_stmt|;
comment|/* recognize identifiers in initializations */
if|if
condition|(
name|blevel
operator|==
literal|0
operator|&&
name|stab
index|[
name|idname
index|]
operator|.
name|stype
operator|==
name|UNDEF
condition|)
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|werror
argument_list|(
literal|"undeclared initializer name %.8s"
argument_list|,
name|stab
index|[
name|idname
index|]
operator|.
name|sname
argument_list|)
expr_stmt|;
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|idname
expr_stmt|;
name|defid
argument_list|(
name|q
argument_list|,
name|EXTERN
argument_list|)
expr_stmt|;
block|}
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|stab
index|[
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
index|]
operator|.
name|suse
operator|=
operator|-
name|lineno
expr_stmt|;
block|}
break|break;
case|case
literal|170
case|:
line|#
directive|line
number|762
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|bcon
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|->
name|lval
operator|=
name|lastcon
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|->
name|rval
operator|=
name|NONAME
expr_stmt|;
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|intval
condition|)
name|yyval
operator|.
name|nodep
operator|->
name|csiz
operator|=
name|yyval
operator|.
name|nodep
operator|->
name|type
operator|=
name|ctype
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|171
case|:
line|#
directive|line
number|768
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|FCON
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|->
name|dval
operator|=
name|dcon
expr_stmt|;
block|}
break|break;
case|case
literal|172
case|:
line|#
directive|line
number|772
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|getstr
argument_list|()
expr_stmt|;
comment|/* get string contents */
block|}
break|break;
case|case
literal|173
case|:
line|#
directive|line
number|774
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
expr_stmt|;
block|}
break|break;
case|case
literal|174
case|:
line|#
directive|line
number|778
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|tymerge
argument_list|(
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|nodep
argument_list|)
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|->
name|op
operator|=
name|NAME
expr_stmt|;
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
literal|175
case|:
line|#
directive|line
number|786
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|176
case|:
line|#
directive|line
number|788
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
argument|UNARY CALL
argument_list|,
argument|bdty(NAME,NIL,-
literal|1
argument|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|177
case|:
line|#
directive|line
number|790
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|bdty
argument_list|(
argument|UNARY CALL
argument_list|,
argument|yypvt[-
literal|3
argument|].nodep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|178
case|:
line|#
directive|line
number|792
file|"../mip/cgram.y"
block|{
goto|goto
name|umul
goto|;
block|}
break|break;
case|case
literal|179
case|:
line|#
directive|line
number|794
file|"../mip/cgram.y"
block|{
goto|goto
name|uary
goto|;
block|}
break|break;
case|case
literal|180
case|:
line|#
directive|line
number|796
file|"../mip/cgram.y"
block|{
goto|goto
name|bary
goto|;
block|}
break|break;
case|case
literal|181
case|:
line|#
directive|line
number|798
file|"../mip/cgram.y"
block|{
name|yyval
operator|.
name|nodep
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|nodep
expr_stmt|;
block|}
break|break;
case|case
literal|182
case|:
line|#
directive|line
number|802
file|"../mip/cgram.y"
block|{
if|if
condition|(
name|stab
index|[
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
index|]
operator|.
name|stype
operator|==
name|UNDEF
condition|)
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|FTN
operator||
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
name|defid
argument_list|(
name|q
argument_list|,
name|EXTERN
argument_list|)
expr_stmt|;
block|}
name|idname
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|intval
expr_stmt|;
name|yyval
operator|.
name|nodep
operator|=
name|buildtree
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|stab
index|[
name|idname
index|]
operator|.
name|suse
operator|=
operator|-
name|lineno
expr_stmt|;
block|}
break|break;
block|}
goto|goto
name|yystack
goto|;
comment|/* stack new state and value */
block|}
end_block

end_unit

