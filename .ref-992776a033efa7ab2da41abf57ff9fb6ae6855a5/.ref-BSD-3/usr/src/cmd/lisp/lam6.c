begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_function
name|FILE
modifier|*
name|mkstFI
parameter_list|(
name|base
parameter_list|,
name|count
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
name|char
name|flag
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|p
init|=
name|stderr
decl_stmt|;
comment|/* find free file descriptor */
for|for
control|(
init|;
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOREAD
operator||
name|_IOWRT
operator|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|>=
name|_iob
operator|+
name|_NFILE
condition|)
name|error
argument_list|(
literal|"Too many open files to do readlist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|_flag
operator|=
name|_IOSTRG
operator||
name|flag
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
name|count
expr_stmt|;
name|p
operator|->
name|_base
operator|=
name|base
expr_stmt|;
name|p
operator|->
name|_ptr
operator|=
name|base
expr_stmt|;
name|p
operator|->
name|_file
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lreadli
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|argent
modifier|*
name|olbot
decl_stmt|;
name|FILE
modifier|*
name|opiport
init|=
name|piport
decl_stmt|;
name|lispval
name|Lread
parameter_list|()
function_decl|;
name|int
name|count
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
block|{
comment|/*effectively, return(matom(""));*/
name|strbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|()
operator|)
return|;
block|}
name|count
operator|=
literal|1
expr_stmt|;
comment|/* compute length of list */
for|for
control|(
name|work
operator|=
name|lbot
operator|->
name|val
init|;
name|TYPE
argument_list|(
name|work
argument_list|)
operator|==
name|DTPR
condition|;
name|work
operator|=
name|work
operator|->
name|cdr
control|)
name|count
operator|++
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkstFI
argument_list|(
name|string
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|_IOREAD
argument_list|)
expr_stmt|;
for|for
control|(
name|work
operator|=
name|lbot
operator|->
name|val
init|;
name|TYPE
argument_list|(
name|work
argument_list|)
operator|==
name|DTPR
condition|;
name|work
operator|=
name|work
operator|->
name|cdr
control|)
block|{
name|handy
operator|=
name|work
operator|->
name|car
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|SDOT
case|:
case|case
name|INT
case|:
operator|*
name|string
operator|++
operator|=
name|handy
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|ATOM
case|:
operator|*
name|string
operator|++
operator|=
operator|*
operator|(
name|handy
operator|->
name|pname
operator|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non atom or int to readlist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|string
operator|=
literal|0
expr_stmt|;
name|olbot
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|=
name|Lread
argument_list|()
expr_stmt|;
name|lbot
operator|=
name|olbot
expr_stmt|;
name|frstFI
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|frstFI
argument_list|(
name|p
argument_list|)
specifier|register
name|FILE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|->
name|_flag
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_base
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_ptr
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_file
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|lispval
name|Lgetenv
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|snpand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mylbot
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"argument to getenv must be atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strbuf
argument_list|,
name|getenv
argument_list|(
name|mylbot
operator|->
name|val
operator|->
name|pname
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lboundp
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mynp
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|,
name|handy
decl_stmt|;
name|snpand
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mynp
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"argument to boundp must be atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|handy
operator|=
name|mynp
operator|->
name|val
operator|)
operator|->
name|clb
operator|==
name|CNIL
condition|)
name|result
operator|=
name|nil
expr_stmt|;
else|else
operator|(
name|result
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|cdr
operator|=
name|handy
operator|->
name|clb
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lplist
parameter_list|()
block|{
specifier|register
name|lispval
name|atm
decl_stmt|;
name|snpand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* get property list of an atom or disembodied property list */
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|atm
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|atm
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
case|case
name|DTPR
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"Only Atoms and disembodied property lists allowed for plist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atm
operator|==
name|nil
condition|)
return|return
operator|(
name|nilplist
operator|)
return|;
return|return
operator|(
name|atm
operator|->
name|plist
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsetpli
parameter_list|()
block|{
comment|/* set the property list of the given atom to the given list */
specifier|register
name|lispval
name|atm
decl_stmt|,
name|vall
decl_stmt|;
specifier|register
name|lispval
name|dum1
decl_stmt|,
name|dum2
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|atm
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|atm
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"First argument must be an atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vall
operator|=
operator|(
name|np
operator|-
literal|1
operator|)
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|vall
argument_list|)
operator|!=
name|DTPR
operator|&&
name|vall
operator|!=
name|nil
condition|)
name|error
argument_list|(
literal|"Second argument must be a list"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm
operator|==
name|nil
condition|)
name|nilplist
operator|=
name|vall
expr_stmt|;
else|else
name|atm
operator|->
name|plist
operator|=
name|vall
expr_stmt|;
return|return
operator|(
name|vall
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsignal
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
specifier|extern
name|lispval
name|sigacts
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|,
name|old
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|handy
operator|=
name|mylbot
index|[
name|AD
index|]
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"First arg to signal must be an int"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|i
operator|=
name|handy
operator|->
name|i
operator|&
literal|15
expr_stmt|;
name|handy
operator|=
name|mylbot
index|[
name|AD
operator|+
literal|1
index|]
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"Second arg to signal must be an atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|old
operator|=
name|sigacts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
condition|)
name|old
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|sigacts
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
expr_stmt|;
else|else
name|sigacts
index|[
name|i
index|]
operator|=
name|handy
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lassq
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|,
name|handy
decl_stmt|,
name|dum1
decl_stmt|,
name|dum2
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|work
operator|=
name|lbot
index|[
name|AD
operator|+
literal|1
index|]
operator|.
name|val
init|;
name|work
operator|->
name|car
operator|->
name|car
operator|!=
name|lbot
operator|->
name|val
operator|&&
name|work
operator|!=
name|nil
condition|;
name|work
operator|=
name|work
operator|->
name|cdr
control|)
empty_stmt|;
return|return
operator|(
name|work
operator|->
name|car
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lkilcopy
parameter_list|()
block|{
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
asm|asm(".byte 0");
block|}
block|}
end_function

begin_function
name|lispval
name|Larg
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|offset
operator|,
name|count
expr_stmt|;
name|snpand
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lexpr_atom
operator|->
name|clb
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|CNIL
operator|||
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|DTPR
condition|)
name|error
argument_list|(
literal|"Arg: not in context of Lexpr."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
name|handy
operator|->
name|cdr
operator|)
operator|-
operator|(
name|long
operator|*
operator|)
name|handy
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|lbot
operator|||
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|count
argument_list|)
operator|)
return|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|||
operator|(
name|offset
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
operator|-
literal|1
operator|)
operator|>
name|count
operator|||
name|offset
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Out of bonds: arg to \"Arg\""
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
expr|struct
name|argent
operator|*
operator|)
name|handy
operator|->
name|car
operator|)
index|[
name|offset
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lptime
parameter_list|()
block|{
specifier|extern
name|int
name|GCtime
decl_stmt|;
name|int
name|lgctime
init|=
name|GCtime
decl_stmt|;
specifier|static
struct|struct
name|tbuf
block|{
name|long
name|mytime
decl_stmt|;
name|long
name|allelse
index|[
literal|3
index|]
decl_stmt|;
block|}
name|current
struct|;
specifier|register
name|lispval
name|result
decl_stmt|,
name|handy
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|times
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
name|result
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|=
name|result
expr_stmt|;
name|protect
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|->
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|result
operator|->
name|car
operator|=
name|inewint
argument_list|(
name|current
operator|.
name|mytime
argument_list|)
expr_stmt|;
name|handy
operator|=
name|result
operator|->
name|cdr
expr_stmt|;
name|handy
operator|->
name|car
operator|=
name|inewint
argument_list|(
name|lgctime
argument_list|)
expr_stmt|;
name|handy
operator|->
name|cdr
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|GCtime
operator|==
literal|0
condition|)
name|GCtime
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* (err [value] [flag])     where if value is present, it is the value to throw to the errset.    flag if present must evaluate to nil, as we always evaluate value    before unwinding stack  */
end_comment

begin_function
name|lispval
name|Lerr
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
name|errorh
parameter_list|()
function_decl|;
name|char
modifier|*
name|mesg
init|=
literal|"call to err"
decl_stmt|;
comment|/* default message */
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|>=
name|lbot
operator|+
literal|2
operator|)
operator|&&
operator|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|!=
name|nil
operator|)
condition|)
name|error
argument_list|(
literal|"Second arg to err must be nil"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbot
operator|->
name|val
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|ATOM
operator|)
condition|)
name|mesg
operator|=
name|lbot
operator|->
name|val
operator|->
name|pname
expr_stmt|;
comment|/* new message if atom */
return|return
operator|(
name|errorh
argument_list|(
name|Vererr
argument_list|,
name|mesg
argument_list|,
name|lbot
operator|->
name|val
argument_list|,
name|nil
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltyi
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|char
name|val
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|okport
argument_list|(
name|Vpiport
operator|->
name|clb
argument_list|,
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* flush any pending output characters */
name|val
operator|=
name|getc
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltyipeek
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|char
name|val
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|okport
argument_list|(
name|Vpiport
operator|->
name|clb
argument_list|,
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* flush any pending output characters */
name|val
operator|=
name|getc
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|val
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltyo
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|,
name|where
decl_stmt|;
specifier|register
name|char
name|val
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"Tyo demands number for 1st arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|val
operator|=
name|handy
operator|->
name|i
expr_stmt|;
name|where
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|port
operator|=
operator|(
name|FILE
operator|*
operator|)
name|okport
argument_list|(
name|where
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|val
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Imkrtab
parameter_list|(
name|current
parameter_list|)
block|{
specifier|extern
struct|struct
name|rtab
block|{
name|char
name|ctable
index|[
literal|132
index|]
decl_stmt|;
block|}
name|initread
struct|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|extern
name|lispval
name|lastrtab
decl_stmt|;
specifier|static
name|int
name|cycle
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|nextfree
decl_stmt|;
if|if
condition|(
operator|(
name|cycle
operator|++
operator|)
operator|%
literal|3
operator|==
literal|0
condition|)
block|{
name|nextfree
operator|=
operator|(
name|char
operator|*
operator|)
name|csegment
argument_list|(
name|int_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
block|}
name|handy
operator|=
name|newarray
argument_list|()
expr_stmt|;
name|handy
operator|->
name|data
operator|=
name|nextfree
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
operator|*
operator|(
expr|struct
name|rtab
operator|*
operator|)
name|nextfree
operator|=
name|initread
expr_stmt|;
else|else
operator|*
operator|(
expr|struct
name|rtab
operator|*
operator|)
name|nextfree
operator|=
operator|*
operator|(
expr|struct
name|rtab
operator|*
operator|)
name|ctable
expr_stmt|;
name|handy
operator|->
name|delta
operator|=
name|inewint
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|handy
operator|->
name|length
operator|=
name|inewint
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|handy
operator|->
name|accfun
operator|=
name|handy
operator|->
name|aux
operator|=
name|nil
expr_stmt|;
name|nextfree
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|rtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* makereadtable - arg : t or nil 	returns a readtable, t means return a copy of the initial readtable  			     nil means return a copy of the current readtable */
end_comment

begin_function
name|lispval
name|Lmakertbl
parameter_list|()
block|{
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
name|error
argument_list|(
literal|"makereadtable: wrong number of args"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"makereadtable: arg must be atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
return|return
operator|(
name|Imkrtab
argument_list|(
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|Imkrtab
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcpy1
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
init|=
name|lbot
operator|->
name|val
decl_stmt|,
name|result
init|=
name|handy
decl_stmt|;
name|top
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|result
operator|=
name|inewint
argument_list|(
name|handy
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUE
case|:
operator|(
name|result
operator|=
name|newval
argument_list|()
operator|)
operator|->
name|l
operator|=
name|handy
operator|->
name|l
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
operator|(
name|result
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|handy
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|lbot
operator|->
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Bad arg to cpy1"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|67
argument_list|,
name|handy
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

