begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*	prs [-d<dataspec>] [-r<sid>] [-c<cutoff>] [-a]			 */
end_comment

begin_comment
comment|/*	    [-y<reverse-cutoff>] file ...				 */
end_comment

begin_comment
comment|/*									 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/* 	Program to print parts or all of an SCCS file 	in user supplied format. 	Arguments to the program may appear in any order 	and consist of keyletters, which begin with '-', 	and named files.  	If a direcory is given as an argument, each 	SCCS file within the directory is processed as if 	it had been specifically named. If a name of '-' 	is given, the standard input is read for a list 	of names of SCCS files to be processed. 	Non-SCCS files are ignored. */
end_comment

begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_include
include|#
directive|include
file|"../hdr/had.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|prs
operator|.
name|c
literal|4.1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|had
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|char
name|Getpgm
index|[]
literal|"/usr/local/get"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|Sid
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Mod
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Deltadate
index|[
literal|18
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Deltatime
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|char
name|tempskel
index|[]
literal|"/tmp/prXXXXXX"
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* used to generate temp 						   file names 						*/
end_comment

begin_decl_stmt
name|char
name|untmp
index|[
literal|32
index|]
decl_stmt|,
name|uttmp
index|[
literal|32
index|]
decl_stmt|,
name|cmtmp
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mrtmp
index|[
literal|32
index|]
decl_stmt|,
name|bdtmp
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|UNiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|UTiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|CMiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|MRiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|BDiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cutoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|revcut
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dataspec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|iline
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|xline
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|gline
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|maket
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|packet
name|gpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sid
name|sid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tm
modifier|*
name|Dtime
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
extern|extern prs(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|int
name|Fcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Set flags for 'fatal' to issue message, call clean-up 	routine, and terminate processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|=
name|FTLMSG
operator||
name|FTLCLN
operator||
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	The following loop processes keyletters and arguments. 	Note that these are processed only once for each 	invocation of 'main'. 	*/
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|argv
index|[
name|j
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|c
operator|=
name|argv
index|[
name|j
index|]
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|p
operator|=
operator|&
name|argv
index|[
name|j
index|]
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* delta cutoff */
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|invalid
argument_list|(
name|p
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"invalid sid (co8)"
argument_list|)
expr_stmt|;
name|sid_ab
argument_list|(
name|p
argument_list|,
operator|&
name|sid
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* time cutoff */
if|if
condition|(
operator|*
name|p
operator|&&
name|date_ab
argument_list|(
name|p
argument_list|,
operator|&
name|cutoff
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"bad date/time (cm5)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* reverse time cutoff */
if|if
condition|(
operator|*
name|p
operator|&&
name|date_ab
argument_list|(
name|p
argument_list|,
operator|&
name|revcut
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"bad date/time (cm5)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
operator|*
name|p
condition|)
name|fatal
argument_list|(
literal|"value after a arg (cm7)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* dataspec line */
name|dataspec
operator|=
name|p
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unknown key letter (cm1)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|had
index|[
name|c
operator|-
literal|'a'
index|]
operator|++
condition|)
name|fatal
argument_list|(
literal|"key letter twice (cm2)"
argument_list|)
expr_stmt|;
name|argv
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|num_files
operator|++
expr_stmt|;
end_for

begin_if
if|if
condition|(
name|num_files
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"missing file arg (cm3)"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|HADD
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|HADC
operator|&&
name|HADY
condition|)
name|fatal
argument_list|(
literal|"both 'c' and 'y' keyletters specified (prs2)"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|setsig
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Change flags for 'fatal' so that it will return to this 	routine (main) instead of terminating processing. 	*/
end_comment

begin_expr_stmt
name|Fflags
operator|=
operator|&
operator|~
name|FTLEXIT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fflags
operator|=
operator||
name|FTLJMP
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Call 'prs' routine for each file argument. 	*/
end_comment

begin_for
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|p
operator|=
name|argv
index|[
name|j
index|]
condition|)
name|do_file
argument_list|(
name|p
argument_list|,
name|prs
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|exit
argument_list|(
name|Fcnt
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   prs
operator|(
name|file
operator|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
specifier|extern
name|char
name|had_dir
decl_stmt|,
name|had_standinp
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Fjmp
argument_list|)
condition|)
return|return;
name|sinit
argument_list|(
operator|&
name|gpkt
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* init packet and open SCCS file */
name|gpkt
operator|.
name|p_reqsid
operator|.
name|s_rel
operator|=
name|sid
operator|.
name|s_rel
expr_stmt|;
name|gpkt
operator|.
name|p_reqsid
operator|.
name|s_lev
operator|=
name|sid
operator|.
name|s_lev
expr_stmt|;
name|gpkt
operator|.
name|p_reqsid
operator|.
name|s_br
operator|=
name|sid
operator|.
name|s_br
expr_stmt|;
name|gpkt
operator|.
name|p_reqsid
operator|.
name|s_seq
operator|=
name|sid
operator|.
name|s_seq
expr_stmt|;
name|gpkt
operator|.
name|p_cutoff
operator|=
name|cutoff
expr_stmt|;
name|gpkt
operator|.
name|p_reopen
operator|=
literal|1
expr_stmt|;
comment|/* 	read delta table entries checking only for format error 	*/
name|deltblchk
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
comment|/* 	create auxiliary file for User Name Section 	*/
name|aux_create
argument_list|(
name|UNiop
argument_list|,
name|untmp
argument_list|,
name|EUSERNAM
argument_list|)
expr_stmt|;
name|doflags
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
comment|/* 	create auxiliary file for the User Text section 	*/
name|aux_create
argument_list|(
name|UTiop
argument_list|,
name|uttmp
argument_list|,
name|EUSERTXT
argument_list|)
expr_stmt|;
comment|/* 	indicate to 'getline' that EOF is okay 	*/
name|gpkt
operator|.
name|p_chkeof
operator|=
literal|1
expr_stmt|;
comment|/* 	read body of SCCS file and create temp file for it 	*/
while|while
condition|(
name|read_mod
argument_list|(
operator|&
name|gpkt
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|num_files
operator|>
literal|1
operator|||
name|had_dir
operator|||
name|had_standinp
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|gpkt
operator|.
name|p_file
argument_list|)
expr_stmt|;
comment|/* 	Here, file has already been re-opened (by 'getline') 	*/
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
comment|/* skip over header line */
comment|/* 	call dodeltbl to read delta table entries 	*/
name|dodeltbl
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
name|clean_up
argument_list|()
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
name|dodeltbl
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|struct
name|deltab
name|dt
decl_stmt|;
name|struct
name|stats
name|stats
decl_stmt|;
comment|/* 	Read entire delta table. 	*/
while|while
condition|(
name|getstats
argument_list|(
name|pkt
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
name|getadel
argument_list|(
name|pkt
argument_list|,
operator|&
name|dt
argument_list|)
operator|!=
name|BDELTAB
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* 		Read rest of delta entry.  		*/
while|while
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|(
name|pkt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
break|break;
else|else
block|{
switch|switch
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EDELTAB
case|:
name|scanspec
argument_list|(
name|dataspec
argument_list|,
operator|&
name|dt
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
break|break;
case|case
name|INCLUDE
case|:
name|getit
argument_list|(
name|iline
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|EXCLUDE
case|:
name|getit
argument_list|(
name|xline
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|IGNORE
case|:
name|getit
argument_list|(
name|gline
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MRNUM
case|:
case|case
name|COMMENTS
case|:
continue|continue;
default|default:
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|pkt
operator|->
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * The scanspec procedure scans the dataspec searching for ID keywords.  * When a keyword is found the value is replaced and printed on the  * standard output. Any character that is not an ID keyword is printed  * immediately. */
end_comment

begin_expr_stmt
specifier|static
name|char
name|Zkeywd
index|[
literal|5
index|]
literal|"@(#)"
expr_stmt|;
end_expr_stmt

begin_macro
name|scanspec
argument_list|(
argument|spec
argument_list|,
argument|dtp
argument_list|,
argument|statp
argument_list|)
end_macro

begin_decl_stmt
name|char
name|spec
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|deltab
modifier|*
name|dtp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stats
modifier|*
name|statp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|Sflags
index|[]
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|k
decl_stmt|;
union|union
block|{
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|short
name|istr
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|char
name|c
decl_stmt|;
name|idsetup
argument_list|(
operator|&
name|dtp
operator|->
name|d_sid
argument_list|,
operator|&
name|gpkt
argument_list|,
operator|&
name|dtp
operator|->
name|d_datetime
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|spec
init|;
operator|*
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|lp
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
name|lp
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|lp
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'I'
case|:
comment|/* SID */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Sid
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Release number */
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|dtp
operator|->
name|d_sid
operator|.
name|s_rel
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Level number */
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|dtp
operator|->
name|d_sid
operator|.
name|s_lev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Branch number */
if|if
condition|(
name|dtp
operator|->
name|d_sid
operator|.
name|s_br
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|dtp
operator|->
name|d_sid
operator|.
name|s_br
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Sequence number */
if|if
condition|(
name|dtp
operator|->
name|d_sid
operator|.
name|s_seq
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|dtp
operator|->
name|d_sid
operator|.
name|s_seq
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Date delta created */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Deltadate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Time delta created */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Deltatime
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Programmer who created delta */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|dtp
operator|->
name|d_pgmr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Comments */
break|break;
case|case
literal|'Y'
case|:
comment|/* Type flag */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Module name */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Mod
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Form of what string */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Zkeywd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Mod
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Sid
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* Form of what string */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Zkeywd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|Type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|Mod
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Sid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Zkeywd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* what string constructor */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Zkeywd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* File name */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sname
argument_list|(
name|gpkt
operator|.
name|p_file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
break|break;
block|}
name|lp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|lp
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
name|lp
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
name|lp
index|[
literal|3
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|lp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
operator|+
literal|2
expr_stmt|;
continue|continue;
block|}
name|u
operator|.
name|str
index|[
literal|1
index|]
operator|=
operator|*
operator|++
name|lp
expr_stmt|;
name|u
operator|.
name|str
index|[
literal|0
index|]
operator|=
operator|*
operator|++
name|lp
expr_stmt|;
switch|switch
condition|(
name|u
operator|.
name|istr
condition|)
block|{
case|case
literal|'Dl'
case|:
comment|/* Delta line statistics */
name|printf
argument_list|(
literal|"%05d"
argument_list|,
name|statp
operator|->
name|s_ins
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%05d"
argument_list|,
name|statp
operator|->
name|s_del
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%05d"
argument_list|,
name|statp
operator|->
name|s_unc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Li'
case|:
comment|/* Lines inserted by delta */
name|printf
argument_list|(
literal|"%05d"
argument_list|,
name|statp
operator|->
name|s_ins
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Ld'
case|:
comment|/* Lines deleted by delta */
name|printf
argument_list|(
literal|"%05d"
argument_list|,
name|statp
operator|->
name|s_del
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Lu'
case|:
comment|/* Lines unchanged by delta */
name|printf
argument_list|(
literal|"%05d"
argument_list|,
name|statp
operator|->
name|s_unc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'DT'
case|:
comment|/* Delta type */
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|dtp
operator|->
name|d_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Dy'
case|:
comment|/* Year delta created */
name|printf
argument_list|(
literal|"%02d"
argument_list|,
name|Dtime
operator|->
name|tm_year
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Dm'
case|:
comment|/* Month delta created */
name|printf
argument_list|(
literal|"%02d"
argument_list|,
operator|(
name|Dtime
operator|->
name|tm_mon
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Dd'
case|:
comment|/* Day delta created */
name|printf
argument_list|(
literal|"%02d"
argument_list|,
name|Dtime
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Th'
case|:
comment|/* Hour delta created */
name|printf
argument_list|(
literal|"%02d"
argument_list|,
name|Dtime
operator|->
name|tm_hour
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Tm'
case|:
comment|/* Minutes delta created */
name|printf
argument_list|(
literal|"%02d"
argument_list|,
name|Dtime
operator|->
name|tm_min
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Ts'
case|:
comment|/* Seconds delta created */
name|printf
argument_list|(
literal|"%02d"
argument_list|,
name|Dtime
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'DS'
case|:
comment|/* Delta sequence number */
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|dtp
operator|->
name|d_serial
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'DP'
case|:
comment|/* Predecessor delta sequence number */
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|dtp
operator|->
name|d_pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'DI'
case|:
comment|/* Deltas included,excluded,ignored */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|iline
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|xline
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|gline
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Di'
case|:
comment|/* Deltas included */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|iline
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Dx'
case|:
comment|/* Deltas excluded */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|xline
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Dg'
case|:
comment|/* Deltas ignored */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|gline
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'MR'
case|:
comment|/* MR numbers */
break|break;
case|case
literal|'UN'
case|:
comment|/* User names */
name|printfile
argument_list|(
name|untmp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'MF'
case|:
comment|/* MR validation flag */
if|if
condition|(
name|Sflags
index|[
name|VALFLAG
operator|-
literal|'a'
index|]
condition|)
name|printf
argument_list|(
literal|"yes"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'MP'
case|:
comment|/* MR validation program */
if|if
condition|(
operator|!
operator|(
name|k
operator|=
name|Sflags
index|[
name|VALFLAG
operator|-
literal|'a'
index|]
operator|)
condition|)
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'KF'
case|:
comment|/* Keyword err/warn flag */
if|if
condition|(
name|Sflags
index|[
name|IDFLAG
operator|-
literal|'a'
index|]
condition|)
name|printf
argument_list|(
literal|"yes"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'BF'
case|:
comment|/* Branch flag */
if|if
condition|(
name|Sflags
index|[
name|BRCHFLAG
operator|-
literal|'a'
index|]
condition|)
name|printf
argument_list|(
literal|"yes"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'FB'
case|:
comment|/* Floor Boundry */
if|if
condition|(
name|k
operator|=
name|Sflags
index|[
name|FLORFLAG
operator|-
literal|'a'
index|]
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'CB'
case|:
comment|/* Ceiling Boundry */
if|if
condition|(
name|k
operator|=
name|Sflags
index|[
name|CEILFLAG
operator|-
literal|'a'
index|]
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Ds'
case|:
comment|/* Default SID */
if|if
condition|(
name|k
operator|=
name|Sflags
index|[
name|DEFTFLAG
operator|-
literal|'a'
index|]
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'ND'
case|:
comment|/* Null delta */
if|if
condition|(
name|Sflags
index|[
name|NULLFLAG
operator|-
literal|'a'
index|]
condition|)
name|printf
argument_list|(
literal|"yes"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'FD'
case|:
comment|/* File descriptive text */
name|printfile
argument_list|(
name|uttmp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'BD'
case|:
comment|/* Entire file body */
name|printfile
argument_list|(
name|bdtmp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'GB'
case|:
comment|/* Gotten body from 'get' */
name|getbody
argument_list|(
operator|&
name|dtp
operator|->
name|d_sid
argument_list|,
operator|&
name|gpkt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|u
operator|.
name|istr
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
break|break;
block|}
name|lp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
name|lp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|lp
condition|)
block|{
case|case
literal|'n'
case|:
comment|/* for newline */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* for wanted colon */
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* for tab */
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* for backspace */
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* for carriage return */
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* for form feed */
name|putchar
argument_list|(
literal|'\f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* for backslash */
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* for single quote */
name|putchar
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* unknown case */
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|putchar
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	zero out first char of global string lines in case 	a value is not gotten in next delta table entry 	*/
name|iline
index|[
literal|0
index|]
operator|=
name|xline
index|[
literal|0
index|]
operator|=
name|gline
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|clean_up
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|untmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|uttmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|bdtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpkt
operator|.
name|p_iop
condition|)
name|fclose
argument_list|(
name|gpkt
operator|.
name|p_iop
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This function takes as it's argument the SID inputed and determines  * whether or not it is valid (e. g. not ambiguous or illegal). */
end_comment

begin_expr_stmt
name|invalid
argument_list|(
name|i_sid
argument_list|)
specifier|register
name|char
operator|*
name|i_sid
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|digits
decl_stmt|;
name|count
operator|=
name|digits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|i_sid
operator|==
literal|'0'
operator|||
operator|*
name|i_sid
operator|==
literal|'.'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|i_sid
operator|++
expr_stmt|;
name|digits
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|i_sid
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|i_sid
operator|++
operator|==
literal|'.'
condition|)
block|{
name|digits
operator|=
literal|0
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|i_sid
operator|==
literal|'0'
operator|||
operator|*
name|i_sid
operator|==
literal|'.'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|digits
operator|++
expr_stmt|;
if|if
condition|(
name|digits
operator|>
literal|5
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
operator|(
operator|--
name|i_sid
operator|)
operator|==
literal|'.'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|1
operator|||
name|count
operator|==
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|deltblchk
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|struct
name|deltab
name|dt
decl_stmt|;
name|struct
name|stats
name|stats
decl_stmt|;
comment|/* 	Read entire delta table. 	*/
while|while
condition|(
name|getstats
argument_list|(
name|pkt
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
name|getadel
argument_list|(
name|pkt
argument_list|,
operator|&
name|dt
argument_list|)
operator|!=
name|BDELTAB
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* 		Read rest of delta entry.  		*/
while|while
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|(
name|pkt
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
break|break;
else|else
block|{
switch|switch
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EDELTAB
case|:
break|break;
case|case
name|INCLUDE
case|:
case|case
name|EXCLUDE
case|:
case|case
name|IGNORE
case|:
case|case
name|MRNUM
case|:
case|case
name|COMMENTS
case|:
continue|continue;
default|default:
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|pkt
operator|->
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkt
operator|->
name|p_line
index|[
literal|1
index|]
operator|!=
name|BUSERNAM
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getstats
argument_list|(
name|pkt
argument_list|,
name|statp
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|stats
modifier|*
name|statp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pkt
operator|->
name|p_line
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
name|pkt
argument_list|)
operator|==
name|NULL
operator|||
operator|*
name|p
operator|++
operator|!=
name|CTLCHAR
operator|||
operator|*
name|p
operator|++
operator|!=
name|STATS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|satoi
argument_list|(
name|p
argument_list|,
operator|&
name|statp
operator|->
name|s_ins
argument_list|)
expr_stmt|;
name|p
operator|=
name|satoi
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|statp
operator|->
name|s_del
argument_list|)
expr_stmt|;
name|satoi
argument_list|(
operator|++
name|p
argument_list|,
operator|&
name|statp
operator|->
name|s_unc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|getadel
argument_list|(
name|pkt
argument_list|,
name|dt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|deltab
modifier|*
name|dt
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|getline
argument_list|(
name|pkt
argument_list|)
operator|==
name|NULL
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|del_ab
argument_list|(
name|pkt
operator|->
name|p_line
argument_list|,
name|dt
argument_list|,
name|pkt
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|maket
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|FILE
modifier|*
name|iop
decl_stmt|;
name|copy
argument_list|(
name|tempskel
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|iop
operator|=
name|xfcreat
argument_list|(
name|mktemp
argument_list|(
name|file
argument_list|)
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|printfile
argument_list|(
name|file
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|iop
decl_stmt|;
name|iop
operator|=
name|xfopen
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|iop
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|read_mod
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ser
decl_stmt|;
name|int
name|iord
decl_stmt|;
specifier|register
name|struct
name|apply
modifier|*
name|ap
decl_stmt|;
name|BDiop
operator|=
name|maket
argument_list|(
name|bdtmp
argument_list|)
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
name|pkt
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|pkt
operator|->
name|p_line
expr_stmt|;
name|fputs
argument_list|(
name|p
argument_list|,
name|BDiop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|CTLCHAR
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|iord
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
name|INS
operator|||
name|iord
operator|==
name|DEL
operator|||
name|iord
operator|==
name|END
operator|)
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|NONBLANK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|satoi
argument_list|(
name|p
argument_list|,
operator|&
name|ser
argument_list|)
expr_stmt|;
if|if
condition|(
name|iord
operator|==
name|END
condition|)
name|remq
argument_list|(
name|pkt
argument_list|,
name|ser
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ap
operator|=
operator|&
name|pkt
operator|->
name|p_apply
index|[
name|ser
index|]
operator|)
operator|->
name|a_code
operator|==
name|APPLY
condition|)
name|addq
argument_list|(
name|pkt
argument_list|,
name|ser
argument_list|,
name|iord
operator|==
name|INS
condition|?
name|YES
else|:
name|NO
argument_list|,
name|iord
argument_list|,
name|ap
operator|->
name|a_reason
operator|&
name|USER
argument_list|)
expr_stmt|;
else|else
name|addq
argument_list|(
name|pkt
argument_list|,
name|ser
argument_list|,
name|iord
operator|==
name|INS
condition|?
name|NO
else|:
name|NULL
argument_list|,
name|iord
argument_list|,
name|ap
operator|->
name|a_reason
operator|&
name|USER
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|BDiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|p_q
condition|)
name|fatal
argument_list|(
literal|"premature eof (co5)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getbody
argument_list|(
argument|gsid
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sid
modifier|*
name|gsid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|extern
name|char
name|Getpgm
index|[]
decl_stmt|;
name|char
name|str
index|[
literal|128
index|]
decl_stmt|;
name|char
name|rarg
index|[
literal|20
index|]
decl_stmt|;
name|char
name|filearg
index|[
literal|80
index|]
decl_stmt|;
name|sid_ba
argument_list|(
name|gsid
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rarg
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filearg
argument_list|,
literal|"%s"
argument_list|,
name|pkt
operator|->
name|p_file
argument_list|)
expr_stmt|;
comment|/* 	fork here so 'getbody' can execute 'get' to 	print out gotten body :GB: 	*/
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot fork, try again"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
literal|0
condition|)
block|{
comment|/* 		perform 'get' and redirect output 		to standard output 		*/
name|execl
argument_list|(
name|Getpgm
argument_list|,
name|Getpgm
argument_list|,
literal|"-s"
argument_list|,
literal|"-p"
argument_list|,
literal|"-r"
argument_list|,
name|rarg
argument_list|,
name|filearg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"cannot execute '%s'"
argument_list|,
name|Getpgm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|getit
argument_list|(
name|str
argument_list|,
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|str
operator|,
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cp
operator|=
operator|+
literal|2
expr_stmt|;
name|NONBLANK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
index|[
name|length
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|aux_create
argument_list|(
argument|iop
argument_list|,
argument|file
argument_list|,
argument|delchar
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|delchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|int
name|text
decl_stmt|;
comment|/* 	create auxiliary file for the named section 	*/
name|text
operator|=
literal|0
expr_stmt|;
name|iop
operator|=
name|maket
argument_list|(
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|(
operator|&
name|gpkt
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|gpkt
operator|.
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
condition|)
block|{
name|text
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|n
argument_list|,
name|iop
argument_list|)
expr_stmt|;
block|}
comment|/* 	check to see that delimiter found is correct 	*/
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|gpkt
operator|.
name|p_line
index|[
literal|0
index|]
operator|!=
name|CTLCHAR
operator|||
name|gpkt
operator|.
name|p_line
index|[
literal|1
index|]
operator|!=
name|delchar
condition|)
name|fmterr
argument_list|(
operator|&
name|gpkt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text
condition|)
name|fprintf
argument_list|(
name|iop
argument_list|,
literal|"No entries\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|idsetup
argument_list|(
argument|gsid
argument_list|,
argument|pkt
argument_list|,
argument|bdate
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sid
modifier|*
name|gsid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|bdate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|date_ba
argument_list|(
name|bdate
argument_list|,
name|Deltadate
argument_list|)
expr_stmt|;
name|Deltatime
operator|=
operator|&
name|Deltadate
index|[
literal|9
index|]
expr_stmt|;
name|Deltadate
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|sid_ba
argument_list|(
name|gsid
argument_list|,
name|Sid
argument_list|)
expr_stmt|;
name|Dtime
operator|=
name|localtime
argument_list|(
name|bdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|Sflags
index|[
name|MODFLAG
operator|-
literal|'a'
index|]
condition|)
name|copy
argument_list|(
name|p
argument_list|,
name|Mod
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|Mod
argument_list|,
literal|"%s"
argument_list|,
name|sname
argument_list|(
name|pkt
operator|->
name|p_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Type
operator|=
name|Sflags
index|[
name|TYPEFLAG
operator|-
literal|'a'
index|]
operator|)
condition|)
name|Type
operator|=
literal|"none"
expr_stmt|;
block|}
end_block

end_unit

