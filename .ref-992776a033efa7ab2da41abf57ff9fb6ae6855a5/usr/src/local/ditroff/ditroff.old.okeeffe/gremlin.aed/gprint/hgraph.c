begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hgraph.c-  *  *  * Copyright -C- 1982 Barry S. Roitblat  *  *     This file contains the graphics routines for hard copy (gprint)   * production of gremlin files.  *  */
end_comment

begin_include
include|#
directive|include
file|"gprint.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_include
include|#
directive|include
file|<vfont.h>
end_include

begin_comment
comment|/* line and character styles */
end_comment

begin_decl_stmt
name|int
name|style
index|[
name|STYLES
index|]
init|=
block|{
name|DOTTED
block|,
name|DOTDASHED
block|,
name|SOLID
block|,
name|DASHED
block|,
name|SOLID
block|,
name|SOLID
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|thick
index|[
name|STYLES
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tfont
index|[
name|FONTS
index|]
init|=
block|{
literal|"R"
block|,
literal|"I"
block|,
literal|"B"
block|,
literal|"S"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tsize
index|[
name|SIZES
index|]
init|=
block|{
literal|"10"
block|,
literal|"16"
block|,
literal|"24"
block|,
literal|"36"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables used to print from font file */
end_comment

begin_extern
extern|extern Orientation;
end_extern

begin_extern
extern|extern cfont;
end_extern

begin_extern
extern|extern csize;
end_extern

begin_decl_stmt
specifier|extern
name|struct
name|header
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|dispatch
name|dispatch
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fontdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|double
name|scale
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern point(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|int
name|linethickness
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linmod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|topx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|topy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|botx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|boty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|centx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|centy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|delx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|dely
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|del
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DevRange
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|device
decl_stmt|;
end_decl_stmt

begin_macro
name|line
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine is called to draw a line from the point at (x0, y0) to (x1, y1).  * The line is drawn using a variation of   */
end_comment

begin_block
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|xinc
decl_stmt|,
name|yinc
decl_stmt|;
name|int
name|res1
decl_stmt|;
name|int
name|res2
decl_stmt|;
name|int
name|slope
decl_stmt|;
name|xinc
operator|=
literal|1
expr_stmt|;
name|yinc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dx
operator|=
name|x1
operator|-
name|x0
operator|)
operator|<
literal|0
condition|)
block|{
name|xinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dy
operator|=
name|y1
operator|-
name|y0
operator|)
operator|<
literal|0
condition|)
block|{
name|yinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
name|slope
operator|=
name|xinc
operator|*
name|yinc
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|res2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
while|while
condition|(
name|x0
operator|!=
name|x1
condition|)
block|{
if|if
condition|(
operator|(
name|x0
operator|+
name|slope
operator|*
name|y0
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|res2
operator|+=
name|dx
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
else|else
while|while
condition|(
name|y0
operator|!=
name|y1
condition|)
block|{
if|if
condition|(
operator|(
name|x0
operator|+
name|slope
operator|*
name|y0
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|res2
operator|+=
name|dy
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x1
operator|+
name|slope
operator|*
name|y1
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|HGPrintElt
argument_list|(
argument|element
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|element
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine examines the picture elements and calls the appropriate  * routine(s) to print them according to their type.  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
name|pt1
decl_stmt|,
name|pt2
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|i
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|element
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEXT
argument_list|(
name|element
operator|->
name|type
argument_list|)
condition|)
block|{
name|p1
operator|=
name|element
operator|->
name|ptlist
expr_stmt|;
name|HGSetFont
argument_list|(
name|element
operator|->
name|brushf
argument_list|,
name|element
operator|->
name|size
argument_list|)
expr_stmt|;
name|pt1
operator|.
name|x
operator|=
name|mapx
argument_list|(
name|xorn
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|mapy
argument_list|(
name|yorn
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|txt
operator|=
name|element
operator|->
name|textpt
expr_stmt|;
name|HGPutText
argument_list|(
name|element
operator|->
name|type
argument_list|,
name|pt1
argument_list|,
name|txt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|element
operator|->
name|type
condition|)
block|{
case|case
name|ARC
case|:
name|p1
operator|=
name|element
operator|->
name|ptlist
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|HGSetBrush
argument_list|(
name|element
operator|->
name|brushf
argument_list|)
expr_stmt|;
name|pt1
operator|.
name|x
operator|=
name|mapx
argument_list|(
name|xorn
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|pt1
operator|.
name|y
operator|=
name|mapy
argument_list|(
name|yorn
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|pt2
operator|.
name|x
operator|=
name|mapx
argument_list|(
name|xorn
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|pt2
operator|.
name|y
operator|=
name|mapy
argument_list|(
name|yorn
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|HGArc
argument_list|(
operator|&
name|pt1
argument_list|,
operator|&
name|pt2
argument_list|,
name|element
operator|->
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|CURVE
case|:
name|HGSetBrush
argument_list|(
name|element
operator|->
name|brushf
argument_list|)
expr_stmt|;
name|HGCurve
argument_list|(
name|element
operator|->
name|ptlist
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR
case|:
name|p1
operator|=
name|element
operator|->
name|ptlist
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|HGSetBrush
argument_list|(
name|element
operator|->
name|brushf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|x1
operator|=
name|mapx
argument_list|(
name|xorn
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|y1
operator|=
name|mapy
argument_list|(
name|yorn
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|mapx
argument_list|(
name|xorn
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|lasty
operator|=
name|mapy
argument_list|(
name|yorn
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|HGtline
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|lastx
argument_list|,
name|lasty
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
empty_stmt|;
break|break;
block|}
comment|/* end switch */
empty_stmt|;
block|}
comment|/* end else Text */
block|}
comment|/* end if */
block|}
end_block

begin_comment
comment|/* end PrintElt */
end_comment

begin_macro
name|HGPutText
argument_list|(
argument|justify
argument_list|,
argument|pnt
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|int
name|justify
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|POINT
name|pnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|string
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine is used to calculate the proper starting position for a  * text string (based on justification, size and font), and prints it   * character by character.  */
end_comment

begin_block
block|{
name|int
name|length
decl_stmt|,
name|height
decl_stmt|,
name|nchars
decl_stmt|,
name|i
decl_stmt|;
name|POINT
name|pos
decl_stmt|;
name|height
operator|=
name|dispatch
index|[
literal|'T'
index|]
operator|.
name|up
operator|+
name|dispatch
index|[
literal|'y'
index|]
operator|.
name|down
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
name|length
operator|+=
name|dispatch
index|[
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|' '
operator|)
condition|?
literal|'a'
else|:
name|string
index|[
name|i
index|]
index|]
operator|.
name|width
expr_stmt|;
name|nchars
operator|=
name|i
expr_stmt|;
switch|switch
condition|(
name|justify
condition|)
block|{
case|case
name|BOTLEFT
case|:
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
expr_stmt|;
break|break;
case|case
name|BOTCENT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|BOTRIGHT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
name|length
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|-
name|length
expr_stmt|;
block|}
break|break;
case|case
name|CENTLEFT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|+
operator|(
name|height
operator|/
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
operator|(
name|height
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
expr_stmt|;
block|}
break|break;
case|case
name|CENTCENT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|+
operator|(
name|height
operator|/
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
operator|(
name|height
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|CENTRIGHT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
name|length
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|+
operator|(
name|height
operator|/
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
operator|(
name|height
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|-
name|length
expr_stmt|;
block|}
break|break;
case|case
name|TOPLEFT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|+
name|height
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
name|height
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
expr_stmt|;
block|}
break|break;
case|case
name|TOPCENT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|+
name|height
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
name|height
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|TOPRIGHT
case|:
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
name|length
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|+
name|height
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pnt
operator|.
name|x
operator|-
name|height
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|pnt
operator|.
name|y
operator|-
name|length
expr_stmt|;
block|}
break|break;
block|}
name|HGMove
argument_list|(
name|pos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchars
condition|;
operator|++
name|i
control|)
block|{
name|HGplotch
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end HGPutText */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|pi
value|3.14159265357
end_define

begin_define
define|#
directive|define
name|log2_10
value|3.321915
end_define

begin_macro
name|HGArc
argument_list|(
argument|center
argument_list|,
argument|cpoint
argument_list|,
argument|angle
argument_list|)
end_macro

begin_decl_stmt
name|POINT
modifier|*
name|center
decl_stmt|,
modifier|*
name|cpoint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|angle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine plots an arc centered about 'center' counter clockwise for  * the point 'cpoint' through 'angle' degrees.  If angle is 0, a full circle  * is drawn.  */
end_comment

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|resolution
decl_stmt|,
name|epsalon
decl_stmt|,
name|degreesperpoint
decl_stmt|,
name|fullcircle
decl_stmt|;
name|double
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|extent
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|xs
operator|=
name|cpoint
operator|->
name|x
operator|-
name|center
operator|->
name|x
expr_stmt|;
name|ys
operator|=
name|cpoint
operator|->
name|y
operator|-
name|center
operator|->
name|y
expr_stmt|;
name|lastx
operator|=
operator|(
name|int
operator|)
name|cpoint
operator|->
name|x
expr_stmt|;
name|lasty
operator|=
operator|(
name|int
operator|)
name|cpoint
operator|->
name|y
expr_stmt|;
comment|/* calculate drawing parameters */
name|t1
operator|=
name|log10
argument_list|(
name|sqrt
argument_list|(
name|xs
operator|*
name|xs
operator|+
name|ys
operator|*
name|ys
argument_list|)
argument_list|)
operator|*
name|log2_10
expr_stmt|;
name|t1
operator|=
name|ceil
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|resolution
operator|=
name|pow
argument_list|(
literal|2.0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|epsalon
operator|=
literal|1.0
operator|/
name|resolution
expr_stmt|;
name|fullcircle
operator|=
literal|2
operator|*
name|pi
operator|*
name|resolution
expr_stmt|;
name|fullcircle
operator|=
name|ceil
argument_list|(
name|fullcircle
argument_list|)
expr_stmt|;
name|degreesperpoint
operator|=
literal|360.0
operator|/
name|fullcircle
expr_stmt|;
if|if
condition|(
name|angle
operator|==
literal|0
condition|)
name|extent
operator|=
name|fullcircle
expr_stmt|;
else|else
name|extent
operator|=
name|angle
operator|/
name|degreesperpoint
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
name|xs
operator|+=
name|epsalon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
name|center
operator|->
name|x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|ys
operator|-=
name|epsalon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
name|center
operator|->
name|y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|RoundEnd
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|,
call|(
name|int
call|)
argument_list|(
name|linethickness
operator|/
literal|2
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|nx
expr_stmt|;
name|lasty
operator|=
name|ny
expr_stmt|;
block|}
comment|/* end for */
empty_stmt|;
block|}
end_block

begin_comment
comment|/* end HGArc */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|RoundEnd
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|radius
argument_list|,
argument|filled
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|radius
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether the circle is filled */
end_comment

begin_comment
comment|/* This routine plots a filled circle of the specified radius centered   * about (x, y).  */
end_comment

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|epsalon
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|extent
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|int
name|cx
decl_stmt|,
name|cy
decl_stmt|;
if|if
condition|(
name|radius
operator|<
literal|1
condition|)
comment|/* too small to notice */
block|{
name|point
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
name|xs
operator|=
literal|0
expr_stmt|;
name|ys
operator|=
name|radius
expr_stmt|;
name|epsalon
operator|=
literal|1.0
operator|/
name|radius
expr_stmt|;
name|extent
operator|=
name|pi
operator|*
name|radius
operator|/
literal|2
expr_stmt|;
comment|/* 1/4 the circumference */
comment|/* Calculate the trajectory of the circle for 1/4 the circumference          * and mirror appropriately to get the other three quadrants.          */
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|+
operator|(
operator|(
name|int
operator|)
name|ys
operator|)
argument_list|)
expr_stmt|;
comment|/* take care if end of arc missed by */
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|-
operator|(
operator|(
name|int
operator|)
name|ys
operator|)
argument_list|)
expr_stmt|;
comment|/* below formulation                 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
comment|/* generate circumference */
name|xs
operator|+=
name|epsalon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
name|x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|<
name|x
condition|)
name|nx
operator|=
name|x
expr_stmt|;
comment|/* 1st quadrant, should be positive */
name|ys
operator|-=
name|epsalon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
name|y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ny
operator|<
name|y
condition|)
name|ny
operator|=
name|y
expr_stmt|;
comment|/* 1st quadrant, should be positive */
if|if
condition|(
name|filled
operator|==
name|TRUE
condition|)
block|{
comment|/* fill from center */
name|cx
operator|=
name|x
expr_stmt|;
name|cy
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* fill from perimeter only (no fill) */
name|cx
operator|=
name|nx
expr_stmt|;
name|cy
operator|=
name|ny
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|cx
init|;
name|j
operator|<=
name|nx
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|k
operator|=
name|cy
init|;
name|k
operator|<=
name|ny
condition|;
operator|++
name|k
control|)
block|{
name|point
argument_list|(
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|j
argument_list|,
literal|2
operator|*
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
literal|2
operator|*
name|x
operator|-
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
literal|2
operator|*
name|x
operator|-
name|j
argument_list|,
literal|2
operator|*
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
empty_stmt|;
block|}
comment|/* end for i */
empty_stmt|;
block|}
end_block

begin_comment
comment|/* end RoundEnd */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|MAXPOINTS
value|200
end_define

begin_expr_stmt
specifier|static
name|Paramaterize
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|h
argument_list|,
argument|n
argument_list|)
name|float
name|x
index|[
name|MAXPOINTS
index|]
operator|,
name|y
index|[
name|MAXPOINTS
index|]
operator|,
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     This routine calculates parameteric values for use in calculating  * curves.  The parametric values are returned in the array u.  The values  * are an approximation of cumulative arc lengths of the curve (uses cord  * length).  For additional information, see paper cited below.  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|float
name|u
index|[
name|MAXPOINTS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|u
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
name|u
index|[
name|i
index|]
operator|+=
name|sqrt
argument_list|(
name|pow
argument_list|(
call|(
name|double
call|)
argument_list|(
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|j
index|]
argument_list|)
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
call|(
name|double
call|)
argument_list|(
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|j
index|]
argument_list|)
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|h
index|[
name|i
index|]
operator|=
name|u
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|u
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Paramaterize */
end_comment

begin_expr_stmt
specifier|static
name|PeriodicSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
operator|,
name|z
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Point list and paramaterization  */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_comment
comment|/*  *     This routine solves for the cubic polynomial to fit a spline  * curve to the the points  specified by the list of values.  * The Curve generated is periodic.  The alogrithms for this   * curve are from the "Spline Curve Techniques" paper cited below.  */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|c
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|r
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|s
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|h
index|[
literal|0
index|]
operator|=
name|h
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3a */
name|a
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|0
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|h
index|[
name|i
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 3b */
name|r
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|s
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
operator|-
operator|(
name|h
index|[
name|i
index|]
operator|*
name|r
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|c
index|[
name|i
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
operator|(
literal|6
operator|*
name|d
index|[
name|npoints
operator|-
literal|2
index|]
operator|-
name|h
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
operator|-
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|s
index|[
name|npoints
operator|-
literal|2
index|]
operator|)
operator|/
operator|(
name|h
index|[
literal|0
index|]
operator|*
name|r
index|[
literal|1
index|]
operator|+
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|r
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
literal|2
operator|*
operator|(
name|h
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
name|h
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
name|r
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|+
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end PeriodicSpline */
end_comment

begin_expr_stmt
specifier|static
name|NaturalEndSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
operator|,
name|z
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Point list and parameterization */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_comment
comment|/*  *     This routine solves for the cubic polynomial to fit a spline  * curve the the points  specified by the list of values.  The alogrithms for  * this curve are from the "Spline Curve Techniques" paper cited below.  */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3 */
name|a
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|2
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
operator|--
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
operator|-
literal|2
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
block|}
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end NaturalEndSpline */
end_comment

begin_define
define|#
directive|define
name|PointsPerInterval
value|32
end_define

begin_macro
name|HGCurve
argument_list|(
argument|pointlist
argument_list|,
argument|style
argument_list|)
end_macro

begin_decl_stmt
name|POINT
modifier|*
name|pointlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *    This routine generates a smooth curve through a set of points.  The   * method used is the parametric spline curve on unit knot mesh described  * in "Spline Curve Techniques" by Patrick Baudelaire, Robert Flegal, and   * Robert Sproull -- Xerox Parc.  */
end_comment

begin_block
block|{
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dx
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dy
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|d2x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|xinter
decl_stmt|,
name|yinter
decl_stmt|;
name|POINT
modifier|*
name|ptr
decl_stmt|;
name|int
name|numpoints
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lx
decl_stmt|,
name|ly
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
comment|/* Copy point list to array for easier access */
name|ptr
operator|=
name|pointlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
operator|!
name|Nullpoint
argument_list|(
name|ptr
argument_list|)
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|x
index|[
name|i
index|]
operator|=
name|mapx
argument_list|(
name|xorn
argument_list|(
name|ptr
operator|->
name|x
argument_list|,
name|ptr
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|y
index|[
name|i
index|]
operator|=
name|mapy
argument_list|(
name|yorn
argument_list|(
name|ptr
operator|->
name|x
argument_list|,
name|ptr
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAXPOINTS
operator|-
literal|1
condition|)
break|break;
name|ptr
operator|=
name|PTNextPoint
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|lx
operator|=
operator|(
name|int
operator|)
name|x
index|[
literal|1
index|]
expr_stmt|;
name|ly
operator|=
operator|(
name|int
operator|)
name|y
index|[
literal|1
index|]
expr_stmt|;
comment|/* Solve for derivatives of the curve at each point                * separately for x and y (parametric). 	      */
name|numpoints
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|Paramaterize
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|)
operator|&&
operator|(
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|numpoints
index|]
operator|)
condition|)
comment|/* closed curve */
block|{
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
comment|/* generate the curve using the above information and  	       * PointsPerInterval vectors between each specified knot. 	       */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numpoints
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|x
index|[
name|j
index|]
operator|==
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|y
index|[
name|j
index|]
operator|==
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|)
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|PointsPerInterval
condition|;
operator|++
name|k
control|)
block|{
name|t
operator|=
operator|(
name|float
operator|)
name|k
operator|*
name|h
index|[
name|j
index|]
operator|/
operator|(
name|float
operator|)
name|PointsPerInterval
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t
operator|*
name|t
operator|*
name|t
expr_stmt|;
name|xinter
operator|=
name|x
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6
expr_stmt|;
name|nx
operator|=
operator|(
name|int
operator|)
name|xinter
expr_stmt|;
name|yinter
operator|=
name|y
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6
expr_stmt|;
name|ny
operator|=
operator|(
name|int
operator|)
name|yinter
expr_stmt|;
name|HGtline
argument_list|(
name|lx
argument_list|,
name|ly
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
name|lx
operator|=
name|nx
expr_stmt|;
name|ly
operator|=
name|ny
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
block|}
end_block

begin_comment
comment|/* end HGCurve */
end_comment

begin_macro
name|HGplotch
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine prints a single character using the current (bit mapped)  * vtroff font  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
name|c
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|ptr
operator|=
name|bits
operator|+
name|dispatch
index|[
name|ch
index|]
operator|.
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dispatch
index|[
name|ch
index|]
operator|.
name|up
init|;
name|i
operator|>
operator|-
name|dispatch
index|[
name|ch
index|]
operator|.
name|down
condition|;
operator|--
name|i
control|)
block|{
name|nbytes
operator|=
operator|(
name|dispatch
index|[
name|ch
index|]
operator|.
name|right
operator|+
name|dispatch
index|[
name|ch
index|]
operator|.
name|left
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nbytes
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|7
init|;
name|k
operator|>=
literal|0
condition|;
operator|--
name|k
control|)
if|if
condition|(
operator|(
name|c
operator|>>
name|k
operator|)
operator|&
literal|1
condition|)
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
name|point
argument_list|(
name|lastx
operator|+
literal|7
operator|-
name|k
operator|+
name|j
operator|*
literal|8
operator|-
name|dispatch
index|[
name|ch
index|]
operator|.
name|left
argument_list|,
name|lasty
operator|-
name|i
argument_list|)
expr_stmt|;
else|else
name|point
argument_list|(
name|lastx
operator|+
name|i
argument_list|,
name|lasty
operator|+
literal|7
operator|-
name|k
operator|+
name|j
operator|*
literal|8
operator|-
name|dispatch
index|[
name|ch
index|]
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
name|lastx
operator|+=
name|dispatch
index|[
operator|(
name|ch
operator|==
literal|' '
operator|)
condition|?
literal|'a'
else|:
name|ch
index|]
operator|.
name|width
expr_stmt|;
else|else
name|lasty
operator|+=
name|dispatch
index|[
operator|(
name|ch
operator|==
literal|' '
operator|)
condition|?
literal|'a'
else|:
name|ch
index|]
operator|.
name|width
expr_stmt|;
block|}
end_block

begin_macro
name|HGInitFont
argument_list|(
argument|fontFile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fontFile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine reads in the appropriate font file */
end_comment

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|fonts
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the font file */
name|s
operator|=
name|fontFile
expr_stmt|;
if|if
condition|(
operator|(
name|fonts
operator|=
name|open
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get font file"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Get the header and check magic number */
if|if
condition|(
name|read
argument_list|(
name|fonts
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad read in font file"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|.
name|magic
operator|!=
literal|0436
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad magic numer in font file"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Get dispatches */
if|if
condition|(
name|read
argument_list|(
name|fonts
argument_list|,
name|dispatch
argument_list|,
sizeof|sizeof
argument_list|(
name|dispatch
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dispatch
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad read in font file"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Allocate space for bit map and read in bits */
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fonts
argument_list|,
name|bits
argument_list|,
name|header
operator|.
name|size
argument_list|)
operator|!=
name|header
operator|.
name|size
condition|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read bit map in font file"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Close font file */
if|if
condition|(
name|close
argument_list|(
name|fonts
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close font file"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|HGtline
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine calls line repeatedly until the line is   * of the proper thickness.  */
end_comment

begin_block
block|{
name|double
name|morelen
decl_stmt|,
name|theta
decl_stmt|,
name|wx
decl_stmt|,
name|wy
decl_stmt|,
name|xx
decl_stmt|,
name|xy
decl_stmt|;
name|int
name|xs
decl_stmt|,
name|xe
decl_stmt|,
name|ys
decl_stmt|,
name|ye
decl_stmt|;
name|int
name|addln
decl_stmt|,
name|j
decl_stmt|,
name|xdir
decl_stmt|,
name|ydir
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|xdir
operator|=
name|ydir
operator|=
literal|1
expr_stmt|;
name|dx
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
comment|/* calculate direction to move to  */
name|dy
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
comment|/* move to draw additional lines if needed */
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
comment|/* for extra thickness */
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|xdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
name|ydir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|morelen
operator|=
name|linethickness
operator|/
literal|2
expr_stmt|;
name|addln
operator|=
operator|(
name|int
operator|)
name|morelen
expr_stmt|;
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
operator|(
name|int
operator|)
name|morelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add rounded end */
for|for
control|(
name|j
operator|=
operator|(
operator|-
name|addln
operator|)
init|;
name|j
operator|<=
name|addln
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|dy
operator|==
literal|0
condition|)
block|{
name|xs
operator|=
name|x0
expr_stmt|;
name|xe
operator|=
name|x1
expr_stmt|;
name|ys
operator|=
name|ye
operator|=
name|y0
operator|+
name|j
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
block|{
name|ys
operator|=
name|y0
expr_stmt|;
name|ye
operator|=
name|y1
expr_stmt|;
name|xs
operator|=
name|xe
operator|=
name|x0
operator|+
name|j
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dy
operator|!=
literal|0
operator|)
condition|)
block|{
name|theta
operator|=
name|pi
operator|/
literal|2.0
operator|-
name|atan
argument_list|(
operator|(
operator|(
name|double
operator|)
name|dx
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|dy
operator|)
argument_list|)
expr_stmt|;
name|wx
operator|=
name|j
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|wy
operator|=
name|j
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|xs
operator|=
name|x0
operator|+
name|wx
operator|*
name|xdir
expr_stmt|;
name|ys
operator|=
name|y0
operator|-
name|wy
operator|*
name|ydir
expr_stmt|;
name|xe
operator|=
name|x1
operator|+
name|wx
operator|*
name|xdir
expr_stmt|;
name|ye
operator|=
name|y1
operator|-
name|wy
operator|*
name|ydir
expr_stmt|;
block|}
name|line
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
name|RoundEnd
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|int
operator|)
name|morelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add rounded end */
block|}
end_block

begin_comment
comment|/* end HGtline */
end_comment

begin_macro
name|HGMove
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|POINT
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lastx
operator|=
name|p
operator|.
name|x
expr_stmt|;
name|lasty
operator|=
name|p
operator|.
name|y
expr_stmt|;
block|}
end_block

begin_macro
name|HGSetFont
argument_list|(
argument|font
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|font
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|,
name|string
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|font
operator|==
name|cfont
operator|)
operator|&&
operator|(
name|size
operator|==
name|csize
operator|)
condition|)
return|return;
name|cfont
operator|=
name|font
expr_stmt|;
name|csize
operator|=
name|size
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|fontdir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|tfont
index|[
name|font
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|tsize
index|[
name|size
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|HGInitFont
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|HGSetBrush
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|linmod
operator|=
name|style
index|[
name|mode
operator|-
literal|1
index|]
expr_stmt|;
name|linethickness
operator|=
name|thick
index|[
name|mode
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_block

end_unit

