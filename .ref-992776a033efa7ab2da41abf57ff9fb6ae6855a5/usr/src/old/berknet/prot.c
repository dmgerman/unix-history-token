begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)prot.c	4.1	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protocol driver, user level, Berkeley network */
end_comment

begin_comment
comment|/* 	This code is a little complicated because of a number of different 	protocols used.  Here is an explanation:  Level	Description  0	Normal Case (6 bit with no kernel driver support)  1	Line Discipline -- uses NETLDISP in sgtty.h and ioctl to set the 	line discipline.  At Berkeley this means avoiding interrupting on 	every character by using a Silo on a DH or DZ board, and (optionally) 	bypassing the canonicalization in the tty code by putting the charactars 	directly in a buffer. 	condition (netd.dp_bnetldis != 0)  2	8-bit TTY protocol -- implies Level 1 and inserts record separators(012) 	and escapes other occurrences of 012.  Since the driver on the other 	end must interpolate the escapes, this is an asymmetric protocol where 	the sender puts in the escapes but the receiver at the user level knows 	they have already been removed. 	condition (netd.dp_bnetldis != 0&& netd.dp_use8bit != 0)  3	8-bit Block Device protocol -- this is for a DMC-11, it writes fixed 	length blocks in both directions with no quoting. 	condition (netd.dp_bnetldis != 0&& netd.dp_usehighspeed != 0)  4	RAND 8-bit protocol -- included for completeness, is not 	correctly specified here. 	Specified by an IFDEF.  If the daemons are being simulated by pipes, then netd.dp_pipesim != 0 and each of the 4 levels (except RAND) are simulated. In this case at level 2 (use8bit) on the receiver end it does the quoting.  Timing statistics: We estimate 300 micros for queue/dequeue and then 	20 micros per interrupt for 30 cps => 2.5% of system for 9600 Baud line  Max packet lengths=> to CSVAX with 1k buffers and 6-bit prot = 758 chars 	to Ing70 with 512 byte buffers and no NETLDISC, only 182 chars  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* global */
end_comment

begin_decl_stmt
name|struct
name|dumpstruc
name|dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|daemonparms
name|netd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bufleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|retransmit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|masterseqno
decl_stmt|,
name|lastseqno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* writing packet */
end_comment

begin_decl_stmt
specifier|static
name|char
name|wpack
index|[
name|MAXNBUF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    one problem has been character loss on    overloaded systems due to the daemon    taking too long to swap in    and losing characters.    A high priority process of small size    with a pipe would do the job. */
end_comment

begin_macro
name|alarmint
argument_list|()
end_macro

begin_block
block|{
name|errno
operator|=
literal|100
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* alarm off */
name|longjmp
argument_list|(
name|env
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ugh */
block|}
end_block

begin_comment
comment|/* returns number of bytes written, error returns WRITEFAIL (-3) */
end_comment

begin_comment
comment|/* inbuf is buffer of amt chars to be written */
end_comment

begin_macro
name|xwrite
argument_list|(
argument|inbuf
argument_list|,
argument|amt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|inbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|num
decl_stmt|,
name|savetime
decl_stmt|;
name|struct
name|packet
modifier|*
name|rpp
decl_stmt|,
modifier|*
name|xptr
decl_stmt|;
name|xptr
operator|=
operator|(
expr|struct
name|packet
operator|*
operator|)
name|wpack
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|retransmit
operator|=
literal|0
expr_stmt|;
name|savetime
operator|=
name|netd
operator|.
name|dp_atime
expr_stmt|;
while|while
condition|(
name|amt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|retransmit
operator|>
name|netd
operator|.
name|dp_maxbread
condition|)
block|{
name|debug
argument_list|(
literal|"xwrite fail"
argument_list|)
expr_stmt|;
return|return
operator|(
name|WRITEFAIL
operator|)
return|;
block|}
comment|/* format the packet to send */
name|num
operator|=
name|min
argument_list|(
name|netd
operator|.
name|dp_datasize
argument_list|,
name|amt
argument_list|)
expr_stmt|;
comment|/* set the length down if escapes are being used */
if|if
condition|(
name|netd
operator|.
name|dp_use8bit
condition|)
name|num
operator|=
name|min
argument_list|(
name|num
argument_list|,
name|MAXNBUF
operator|/
literal|2
argument_list|)
expr_stmt|;
name|xptr
operator|->
name|pcode
operator|=
name|REQUEST
expr_stmt|;
name|xptr
operator|->
name|seqno
operator|=
name|masterseqno
expr_stmt|;
name|xptr
operator|->
name|len
operator|=
name|num
expr_stmt|;
name|p
operator|=
name|xptr
operator|->
name|data
expr_stmt|;
name|i
operator|=
name|num
expr_stmt|;
name|b
operator|=
name|inbuf
operator|+
name|cnt
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
comment|/* send it */
name|sendpacket
argument_list|(
name|xptr
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|getpacket
argument_list|()
expr_stmt|;
if|if
condition|(
name|rpp
operator|==
name|NULL
condition|)
block|{
name|netd
operator|.
name|dp_atime
operator|+=
literal|3
expr_stmt|;
comment|/* wait three more secs */
name|retransmit
operator|++
expr_stmt|;
name|dump
operator|.
name|nretrans
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* various errors */
if|if
condition|(
name|rpp
operator|->
name|chksum
operator|!=
literal|0
operator|||
name|rpp
operator|->
name|pcode
operator|!=
name|ACK
operator|||
name|rpp
operator|->
name|seqno
operator|!=
name|xptr
operator|->
name|seqno
condition|)
block|{
if|if
condition|(
name|rpp
operator|->
name|seqno
operator|==
literal|1
operator|&&
name|rpp
operator|->
name|pcode
operator|==
name|REQUEST
condition|)
block|{
name|error
argument_list|(
literal|"collision"
argument_list|)
expr_stmt|;
return|return
operator|(
name|WRITEFAIL
operator|)
return|;
block|}
if|if
condition|(
name|rpp
operator|->
name|chksum
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"chksum %d"
argument_list|,
name|rpp
operator|->
name|seqno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rpp
operator|->
name|pcode
operator|!=
name|ACK
condition|)
name|error
argument_list|(
literal|"not ack %d %d"
argument_list|,
name|rpp
operator|->
name|pcode
argument_list|,
name|rpp
operator|->
name|seqno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rpp
operator|->
name|seqno
operator|!=
name|xptr
operator|->
name|seqno
condition|)
name|error
argument_list|(
literal|"WRSQNO got %d request %d"
argument_list|,
name|rpp
operator|->
name|seqno
argument_list|,
name|xptr
operator|->
name|seqno
argument_list|)
expr_stmt|;
name|netd
operator|.
name|dp_atime
operator|+=
literal|3
expr_stmt|;
name|retransmit
operator|++
expr_stmt|;
name|dump
operator|.
name|nretrans
operator|++
expr_stmt|;
continue|continue;
block|}
name|masterseqno
operator|++
expr_stmt|;
name|retransmit
operator|=
literal|0
expr_stmt|;
name|amt
operator|-=
name|num
expr_stmt|;
name|cnt
operator|+=
name|num
expr_stmt|;
block|}
name|netd
operator|.
name|dp_atime
operator|=
name|savetime
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/* return the number of bytes read, or error = BROKENREAD (-2) */
end_comment

begin_expr_stmt
name|nread
argument_list|(
name|bptr
argument_list|,
name|num
argument_list|)
specifier|register
name|char
operator|*
name|bptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|packet
modifier|*
name|pp
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|bcnt
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|;
specifier|static
name|char
name|savebuf
index|[
name|MAXNBUF
index|]
decl_stmt|;
comment|/* first see if theres any left from the last packet */
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufleft
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|savebuf
expr_stmt|;
name|cnt
operator|=
name|n
operator|=
name|min
argument_list|(
name|bufleft
argument_list|,
name|num
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|bptr
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|num
operator|-=
name|cnt
expr_stmt|;
name|bufleft
operator|-=
name|cnt
expr_stmt|;
if|if
condition|(
name|bufleft
operator|>
literal|0
condition|)
block|{
name|q
operator|=
name|savebuf
expr_stmt|;
name|n
operator|=
name|bufleft
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return
operator|(
name|cnt
operator|)
return|;
comment|/* now read a packet */
name|retransmit
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pp
operator|=
name|getpacket
argument_list|()
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|++
name|bcnt
operator|>=
name|netd
operator|.
name|dp_maxbread
condition|)
block|{
name|debug
argument_list|(
literal|"read timeout"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BROKENREAD
operator|)
return|;
block|}
continue|continue;
block|}
comment|/* various errors */
if|if
condition|(
name|pp
operator|->
name|chksum
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"chksum %d"
argument_list|,
name|pp
operator|->
name|seqno
argument_list|)
expr_stmt|;
name|retransmit
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pp
operator|->
name|pcode
operator|&
operator|~
name|REQUEST
condition|)
block|{
name|error
argument_list|(
literal|"pcode %d %d"
argument_list|,
name|pp
operator|->
name|pcode
argument_list|,
name|pp
operator|->
name|seqno
argument_list|)
expr_stmt|;
name|retransmit
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* this is the normal case, so we ack it */
else|else
block|{
comment|/* else was a REQUEST packet, no chksum errs */
comment|/* 			if(pp->seqno == 1)debug("^R "); 			*/
name|pp
operator|->
name|pcode
operator|=
name|ACK
expr_stmt|;
name|n
operator|=
name|pp
operator|->
name|len
expr_stmt|;
name|pp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|sendpacket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* send ACK */
name|pp
operator|->
name|len
operator|=
name|n
expr_stmt|;
break|break;
block|}
block|}
comment|/* now process this packet, bptr points to where we left off */
name|retransmit
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|n
operator|=
name|min
argument_list|(
name|num
argument_list|,
name|pp
operator|->
name|len
argument_list|)
expr_stmt|;
name|cnt
operator|+=
name|j
expr_stmt|;
name|p
operator|=
name|pp
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|bptr
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|len
operator|>
name|num
condition|)
block|{
name|n
operator|=
name|bufleft
operator|=
name|pp
operator|->
name|len
operator|-
name|num
expr_stmt|;
name|bptr
operator|=
name|savebuf
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|bptr
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_macro
name|printpacket
argument_list|(
argument|pp
argument_list|,
argument|dest
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|dest
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|pcode
operator|==
name|REQUEST
condition|)
name|c
operator|=
literal|'r'
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|->
name|pcode
operator|==
name|ACK
condition|)
name|c
operator|=
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|->
name|pcode
operator|==
name|PURGE
condition|)
name|c
operator|=
literal|'p'
expr_stmt|;
else|else
name|c
operator|=
literal|'u'
expr_stmt|;
name|sprintf
argument_list|(
name|dest
argument_list|,
literal|"p:%d len:%d c:%c d:"
argument_list|,
name|pp
operator|->
name|seqno
argument_list|,
name|pp
operator|->
name|len
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|s
operator|=
name|dest
operator|+
name|strlen
argument_list|(
name|dest
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pp
operator|->
name|len
operator|&&
name|pp
operator|->
name|data
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
operator|*
name|s
operator|++
operator|=
name|pp
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * A purge can always be sent -  * the receiver totally ignores it.  * It is used to push the packet terminator  * down the wire in case of a crash  * leaving the receiver half reading.  */
end_comment

begin_macro
name|sendpurge
argument_list|()
end_macro

begin_block
block|{
name|struct
name|packet
modifier|*
name|xptr
decl_stmt|;
name|xptr
operator|=
operator|(
expr|struct
name|packet
operator|*
operator|)
name|wpack
expr_stmt|;
name|xptr
operator|->
name|pcode
operator|=
name|PURGE
expr_stmt|;
name|xptr
operator|->
name|seqno
operator|=
literal|0
expr_stmt|;
name|xptr
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
literal|"send purge"
argument_list|)
expr_stmt|;
name|sendpacket
argument_list|(
name|xptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* init sequence numbers */
end_comment

begin_macro
name|initseqno
argument_list|()
end_macro

begin_block
block|{
name|masterseqno
operator|=
literal|1
expr_stmt|;
name|lastseqno
operator|=
literal|0
expr_stmt|;
name|bufleft
operator|=
literal|0
expr_stmt|;
comment|/* if any chars are left in buffer, flush them*/
name|netd
operator|.
name|dp_atime
operator|=
name|netd
operator|.
name|dp_oatime
operator|+
operator|(
operator|(
name|rand
argument_list|()
operator|>>
literal|8
operator|)
operator|%
literal|15
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Just sends packet pp  *	Calculates the chksum  */
end_comment

begin_macro
name|sendpacket
argument_list|(
argument|pp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|finalp
decl_stmt|;
specifier|static
name|char
name|raw
index|[
name|MAXNBUF
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
comment|/* writes the data to be sent in array raw */
comment|/* finalp will point to either pp or raw */
name|dump
operator|.
name|nbytesent
operator|+=
name|pp
operator|->
name|len
expr_stmt|;
name|dump
operator|.
name|npacksent
operator|++
expr_stmt|;
name|pp
operator|->
name|chksum
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|pp
expr_stmt|;
name|len
operator|=
name|ACKLENGTH
operator|+
name|pp
operator|->
name|len
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
name|n
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
name|pp
operator|->
name|chksum
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|SWAB
name|switchem
argument_list|(
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|RAND
if|if
condition|(
name|netd
operator|.
name|dp_usehispeed
condition|)
name|finalp
operator|=
operator|(
name|char
operator|*
operator|)
name|pp
expr_stmt|;
elseif|else
if|if
condition|(
name|netd
operator|.
name|dp_use8bit
condition|)
block|{
if|if
condition|(
name|len
operator|>=
name|MAXNBUF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Packet size too big- error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* add escapes */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|pp
expr_stmt|;
name|q
operator|=
name|raw
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|q
operator|=
literal|'\n'
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|finalp
operator|=
name|raw
expr_stmt|;
block|}
else|else
block|{
comment|/* now change 8-bit data to 6-bit data */
if|if
condition|(
operator|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|*
literal|4
operator|)
operator|/
literal|3
operator|>=
name|MAXNBUF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Packet size too big- error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|raw
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|pp
expr_stmt|;
name|len
operator|=
name|n
operator|=
operator|(
name|len
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
operator|*
name|q
operator|&
literal|077
operator|)
operator|+
name|INCR
expr_stmt|;
name|j
operator|=
operator|(
operator|*
name|q
operator|++
operator|>>
literal|6
operator|)
operator|&
literal|03
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
operator|(
operator|*
name|q
operator|<<
literal|2
operator|)
operator||
name|j
operator|)
operator|&
literal|077
operator|)
operator|+
name|INCR
expr_stmt|;
name|j
operator|=
operator|(
operator|*
name|q
operator|++
operator|>>
literal|4
operator|)
operator|&
literal|017
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
operator|(
operator|*
name|q
operator|<<
literal|4
operator|)
operator||
name|j
operator|)
operator|&
literal|077
operator|)
operator|+
name|INCR
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
operator|*
name|q
operator|++
operator|>>
literal|2
operator|)
operator|&
literal|077
operator|)
operator|+
name|INCR
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/*	because of bugs in processing around erase and kill in v6 */
for|for
control|(
name|p
operator|=
name|raw
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
operator|*
name|p
operator|=
literal|'}'
expr_stmt|;
name|len
operator|=
name|len
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
name|finalp
operator|=
name|raw
expr_stmt|;
block|}
comment|/* 	debug("send %d<<%s>>",len,raw); 	*/
if|if
condition|(
name|netd
operator|.
name|dp_usehispeed
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|SENDLEN
condition|)
name|error
argument_list|(
literal|"send length too long"
argument_list|)
expr_stmt|;
name|len
operator|=
name|SENDLEN
expr_stmt|;
block|}
if|if
condition|(
name|netd
operator|.
name|dp_pipesim
condition|)
name|i
operator|=
name|write
argument_list|(
name|netd
operator|.
name|dp_pwritefd
argument_list|,
name|finalp
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|write
argument_list|(
name|netd
operator|.
name|dp_linefd
argument_list|,
name|finalp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dump
operator|.
name|braw
operator|+=
name|i
expr_stmt|;
name|dump
operator|.
name|brawtot
operator|+=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|SWAB
name|switchem
argument_list|(
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* for RAND */
name|i
operator|=
name|write
argument_list|(
name|netd
operator|.
name|dp_linefd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	debug("count %d",i); 	*/
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|tooshort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	returns NULL if couldn't get a packet with correct seqno  *	chksum not checked here  * 	because other programs may want to interrogate checksum  */
end_comment

begin_function
name|struct
name|packet
modifier|*
name|getpacket
parameter_list|()
block|{
specifier|register
name|struct
name|packet
modifier|*
name|gptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|,
name|bcnt
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|packet
modifier|*
name|decpacket
parameter_list|()
function_decl|;
name|bcnt
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|setjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmint
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bcnt
operator|++
operator|>
name|netd
operator|.
name|dp_maxbread
condition|)
name|errno
operator|=
literal|100
expr_stmt|;
comment|/* give up */
if|if
condition|(
name|errno
operator|==
literal|100
condition|)
block|{
if|if
condition|(
name|debugflg
condition|)
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* decode the buffer, including 6-8 bit conv, etc. */
name|gptr
operator|=
name|decpacket
argument_list|()
expr_stmt|;
if|if
condition|(
name|gptr
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"getpacket fails"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|tooshort
operator|||
name|gptr
operator|->
name|len
operator|<
literal|0
operator|||
name|gptr
operator|->
name|len
operator|>
name|MAXNBUF
condition|)
block|{
name|error
argument_list|(
literal|"too short p:%d l:%d"
argument_list|,
name|gptr
operator|->
name|seqno
argument_list|,
name|gptr
operator|->
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|gptr
operator|->
name|seqno
operator|==
literal|1
operator|&&
name|gptr
operator|->
name|pcode
operator|!=
name|ACK
condition|)
block|{
name|debug
argument_list|(
literal|"got reset"
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"^R "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gptr
operator|->
name|pcode
operator|==
name|PURGE
condition|)
block|{
name|debug
argument_list|(
literal|"got purge"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* never seen */
block|}
if|if
condition|(
name|gptr
operator|->
name|seqno
operator|==
name|lastseqno
condition|)
block|{
if|if
condition|(
name|retransmit
condition|)
break|break;
comment|/* send ACK - it was lost first time thru */
name|len
operator|=
name|gptr
operator|->
name|len
expr_stmt|;
name|n
operator|=
name|gptr
operator|->
name|pcode
expr_stmt|;
name|gptr
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|gptr
operator|->
name|pcode
operator|=
name|ACK
expr_stmt|;
name|sendpacket
argument_list|(
name|gptr
argument_list|)
expr_stmt|;
name|gptr
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|gptr
operator|->
name|pcode
operator|=
name|n
expr_stmt|;
name|error
argument_list|(
literal|"sendlostack %d"
argument_list|,
name|lastseqno
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* this is the correct case */
if|if
condition|(
name|gptr
operator|->
name|seqno
operator|==
name|lastseqno
operator|+
literal|1
condition|)
break|break;
name|error
argument_list|(
literal|"Wrong seq no g: %d last: %d"
argument_list|,
name|gptr
operator|->
name|seqno
argument_list|,
name|lastseqno
argument_list|)
expr_stmt|;
block|}
name|lastseqno
operator|=
name|gptr
operator|->
name|seqno
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|gptr
operator|->
name|len
operator|+
name|ACKLENGTH
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|gptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|n
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
name|gptr
operator|->
name|chksum
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|dump
operator|.
name|ncksum
operator|++
expr_stmt|;
name|dump
operator|.
name|nbytercv
operator|+=
name|gptr
operator|->
name|len
expr_stmt|;
name|dump
operator|.
name|npackrcv
operator|++
expr_stmt|;
return|return
operator|(
name|gptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read in and decode packet */
end_comment

begin_comment
comment|/* as a side effect sets "tooshort" */
end_comment

begin_function
specifier|static
name|struct
name|packet
modifier|*
name|decpacket
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|RAND
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|,
name|ch
decl_stmt|;
name|struct
name|packet
modifier|*
name|pp
decl_stmt|;
specifier|static
name|char
name|cooked
index|[
name|MAXNBUF
index|]
decl_stmt|,
name|raw
index|[
name|MAXNBUF
index|]
decl_stmt|;
comment|/* read in chars to raw, if processed then return in cooked, otherwise 	return in raw */
name|alarm
argument_list|(
name|netd
operator|.
name|dp_atime
argument_list|)
expr_stmt|;
name|tooshort
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|netd
operator|.
name|dp_pipesim
condition|)
block|{
if|if
condition|(
name|netd
operator|.
name|dp_usehispeed
condition|)
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|netd
operator|.
name|dp_rdfile
argument_list|)
argument_list|,
name|raw
argument_list|,
name|SENDLEN
argument_list|)
expr_stmt|;
else|else
block|{
name|q
operator|=
name|raw
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|netd
operator|.
name|dp_rdfile
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
comment|/* eat up the backslashes */
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|&&
name|netd
operator|.
name|dp_use8bit
condition|)
name|ch
operator|=
name|getc
argument_list|(
name|netd
operator|.
name|dp_rdfile
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|netd
operator|.
name|dp_use8bit
condition|)
name|len
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|netd
operator|.
name|dp_usehispeed
condition|)
name|len
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|netd
operator|.
name|dp_rdfile
argument_list|)
argument_list|,
name|raw
argument_list|,
name|SENDLEN
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|read
argument_list|(
name|netd
operator|.
name|dp_linefd
argument_list|,
name|raw
argument_list|,
name|MAXNBUF
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"eof pip %d\n"
argument_list|,
name|fileno
argument_list|(
name|netd
operator|.
name|dp_rdfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|raw
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|dump
operator|.
name|braw
operator|+=
name|len
expr_stmt|;
name|dump
operator|.
name|brawtot
operator|+=
name|len
expr_stmt|;
comment|/* 	debug("receive %d<<%s>>",len,raw); 	*/
comment|/* if 8 bit the all we need to do is return */
if|if
condition|(
name|netd
operator|.
name|dp_usehispeed
condition|)
return|return
operator|(
operator|(
expr|struct
name|packet
operator|*
operator|)
name|raw
operator|)
return|;
if|if
condition|(
name|netd
operator|.
name|dp_use8bit
condition|)
block|{
name|pp
operator|=
operator|(
expr|struct
name|packet
operator|*
operator|)
name|raw
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|ACKLENGTH
operator|+
name|pp
operator|->
name|len
condition|)
name|tooshort
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|pp
operator|)
return|;
block|}
comment|/* remove this loop later */
for|for
control|(
name|p
operator|=
name|raw
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
operator|*
name|p
operator|=
literal|'\\'
expr_stmt|;
name|p
operator|=
name|raw
expr_stmt|;
name|q
operator|=
name|cooked
expr_stmt|;
name|n
operator|=
operator|(
name|len
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|<
name|INCR
operator|||
operator|*
name|p
operator|&
literal|0200
condition|)
name|error
argument_list|(
literal|"bad char %o\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
operator|-
name|INCR
expr_stmt|;
name|j
operator|=
operator|*
name|p
operator|++
operator|-
name|INCR
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
operator|(
name|j
operator|&
literal|03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|i
operator|&
literal|077
operator|)
expr_stmt|;
name|i
operator|=
operator|*
name|p
operator|++
operator|-
name|INCR
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
operator|(
name|i
operator|&
literal|017
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|j
operator|>>
literal|2
operator|)
operator|&
literal|017
operator|)
expr_stmt|;
name|j
operator|=
operator|*
name|p
operator|++
operator|-
name|INCR
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
operator|(
name|j
operator|&
literal|077
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|i
operator|>>
literal|4
operator|)
operator|&
literal|03
operator|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|packet
operator|*
operator|)
name|cooked
expr_stmt|;
ifdef|#
directive|ifdef
name|SWAB
name|switchem
argument_list|(
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|!=
operator|(
operator|(
name|ACKLENGTH
operator|+
name|pp
operator|->
name|len
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
operator|*
literal|4
operator|+
literal|1
condition|)
name|tooshort
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* for RAND */
comment|/* not sure of the length computation */
if|if
condition|(
name|len
operator|!=
name|ACKLENGTH
operator|+
name|gptr
operator|->
name|len
condition|)
name|tooshort
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
expr|struct
name|packet
operator|*
operator|)
name|cooked
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SWAB
end_ifdef

begin_expr_stmt
name|switchem
argument_list|(
name|pp
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
operator|(
name|pp
operator|->
name|seqno
operator|)
expr_stmt|;
name|swab
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
operator|(
name|pp
operator|->
name|len
operator|)
expr_stmt|;
name|swab
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

