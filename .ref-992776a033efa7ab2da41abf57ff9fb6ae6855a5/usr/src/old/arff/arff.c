begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)arff.c	4.12 (Berkeley) 82/12/23"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|dbprintf
value|printf
end_define

begin_struct
struct|struct
name|rt_dat
block|{
name|u_short
name|rt_yr
range|:
literal|5
decl_stmt|;
comment|/* year-1972 */
name|u_short
name|rt_dy
range|:
literal|5
decl_stmt|;
comment|/* day */
name|u_short
name|rt_mo
range|:
literal|5
decl_stmt|;
comment|/* month */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rt_axent
block|{
name|char
name|rt_sent
index|[
literal|14
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rt_ent
block|{
name|char
name|rt_pad
decl_stmt|;
comment|/* unusued */
name|char
name|rt_stat
decl_stmt|;
comment|/* type of entry, or end of seg */
name|u_short
name|rt_name
index|[
literal|3
index|]
decl_stmt|;
comment|/* name, 3 words in rad50 form */
name|u_short
name|rt_len
decl_stmt|;
comment|/* length of file */
name|char
name|rt_chan
decl_stmt|;
comment|/* only used in temporary files */
name|char
name|rt_job
decl_stmt|;
comment|/* only used in temporary files */
name|struct
name|rt_dat
name|rt_date
decl_stmt|;
comment|/* creation date */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RT_TEMP
value|1
end_define

begin_define
define|#
directive|define
name|RT_NULL
value|2
end_define

begin_define
define|#
directive|define
name|RT_FILE
value|4
end_define

begin_define
define|#
directive|define
name|RT_ESEG
value|8
end_define

begin_define
define|#
directive|define
name|RT_BLOCK
value|512
end_define

begin_comment
comment|/* block size */
end_comment

begin_define
define|#
directive|define
name|RT_DIRSIZE
value|31
end_define

begin_comment
comment|/* max # of directory segments */
end_comment

begin_struct
struct|struct
name|rt_head
block|{
name|short
name|rt_numseg
decl_stmt|;
comment|/* # of segments available */
name|short
name|rt_nxtseg
decl_stmt|;
comment|/* # of next logical segment */
name|short
name|rt_lstseg
decl_stmt|;
comment|/* highest seg currently open */
name|u_short
name|rt_entpad
decl_stmt|;
comment|/* extra words/directory entry */
name|short
name|rt_stfile
decl_stmt|;
comment|/* block # where files begin */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rt_dir
block|{
name|struct
name|rt_head
name|rt_axhead
decl_stmt|;
name|struct
name|rt_ent
name|rt_ents
index|[
literal|72
index|]
decl_stmt|;
name|char
name|_dirpad
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|fldope
block|{
name|int
name|startad
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|rt_ent
modifier|*
name|rtdope
decl_stmt|;
block|}
name|FLDOPE
typedef|;
end_typedef

begin_function_decl
name|FLDOPE
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|rt
parameter_list|(
name|p
parameter_list|)
value|((struct rt_ent *) p )
end_define

begin_define
define|#
directive|define
name|Ain1
value|03100
end_define

begin_define
define|#
directive|define
name|Ain2
value|050
end_define

begin_define
define|#
directive|define
name|flag
parameter_list|(
name|c
parameter_list|)
value|(flg[('c') - 'a'])
end_define

begin_decl_stmt
name|char
modifier|*
name|man
init|=
literal|"rxtd"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|zeroes
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rt_dir
name|rt_dir
index|[
name|RT_DIRSIZE
index|]
init|=
block|{
block|{
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|14
block|}
block|,
block|{
block|{
literal|0
block|,
name|RT_NULL
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|494
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|RT_ESEG
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rt_entsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rt_nleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rt_ent
modifier|*
name|rt_curend
index|[
name|RT_DIRSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|floppydes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dirdirty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rt_last
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|defdev
init|=
literal|"/dev/floppy"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|opt
init|=
literal|"vf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|signum
index|[]
init|=
block|{
name|SIGHUP
block|,
name|SIGINT
block|,
name|SIGQUIT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|rcmd
argument_list|()
decl_stmt|,
name|dcmd
argument_list|()
decl_stmt|,
name|xcmd
argument_list|()
decl_stmt|,
name|tcmd
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|comfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|flg
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|namv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|namc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|cp
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'m'
case|:
case|case
literal|'v'
case|:
case|case
literal|'u'
case|:
case|case
literal|'w'
case|:
name|flg
index|[
operator|*
name|cp
operator|-
literal|'a'
index|]
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
block|{
define|#
directive|define
name|SURE
value|"Last chance before clobbering floppy?"
name|int
name|tty
decl_stmt|;
name|char
name|response
index|[
literal|128
index|]
decl_stmt|;
name|tty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|tty
argument_list|,
name|SURE
argument_list|,
sizeof|sizeof
argument_list|(
name|SURE
argument_list|)
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|tty
argument_list|,
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|response
operator|!=
literal|'y'
condition|)
name|exit
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|flag
argument_list|(
name|c
argument_list|)
operator|++
expr_stmt|;
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
name|dirdirty
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|setcom
argument_list|(
name|rcmd
argument_list|)
expr_stmt|;
name|flag
argument_list|(
name|r
argument_list|)
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|setcom
argument_list|(
name|dcmd
argument_list|)
expr_stmt|;
name|flag
argument_list|(
name|d
argument_list|)
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|setcom
argument_list|(
name|xcmd
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|setcom
argument_list|(
name|tcmd
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|defdev
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
continue|continue;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: bad option `%c'\n"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|namv
operator|=
name|argv
operator|+
literal|2
expr_stmt|;
name|namc
operator|=
name|argc
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|comfun
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flag
argument_list|(
name|u
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: one of [%s] must be specified\n"
argument_list|,
name|man
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setcom
argument_list|(
name|rcmd
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|comfun
call|)
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|notfound
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|setcom
function_decl|(
name|fun
function_decl|)
name|int
argument_list|(
argument|*fun
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|comfun
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: only one of [%s] allowed\n"
argument_list|,
name|man
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|comfun
operator|=
name|fun
expr_stmt|;
block|}
end_block

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: ar [%s][%s] archive files ...\n"
argument_list|,
name|opt
argument_list|,
name|man
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|notfound
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|namv
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: %s not found\n"
argument_list|,
name|namv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|mesg
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|flag
argument_list|(
name|v
argument_list|)
condition|)
if|if
condition|(
name|c
operator|!=
literal|'c'
operator|||
name|flag
argument_list|(
name|v
argument_list|)
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%c - %s\n"
argument_list|,
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tcmd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|de
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|FLDOPE
modifier|*
name|lookup
argument_list|()
decl_stmt|,
modifier|*
name|dope
decl_stmt|;
name|int
name|segnum
decl_stmt|,
name|nleft
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|rt_ent
modifier|*
name|rde
decl_stmt|;
name|rt_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|namc
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dope
operator|=
name|lookup
argument_list|(
name|namv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|rde
operator|=
name|dope
operator|->
name|rtdope
expr_stmt|;
name|rtls
argument_list|(
name|rde
argument_list|)
expr_stmt|;
name|namv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|segnum
operator|=
literal|0
init|;
name|segnum
operator|!=
operator|-
literal|1
condition|;
name|segnum
operator|=
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_axhead
operator|.
name|rt_nxtseg
operator|-
literal|1
control|)
block|{
name|last
operator|=
name|rt_last
operator|+
name|segnum
operator|*
literal|2
operator|*
name|RT_BLOCK
expr_stmt|;
for|for
control|(
name|de
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
name|segnum
index|]
operator|)
operator|+
literal|10
init|;
name|de
operator|<=
name|last
condition|;
name|de
operator|+=
name|rt_entsiz
control|)
if|if
condition|(
name|rtls
argument_list|(
name|rt
argument_list|(
name|de
argument_list|)
argument_list|)
condition|)
block|{
name|nleft
operator|=
operator|(
name|last
operator|-
name|de
operator|)
operator|/
name|rt_entsiz
expr_stmt|;
define|#
directive|define
name|ENTRIES
value|"\n%d entries remaining in directory segment %d.\n"
name|printf
argument_list|(
name|ENTRIES
argument_list|,
name|nleft
argument_list|,
name|segnum
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|rtls
argument_list|(
name|de
argument_list|)
specifier|register
expr|struct
name|rt_ent
operator|*
name|de
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|month
decl_stmt|,
name|day
decl_stmt|,
name|year
decl_stmt|;
name|char
name|name
index|[
literal|12
index|]
decl_stmt|,
name|ext
index|[
literal|4
index|]
decl_stmt|;
switch|switch
condition|(
name|de
operator|->
name|rt_stat
condition|)
block|{
case|case
name|RT_TEMP
case|:
if|if
condition|(
name|flag
argument_list|(
name|v
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Tempfile:\n"
argument_list|)
expr_stmt|;
comment|/* fall thru...*/
case|case
name|RT_FILE
case|:
if|if
condition|(
operator|!
name|flag
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|sunrad50
argument_list|(
name|name
argument_list|,
name|de
operator|->
name|rt_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|unrad50
argument_list|(
literal|2
argument_list|,
name|de
operator|->
name|rt_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|unrad50
argument_list|(
literal|1
argument_list|,
operator|&
operator|(
name|de
operator|->
name|rt_name
index|[
literal|2
index|]
operator|)
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|day
operator|=
name|de
operator|->
name|rt_date
operator|.
name|rt_dy
expr_stmt|;
name|year
operator|=
name|de
operator|->
name|rt_date
operator|.
name|rt_yr
operator|+
literal|72
expr_stmt|;
name|month
operator|=
name|de
operator|->
name|rt_date
operator|.
name|rt_mo
expr_stmt|;
name|printf
argument_list|(
literal|"%6.6s  %3.3s	%02d/%02d/%02d	%d\n"
argument_list|,
name|name
argument_list|,
name|ext
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|year
argument_list|,
name|de
operator|->
name|rt_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_NULL
case|:
name|printf
argument_list|(
literal|"%-25.9s	%d\n"
argument_list|,
literal|"<UNUSED>"
argument_list|,
name|de
operator|->
name|rt_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_ESEG
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|xcmd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|de
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|segnum
decl_stmt|;
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rt_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|namc
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx
argument_list|(
name|namv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|namv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|segnum
operator|=
literal|0
init|;
name|segnum
operator|!=
operator|-
literal|1
condition|;
name|segnum
operator|=
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_axhead
operator|.
name|rt_nxtseg
operator|-
literal|1
control|)
for|for
control|(
name|last
operator|=
name|rt_last
operator|+
operator|(
name|segnum
operator|*
literal|2
operator|*
name|RT_BLOCK
operator|)
operator|,
name|de
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
name|segnum
index|]
operator|)
operator|+
literal|10
init|;
name|de
operator|<=
name|last
condition|;
name|de
operator|+=
name|rt_entsiz
control|)
switch|switch
condition|(
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_stat
condition|)
block|{
case|case
name|RT_ESEG
case|:
return|return;
case|case
name|RT_TEMP
case|:
case|case
name|RT_FILE
case|:
name|sunrad50
argument_list|(
name|name
argument_list|,
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_name
argument_list|)
expr_stmt|;
name|rtx
argument_list|(
name|name
argument_list|)
expr_stmt|;
case|case
name|RT_NULL
case|:
break|break;
block|}
block|}
end_block

begin_macro
name|rtx
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FLDOPE
modifier|*
name|dope
decl_stmt|;
name|FLDOPE
modifier|*
name|lookup
parameter_list|()
function_decl|;
specifier|register
name|startad
operator|,
name|count
expr_stmt|;
name|int
name|file
decl_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|dope
operator|=
name|lookup
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag
argument_list|(
name|v
argument_list|)
condition|)
name|rtls
argument_list|(
name|dope
operator|->
name|rtdope
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"x - %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|count
operator|=
name|dope
operator|->
name|count
expr_stmt|;
name|startad
operator|=
name|dope
operator|->
name|startad
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|-=
literal|512
control|)
block|{
name|lread
argument_list|(
name|startad
argument_list|,
literal|512
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|file
argument_list|,
name|buff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|startad
operator|+=
literal|512
expr_stmt|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|rt_init
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|initized
operator|=
literal|0
expr_stmt|;
specifier|register
name|char
modifier|*
name|de
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|dirnum
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
name|FILE
modifier|*
name|temp_floppydes
decl_stmt|;
if|if
condition|(
name|initized
condition|)
return|return;
name|initized
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag
argument_list|(
name|c
argument_list|)
operator|||
name|flag
argument_list|(
name|d
argument_list|)
operator|||
name|flag
argument_list|(
name|r
argument_list|)
condition|)
name|mode
operator|=
literal|"r+"
expr_stmt|;
else|else
name|mode
operator|=
literal|"r"
expr_stmt|;
if|if
condition|(
operator|(
name|temp_floppydes
operator|=
name|fopen
argument_list|(
name|defdev
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|defdev
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|floppydes
operator|=
name|fileno
argument_list|(
name|temp_floppydes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|lread
argument_list|(
literal|6
operator|*
name|RT_BLOCK
argument_list|,
literal|2
operator|*
name|RT_BLOCK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dirnum
operator|=
name|rt_dir
index|[
literal|0
index|]
operator|.
name|rt_axhead
operator|.
name|rt_numseg
expr_stmt|;
if|if
condition|(
name|dirnum
operator|>
name|RT_DIRSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: too many directory segments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|dirnum
condition|;
name|i
operator|++
control|)
name|lread
argument_list|(
operator|(
literal|6
operator|+
literal|2
operator|*
name|i
operator|)
operator|*
name|RT_BLOCK
argument_list|,
literal|2
operator|*
name|RT_BLOCK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|dirnum
operator|=
literal|1
expr_stmt|;
name|rt_entsiz
operator|=
literal|2
operator|*
name|rt_dir
index|[
literal|0
index|]
operator|.
name|rt_axhead
operator|.
name|rt_entpad
operator|+
literal|14
expr_stmt|;
name|rt_entsiz
operator|=
literal|14
expr_stmt|;
comment|/* assume rt_entpad = 0 ??? */
name|rt_last
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
literal|0
index|]
operator|)
operator|+
literal|10
operator|+
literal|1014
operator|/
name|rt_entsiz
operator|*
name|rt_entsiz
expr_stmt|;
name|rt_nleft
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dirnum
condition|;
name|i
operator|++
control|)
block|{
name|last
operator|=
name|rt_last
operator|+
name|i
operator|*
literal|2
operator|*
name|RT_BLOCK
expr_stmt|;
for|for
control|(
name|de
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
name|i
index|]
operator|)
operator|+
literal|10
init|;
name|de
operator|<=
name|last
condition|;
name|de
operator|+=
name|rt_entsiz
control|)
if|if
condition|(
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_stat
operator|==
name|RT_ESEG
condition|)
break|break;
name|rt_curend
index|[
name|i
index|]
operator|=
name|rt
argument_list|(
name|de
argument_list|)
expr_stmt|;
name|rt_nleft
operator|+=
operator|(
name|last
operator|-
name|de
operator|)
operator|/
name|rt_entsiz
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|FLDOPE
name|result
decl_stmt|;
end_decl_stmt

begin_function
name|FLDOPE
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|short
name|rname
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|de
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|segnum
decl_stmt|;
specifier|register
name|index
expr_stmt|;
name|srad50
argument_list|(
name|name
argument_list|,
name|rname
argument_list|)
expr_stmt|;
comment|/*  	 *  Search for name, accumulate blocks in index 	 */
name|rt_init
argument_list|()
expr_stmt|;
for|for
control|(
name|segnum
operator|=
literal|0
init|;
name|segnum
operator|!=
operator|-
literal|1
condition|;
name|segnum
operator|=
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_axhead
operator|.
name|rt_nxtseg
operator|-
literal|1
control|)
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|rt_last
operator|+
name|segnum
operator|*
literal|2
operator|*
name|RT_BLOCK
expr_stmt|;
for|for
control|(
name|de
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
name|segnum
index|]
operator|)
operator|+
literal|10
init|;
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_stat
operator|!=
name|RT_ESEG
condition|;
name|de
operator|+=
name|rt_entsiz
control|)
switch|switch
condition|(
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_stat
condition|)
block|{
case|case
name|RT_FILE
case|:
case|case
name|RT_TEMP
case|:
if|if
condition|(
name|samename
argument_list|(
name|rname
argument_list|,
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_name
argument_list|)
condition|)
block|{
name|result
operator|.
name|count
operator|=
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_len
operator|*
literal|512
expr_stmt|;
name|result
operator|.
name|startad
operator|=
literal|512
operator|*
operator|(
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_axhead
operator|.
name|rt_stfile
operator|+
name|index
operator|)
expr_stmt|;
name|result
operator|.
name|rtdope
operator|=
operator|(
expr|struct
name|rt_ent
operator|*
operator|)
name|de
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
case|case
name|RT_NULL
case|:
name|index
operator|+=
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_len
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|FLDOPE
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|samename
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
name|u_short
name|a
index|[]
operator|,
name|b
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|*
name|a
operator|==
operator|*
name|b
operator|&&
name|a
index|[
literal|1
index|]
operator|==
name|b
index|[
literal|1
index|]
operator|&&
name|a
index|[
literal|2
index|]
operator|==
name|b
index|[
literal|2
index|]
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rad50
argument_list|(
name|cp
argument_list|,
name|out
argument_list|)
specifier|register
name|u_char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_short
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|index
operator|,
name|temp
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|index
operator|++
control|)
block|{
name|temp
operator|=
name|Ain1
operator|*
name|table
index|[
operator|*
name|cp
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0
condition|)
block|{
name|temp
operator|+=
name|Ain2
operator|*
name|table
index|[
operator|*
name|cp
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0
condition|)
name|temp
operator|+=
name|table
index|[
operator|*
name|cp
operator|++
index|]
expr_stmt|;
block|}
name|out
index|[
name|index
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|reduce
parameter_list|(
name|x
parameter_list|,
name|p
parameter_list|,
name|q
parameter_list|)
value|(x = v[p/q], p %= q);
end_define

begin_macro
name|unrad50
argument_list|(
argument|count
argument_list|,
argument|in
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|u_short
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|temp
expr_stmt|;
specifier|register
name|u_char
modifier|*
name|v
init|=
operator|(
name|u_char
operator|*
operator|)
name|val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|in
index|[
name|i
index|]
expr_stmt|;
name|reduce
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|temp
argument_list|,
name|Ain1
argument_list|)
expr_stmt|;
name|reduce
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|temp
argument_list|,
name|Ain2
argument_list|)
expr_stmt|;
name|reduce
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|srad50
argument_list|(
name|name
argument_list|,
name|rname
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|u_short
modifier|*
name|rname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|index
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|file
index|[
literal|7
index|]
decl_stmt|,
name|ext
index|[
literal|4
index|]
decl_stmt|;
comment|/*  	 * Find end of pathname 	 */
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
operator|++
condition|;
control|)
empty_stmt|;
while|while
condition|(
name|cp
operator|>=
name|name
operator|&&
operator|*
operator|--
name|cp
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|cp
operator|++
expr_stmt|;
comment|/*  	 * Change to rad50 	 */
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
control|)
block|{
name|file
index|[
name|index
operator|++
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|index
operator|>=
literal|6
condition|)
block|{
break|break;
block|}
block|}
name|file
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
control|)
block|{
name|ext
index|[
name|index
operator|++
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
operator|||
name|index
operator|>=
literal|3
condition|)
break|break;
block|}
name|ext
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|rname
index|[
literal|0
index|]
operator|=
name|rname
index|[
literal|1
index|]
operator|=
name|rname
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rad50
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|file
argument_list|,
name|rname
argument_list|)
expr_stmt|;
name|rad50
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ext
argument_list|,
name|rname
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sunrad50
argument_list|(
argument|name
argument_list|,
argument|rname
argument_list|)
end_macro

begin_decl_stmt
name|u_short
name|rname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
name|ext
index|[
literal|4
index|]
decl_stmt|;
name|unrad50
argument_list|(
literal|2
argument_list|,
name|rname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|unrad50
argument_list|(
literal|1
argument_list|,
name|rname
operator|+
literal|2
argument_list|,
name|ext
argument_list|)
expr_stmt|;
comment|/* 	 * Jam name and extension together with a dot 	 * deleting white space 	 */
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
operator|++
condition|;
control|)
empty_stmt|;
operator|--
name|cp
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|cp
operator|==
literal|' '
operator|&&
name|cp
operator|>=
name|name
condition|)
empty_stmt|;
operator|*
operator|++
name|cp
operator|=
literal|'.'
expr_stmt|;
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|cp2
operator|=
name|ext
init|;
operator|*
name|cp2
operator|!=
literal|' '
operator|&&
name|cp2
operator|<
name|ext
operator|+
literal|3
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp2
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|oval
init|=
literal|" ABCDEFGHIJKLMNOPQRSTUVWXYZ$.@0123456789"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|val
init|=
literal|" abcdefghijklmnopqrstuvwxyz$.@0123456789"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|table
index|[
literal|256
index|]
init|=
block|{
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|0
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|27
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|0
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|27
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|,
literal|29
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Logical to physical adress translation  */
end_comment

begin_function
name|long
name|trans
parameter_list|(
name|logical
parameter_list|)
specifier|register
name|int
name|logical
decl_stmt|;
block|{
specifier|register
name|int
name|sector
decl_stmt|,
name|bytes
decl_stmt|,
name|track
decl_stmt|;
name|logical
operator|+=
literal|26
operator|*
literal|128
expr_stmt|;
name|bytes
operator|=
operator|(
name|logical
operator|&
literal|127
operator|)
expr_stmt|;
name|logical
operator|>>=
literal|7
expr_stmt|;
name|sector
operator|=
name|logical
operator|%
literal|26
expr_stmt|;
if|if
condition|(
name|sector
operator|>=
literal|13
condition|)
name|sector
operator|=
name|sector
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
else|else
name|sector
operator|*=
literal|2
expr_stmt|;
name|sector
operator|+=
literal|26
operator|+
operator|(
operator|(
name|track
operator|=
operator|(
name|logical
operator|/
literal|26
operator|)
operator|)
operator|-
literal|1
operator|)
operator|*
literal|6
expr_stmt|;
name|sector
operator|%=
literal|26
expr_stmt|;
return|return
operator|(
operator|(
operator|(
operator|(
name|track
operator|*
literal|26
operator|)
operator|+
name|sector
operator|)
operator|<<
literal|7
operator|)
operator|+
name|bytes
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|lread
argument_list|(
name|startad
argument_list|,
name|count
argument_list|,
name|obuff
argument_list|)
specifier|register
name|startad
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|obuff
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|trans
parameter_list|()
function_decl|;
extern|extern floppydes;
specifier|register
name|int
name|size
init|=
name|flag
argument_list|(
name|m
argument_list|)
condition|?
literal|512
else|:
literal|128
decl_stmt|;
name|rt_init
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|-=
name|size
operator|)
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|floppydes
argument_list|,
name|flag
argument_list|(
name|m
argument_list|)
condition|?
operator|(
name|long
operator|)
name|startad
else|:
name|trans
argument_list|(
name|startad
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|floppydes
argument_list|,
name|obuff
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: read error block %d\n"
argument_list|,
name|startad
operator|/
name|size
argument_list|)
expr_stmt|;
name|obuff
operator|+=
name|size
expr_stmt|;
name|startad
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|lwrite
argument_list|(
name|startad
argument_list|,
name|count
argument_list|,
name|obuff
argument_list|)
specifier|register
name|startad
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|obuff
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|trans
parameter_list|()
function_decl|;
extern|extern floppydes;
specifier|register
name|int
name|size
init|=
name|flag
argument_list|(
name|m
argument_list|)
condition|?
literal|512
else|:
literal|128
decl_stmt|;
name|rt_init
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|-=
name|size
operator|)
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|floppydes
argument_list|,
name|flag
argument_list|(
name|m
argument_list|)
condition|?
operator|(
name|long
operator|)
name|startad
else|:
name|trans
argument_list|(
name|startad
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|floppydes
argument_list|,
name|obuff
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: write error block %d\n"
argument_list|,
name|startad
operator|/
name|size
argument_list|)
expr_stmt|;
name|obuff
operator|+=
name|size
expr_stmt|;
name|startad
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rcmd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rt_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|namc
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtr
argument_list|(
name|namv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|namv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|rtr
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FLDOPE
modifier|*
name|dope
decl_stmt|;
specifier|register
name|struct
name|rt_ent
modifier|*
name|de
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|bufp
init|=
operator|&
name|buf
decl_stmt|;
name|int
name|segnum
decl_stmt|;
specifier|register
name|char
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
name|bufp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dope
operator|=
name|lookup
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* can replace, no problem */
name|de
operator|=
name|dope
operator|->
name|rtdope
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|st_size
operator|<=
operator|(
name|de
operator|->
name|rt_len
operator|*
literal|512
operator|)
condition|)
name|printf
argument_list|(
literal|"r - %s\n"
argument_list|,
name|name
argument_list|)
operator|,
name|toflop
argument_list|(
name|name
argument_list|,
name|bufp
operator|->
name|st_size
argument_list|,
name|dope
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s will not fit in currently used file on floppy\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
goto|goto
name|found
goto|;
block|}
comment|/* 	 * Search for vacant spot 	 */
for|for
control|(
name|segnum
operator|=
literal|0
init|;
name|segnum
operator|!=
operator|-
literal|1
condition|;
name|segnum
operator|=
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_axhead
operator|.
name|rt_nxtseg
operator|-
literal|1
control|)
block|{
name|last
operator|=
name|rt_last
operator|+
name|segnum
operator|*
literal|2
operator|*
name|RT_BLOCK
expr_stmt|;
for|for
control|(
name|de
operator|=
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_ents
init|;
name|rt
argument_list|(
name|de
argument_list|)
operator|->
name|rt_stat
operator|!=
name|RT_ESEG
condition|;
name|de
operator|++
control|)
if|if
condition|(
operator|(
name|de
operator|)
operator|->
name|rt_stat
operator|==
name|RT_NULL
condition|)
block|{
if|if
condition|(
name|bufp
operator|->
name|st_size
operator|<=
operator|(
name|de
operator|->
name|rt_len
operator|*
literal|512
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"a - %s\n"
argument_list|,
name|name
argument_list|)
operator|,
name|mkent
argument_list|(
name|de
argument_list|,
name|segnum
argument_list|,
name|bufp
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
continue|continue;
block|}
block|}
name|printf
argument_list|(
literal|"%s: no slot for file\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|found
label|:
if|if
condition|(
name|dope
operator|=
name|lookup
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|toflop
argument_list|(
name|name
argument_list|,
name|bufp
operator|->
name|st_size
argument_list|,
name|dope
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%s: internal error, added then not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mkent
argument_list|(
name|de
argument_list|,
name|segnum
argument_list|,
name|bufp
argument_list|,
name|name
argument_list|)
specifier|register
expr|struct
name|rt_ent
operator|*
name|de
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|segnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|stat
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
specifier|register
name|struct
name|tm
modifier|*
name|timp
decl_stmt|;
specifier|register
name|struct
name|rt_ent
modifier|*
name|workp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
name|bufp
operator|->
name|st_size
operator|-
literal|1
operator|)
operator|>>
literal|9
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* make sure there is room */
if|if
condition|(
name|de
operator|->
name|rt_len
operator|==
name|count
condition|)
goto|goto
name|overwrite
goto|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|rt_curend
index|[
name|segnum
index|]
operator|==
operator|(
name|rt_last
operator|+
operator|(
name|segnum
operator|*
literal|2
operator|*
name|RT_BLOCK
operator|)
operator|)
condition|)
block|{
comment|/* no entries left on segment */
if|if
condition|(
name|flag
argument_list|(
name|o
argument_list|)
condition|)
goto|goto
name|overwrite
goto|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Directory segment #%d full on  %s\n"
argument_list|,
name|segnum
operator|+
literal|1
argument_list|,
name|defdev
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* copy directory entries up */
for|for
control|(
name|workp
operator|=
name|rt_curend
index|[
name|segnum
index|]
operator|+
literal|1
init|;
name|workp
operator|>
name|de
condition|;
name|workp
operator|--
control|)
operator|*
name|workp
operator|=
name|workp
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|de
index|[
literal|1
index|]
operator|.
name|rt_len
operator|-=
name|count
expr_stmt|;
name|de
operator|->
name|rt_len
operator|=
name|count
expr_stmt|;
name|rt_curend
index|[
name|segnum
index|]
operator|++
expr_stmt|;
name|rt_nleft
operator|--
expr_stmt|;
name|overwrite
label|:
name|srad50
argument_list|(
name|name
argument_list|,
name|de
operator|->
name|rt_name
argument_list|)
expr_stmt|;
name|timp
operator|=
name|localtime
argument_list|(
operator|&
name|bufp
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
name|de
operator|->
name|rt_date
operator|.
name|rt_dy
operator|=
name|timp
operator|->
name|tm_mday
expr_stmt|;
name|de
operator|->
name|rt_date
operator|.
name|rt_mo
operator|=
name|timp
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|de
operator|->
name|rt_date
operator|.
name|rt_yr
operator|=
name|timp
operator|->
name|tm_year
operator|-
literal|72
expr_stmt|;
name|de
operator|->
name|rt_stat
operator|=
name|RT_FILE
expr_stmt|;
name|de
operator|->
name|rt_pad
operator|=
literal|0
expr_stmt|;
name|de
operator|->
name|rt_chan
operator|=
literal|0
expr_stmt|;
name|de
operator|->
name|rt_job
operator|=
literal|0
expr_stmt|;
name|lwrite
argument_list|(
operator|(
literal|6
operator|+
name|segnum
operator|*
literal|2
operator|)
operator|*
name|RT_BLOCK
argument_list|,
literal|2
operator|*
name|RT_BLOCK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
name|segnum
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|toflop
argument_list|(
argument|name
argument_list|,
argument|ocount
argument_list|,
argument|dope
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FLDOPE
modifier|*
name|dope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ocount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|file
operator|,
name|n
operator|,
name|startad
operator|=
name|dope
operator|->
name|startad
operator|,
name|count
operator|=
name|ocount
expr_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
name|file
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arff: couldn't open %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
operator|>=
literal|512
condition|;
name|count
operator|-=
literal|512
control|)
block|{
name|read
argument_list|(
name|file
argument_list|,
name|buff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|lwrite
argument_list|(
name|startad
argument_list|,
literal|512
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|startad
operator|+=
literal|512
expr_stmt|;
block|}
name|read
argument_list|(
name|file
argument_list|,
name|buff
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
name|n
operator|=
name|count
init|;
name|n
operator|<
literal|512
condition|;
name|n
operator|++
control|)
name|buff
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|lwrite
argument_list|(
name|startad
argument_list|,
literal|512
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|dope
operator|->
name|rtdope
operator|->
name|rt_len
operator|*
literal|512
operator|-
name|ocount
operator|)
operator|/
literal|512
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|startad
operator|+=
literal|512
expr_stmt|;
name|lwrite
argument_list|(
name|startad
argument_list|,
literal|512
argument_list|,
name|zeroes
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|dcmd
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rt_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|namc
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtk
argument_list|(
name|namv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|namv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dirdirty
condition|)
name|scrunch
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|rtk
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FLDOPE
modifier|*
name|dope
decl_stmt|;
specifier|register
name|struct
name|rt_ent
modifier|*
name|de
decl_stmt|;
name|FLDOPE
modifier|*
name|lookup
parameter_list|()
function_decl|;
if|if
condition|(
name|dope
operator|=
name|lookup
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"d - %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|de
operator|=
name|dope
operator|->
name|rtdope
expr_stmt|;
name|de
operator|->
name|rt_stat
operator|=
name|RT_NULL
expr_stmt|;
name|de
operator|->
name|rt_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|de
operator|->
name|rt_name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|de
operator|->
name|rt_name
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
operator|(
name|de
operator|->
name|rt_date
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|dirdirty
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|scrunch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|rt_ent
modifier|*
name|de
decl_stmt|,
modifier|*
name|workp
decl_stmt|;
specifier|register
name|segnum
expr_stmt|;
for|for
control|(
name|segnum
operator|=
literal|0
init|;
name|segnum
operator|!=
operator|-
literal|1
condition|;
name|segnum
operator|=
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_axhead
operator|.
name|rt_nxtseg
operator|-
literal|1
control|)
block|{
name|dirdirty
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|de
operator|=
name|rt_dir
index|[
name|segnum
index|]
operator|.
name|rt_ents
init|;
name|de
operator|<=
name|rt_curend
index|[
name|segnum
index|]
condition|;
name|de
operator|++
control|)
if|if
condition|(
name|de
operator|->
name|rt_stat
operator|==
name|RT_NULL
operator|&&
name|de
index|[
literal|1
index|]
operator|.
name|rt_stat
operator|==
name|RT_NULL
condition|)
block|{
operator|(
name|de
operator|+
literal|1
operator|)
operator|->
name|rt_len
operator|+=
name|de
operator|->
name|rt_len
expr_stmt|;
for|for
control|(
name|workp
operator|=
name|de
init|;
name|workp
operator|<
name|rt_curend
index|[
name|segnum
index|]
condition|;
name|workp
operator|++
control|)
operator|*
name|workp
operator|=
name|workp
index|[
literal|1
index|]
expr_stmt|;
name|de
operator|--
expr_stmt|;
name|rt_curend
index|[
name|segnum
index|]
operator|--
expr_stmt|;
name|rt_nleft
operator|++
expr_stmt|;
name|dirdirty
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dirdirty
condition|)
name|lwrite
argument_list|(
operator|(
literal|6
operator|+
name|segnum
operator|*
literal|2
operator|)
operator|*
name|RT_BLOCK
argument_list|,
literal|2
operator|*
name|RT_BLOCK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rt_dir
index|[
name|segnum
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

