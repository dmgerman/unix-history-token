begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)symbols.c 1.3 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Symbol management.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_include
include|#
directive|include
file|"printsym.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"operators.h"
end_include

begin_include
include|#
directive|include
file|"eval.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"events.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|public
end_ifndef

begin_typedef
typedef|typedef
name|struct
name|Symbol
modifier|*
name|Symbol
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"languages.h"
end_include

begin_comment
comment|/*  * Symbol classes  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|BADUSE
block|,
name|CONST
block|,
name|TYPE
block|,
name|VAR
block|,
name|ARRAY
block|,
name|PTRFILE
block|,
name|RECORD
block|,
name|FIELD
block|,
name|PROC
block|,
name|FUNC
block|,
name|FVAR
block|,
name|REF
block|,
name|PTR
block|,
name|FILET
block|,
name|SET
block|,
name|RANGE
block|,
name|LABEL
block|,
name|WITHPTR
block|,
name|SCAL
block|,
name|STR
block|,
name|PROG
block|,
name|IMPROPER
block|,
name|VARNT
block|,
name|FPROC
block|,
name|FFUNC
block|,
name|MODULE
block|,
name|TYPEREF
block|,
name|TAG
block|}
name|Symclass
typedef|;
end_typedef

begin_struct
struct|struct
name|Symbol
block|{
name|Name
name|name
decl_stmt|;
name|Language
name|language
decl_stmt|;
name|Symclass
name|class
range|:
literal|8
decl_stmt|;
name|Integer
name|level
range|:
literal|8
decl_stmt|;
name|Symbol
name|type
decl_stmt|;
name|Symbol
name|chain
decl_stmt|;
union|union
block|{
name|int
name|offset
decl_stmt|;
comment|/* variable address */
name|long
name|iconval
decl_stmt|;
comment|/* integer constant value */
name|double
name|fconval
decl_stmt|;
comment|/* floating constant value */
struct|struct
block|{
comment|/* field offset and size (both in bits) */
name|int
name|offset
decl_stmt|;
name|int
name|length
decl_stmt|;
block|}
name|field
struct|;
struct|struct
block|{
comment|/* range bounds */
name|long
name|lower
decl_stmt|;
name|long
name|upper
decl_stmt|;
block|}
name|rangev
struct|;
struct|struct
block|{
comment|/* address of function value, code */
name|int
name|offset
decl_stmt|;
name|Address
name|beginaddr
decl_stmt|;
block|}
name|funcv
struct|;
struct|struct
block|{
comment|/* variant record info */
name|int
name|size
decl_stmt|;
name|Symbol
name|vtorec
decl_stmt|;
name|Symbol
name|vtag
decl_stmt|;
block|}
name|varnt
struct|;
block|}
name|symvalue
union|;
name|Symbol
name|block
decl_stmt|;
comment|/* symbol containing this symbol */
name|Symbol
name|next_sym
decl_stmt|;
comment|/* hash chain */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Basic types.  */
end_comment

begin_decl_stmt
name|Symbol
name|t_boolean
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_real
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|t_nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|program
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Symbol
name|curfunc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|symname
parameter_list|(
name|s
parameter_list|)
value|ident(s->name)
end_define

begin_define
define|#
directive|define
name|codeloc
parameter_list|(
name|f
parameter_list|)
value|((f)->symvalue.funcv.beginaddr)
end_define

begin_define
define|#
directive|define
name|isblock
parameter_list|(
name|s
parameter_list|)
value|(Boolean) ( \     s->class == FUNC or s->class == PROC or \     s->class == MODULE or s->class == PROG \ )
end_define

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*  * Some macros to make finding a symbol with certain attributes.  */
end_comment

begin_define
define|#
directive|define
name|find
parameter_list|(
name|s
parameter_list|,
name|withname
parameter_list|)
define|\
value|{ \     s = lookup(withname); \     while (s != nil and not (s->name == (withname) and
end_define

begin_define
define|#
directive|define
name|where
end_define

begin_comment
comment|/* qualification */
end_comment

begin_define
define|#
directive|define
name|endfind
parameter_list|(
name|s
parameter_list|)
value|)) { \ 	s = s->next_sym; \     } \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Symbol table structure currently does not support deletions.  */
end_comment

begin_define
define|#
directive|define
name|HASHTABLESIZE
value|2003
end_define

begin_decl_stmt
name|private
name|Symbol
name|hashtab
index|[
name|HASHTABLESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hash
parameter_list|(
name|name
parameter_list|)
value|((((unsigned) name)>> 2) mod HASHTABLESIZE)
end_define

begin_comment
comment|/*  * Allocate a new symbol.  */
end_comment

begin_define
define|#
directive|define
name|SYMBLOCKSIZE
value|100
end_define

begin_typedef
typedef|typedef
struct|struct
name|Sympool
block|{
name|struct
name|Symbol
name|sym
index|[
name|SYMBLOCKSIZE
index|]
decl_stmt|;
name|struct
name|Sympool
modifier|*
name|prevpool
decl_stmt|;
block|}
typedef|*
name|Sympool
typedef|;
end_typedef

begin_decl_stmt
name|private
name|Sympool
name|sympool
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Integer
name|nleft
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|public
name|Symbol
name|symbol_alloc
parameter_list|()
block|{
specifier|register
name|Sympool
name|newpool
decl_stmt|;
if|if
condition|(
name|nleft
operator|<=
literal|0
condition|)
block|{
name|newpool
operator|=
name|new
argument_list|(
name|Sympool
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|newpool
argument_list|,
sizeof|sizeof
argument_list|(
name|newpool
argument_list|)
argument_list|)
expr_stmt|;
name|newpool
operator|->
name|prevpool
operator|=
name|sympool
expr_stmt|;
name|sympool
operator|=
name|newpool
expr_stmt|;
name|nleft
operator|=
name|SYMBLOCKSIZE
expr_stmt|;
block|}
operator|--
name|nleft
expr_stmt|;
return|return
operator|&
operator|(
name|sympool
operator|->
name|sym
index|[
name|nleft
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all the symbols currently allocated.  */
end_comment

begin_function
name|public
name|symbol_free
parameter_list|()
block|{
name|Sympool
name|s
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|Integer
name|i
decl_stmt|;
name|s
operator|=
name|sympool
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|nil
condition|)
block|{
name|t
operator|=
name|s
operator|->
name|prevpool
expr_stmt|;
name|dispose
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHTABLESIZE
condition|;
name|i
operator|++
control|)
block|{
name|hashtab
index|[
name|i
index|]
operator|=
name|nil
expr_stmt|;
block|}
name|sympool
operator|=
name|nil
expr_stmt|;
name|nleft
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new symbol with the given attributes.  */
end_comment

begin_function
name|public
name|Symbol
name|newSymbol
parameter_list|(
name|name
parameter_list|,
name|blevel
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|chain
parameter_list|)
name|Name
name|name
decl_stmt|;
name|Integer
name|blevel
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
name|Symbol
name|type
decl_stmt|;
name|Symbol
name|chain
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|level
operator|=
name|blevel
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|s
operator|->
name|chain
operator|=
name|chain
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a symbol into the hash table.  */
end_comment

begin_function
name|public
name|Symbol
name|insert
parameter_list|(
name|name
parameter_list|)
name|Name
name|name
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|unsigned
name|int
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|symbol_alloc
argument_list|()
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|s
operator|->
name|next_sym
operator|=
name|hashtab
index|[
name|h
index|]
expr_stmt|;
name|hashtab
index|[
name|h
index|]
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Symbol lookup.  */
end_comment

begin_function
name|public
name|Symbol
name|lookup
parameter_list|(
name|name
parameter_list|)
name|Name
name|name
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
specifier|register
name|unsigned
name|int
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|hashtab
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|nil
name|and
name|s
operator|->
name|name
operator|!=
name|name
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|next_sym
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Dump out all the variables associated with the given  * procedure, function, or program at the given recursive level.  *  * This is quite inefficient.  We traverse the entire symbol table  * each time we're called.  The assumption is that this routine  * won't be called frequently enough to merit improved performance.  */
end_comment

begin_function
name|public
name|dumpvars
parameter_list|(
name|f
parameter_list|,
name|frame
parameter_list|)
name|Symbol
name|f
decl_stmt|;
name|Frame
name|frame
decl_stmt|;
block|{
specifier|register
name|Integer
name|i
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHTABLESIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|s
operator|=
name|hashtab
index|[
name|i
index|]
init|;
name|s
operator|!=
name|nil
condition|;
name|s
operator|=
name|s
operator|->
name|next_sym
control|)
block|{
if|if
condition|(
name|container
argument_list|(
name|s
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|should_print
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printv
argument_list|(
name|s
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
name|dumpvars
argument_list|(
name|s
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Create a builtin type.  * Builtin types are circular in that btype->type->type = btype.  */
end_comment

begin_function
name|public
name|Symbol
name|maketype
parameter_list|(
name|name
parameter_list|,
name|lower
parameter_list|,
name|upper
parameter_list|)
name|String
name|name
decl_stmt|;
name|long
name|lower
decl_stmt|;
name|long
name|upper
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|newSymbol
argument_list|(
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".c"
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|0
argument_list|,
name|RANGE
argument_list|,
name|s
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|=
name|lower
expr_stmt|;
name|s
operator|->
name|type
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|=
name|upper
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * These functions are now compiled inline.  *  * public String symname(s) Symbol s; {     checkref(s);     return ident(s->name); }   *  * public Address codeloc(f) Symbol f; {     checkref(f);     if (not isblock(f)) { 	panic("codeloc: \"%s\" is not a block", ident(f->name));     }     return f->symvalue.funcv.beginaddr; }  *  */
end_comment

begin_comment
comment|/*  * Reduce type to avoid worrying about type names.  */
end_comment

begin_function
name|public
name|Symbol
name|rtype
parameter_list|(
name|type
parameter_list|)
name|Symbol
name|type
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|VAR
name|or
name|t
operator|->
name|class
operator|==
name|FIELD
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
while|while
condition|(
name|t
operator|->
name|class
operator|==
name|TYPE
name|or
name|t
operator|->
name|class
operator|==
name|TAG
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
name|public
name|Integer
name|level
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|level
return|;
block|}
end_function

begin_function
name|public
name|Symbol
name|container
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|block
return|;
block|}
end_function

begin_comment
comment|/*  * Return the object address of the given symbol.  *  * There are the following possibilities:  *  *	globals		- just take offset  *	locals		- take offset from locals base  *	arguments	- take offset from argument base  *	register	- offset is register number  */
end_comment

begin_define
define|#
directive|define
name|isglobal
parameter_list|(
name|s
parameter_list|)
value|(s->level == 1 or s->level == 2)
end_define

begin_define
define|#
directive|define
name|islocaloff
parameter_list|(
name|s
parameter_list|)
value|(s->level>= 3 and s->symvalue.offset< 0)
end_define

begin_define
define|#
directive|define
name|isparamoff
parameter_list|(
name|s
parameter_list|)
value|(s->level>= 3 and s->symvalue.offset>= 0)
end_define

begin_define
define|#
directive|define
name|isreg
parameter_list|(
name|s
parameter_list|)
value|(s->level< 0)
end_define

begin_function
name|public
name|Address
name|address
parameter_list|(
name|s
parameter_list|,
name|frame
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|Frame
name|frame
decl_stmt|;
block|{
specifier|register
name|Frame
name|frp
decl_stmt|;
specifier|register
name|Address
name|addr
decl_stmt|;
specifier|register
name|Symbol
name|cur
decl_stmt|;
name|checkref
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|isactive
argument_list|(
name|s
operator|->
name|block
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not currently defined"
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isglobal
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
name|frp
operator|=
name|frame
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|cur
operator|=
name|s
operator|->
name|block
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|nil
name|and
name|cur
operator|->
name|class
operator|==
name|MODULE
condition|)
block|{
name|cur
operator|=
name|cur
operator|->
name|block
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|==
name|nil
condition|)
block|{
name|cur
operator|=
name|whatblock
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
name|frp
operator|=
name|findframe
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"unexpected nil frame for \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|islocaloff
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|locals_base
argument_list|(
name|frp
argument_list|)
operator|+
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isparamoff
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|args_base
argument_list|(
name|frp
argument_list|)
operator|+
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isreg
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|addr
operator|=
name|savereg
argument_list|(
name|s
operator|->
name|symvalue
operator|.
name|offset
argument_list|,
name|frp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"address: bad symbol \"%s\""
argument_list|,
name|symname
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Define a symbol used to access register values.  */
end_comment

begin_function
name|public
name|defregname
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
name|Name
name|n
decl_stmt|;
name|Integer
name|r
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
name|s
operator|=
name|insert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|0
argument_list|,
name|PTR
argument_list|,
name|t_int
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|t
operator|->
name|language
expr_stmt|;
name|s
operator|->
name|class
operator|=
name|VAR
expr_stmt|;
name|s
operator|->
name|level
operator|=
operator|-
literal|3
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|s
operator|->
name|block
operator|=
name|program
expr_stmt|;
name|s
operator|->
name|symvalue
operator|.
name|offset
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resolve an "abstract" type reference.  *  * It is possible in C to define a pointer to a type, but never define  * the type in a particular source file.  Here we try to resolve  * the type definition.  This is problematic, it is possible to  * have multiple, different definitions for the same name type.  */
end_comment

begin_function
name|public
name|findtype
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|,
name|u
decl_stmt|,
name|prev
decl_stmt|;
name|u
operator|=
name|s
expr_stmt|;
name|prev
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|u
operator|!=
name|nil
name|and
name|u
operator|->
name|class
operator|!=
name|BADUSE
condition|)
block|{
if|if
condition|(
name|u
operator|->
name|name
operator|!=
name|nil
condition|)
block|{
name|prev
operator|=
name|u
expr_stmt|;
block|}
name|u
operator|=
name|u
operator|->
name|type
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"couldn't find link to type reference"
argument_list|)
expr_stmt|;
block|}
name|find
argument_list|(
argument|t
argument_list|,
argument|prev->name
argument_list|)
name|where
name|t
operator|->
name|type
operator|!=
name|nil
name|and
name|t
operator|->
name|class
operator|==
name|prev
operator|->
name|class
name|and
name|t
operator|->
name|type
operator|->
name|class
operator|!=
name|BADUSE
name|and
name|t
operator|->
name|block
operator|->
name|class
operator|==
name|MODULE
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"couldn't resolve reference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|type
operator|=
name|t
operator|->
name|type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the size in bytes of the given type.  *  * This is probably the WRONG thing to do.  The size should be kept  * as an attribute in the symbol information as is done for structures  * and fields.  I haven't gotten around to cleaning this up yet.  */
end_comment

begin_define
define|#
directive|define
name|MINCHAR
value|-128
end_define

begin_define
define|#
directive|define
name|MAXCHAR
value|127
end_define

begin_define
define|#
directive|define
name|MINSHORT
value|-32768
end_define

begin_define
define|#
directive|define
name|MAXSHORT
value|32767
end_define

begin_function
name|public
name|Integer
name|size
parameter_list|(
name|sym
parameter_list|)
name|Symbol
name|sym
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|int
name|nel
decl_stmt|,
name|elsize
decl_stmt|;
name|long
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|int
name|r
decl_stmt|;
name|t
operator|=
name|sym
expr_stmt|;
name|checkref
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|class
condition|)
block|{
case|case
name|RANGE
case|:
name|lower
operator|=
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|upper
operator|=
name|t
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
if|if
condition|(
name|upper
operator|==
literal|0
name|and
name|lower
operator|>
literal|0
condition|)
block|{
comment|/* real */
name|r
operator|=
name|lower
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lower
operator|>=
name|MINCHAR
name|and
name|upper
operator|<=
name|MAXCHAR
condition|)
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lower
operator|>=
name|MINSHORT
name|and
name|upper
operator|<=
name|MAXSHORT
condition|)
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY
case|:
name|elsize
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|nel
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
name|t
operator|->
name|chain
init|;
name|t
operator|!=
name|nil
condition|;
name|t
operator|=
name|t
operator|->
name|chain
control|)
block|{
name|s
operator|=
name|rtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|lower
operator|=
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|upper
operator|=
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
name|nel
operator|*=
operator|(
name|upper
operator|-
name|lower
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|r
operator|=
name|nel
operator|*
name|elsize
expr_stmt|;
break|break;
case|case
name|VAR
case|:
case|case
name|FVAR
case|:
name|r
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
condition|)
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST
case|:
name|r
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE
case|:
if|if
condition|(
name|t
operator|->
name|type
operator|->
name|class
operator|==
name|PTR
name|and
name|t
operator|->
name|type
operator|->
name|type
operator|->
name|class
operator|==
name|BADUSE
condition|)
block|{
name|findtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG
case|:
name|r
operator|=
name|size
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD
case|:
name|r
operator|=
operator|(
name|t
operator|->
name|symvalue
operator|.
name|field
operator|.
name|length
operator|+
literal|7
operator|)
name|div
literal|8
expr_stmt|;
break|break;
case|case
name|RECORD
case|:
case|case
name|VARNT
case|:
name|r
operator|=
name|t
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
name|and
name|t
operator|->
name|chain
operator|!=
name|nil
condition|)
block|{
name|panic
argument_list|(
literal|"missing size information for record"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTR
case|:
case|case
name|REF
case|:
case|case
name|FILET
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCAL
case|:
if|if
condition|(
name|t
operator|->
name|symvalue
operator|.
name|iconval
operator|>
literal|255
condition|)
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FPROC
case|:
case|case
name|FFUNC
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROC
case|:
case|case
name|FUNC
case|:
case|case
name|MODULE
case|:
case|case
name|PROG
case|:
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Symbol
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ord
argument_list|(
name|t
operator|->
name|class
argument_list|)
operator|>
name|ord
argument_list|(
name|TYPEREF
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"size: bad class (%d)"
argument_list|,
name|ord
argument_list|(
name|t
operator|->
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"improper operation on a %s"
argument_list|,
name|classname
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|r
operator|<
expr|sizeof
operator|(
name|Word
operator|)
name|and
name|isparam
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|r
operator|=
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a parameter.  This is true if there  * is a cycle from s->block to s via chain pointers.  */
end_comment

begin_function
name|public
name|Boolean
name|isparam
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|s
operator|->
name|block
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|nil
name|and
name|t
operator|!=
name|s
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
block|}
return|return
call|(
name|Boolean
call|)
argument_list|(
name|t
operator|!=
name|nil
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a var parameter, i.e. has class REF.  */
end_comment

begin_function
name|public
name|Boolean
name|isvarparam
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
return|return
call|(
name|Boolean
call|)
argument_list|(
name|s
operator|->
name|class
operator|==
name|REF
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a variable (actually any addressible quantity  * with do).  */
end_comment

begin_function
name|public
name|Boolean
name|isvariable
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
return|return
operator|(
name|Boolean
operator|)
operator|(
name|s
operator|->
name|class
operator|==
name|VAR
name|or
name|s
operator|->
name|class
operator|==
name|FVAR
name|or
name|s
operator|->
name|class
operator|==
name|REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is a block, e.g. function, procedure, or the  * main program.  *  * This function is now expanded inline for efficiency.  *  * public Boolean isblock(s) register Symbol s; {     return (Boolean) ( 	s->class == FUNC or s->class == PROC or 	s->class == MODULE or s->class == PROG     ); }  *  */
end_comment

begin_comment
comment|/*  * Test if a symbol is a module.  */
end_comment

begin_function
name|public
name|Boolean
name|ismodule
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
return|return
call|(
name|Boolean
call|)
argument_list|(
name|s
operator|->
name|class
operator|==
name|MODULE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if a symbol is builtin, that is, a predefined type or  * reserved word.  */
end_comment

begin_function
name|public
name|Boolean
name|isbuiltin
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
return|return
operator|(
name|Boolean
operator|)
operator|(
name|s
operator|->
name|level
operator|==
literal|0
name|and
name|s
operator|->
name|class
operator|!=
name|PROG
name|and
name|s
operator|->
name|class
operator|!=
name|VAR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test if two types match.  * Equivalent names implies a match in any language.  *  * Special symbols must be handled with care.  */
end_comment

begin_function
name|public
name|Boolean
name|compatible
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|register
name|Symbol
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
name|Boolean
name|b
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
block|{
name|b
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|nil
name|or
name|t2
operator|==
name|nil
condition|)
block|{
name|b
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|procsym
condition|)
block|{
name|b
operator|=
name|isblock
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|==
name|procsym
condition|)
block|{
name|b
operator|=
name|isblock
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|->
name|language
operator|==
name|nil
condition|)
block|{
name|b
operator|=
operator|(
name|Boolean
operator|)
operator|(
name|t2
operator|->
name|language
operator|==
name|nil
name|or
argument_list|(
operator|*
name|language_op
argument_list|(
name|t2
operator|->
name|language
argument_list|,
name|L_TYPEMATCH
argument_list|)
argument_list|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
call|(
name|Boolean
call|)
argument_list|(
operator|*
name|language_op
argument_list|(
name|t1
operator|->
name|language
argument_list|,
name|L_TYPEMATCH
argument_list|)
argument_list|)
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Check for a type of the given name.  */
end_comment

begin_function
name|public
name|Boolean
name|istypename
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|Symbol
name|type
decl_stmt|;
name|String
name|name
decl_stmt|;
block|{
name|Symbol
name|t
decl_stmt|;
name|Boolean
name|b
decl_stmt|;
name|t
operator|=
name|type
expr_stmt|;
name|checkref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|Boolean
operator|)
operator|(
name|t
operator|->
name|class
operator|==
name|TYPE
name|and
name|t
operator|->
name|name
operator|==
name|identname
argument_list|(
name|name
argument_list|,
name|true
argument_list|)
operator|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Test if the name of a symbol is uniquely defined or not.  */
end_comment

begin_function
name|public
name|Boolean
name|isambiguous
parameter_list|(
name|s
parameter_list|)
specifier|register
name|Symbol
name|s
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|find
argument_list|(
argument|t
argument_list|,
argument|s->name
argument_list|)
name|where
name|t
operator|!=
name|s
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
call|(
name|Boolean
call|)
argument_list|(
name|t
operator|!=
name|nil
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|char
modifier|*
name|Arglist
typedef|;
end_typedef

begin_define
define|#
directive|define
name|nextarg
parameter_list|(
name|type
parameter_list|)
value|((type *) (ap += sizeof(type)))[-1]
end_define

begin_function_decl
name|private
name|Symbol
name|mkstring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|Symbol
name|namenode
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine the type of a parse tree.  * Also make some symbol-dependent changes to the tree such as  * changing removing RVAL nodes for constant symbols.  */
end_comment

begin_function
name|public
name|assigntypes
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Node
name|p
decl_stmt|;
block|{
specifier|register
name|Node
name|p1
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|O_SYM
case|:
name|p
operator|->
name|nodetype
operator|=
name|namenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LCON
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
break|break;
case|case
name|O_FCON
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
break|break;
case|case
name|O_SCON
case|:
name|p
operator|->
name|value
operator|.
name|scon
operator|=
name|strdup
argument_list|(
name|p
operator|->
name|value
operator|.
name|scon
argument_list|)
expr_stmt|;
name|s
operator|=
name|mkstring
argument_list|(
name|p
operator|->
name|value
operator|.
name|scon
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|t_char
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_LCON
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|lcon
operator|=
name|p
operator|->
name|value
operator|.
name|scon
index|[
literal|0
index|]
expr_stmt|;
block|}
name|p
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
break|break;
case|case
name|O_INDIR
case|:
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|chkclass
argument_list|(
name|p1
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|rtype
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|O_DOT
case|:
name|p
operator|->
name|nodetype
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
break|break;
case|case
name|O_RVAL
case|:
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|p1
operator|->
name|nodetype
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|nodetype
operator|->
name|class
operator|==
name|FUNC
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_CALL
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|=
name|nil
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|value
operator|.
name|sym
operator|->
name|class
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|compatible
argument_list|(
name|p1
operator|->
name|value
operator|.
name|sym
operator|->
name|type
argument_list|,
name|t_real
argument_list|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_FCON
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|fcon
operator|=
name|p1
operator|->
name|value
operator|.
name|sym
operator|->
name|symvalue
operator|.
name|fconval
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|O_LCON
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|lcon
operator|=
name|p1
operator|->
name|value
operator|.
name|sym
operator|->
name|symvalue
operator|.
name|iconval
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|p1
operator|->
name|value
operator|.
name|sym
operator|->
name|type
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isreg
argument_list|(
name|p1
operator|->
name|value
operator|.
name|sym
argument_list|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|O_SYM
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|sym
operator|=
name|p1
operator|->
name|value
operator|.
name|sym
expr_stmt|;
name|dispose
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|O_INDIR
name|and
name|p1
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|op
operator|==
name|O_SYM
condition|)
block|{
name|s
operator|=
name|p1
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|isreg
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|p1
operator|->
name|op
operator|=
name|O_SYM
expr_stmt|;
name|dispose
argument_list|(
name|p1
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p1
operator|->
name|value
operator|.
name|sym
operator|=
name|s
expr_stmt|;
name|p1
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Perform a cast if the call is of the form "type(expr)". 	 */
case|case
name|O_CALL
case|:
name|p1
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|rtype
argument_list|(
name|p1
operator|->
name|nodetype
argument_list|)
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|O_TYPERENAME
case|:
name|p
operator|->
name|nodetype
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|->
name|nodetype
expr_stmt|;
break|break;
case|case
name|O_ITOF
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
break|break;
case|case
name|O_NEG
case|:
name|s
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|nodetype
expr_stmt|;
if|if
condition|(
name|not
name|compatible
argument_list|(
name|s
argument_list|,
name|t_int
argument_list|)
condition|)
block|{
if|if
condition|(
name|not
name|compatible
argument_list|(
name|s
argument_list|,
name|t_real
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"is improper type"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|O_NEGF
expr_stmt|;
block|}
block|}
name|p
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
break|break;
case|case
name|O_ADD
case|:
case|case
name|O_SUB
case|:
case|case
name|O_MUL
case|:
case|case
name|O_LT
case|:
case|case
name|O_LE
case|:
case|case
name|O_GT
case|:
case|case
name|O_GE
case|:
case|case
name|O_EQ
case|:
case|case
name|O_NE
case|:
block|{
name|Boolean
name|t1real
decl_stmt|,
name|t2real
decl_stmt|;
name|Symbol
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|t1
operator|=
name|rtype
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|t2
operator|=
name|rtype
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|t1real
operator|=
name|compatible
argument_list|(
name|t1
argument_list|,
name|t_real
argument_list|)
expr_stmt|;
name|t2real
operator|=
name|compatible
argument_list|(
name|t2
argument_list|,
name|t_real
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1real
name|or
name|t2real
condition|)
block|{
name|p
operator|->
name|op
operator|=
call|(
name|Operator
call|)
argument_list|(
name|ord
argument_list|(
name|p
operator|->
name|op
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|t1real
condition|)
block|{
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|=
name|build
argument_list|(
name|O_ITOF
argument_list|,
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|t2real
condition|)
block|{
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|=
name|build
argument_list|(
name|O_ITOF
argument_list|,
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|t1real
condition|)
block|{
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|)
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t2real
condition|)
block|{
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|)
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ord
argument_list|(
name|p
operator|->
name|op
argument_list|)
operator|>=
name|ord
argument_list|(
name|O_LT
argument_list|)
condition|)
block|{
name|p
operator|->
name|nodetype
operator|=
name|t_boolean
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t1real
name|or
name|t2real
condition|)
block|{
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|O_DIVF
case|:
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|)
argument_list|,
name|t_real
argument_list|,
name|O_ITOF
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|)
argument_list|,
name|t_real
argument_list|,
name|O_ITOF
argument_list|)
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_real
expr_stmt|;
break|break;
case|case
name|O_DIV
case|:
case|case
name|O_MOD
case|:
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|)
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
name|convert
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|)
argument_list|,
name|t_int
argument_list|,
name|O_NOP
argument_list|)
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
break|break;
case|case
name|O_AND
case|:
case|case
name|O_OR
case|:
name|chkboolean
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|chkboolean
argument_list|(
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|t_boolean
expr_stmt|;
break|break;
case|case
name|O_QLINE
case|:
name|p
operator|->
name|nodetype
operator|=
name|t_int
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|nodetype
operator|=
name|nil
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a node for a name.  The symbol for the name has already  * been chosen, either implicitly with "which" or explicitly from  * the dot routine.  */
end_comment

begin_function
name|private
name|Symbol
name|namenode
parameter_list|(
name|p
parameter_list|)
name|Node
name|p
decl_stmt|;
block|{
specifier|register
name|Symbol
name|r
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|Node
name|np
decl_stmt|;
name|s
operator|=
name|p
operator|->
name|value
operator|.
name|sym
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|REF
condition|)
block|{
name|np
operator|=
name|new
argument_list|(
name|Node
argument_list|)
expr_stmt|;
name|np
operator|->
name|op
operator|=
name|p
operator|->
name|op
expr_stmt|;
name|np
operator|->
name|nodetype
operator|=
name|s
expr_stmt|;
name|np
operator|->
name|value
operator|.
name|sym
operator|=
name|s
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_INDIR
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
operator|=
name|np
expr_stmt|;
block|}
comment|/*  * Old way  *     if (s->class == CONST or s->class == VAR or s->class == FVAR) { 	r = s->type;     } else { 	r = s;     }  *  */
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a tree to a type via a conversion operator;  * if this isn't possible generate an error.  *  * Note the tree is call by address, hence the #define below.  */
end_comment

begin_function
name|private
name|convert
parameter_list|(
name|tp
parameter_list|,
name|typeto
parameter_list|,
name|op
parameter_list|)
name|Node
modifier|*
name|tp
decl_stmt|;
name|Symbol
name|typeto
decl_stmt|;
name|Operator
name|op
decl_stmt|;
block|{
define|#
directive|define
name|tree
value|(*tp)
name|Symbol
name|s
decl_stmt|;
name|s
operator|=
name|rtype
argument_list|(
name|tree
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|typeto
operator|=
name|rtype
argument_list|(
name|typeto
argument_list|)
expr_stmt|;
if|if
condition|(
name|compatible
argument_list|(
argument|typeto
argument_list|,
argument|t_real
argument_list|)
name|and
name|compatible
argument_list|(
name|s
argument_list|,
name|t_int
argument_list|)
condition|)
block|{
name|tree
operator|=
name|build
argument_list|(
name|op
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|not
name|compatible
argument_list|(
name|s
argument_list|,
name|typeto
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is improper type"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|!=
name|O_NOP
name|and
name|s
operator|!=
name|typeto
condition|)
block|{
name|tree
operator|=
name|build
argument_list|(
name|op
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|tree
block|}
end_function

begin_comment
comment|/*  * Construct a node for the dot operator.  *  * If the left operand is not a record, but rather a procedure  * or function, then we interpret the "." as referencing an  * "invisible" variable; i.e. a variable within a dynamically  * active block but not within the static scope of the current procedure.  */
end_comment

begin_function
name|public
name|Node
name|dot
parameter_list|(
name|record
parameter_list|,
name|fieldname
parameter_list|)
name|Node
name|record
decl_stmt|;
name|Name
name|fieldname
decl_stmt|;
block|{
specifier|register
name|Node
name|p
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|isblock
argument_list|(
name|record
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|find
argument_list|(
argument|s
argument_list|,
argument|fieldname
argument_list|)
name|where
name|s
operator|->
name|block
operator|==
name|record
operator|->
name|nodetype
name|and
name|s
operator|->
name|class
operator|!=
name|FIELD
name|and
name|s
operator|->
name|class
operator|!=
name|TAG
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" is not defined in "
argument_list|,
name|ident
argument_list|(
name|fieldname
argument_list|)
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|stderr
argument_list|,
name|record
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|new
argument_list|(
name|Node
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_SYM
expr_stmt|;
name|p
operator|->
name|value
operator|.
name|sym
operator|=
name|s
expr_stmt|;
name|p
operator|->
name|nodetype
operator|=
name|namenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|record
expr_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|PTR
condition|)
block|{
name|s
operator|=
name|findfield
argument_list|(
name|fieldname
argument_list|,
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|findfield
argument_list|(
name|fieldname
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" is not a field in "
argument_list|,
name|ident
argument_list|(
name|fieldname
argument_list|)
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|class
operator|==
name|PTR
name|and
name|not
name|isreg
argument_list|(
name|record
operator|->
name|nodetype
argument_list|)
condition|)
block|{
name|p
operator|=
name|build
argument_list|(
name|O_INDIR
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|build
argument_list|(
name|O_DOT
argument_list|,
name|p
argument_list|,
name|build
argument_list|(
name|O_SYM
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Return a tree corresponding to an array reference and do the  * error checking.  */
end_comment

begin_function
name|public
name|Node
name|subscript
parameter_list|(
name|a
parameter_list|,
name|slist
parameter_list|)
name|Node
name|a
decl_stmt|,
name|slist
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
specifier|register
name|Node
name|p
decl_stmt|;
name|Symbol
name|etype
decl_stmt|,
name|atype
decl_stmt|,
name|eltype
decl_stmt|;
name|Node
name|esub
decl_stmt|,
name|olda
decl_stmt|;
name|olda
operator|=
name|a
expr_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|a
operator|->
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|class
operator|!=
name|ARRAY
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is not an array"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|eltype
operator|=
name|t
operator|->
name|type
expr_stmt|;
name|p
operator|=
name|slist
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|nil
name|and
name|t
operator|!=
name|nil
condition|;
name|p
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|1
index|]
operator|,
name|t
operator|=
name|t
operator|->
name|chain
control|)
block|{
name|esub
operator|=
name|p
operator|->
name|value
operator|.
name|arg
index|[
literal|0
index|]
expr_stmt|;
name|etype
operator|=
name|rtype
argument_list|(
name|esub
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|atype
operator|=
name|rtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|not
name|compatible
argument_list|(
name|atype
argument_list|,
name|etype
argument_list|)
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"subscript "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|esub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is the wrong type"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
name|a
operator|=
name|build
argument_list|(
name|O_INDEX
argument_list|,
name|a
argument_list|,
name|esub
argument_list|)
expr_stmt|;
name|a
operator|->
name|nodetype
operator|=
name|eltype
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|nil
name|or
name|t
operator|!=
name|nil
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|nil
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many subscripts for "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not enough subscripts for "
argument_list|)
expr_stmt|;
block|}
name|prtree
argument_list|(
name|stderr
argument_list|,
name|olda
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a subscript index.  */
end_comment

begin_function
name|public
name|int
name|evalindex
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
name|Symbol
name|s
decl_stmt|;
name|long
name|i
decl_stmt|;
block|{
name|long
name|lb
decl_stmt|,
name|ub
decl_stmt|;
name|s
operator|=
name|rtype
argument_list|(
name|s
argument_list|)
operator|->
name|chain
expr_stmt|;
name|lb
operator|=
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
expr_stmt|;
name|ub
operator|=
name|s
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|lb
name|or
name|i
operator|>
name|ub
condition|)
block|{
name|error
argument_list|(
literal|"subscript out of range"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|-
name|lb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a tree is boolean-valued, if not it's an error.  */
end_comment

begin_function
name|public
name|chkboolean
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Node
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|nodetype
operator|!=
name|t_boolean
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", expected boolean expression"
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to make sure the given tree has a type of the given class.  */
end_comment

begin_function
name|private
name|chkclass
parameter_list|(
name|p
parameter_list|,
name|class
parameter_list|)
name|Node
name|p
decl_stmt|;
name|Symclass
name|class
decl_stmt|;
block|{
name|struct
name|Symbol
name|tmpsym
decl_stmt|;
name|tmpsym
operator|.
name|class
operator|=
name|class
expr_stmt|;
if|if
condition|(
name|rtype
argument_list|(
name|p
operator|->
name|nodetype
argument_list|)
operator|->
name|class
operator|!=
name|class
condition|)
block|{
name|beginerrmsg
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|stderr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\" is not a %s"
argument_list|,
name|classname
argument_list|(
operator|&
name|tmpsym
argument_list|)
argument_list|)
expr_stmt|;
name|enderrmsg
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct a node for the type of a string.  While we're at it,  * scan the string for '' that collapse to ', and chop off the ends.  */
end_comment

begin_function
name|private
name|Symbol
name|mkstring
parameter_list|(
name|str
parameter_list|)
name|String
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|Symbol
name|s
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
name|q
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
operator|++
name|p
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|0
argument_list|,
name|ARRAY
argument_list|,
name|t_char
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|->
name|language
operator|=
name|findlanguage
argument_list|(
literal|".s"
argument_list|)
expr_stmt|;
name|s
operator|->
name|chain
operator|=
name|newSymbol
argument_list|(
name|nil
argument_list|,
literal|0
argument_list|,
name|RANGE
argument_list|,
name|t_int
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|s
operator|->
name|chain
operator|->
name|language
operator|=
name|s
operator|->
name|language
expr_stmt|;
name|s
operator|->
name|chain
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|lower
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|chain
operator|->
name|symvalue
operator|.
name|rangev
operator|.
name|upper
operator|=
name|p
operator|-
name|str
operator|+
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Free up the space allocated for a string type.  */
end_comment

begin_function
name|public
name|unmkstring
parameter_list|(
name|s
parameter_list|)
name|Symbol
name|s
decl_stmt|;
block|{
name|dispose
argument_list|(
name|s
operator|->
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Figure out the "current" variable or function being referred to,  * this is either the active one or the most visible from the  * current scope.  */
end_comment

begin_function
name|public
name|Symbol
name|which
parameter_list|(
name|n
parameter_list|)
name|Name
name|n
decl_stmt|;
block|{
specifier|register
name|Symbol
name|s
decl_stmt|,
name|p
decl_stmt|,
name|t
decl_stmt|,
name|f
decl_stmt|;
name|find
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
name|where
name|s
operator|->
name|class
operator|!=
name|FIELD
name|and
name|s
operator|->
name|class
operator|!=
name|TAG
name|endfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|s
operator|=
name|lookup
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" is not defined"
argument_list|,
name|ident
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|program
name|or
name|isbuiltin
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|t
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/*      * Old way      * 	if (not isactive(program)) { 	    f = program; 	} else { 	    f = whatblock(pc); 	    if (f == nil) { 		panic("no block for addr 0x%x", pc); 	    } 	}      *      * Now start with curfunc.      */
name|p
operator|=
name|curfunc
expr_stmt|;
do|do
block|{
name|find
argument_list|(
argument|t
argument_list|,
argument|n
argument_list|)
name|where
name|t
operator|->
name|block
operator|==
name|p
name|and
name|t
operator|->
name|class
operator|!=
name|FIELD
name|and
name|t
operator|->
name|class
operator|!=
name|TAG
name|endfind
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|block
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|==
name|nil
name|and
name|p
operator|!=
name|nil
condition|)
do|;
if|if
condition|(
name|t
operator|==
name|nil
condition|)
block|{
name|t
operator|=
name|s
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*  * Find the symbol which is has the same name and scope as the  * given symbol but is of the given field.  Return nil if there is none.  */
end_comment

begin_function
name|public
name|Symbol
name|findfield
parameter_list|(
name|fieldname
parameter_list|,
name|record
parameter_list|)
name|Name
name|fieldname
decl_stmt|;
name|Symbol
name|record
decl_stmt|;
block|{
specifier|register
name|Symbol
name|t
decl_stmt|;
name|t
operator|=
name|rtype
argument_list|(
name|record
argument_list|)
operator|->
name|chain
expr_stmt|;
while|while
condition|(
name|t
operator|!=
name|nil
name|and
name|t
operator|->
name|name
operator|!=
name|fieldname
condition|)
block|{
name|t
operator|=
name|t
operator|->
name|chain
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

end_unit

