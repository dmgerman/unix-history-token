begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  	    	C compiler, part 2  	Copyright 1972 Bell Telephone Laboratories, Inc.  */
end_comment

begin_include
include|#
directive|include
file|"c1h.c"
end_include

begin_decl_stmt
name|char
name|maprel
index|[]
block|{
name|EQUAL
operator|,
name|NEQUAL
operator|,
name|GREATEQ
operator|,
name|GREAT
operator|,
name|LESSEQ
operator|,
name|LESS
operator|,
name|GREATQP
operator|,
name|GREATP
operator|,
name|LESSEQP
operator|,
name|LESSP
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
name|notrel
index|[]
block|{
name|NEQUAL
operator|,
name|EQUAL
operator|,
name|GREAT
operator|,
name|GREATEQ
operator|,
name|LESS
operator|,
name|LESSEQ
operator|,
name|GREATP
operator|,
name|GREATQP
operator|,
name|LESSP
operator|,
name|LESSEQP
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|tconst
name|czero
block|{
name|CON
operator|,
name|INT
operator|,
literal|0
operator|,
literal|0
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tconst
name|cone
block|{
name|CON
operator|,
name|INT
operator|,
literal|0
operator|,
literal|1
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tconst
name|fczero
block|{
name|SFCON
operator|,
name|DOUBLE
operator|,
literal|0
operator|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|table
modifier|*
name|tabtab
index|[]
block|{
name|regtab
operator|,
name|efftab
operator|,
name|cctab
operator|,
name|sptab
operator|,
literal|0
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|int
name|nreg
literal|3
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|isn
literal|10000
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|namsiz
literal|8
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|treebase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|xdel
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|treespace
index|[
name|ossiz
index|]
decl_stmt|;
name|struct
name|table
modifier|*
name|table
decl_stmt|;
specifier|register
operator|*
name|sp
operator|,
name|c
operator|,
operator|*
name|tree
expr_stmt|;
extern|extern fout;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|error
argument_list|(
literal|"Arg count"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|ascbuf
argument_list|)
operator|<
literal|0
operator|||
name|fopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|binbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Missing temp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fout
operator|=
name|creat
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't create %s"
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|treebase
operator|=
name|getw
argument_list|(
name|binbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|treebase
operator|<
name|treespace
condition|)
block|{
name|error
argument_list|(
literal|"Tree space botch"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|spacemax
operator|=
operator|&
name|treespace
index|[
name|ossiz
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ascbuf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|sp
operator|=
name|treebase
expr_stmt|;
name|c
operator|=
name|getw
argument_list|(
name|binbuf
argument_list|)
expr_stmt|;
name|tree
operator|=
name|getw
argument_list|(
name|binbuf
argument_list|)
expr_stmt|;
name|table
operator|=
name|tabtab
index|[
name|getw
argument_list|(
name|binbuf
argument_list|)
index|]
expr_stmt|;
name|line
operator|=
name|getw
argument_list|(
name|binbuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|c
operator|>=
literal|0
condition|)
operator|*
name|sp
operator|++
operator|=
name|getw
argument_list|(
name|binbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
literal|0
condition|)
comment|/* is switch */
name|pswitch
argument_list|(
name|treebase
argument_list|,
name|sp
argument_list|,
name|tree
argument_list|)
expr_stmt|;
else|else
block|{
name|spacep
operator|=
name|sp
expr_stmt|;
name|tree
operator|=
name|optim
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|nstack
operator|=
literal|0
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfloat
condition|)
name|printf
argument_list|(
literal|".globl	fltused\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|nerror
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|match
parameter_list|(
name|atree
parameter_list|,
name|table
parameter_list|,
name|nrleft
parameter_list|)
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
name|struct
name|table
modifier|*
name|table
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|dope
decl_stmt|;
name|struct
name|tnode
modifier|*
name|p2
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p1
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
specifier|register
name|struct
name|optab
modifier|*
name|opt
decl_stmt|;
if|if
condition|(
operator|(
name|tree
operator|=
name|atree
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|table
operator|==
name|lsptab
condition|)
name|table
operator|=
name|sptab
expr_stmt|;
name|op
operator|=
name|tree
operator|->
name|op
expr_stmt|;
name|dope
operator|=
name|opdope
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dope
operator|&
name|LEAF
operator|)
operator|==
literal|0
condition|)
name|p1
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
else|else
name|p1
operator|=
name|tree
expr_stmt|;
name|t1
operator|=
name|p1
operator|->
name|type
expr_stmt|;
name|d1
operator|=
name|dcalc
argument_list|(
name|p1
argument_list|,
name|nrleft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dope
operator|&
name|BINARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|p2
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
name|t2
operator|=
name|p2
operator|->
name|type
expr_stmt|;
name|d2
operator|=
name|dcalc
argument_list|(
name|p2
argument_list|,
name|nrleft
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|table
operator|->
name|op
operator|!=
name|op
condition|;
name|table
operator|++
control|)
if|if
condition|(
name|table
operator|->
name|op
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|opt
operator|=
name|table
operator|->
name|tabp
init|;
name|opt
operator|->
name|tabdeg1
operator|!=
literal|0
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
name|d1
operator|>
operator|(
name|opt
operator|->
name|tabdeg1
operator|&
literal|077
operator|)
operator|||
operator|(
name|opt
operator|->
name|tabdeg1
operator|>=
literal|0100
operator|&&
operator|(
name|p1
operator|->
name|op
operator|!=
name|STAR
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|notcompat
argument_list|(
name|p1
argument_list|,
name|opt
operator|->
name|tabtyp1
argument_list|,
name|op
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|opdope
index|[
name|op
index|]
operator|&
name|BINARY
operator|)
operator|!=
literal|0
operator|&&
name|p2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|d2
operator|>
operator|(
name|opt
operator|->
name|tabdeg2
operator|&
literal|077
operator|)
operator|||
operator|(
name|opt
operator|->
name|tabdeg2
operator|>=
literal|0100
operator|)
operator|&&
operator|(
name|p2
operator|->
name|op
operator|!=
name|STAR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|notcompat
argument_list|(
name|p2
argument_list|,
name|opt
operator|->
name|tabtyp2
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
block|}
return|return
operator|(
name|opt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|rcexpr
argument_list|(
argument|atree
argument_list|,
argument|atable
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|atable
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
expr_stmt|;
name|int
name|modf
decl_stmt|,
name|nargs
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
specifier|register
name|struct
name|table
modifier|*
name|table
decl_stmt|;
name|table
operator|=
name|atable
expr_stmt|;
if|if
condition|(
operator|(
name|tree
operator|=
name|atree
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
case|case
name|SETREG
case|:
name|nreg
operator|=
name|tree
operator|->
name|type
operator|-
literal|1
expr_stmt|;
return|return;
case|case
name|CBRANCH
case|:
name|cbranch
argument_list|(
name|tree
operator|->
name|btree
argument_list|,
name|tree
operator|->
name|lbl
argument_list|,
name|tree
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|INIT
case|:
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|==
name|AMPER
condition|)
name|tree
operator|->
name|tr1
operator|=
name|tree
operator|->
name|tr1
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|NAME
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|CON
condition|)
name|error
argument_list|(
literal|"Illegal initialization"
argument_list|)
expr_stmt|;
else|else
name|cexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|nreg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EXCLA
case|:
if|if
condition|(
operator|(
name|opdope
index|[
name|tree
operator|->
name|tr1
operator|->
name|op
index|]
operator|&
name|RELAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|tree
operator|->
name|op
operator|=
name|notrel
index|[
name|tree
operator|->
name|op
operator|-
name|EQUAL
index|]
expr_stmt|;
block|}
break|break;
case|case
name|RFORCE
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|rcexpr
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"mov%c	r%d,r0\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
operator|->
name|tr1
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|COMMA
case|:
name|rcexpr
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|efftab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|r
operator|=
literal|0
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
name|modf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|NAME
condition|)
block|{
comment|/* get nargs right */
name|nargs
operator|++
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
name|tree
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
condition|)
block|{
while|while
condition|(
name|tree
operator|->
name|op
operator|==
name|COMMA
condition|)
block|{
name|r
operator|=
operator|+
name|comarg
argument_list|(
name|tree
operator|->
name|tr2
argument_list|,
operator|&
name|modf
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
block|}
name|r
operator|=
operator|+
name|comarg
argument_list|(
name|tree
argument_list|,
operator|&
name|modf
argument_list|)
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
block|}
name|tree
operator|=
name|atree
expr_stmt|;
name|tree
operator|->
name|op
operator|=
name|CALL2
expr_stmt|;
if|if
condition|(
name|modf
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|class
operator|==
name|EXTERN
condition|)
name|tree
operator|->
name|op
operator|=
name|CALL1
expr_stmt|;
name|cexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|popstk
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|nstack
operator|=
operator|-
name|nargs
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|efftab
operator|||
name|table
operator|==
name|regtab
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
literal|0
expr_stmt|;
name|xdel
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|xdel
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|fixup
goto|;
case|case
name|TIMES
case|:
case|case
name|DIVIDE
case|:
case|case
name|ASTIMES
case|:
case|case
name|ASDIV
case|:
name|pow2
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
name|modf
operator|=
literal|100
expr_stmt|;
name|tree
operator|=
name|reorder
argument_list|(
name|tree
argument_list|,
name|reg
argument_list|,
operator|&
name|modf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|modf
operator|!=
literal|100
condition|)
name|tree
operator|=
name|optim
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|efftab
operator|&&
name|tree
operator|->
name|op
operator|==
name|NAME
condition|)
return|return
operator|(
name|reg
operator|)
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|cexpr
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|table
operator|!=
name|regtab
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|cexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|fixup
label|:
name|modf
operator|=
name|isfloat
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|sptab
operator|||
name|table
operator|==
name|lsptab
condition|)
block|{
name|printf
argument_list|(
literal|"mov%c	r%d,%c(sp)\n"
argument_list|,
name|modf
argument_list|,
name|r
argument_list|,
name|table
operator|==
name|sptab
condition|?
literal|'-'
else|:
literal|0
argument_list|)
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
name|atree
operator|=
name|xdel
index|[
literal|1
index|]
expr_stmt|;
name|xdel
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xdel
index|[
literal|0
index|]
condition|)
block|{
name|tree
operator|=
name|xdel
index|[
literal|0
index|]
expr_stmt|;
name|xdel
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|efftab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atree
condition|)
name|rcexpr
argument_list|(
name|atree
argument_list|,
name|efftab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
name|printf
argument_list|(
literal|"tst%c	r%d\n"
argument_list|,
name|modf
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
name|error
argument_list|(
literal|"No match for op %d"
argument_list|,
name|tree
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|struct
name|table
modifier|*
name|cregtab
decl_stmt|;
end_decl_stmt

begin_macro
name|cexpr
argument_list|(
argument|atree
argument_list|,
argument|table
argument_list|,
argument|areg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
name|struct
name|table
modifier|*
name|ctable
decl_stmt|;
name|struct
name|tnode
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|reg1
decl_stmt|,
name|rreg
decl_stmt|,
name|flag
decl_stmt|,
name|opd
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|struct
name|tnode
modifier|*
name|del
index|[
literal|2
index|]
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
name|del
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|del
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|areg
expr_stmt|;
name|p1
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
name|c
operator|=
name|tree
operator|->
name|op
expr_stmt|;
name|opd
operator|=
name|opdope
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|opd
operator|&
name|RELAT
operator|||
name|c
operator|==
name|LOGAND
operator|||
name|c
operator|==
name|LOGOR
operator|||
name|c
operator|==
name|EXCLA
operator|)
operator|&&
name|table
operator|!=
name|cctab
condition|)
block|{
name|cbranch
argument_list|(
name|tree
argument_list|,
name|c
operator|=
name|isn
operator|++
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|&
name|czero
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|&
name|cone
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|isn
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QUEST
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cbranch
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|c
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|flag
operator|=
name|nstack
expr_stmt|;
name|rreg
operator|=
name|rcexpr
argument_list|(
name|p1
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|nstack
operator|=
name|flag
expr_stmt|;
name|branch
argument_list|(
name|r
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rcexpr
argument_list|(
name|p1
operator|->
name|tr2
argument_list|,
name|table
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rreg
operator|!=
name|reg
condition|)
name|printf
argument_list|(
literal|"mov%c	r%d,r%d\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
argument_list|)
argument_list|,
name|reg
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rreg
expr_stmt|;
name|label
argument_list|(
name|r
argument_list|)
expr_stmt|;
goto|goto
name|retrn
goto|;
block|}
name|reg
operator|=
name|oddreg
argument_list|(
name|tree
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|chkleaf
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|cctab
operator|||
name|table
operator|==
name|cregtab
condition|)
name|r
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|opd
operator|&
name|LEAF
operator|)
operator|==
literal|0
condition|)
name|p1
operator|=
name|tree
operator|->
name|tr1
operator|=
name|reorder
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|areg
argument_list|,
operator|&
name|flag
argument_list|,
name|r
condition|?
literal|0
else|:
operator|&
name|del
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opd
operator|&
name|BINARY
condition|)
name|p2
operator|=
name|tree
operator|->
name|tr2
operator|=
name|reorder
argument_list|(
name|tree
operator|->
name|tr2
argument_list|,
name|areg
argument_list|,
operator|&
name|flag
argument_list|,
name|r
condition|?
literal|0
else|:
operator|&
name|del
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|flag
operator|>
literal|1
operator|&&
operator|(
name|opd
operator|&
name|RELAT
operator|)
operator|&&
name|p2
operator|->
name|op
operator|==
name|CON
operator|&&
name|p2
operator|->
name|value
operator|==
literal|0
operator|&&
name|r
operator|&&
name|opdope
index|[
name|p1
operator|->
name|op
index|]
operator|&
name|LEAF
operator|&&
name|del
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|del
index|[
literal|1
index|]
operator|==
literal|0
condition|)
goto|goto
name|retrn
goto|;
name|tree
operator|=
name|optim
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tree
operator|->
name|op
operator|==
name|PLUS
operator|||
name|tree
operator|->
name|op
operator|==
name|ASPLUS
operator|)
operator|&&
name|p2
operator|->
name|op
operator|==
name|CON
operator|&&
name|p2
operator|->
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|p2
operator|->
name|value
operator|=
literal|1
expr_stmt|;
name|tree
operator|->
name|op
operator|++
expr_stmt|;
comment|/* +, =+ to -, =- */
block|}
if|if
condition|(
name|table
operator|==
name|cregtab
condition|)
name|table
operator|=
name|regtab
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|cctab
operator|||
name|c
operator|==
name|INCAFT
operator|||
name|c
operator|==
name|DECAFT
operator|||
operator|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|efftab
argument_list|,
name|nreg
operator|-
name|reg
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|nreg
operator|-
name|reg
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|xdel
index|[
literal|0
index|]
operator|=
name|del
index|[
literal|0
index|]
expr_stmt|;
name|xdel
index|[
literal|1
index|]
operator|=
name|del
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|string
operator|=
name|opt
operator|->
name|tabstring
expr_stmt|;
name|loop
label|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|&
literal|0200
condition|)
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
name|retrn
label|:
if|if
condition|(
name|del
index|[
literal|0
index|]
condition|)
name|rcexpr
argument_list|(
name|del
index|[
literal|0
index|]
argument_list|,
name|efftab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|del
index|[
literal|1
index|]
condition|)
name|rcexpr
argument_list|(
name|del
index|[
literal|1
index|]
argument_list|,
name|efftab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfloat
argument_list|(
name|tree
argument_list|)
condition|)
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|DIVIDE
operator|||
name|tree
operator|->
name|op
operator|==
name|ASDIV
condition|)
name|reg
operator|--
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
comment|/* A1 */
case|case
literal|'A'
case|:
name|p
operator|=
name|p1
expr_stmt|;
goto|goto
name|adr
goto|;
comment|/* A2 */
case|case
literal|'B'
case|:
name|p
operator|=
name|p2
expr_stmt|;
goto|goto
name|adr
goto|;
comment|/* A */
case|case
literal|'O'
case|:
name|p
operator|=
name|tree
expr_stmt|;
name|adr
label|:
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\''
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
name|pname
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* I */
case|case
literal|'M'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|)
operator|==
literal|'\''
condition|)
name|string
operator|++
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
name|prins
argument_list|(
name|tree
operator|->
name|op
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* B1 */
case|case
literal|'C'
case|:
if|if
condition|(
operator|(
name|opd
operator|&
name|LEAF
operator|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|tree
expr_stmt|;
else|else
name|p
operator|=
name|p1
expr_stmt|;
goto|goto
name|pbyte
goto|;
comment|/* BF */
case|case
literal|'P'
case|:
name|p
operator|=
name|tree
expr_stmt|;
goto|goto
name|pb1
goto|;
comment|/* B2 */
case|case
literal|'D'
case|:
name|p
operator|=
name|p2
expr_stmt|;
name|pbyte
label|:
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CHAR
condition|)
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|pb1
label|:
if|if
condition|(
name|isfloat
argument_list|(
name|p
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* BE */
case|case
literal|'L'
case|:
if|if
condition|(
name|p1
operator|->
name|type
operator|==
name|CHAR
operator|||
name|p2
operator|->
name|type
operator|==
name|CHAR
condition|)
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|p
operator|=
name|tree
expr_stmt|;
goto|goto
name|pb1
goto|;
comment|/* C1 */
case|case
literal|'E'
case|:
name|p
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
goto|goto const;
comment|/* C2 */
case|case
literal|'F'
case|:
name|p
operator|=
name|p2
operator|->
name|tr1
expr_stmt|;
specifier|const
operator|:
name|printf
argument_list|(
literal|"%o"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* F */
case|case
literal|'G'
case|:
name|p
operator|=
name|p1
expr_stmt|;
name|flag
operator|=
literal|01
expr_stmt|;
goto|goto
name|subtre
goto|;
comment|/* S */
case|case
literal|'K'
case|:
name|p
operator|=
name|p2
expr_stmt|;
name|flag
operator|=
literal|02
expr_stmt|;
goto|goto
name|subtre
goto|;
comment|/* H */
case|case
literal|'H'
case|:
name|p
operator|=
name|tree
expr_stmt|;
name|flag
operator|=
literal|04
expr_stmt|;
name|subtre
label|:
name|ctable
operator|=
name|regtab
expr_stmt|;
name|c
operator|=
operator|*
name|string
operator|++
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|02
operator|)
operator|!=
literal|0
condition|)
name|ctable
operator|=
name|sptab
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|04
operator|)
operator|!=
literal|0
condition|)
name|ctable
operator|=
name|cctab
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
literal|01
operator|)
operator|&&
name|ctable
operator|==
name|regtab
operator|&&
operator|(
name|c
operator|&
literal|01
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tree
operator|->
name|op
operator|==
name|DIVIDE
operator|||
name|tree
operator|->
name|op
operator|==
name|MOD
operator|||
name|tree
operator|->
name|op
operator|==
name|ASDIV
operator|||
name|tree
operator|->
name|op
operator|==
name|ASMOD
operator|)
condition|)
name|ctable
operator|=
name|cregtab
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|01
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|collcon
argument_list|(
name|p
argument_list|)
operator|&&
name|ctable
operator|!=
name|sptab
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
condition|)
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|table
operator|==
name|lsptab
operator|&&
name|ctable
operator|==
name|sptab
condition|)
name|ctable
operator|=
name|lsptab
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|010
condition|)
name|r
operator|=
name|reg1
expr_stmt|;
elseif|else
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|LEAF
operator|||
name|p
operator|->
name|degree
operator|<
literal|2
condition|)
name|r
operator|=
name|reg
expr_stmt|;
else|else
name|r
operator|=
name|areg
expr_stmt|;
name|rreg
operator|=
name|rcexpr
argument_list|(
name|p
argument_list|,
name|ctable
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctable
operator|!=
name|regtab
operator|&&
name|ctable
operator|!=
name|cregtab
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|c
operator|&
literal|010
condition|)
name|reg1
operator|=
name|rreg
expr_stmt|;
elseif|else
if|if
condition|(
name|rreg
operator|!=
name|reg
condition|)
if|if
condition|(
name|oddreg
argument_list|(
name|tree
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|flag
operator|&
literal|04
operator|||
name|flag
operator|&
literal|01
operator|&&
name|xdcalc
argument_list|(
name|p2
argument_list|,
name|nreg
operator|-
name|rreg
operator|-
literal|1
argument_list|)
operator|<=
operator|(
name|opt
operator|->
name|tabdeg2
operator|&
literal|077
operator|)
operator|||
name|flag
operator|&
literal|02
operator|&&
name|xdcalc
argument_list|(
name|p1
argument_list|,
name|nreg
operator|-
name|rreg
operator|-
literal|1
argument_list|)
operator|<=
operator|(
name|opt
operator|->
name|tabdeg1
operator|&
literal|077
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|rreg
expr_stmt|;
name|reg1
operator|=
name|rreg
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"mov%c\tr%d,r%d\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
argument_list|)
argument_list|,
name|rreg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* R */
case|case
literal|'I'
case|:
name|r
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|r
operator|--
expr_stmt|;
block|}
goto|goto
name|preg
goto|;
comment|/* R1 */
case|case
literal|'J'
case|:
name|r
operator|=
name|reg1
expr_stmt|;
name|preg
label|:
if|if
condition|(
name|r
operator|>
name|nreg
condition|)
name|error
argument_list|(
literal|"Register overflow: simplify expression"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'-'
case|:
comment|/* check -(sp) */
if|if
condition|(
operator|*
name|string
operator|==
literal|'('
condition|)
block|{
name|nstack
operator|++
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|lsptab
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
break|break;
case|case
literal|')'
case|:
comment|/* check (sp)+ */
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'+'
condition|)
name|nstack
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* #1 */
case|case
literal|'#'
case|:
name|p
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
goto|goto
name|nmbr
goto|;
comment|/* #2 */
case|case
literal|'"'
case|:
name|p
operator|=
name|p2
operator|->
name|tr1
expr_stmt|;
name|nmbr
label|:
if|if
condition|(
name|collcon
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
condition|)
block|{
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|tr2
operator|)
operator|->
name|op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|value
condition|)
name|psoct
argument_list|(
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|AMPER
condition|)
name|pname
argument_list|(
name|p
operator|->
name|tr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
comment|/* V */
case|case
literal|'V'
case|:
name|tree
operator|->
name|op
operator|=
name|maprel
index|[
name|tree
operator|->
name|op
operator|-
name|EQUAL
index|]
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'^'
case|:
comment|/* for ++ --, tr2 is length */
name|printf
argument_list|(
literal|"%o"
argument_list|,
name|tree
operator|->
name|tr2
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'T'
case|:
comment|/* "tst R" if 1st op not in cctab */
if|if
condition|(
name|dcalc
argument_list|(
name|p1
argument_list|,
literal|5
argument_list|)
operator|>
literal|12
operator|&&
operator|!
name|match
argument_list|(
name|p1
argument_list|,
name|cctab
argument_list|,
literal|10
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tst	r%d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_macro
name|reorder
argument_list|(
argument|ap
argument_list|,
argument|reg
argument_list|,
argument|afp
argument_list|,
argument|delp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|afp
decl_stmt|,
modifier|*
name|delp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
modifier|*
name|fp
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|LEAF
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|fp
operator|=
name|afp
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
operator|||
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
block|{
name|p
operator|->
name|tr1
operator|=
name|reorder
argument_list|(
name|p1
argument_list|,
name|reg
argument_list|,
name|fp
argument_list|,
name|delp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
name|p
operator|->
name|tr2
operator|=
name|reorder
argument_list|(
name|p
operator|->
name|tr2
argument_list|,
name|reg
argument_list|,
name|fp
argument_list|,
name|delp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fp
condition|)
operator|*
name|fp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|NAME
condition|)
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ASLSH
case|:
case|case
name|ASRSH
case|:
case|case
name|ASSIGN
case|:
if|if
condition|(
name|p1
operator|->
name|class
operator|!=
name|REG
operator|||
name|isfloat
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASSIGN
condition|)
switch|switch
condition|(
name|p
operator|->
name|tr2
operator|->
name|op
condition|)
block|{
case|case
name|TIMES
case|:
case|case
name|DIVIDE
case|:
if|if
condition|(
operator|!
name|ispow2
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
condition|)
break|break;
name|pow2
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
expr_stmt|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|EXOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|RSHIFT
case|:
name|p1
operator|=
name|p
operator|->
name|tr2
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|xdcalc
argument_list|(
name|p1
argument_list|)
operator|>
literal|12
operator|||
name|p1
operator|->
name|op
operator|==
name|NAME
operator|&&
operator|(
name|p1
operator|->
name|nloc
operator|==
name|p
operator|->
name|tr1
operator|->
name|nloc
operator|||
name|p1
operator|->
name|regno
operator|==
name|p
operator|->
name|tr1
operator|->
name|nloc
operator|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p1
operator|=
name|p
operator|->
name|tr2
expr_stmt|;
name|p
operator|->
name|tr2
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|tr1
operator|->
name|op
operator|!=
name|NAME
operator|||
name|p1
operator|->
name|tr1
operator|->
name|class
operator|!=
name|REG
operator|||
name|p1
operator|->
name|tr1
operator|->
name|nloc
operator|!=
name|p
operator|->
name|tr1
operator|->
name|nloc
condition|)
name|rcexpr
argument_list|(
name|p
argument_list|,
name|efftab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|p
operator|->
name|tr2
operator|=
name|p1
operator|->
name|tr2
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|p1
operator|->
name|op
operator|+
name|ASPLUS
operator|-
name|PLUS
expr_stmt|;
operator|(
operator|*
name|fp
operator|)
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
goto|goto
name|OK
goto|;
case|case
name|INCAFT
case|:
case|case
name|DECAFT
case|:
if|if
condition|(
name|delp
operator|&&
operator|*
name|fp
operator|<
literal|100
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|NAME
operator|&&
name|p1
operator|->
name|class
operator|==
name|REG
condition|)
name|p1
operator|=
name|block
argument_list|(
literal|3
argument_list|,
name|p1
operator|->
name|op
argument_list|,
name|p1
operator|->
name|type
argument_list|,
name|p1
operator|->
name|elsize
argument_list|,
name|p1
operator|->
name|tr1
argument_list|,
name|p1
operator|->
name|offset
argument_list|,
name|p1
operator|->
name|nloc
argument_list|)
expr_stmt|;
operator|*
name|delp
operator|=
name|p
expr_stmt|;
operator|*
name|fp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
break|break;
case|case
name|ASTIMES
case|:
case|case
name|ASDIV
case|:
if|if
condition|(
operator|!
name|ispow2
argument_list|(
name|p
argument_list|)
condition|)
break|break;
case|case
name|ASPLUS
case|:
case|case
name|ASMINUS
case|:
case|case
name|ASSAND
case|:
case|case
name|ASOR
case|:
case|case
name|ASXOR
case|:
case|case
name|DECBEF
case|:
case|case
name|INCBEF
case|:
name|OK
label|:
if|if
condition|(
operator|*
name|fp
operator|>=
literal|100
condition|)
break|break;
name|rcexpr
argument_list|(
name|p
argument_list|,
name|delp
condition|?
name|efftab
else|:
name|cctab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fp
operator|)
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|chkleaf
argument_list|(
argument|atree
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tnode
name|lbuf
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|!=
name|STAR
operator|&&
name|dcalc
argument_list|(
name|tree
argument_list|,
name|nreg
operator|-
name|reg
argument_list|)
operator|>
literal|12
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lbuf
operator|.
name|op
operator|=
name|LOAD
expr_stmt|;
name|lbuf
operator|.
name|type
operator|=
name|tree
operator|->
name|type
expr_stmt|;
name|lbuf
operator|.
name|degree
operator|=
name|tree
operator|->
name|degree
expr_stmt|;
name|lbuf
operator|.
name|tr1
operator|=
name|tree
expr_stmt|;
return|return
operator|(
name|rcexpr
argument_list|(
operator|&
name|lbuf
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|comarg
argument_list|(
argument|atree
argument_list|,
argument|flagp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|flagp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|rathole
expr_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
name|struct
name|tnode
modifier|*
name|pmp
decl_stmt|;
specifier|register
name|retval
expr_stmt|;
name|pmp
operator|=
literal|0
expr_stmt|;
name|tree
operator|=
name|reorder
argument_list|(
name|atree
argument_list|,
literal|0
argument_list|,
operator|&
name|rathole
argument_list|,
operator|&
name|pmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|STRUCT
condition|)
name|error
argument_list|(
literal|"Illegal structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstack
operator|||
name|isfloat
argument_list|(
name|tree
argument_list|)
condition|)
block|{
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|sptab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|arlength
argument_list|(
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|flagp
operator|)
operator|++
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|lsptab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pmp
condition|)
name|rcexpr
argument_list|(
name|pmp
argument_list|,
name|efftab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

end_unit

