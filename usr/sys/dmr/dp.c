begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  */
end_comment

begin_comment
comment|/*  * DP-11 Synchronous interface driver  * This driver is rather insensitive to the remote  * device it talks to, which is to say most of the protocol  * must be supplied by the calling program.  * Exceptions: parity is even; 7 data bits per character;  * max. of 512 characters per record; 10 second timeout  * on waiting to receive; half-duplex transmission.  */
end_comment

begin_include
include|#
directive|include
file|"../param.h"
end_include

begin_include
include|#
directive|include
file|"../conf.h"
end_include

begin_include
include|#
directive|include
file|"../user.h"
end_include

begin_include
include|#
directive|include
file|"../buf.h"
end_include

begin_comment
comment|/* control info */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|dp_buf
decl_stmt|;
name|char
modifier|*
name|dp_bufp
decl_stmt|;
name|int
name|dp_nxmit
decl_stmt|;
name|char
name|dp_state
decl_stmt|;
name|char
name|dp_timer
decl_stmt|;
name|int
name|dp_proc
decl_stmt|;
block|}
name|dp11
struct|;
end_struct

begin_comment
comment|/* device registers */
end_comment

begin_struct
struct|struct
block|{
name|int
name|dprcsr
decl_stmt|;
name|char
name|dprbuf
decl_stmt|;
name|char
name|dpsyn0
decl_stmt|;
name|int
name|dptcsr
decl_stmt|;
name|char
name|dptbuf
decl_stmt|;
name|char
name|dpsyn1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* bits */
end_comment

begin_define
define|#
directive|define
name|ODDPAR
value|010000
end_define

begin_define
define|#
directive|define
name|IENABLE
value|0100
end_define

begin_define
define|#
directive|define
name|HDUPLX
value|02
end_define

begin_define
define|#
directive|define
name|CTRANS
value|0100000
end_define

begin_define
define|#
directive|define
name|RORUN
value|040000
end_define

begin_define
define|#
directive|define
name|RING
value|020000
end_define

begin_define
define|#
directive|define
name|DSRDY
value|010000
end_define

begin_define
define|#
directive|define
name|CARRIER
value|04000
end_define

begin_define
define|#
directive|define
name|DONE
value|0200
end_define

begin_define
define|#
directive|define
name|IENABLE
value|0100
end_define

begin_define
define|#
directive|define
name|SIENABL
value|040
end_define

begin_define
define|#
directive|define
name|WRITE
value|1
end_define

begin_define
define|#
directive|define
name|READ
value|0
end_define

begin_define
define|#
directive|define
name|DTRDY
value|01
end_define

begin_define
define|#
directive|define
name|RCVACT
value|04000
end_define

begin_define
define|#
directive|define
name|DPADDR
value|0174770
end_define

begin_define
define|#
directive|define
name|DPPRI
value|5
end_define

begin_define
define|#
directive|define
name|SYN
value|026
end_define

begin_comment
comment|/* (receive) sync character */
end_comment

begin_comment
comment|/*  * The open fails unless the device is not open or  * the opening process is the one that has it open already.  */
end_comment

begin_macro
name|dpopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_block
block|{
name|int
name|dptimeout
parameter_list|()
function_decl|;
if|if
condition|(
name|dp11
operator|.
name|dp_proc
operator|!=
literal|0
operator|&&
name|dp11
operator|.
name|dp_proc
operator|!=
name|u
operator|.
name|u_procp
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|ENXIO
expr_stmt|;
return|return;
block|}
name|dp11
operator|.
name|dp_proc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|dp11
operator|.
name|dp_state
operator|=
name|READ
expr_stmt|;
if|if
condition|(
name|dp11
operator|.
name|dp_buf
operator|==
literal|0
condition|)
block|{
name|dp11
operator|.
name|dp_buf
operator|=
name|getblk
argument_list|(
name|NODEV
argument_list|)
expr_stmt|;
name|dp11
operator|.
name|dp_bufp
operator|=
name|dp11
operator|.
name|dp_buf
operator|->
name|b_addr
expr_stmt|;
name|dp11
operator|.
name|dp_timer
operator|=
name|HZ
expr_stmt|;
name|timeout
argument_list|(
name|dptimeout
argument_list|,
literal|0
argument_list|,
name|HZ
argument_list|)
expr_stmt|;
block|}
name|DPADDR
operator|->
name|dpsyn0
operator|=
name|SYN
expr_stmt|;
name|DPADDR
operator|->
name|dprcsr
operator|=
name|HDUPLX
operator||
name|IENABLE
expr_stmt|;
name|DPADDR
operator|->
name|dptcsr
operator|=
name|IENABLE
operator||
name|SIENABL
operator||
name|DTRDY
expr_stmt|;
block|}
end_block

begin_macro
name|dpclose
argument_list|()
end_macro

begin_block
block|{
name|DPADDR
operator|->
name|dprcsr
operator|=
literal|0
expr_stmt|;
name|DPADDR
operator|->
name|dptcsr
operator|=
literal|0
expr_stmt|;
name|dp11
operator|.
name|dp_timer
operator|=
literal|0
expr_stmt|;
name|dp11
operator|.
name|dp_proc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp11
operator|.
name|dp_buf
operator|!=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|dp11
operator|.
name|dp_buf
argument_list|)
expr_stmt|;
name|dp11
operator|.
name|dp_buf
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Read waits until:  *  there is loss of "data set ready", or  *  a timeout occurs, or  *  a full record has been received.  * The former two result in an error.  */
end_comment

begin_macro
name|dpread
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|epp
decl_stmt|;
name|bp
operator|=
name|dp11
operator|.
name|dp_buf
operator|->
name|b_addr
expr_stmt|;
name|epp
operator|=
operator|&
name|dp11
operator|.
name|dp_bufp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dpwait
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|*
name|epp
operator|>
name|bp
condition|)
break|break;
name|spl6
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp11
operator|.
name|dp_timer
operator|<=
literal|1
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return;
block|}
name|sleep
argument_list|(
operator|&
name|dp11
argument_list|,
name|DPPRI
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
block|}
name|iomove
argument_list|(
name|dp11
operator|.
name|dp_buf
argument_list|,
literal|0
argument_list|,
name|min
argument_list|(
name|u
operator|.
name|u_count
argument_list|,
operator|*
name|epp
operator|-
name|bp
argument_list|)
argument_list|,
name|B_READ
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * write checks to make sure that the data set is not reading,  * and that it is ready.  Then the record is copied  * and transmission started.  */
end_comment

begin_macro
name|dpwrite
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|u
operator|.
name|u_count
operator|==
literal|0
operator|||
name|dpwait
argument_list|()
condition|)
return|return;
name|dp11
operator|.
name|dp_state
operator|=
name|WRITE
expr_stmt|;
name|bp
operator|=
name|dp11
operator|.
name|dp_buf
operator|->
name|b_addr
expr_stmt|;
name|dp11
operator|.
name|dp_bufp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_count
operator|>
literal|512
condition|)
name|u
operator|.
name|u_count
operator|=
literal|512
expr_stmt|;
name|dp11
operator|.
name|dp_nxmit
operator|=
name|u
operator|.
name|u_count
expr_stmt|;
name|iomove
argument_list|(
name|dp11
operator|.
name|dp_buf
argument_list|,
literal|0
argument_list|,
name|u
operator|.
name|u_count
argument_list|,
name|B_WRITE
argument_list|)
expr_stmt|;
name|dpstart
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * If "data set ready" is down return an error; otherwise  * wait until the dataset is in read state with no carrier,  * which means a record has just been received.  */
end_comment

begin_macro
name|dpwait
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|DPADDR
operator|->
name|dptcsr
operator|&
name|DSRDY
operator|)
operator|==
literal|0
operator|||
name|dp11
operator|.
name|dp_buf
operator|==
literal|0
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|spl6
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp11
operator|.
name|dp_state
operator|==
name|READ
operator|&&
operator|(
name|DPADDR
operator|->
name|dptcsr
operator|&
name|CARRIER
operator|)
operator|==
literal|0
condition|)
block|{
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sleep
argument_list|(
operator|&
name|dp11
argument_list|,
name|DPPRI
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Start off the next character to be transmitted;  * when the record is done, drop back into read state.  */
end_comment

begin_macro
name|dpstart
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|extern
name|char
name|partab
index|[]
decl_stmt|;
name|dp11
operator|.
name|dp_timer
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|--
name|dp11
operator|.
name|dp_nxmit
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
operator|(
operator|*
name|dp11
operator|.
name|dp_bufp
operator|++
operator|)
operator|&
literal|0177
expr_stmt|;
name|DPADDR
operator|->
name|dptbuf
operator|=
name|c
operator||
operator|~
name|partab
index|[
name|c
index|]
operator|&
literal|0200
expr_stmt|;
block|}
else|else
block|{
name|dp11
operator|.
name|dp_bufp
operator|=
name|dp11
operator|.
name|dp_buf
operator|->
name|b_addr
expr_stmt|;
name|dp11
operator|.
name|dp_state
operator|=
name|READ
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Count down the DP timer (once per second)  * If it runs out, it presumably means the other station  * won't speak.  */
end_comment

begin_macro
name|dptimeout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dp11
operator|.
name|dp_timer
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|--
name|dp11
operator|.
name|dp_timer
operator|==
literal|0
condition|)
block|{
name|dpturnaround
argument_list|()
expr_stmt|;
name|dp11
operator|.
name|dp_timer
operator|=
literal|1
expr_stmt|;
block|}
name|timeout
argument_list|(
name|dptimeout
argument_list|,
literal|0
argument_list|,
name|HZ
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Receiver interrupt: if reading, stash character  * unless there is an overrun.  */
end_comment

begin_macro
name|dprint
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|DPADDR
operator|->
name|dprbuf
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|dp11
operator|.
name|dp_state
operator|==
name|READ
condition|)
block|{
if|if
condition|(
operator|(
name|DPADDR
operator|->
name|dprcsr
operator|&
name|ODDPAR
operator|)
operator|==
literal|0
condition|)
name|c
operator|=
operator||
literal|0200
expr_stmt|;
if|if
condition|(
name|dp11
operator|.
name|dp_bufp
operator|<
name|dp11
operator|.
name|dp_buf
operator|->
name|b_addr
operator|+
literal|512
condition|)
operator|*
name|dp11
operator|.
name|dp_bufp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Transmitter interrupt:  * Knock down hardware bits.  * If carrier has dropped, the record is done, so turn the line around;  * otherwise start another character.  */
end_comment

begin_macro
name|dpxint
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|dpstat
decl_stmt|;
name|dpstat
operator|=
name|DPADDR
operator|->
name|dptcsr
expr_stmt|;
name|DPADDR
operator|->
name|dptcsr
operator|=
operator|&
operator|~
operator|(
name|CTRANS
operator||
name|RORUN
operator||
name|RING
operator||
name|DONE
operator|)
expr_stmt|;
if|if
condition|(
name|dpstat
operator|&
operator|(
name|CTRANS
operator||
name|RORUN
operator|)
condition|)
name|dpturnaround
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|dpstat
operator|&
name|DONE
operator|&&
name|dp11
operator|.
name|dp_state
operator|==
name|WRITE
condition|)
name|dpstart
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Change the state from writing to reading at the end of a record.  */
end_comment

begin_macro
name|dpturnaround
argument_list|()
end_macro

begin_block
block|{
name|DPADDR
operator|->
name|dprcsr
operator|=
operator|&
operator|~
name|RCVACT
expr_stmt|;
if|if
condition|(
name|dp11
operator|.
name|dp_state
operator|==
name|WRITE
condition|)
block|{
name|dp11
operator|.
name|dp_timer
operator|=
literal|10
expr_stmt|;
name|dp11
operator|.
name|dp_state
operator|=
name|READ
expr_stmt|;
name|dp11
operator|.
name|dp_bufp
operator|=
name|dp11
operator|.
name|dp_buf
operator|->
name|b_addr
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|dp11
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

