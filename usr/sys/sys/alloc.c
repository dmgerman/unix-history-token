begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/mount.h"
end_include

begin_include
include|#
directive|include
file|"../h/filsys.h"
end_include

begin_include
include|#
directive|include
file|"../h/fblk.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/ino.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_typedef
typedef|typedef
name|struct
name|fblk
modifier|*
name|FBLKP
typedef|;
end_typedef

begin_comment
comment|/*  * alloc will obtain the next available  * free disk block from the free list of  * the specified device.  * The super block has up to NICFREE remembered  * free blocks; the last of these is read to  * obtain NICFREE more . . .  *  * no space on dev x/y -- when  * the free list is exhausted.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|alloc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|daddr_t
name|bno
decl_stmt|;
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_flock
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
goto|goto
name|nospace
goto|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|>
name|NICFREE
condition|)
block|{
name|prdev
argument_list|(
literal|"Bad free count"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
goto|goto
name|nospace
goto|;
block|}
name|bno
operator|=
name|fp
operator|->
name|s_free
index|[
operator|--
name|fp
operator|->
name|s_nfree
index|]
expr_stmt|;
if|if
condition|(
name|bno
operator|==
literal|0
condition|)
goto|goto
name|nospace
goto|;
block|}
do|while
condition|(
name|badblock
argument_list|(
name|fp
argument_list|,
name|bno
argument_list|,
name|dev
argument_list|)
condition|)
do|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
block|{
name|fp
operator|->
name|s_flock
operator|++
expr_stmt|;
name|bp
operator|=
name|bread
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|s_nfree
operator|=
operator|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
operator|)
operator|->
name|df_nfree
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
argument_list|)
operator|->
name|df_free
argument_list|,
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|s_free
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|s_free
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_flock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
goto|goto
name|nospace
goto|;
block|}
name|bp
operator|=
name|getblk
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
name|nospace
label|:
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|prdev
argument_list|(
literal|"no space"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|ENOSPC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * place the specified disk block  * back on the free list of the  * specified device.  */
end_comment

begin_macro
name|free
argument_list|(
argument|dev
argument_list|,
argument|bno
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_flock
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|badblock
argument_list|(
name|fp
argument_list|,
name|bno
argument_list|,
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
block|{
name|fp
operator|->
name|s_nfree
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|s_free
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|>=
name|NICFREE
condition|)
block|{
name|fp
operator|->
name|s_flock
operator|++
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
operator|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
operator|)
operator|->
name|df_nfree
operator|=
name|fp
operator|->
name|s_nfree
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|s_free
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|FBLKP
call|)
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|)
argument_list|)
operator|->
name|df_free
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|s_free
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_flock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_flock
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|s_free
index|[
name|fp
operator|->
name|s_nfree
operator|++
index|]
operator|=
name|bno
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check that a block number is in the  * range between the I list and the size  * of the device.  * This is used mainly to check that a  * garbage file system has not been mounted.  *  * bad block on dev x/y -- not in range  */
end_comment

begin_expr_stmt
name|badblock
argument_list|(
name|fp
argument_list|,
name|bn
argument_list|,
name|dev
argument_list|)
specifier|register
expr|struct
name|filsys
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|daddr_t
name|bn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bn
operator|<
name|fp
operator|->
name|s_isize
operator|||
name|bn
operator|>=
name|fp
operator|->
name|s_fsize
condition|)
block|{
name|prdev
argument_list|(
literal|"bad block"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Allocate an unused I node  * on the specified device.  * Used with file creation.  * The algorithm keeps up to  * NICINOD spare I nodes in the  * super block. When this runs out,  * a linear search through the  * I list is instituted to pick  * up NICINOD more.  */
end_comment

begin_function
name|struct
name|inode
modifier|*
name|ialloc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|dinode
modifier|*
name|dp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|daddr_t
name|adr
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_ilock
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_ilock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>
literal|0
condition|)
block|{
name|ino
operator|=
name|fp
operator|->
name|s_inode
index|[
operator|--
name|fp
operator|->
name|s_ninode
index|]
expr_stmt|;
if|if
condition|(
name|ino
operator|<
name|ROOTINO
condition|)
goto|goto
name|loop
goto|;
name|ip
operator|=
name|iget
argument_list|(
name|dev
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ip
operator|->
name|i_mode
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NADDR
condition|;
name|i
operator|++
control|)
name|ip
operator|->
name|i_un
operator|.
name|i_addr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
comment|/* 		 * Inode was allocated after all. 		 * Look some more. 		 */
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|fp
operator|->
name|s_ilock
operator|++
expr_stmt|;
name|ino
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|adr
operator|=
name|SUPERB
operator|+
literal|1
init|;
name|adr
operator|<
name|fp
operator|->
name|s_isize
condition|;
name|adr
operator|++
control|)
block|{
name|bp
operator|=
name|bread
argument_list|(
name|dev
argument_list|,
name|adr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ino
operator|+=
name|INOPB
expr_stmt|;
continue|continue;
block|}
name|dp
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_dino
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INOPB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|di_mode
operator|!=
literal|0
condition|)
goto|goto
name|cont
goto|;
for|for
control|(
name|ip
operator|=
operator|&
name|inode
index|[
literal|0
index|]
init|;
name|ip
operator|<
operator|&
name|inode
index|[
name|NINODE
index|]
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|dev
operator|==
name|ip
operator|->
name|i_dev
operator|&&
name|ino
operator|==
name|ip
operator|->
name|i_number
condition|)
goto|goto
name|cont
goto|;
name|fp
operator|->
name|s_inode
index|[
name|fp
operator|->
name|s_ninode
operator|++
index|]
operator|=
name|ino
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
name|NICINOD
condition|)
break|break;
name|cont
label|:
name|ino
operator|++
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
name|NICINOD
condition|)
break|break;
block|}
name|fp
operator|->
name|s_ilock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fp
operator|->
name|s_ilock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|prdev
argument_list|(
literal|"Out of inodes"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|ENOSPC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the specified I node  * on the specified device.  * The algorithm stores up  * to NICINOD I nodes in the super  * block and throws away any more.  */
end_comment

begin_macro
name|ifree
argument_list|(
argument|dev
argument_list|,
argument|ino
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ino
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ilock
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
name|NICINOD
condition|)
return|return;
name|fp
operator|->
name|s_inode
index|[
name|fp
operator|->
name|s_ninode
operator|++
index|]
operator|=
name|ino
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * getfs maps a device number into  * a pointer to the incore super  * block.  * The algorithm is a linear  * search through the mount table.  * A consistency check of the  * in core free-block and i-node  * counts.  *  * bad count on dev x/y -- the count  *	check failed. At this point, all  *	the counts are zeroed which will  *	almost certainly lead to "no space"  *	diagnostic  * panic: no fs -- the device is not mounted.  *	this "cannot happen"  */
end_comment

begin_function
name|struct
name|filsys
modifier|*
name|getfs
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|mount
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_bufp
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|m_dev
operator|==
name|dev
condition|)
block|{
name|fp
operator|=
name|mp
operator|->
name|m_bufp
operator|->
name|b_un
operator|.
name|b_filsys
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|>
name|NICFREE
operator|||
name|fp
operator|->
name|s_ninode
operator|>
name|NICINOD
condition|)
block|{
name|prdev
argument_list|(
literal|"bad count"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_ninode
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"no fs"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update is the internal name of  * 'sync'. It goes through the disk  * queues to initiate sandbagged IO;  * goes through the I nodes to write  * modified nodes; and it goes through  * the mount table to initiate modified  * super blocks.  */
end_comment

begin_macro
name|update
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|updlock
condition|)
return|return;
name|updlock
operator|++
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|mount
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_bufp
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|=
name|mp
operator|->
name|m_bufp
operator|->
name|b_un
operator|.
name|b_filsys
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_fmod
operator|==
literal|0
operator|||
name|fp
operator|->
name|s_ilock
operator|!=
literal|0
operator|||
name|fp
operator|->
name|s_flock
operator|!=
literal|0
operator|||
name|fp
operator|->
name|s_ronly
operator|!=
literal|0
condition|)
continue|continue;
name|bp
operator|=
name|getblk
argument_list|(
name|mp
operator|->
name|m_dev
argument_list|,
name|SUPERB
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
continue|continue;
name|fp
operator|->
name|s_fmod
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_time
operator|=
name|time
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ip
operator|=
operator|&
name|inode
index|[
literal|0
index|]
init|;
name|ip
operator|<
operator|&
name|inode
index|[
name|NINODE
index|]
condition|;
name|ip
operator|++
control|)
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|ILOCK
operator|)
operator|==
literal|0
operator|&&
name|ip
operator|->
name|i_count
condition|)
block|{
name|ip
operator|->
name|i_flag
operator||=
name|ILOCK
expr_stmt|;
name|ip
operator|->
name|i_count
operator|++
expr_stmt|;
name|iupdat
argument_list|(
name|ip
argument_list|,
operator|&
name|time
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|updlock
operator|=
literal|0
expr_stmt|;
name|bflush
argument_list|(
name|NODEV
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

