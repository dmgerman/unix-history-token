begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_include
include|#
directive|include
file|"../h/pk.p"
end_include

begin_comment
comment|/*  * kernel support routines.  */
end_comment

begin_decl_stmt
name|struct
name|pack
modifier|*
name|pklines
index|[
name|NPLINES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxwindow
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * start initial synchronization.  * allocate space.  */
end_comment

begin_expr_stmt
name|pkopen
argument_list|(
name|dev
argument_list|,
name|tp
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|pktimeout
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
specifier|static
name|timer_on
expr_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|piocb
name|piocb
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
return|return;
comment|/* 	 * copy user parameters 	 */
if|if
condition|(
name|copyin
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|piocb
argument_list|,
sizeof|sizeof
argument_list|(
name|piocb
argument_list|)
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|npbits
operator|=
name|dtom
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pack
argument_list|)
argument_list|)
expr_stmt|;
name|pk
operator|=
operator|(
expr|struct
name|pack
operator|*
operator|)
name|getepack
argument_list|(
name|npbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk
operator|==
name|NULL
condition|)
goto|goto
name|notsobad
goto|;
name|pkzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pack
argument_list|)
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_rwindow
operator|=
name|piocb
operator|.
name|window
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_rwindow
operator|>
name|maxwindow
condition|)
name|pk
operator|->
name|p_rwindow
operator|=
name|maxwindow
expr_stmt|;
name|pk
operator|->
name|p_rsize
operator|=
name|piocb
operator|.
name|psize
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_rsize
operator|>
literal|512
operator|||
name|pk
operator|->
name|p_rsize
operator|&
literal|037
condition|)
goto|goto
name|notsobad
goto|;
name|pk
operator|->
name|p_mode
operator|=
name|piocb
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_mode
operator|&
literal|01
condition|)
name|pkdebug
operator|++
expr_stmt|;
comment|/* 	 * try to allocate input window 	 */
name|pk
operator|->
name|p_bits
operator|=
name|dtom
argument_list|(
name|pk
operator|->
name|p_rsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pk
operator|->
name|p_rwindow
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|getepack
argument_list|(
name|pk
operator|->
name|p_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
break|break;
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|bp
operator|==
name|NULL
condition|)
goto|goto
name|notsobad
goto|;
name|pk
operator|->
name|p_rwindow
operator|=
name|i
expr_stmt|;
comment|/* 	 * start timer process, 	 * wait for synchronization. 	 */
name|flushtty
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
name|pkdisc
operator|=
name|tp
operator|->
name|t_line
operator|=
name|piocb
operator|.
name|t
expr_stmt|;
name|pk
operator|->
name|p_ttyp
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|t_linep
operator|=
operator|(
name|caddr_t
operator|)
name|pk
expr_stmt|;
name|q2
operator|.
name|c_cf
operator|=
name|q2
operator|.
name|c_cl
operator|=
name|NULL
expr_stmt|;
name|q1
operator|.
name|c_cf
operator|=
name|q1
operator|.
name|c_cl
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ihbuf
expr_stmt|;
name|q1
operator|.
name|c_cc
operator|=
operator|-
name|HDRSIZ
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_iproc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tp
operator|->
name|t_iproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_rmsg
operator|=
name|M_INITA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPLINES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pklines
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pklines
index|[
name|i
index|]
operator|=
name|pk
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
goto|goto
name|notsobad
goto|;
name|found
label|:
name|pk
operator|->
name|p_timer
operator|++
expr_stmt|;
if|if
condition|(
name|timer_on
operator|==
literal|0
condition|)
block|{
name|timer_on
operator|++
expr_stmt|;
name|pktimeout
argument_list|()
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SLEEP
argument_list|(
operator|&
name|pk
operator|->
name|p_state
argument_list|,
name|PKOPRI
argument_list|)
expr_stmt|;
name|pkreset
argument_list|(
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|pk
operator|->
name|p_state
operator|=
name|DOWN
expr_stmt|;
name|pk
operator|->
name|p_rmsg
operator|=
literal|0
expr_stmt|;
name|notsobad
label|:
name|u
operator|.
name|u_error
operator|=
name|ENXIO
expr_stmt|;
return|return;
block|}
name|pksetgrp
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|pkioctl
argument_list|(
name|DIOCGETP
argument_list|,
name|tp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * unix ioctl interface  */
end_comment

begin_expr_stmt
name|pkioctl
argument_list|(
name|com
argument_list|,
name|tp
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|piocb
name|piocb
decl_stmt|;
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
name|pk
operator|=
operator|(
expr|struct
name|pack
operator|*
operator|)
name|tp
operator|->
name|t_linep
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|DIOCGETP
condition|)
block|{
name|piocb
operator|.
name|window
operator|=
name|pk
operator|->
name|p_swindow
expr_stmt|;
name|piocb
operator|.
name|psize
operator|=
name|pk
operator|->
name|p_xsize
expr_stmt|;
name|piocb
operator|.
name|state
operator|=
name|pk
operator|->
name|p_state
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|piocb
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|piocb
argument_list|)
argument_list|)
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|.
name|u_error
operator|==
literal|0
condition|)
name|u
operator|.
name|u_r
operator|.
name|r_val1
operator|=
name|piocb
operator|.
name|psize
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Arrange for the device (i.e. tp)  * to be able to generate signals if need be.  */
end_comment

begin_expr_stmt
name|pksetgrp
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_pgrp
operator|==
literal|0
condition|)
name|pp
operator|->
name|p_pgrp
operator|=
name|pp
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_pgrp
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_pgrp
operator|=
name|pp
operator|->
name|p_pgrp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Shut down io.  * The problem is mainly input since the  * device driver may have a buffer.  */
end_comment

begin_expr_stmt
name|pkturnoff
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|s
expr_stmt|;
name|pk
operator|=
name|PADDR
expr_stmt|;
name|LOCK
expr_stmt|;
name|bp
operator|=
name|pk
operator|->
name|p_io
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|q1
operator|.
name|c_cf
operator|=
name|NULL
expr_stmt|;
name|flushtty
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
block|}
name|UNLOCK
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * link dead?  */
end_comment

begin_expr_stmt
name|pklive
argument_list|(
name|pk
argument_list|)
specifier|register
expr|struct
name|pack
operator|*
name|pk
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|pk
operator|->
name|p_ttyp
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|!=
name|pkdisc
operator|||
name|tp
operator|->
name|t_linep
operator|!=
operator|(
name|caddr_t
operator|)
name|pk
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|tp
operator|->
name|t_state
operator|&
name|CARR_ON
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * timeout process:  * wakes up periodically to check status  * of active lines.  */
end_comment

begin_macro
name|pktimeout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|extern
name|time_t
name|time
decl_stmt|;
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPLINES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pk
operator|=
name|pklines
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|pk
operator|->
name|p_nout
operator|==
name|pk
operator|->
name|p_tout
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_xcount
operator|&&
name|pk
operator|->
name|p_timer
operator|==
literal|0
condition|)
block|{
name|pk
operator|->
name|p_timer
operator|=
literal|3
expr_stmt|;
name|pk
operator|->
name|p_state
operator||=
name|WAITO
expr_stmt|;
block|}
block|}
else|else
name|pk
operator|->
name|p_tout
operator|=
name|pk
operator|->
name|p_nout
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_timer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|BADFRAME
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|M_RJ
expr_stmt|;
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|BADFRAME
expr_stmt|;
goto|goto
name|startup
goto|;
block|}
if|if
condition|(
name|pk
operator|->
name|p_rmsg
condition|)
goto|goto
name|startup
goto|;
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|--
name|pk
operator|->
name|p_timer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|startup
label|:
name|pk
operator|->
name|p_timer
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|WAITO
condition|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DRAINO
condition|)
block|{
name|pk
operator|->
name|p_state
operator||=
name|DOWN
expr_stmt|;
block|}
else|else
block|{
name|pk
operator|->
name|p_state
operator||=
name|RXMIT
expr_stmt|;
block|}
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_timer
operator|=
literal|5
operator|+
literal|2
operator|*
name|pkzot
expr_stmt|;
block|}
name|WAKEUP
argument_list|(
operator|&
name|pk
operator|->
name|p_ps
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_msg
operator||=
name|pk
operator|->
name|p_rmsg
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_msg
condition|)
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
block|}
name|timeout
argument_list|(
name|pktimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|pk
argument_list|,
literal|60
argument_list|)
expr_stmt|;
comment|/* 	 * randomize timeouts. 	 */
name|pkzot
operator|=
literal|2
operator|+
name|time
operator|&
literal|07
expr_stmt|;
block|}
end_block

end_unit

