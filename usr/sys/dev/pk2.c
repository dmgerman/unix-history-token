begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_include
include|#
directive|include
file|"../h/pk.p"
end_include

begin_comment
comment|/*  * input framing and block checking.  * frame layout for most devices is:  *	  *	S|K|X|Y|C|Z|  ... data ... |  *  *	where 	S	== initial synch byte  *		K	== encoded frame size (indexes pksizes[])  *		X, Y	== block check bytes  *		C	== control byte  *		Z	== XOR of header (K^X^Y^C)  *		data	== 0 or more data bytes  *  * device driver interfaces on input are:  *	pkrint  - byte level  *	pkrend  - dma or pseudo-dma transfer level  *	pkdata - packet level  */
end_comment

begin_decl_stmt
name|int
name|pksizes
index|[]
init|=
block|{
literal|1
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,
literal|512
block|,
literal|1024
block|,
literal|2048
block|,
literal|4096
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pseudo-dma byte collection.  * This code can be put in the device driver  * interrupt routine to eliminate the per byte  * subroutine call.  */
end_comment

begin_expr_stmt
name|pkrint
argument_list|(
name|c
argument_list|,
name|tp
argument_list|)
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|q1
operator|.
name|c_cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|q1
operator|.
name|c_cf
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_erase
operator|=
literal|0
expr_stmt|;
operator|*
name|q1
operator|.
name|c_cf
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|q1
operator|.
name|c_cc
condition|)
return|return;
name|pkrend
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * End of input transfer.  */
end_comment

begin_expr_stmt
name|pkrend
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
name|struct
name|header
modifier|*
name|h
decl_stmt|;
specifier|register
name|x
expr_stmt|;
name|char
name|cntl
decl_stmt|,
name|hdcheck
decl_stmt|;
name|unsigned
name|short
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|p
operator|=
name|q1
operator|.
name|c_cl
expr_stmt|;
name|x
operator|=
operator|(
name|int
operator|)
name|q1
operator|.
name|c_cf
operator|-
operator|(
name|int
operator|)
name|p
expr_stmt|;
name|pk
operator|=
operator|(
expr|struct
name|pack
operator|*
operator|)
name|tp
operator|->
name|t_linep
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
operator|&
name|pk
operator|->
name|p_ihbuf
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|HDRSIZ
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|SYN
condition|)
block|{
name|hdcheck
operator|=
name|k
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|sum
operator|=
operator|(
name|unsigned
operator|)
operator|*
name|p
expr_stmt|;
name|hdcheck
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
name|sum
operator||=
operator|(
name|unsigned
operator|)
operator|*
name|p
operator|<<
literal|8
expr_stmt|;
name|hdcheck
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
name|hdcheck
operator|^=
name|cntl
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|hdcheck
operator|!=
operator|*
name|p
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|k
operator|==
literal|9
condition|)
block|{
name|pkcntl
argument_list|(
name|cntl
argument_list|,
name|pk
argument_list|)
expr_stmt|;
name|q1
operator|.
name|c_cf
operator|=
name|q1
operator|.
name|c_cl
expr_stmt|;
name|q1
operator|.
name|c_cc
operator|=
operator|-
name|HDRSIZ
expr_stmt|;
goto|goto
name|istart1
goto|;
block|}
if|if
condition|(
name|k
operator|&&
name|pksizes
index|[
name|k
index|]
operator|==
name|pk
operator|->
name|p_rsize
condition|)
block|{
name|pk
operator|->
name|p_rpr
operator|=
name|cntl
operator|&
name|MOD8
expr_stmt|;
name|pksack
argument_list|(
name|pk
argument_list|)
expr_stmt|;
name|bp
operator|=
name|pk
operator|->
name|p_ipool
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|pk
operator|->
name|p_ipool
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|*
name|bp
expr_stmt|;
name|pk
operator|->
name|p_io
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{ 				}
name|q1
operator|.
name|c_cf
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
expr_stmt|;
name|q1
operator|.
name|c_cc
operator|=
operator|-
name|pk
operator|->
name|p_rsize
expr_stmt|;
name|h
operator|->
name|sum
operator|=
name|sum
expr_stmt|;
name|h
operator|->
name|cntl
operator|=
name|cntl
expr_stmt|;
goto|goto
name|istart1
goto|;
block|}
name|bad
label|:
name|pkbadframe
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
name|scan
label|:
name|x
operator|=
name|HDRSIZ
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|h
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|HDRSIZ
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
name|SYN
condition|)
for|for
control|(
name|x
operator|=
name|i
init|;
name|i
operator|<
name|HDRSIZ
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|p
index|[
name|j
index|]
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
name|q1
operator|.
name|c_cc
operator|=
operator|-
name|x
expr_stmt|;
name|q1
operator|.
name|c_cf
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|p
operator|+
name|j
argument_list|)
expr_stmt|;
goto|goto
name|istart2
goto|;
block|}
if|if
condition|(
name|x
operator|==
name|pk
operator|->
name|p_rsize
condition|)
block|{
name|pkdata
argument_list|(
name|h
operator|->
name|cntl
argument_list|,
name|h
operator|->
name|sum
argument_list|,
name|pk
argument_list|,
name|q1
operator|.
name|c_cl
argument_list|)
expr_stmt|;
name|pk
operator|->
name|p_io
operator|=
name|NULL
expr_stmt|;
name|q1
operator|.
name|c_cf
operator|=
operator|(
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|q1
operator|.
name|c_cc
operator|=
operator|-
name|HDRSIZ
expr_stmt|;
goto|goto
name|istart1
goto|;
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|q1
operator|.
name|c_cf
operator|=
operator|(
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|q1
operator|.
name|c_cc
operator|=
operator|-
name|HDRSIZ
expr_stmt|;
name|pkbadframe
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkbadframe
argument_list|(
name|pk
argument_list|)
expr_stmt|;
goto|goto
name|scan
goto|;
block|}
name|istart1
label|:
name|q1
operator|.
name|c_cl
operator|=
name|q1
operator|.
name|c_cf
expr_stmt|;
name|istart2
label|:
if|if
condition|(
name|tp
operator|->
name|t_iproc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tp
operator|->
name|t_iproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put packet located at address bp  * in an input slot for further processing.  */
end_comment

begin_macro
name|pkdata
argument_list|(
argument|c
argument_list|,
argument|sum
argument_list|,
argument|pk
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|sum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|x
expr_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|int
name|t
decl_stmt|;
name|pk
operator|->
name|p_state
operator|&=
operator|~
name|BADFRAME
expr_stmt|;
name|bp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|cp
expr_stmt|;
name|tp
operator|=
name|pk
operator|->
name|p_ttyp
expr_stmt|;
if|if
condition|(
name|pk
operator|->
name|p_state
operator|&
name|DRAINO
operator|||
operator|!
operator|(
name|pk
operator|->
name|p_state
operator|&
name|LIVE
operator|)
condition|)
block|{
name|pk
operator|->
name|p_msg
operator||=
name|pk
operator|->
name|p_rmsg
expr_stmt|;
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|t
operator|=
name|next
index|[
name|pk
operator|->
name|p_pr
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
name|pk
operator|->
name|p_pr
init|;
name|x
operator|!=
name|t
condition|;
name|x
operator|=
operator|(
name|x
operator|-
literal|1
operator|)
operator|&
literal|7
control|)
block|{
if|if
condition|(
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|==
literal|0
condition|)
goto|goto
name|slot
goto|;
block|}
comment|/* 	 * this can't happen 	 */
name|printf
argument_list|(
literal|"no slot\n"
argument_list|)
expr_stmt|;
name|drop
label|:
operator|*
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|pk
operator|->
name|p_ipool
expr_stmt|;
name|pk
operator|->
name|p_ipool
operator|=
name|bp
expr_stmt|;
return|return;
name|slot
label|:
name|pk
operator|->
name|p_imap
operator||=
name|mask
index|[
name|x
index|]
expr_stmt|;
name|pk
operator|->
name|p_is
index|[
name|x
index|]
operator|=
name|c
expr_stmt|;
name|pk
operator|->
name|p_isum
index|[
name|x
index|]
operator|=
name|sum
expr_stmt|;
name|pk
operator|->
name|p_ib
index|[
name|x
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_chan
condition|)
name|sdata
argument_list|(
name|tp
operator|->
name|t_chan
argument_list|)
expr_stmt|;
else|else
name|wakeup
argument_list|(
operator|&
name|pk
operator|->
name|p_pr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start transmission on output device associated with pk.  * For asynch devices (t_line==1) framing is  * imposed.  For devices with framing and crc  * in the driver (t_line==2) the transfer is  * passed on to the driver.  */
end_comment

begin_macro
name|pkxstart
argument_list|(
argument|pk
argument_list|,
argument|cntl
argument_list|,
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cntl
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|short
name|checkword
decl_stmt|;
name|char
name|hdcheck
decl_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ohbuf
expr_stmt|;
name|tp
operator|=
name|pk
operator|->
name|p_ttyp
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
literal|1
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|SYN
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
operator|*
name|p
operator|=
literal|9
expr_stmt|;
name|checkword
operator|=
name|cntl
expr_stmt|;
name|q3
operator|.
name|c_cl
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
name|pk
operator|->
name|p_lpsize
expr_stmt|;
name|checkword
operator|=
name|pk
operator|->
name|p_osum
index|[
name|x
index|]
operator|^
operator|(
name|unsigned
operator|)
name|cntl
expr_stmt|;
name|q3
operator|.
name|c_cl
operator|=
name|pk
operator|->
name|p_ob
index|[
name|x
index|]
expr_stmt|;
block|}
name|checkword
operator|=
name|CHECK
operator|-
name|checkword
expr_stmt|;
name|hdcheck
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|hdcheck
operator|^=
operator|*
name|p
operator|++
operator|=
name|checkword
expr_stmt|;
name|hdcheck
operator|^=
operator|*
name|p
operator|++
operator|=
name|checkword
operator|>>
literal|8
expr_stmt|;
name|q3
operator|.
name|c_cc
operator|=
operator|-
name|HDRSIZ
expr_stmt|;
block|}
else|else
block|{
name|q3
operator|.
name|c_cc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|hdcheck
operator|^=
operator|*
name|p
operator|++
operator|=
name|cntl
expr_stmt|;
operator|*
name|p
operator|=
name|hdcheck
expr_stmt|;
name|q3
operator|.
name|c_cf
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|pk
operator|->
name|p_ohbuf
expr_stmt|;
comment|/* 	pk->p_srxmit++; */
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * transmitter interrupt.  */
end_comment

begin_decl_stmt
name|int
name|pkdelay
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|pkxint
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pack
modifier|*
name|pk
decl_stmt|;
specifier|register
name|s
expr_stmt|;
specifier|extern
name|int
name|pkoutput
parameter_list|()
function_decl|;
name|pk
operator|=
operator|(
expr|struct
name|pack
operator|*
operator|)
name|tp
operator|->
name|t_linep
expr_stmt|;
name|s
operator|=
name|spl6
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|BUSY
expr_stmt|;
if|if
condition|(
name|q3
operator|.
name|c_cl
operator|==
name|NULL
condition|)
block|{
name|pkoutput
argument_list|(
name|pk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q3
operator|.
name|c_cf
operator|=
name|q3
operator|.
name|c_cl
expr_stmt|;
name|q3
operator|.
name|c_cl
operator|=
name|NULL
expr_stmt|;
name|q3
operator|.
name|c_cc
operator|=
operator|-
name|pk
operator|->
name|p_xsize
expr_stmt|;
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

