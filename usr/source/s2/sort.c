begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|L
value|512
end_define

begin_define
define|#
directive|define
name|N
value|7
end_define

begin_define
define|#
directive|define
name|C
value|20
end_define

begin_define
define|#
directive|define
name|MEM
value|(16*2048)
end_define

begin_define
define|#
directive|define
name|NF
value|10
end_define

begin_decl_stmt
name|int
name|ibuf
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|obuf
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|lspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tspace
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|cmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|term
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|mflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outfil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tabchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|eargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fold
index|[
literal|128
index|]
block|{
literal|0000
operator|,
literal|0001
operator|,
literal|0002
operator|,
literal|0003
operator|,
literal|0004
operator|,
literal|0005
operator|,
literal|0006
operator|,
literal|0007
operator|,
literal|0010
operator|,
literal|0011
operator|,
literal|0012
operator|,
literal|0013
operator|,
literal|0014
operator|,
literal|0015
operator|,
literal|0016
operator|,
literal|0017
operator|,
literal|0020
operator|,
literal|0021
operator|,
literal|0022
operator|,
literal|0023
operator|,
literal|0024
operator|,
literal|0025
operator|,
literal|0026
operator|,
literal|0027
operator|,
literal|0030
operator|,
literal|0031
operator|,
literal|0032
operator|,
literal|0033
operator|,
literal|0034
operator|,
literal|0035
operator|,
literal|0036
operator|,
literal|0037
operator|,
literal|0040
operator|,
literal|0041
operator|,
literal|0042
operator|,
literal|0043
operator|,
literal|0044
operator|,
literal|0045
operator|,
literal|0046
operator|,
literal|0047
operator|,
literal|0050
operator|,
literal|0051
operator|,
literal|0052
operator|,
literal|0053
operator|,
literal|0054
operator|,
literal|0055
operator|,
literal|0056
operator|,
literal|0057
operator|,
literal|0060
operator|,
literal|0061
operator|,
literal|0062
operator|,
literal|0063
operator|,
literal|0064
operator|,
literal|0065
operator|,
literal|0066
operator|,
literal|0067
operator|,
literal|0070
operator|,
literal|0071
operator|,
literal|0072
operator|,
literal|0073
operator|,
literal|0074
operator|,
literal|0075
operator|,
literal|0076
operator|,
literal|0077
operator|,
literal|0100
operator|,
literal|0101
operator|,
literal|0102
operator|,
literal|0103
operator|,
literal|0104
operator|,
literal|0105
operator|,
literal|0106
operator|,
literal|0107
operator|,
literal|0110
operator|,
literal|0111
operator|,
literal|0112
operator|,
literal|0113
operator|,
literal|0114
operator|,
literal|0115
operator|,
literal|0116
operator|,
literal|0117
operator|,
literal|0120
operator|,
literal|0121
operator|,
literal|0122
operator|,
literal|0123
operator|,
literal|0124
operator|,
literal|0125
operator|,
literal|0126
operator|,
literal|0127
operator|,
literal|0130
operator|,
literal|0131
operator|,
literal|0132
operator|,
literal|0133
operator|,
literal|0134
operator|,
literal|0134
operator|,
literal|0136
operator|,
literal|0137
operator|,
literal|0140
operator|,
literal|0101
operator|,
literal|0102
operator|,
literal|0103
operator|,
literal|0104
operator|,
literal|0105
operator|,
literal|0106
operator|,
literal|0107
operator|,
literal|0110
operator|,
literal|0111
operator|,
literal|0112
operator|,
literal|0113
operator|,
literal|0114
operator|,
literal|0115
operator|,
literal|0116
operator|,
literal|0117
operator|,
literal|0120
operator|,
literal|0121
operator|,
literal|0122
operator|,
literal|0123
operator|,
literal|0124
operator|,
literal|0125
operator|,
literal|0126
operator|,
literal|0127
operator|,
literal|0130
operator|,
literal|0131
operator|,
literal|0132
operator|,
literal|0173
operator|,
literal|0174
operator|,
literal|0175
operator|,
literal|0176
operator|,
literal|0177
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
name|nofold
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dict
index|[
literal|128
index|]
block|{
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|0
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
operator|,
literal|1
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
name|nodict
index|[
literal|128
index|]
block|{
literal|1
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|field
block|{
name|char
modifier|*
name|code
decl_stmt|;
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|nflg
decl_stmt|;
name|int
name|rflg
decl_stmt|;
name|int
name|bflg
decl_stmt|;
name|char
modifier|*
name|m
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|n
index|[
literal|2
index|]
decl_stmt|;
block|}
name|fields
index|[
name|NF
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|proto
index|[
literal|9
index|]
block|{
operator|&
name|fold
operator|,
operator|&
name|nodict
operator|,
literal|0
operator|,
literal|1
operator|,
literal|0
operator|,
literal|0
operator|,
operator|-
literal|1
operator|,
literal|0
operator|,
literal|0
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|nfields
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|error
literal|1
expr_stmt|;
end_expr_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|a
operator|,
name|i
expr_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
literal|128
condition|;
name|a
operator|++
control|)
name|nofold
index|[
name|a
index|]
operator|=
name|a
expr_stmt|;
name|nodict
index|[
literal|127
index|]
operator|=
literal|1
expr_stmt|;
name|copyproto
argument_list|()
expr_stmt|;
name|eargv
operator|=
name|argv
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
for|for
control|(
name|arg
operator|=
operator|*
name|argv
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|arg
condition|)
block|{
case|case
literal|'\0'
case|:
if|if
condition|(
name|arg
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
name|outfil
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
continue|continue;
default|default:
name|field
argument_list|(
operator|++
operator|*
name|argv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|++
name|nfields
operator|>=
name|NF
condition|)
block|{
name|mess
argument_list|(
literal|"Too many keys\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|copyproto
argument_list|()
expr_stmt|;
name|field
argument_list|(
operator|++
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
operator|*
name|argv
expr_stmt|;
block|}
name|q
operator|=
operator|&
name|fields
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|1
init|;
name|a
operator|<=
name|nfields
condition|;
name|a
operator|++
control|)
block|{
name|p
operator|=
operator|&
name|fields
index|[
name|a
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
comment|/*sensitive to sizeof(proto)*/
if|if
condition|(
name|p
index|[
name|i
index|]
operator|!=
name|proto
index|[
name|i
index|]
condition|)
goto|goto
name|next
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|q
index|[
name|i
index|]
expr_stmt|;
name|next
label|:
empty_stmt|;
block|}
if|if
condition|(
name|eargc
operator|==
literal|0
condition|)
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
literal|"-"
expr_stmt|;
name|a
operator|=
name|MEM
expr_stmt|;
name|i
operator|=
name|lspace
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|brk
argument_list|(
name|a
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|a
operator|=
operator|-
literal|512
expr_stmt|;
name|brk
argument_list|(
name|a
operator|=
operator|-
literal|512
argument_list|)
expr_stmt|;
comment|/* for recursion */
name|a
operator|=
operator|-
name|i
expr_stmt|;
name|nlines
operator|=
operator|(
operator|(
name|a
operator|-
name|L
operator|)
operator|>>
literal|1
operator|)
operator|&
literal|077777
expr_stmt|;
name|nlines
operator|=
operator|/
literal|5
expr_stmt|;
name|ntext
operator|=
name|nlines
operator|*
literal|8
expr_stmt|;
name|tspace
operator|=
name|lspace
operator|+
name|nlines
expr_stmt|;
name|file
operator|=
literal|"/usr/tmp/stmXaa"
expr_stmt|;
name|loop
label|:
name|filep
operator|=
name|file
expr_stmt|;
while|while
condition|(
operator|*
name|filep
operator|!=
literal|'X'
condition|)
name|filep
operator|++
expr_stmt|;
for|for
control|(
operator|*
name|filep
operator|=
literal|'a'
init|;
condition|;
operator|(
operator|*
name|filep
operator|)
operator|++
control|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
name|lspace
argument_list|)
operator|<
literal|0
condition|)
block|{
name|a
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|filep
operator|==
literal|'z'
condition|)
block|{
if|if
condition|(
name|file
index|[
literal|1
index|]
operator|!=
literal|'t'
condition|)
block|{
name|file
operator|=
literal|"/tmp/stmXaa"
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|mess
argument_list|(
literal|"Cannot locate temp\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|filep
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|signal
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|&
literal|01
operator|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
literal|2
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|nfiles
operator|=
name|eargc
expr_stmt|;
if|if
condition|(
operator|!
name|mflg
condition|)
block|{
name|ibuf
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|sort
argument_list|()
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|a
operator|=
name|mflg
condition|?
literal|0
else|:
name|eargc
init|;
name|a
operator|+
name|N
operator|<
name|nfiles
condition|;
name|a
operator|=
operator|+
name|N
control|)
block|{
name|newfile
argument_list|()
expr_stmt|;
name|merge
argument_list|(
name|a
argument_list|,
name|a
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
name|nfiles
condition|)
block|{
name|oldfile
argument_list|()
expr_stmt|;
name|merge
argument_list|(
name|a
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|sort
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
operator|*
name|lp
operator|,
name|c
expr_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|f
decl_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cp
operator|=
name|tspace
expr_stmt|;
name|lp
operator|=
name|lspace
expr_stmt|;
while|while
condition|(
name|lp
operator|<
name|lspace
operator|+
name|nlines
operator|&&
name|cp
operator|<
name|tspace
operator|+
name|ntext
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|++
operator|=
name|c
operator|=
name|getc
argument_list|(
name|ibuf
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
continue|continue;
name|cp
operator|--
expr_stmt|;
name|close
argument_list|(
name|ibuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|eargc
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|setfil
argument_list|(
name|i
operator|++
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ibuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|fopen
argument_list|(
name|f
argument_list|,
name|ibuf
argument_list|)
operator|<
literal|0
condition|)
name|cant
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|done
operator|++
expr_stmt|;
name|lp
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|qsort
argument_list|(
name|lspace
argument_list|,
name|lp
operator|-
name|lspace
argument_list|,
literal|2
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|==
literal|0
operator|||
name|nfiles
operator|!=
name|eargc
condition|)
name|newfile
argument_list|()
expr_stmt|;
else|else
name|oldfile
argument_list|()
expr_stmt|;
while|while
condition|(
name|lp
operator|>
name|lspace
condition|)
block|{
name|cp
operator|=
operator|*
operator|--
name|lp
expr_stmt|;
do|do
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\n'
condition|)
do|;
block|}
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|obuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|done
operator|==
literal|0
condition|)
do|;
block|}
end_block

begin_struct
struct|struct
name|merg
block|{
name|char
name|l
index|[
name|L
index|]
decl_stmt|;
name|int
name|b
index|[
literal|259
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|merge
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|merg
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
struct|struct
block|{
name|int
modifier|*
name|ip
decl_stmt|;
block|}
struct|;
name|int
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|p
operator|=
name|lspace
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|a
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|setfil
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
name|p
operator|->
name|b
index|[
literal|0
index|]
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fopen
argument_list|(
name|f
argument_list|,
name|p
operator|->
name|b
argument_list|)
operator|<
literal|0
condition|)
name|cant
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|rline
argument_list|(
name|p
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|i
operator|=
name|j
expr_stmt|;
name|qsort
argument_list|(
name|ibuf
argument_list|,
name|i
argument_list|,
literal|2
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
do|do
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|rline
argument_list|(
name|ibuf
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
block|}
name|cp
operator|=
operator|&
name|ibuf
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|cp
operator|.
name|ip
operator|>
name|ibuf
operator|&&
name|cmp
argument_list|(
name|cp
operator|.
name|ip
argument_list|,
name|cp
operator|.
name|ip
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p
operator|=
operator|*
name|cp
operator|.
name|ip
expr_stmt|;
operator|*
name|cp
operator|.
name|ip
operator|=
operator|*
operator|(
name|cp
operator|.
name|ip
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|cp
operator|.
name|ip
operator|-
literal|1
operator|)
operator|=
name|p
expr_stmt|;
block|}
block|}
name|p
operator|=
name|lspace
expr_stmt|;
for|for
control|(
name|i
operator|=
name|a
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
block|{
name|close
argument_list|(
name|p
operator|->
name|b
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|eargc
condition|)
name|close
argument_list|(
name|creat
argument_list|(
name|setfil
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|obuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rline
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|merg
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
operator|*
name|bp
operator|,
name|c
expr_stmt|;
name|bp
operator|=
name|mp
operator|->
name|b
expr_stmt|;
name|cp
operator|=
name|mp
operator|->
name|l
expr_stmt|;
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|newfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|fcreat
argument_list|(
name|setfil
argument_list|(
name|nfiles
argument_list|)
argument_list|,
name|obuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mess
argument_list|(
literal|"Can't create temp\n"
argument_list|)
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
name|nfiles
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|setfil
parameter_list|(
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
name|eargc
condition|)
if|if
condition|(
name|eargv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|eargv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|eargv
index|[
name|i
index|]
operator|)
return|;
name|i
operator|=
operator|-
name|eargc
expr_stmt|;
name|filep
index|[
literal|0
index|]
operator|=
name|i
operator|/
literal|26
operator|+
literal|'a'
expr_stmt|;
name|filep
index|[
literal|1
index|]
operator|=
name|i
operator|%
literal|26
operator|+
literal|'a'
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_macro
name|oldfile
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outfil
condition|)
block|{
if|if
condition|(
name|fcreat
argument_list|(
name|outfil
argument_list|,
name|obuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mess
argument_list|(
literal|"Can't create output\n"
argument_list|)
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|obuf
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|cant
argument_list|(
argument|f
argument_list|)
end_macro

begin_block
block|{
name|mess
argument_list|(
literal|"Can't open "
argument_list|)
expr_stmt|;
name|mess
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|mess
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|term
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|term
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
name|nfiles
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|eargc
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|unlink
argument_list|(
name|setfil
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cmp
argument_list|(
argument|i
argument_list|,
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pa
decl_stmt|,
modifier|*
name|pb
decl_stmt|;
name|char
modifier|*
name|code
decl_stmt|,
modifier|*
name|ignore
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|la
decl_stmt|,
modifier|*
name|lb
decl_stmt|;
specifier|register
name|int
name|sa
decl_stmt|;
name|int
name|sb
decl_stmt|;
name|char
modifier|*
name|ipa
decl_stmt|,
modifier|*
name|ipb
decl_stmt|,
modifier|*
name|jpa
decl_stmt|,
modifier|*
name|jpb
decl_stmt|;
name|struct
name|field
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|k
operator|=
name|nfields
operator|>
literal|0
init|;
name|k
operator|<=
name|nfields
condition|;
name|k
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|fields
index|[
name|k
index|]
expr_stmt|;
name|pa
operator|=
operator|*
name|i
expr_stmt|;
name|pb
operator|=
operator|*
name|j
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|la
operator|=
name|skip
argument_list|(
name|pa
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pa
operator|=
name|skip
argument_list|(
name|pa
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lb
operator|=
name|skip
argument_list|(
name|pb
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pb
operator|=
name|skip
argument_list|(
name|pb
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|la
operator|=
operator|-
literal|1
expr_stmt|;
name|lb
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|nflg
condition|)
block|{
while|while
condition|(
name|blank
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
name|pa
operator|++
expr_stmt|;
while|while
condition|(
name|blank
argument_list|(
operator|*
name|pb
argument_list|)
condition|)
name|pb
operator|++
expr_stmt|;
name|sa
operator|=
name|sb
operator|=
name|fp
operator|->
name|rflg
expr_stmt|;
if|if
condition|(
operator|*
name|pa
operator|==
literal|'-'
condition|)
block|{
name|pa
operator|++
expr_stmt|;
name|sa
operator|=
operator|-
name|sa
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pb
operator|==
literal|'-'
condition|)
block|{
name|pb
operator|++
expr_stmt|;
name|sb
operator|=
operator|-
name|sb
expr_stmt|;
block|}
if|if
condition|(
name|sa
operator|!=
name|sb
condition|)
name|sa
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ipa
operator|=
name|pa
init|;
name|ipa
operator|<
name|la
operator|&&
name|digit
argument_list|(
operator|*
name|ipa
argument_list|)
condition|;
name|ipa
operator|++
control|)
empty_stmt|;
for|for
control|(
name|ipb
operator|=
name|pb
init|;
name|ipb
operator|<
name|lb
operator|&&
name|digit
argument_list|(
operator|*
name|ipb
argument_list|)
condition|;
name|ipb
operator|++
control|)
empty_stmt|;
name|jpa
operator|=
name|ipa
expr_stmt|;
name|jpb
operator|=
name|ipb
expr_stmt|;
name|a
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sa
condition|)
while|while
condition|(
name|ipa
operator|>
name|pa
operator|&&
name|ipb
operator|>
name|pb
condition|)
if|if
condition|(
name|b
operator|=
operator|*
operator|--
name|ipb
operator|-
operator|*
operator|--
name|ipa
condition|)
name|a
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|ipa
operator|>
name|pa
condition|)
if|if
condition|(
operator|*
operator|--
name|ipa
operator|!=
literal|'0'
condition|)
return|return
operator|(
name|sa
condition|?
operator|-
name|sa
else|:
name|sb
operator|)
return|;
while|while
condition|(
name|ipb
operator|>
name|pb
condition|)
if|if
condition|(
operator|*
operator|--
name|ipb
operator|!=
literal|'0'
condition|)
return|return
operator|(
name|sa
condition|?
name|sa
else|:
name|sb
operator|)
return|;
if|if
condition|(
name|a
condition|)
return|return
operator|(
name|a
operator|*
name|sa
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|pa
operator|=
name|jpa
operator|)
operator|==
literal|'.'
condition|)
name|pa
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|pb
operator|=
name|jpb
operator|)
operator|==
literal|'.'
condition|)
name|pb
operator|++
expr_stmt|;
while|while
condition|(
name|pa
operator|<
name|la
operator|&&
name|digit
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
if|if
condition|(
name|pb
operator|<
name|lb
operator|&&
name|digit
argument_list|(
operator|*
name|pb
argument_list|)
condition|)
block|{
if|if
condition|(
name|a
operator|=
operator|*
name|pb
operator|++
operator|-
operator|*
name|pa
operator|++
condition|)
return|return
operator|(
name|sa
condition|?
name|a
operator|*
name|sa
else|:
name|sb
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pa
operator|++
operator|!=
literal|'0'
condition|)
return|return
operator|(
name|sa
condition|?
operator|-
name|sa
else|:
name|sb
operator|)
return|;
while|while
condition|(
name|pb
operator|<
name|lb
operator|&&
name|digit
argument_list|(
operator|*
name|pb
argument_list|)
condition|)
if|if
condition|(
operator|*
name|pb
operator|++
operator|!=
literal|'0'
condition|)
return|return
operator|(
name|sa
condition|?
name|sa
else|:
name|sb
operator|)
return|;
continue|continue;
block|}
name|code
operator|=
name|fp
operator|->
name|code
expr_stmt|;
name|ignore
operator|=
name|fp
operator|->
name|ignore
expr_stmt|;
name|loop
label|:
while|while
condition|(
operator|*
name|pa
operator|<
literal|0
operator|||
name|ignore
index|[
operator|*
name|pa
index|]
condition|)
name|pa
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|pb
operator|<
literal|0
operator|||
name|ignore
index|[
operator|*
name|pb
index|]
condition|)
name|pb
operator|++
expr_stmt|;
if|if
condition|(
name|pa
operator|>=
name|la
operator|||
operator|*
name|pa
operator|==
literal|'\n'
condition|)
if|if
condition|(
name|pb
operator|<
name|lb
operator|&&
operator|*
name|pb
operator|!=
literal|'\n'
condition|)
return|return
operator|(
name|fp
operator|->
name|rflg
operator|)
return|;
else|else
continue|continue;
if|if
condition|(
name|pb
operator|>=
name|lb
operator|||
operator|*
name|pb
operator|==
literal|'\n'
condition|)
return|return
operator|(
operator|-
name|fp
operator|->
name|rflg
operator|)
return|;
if|if
condition|(
operator|(
name|sa
operator|=
name|code
index|[
operator|*
name|pb
operator|++
index|]
operator|-
name|code
index|[
operator|*
name|pa
operator|++
index|]
operator|)
operator|==
literal|0
condition|)
goto|goto
name|loop
goto|;
return|return
operator|(
name|sa
operator|*
name|fp
operator|->
name|rflg
operator|)
return|;
block|}
name|pa
operator|=
operator|*
name|i
expr_stmt|;
name|pb
operator|=
operator|*
name|j
expr_stmt|;
while|while
condition|(
operator|*
name|pa
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|pa
operator|==
operator|*
name|pb
condition|)
block|{
name|pa
operator|++
expr_stmt|;
name|pb
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|pb
operator|==
literal|'\n'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|*
name|pb
operator|-
operator|*
name|pa
operator|)
return|;
block|}
return|return
operator|(
operator|*
name|pb
operator|!=
literal|'\n'
operator|)
return|;
block|}
end_block

begin_macro
name|skip
argument_list|(
argument|pp
argument_list|,
argument|fp
argument_list|,
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|field
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pp
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fp
operator|->
name|m
index|[
name|j
index|]
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tabchar
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
name|tabchar
condition|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
else|else
goto|goto
name|ret
goto|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|blank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|blank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
else|else
goto|goto
name|ret
goto|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|bflg
condition|)
while|while
condition|(
name|blank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|i
operator|=
name|fp
operator|->
name|n
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
else|else
goto|goto
name|ret
goto|;
block|}
name|ret
label|:
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|digit
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|c
operator|<=
literal|'9'
operator|&&
name|c
operator|>=
literal|'0'
operator|)
return|;
block|}
end_block

begin_macro
name|mess
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
name|write
argument_list|(
literal|2
argument_list|,
name|s
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|copyproto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|proto
expr_stmt|;
name|q
operator|=
operator|&
name|fields
index|[
name|nfields
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|proto
argument_list|)
operator|/
literal|2
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|field
argument_list|(
argument|s
argument_list|,
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|field
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|fields
index|[
name|nfields
index|]
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'a'
case|:
name|p
operator|->
name|code
operator|=
name|nofold
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|p
operator|->
name|bflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|p
operator|->
name|ignore
operator|=
name|dict
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|p
operator|->
name|nflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tabchar
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|tabchar
operator|==
literal|0
condition|)
name|s
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|p
operator|->
name|rflg
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|m
index|[
name|k
index|]
operator|=
name|number
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|++
expr_stmt|;
name|p
operator|->
name|n
index|[
name|k
index|]
operator|=
name|number
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|number
argument_list|(
argument|ppa
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ppa
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|pa
decl_stmt|;
name|pa
operator|=
operator|*
name|ppa
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|digit
argument_list|(
operator|*
name|pa
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|pa
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|ppa
operator|=
name|pa
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|blank
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

