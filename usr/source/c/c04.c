begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * C compiler  *  *  */
end_comment

begin_include
include|#
directive|include
file|"c0h.c"
end_include

begin_comment
comment|/*  * Reduce the degree-of-reference by one.  * e.g. turn "ptr-to-int" into "int".  */
end_comment

begin_macro
name|decref
argument_list|(
argument|at
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|t
expr_stmt|;
name|t
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|&
operator|~
name|TYPE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Illegal indirection"
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|t
operator|>>
name|TYLEN
operator|)
operator|&
operator|~
name|TYPE
operator||
name|t
operator|&
name|TYPE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Increase the degree of reference by  * one; e.g. turn "int" to "ptr-to-int".  */
end_comment

begin_macro
name|incref
argument_list|(
argument|t
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
operator|(
name|t
operator|&
operator|~
name|TYPE
operator|)
operator|<<
name|TYLEN
operator|)
operator||
operator|(
name|t
operator|&
name|TYPE
operator|)
operator||
name|PTR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Make a tree that causes a branch to lbl  * if the tree's value is non-zero together with the cond.  */
end_comment

begin_macro
name|cbranch
argument_list|(
argument|tree
argument_list|,
argument|lbl
argument_list|,
argument|cond
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|CBRANCH
argument_list|,
name|tree
argument_list|,
name|lbl
argument_list|,
name|cond
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write out a tree.  */
end_comment

begin_macro
name|rcexpr
argument_list|(
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|treeout
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|EXPR
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|treeout
argument_list|(
argument|atree
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
if|if
condition|(
operator|(
name|tree
operator|=
name|atree
operator|)
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
case|case
literal|0
case|:
name|outcode
argument_list|(
literal|"B"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|NAME
case|:
name|outcode
argument_list|(
literal|"BNN"
argument_list|,
name|NAME
argument_list|,
name|tree
operator|->
name|class
argument_list|,
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|class
operator|==
name|EXTERN
condition|)
name|outcode
argument_list|(
literal|"S"
argument_list|,
name|tree
operator|->
name|nname
argument_list|)
expr_stmt|;
else|else
name|outcode
argument_list|(
literal|"N"
argument_list|,
name|tree
operator|->
name|nloc
argument_list|)
expr_stmt|;
return|return;
case|case
name|CON
case|:
case|case
name|FCON
case|:
case|case
name|SFCON
case|:
name|outcode
argument_list|(
literal|"BNN"
argument_list|,
name|tree
operator|->
name|op
argument_list|,
name|tree
operator|->
name|type
argument_list|,
name|tree
operator|->
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|FSEL
case|:
name|treeout
argument_list|(
name|tree
operator|->
name|tr1
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BNN"
argument_list|,
name|tree
operator|->
name|op
argument_list|,
name|tree
operator|->
name|type
argument_list|,
name|tree
operator|->
name|tr2
argument_list|)
expr_stmt|;
return|return;
case|case
name|CBRANCH
case|:
name|treeout
argument_list|(
name|tree
operator|->
name|btree
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BNN"
argument_list|,
name|tree
operator|->
name|op
argument_list|,
name|tree
operator|->
name|lbl
argument_list|,
name|tree
operator|->
name|cond
argument_list|)
expr_stmt|;
return|return;
default|default:
name|treeout
argument_list|(
name|tree
operator|->
name|tr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|tree
operator|->
name|op
index|]
operator|&
name|BINARY
condition|)
name|treeout
argument_list|(
name|tree
operator|->
name|tr2
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|tree
operator|->
name|op
argument_list|,
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Generate a branch  */
end_comment

begin_macro
name|branch
argument_list|(
argument|lab
argument_list|)
end_macro

begin_block
block|{
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|BRANCH
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate a label  */
end_comment

begin_macro
name|label
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
name|outcode
argument_list|(
literal|"BN"
argument_list|,
name|LABEL
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * ap is a tree node whose type  * is some kind of pointer; return the size of the object  * to which the pointer points.  */
end_comment

begin_macro
name|plength
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tname
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|t
operator|,
name|l
expr_stmt|;
specifier|register
name|struct
name|tname
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
operator|(
operator|(
name|t
operator|=
name|p
operator|->
name|type
operator|)
operator|&
operator|~
name|TYPE
operator|)
operator|==
literal|0
condition|)
comment|/* not a reference */
return|return
operator|(
literal|1
operator|)
return|;
name|p
operator|->
name|type
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|l
operator|=
name|length
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * return the number of bytes in the object  * whose tree node is acs.  */
end_comment

begin_macro
name|length
argument_list|(
argument|acs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|acs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|t
operator|,
name|n
expr_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|acs
expr_stmt|;
name|t
operator|=
name|cs
operator|->
name|type
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|&
name|XTYPE
operator|)
operator|==
name|ARRAY
condition|)
block|{
name|t
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n
operator|=
name|dimtab
index|[
name|cs
operator|->
name|ssp
operator|&
literal|0377
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|&
operator|~
name|TYPE
operator|)
operator|==
name|FUNC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|t
operator|>=
name|PTR
condition|)
return|return
operator|(
literal|2
operator|*
name|n
operator|)
return|;
switch|switch
condition|(
name|t
operator|&
name|TYPE
condition|)
block|{
case|case
name|INT
case|:
return|return
operator|(
literal|2
operator|*
name|n
operator|)
return|;
case|case
name|CHAR
case|:
return|return
operator|(
name|n
operator|)
return|;
case|case
name|FLOAT
case|:
case|case
name|LONG
case|:
return|return
operator|(
literal|4
operator|*
name|n
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
literal|8
operator|*
name|n
operator|)
return|;
case|case
name|STRUCT
case|:
return|return
operator|(
name|n
operator|*
name|dimtab
index|[
name|cs
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|)
return|;
case|case
name|RSTRUCT
case|:
name|error
argument_list|(
literal|"Bad structure"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
argument_list|(
literal|"Compiler error (length)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The number of bytes in an object, rounded up to a word.  */
end_comment

begin_macro
name|rlength
argument_list|(
argument|cs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|cs
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|length
argument_list|(
name|cs
argument_list|)
operator|+
name|ALIGN
operator|)
operator|&
operator|~
name|ALIGN
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * After an "if (...) goto", look to see if the transfer  * is to a simple label.  */
end_comment

begin_macro
name|simplegoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|hshtab
modifier|*
name|csp
decl_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|NAME
operator|&&
name|nextchar
argument_list|()
operator|==
literal|';'
condition|)
block|{
name|csp
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|hclass
operator|==
literal|0
operator|&&
name|csp
operator|->
name|htype
operator|==
literal|0
condition|)
block|{
name|csp
operator|->
name|htype
operator|=
name|ARRAY
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|hoffset
operator|==
literal|0
condition|)
name|csp
operator|->
name|hoffset
operator|=
name|isn
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|csp
operator|->
name|hclass
operator|==
literal|0
operator|||
name|csp
operator|->
name|hclass
operator|==
name|STATIC
operator|)
operator|&&
name|csp
operator|->
name|htype
operator|==
name|ARRAY
condition|)
block|{
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|csp
operator|->
name|hoffset
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the next non-white-space character  */
end_comment

begin_macro
name|nextchar
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|spnextchar
argument_list|()
operator|==
literal|' '
condition|)
name|peekc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|peekc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the next character, translating all white space  * to blank and handling line-ends.  */
end_comment

begin_macro
name|spnextchar
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|peekc
operator|)
operator|==
literal|0
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|inhdr
operator|==
literal|0
condition|)
name|line
operator|++
expr_stmt|;
name|inhdr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\001'
condition|)
block|{
comment|/* SOH, insert marker */
name|inhdr
operator|++
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
name|peekc
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * is a break or continue legal?  */
end_comment

begin_macro
name|chconbrk
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Break/continue error"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The goto statement.  */
end_comment

begin_macro
name|dogoto
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|np
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tree
argument_list|()
expr_stmt|;
name|build
argument_list|(
name|STAR
argument_list|)
expr_stmt|;
name|chkw
argument_list|(
name|np
operator|=
operator|*
operator|--
name|cp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|JUMP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The return statement, which has to convert  * the returned object to the function's type.  */
end_comment

begin_macro
name|doret
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|nextchar
argument_list|()
operator|!=
literal|';'
condition|)
block|{
name|t
operator|=
name|tree
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|&
name|funcblk
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|t
expr_stmt|;
name|build
argument_list|(
name|ASSIGN
argument_list|)
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
name|cp
index|[
operator|-
literal|1
index|]
operator|->
name|tr2
expr_stmt|;
name|build
argument_list|(
name|RFORCE
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
expr_stmt|;
block|}
name|branch
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * write out a character to the usual output  * or to the string file  */
end_comment

begin_macro
name|putchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|write
argument_list|(
literal|1
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|outcode
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
operator|*
name|ap
operator|,
operator|*
name|bufp
expr_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
name|bufp
operator|=
name|obuf
expr_stmt|;
if|if
condition|(
name|strflg
condition|)
name|bufp
operator|=
name|sbuf
expr_stmt|;
name|ap
operator|=
operator|&
name|a
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'B'
case|:
name|putw
argument_list|(
operator|*
name|ap
operator|++
operator||
operator|(
literal|0376
operator|<<
literal|8
operator|)
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'N'
case|:
name|putw
argument_list|(
operator|*
name|ap
operator|++
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
name|np
operator|=
operator|*
name|ap
operator|++
expr_stmt|;
name|n
operator|=
name|ncps
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|*
name|np
condition|)
block|{
name|putc
argument_list|(
operator|*
name|np
operator|++
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|0
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
name|putw
argument_list|(
literal|1
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
name|putw
argument_list|(
literal|0
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
return|return;
block|}
name|error
argument_list|(
literal|"Botch in outcode"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

