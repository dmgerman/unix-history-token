begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"r.h"
end_include

begin_decl_stmt
name|char
name|scrat
index|[
literal|500
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|brkptr
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|brkstk
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|forptr
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|forstk
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|repcode
argument_list|()
end_macro

begin_block
block|{
name|outcont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|genlab
argument_list|()
expr_stmt|;
name|outcont
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
operator|+
literal|1
expr_stmt|;
name|genlab
argument_list|()
expr_stmt|;
name|genlab
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|untils
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outnum
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"\tif(.not."
argument_list|)
expr_stmt|;
name|balpar
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|outgoto
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|outcont
argument_list|(
name|p1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|ifcode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outcode
argument_list|(
literal|"\tif(.not."
argument_list|)
expr_stmt|;
name|balpar
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|outgoto
argument_list|(
name|yyval
operator|=
name|genlab
argument_list|()
argument_list|)
expr_stmt|;
name|genlab
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|whilecode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outcont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
operator|=
name|genlab
argument_list|()
expr_stmt|;
name|genlab
argument_list|()
expr_stmt|;
name|outnum
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"\tif(.not."
argument_list|)
expr_stmt|;
name|balpar
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|outgoto
argument_list|(
name|yyval
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|whilestat
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outgoto
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|outcont
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|balpar
argument_list|(
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|lpar
decl_stmt|;
specifier|extern
name|int
name|peek
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|peek
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
block|{
name|error
argument_list|(
literal|"missing left paren"
argument_list|)
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
for|for
control|(
name|lpar
operator|=
name|i
operator|=
literal|0
init|;
operator|(
name|bp
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
while|while
condition|(
operator|(
name|bp
index|[
name|i
operator|++
index|]
operator|=
name|getc
argument_list|()
operator|)
operator|!=
name|c
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|>=
literal|499
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
condition|)
block|{
name|error
argument_list|(
literal|"missing right parenthesis at %.20s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|lpar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|lpar
operator|--
expr_stmt|;
if|if
condition|(
name|lpar
operator|==
literal|0
condition|)
break|break;
block|}
name|bp
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|int
name|labval
literal|23000
expr_stmt|;
end_expr_stmt

begin_macro
name|genlab
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
operator|++
name|labval
operator|)
return|;
block|}
end_block

begin_macro
name|gokcode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outcode
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|eatup
argument_list|(
name|p1
argument_list|,
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eatup
argument_list|(
argument|p1
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|peek
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|lnb
decl_stmt|,
name|lpar
decl_stmt|;
name|lnb
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p1
operator|++
condition|)
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
name|lnb
operator|=
name|c
expr_stmt|;
name|i
operator|=
name|lpar
operator|=
literal|0
expr_stmt|;
name|more
label|:
for|for
control|(
init|;
operator|(
name|bp
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'}'
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|>=
literal|499
condition|)
block|{
name|error
argument_list|(
literal|"statement too long at %.20s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
name|lnb
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
while|while
condition|(
operator|(
name|bp
index|[
name|i
operator|++
index|]
operator|=
name|getc
argument_list|()
operator|)
operator|!=
name|c
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|lpar
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|lpar
operator|--
expr_stmt|;
if|if
condition|(
name|lpar
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"missing left paren at %.20s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|lnb
operator|==
literal|'\n'
operator|||
name|lnb
operator|==
literal|'+'
operator|||
name|lnb
operator|==
literal|'-'
operator|||
name|lnb
operator|==
literal|'*'
operator|||
name|lnb
operator|==
literal|'('
operator|||
name|lnb
operator|==
literal|'/'
operator|||
name|lnb
operator|==
literal|','
operator|||
name|lnb
operator|==
literal|'&'
operator|||
name|lnb
operator|==
literal|'|'
operator|||
name|lnb
operator|==
literal|'='
condition|)
goto|goto
name|more
goto|;
name|c
operator|=
literal|';'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|';'
condition|)
name|peek
operator|=
name|c
expr_stmt|;
name|bp
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lpar
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"missing right paren at %.20s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_block

begin_macro
name|forcode
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|peek
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|getvec
argument_list|()
decl_stmt|;
name|outcont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|balpar
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|genlab
argument_list|()
expr_stmt|;
name|genlab
argument_list|()
expr_stmt|;
name|genlab
argument_list|()
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|scrat
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|forstk
index|[
name|forptr
operator|++
index|]
operator|=
name|bp
operator|=
name|getvec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|scrat
index|[
literal|0
index|]
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|c
operator|=
name|scrat
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|;
control|)
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
while|while
condition|(
name|scrat
index|[
name|i
operator|++
index|]
operator|!=
name|c
condition|)
empty_stmt|;
name|scrat
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nonblank
argument_list|(
name|scrat
argument_list|)
condition|)
block|{
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|i
init|;
operator|(
name|c
operator|=
name|scrat
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|;
control|)
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
while|while
condition|(
name|scrat
index|[
name|i
operator|++
index|]
operator|!=
name|c
condition|)
empty_stmt|;
name|scrat
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nonblank
argument_list|(
operator|&
name|scrat
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|outnum
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"\tif(.not.("
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
operator|&
name|scrat
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"))"
argument_list|)
expr_stmt|;
name|outgoto
argument_list|(
name|yyval
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|outcont
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|scrat
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|;
control|)
name|scrat
index|[
name|j
operator|++
index|]
operator|=
name|scrat
index|[
name|i
operator|++
index|]
expr_stmt|;
name|scrat
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|forstk
index|[
name|forptr
operator|++
index|]
operator|=
name|bp
operator|=
name|getvec
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|bp
operator|++
operator|=
name|scrat
index|[
name|i
operator|++
index|]
condition|;
control|)
empty_stmt|;
block|}
end_block

begin_macro
name|forstat
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bp
operator|=
name|forstk
index|[
operator|--
name|forptr
index|]
expr_stmt|;
name|outnum
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonblank
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|outcode
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|outgoto
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|outcont
argument_list|(
name|p1
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|bp
init|;
operator|*
name|q
operator|++
condition|;
control|)
empty_stmt|;
name|relvec
argument_list|(
name|bp
argument_list|,
name|q
operator|-
name|bp
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|docode
argument_list|(
argument|new
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outcode
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|eatup
argument_list|(
name|p1
argument_list|,
name|scrat
argument_list|)
expr_stmt|;
name|yyval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|yyval
operator|=
name|genlab
argument_list|()
expr_stmt|;
name|genlab
argument_list|()
expr_stmt|;
name|brkstk
index|[
operator|++
name|brkptr
index|]
operator|=
name|yyval
expr_stmt|;
name|outnum
argument_list|(
name|yyval
argument_list|)
expr_stmt|;
block|}
name|outcode
argument_list|(
name|scrat
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dostat
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p1
operator|==
literal|0
condition|)
return|return;
name|outcont
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|outcont
argument_list|(
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|brkptr
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|breakcode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|brkptr
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"illegal BREAK"
argument_list|)
expr_stmt|;
return|return;
block|}
name|outgoto
argument_list|(
name|brkstk
index|[
name|brkptr
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nextcode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|brkptr
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"illegal NEXT"
argument_list|)
expr_stmt|;
return|return;
block|}
name|outgoto
argument_list|(
name|brkstk
index|[
name|brkptr
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nonblank
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|linect
index|[]
decl_stmt|,
name|ninclude
decl_stmt|,
name|infile
decl_stmt|;
name|printf
argument_list|(
literal|2
argument_list|,
literal|"error at line %d, file %d: "
argument_list|,
name|linect
index|[
name|ninclude
index|]
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|2
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errorflag
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|errcode
argument_list|(
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
specifier|extern
name|int
name|yychar
decl_stmt|;
specifier|extern
name|int
name|linect
index|[]
decl_stmt|,
name|ninclude
decl_stmt|,
name|infile
decl_stmt|;
name|printf
argument_list|(
literal|2
argument_list|,
literal|"\nsyntax error, line %d, file %d\n"
argument_list|,
name|linect
index|[
name|ninclude
index|]
argument_list|,
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
name|errorflag
operator|=
literal|1
expr_stmt|;
block|}
end_block

end_unit

