begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|VERSION
value|"3.00 4-19-89"
end_define

begin_define
define|#
directive|define
name|PUBDIR
value|"/usr/spool/uucppublic"
end_define

begin_comment
comment|/*% cc -compat -M2 -Ox -K -i -DMD % -o rz; size rz;<-xtx-*> cc386 -Ox -DMD rz.c -o $B/rz;  size $B/rz  *  * rz.c By Chuck Forsberg  *  *	cc -O rz.c -o rz		USG (3.0) Unix  * 	cc -O -DV7  rz.c -o rz		Unix V7, BSD 2.8 - 4.3  *  *	ln rz rb;  ln rz rx			For either system  *  *	ln rz /usr/bin/rzrmail		For remote mail.  Make this the  *					login shell. rzrmail then calls  *					rmail(1) to deliver mail.  *  * To compile on VMS:  *  *	define LNK$LIBRARY   SYS$LIBRARY:VAXCRTL.OLB  *	cc rz.c  *	cc vvmodem.c  *	link rz,vvmodem  *	rz :== $disk:[username.subdir]rz.exe  *      For high speed, try increasing the SYSGEN parameter TTY_TYPAHDSZ to 256.  *  *  *  Unix is a trademark of Western Electric Company  *  * A program for Unix to receive files and commands from computers running  *  Professional-YAM, PowerCom, YAM, IMP, or programs supporting XMODEM.  *  rz uses Unix buffered input to reduce wasted CPU time.  *  *	This version implements ZMODEM Run Length Encoding   *	and variable length headers.  These features were not funded  *	by the original Telenet development contract.  This software,  *	including these features, may be freely used for non  *	commercial and educational purposes.  This software may also  *	be freely used to support file transfer operations to or from  *	licensed Omen Technology products.  Contact Omen Technology  *	for licensing for other uses.  Any programs which use part or  *	all of this software must be provided in source form with this  *	notice intact except by written permission from Omen  *	Technology Incorporated.  *  *		Omen Technology Inc		FAX: 503-621-3745  *		Post Office Box 4681  *		Portland OR 97208  *  *	Previous versions of this program (not containing the extensions  *	listed above) remain in the public domain.  *  *	This code is made available in the hope it will be useful,  *	BUT WITHOUT ANY WARRANTY OF ANY KIND OR LIABILITY FOR ANY  *	DAMAGES OF ANY KIND.  *  *  * Iff the program is invoked by rzCOMMAND, output is piped to   * "COMMAND filename"  (Unix only)  *  *  Some systems (Venix, Coherent, Regulus) may not support tty raw mode  *  read(2) the same way as Unix. ONEREAD must be defined to force one  *  character reads for these systems. Added 7-01-84 CAF  *  *  Alarm signal handling changed to work with 4.2 BSD 7-15-84 CAF   *  *  BIX added 6-30-87 to support BIX(TM) upload protocol used by the  *  Byte Information Exchange.  *  *  NFGVMIN Updated 2-18-87 CAF for Xenix systems where c_cc[VMIN]  *  doesn't work properly (even though it compiles without error!),  *  *  SEGMENTS=n added 2-21-88 as a model for CP/M programs  *    for CP/M-80 systems that cannot overlap modem and disk I/O.  *  *  VMS flavor hacks begin with rz version 2.00  *  *  -DMD may be added to compiler command line to compile in  *    Directory-creating routines from Public Domain TAR by John Gilmore  *  *  HOWMANY may be tuned for best performance  *  *  USG UNIX (3.0) ioctl conventions courtesy  Jeff Martin  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_include
include|#
directive|include
file|<types.h>
end_include

begin_include
include|#
directive|include
file|<stat.h>
end_include

begin_define
define|#
directive|define
name|LOGFILE
value|"rzlog.tmp"
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|OS
value|"VMS"
end_define

begin_define
define|#
directive|define
name|BUFREAD
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SS_NORMAL
value|SS$_NORMAL
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PROGNAME
end_ifndef

begin_define
define|#
directive|define
name|PROGNAME
value|"rz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SS_NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|LOGFILE
value|"/tmp/rzlog"
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OK
value|0
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|ERROR
value|(-1)
end_define

begin_comment
comment|/*  * Max value for HOWMANY is 255.  *   A larger value reduces system overhead but may evoke kernel bugs.  *   133 corresponds to an XMODEM/CRC sector  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HOWMANY
end_ifndef

begin_define
define|#
directive|define
name|HOWMANY
value|133
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Ward Christensen / CP/M parameters - Don't change these! */
end_comment

begin_define
define|#
directive|define
name|ENQ
value|005
end_define

begin_define
define|#
directive|define
name|CAN
value|('X'&037)
end_define

begin_define
define|#
directive|define
name|XOFF
value|('s'&037)
end_define

begin_define
define|#
directive|define
name|XON
value|('q'&037)
end_define

begin_define
define|#
directive|define
name|SOH
value|1
end_define

begin_define
define|#
directive|define
name|STX
value|2
end_define

begin_define
define|#
directive|define
name|EOT
value|4
end_define

begin_define
define|#
directive|define
name|ACK
value|6
end_define

begin_define
define|#
directive|define
name|NAK
value|025
end_define

begin_define
define|#
directive|define
name|CPMEOF
value|032
end_define

begin_define
define|#
directive|define
name|WANTCRC
value|0103
end_define

begin_comment
comment|/* send C not NAK to get crc not checksum */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT
value|(-2)
end_define

begin_define
define|#
directive|define
name|RCDO
value|(-3)
end_define

begin_define
define|#
directive|define
name|GCOUNT
value|(-4)
end_define

begin_define
define|#
directive|define
name|ERRORMAX
value|5
end_define

begin_define
define|#
directive|define
name|RETRYMAX
value|5
end_define

begin_define
define|#
directive|define
name|WCEOT
value|(-10)
end_define

begin_define
define|#
directive|define
name|PATHLEN
value|257
end_define

begin_comment
comment|/* ready for 4.2 bsd ? */
end_comment

begin_define
define|#
directive|define
name|UNIXFILE
value|0xF000
end_define

begin_comment
comment|/* The S_IFMT file mask bit for stat */
end_comment

begin_decl_stmt
name|int
name|Zmodem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ZMODEM protocol requested */
end_comment

begin_decl_stmt
name|int
name|Nozmodem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If invoked as "rb" */
end_comment

begin_decl_stmt
name|unsigned
name|Baudrate
init|=
literal|2400
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|Effbaud
init|=
literal|2400
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|vax11c
end_ifdef

begin_include
include|#
directive|include
file|"vrzsz.c"
end_include

begin_comment
comment|/* most of the system dependent stuff here */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"rbsb.c"
end_include

begin_comment
comment|/* most of the system dependent stuff here */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"crctab.c"
end_include

begin_function_decl
name|char
modifier|*
name|substr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|fout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Routine to calculate the free bytes on the current file system  *  ~0 means many free bytes (unknown)  */
end_comment

begin_function
name|long
name|getfree
parameter_list|()
block|{
return|return
operator|(
operator|~
literal|0L
operator|)
return|;
comment|/* many free bytes ... */
block|}
end_function

begin_decl_stmt
name|int
name|Lastrx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Crcflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Firstsec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Eofseen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates cpm eof (^Z) has been received */
end_comment

begin_decl_stmt
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Restricted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* restricted; no /.. or ../ in filenames */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ONEREAD
end_ifdef

begin_comment
comment|/* Sorry, Regulus and some others don't work right in raw mode! */
end_comment

begin_decl_stmt
name|int
name|Readnum
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes to ask for in read() from modem */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|Readnum
init|=
name|HOWMANY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes to ask for in read() from modem */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFBYTL
value|2000000000L
end_define

begin_comment
comment|/* default rx file size */
end_comment

begin_decl_stmt
name|long
name|Bytesleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes of incoming file left */
end_comment

begin_decl_stmt
name|long
name|Modtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unix style mod time for incoming file */
end_comment

begin_decl_stmt
name|int
name|Filemode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unix style mode for incoming file */
end_comment

begin_decl_stmt
name|char
name|Pathname
index|[
name|PATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the name by which we were called */
end_comment

begin_decl_stmt
name|int
name|Batch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Topipe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|MakeLCPathname
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make received pathname lower case */
end_comment

begin_decl_stmt
name|int
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* overrides logic that would otherwise set verbose */
end_comment

begin_decl_stmt
name|int
name|Nflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't really transfer files */
end_comment

begin_decl_stmt
name|int
name|Rxclob
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clobber existing file */
end_comment

begin_decl_stmt
name|int
name|Rxbinary
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receive all files in bin mode */
end_comment

begin_decl_stmt
name|int
name|Rxascii
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receive files in ascii (translate) mode */
end_comment

begin_decl_stmt
name|int
name|Thisbinary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file is to be received in bin mode */
end_comment

begin_decl_stmt
name|int
name|Blklen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* record length of received packets */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SEGMENTS
end_ifdef

begin_decl_stmt
name|int
name|chinseg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters received in this data seg */
end_comment

begin_decl_stmt
name|char
name|secbuf
index|[
literal|1
operator|+
operator|(
name|SEGMENTS
operator|+
literal|1
operator|)
operator|*
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|secbuf
index|[
literal|1025
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|linbuf
index|[
name|HOWMANY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Lleft
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters in linbuf */
end_comment

begin_decl_stmt
name|time_t
name|timep
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Lzmanag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local file management request */
end_comment

begin_decl_stmt
name|char
name|zconv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ZMODEM file conversion request */
end_comment

begin_decl_stmt
name|char
name|zmanag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ZMODEM file management request */
end_comment

begin_decl_stmt
name|char
name|ztrans
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ZMODEM file transport request */
end_comment

begin_decl_stmt
name|int
name|Zctlesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Encode control characters */
end_comment

begin_decl_stmt
name|int
name|Zrwindow
init|=
literal|1400
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RX window size (controls garbage count) */
end_comment

begin_decl_stmt
name|jmp_buf
name|tohere
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For the interrupt on RX timeout */
end_comment

begin_define
define|#
directive|define
name|xsendline
parameter_list|(
name|c
parameter_list|)
value|sendline(c)
end_define

begin_include
include|#
directive|include
file|"zm.c"
end_include

begin_include
include|#
directive|include
file|"zmr.c"
end_include

begin_decl_stmt
name|int
name|tryzhdrtype
init|=
name|ZRINIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Header type to send corresponding to Last rx close */
end_comment

begin_function
name|void
name|alrm
parameter_list|()
block|{
name|longjmp
argument_list|(
name|tohere
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called by signal interrupt or terminate to clean things up */
end_comment

begin_function
name|SIGTYPE
name|bibi
parameter_list|(
name|n
parameter_list|)
block|{
if|if
condition|(
name|Zmodem
condition|)
name|zmputs
argument_list|(
name|Attn
argument_list|)
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rz: caught signal %d; exiting"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cucheck
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|128
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|npats
expr_stmt|;
name|char
modifier|*
name|virgin
decl_stmt|,
modifier|*
modifier|*
name|patts
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|exitcode
decl_stmt|;
name|Rxtimeout
operator|=
literal|100
expr_stmt|;
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|&&
operator|(
name|substr
argument_list|(
name|cp
argument_list|,
literal|"rsh"
argument_list|)
operator|||
name|substr
argument_list|(
name|cp
argument_list|,
literal|"rksh"
argument_list|)
operator|)
condition|)
name|Restricted
operator|=
name|TRUE
expr_stmt|;
name|from_cu
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|vax11c
name|chkinvok
argument_list|(
name|virgin
operator|=
name|PROGNAME
argument_list|)
expr_stmt|;
else|#
directive|else
name|chkinvok
argument_list|(
name|virgin
operator|=
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* if called as [-]rzCOMMAND set flag */
endif|#
directive|endif
name|npats
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|argc
condition|)
block|{
name|cp
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'\\'
case|:
name|cp
index|[
literal|1
index|]
operator|=
name|toupper
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
name|Lzmanag
operator|=
name|ZMAPND
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|Rxascii
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|Rxbinary
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|Crcflg
operator|=
name|TRUE
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|vax11c
case|case
literal|'D'
case|:
name|Nflag
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'e'
case|:
name|Zctlesc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|Lzmanag
operator|=
name|ZMPROT
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|Quiet
operator|=
name|TRUE
expr_stmt|;
name|Verbose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|Rxtimeout
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|Rxtimeout
operator|<
literal|10
operator|||
name|Rxtimeout
operator|>
literal|1000
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|Zrwindow
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|MakeLCPathname
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|Verbose
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|Rxclob
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|npats
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
name|npats
operator|=
name|argc
expr_stmt|;
name|patts
operator|=
name|argv
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|npats
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|Batch
operator|&&
name|npats
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
name|LOGFILE
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Can't open log file %s\n"
argument_list|,
name|LOGFILE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0200
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argv[0]=%s Progname=%s\n"
argument_list|,
name|virgin
argument_list|,
name|Progname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Fromcu
operator|&&
operator|!
name|Quiet
condition|)
block|{
if|if
condition|(
name|Verbose
operator|==
literal|0
condition|)
name|Verbose
operator|=
literal|2
expr_stmt|;
block|}
name|vfile
argument_list|(
literal|"%s %s for %s\n"
argument_list|,
name|Progname
argument_list|,
name|VERSION
argument_list|,
name|OS
argument_list|)
expr_stmt|;
name|mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|bibi
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGKILL
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|bibi
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGKILL
argument_list|,
name|bibi
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|bibi
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcreceive
argument_list|(
name|npats
argument_list|,
name|patts
argument_list|)
operator|==
name|ERROR
condition|)
block|{
name|exitcode
operator|=
literal|0200
expr_stmt|;
name|canit
argument_list|()
expr_stmt|;
block|}
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitcode
operator|&&
operator|!
name|Zmodem
condition|)
comment|/* bellow again with all thy might. */
name|canit
argument_list|()
expr_stmt|;
if|if
condition|(
name|exitcode
condition|)
name|cucheck
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|exitcode
condition|?
name|exitcode
else|:
name|SS_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|cucheck
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:	rz [-abeuvy]		(ZMODEM)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"or	rb [-abuvy]		(YMODEM)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"or	rx [-abcv] file	(XMODEM or XMODEM-1k)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	  -a ASCII transfer (strip CR)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	  -b Binary transfer for all files\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	  -c Use 16 bit CRC	(XMODEM)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	  -e Escape control characters	(ZMODEM)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	  -v Verbose more v's give more info\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	  -y Yes, clobber existing file if any\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s for %s by Chuck Forsberg, Omen Technology INC\n"
argument_list|,
name|Progname
argument_list|,
name|VERSION
argument_list|,
name|OS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\042The High Reliability Software\042\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SS_NORMAL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  Debugging information output interface routine  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_expr_stmt
name|vfile
argument_list|(
name|f
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
specifier|register
name|char
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|Verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Let's receive something already.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rbmsg
init|=
literal|"%s ready. To begin transfer, type \"%s file ...\" to your modem program\r\n\n"
decl_stmt|;
end_decl_stmt

begin_macro
name|wcreceive
argument_list|(
argument|argc
argument_list|,
argument|argp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|Batch
operator|||
name|argc
operator|==
literal|0
condition|)
block|{
name|Crcflg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|Quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|rbmsg
argument_list|,
name|Progname
argument_list|,
name|Nozmodem
condition|?
literal|"sb"
else|:
literal|"sz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|tryz
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ZCOMPL
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|c
operator|==
name|ERROR
condition|)
goto|goto
name|fubar
goto|;
name|c
operator|=
name|rzfiles
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
condition|)
goto|goto
name|fubar
goto|;
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|wcrxpn
argument_list|(
name|secbuf
argument_list|)
operator|==
name|ERROR
condition|)
goto|goto
name|fubar
goto|;
if|if
condition|(
name|secbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|procheader
argument_list|(
name|secbuf
argument_list|)
operator|==
name|ERROR
condition|)
goto|goto
name|fubar
goto|;
if|if
condition|(
name|wcrx
argument_list|()
operator|==
name|ERROR
condition|)
goto|goto
name|fubar
goto|;
block|}
block|}
block|}
else|else
block|{
name|Bytesleft
operator|=
name|DEFBYTL
expr_stmt|;
name|Filemode
operator|=
literal|0
expr_stmt|;
name|Modtime
operator|=
literal|0L
expr_stmt|;
name|procheader
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Pathname
argument_list|,
operator|*
name|argp
argument_list|)
expr_stmt|;
name|checkpath
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nrz: ready to receive %s\r\n"
argument_list|,
name|Pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fout
operator|=
name|fopen
argument_list|(
name|Pathname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERROR
return|;
if|if
condition|(
name|wcrx
argument_list|()
operator|==
name|ERROR
condition|)
goto|goto
name|fubar
goto|;
block|}
return|return
name|OK
return|;
name|fubar
label|:
name|canit
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
name|Topipe
operator|&&
name|fout
condition|)
block|{
name|pclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
endif|#
directive|endif
name|Modtime
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fout
condition|)
name|fclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
name|Restricted
condition|)
block|{
name|unlink
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nrz: %s removed.\r\n"
argument_list|,
name|Pathname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ERROR
return|;
block|}
end_block

begin_comment
comment|/*  * Fetch a pathname from the other end as a C ctyle ASCIZ string.  * Length is indeterminate as long as less than Blklen  * A null string represents no more files (YMODEM)  */
end_comment

begin_macro
name|wcrxpn
argument_list|(
argument|rpn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|rpn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receive a pathname */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|NFGVMIN
name|readline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|purgeline
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|et_tu
label|:
name|Firstsec
operator|=
name|TRUE
expr_stmt|;
name|Eofseen
operator|=
name|FALSE
expr_stmt|;
name|sendline
argument_list|(
name|Crcflg
condition|?
name|WANTCRC
else|:
name|NAK
argument_list|)
expr_stmt|;
name|Lleft
operator|=
literal|0
expr_stmt|;
comment|/* Do read next time ... */
while|while
condition|(
operator|(
name|c
operator|=
name|wcgetsec
argument_list|(
name|rpn
argument_list|,
literal|100
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|WCEOT
condition|)
block|{
name|zperr
argument_list|(
literal|"Pathname fetch returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|ACK
argument_list|)
expr_stmt|;
name|Lleft
operator|=
literal|0
expr_stmt|;
comment|/* Do read next time ... */
name|readline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|et_tu
goto|;
block|}
return|return
name|ERROR
return|;
block|}
name|sendline
argument_list|(
name|ACK
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*  * Adapted from CMODEM13.C, written by  * Jack M. Wierda and Roderick W. Hart  */
end_comment

begin_macro
name|wcrx
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|sectnum
decl_stmt|,
name|sectcurr
decl_stmt|;
specifier|register
name|char
name|sendchar
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|cblklen
decl_stmt|;
comment|/* bytes to dump this block */
name|Firstsec
operator|=
name|TRUE
expr_stmt|;
name|sectnum
operator|=
literal|0
expr_stmt|;
name|Eofseen
operator|=
name|FALSE
expr_stmt|;
name|sendchar
operator|=
name|Crcflg
condition|?
name|WANTCRC
else|:
name|NAK
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sendline
argument_list|(
name|sendchar
argument_list|)
expr_stmt|;
comment|/* send it now, we're ready! */
name|Lleft
operator|=
literal|0
expr_stmt|;
comment|/* Do read next time ... */
name|sectcurr
operator|=
name|wcgetsec
argument_list|(
name|secbuf
argument_list|,
operator|(
name|sectnum
operator|&
literal|0177
operator|)
condition|?
literal|50
else|:
literal|130
argument_list|)
expr_stmt|;
name|report
argument_list|(
name|sectcurr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectcurr
operator|==
operator|(
name|sectnum
operator|+
literal|1
operator|&
literal|0377
operator|)
condition|)
block|{
name|sectnum
operator|++
expr_stmt|;
name|cblklen
operator|=
name|Bytesleft
operator|>
name|Blklen
condition|?
name|Blklen
else|:
name|Bytesleft
expr_stmt|;
if|if
condition|(
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|cblklen
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|ERROR
return|;
if|if
condition|(
operator|(
name|Bytesleft
operator|-=
name|cblklen
operator|)
operator|<
literal|0
condition|)
name|Bytesleft
operator|=
literal|0
expr_stmt|;
name|sendchar
operator|=
name|ACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sectcurr
operator|==
operator|(
name|sectnum
operator|&
literal|0377
operator|)
condition|)
block|{
name|zperr
argument_list|(
literal|"Received dup Sector"
argument_list|)
expr_stmt|;
name|sendchar
operator|=
name|ACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sectcurr
operator|==
name|WCEOT
condition|)
block|{
if|if
condition|(
name|closeit
argument_list|()
condition|)
return|return
name|ERROR
return|;
name|sendline
argument_list|(
name|ACK
argument_list|)
expr_stmt|;
name|Lleft
operator|=
literal|0
expr_stmt|;
comment|/* Do read next time ... */
return|return
name|OK
return|;
block|}
elseif|else
if|if
condition|(
name|sectcurr
operator|==
name|ERROR
condition|)
return|return
name|ERROR
return|;
else|else
block|{
name|zperr
argument_list|(
literal|"Sync Error"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Wcgetsec fetches a Ward Christensen type sector.  * Returns sector number encountered or ERROR if valid sector not received,  * or CAN CAN received  * or WCEOT if eot sector  * time is timeout for first char, set to 4 seconds thereafter  ***************** NO ACK IS SENT IF SECTOR IS RECEIVED OK **************  *    (Caller must do that when he is good and ready to get next sector)  */
end_comment

begin_macro
name|wcgetsec
argument_list|(
argument|rxbuf
argument_list|,
argument|maxtime
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|rxbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxtime
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|checksum
operator|,
name|wcj
operator|,
name|firstch
expr_stmt|;
specifier|register
name|unsigned
name|short
name|oldcrc
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|sectcurr
decl_stmt|;
for|for
control|(
name|Lastrx
operator|=
name|errors
operator|=
literal|0
init|;
name|errors
operator|<
name|RETRYMAX
condition|;
name|errors
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|firstch
operator|=
name|readline
argument_list|(
name|maxtime
argument_list|)
operator|)
operator|==
name|STX
condition|)
block|{
name|Blklen
operator|=
literal|1024
expr_stmt|;
goto|goto
name|get2
goto|;
block|}
if|if
condition|(
name|firstch
operator|==
name|SOH
condition|)
block|{
name|Blklen
operator|=
literal|128
expr_stmt|;
name|get2
label|:
name|sectcurr
operator|=
name|readline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sectcurr
operator|+
operator|(
name|oldcrc
operator|=
name|readline
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|==
literal|0377
condition|)
block|{
name|oldcrc
operator|=
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|rxbuf
operator|,
name|wcj
operator|=
name|Blklen
init|;
operator|--
name|wcj
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|firstch
operator|=
name|readline
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bilge
goto|;
name|oldcrc
operator|=
name|updcrc
argument_list|(
name|firstch
argument_list|,
name|oldcrc
argument_list|)
expr_stmt|;
name|checksum
operator|+=
operator|(
operator|*
name|p
operator|++
operator|=
name|firstch
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|firstch
operator|=
name|readline
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bilge
goto|;
if|if
condition|(
name|Crcflg
condition|)
block|{
name|oldcrc
operator|=
name|updcrc
argument_list|(
name|firstch
argument_list|,
name|oldcrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|firstch
operator|=
name|readline
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bilge
goto|;
name|oldcrc
operator|=
name|updcrc
argument_list|(
name|firstch
argument_list|,
name|oldcrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcrc
operator|&
literal|0xFFFF
condition|)
name|zperr
argument_list|(
literal|"CRC"
argument_list|)
expr_stmt|;
else|else
block|{
name|Firstsec
operator|=
name|FALSE
expr_stmt|;
return|return
name|sectcurr
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|checksum
operator|-
name|firstch
operator|)
operator|&
literal|0377
operator|)
operator|==
literal|0
condition|)
block|{
name|Firstsec
operator|=
name|FALSE
expr_stmt|;
return|return
name|sectcurr
return|;
block|}
else|else
name|zperr
argument_list|(
literal|"Checksum"
argument_list|)
expr_stmt|;
block|}
else|else
name|zperr
argument_list|(
literal|"Sector number garbled"
argument_list|)
expr_stmt|;
block|}
comment|/* make sure eot really is eot and not just mixmash */
ifdef|#
directive|ifdef
name|NFGVMIN
elseif|else
if|if
condition|(
name|firstch
operator|==
name|EOT
operator|&&
name|readline
argument_list|(
literal|1
argument_list|)
operator|==
name|TIMEOUT
condition|)
return|return
name|WCEOT
return|;
else|#
directive|else
elseif|else
if|if
condition|(
name|firstch
operator|==
name|EOT
operator|&&
name|Lleft
operator|==
literal|0
condition|)
return|return
name|WCEOT
return|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|firstch
operator|==
name|CAN
condition|)
block|{
if|if
condition|(
name|Lastrx
operator|==
name|CAN
condition|)
block|{
name|zperr
argument_list|(
literal|"Sender CANcelled"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
else|else
block|{
name|Lastrx
operator|=
name|CAN
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|firstch
operator|==
name|TIMEOUT
condition|)
block|{
if|if
condition|(
name|Firstsec
condition|)
goto|goto
name|humbug
goto|;
name|bilge
label|:
name|zperr
argument_list|(
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
block|}
else|else
name|zperr
argument_list|(
literal|"Got 0%o sector header"
argument_list|,
name|firstch
argument_list|)
expr_stmt|;
name|humbug
label|:
name|Lastrx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|readline
argument_list|(
literal|1
argument_list|)
operator|!=
name|TIMEOUT
condition|)
empty_stmt|;
if|if
condition|(
name|Firstsec
condition|)
block|{
name|sendline
argument_list|(
name|Crcflg
condition|?
name|WANTCRC
else|:
name|NAK
argument_list|)
expr_stmt|;
name|Lleft
operator|=
literal|0
expr_stmt|;
comment|/* Do read next time ... */
block|}
else|else
block|{
name|maxtime
operator|=
literal|40
expr_stmt|;
name|sendline
argument_list|(
name|NAK
argument_list|)
expr_stmt|;
name|Lleft
operator|=
literal|0
expr_stmt|;
comment|/* Do read next time ... */
block|}
block|}
comment|/* try to stop the bubble machine. */
name|canit
argument_list|()
expr_stmt|;
return|return
name|ERROR
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|vax11c
end_ifndef

begin_comment
comment|/*  * This version of readline is reasoably well suited for  * reading many characters.  *  (except, currently, for the Regulus version!)  *  * timeout is in tenths of seconds  */
end_comment

begin_macro
name|readline
argument_list|(
argument|timeout
argument_list|)
end_macro

begin_decl_stmt
name|int
name|timeout
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|static
name|char
modifier|*
name|cdq
decl_stmt|;
comment|/* pointer for removing chars from linbuf */
if|if
condition|(
operator|--
name|Lleft
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|Verbose
operator|>
literal|8
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x "
argument_list|,
operator|*
name|cdq
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|cdq
operator|++
operator|&
literal|0377
operator|)
return|;
block|}
name|n
operator|=
name|timeout
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|2
condition|)
name|n
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|5
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Calling read: alarm=%d  Readnum=%d "
argument_list|,
name|n
argument_list|,
name|Readnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|tohere
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCFLUSH
comment|/*		ioctl(0, TIOCFLUSH, 0); */
endif|#
directive|endif
name|Lleft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Readline:TIMEOUT\n"
argument_list|)
expr_stmt|;
return|return
name|TIMEOUT
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alrm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|Lleft
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|cdq
operator|=
name|linbuf
argument_list|,
name|Readnum
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|5
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Read returned %d bytes\n"
argument_list|,
name|Lleft
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Lleft
operator|<
literal|1
condition|)
return|return
name|TIMEOUT
return|;
operator|--
name|Lleft
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|8
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x "
argument_list|,
operator|*
name|cdq
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|cdq
operator|++
operator|&
literal|0377
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Purge the modem input queue of all characters  */
end_comment

begin_macro
name|purgeline
argument_list|()
end_macro

begin_block
block|{
name|Lleft
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCFLSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process incoming file information header  */
end_comment

begin_macro
name|procheader
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|openmode
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
comment|/* set default parameters and overrides */
name|openmode
operator|=
literal|"w"
expr_stmt|;
name|Thisbinary
operator|=
operator|(
operator|!
name|Rxascii
operator|)
operator|||
name|Rxbinary
expr_stmt|;
if|if
condition|(
name|Lzmanag
condition|)
name|zmanag
operator|=
name|Lzmanag
expr_stmt|;
comment|/* 	 *  Process ZMODEM remote file management requests 	 */
if|if
condition|(
operator|!
name|Rxbinary
operator|&&
name|zconv
operator|==
name|ZCNL
condition|)
comment|/* Remote ASCII override */
name|Thisbinary
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zconv
operator|==
name|ZCBIN
condition|)
comment|/* Remote Binary override */
name|Thisbinary
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|zmanag
operator|==
name|ZMAPND
condition|)
name|openmode
operator|=
literal|"a"
expr_stmt|;
ifndef|#
directive|ifndef
name|BIX
comment|/* Check for existing file */
if|if
condition|(
operator|!
name|Rxclob
operator|&&
operator|(
name|zmanag
operator|&
name|ZMMASK
operator|)
operator|!=
name|ZMCLOB
operator|&&
operator|(
name|fout
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
endif|#
directive|endif
name|Bytesleft
operator|=
name|DEFBYTL
expr_stmt|;
name|Filemode
operator|=
literal|0
expr_stmt|;
name|Modtime
operator|=
literal|0L
expr_stmt|;
name|p
operator|=
name|name
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
comment|/* file coming from Unix or DOS system */
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%ld%lo%o"
argument_list|,
operator|&
name|Bytesleft
argument_list|,
operator|&
name|Modtime
argument_list|,
operator|&
name|Filemode
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
name|Filemode
operator|&
name|UNIXFILE
condition|)
operator|++
name|Thisbinary
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Incoming: %s %ld %lo %o\n"
argument_list|,
name|name
argument_list|,
name|Bytesleft
argument_list|,
name|Modtime
argument_list|,
name|Filemode
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BIX
if|if
condition|(
operator|(
name|fout
operator|=
name|fopen
argument_list|(
literal|"scratchpad"
argument_list|,
name|openmode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERROR
return|;
return|return
name|OK
return|;
else|#
directive|else
else|else
block|{
comment|/* File coming from CP/M system */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
comment|/* change / to _ */
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'.'
condition|)
comment|/* zap trailing period */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
operator|!
name|Zmodem
operator|&&
name|MakeLCPathname
operator|&&
operator|!
name|IsAnyLower
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
operator|(
name|Filemode
operator|&
name|UNIXFILE
operator|)
condition|)
name|uncaps
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Topipe
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|Pathname
argument_list|,
literal|"%s %s"
argument_list|,
name|Progname
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Topipe: %s %s\n"
argument_list|,
name|Pathname
argument_list|,
name|Thisbinary
condition|?
literal|"BIN"
else|:
literal|"ASCII"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
operator|(
name|fout
operator|=
name|popen
argument_list|(
name|Pathname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ERROR
return|;
endif|#
directive|endif
block|}
else|else
block|{
name|strcpy
argument_list|(
name|Pathname
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Receiving %s %s %s\n"
argument_list|,
name|name
argument_list|,
name|Thisbinary
condition|?
literal|"BIN"
else|:
literal|"ASCII"
argument_list|,
name|openmode
argument_list|)
expr_stmt|;
block|}
name|checkpath
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
name|name
operator|=
literal|"/dev/null"
expr_stmt|;
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'!'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fout
operator|=
name|popen
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
return|return
name|ERROR
return|;
block|}
name|Topipe
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD
name|fout
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|openmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fout
condition|)
if|if
condition|(
name|make_dirs
argument_list|(
name|name
argument_list|)
condition|)
name|fout
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|openmode
argument_list|)
expr_stmt|;
else|#
directive|else
name|fout
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|openmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fout
condition|)
return|return
name|ERROR
return|;
block|}
return|return
name|OK
return|;
endif|#
directive|endif
comment|/* BIX */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MD
end_ifdef

begin_comment
comment|/*  *  Directory-creating routines from Public Domain TAR by John Gilmore  */
end_comment

begin_comment
comment|/*  * After a file/link/symlink/dir creation has failed, see if  * it's because some required directory was not present, and if  * so, create all required dirs.  */
end_comment

begin_expr_stmt
name|make_dirs
argument_list|(
name|pathname
argument_list|)
specifier|register
name|char
operator|*
name|pathname
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Points into path */
name|int
name|madeone
init|=
literal|0
decl_stmt|;
comment|/* Did we do anything yet? */
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* Remember caller's errno */
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
return|return
literal|0
return|;
comment|/* Not our problem */
for|for
control|(
name|p
operator|=
name|strchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
control|)
block|{
comment|/* Avoid mkdir of empty string, if leading or double '/' */
if|if
condition|(
name|p
operator|==
name|pathname
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
continue|continue;
comment|/* Avoid mkdir where last part of path is '.' */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
operator|==
name|pathname
operator|+
literal|1
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Truncate the path there */
if|if
condition|(
operator|!
name|mkdir
argument_list|(
name|pathname
argument_list|,
literal|0777
argument_list|)
condition|)
block|{
comment|/* Try to create it as a dir */
name|vfile
argument_list|(
literal|"Made directory %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|madeone
operator|++
expr_stmt|;
comment|/* Remember if we made one */
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
comment|/* Directory already exists */
continue|continue;
comment|/* 		 * Some other error in the mkdir.  We return to the caller. 		 */
break|break;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
comment|/* Restore caller's errno */
return|return
name|madeone
return|;
comment|/* Tell them to retry if we made one */
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|MD
operator|!=
literal|2
operator|)
end_if

begin_define
define|#
directive|define
name|TERM_SIGNAL
parameter_list|(
name|status
parameter_list|)
value|((status)& 0x7F)
end_define

begin_define
define|#
directive|define
name|TERM_COREDUMP
parameter_list|(
name|status
parameter_list|)
value|(((status)& 0x80) != 0)
end_define

begin_define
define|#
directive|define
name|TERM_VALUE
parameter_list|(
name|status
parameter_list|)
value|((status)>> 8)
end_define

begin_comment
comment|/*  * Make a directory.  Compatible with the mkdir() system call on 4.2BSD.  */
end_comment

begin_macro
name|mkdir
argument_list|(
argument|dpath
argument_list|,
argument|dmode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dmode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cpid
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dpath
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EEXIST
expr_stmt|;
comment|/* Stat worked, so it already exists */
return|return
operator|-
literal|1
return|;
block|}
comment|/* If stat fails for a reason other than non-existence, return error */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|cpid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error in fork() */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Errno is set already */
case|case
literal|0
case|:
comment|/* Child process */
comment|/* 		 * Cheap hack to set mode of new directory.  Since this 		 * child process is going away anyway, we zap its umask. 		 * FIXME, this won't suffice to set SUID, SGID, etc. on this 		 * directory.  Does anybody care? 		 */
name|status
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Get current umask */
name|status
operator|=
name|umask
argument_list|(
name|status
operator||
operator|(
literal|0777
operator|&
operator|~
name|dmode
operator|)
argument_list|)
expr_stmt|;
comment|/* Set for mkdir */
name|execl
argument_list|(
literal|"/bin/mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|dpath
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Can't exec /bin/mkdir */
default|default:
comment|/* Parent process */
while|while
condition|(
name|cpid
operator|!=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
condition|)
empty_stmt|;
comment|/* Wait for kid to finish */
block|}
if|if
condition|(
name|TERM_SIGNAL
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
operator|||
name|TERM_VALUE
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
comment|/* We don't know why, but */
return|return
operator|-
literal|1
return|;
comment|/* /bin/mkdir failed */
block|}
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MD != 2 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MD */
end_comment

begin_comment
comment|/*  * Putsec writes the n characters of buf to receive file fout.  *  If not in binary mode, carriage returns, and all characters  *  starting with CPMEOF are discarded.  */
end_comment

begin_macro
name|putsec
argument_list|(
argument|buf
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|Thisbinary
condition|)
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Eofseen
condition|)
return|return
name|OK
return|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
name|CPMEOF
condition|)
block|{
name|Eofseen
operator|=
name|TRUE
expr_stmt|;
return|return
name|OK
return|;
block|}
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|vax11c
end_ifndef

begin_comment
comment|/*  *  Send a character to modem.  Small is beautiful.  */
end_comment

begin_macro
name|sendline
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|char
name|d
decl_stmt|;
name|d
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|6
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sendline: %x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
operator|&
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|flushmo
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* make string s lower case */
end_comment

begin_expr_stmt
name|uncaps
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * IsAnyLower returns TRUE if string s has lower case letters.  */
end_comment

begin_expr_stmt
name|IsAnyLower
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * substr(string, token) searches for token in string s  * returns pointer to token within string if found, NULL otherwise  */
end_comment

begin_function
name|char
modifier|*
name|substr
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
name|tt
decl_stmt|;
comment|/* search for first char of token */
for|for
control|(
name|ss
operator|=
name|s
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|t
condition|)
comment|/* compare token with substring */
for|for
control|(
name|ss
operator|=
name|s
operator|,
name|tt
operator|=
name|t
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|tt
operator|==
literal|0
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|*
name|ss
operator|++
operator|!=
operator|*
name|tt
operator|++
condition|)
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/*  * Log an error  */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|zperr
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|,
argument|u
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|u
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Verbose
operator|<=
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Retry %d: "
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* send cancel string to get the other end to shut up */
end_comment

begin_macro
name|canit
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|canistr
index|[]
init|=
block|{
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|0
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|vax11c
name|raw_wbuf
argument_list|(
name|strlen
argument_list|(
name|canistr
argument_list|)
argument_list|,
name|canistr
argument_list|)
expr_stmt|;
name|purgeline
argument_list|()
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|canistr
argument_list|)
expr_stmt|;
name|Lleft
operator|=
literal|0
expr_stmt|;
comment|/* Do read next time ... */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|report
argument_list|(
argument|sct
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sct
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%03d%c"
argument_list|,
name|sct
argument_list|,
name|sct
operator|%
literal|10
condition|?
literal|' '
else|:
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * If called as [-][dir/../]vrzCOMMAND set Verbose to 1  * If called as [-][dir/../]rzCOMMAND set the pipe flag  * If called as rb use YMODEM protocol  */
end_comment

begin_macro
name|chkinvok
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|s
operator|=
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
name|s
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'v'
condition|)
block|{
name|Verbose
operator|=
literal|1
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|Progname
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'z'
condition|)
name|Batch
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
name|Batch
operator|=
name|Nozmodem
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
name|Topipe
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'r'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'z'
condition|)
name|Topipe
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Totalitarian Communist pathname processing  */
end_comment

begin_macro
name|checkpath
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Restricted
condition|)
block|{
if|if
condition|(
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|canit
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nrz: %s exists\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bibi
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* restrict pathnames to current tree or uucppublic */
if|if
condition|(
name|substr
argument_list|(
name|name
argument_list|,
literal|"../"
argument_list|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|PUBDIR
argument_list|,
name|strlen
argument_list|(
name|PUBDIR
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|canit
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nrz:\tSecurity Violation\r\n"
argument_list|)
expr_stmt|;
name|bibi
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Initialize for Zmodem receive attempt, try to activate Zmodem sender  *  Handles ZSINIT frame  *  Return ZFILE if Zmodem filename received, -1 on error,  *   ZCOMPL if transaction finished,  else 0  */
end_comment

begin_macro
name|tryz
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
operator|,
name|n
expr_stmt|;
specifier|register
name|cmdzack1flg
expr_stmt|;
if|if
condition|(
name|Nozmodem
condition|)
comment|/* Check for "rb" program name */
return|return
literal|0
return|;
for|for
control|(
name|n
operator|=
name|Zmodem
condition|?
literal|15
else|:
literal|5
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* Set buffer length (0) and capability flags */
ifdef|#
directive|ifdef
name|SEGMENTS
name|stohdr
argument_list|(
name|SEGMENTS
operator|*
literal|1024L
argument_list|)
expr_stmt|;
else|#
directive|else
name|stohdr
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CANBREAK
name|Txhdr
index|[
name|ZF0
index|]
operator|=
name|CANFC32
operator||
name|CANFDX
operator||
name|CANOVIO
operator||
name|CANBRK
expr_stmt|;
else|#
directive|else
name|Txhdr
index|[
name|ZF0
index|]
operator|=
name|CANFC32
operator||
name|CANFDX
operator||
name|CANOVIO
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Zctlesc
condition|)
name|Txhdr
index|[
name|ZF0
index|]
operator||=
name|TESCCTL
expr_stmt|;
name|Txhdr
index|[
name|ZF0
index|]
operator||=
name|CANRLE
expr_stmt|;
name|Txhdr
index|[
name|ZF1
index|]
operator|=
name|CANVHDR
expr_stmt|;
comment|/* tryzhdrtype may == ZRINIT */
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|tryzhdrtype
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryzhdrtype
operator|==
name|ZSKIP
condition|)
comment|/* Don't skip too far */
name|tryzhdrtype
operator|=
name|ZRINIT
expr_stmt|;
comment|/* CAF 8-21-87 */
name|again
label|:
switch|switch
condition|(
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|ZRQINIT
case|:
if|if
condition|(
name|Rxhdr
index|[
name|ZF3
index|]
operator|&
literal|0x80
condition|)
name|Usevhdrs
operator|=
literal|1
expr_stmt|;
comment|/* we can var header */
continue|continue;
case|case
name|ZEOF
case|:
continue|continue;
case|case
name|TIMEOUT
case|:
continue|continue;
case|case
name|ZFILE
case|:
name|zconv
operator|=
name|Rxhdr
index|[
name|ZF0
index|]
expr_stmt|;
name|zmanag
operator|=
name|Rxhdr
index|[
name|ZF1
index|]
expr_stmt|;
name|ztrans
operator|=
name|Rxhdr
index|[
name|ZF2
index|]
expr_stmt|;
if|if
condition|(
name|Rxhdr
index|[
name|ZF3
index|]
operator|&
name|ZCANVHDR
condition|)
name|Usevhdrs
operator|=
name|TRUE
expr_stmt|;
name|tryzhdrtype
operator|=
name|ZRINIT
expr_stmt|;
name|c
operator|=
name|zrdata
argument_list|(
name|secbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|mode
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|GOTCRCW
condition|)
return|return
name|ZFILE
return|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZNAK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|ZSINIT
case|:
name|Zctlesc
operator|=
name|TESCCTL
operator|&
name|Rxhdr
index|[
name|ZF0
index|]
expr_stmt|;
if|if
condition|(
name|zrdata
argument_list|(
name|Attn
argument_list|,
name|ZATTNLEN
argument_list|)
operator|==
name|GOTCRCW
condition|)
block|{
name|stohdr
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZACK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZNAK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|ZFREECNT
case|:
name|stohdr
argument_list|(
name|getfree
argument_list|()
argument_list|)
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZACK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|ZCOMMAND
case|:
ifdef|#
directive|ifdef
name|vax11c
return|return
name|ERROR
return|;
else|#
directive|else
name|cmdzack1flg
operator|=
name|Rxhdr
index|[
name|ZF0
index|]
expr_stmt|;
if|if
condition|(
name|zrdata
argument_list|(
name|secbuf
argument_list|,
literal|1024
argument_list|)
operator|==
name|GOTCRCW
condition|)
block|{
if|if
condition|(
name|cmdzack1flg
operator|&
name|ZCACK1
condition|)
name|stohdr
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
else|else
name|stohdr
argument_list|(
operator|(
name|long
operator|)
name|sys2
argument_list|(
name|secbuf
argument_list|)
argument_list|)
expr_stmt|;
name|purgeline
argument_list|()
expr_stmt|;
comment|/* dump impatient questions */
do|do
block|{
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZCOMPL
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|errors
operator|<
literal|20
operator|&&
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|1
argument_list|)
operator|!=
name|ZFIN
condition|)
do|;
name|ackbibi
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmdzack1flg
operator|&
name|ZCACK1
condition|)
name|exec2
argument_list|(
name|secbuf
argument_list|)
expr_stmt|;
return|return
name|ZCOMPL
return|;
block|}
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZNAK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
endif|#
directive|endif
case|case
name|ZCOMPL
case|:
goto|goto
name|again
goto|;
default|default:
continue|continue;
case|case
name|ZFIN
case|:
name|ackbibi
argument_list|()
expr_stmt|;
return|return
name|ZCOMPL
return|;
case|case
name|ZCAN
case|:
return|return
name|ERROR
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Receive 1 or more files with ZMODEM protocol  */
end_comment

begin_macro
name|rzfiles
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|rzfile
argument_list|()
condition|)
block|{
case|case
name|ZEOF
case|:
case|case
name|ZSKIP
case|:
switch|switch
condition|(
name|tryz
argument_list|()
condition|)
block|{
case|case
name|ZCOMPL
case|:
return|return
name|OK
return|;
default|default:
return|return
name|ERROR
return|;
case|case
name|ZFILE
case|:
break|break;
block|}
continue|continue;
default|default:
return|return
name|c
return|;
case|case
name|ERROR
case|:
return|return
name|ERROR
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Receive a file with ZMODEM protocol  *  Assumes file name frame is in secbuf  */
end_comment

begin_macro
name|rzfile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
operator|,
name|n
expr_stmt|;
name|long
name|rxbytes
decl_stmt|;
name|Eofseen
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|procheader
argument_list|(
name|secbuf
argument_list|)
operator|==
name|ERROR
condition|)
block|{
return|return
operator|(
name|tryzhdrtype
operator|=
name|ZSKIP
operator|)
return|;
block|}
name|n
operator|=
literal|20
expr_stmt|;
name|rxbytes
operator|=
literal|0l
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|SEGMENTS
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stohdr
argument_list|(
name|rxbytes
argument_list|)
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZRPOS
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
name|nxthdr
label|:
switch|switch
condition|(
name|c
operator|=
name|zgethdr
argument_list|(
name|Rxhdr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
default|default:
name|vfile
argument_list|(
literal|"rzfile: zgethdr returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
case|case
name|ZNAK
case|:
case|case
name|TIMEOUT
case|:
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
block|{
name|vfile
argument_list|(
literal|"rzfile: zgethdr returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
case|case
name|ZFILE
case|:
name|zrdata
argument_list|(
name|secbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ZEOF
case|:
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rclhdr
argument_list|(
name|Rxhdr
argument_list|)
operator|!=
name|rxbytes
condition|)
block|{
comment|/* 				 * Ignore eof if it's at wrong place - force 				 *  a timeout because the eof might have gone 				 *  out before we sent our zrpos. 				 */
name|errors
operator|=
literal|0
expr_stmt|;
goto|goto
name|nxthdr
goto|;
block|}
if|if
condition|(
name|closeit
argument_list|()
condition|)
block|{
name|tryzhdrtype
operator|=
name|ZFERR
expr_stmt|;
name|vfile
argument_list|(
literal|"rzfile: closeit returned<> 0"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
name|vfile
argument_list|(
literal|"rzfile: normal EOF"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
case|case
name|ERROR
case|:
comment|/* Too much garbage in header search error */
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
block|{
name|vfile
argument_list|(
literal|"rzfile: zgethdr returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
name|zmputs
argument_list|(
name|Attn
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ZSKIP
case|:
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|Modtime
operator|=
literal|1
expr_stmt|;
name|closeit
argument_list|()
expr_stmt|;
name|vfile
argument_list|(
literal|"rzfile: Sender SKIPPED file"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
case|case
name|ZDATA
case|:
if|if
condition|(
name|rclhdr
argument_list|(
name|Rxhdr
argument_list|)
operator|!=
name|rxbytes
condition|)
block|{
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
block|{
return|return
name|ERROR
return|;
block|}
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|zmputs
argument_list|(
name|Attn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|moredata
label|:
if|if
condition|(
name|Verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r%7ld ZMODEM%s    "
argument_list|,
name|rxbytes
argument_list|,
name|Crc32r
condition|?
literal|" CRC-32"
else|:
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEGMENTS
if|if
condition|(
name|chinseg
operator|>=
operator|(
literal|1024
operator|*
name|SEGMENTS
operator|)
condition|)
block|{
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|=
name|zrdata
argument_list|(
name|secbuf
operator|+
name|chinseg
argument_list|,
literal|1024
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|c
operator|=
name|zrdata
argument_list|(
name|secbuf
argument_list|,
literal|1024
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|ZCAN
case|:
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|vfile
argument_list|(
literal|"rzfile: zgethdr returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
case|case
name|ERROR
case|:
comment|/* CRC error */
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
block|{
name|vfile
argument_list|(
literal|"rzfile: zgethdr returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
name|zmputs
argument_list|(
name|Attn
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TIMEOUT
case|:
ifdef|#
directive|ifdef
name|SEGMENTS
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
block|{
name|vfile
argument_list|(
literal|"rzfile: zgethdr returned %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
continue|continue;
case|case
name|GOTCRCW
case|:
name|n
operator|=
literal|20
expr_stmt|;
ifdef|#
directive|ifdef
name|SEGMENTS
name|chinseg
operator|+=
name|Rxcount
expr_stmt|;
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|chinseg
argument_list|)
expr_stmt|;
name|chinseg
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|Rxcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxbytes
operator|+=
name|Rxcount
expr_stmt|;
name|stohdr
argument_list|(
name|rxbytes
argument_list|)
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZACK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
name|sendline
argument_list|(
name|XON
argument_list|)
expr_stmt|;
goto|goto
name|nxthdr
goto|;
case|case
name|GOTCRCQ
case|:
name|n
operator|=
literal|20
expr_stmt|;
ifdef|#
directive|ifdef
name|SEGMENTS
name|chinseg
operator|+=
name|Rxcount
expr_stmt|;
else|#
directive|else
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|Rxcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxbytes
operator|+=
name|Rxcount
expr_stmt|;
name|stohdr
argument_list|(
name|rxbytes
argument_list|)
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZACK
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
goto|goto
name|moredata
goto|;
case|case
name|GOTCRCG
case|:
name|n
operator|=
literal|20
expr_stmt|;
ifdef|#
directive|ifdef
name|SEGMENTS
name|chinseg
operator|+=
name|Rxcount
expr_stmt|;
else|#
directive|else
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|Rxcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxbytes
operator|+=
name|Rxcount
expr_stmt|;
goto|goto
name|moredata
goto|;
case|case
name|GOTCRCE
case|:
name|n
operator|=
literal|20
expr_stmt|;
ifdef|#
directive|ifdef
name|SEGMENTS
name|chinseg
operator|+=
name|Rxcount
expr_stmt|;
else|#
directive|else
name|putsec
argument_list|(
name|secbuf
argument_list|,
name|Rxcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rxbytes
operator|+=
name|Rxcount
expr_stmt|;
goto|goto
name|nxthdr
goto|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Send a string to the modem, processing for \336 (sleep 1 sec)  *   and \335 (break signal)  */
end_comment

begin_macro
name|zmputs
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\336'
case|:
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\335'
case|:
name|sendbrk
argument_list|()
expr_stmt|;
continue|continue;
default|default:
name|sendline
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Close the receive dataset, return OK or ERROR  */
end_comment

begin_macro
name|closeit
argument_list|()
end_macro

begin_block
block|{
name|time_t
name|time
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
name|Topipe
condition|)
block|{
if|if
condition|(
name|pclose
argument_list|(
name|fout
argument_list|)
condition|)
block|{
return|return
name|ERROR
return|;
block|}
return|return
name|OK
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fclose
argument_list|(
name|fout
argument_list|)
operator|==
name|ERROR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file close ERROR\n"
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
ifndef|#
directive|ifndef
name|vax11c
if|if
condition|(
name|Modtime
condition|)
block|{
name|timep
index|[
literal|0
index|]
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|=
name|Modtime
expr_stmt|;
name|utime
argument_list|(
name|Pathname
argument_list|,
name|timep
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|Filemode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
name|chmod
argument_list|(
name|Pathname
argument_list|,
operator|(
literal|07777
operator|&
name|Filemode
operator|)
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*  * Ack a ZFIN packet, let byegones be byegones  */
end_comment

begin_macro
name|ackbibi
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
expr_stmt|;
name|vfile
argument_list|(
literal|"ackbibi:"
argument_list|)
expr_stmt|;
name|Readnum
operator|=
literal|1
expr_stmt|;
name|stohdr
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|3
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
block|{
name|purgeline
argument_list|()
expr_stmt|;
name|zshhdr
argument_list|(
literal|4
argument_list|,
name|ZFIN
argument_list|,
name|Txhdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|readline
argument_list|(
literal|100
argument_list|)
condition|)
block|{
case|case
literal|'O'
case|:
name|readline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Discard 2nd 'O' */
name|vfile
argument_list|(
literal|"ackbibi complete"
argument_list|)
expr_stmt|;
return|return;
case|case
name|RCDO
case|:
return|return;
case|case
name|TIMEOUT
case|:
default|default:
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Local console output simulation  */
end_comment

begin_macro
name|bttyout
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|Verbose
operator|||
name|Fromcu
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|vax11c
end_ifndef

begin_comment
comment|/*  * Strip leading ! if present, do shell escape.   */
end_comment

begin_expr_stmt
name|sys2
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'!'
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|system
argument_list|(
name|s
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Strip leading ! if present, do exec.  */
end_comment

begin_expr_stmt
name|exec2
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'!'
condition|)
operator|++
name|s
expr_stmt|;
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* End of rz.c */
end_comment

end_unit

