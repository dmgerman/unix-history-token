begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  VMODEM  *  VMS support for UMODEM and vvrb/vvsb programs  *  *	Defined herein are some utility routines to make the UNIX  *	program UMODEM run under VAX/VMS C:  *  *		assign_channel	Calls the VMS System Service $ASSIGN  *				to assign a channel to a device.  *				The routine currently has the device  *				"TT" hardwired into it.  *		gtty		Gets terminal characteristics, almost  *				like the UNIX GTTY system call.  *		raw_read	Reads characters from the terminal  *				without any echoing or interpretation  *				and with an optional timeout period.  *		raw_write	Writes a character to the terminal  *				without any interpretation.  *		raw_wbuf	Writes a buffer to the terminal  *				without any interpretation.  *		stty		Sets terminal characteristics, almost  *				like the UNIX STTY system call.  *  *	Some of the ideas used here were obtained from code written  *	by Max Benson and Robert Bruccoleri.  *  *  Walter Reiher  *  Harvard University  *  Department of Chemistry  *  12 Oxford Street  *  Cambridge, MA 02138  *  March 11, 1983  *  *  Modified 4-20-88 Chuck Forsberg, Omen Technology INC  *  17505-V NW Sauvie IS RD Portland OR 97231 omen!caf  *   Added primitives for for ZMODEM use.  */
end_comment

begin_include
include|#
directive|include
include|descrip
end_include

begin_include
include|#
directive|include
include|iodef
end_include

begin_include
include|#
directive|include
include|rms
end_include

begin_include
include|#
directive|include
include|ssdef
end_include

begin_include
include|#
directive|include
include|stdio
end_include

begin_include
include|#
directive|include
file|"vmodem.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_decl_stmt
specifier|static
name|char
name|tt_name
index|[]
init|=
literal|"TT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|tt_chan
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Terminal channel number  */
end_comment

begin_struct
struct|struct
name|tt_io_iosb
comment|/*  Terminal I/O IOSB  */
block|{
name|short
name|status
decl_stmt|;
name|short
name|byte_count
decl_stmt|;
name|short
name|terminator
decl_stmt|;
name|short
name|terminator_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tt_io_tacf
comment|/* Terminal I/O type ahead */
block|{
name|short
name|byte_count
decl_stmt|;
name|char
name|firstchar
decl_stmt|;
name|char
name|something
decl_stmt|;
name|short
name|whatever
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *	Terminator mask for PASSALL reads.  *	Permits reads of all possible 8-bit characters.  */
end_comment

begin_decl_stmt
name|int
name|t_mask
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|terminator_mask
block|{
name|short
name|size
decl_stmt|;
name|short
name|unused
decl_stmt|;
name|int
modifier|*
name|mask
decl_stmt|;
block|}
name|termin_mask
init|=
block|{
literal|32
block|,
literal|0
block|,
name|t_mask
block|}
struct|;
end_struct

begin_comment
comment|/*  *	ASSIGN a channel to the logical name TT, which is usually  *	the terminal.  */
end_comment

begin_macro
name|assign_channel
argument_list|()
end_macro

begin_block
block|{
name|int
name|status
decl_stmt|;
name|$DESCRIPTOR
argument_list|(
name|tt_descriptor
argument_list|,
name|tt_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt_chan
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
name|sys$assign
argument_list|(
operator|&
name|tt_descriptor
argument_list|,
operator|&
name|tt_chan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|SS$_NORMAL
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SS$_NORMAL
operator|||
name|tt_chan
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"ASSIGN_CHANNEL:  error in SYS$ASSIGN\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  *	Gets terminal information from VMS.  */
end_comment

begin_macro
name|gtty
argument_list|(
argument|tt_characteristics
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tt_info
modifier|*
name|tt_characteristics
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|extern
name|unsigned
name|Baudrate
decl_stmt|;
name|int
name|speeds
index|[]
init|=
block|{
literal|2400
block|,
literal|50
block|,
literal|75
block|,
literal|110
block|,
literal|134
block|,
literal|150
block|,
literal|300
block|,
literal|600
block|,
literal|1200
block|,
literal|1800
block|,
literal|2000
block|,
literal|2400
block|,
literal|3600
block|,
literal|4800
block|,
literal|7200
block|,
literal|9600
block|,
literal|19200
block|}
decl_stmt|;
if|if
condition|(
name|tt_chan
operator|==
operator|-
literal|1
condition|)
name|assign_channel
argument_list|()
expr_stmt|;
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|tt_chan
argument_list|,
name|IO$_SENSEMODE
argument_list|,
operator|&
operator|(
name|tt_characteristics
operator|->
name|dev_modes
operator|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|tt_characteristics
operator|->
name|dev_characteristics
operator|)
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SS$_NORMAL
operator|||
name|tt_characteristics
operator|->
name|dev_modes
operator|.
name|status
operator|!=
name|SS$_NORMAL
condition|)
name|fatal
argument_list|(
literal|"GTTY:  sense mode QIO error return.\n"
argument_list|)
expr_stmt|;
name|c
operator|=
name|tt_characteristics
operator|->
name|dev_modes
operator|.
name|t_speed
operator|%
literal|17
expr_stmt|;
name|Baudrate
operator|=
name|speeds
index|[
name|c
index|]
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	Return the number of characters waiting in TTY input buffer  */
end_comment

begin_macro
name|rdchk
argument_list|()
end_macro

begin_block
block|{
name|int
name|status
decl_stmt|;
name|struct
name|tt_io_iosb
name|iosb
decl_stmt|;
name|struct
name|tt_io_tacf
name|typeahead
decl_stmt|;
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|tt_chan
argument_list|,
name|IO$_SENSEMODE
operator||
name|IO$M_TYPEAHDCNT
argument_list|,
operator|&
name|iosb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|typeahead
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|typeahead
operator|.
name|byte_count
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	Read NCHAR characters from the terminal without echoing or  *	interpretation.  *	If the argument SECONDS is non-zero, use that as the  *	timeout period in seconds for the read.  *  *	Returns SS$_TIMEOUT in case of timeout or other error.  *	  Otherwise, returns the number of characters read.  */
end_comment

begin_macro
name|raw_read
argument_list|(
argument|nchar
argument_list|,
argument|charbuf
argument_list|,
argument|seconds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|charbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|seconds
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|function
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|tt_io_iosb
name|iosb
decl_stmt|;
if|if
condition|(
name|tt_chan
operator|==
operator|-
literal|1
condition|)
name|assign_channel
argument_list|()
expr_stmt|;
name|function
operator|=
name|IO$_READVBLK
operator||
name|IO$M_NOECHO
operator||
name|IO$M_NOFILTR
expr_stmt|;
if|if
condition|(
name|seconds
condition|)
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|tt_chan
argument_list|,
name|function
operator||
name|IO$M_TIMED
argument_list|,
operator|&
name|iosb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|charbuf
argument_list|,
name|nchar
argument_list|,
name|seconds
argument_list|,
operator|&
name|termin_mask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|tt_chan
argument_list|,
name|function
argument_list|,
operator|&
name|iosb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|charbuf
argument_list|,
name|nchar
argument_list|,
literal|0
argument_list|,
operator|&
name|termin_mask
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iosb
operator|.
name|byte_count
condition|)
return|return
name|iosb
operator|.
name|byte_count
return|;
return|return
name|SS$_TIMEOUT
return|;
block|}
end_block

begin_comment
comment|/*  *	Writes a character to the terminal without echoing or  *	interpretation.  */
end_comment

begin_macro
name|raw_write
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
name|struct
name|tt_io_iosb
name|iosb
decl_stmt|;
if|if
condition|(
name|tt_chan
operator|==
operator|-
literal|1
condition|)
name|assign_channel
argument_list|()
expr_stmt|;
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|tt_chan
argument_list|,
name|IO$_WRITEVBLK
operator||
name|IO$M_CANCTRLO
operator||
name|IO$M_NOFORMAT
argument_list|,
operator|&
name|iosb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SS$_NORMAL
operator|||
name|iosb
operator|.
name|status
operator|!=
name|SS$_NORMAL
condition|)
name|fatal
argument_list|(
literal|"RAW_WRITE:  write QIO error return.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  *	Writes a buffer to the terminal without echoing or  *	interpretation.  */
end_comment

begin_macro
name|raw_wbuf
argument_list|(
argument|nchar
argument_list|,
argument|charbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|charbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|;
name|struct
name|tt_io_iosb
name|iosb
decl_stmt|;
if|if
condition|(
name|tt_chan
operator|==
operator|-
literal|1
condition|)
name|assign_channel
argument_list|()
expr_stmt|;
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|tt_chan
argument_list|,
name|IO$_WRITEVBLK
operator||
name|IO$M_CANCTRLO
operator||
name|IO$M_NOFORMAT
argument_list|,
operator|&
name|iosb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|charbuf
argument_list|,
name|nchar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SS$_NORMAL
operator|||
name|iosb
operator|.
name|status
operator|!=
name|SS$_NORMAL
condition|)
name|fatal
argument_list|(
literal|"RAW_WRITE:  write QIO error return.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  *  Sets terminal information from VMS.  *	 Modified 12-85 Larry Farr/Chuck Forsberg to not use  *	 bad parity returned by VMS 4.  */
end_comment

begin_macro
name|stty
argument_list|(
argument|tt_characteristics
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tt_info
modifier|*
name|tt_characteristics
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
modifier|*
name|f_ptr
decl_stmt|,
comment|/* *p_ptr, */
modifier|*
name|s_ptr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|tt_mode_iosb
name|iosb
decl_stmt|;
if|if
condition|(
name|tt_chan
operator|==
operator|-
literal|1
condition|)
name|assign_channel
argument_list|()
expr_stmt|;
comment|/*  *	We do the following in order to get a full short, concatenating  *	two adjacent chars:  */
name|s_ptr
operator|=
operator|&
operator|(
name|tt_characteristics
operator|->
name|dev_modes
operator|.
name|t_speed
operator|)
expr_stmt|;
comment|/*  Speeds  */
name|f_ptr
operator|=
operator|&
operator|(
name|tt_characteristics
operator|->
name|dev_modes
operator|.
name|CR_fill
operator|)
expr_stmt|;
comment|/*  Fills  */
comment|/* p_ptr	=&(tt_characteristics->dev_modes.parity_flags); */
name|status
operator|=
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|tt_chan
argument_list|,
name|IO$_SETMODE
argument_list|,
operator|&
name|iosb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|tt_characteristics
operator|->
name|dev_characteristics
operator|)
argument_list|,
literal|12
argument_list|,
comment|/* *s_ptr, *f_ptr, *p_ptr, 0);	*/
operator|*
name|s_ptr
argument_list|,
operator|*
name|f_ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SS$_NORMAL
operator|||
name|iosb
operator|.
name|status
operator|!=
name|SS$_NORMAL
condition|)
name|printf
argument_list|(
literal|"STTY:  set mode QIO returned %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

end_unit

