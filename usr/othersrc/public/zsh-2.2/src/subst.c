begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * subst.c - various substitutions  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_comment
comment|/* do substitutions before fork */
end_comment

begin_function
name|void
name|prefork
parameter_list|(
name|list
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
block|{
name|Lknode
name|node
init|=
name|firstnode
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|int
name|qt
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|str3
decl_stmt|;
name|str
operator|=
name|str3
operator|=
name|getdata
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|str
operator|==
name|Inang
operator|||
operator|*
name|str
operator|==
name|Outang
operator|||
operator|*
name|str
operator|==
name|Equals
operator|)
operator|&&
name|str
index|[
literal|1
index|]
operator|==
name|Inpar
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|Inang
condition|)
name|setdata
argument_list|(
name|node
argument_list|,
name|getoutproc
argument_list|(
name|str
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/*<(...) */
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|Equals
condition|)
name|setdata
argument_list|(
name|node
argument_list|,
name|getoutputfile
argument_list|(
name|str
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* =(...) */
else|else
name|setdata
argument_list|(
name|node
argument_list|,
name|getinproc
argument_list|(
name|str
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/*>(...) */
if|if
condition|(
operator|!
name|getdata
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"parse error in process substitution"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|(
name|qt
operator|=
operator|*
name|str
operator|==
name|Qstring
operator|)
operator|||
operator|*
name|str
operator|==
name|String
condition|)
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
name|Inpar
condition|)
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
name|Inbrack
condition|)
block|{
name|arithsubst
argument_list|(
operator|(
name|vptr
operator|*
operator|)
operator|&
name|str
argument_list|,
operator|&
name|str3
argument_list|)
expr_stmt|;
comment|/* $[...] */
name|setdata
argument_list|(
name|node
argument_list|,
name|str3
argument_list|)
expr_stmt|;
name|str
operator|=
name|str3
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|paramsubst
argument_list|(
name|list
argument_list|,
name|node
argument_list|,
name|str
argument_list|,
name|str3
argument_list|,
name|qt
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
name|str3
operator|=
name|str
operator|=
name|getdata
argument_list|(
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
block|}
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
name|getdata
argument_list|(
name|node
argument_list|)
condition|)
name|remnulargs
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unset
argument_list|(
name|IGNOREBRACES
argument_list|)
condition|)
while|while
condition|(
name|hasbraces
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|xpandbraces
argument_list|(
name|list
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|filesub
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|getaddrdata
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
name|incnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|postfork
parameter_list|(
name|list
parameter_list|,
name|doglob
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
name|int
name|doglob
decl_stmt|;
block|{
name|Lknode
name|node
init|=
name|firstnode
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|int
name|glb
init|=
literal|1
decl_stmt|;
name|badcshglob
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|NOGLOBOPT
argument_list|)
operator|||
operator|!
name|doglob
condition|)
name|glb
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|char
modifier|*
name|str3
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|str3
operator|=
name|getdata
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|str
operator|==
name|String
operator|||
operator|*
name|str
operator|==
name|Qstring
operator|)
operator|&&
name|str
index|[
literal|1
index|]
operator|==
name|Inpar
operator|)
operator|||
operator|*
name|str
operator|==
name|Tick
operator|||
operator|*
name|str
operator|==
name|Qtick
condition|)
block|{
name|Lknode
name|n
init|=
name|prevnode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|commsubst
argument_list|(
name|list
argument_list|,
name|node
argument_list|,
name|str
argument_list|,
name|str3
argument_list|,
operator|(
operator|*
name|str
operator|==
name|Qstring
operator|||
operator|*
name|str
operator|==
name|Qtick
operator|)
argument_list|)
expr_stmt|;
comment|/* `...`,$(...) */
if|if
condition|(
name|errflag
condition|)
return|return;
name|str
operator|=
name|str3
operator|=
name|getdata
argument_list|(
name|node
operator|=
name|nextnode
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|glb
condition|)
block|{
if|if
condition|(
name|haswilds
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
name|glob
argument_list|(
name|list
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
block|}
name|incnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|badcshglob
operator|==
literal|1
condition|)
name|zerr
argument_list|(
literal|"no match"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* perform substitution on a single word */
end_comment

begin_function
name|void
name|singsub
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|Lklist
name|foo
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|*
name|s
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|t
operator|==
name|String
condition|)
operator|*
name|t
operator|=
name|Qstring
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
name|Tick
condition|)
operator|*
name|t
operator|=
name|Qtick
expr_stmt|;
name|foo
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|foo
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|prefork
argument_list|(
name|foo
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
name|postfork
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
operator|*
name|s
operator|=
name|ugetnode
argument_list|(
name|foo
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstnode
argument_list|(
name|foo
argument_list|)
condition|)
name|zerr
argument_list|(
literal|"ambiguous: %s"
argument_list|,
operator|*
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* strdup, but returns "Nularg" if this is a null string */
end_comment

begin_function
name|vptr
name|nstrdup
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|vptr
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
init|=
name|s
decl_stmt|;
name|char
name|u
index|[
literal|2
index|]
decl_stmt|;
name|u
index|[
literal|0
index|]
operator|=
name|Nularg
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t
condition|)
return|return
name|strdup
argument_list|(
name|u
argument_list|)
return|;
return|return
name|strdup
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dynread
parameter_list|(
name|stop
parameter_list|)
comment|/**/
name|int
name|stop
decl_stmt|;
block|{
name|int
name|bsiz
init|=
literal|256
decl_stmt|,
name|ct
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|zalloc
argument_list|(
name|bsiz
argument_list|)
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|hgetc
argument_list|()
operator|)
operator|!=
name|stop
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
name|ct
operator|==
name|bsiz
condition|)
block|{
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|bsiz
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
operator|+
name|ct
expr_stmt|;
block|}
block|}
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|filesub
parameter_list|(
name|namptr
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|namptr
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|namptr
decl_stmt|,
modifier|*
name|cnam
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|Tilde
operator|&&
name|str
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'+'
operator|&&
operator|(
name|str
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|str
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|char
modifier|*
name|foo
init|=
name|strdup
argument_list|(
name|pwd
argument_list|)
decl_stmt|;
comment|/* ~+ */
name|str
operator|+=
literal|2
expr_stmt|;
name|modify
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
operator|*
name|namptr
operator|=
name|dyncat
argument_list|(
name|pwd
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|str
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|str
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|char
modifier|*
name|foo
decl_stmt|;
comment|/* ~- */
if|if
condition|(
name|cnam
operator|=
name|oldpwd
condition|)
name|foo
operator|=
name|cnam
expr_stmt|;
else|else
name|foo
operator|=
name|pwd
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
name|foo
operator|=
name|strdup
argument_list|(
name|foo
argument_list|)
expr_stmt|;
name|modify
argument_list|(
operator|&
name|foo
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
operator|*
name|namptr
operator|=
name|dyncat
argument_list|(
name|foo
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ialpha
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* ~foo */
block|{
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|hom
decl_stmt|;
for|for
control|(
name|ptr
operator|=
operator|++
name|str
init|;
operator|*
name|ptr
operator|&&
name|iuser
argument_list|(
operator|*
name|ptr
argument_list|)
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
operator|*
name|ptr
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|'/'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|hom
operator|=
name|gethome
argument_list|(
name|str
argument_list|,
name|ptr
operator|-
name|str
argument_list|)
operator|)
condition|)
block|{
name|zerr
argument_list|(
literal|"user not found: %l"
argument_list|,
name|str
argument_list|,
name|ptr
operator|-
name|str
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|modify
argument_list|(
operator|&
name|hom
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|namptr
operator|=
name|dyncat
argument_list|(
name|hom
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* ~/foo */
block|{
operator|*
name|namptr
operator|=
name|dyncat
argument_list|(
name|home
argument_list|,
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|str
index|[
literal|1
index|]
condition|)
comment|/* ~ by itself */
block|{
operator|*
name|namptr
operator|=
name|strdup
argument_list|(
name|home
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|*
name|str
operator|==
name|Equals
operator|&&
name|iuser
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
operator|&&
name|unset
argument_list|(
name|NOEQUALS
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|ds
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|ialpha
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* =foo */
block|{
name|char
name|sav
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|str
operator|+
literal|1
init|;
operator|*
name|pp
operator|&&
operator|*
name|pp
operator|!=
literal|':'
condition|;
name|pp
operator|++
control|)
empty_stmt|;
name|sav
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cnam
operator|=
name|findcmd
argument_list|(
name|str
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|zerr
argument_list|(
literal|"%s not found"
argument_list|,
name|str
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|namptr
operator|=
name|cnam
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|=
name|sav
operator|)
operator|==
literal|':'
condition|)
block|{
name|modify
argument_list|(
name|namptr
argument_list|,
operator|&
name|pp
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|namptr
expr_stmt|;
operator|*
name|namptr
operator|=
name|dyncat
argument_list|(
operator|*
name|namptr
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|/* =- */
block|{
name|val
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|str
operator|+
literal|2
expr_stmt|;
block|}
else|else
name|val
operator|=
name|zstrtol
argument_list|(
name|str
operator|+
literal|1
argument_list|,
operator|&
name|ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* =# */
name|ds
operator|=
name|dstackent
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ds
condition|)
return|return
literal|1
return|;
name|s
operator|=
name|strdup
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|modify
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|namptr
operator|=
name|dyncat
argument_list|(
name|s
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get a named directory */
end_comment

begin_function
name|char
modifier|*
name|gethome
parameter_list|(
name|user
parameter_list|,
name|len
parameter_list|)
comment|/**/
name|char
modifier|*
name|user
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|sav
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|strdup
argument_list|(
name|home
argument_list|)
return|;
name|sav
operator|=
name|user
index|[
name|len
index|]
expr_stmt|;
name|user
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|=
name|getsparamval
argument_list|(
name|user
argument_list|,
name|len
argument_list|)
operator|)
operator|&&
operator|*
name|str
operator|==
literal|'/'
condition|)
block|{
name|str
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|adduserdir
argument_list|(
name|user
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|user
index|[
name|len
index|]
operator|=
name|sav
expr_stmt|;
return|return
name|str
return|;
block|}
name|permalloc
argument_list|()
expr_stmt|;
comment|/* fixes iris bug--getpwnam calls strdup! */
name|pw
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|lastalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
block|{
name|user
index|[
name|len
index|]
operator|=
name|sav
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|str
operator|=
name|xsymlink
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|adduserdir
argument_list|(
name|user
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|user
index|[
name|len
index|]
operator|=
name|sav
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* `...`, $(...) */
end_comment

begin_function
name|void
name|commsubst
parameter_list|(
name|l
parameter_list|,
name|n
parameter_list|,
name|str3
parameter_list|,
name|str
parameter_list|,
name|qt
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
name|Lknode
name|n
decl_stmt|;
name|char
modifier|*
name|str3
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|qt
decl_stmt|;
block|{
name|char
modifier|*
name|str2
decl_stmt|;
name|Lknode
name|where
init|=
name|prevnode
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|Lklist
name|pl
decl_stmt|;
if|if
condition|(
operator|*
name|str3
operator|==
name|Tick
operator|||
operator|*
name|str3
operator|==
name|Qtick
condition|)
block|{
operator|*
name|str3
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|str2
operator|=
operator|++
name|str3
init|;
operator|*
name|str3
operator|!=
name|Tick
operator|&&
operator|*
name|str3
operator|!=
name|Qtick
condition|;
name|str3
operator|++
control|)
empty_stmt|;
operator|*
name|str3
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|str3
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|str2
operator|=
operator|++
name|str3
init|;
operator|*
name|str3
operator|!=
name|Outpar
condition|;
name|str3
operator|++
control|)
empty_stmt|;
operator|*
name|str3
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|uremnode
argument_list|(
name|l
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pl
operator|=
name|getoutput
argument_list|(
name|str2
argument_list|,
name|qt
argument_list|)
operator|)
condition|)
block|{
name|zerr
argument_list|(
literal|"parse error in command substitution"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|full
argument_list|(
name|pl
argument_list|)
condition|)
block|{
name|setdata
argument_list|(
name|firstnode
argument_list|(
name|pl
argument_list|)
argument_list|,
name|dyncat
argument_list|(
name|str
argument_list|,
name|peekfirst
argument_list|(
name|pl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setdata
argument_list|(
name|lastnode
argument_list|(
name|pl
argument_list|)
argument_list|,
name|dyncat
argument_list|(
name|getdata
argument_list|(
name|lastnode
argument_list|(
name|pl
argument_list|)
argument_list|)
argument_list|,
name|str3
argument_list|)
argument_list|)
expr_stmt|;
name|inslist
argument_list|(
name|pl
argument_list|,
name|where
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|insnode
argument_list|(
name|l
argument_list|,
name|where
argument_list|,
name|dyncat
argument_list|(
name|str
argument_list|,
name|str3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parameter substitution */
end_comment

begin_function
name|void
name|paramsubst
parameter_list|(
name|l
parameter_list|,
name|n
parameter_list|,
name|aptr
parameter_list|,
name|bptr
parameter_list|,
name|qt
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
name|Lknode
name|n
decl_stmt|;
name|char
modifier|*
name|aptr
decl_stmt|;
name|char
modifier|*
name|bptr
decl_stmt|;
name|int
name|qt
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|aptr
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|idbeg
decl_stmt|,
modifier|*
name|idend
decl_stmt|,
modifier|*
name|ostr
init|=
name|bptr
decl_stmt|;
name|int
name|brs
decl_stmt|;
comment|/* != 0 means ${...}, otherwise $... */
name|int
name|colf
decl_stmt|;
comment|/* != 0 means we found a colon after the name */
name|int
name|doub
init|=
literal|0
decl_stmt|;
comment|/* != 0 means we have %%, not %, or ##, not # */
name|int
name|isarr
init|=
literal|0
decl_stmt|;
name|int
name|wasnularr
init|=
literal|0
decl_stmt|;
name|int
name|plan9
init|=
name|isset
argument_list|(
name|RCEXPANDPARAM
argument_list|)
decl_stmt|;
name|int
name|getlen
init|=
literal|0
decl_stmt|;
name|int
name|vunset
init|=
literal|0
decl_stmt|;
name|int
name|spbreak
init|=
name|isset
argument_list|(
name|SHWORDSPLIT
argument_list|)
operator|&&
operator|!
name|qt
decl_stmt|;
name|char
modifier|*
name|val
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|aval
init|=
name|NULL
decl_stmt|;
name|int
name|fwidth
init|=
literal|0
decl_stmt|;
name|Value
name|v
decl_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|ialnum
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'#'
operator|&&
operator|*
name|s
operator|!=
name|Pound
operator|&&
operator|*
name|s
operator|!=
literal|'-'
operator|&&
operator|*
name|s
operator|!=
literal|'!'
operator|&&
operator|*
name|s
operator|!=
literal|'$'
operator|&&
operator|*
name|s
operator|!=
name|String
operator|&&
operator|*
name|s
operator|!=
name|Qstring
operator|&&
operator|*
name|s
operator|!=
literal|'?'
operator|&&
operator|*
name|s
operator|!=
name|Quest
operator|&&
operator|*
name|s
operator|!=
literal|'_'
operator|&&
operator|*
name|s
operator|!=
literal|'*'
operator|&&
operator|*
name|s
operator|!=
name|Star
operator|&&
operator|*
name|s
operator|!=
literal|'@'
operator|&&
operator|*
name|s
operator|!=
literal|'{'
operator|&&
operator|*
name|s
operator|!=
name|Inbrace
operator|&&
operator|*
name|s
operator|!=
literal|'='
operator|&&
operator|*
name|s
operator|!=
name|Hat
operator|&&
operator|*
name|s
operator|!=
literal|'^'
condition|)
block|{
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|'$'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|brs
operator|=
operator|(
operator|*
name|s
operator|==
literal|'{'
operator|||
operator|*
name|s
operator|==
name|Inbrace
operator|)
condition|)
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'^'
operator|||
operator|*
name|s
operator|==
name|Hat
condition|)
name|plan9
operator|^=
literal|1
operator|,
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|spbreak
operator|^=
literal|1
operator|,
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'#'
operator|||
operator|*
name|s
operator|==
name|Pound
operator|)
operator|&&
name|iident
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|getlen
operator|=
literal|1
operator|,
name|s
operator|++
expr_stmt|;
else|else
break|break;
name|idbeg
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|=
name|getvalue
argument_list|(
operator|&
name|s
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|vunset
operator|=
literal|1
expr_stmt|;
name|idend
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isarr
operator|=
name|v
operator|->
name|isarr
condition|)
name|aval
operator|=
name|getarrvalue
argument_list|(
name|v
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
name|getstrvalue
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|fwidth
operator|=
name|v
operator|->
name|pm
operator|->
name|ct
expr_stmt|;
switch|switch
condition|(
name|v
operator|->
name|pm
operator|->
name|flags
operator|&
operator|(
name|PMFLAG_L
operator||
name|PMFLAG_R
operator||
name|PMFLAG_Z
operator|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|t0
decl_stmt|;
case|case
name|PMFLAG_L
case|:
case|case
name|PMFLAG_L
operator||
name|PMFLAG_Z
case|:
name|t
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|pm
operator|->
name|flags
operator|&
name|PMFLAG_Z
condition|)
while|while
condition|(
operator|*
name|t
operator|==
literal|'0'
condition|)
name|t
operator|++
expr_stmt|;
else|else
while|while
condition|(
name|isep
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
name|val
operator|=
name|ncalloc
argument_list|(
name|fwidth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|val
index|[
name|fwidth
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|t0
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
operator|)
operator|>
name|fwidth
condition|)
name|t0
operator|=
name|fwidth
expr_stmt|;
name|memset
argument_list|(
name|val
argument_list|,
literal|' '
argument_list|,
name|fwidth
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|val
argument_list|,
name|t
argument_list|,
name|t0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMFLAG_R
case|:
case|case
name|PMFLAG_Z
case|:
case|case
name|PMFLAG_Z
operator||
name|PMFLAG_R
case|:
if|if
condition|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|<
name|fwidth
condition|)
block|{
name|t
operator|=
name|ncalloc
argument_list|(
name|fwidth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
operator|(
name|v
operator|->
name|pm
operator|->
name|flags
operator|&
name|PMFLAG_R
operator|)
condition|?
literal|' '
else|:
literal|'0'
argument_list|,
name|fwidth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t0
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|)
operator|>
name|fwidth
condition|)
name|t0
operator|=
name|fwidth
expr_stmt|;
name|strcpy
argument_list|(
name|t
operator|+
operator|(
name|fwidth
operator|-
name|t0
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|ncalloc
argument_list|(
name|fwidth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
index|[
name|fwidth
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|t
argument_list|,
name|val
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|-
name|fwidth
argument_list|,
name|fwidth
argument_list|)
expr_stmt|;
name|val
operator|=
name|t
expr_stmt|;
block|}
break|break;
block|}
switch|switch
condition|(
name|v
operator|->
name|pm
operator|->
name|flags
operator|&
operator|(
name|PMFLAG_l
operator||
name|PMFLAG_u
operator|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
case|case
name|PMFLAG_l
case|:
name|t
operator|=
name|val
expr_stmt|;
for|for
control|(
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
operator|*
name|t
operator|=
name|tulower
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMFLAG_u
case|:
name|t
operator|=
name|val
expr_stmt|;
for|for
control|(
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
operator|*
name|t
operator|=
name|tuupper
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|colf
operator|=
operator|*
name|s
operator|==
literal|':'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* check for ${..?...} or ${..=..} or one of those.  Only works 		if the name is in braces. */
if|if
condition|(
name|brs
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'-'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'?'
operator|||
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'#'
operator|||
operator|*
name|s
operator|==
literal|'%'
operator|||
operator|*
name|s
operator|==
name|Quest
operator|||
operator|*
name|s
operator|==
name|Pound
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|&&
name|v
operator|->
name|isarr
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'%'
operator|||
operator|*
name|s
operator|==
literal|'#'
operator|||
operator|*
name|s
operator|==
name|Pound
operator|)
condition|)
block|{
name|zerr
argument_list|(
literal|"operator requires a scalar"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|s
operator|==
name|s
index|[
literal|1
index|]
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|doub
operator|=
literal|1
expr_stmt|;
block|}
name|u
operator|=
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|brs
condition|)
block|{
name|int
name|bct
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
operator|||
operator|*
name|s
operator|==
name|Inbrace
condition|)
name|bct
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'}'
operator|||
operator|*
name|s
operator|==
name|Outbrace
condition|)
name|bct
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|bct
operator|||
operator|!
operator|*
name|s
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
empty_stmt|;
name|s
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|colf
operator|&&
operator|!
name|vunset
condition|)
name|vunset
operator|=
operator|(
name|isarr
operator|)
condition|?
operator|!
operator|*
name|aval
else|:
operator|!
operator|*
name|val
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|u
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|vunset
condition|)
name|val
operator|=
name|strdup
argument_list|(
name|u
argument_list|)
operator|,
name|isarr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|vunset
condition|)
block|{
name|char
name|sav
init|=
operator|*
name|idend
decl_stmt|;
operator|*
name|idend
operator|=
literal|'\0'
expr_stmt|;
name|setsparam
argument_list|(
name|idbeg
argument_list|,
name|ztrdup
argument_list|(
name|val
operator|=
name|strdup
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|idend
operator|=
name|sav
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
case|case
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Quest
case|:
if|if
condition|(
name|vunset
condition|)
block|{
name|zerr
argument_list|(
literal|"%s"
argument_list|,
operator|(
operator|*
name|u
operator|)
condition|?
name|u
else|:
literal|"parameter not set"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interact
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|vunset
condition|)
name|val
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|strdup
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
case|case
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Pound
case|:
if|if
condition|(
name|vunset
condition|)
name|val
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|u
argument_list|)
expr_stmt|;
name|getmatch
argument_list|(
operator|&
name|val
argument_list|,
name|u
argument_list|,
name|doub
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|vunset
condition|)
name|val
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|u
argument_list|)
expr_stmt|;
name|getmatch
argument_list|(
operator|&
name|val
argument_list|,
name|u
argument_list|,
name|doub
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* no ${...=...} or anything, but possible modifiers. */
if|if
condition|(
name|vunset
condition|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|NOUNSET
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"parameter not set"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|val
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|colf
condition|)
block|{
name|s
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|isarr
condition|)
name|modify
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|ss
init|=
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
init|=
name|aval
decl_stmt|;
while|while
condition|(
operator|*
name|ap
condition|)
block|{
name|ss
operator|=
name|s
expr_stmt|;
name|modify
argument_list|(
name|ap
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|brs
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'}'
operator|&&
operator|*
name|s
operator|!=
name|Outbrace
condition|)
block|{
name|zerr
argument_list|(
literal|"closing brace expected"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errflag
condition|)
return|return;
if|if
condition|(
name|getlen
condition|)
block|{
name|long
name|len
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|14
index|]
decl_stmt|;
if|if
condition|(
name|isarr
condition|)
block|{
name|char
modifier|*
modifier|*
name|ctr
decl_stmt|;
for|for
control|(
name|ctr
operator|=
name|aval
init|;
operator|*
name|ctr
condition|;
name|ctr
operator|++
operator|,
name|len
operator|++
control|)
empty_stmt|;
block|}
else|else
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isarr
condition|)
if|if
condition|(
operator|!
name|aval
operator|||
operator|!
name|aval
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|isarr
operator|<
literal|0
condition|)
name|wasnularr
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|aval
index|[
literal|1
index|]
condition|)
block|{
name|val
operator|=
name|aval
index|[
literal|0
index|]
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qt
condition|)
block|{
if|if
condition|(
name|isarr
operator|>
literal|0
condition|)
block|{
name|val
operator|=
name|spacejoin
argument_list|(
name|aval
argument_list|)
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|spbreak
condition|)
block|{
if|if
condition|(
name|isarr
condition|)
name|val
operator|=
name|spacejoin
argument_list|(
name|aval
argument_list|)
expr_stmt|;
name|isarr
operator|=
literal|1
expr_stmt|;
name|aval
operator|=
name|spacesplit
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aval
operator|||
operator|!
name|aval
index|[
literal|0
index|]
condition|)
block|{
name|val
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|aval
index|[
literal|1
index|]
condition|)
block|{
name|val
operator|=
name|aval
index|[
literal|0
index|]
expr_stmt|;
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if only one member, not really an array */
if|if
condition|(
operator|!
name|aval
index|[
literal|1
index|]
condition|)
name|isarr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isarr
condition|)
if|if
condition|(
name|plan9
condition|)
block|{
name|int
name|dlen
decl_stmt|;
name|char
modifier|*
name|y
decl_stmt|;
name|y
operator|=
name|ncalloc
argument_list|(
operator|(
name|dlen
operator|=
operator|(
name|char
operator|*
operator|)
name|aptr
operator|-
name|bptr
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
operator|)
operator|+
name|strlen
argument_list|(
name|aval
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|setdata
argument_list|(
name|n
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|y
argument_list|,
name|ostr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|y
argument_list|,
name|aval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|y
argument_list|,
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|aval
condition|)
block|{
name|char
modifier|*
name|x
init|=
name|ncalloc
argument_list|(
name|dlen
operator|+
name|strlen
argument_list|(
operator|*
name|aval
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|x
argument_list|,
name|ostr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|x
argument_list|,
operator|*
name|aval
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|x
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|insnode
argument_list|(
name|l
argument_list|,
name|n
argument_list|,
name|x
argument_list|)
operator|,
name|incnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|zz
decl_stmt|;
name|zz
operator|=
name|ncalloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aptr
operator|-
operator|(
name|bptr
operator|)
operator|+
name|strlen
argument_list|(
name|aval
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|setdata
argument_list|(
name|n
argument_list|,
name|zz
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zz
argument_list|,
name|ostr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zz
argument_list|,
operator|*
name|aval
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|aval
index|[
literal|1
index|]
condition|)
name|insnode
argument_list|(
name|l
argument_list|,
name|n
argument_list|,
operator|*
name|aval
operator|++
argument_list|)
operator|,
name|incnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|zz
operator|=
name|ncalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|aval
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zz
argument_list|,
operator|*
name|aval
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zz
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|insnode
argument_list|(
name|l
argument_list|,
name|n
argument_list|,
name|zz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bptr
operator|=
name|ncalloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aptr
operator|-
name|bptr
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|setdata
argument_list|(
name|n
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|ostr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bptr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* arithmetic substitution */
end_comment

begin_function
name|void
name|arithsubst
parameter_list|(
name|aptr
parameter_list|,
name|bptr
parameter_list|)
comment|/**/
name|vptr
modifier|*
name|aptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|bptr
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|aptr
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|long
name|v
decl_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
name|Outbrack
condition|;
name|s
operator|++
control|)
empty_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|matheval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|aptr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t
operator|=
name|ncalloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|bptr
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
operator|*
name|bptr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|t
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|bptr
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|modify
parameter_list|(
name|str
parameter_list|,
name|ptr
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
block|{
name|char
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|,
modifier|*
name|ptr3
decl_stmt|,
name|del
decl_stmt|,
modifier|*
name|lptr
decl_stmt|;
name|int
name|gbal
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
operator|==
literal|':'
condition|)
operator|*
name|str
operator|=
name|strdup
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
operator|==
literal|':'
condition|)
block|{
name|lptr
operator|=
operator|*
name|ptr
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
name|gbal
operator|=
literal|0
expr_stmt|;
name|here
label|:
switch|switch
condition|(
operator|*
operator|(
operator|*
name|ptr
operator|)
operator|++
condition|)
block|{
case|case
literal|'h'
case|:
name|remtpath
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|remtext
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|rembutext
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|remlpaths
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|downcase
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|upcase
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|hsubl
condition|)
name|free
argument_list|(
name|hsubl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsubr
condition|)
name|free
argument_list|(
name|hsubr
argument_list|)
expr_stmt|;
name|ptr1
operator|=
operator|*
name|ptr
expr_stmt|;
name|del
operator|=
operator|*
name|ptr1
operator|++
expr_stmt|;
for|for
control|(
name|ptr2
operator|=
name|ptr1
init|;
operator|*
name|ptr2
operator|!=
name|del
operator|&&
operator|*
name|ptr2
condition|;
name|ptr2
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr2
condition|)
block|{
name|zerr
argument_list|(
literal|"bad subtitution"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
operator|*
name|ptr2
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ptr3
operator|=
name|ptr2
init|;
operator|*
name|ptr3
operator|!=
name|del
operator|&&
operator|*
name|ptr3
condition|;
name|ptr3
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ptr3
condition|)
operator|*
name|ptr3
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|hsubl
operator|=
name|ztrdup
argument_list|(
name|ptr1
argument_list|)
expr_stmt|;
name|hsubr
operator|=
name|ztrdup
argument_list|(
name|ptr2
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ptr3
expr_stmt|;
case|case
literal|'&'
case|:
if|if
condition|(
name|hsubl
operator|&&
name|hsubr
condition|)
name|subst
argument_list|(
name|str
argument_list|,
name|hsubl
argument_list|,
name|hsubr
argument_list|,
name|gbal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|gbal
operator|=
literal|1
expr_stmt|;
goto|goto
name|here
goto|;
default|default:
operator|*
name|ptr
operator|=
name|lptr
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* get a directory stack entry */
end_comment

begin_function
name|char
modifier|*
name|dstackent
parameter_list|(
name|val
parameter_list|)
comment|/**/
name|int
name|val
decl_stmt|;
block|{
name|Lknode
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|<
literal|0
operator|&&
operator|!
name|firstnode
argument_list|(
name|dirstack
argument_list|)
operator|)
operator|||
operator|!
name|val
operator|--
condition|)
return|return
name|pwd
return|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|node
operator|=
name|lastnode
argument_list|(
name|dirstack
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|dirstack
argument_list|)
init|;
name|node
operator|&&
name|val
condition|;
name|val
operator|--
operator|,
name|incnode
argument_list|(
name|node
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|zerr
argument_list|(
literal|"not enough dir stack entries."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|getdata
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* make an alias hash table node */
end_comment

begin_function
name|struct
name|alias
modifier|*
name|mkanode
parameter_list|(
name|txt
parameter_list|,
name|cmflag
parameter_list|)
comment|/**/
name|char
modifier|*
name|txt
decl_stmt|;
name|int
name|cmflag
decl_stmt|;
block|{
name|struct
name|alias
modifier|*
name|ptr
init|=
operator|(
name|Alias
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|ptr
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|text
operator|=
name|txt
expr_stmt|;
name|ptr
operator|->
name|cmd
operator|=
name|cmflag
expr_stmt|;
name|ptr
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

end_unit

