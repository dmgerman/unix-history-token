begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * table.c - linked lists and hash tables  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_define
define|#
directive|define
name|TABLE_C
end_define

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_comment
comment|/* get an empty linked list header */
end_comment

begin_function
name|Lklist
name|newlist
parameter_list|()
comment|/**/
block|{
name|Lklist
name|list
decl_stmt|;
name|list
operator|=
operator|(
name|Lklist
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|list
argument_list|)
expr_stmt|;
name|list
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|last
operator|=
operator|(
name|Lknode
operator|)
name|list
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* get an empty hash table */
end_comment

begin_function
name|Hashtab
name|newhtable
parameter_list|(
name|size
parameter_list|)
comment|/**/
name|int
name|size
decl_stmt|;
block|{
name|Hashtab
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|Hashtab
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|hsize
operator|=
name|size
expr_stmt|;
name|ret
operator|->
name|nodes
operator|=
operator|(
name|Hashnode
operator|*
operator|)
name|zcalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|Hashnode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Peter Weinberger's hash function */
end_comment

begin_function
name|int
name|hasher
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|hash
init|=
literal|0
decl_stmt|,
name|g
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|hash
operator|=
operator|(
name|hash
operator|<<
literal|4
operator|)
operator|+
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|g
operator|=
name|hash
operator|&
literal|0xf0000000
condition|)
block|{
name|hash
operator|^=
name|g
expr_stmt|;
name|hash
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
block|}
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* add a node to a hash table */
end_comment

begin_function
name|void
name|Addhnode
parameter_list|(
name|nam
parameter_list|,
name|dat
parameter_list|,
name|ht
parameter_list|,
name|freefunc
parameter_list|,
name|canfree
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|vptr
name|dat
decl_stmt|;
name|Hashtab
name|ht
decl_stmt|;
name|FFunc
name|freefunc
decl_stmt|;
name|int
name|canfree
decl_stmt|;
block|{
name|int
name|hval
init|=
name|hasher
argument_list|(
name|nam
argument_list|)
operator|%
name|ht
operator|->
name|hsize
decl_stmt|;
name|struct
name|hashnode
modifier|*
modifier|*
name|hp
init|=
name|ht
operator|->
name|nodes
operator|+
name|hval
decl_stmt|,
modifier|*
name|hn
decl_stmt|;
for|for
control|(
init|;
operator|*
name|hp
condition|;
name|hp
operator|=
operator|&
operator|(
operator|*
name|hp
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|nam
argument_list|,
name|nam
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|canfree
condition|)
name|free
argument_list|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|nam
argument_list|)
expr_stmt|;
name|hn
operator|=
name|dat
expr_stmt|;
name|hn
operator|->
name|next
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|freefunc
condition|)
name|zerr
argument_list|(
literal|"attempt to call NULL freefunc"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|freefunc
argument_list|(
operator|*
name|hp
argument_list|)
expr_stmt|;
operator|*
name|hp
operator|=
name|hn
expr_stmt|;
name|hn
operator|->
name|nam
operator|=
name|nam
expr_stmt|;
name|hn
operator|->
name|canfree
operator|=
name|canfree
expr_stmt|;
return|return;
block|}
name|hn
operator|=
operator|(
name|Hashnode
operator|)
name|dat
expr_stmt|;
name|hn
operator|->
name|nam
operator|=
name|nam
expr_stmt|;
name|hn
operator|->
name|canfree
operator|=
name|canfree
expr_stmt|;
name|hn
operator|->
name|next
operator|=
name|ht
operator|->
name|nodes
index|[
name|hval
index|]
expr_stmt|;
name|ht
operator|->
name|nodes
index|[
name|hval
index|]
operator|=
name|hn
expr_stmt|;
if|if
condition|(
operator|++
name|ht
operator|->
name|ct
operator|==
name|ht
operator|->
name|hsize
operator|*
literal|4
condition|)
name|expandhtab
argument_list|(
name|ht
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add a node to command hash table */
end_comment

begin_function
name|void
name|addhcmdnode
parameter_list|(
name|nam
parameter_list|,
name|pnam
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|char
modifier|*
modifier|*
name|pnam
decl_stmt|;
block|{
name|int
name|hval
init|=
name|hasher
argument_list|(
name|nam
argument_list|)
operator|%
name|cmdnamtab
operator|->
name|hsize
decl_stmt|;
name|struct
name|hashnode
modifier|*
name|hp
init|=
name|cmdnamtab
operator|->
name|nodes
index|[
name|hval
index|]
decl_stmt|,
modifier|*
name|hn
decl_stmt|;
name|Cmdnam
name|cc
decl_stmt|;
for|for
control|(
init|;
name|hp
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hp
operator|->
name|nam
argument_list|,
name|nam
argument_list|)
condition|)
return|return;
name|cc
operator|=
operator|(
name|Cmdnam
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|type
operator|=
name|EXCMD
expr_stmt|;
name|cc
operator|->
name|u
operator|.
name|nam
operator|=
name|tricat
argument_list|(
operator|*
name|pnam
argument_list|,
literal|"/"
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|cc
operator|->
name|pcomp
operator|=
name|pnam
expr_stmt|;
name|hn
operator|=
operator|(
name|Hashnode
operator|)
name|cc
expr_stmt|;
name|hn
operator|->
name|nam
operator|=
name|ztrdup
argument_list|(
name|nam
argument_list|)
expr_stmt|;
name|hn
operator|->
name|canfree
operator|=
literal|1
expr_stmt|;
name|hn
operator|->
name|next
operator|=
name|cmdnamtab
operator|->
name|nodes
index|[
name|hval
index|]
expr_stmt|;
name|cmdnamtab
operator|->
name|nodes
index|[
name|hval
index|]
operator|=
name|hn
expr_stmt|;
if|if
condition|(
operator|++
name|cmdnamtab
operator|->
name|ct
operator|==
name|cmdnamtab
operator|->
name|hsize
operator|*
literal|4
condition|)
name|expandhtab
argument_list|(
name|cmdnamtab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* expand hash tables when they get too many entries */
end_comment

begin_function
name|void
name|expandhtab
parameter_list|(
name|ht
parameter_list|)
comment|/**/
name|Hashtab
name|ht
decl_stmt|;
block|{
name|struct
name|hashnode
modifier|*
modifier|*
name|arr
decl_stmt|,
modifier|*
modifier|*
name|ha
decl_stmt|,
modifier|*
name|hn
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
name|int
name|osize
init|=
name|ht
operator|->
name|hsize
decl_stmt|,
name|nsize
init|=
name|osize
operator|*
literal|8
decl_stmt|;
name|ht
operator|->
name|hsize
operator|=
name|nsize
expr_stmt|;
name|arr
operator|=
name|ht
operator|->
name|nodes
expr_stmt|;
name|ht
operator|->
name|nodes
operator|=
operator|(
name|Hashnode
operator|*
operator|)
name|zcalloc
argument_list|(
name|nsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hashnode
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ha
operator|=
name|arr
init|;
name|osize
condition|;
name|osize
operator|--
operator|,
name|ha
operator|++
control|)
for|for
control|(
name|hn
operator|=
operator|*
name|ha
init|;
name|hn
condition|;
control|)
block|{
name|hp
operator|=
name|hn
operator|->
name|next
expr_stmt|;
name|Addhnode
argument_list|(
name|hn
operator|->
name|nam
argument_list|,
operator|(
name|vptr
operator|)
name|hn
argument_list|,
name|ht
argument_list|,
name|NULL
argument_list|,
name|hn
operator|->
name|canfree
argument_list|)
expr_stmt|;
name|hn
operator|=
name|hp
expr_stmt|;
block|}
name|free
argument_list|(
name|arr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get an entry in a hash table */
end_comment

begin_function
name|vptr
name|gethnode
parameter_list|(
name|nam
parameter_list|,
name|ht
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|Hashtab
name|ht
decl_stmt|;
block|{
name|int
name|hval
init|=
name|hasher
argument_list|(
name|nam
argument_list|)
operator|%
name|ht
operator|->
name|hsize
decl_stmt|;
name|struct
name|hashnode
modifier|*
name|hn
init|=
name|ht
operator|->
name|nodes
index|[
name|hval
index|]
decl_stmt|;
for|for
control|(
init|;
name|hn
condition|;
name|hn
operator|=
name|hn
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hn
operator|->
name|nam
argument_list|,
name|nam
argument_list|)
condition|)
return|return
operator|(
name|vptr
operator|)
name|hn
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|freehtab
parameter_list|(
name|ht
parameter_list|,
name|freefunc
parameter_list|)
comment|/**/
name|Hashtab
name|ht
decl_stmt|;
name|FFunc
name|freefunc
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|struct
name|hashnode
modifier|*
name|hn
decl_stmt|,
modifier|*
modifier|*
name|hp
init|=
operator|&
name|ht
operator|->
name|nodes
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|ht
operator|->
name|hsize
init|;
name|val
condition|;
name|val
operator|--
operator|,
name|hp
operator|++
control|)
for|for
control|(
name|hn
operator|=
operator|*
name|hp
init|;
name|hn
condition|;
control|)
block|{
name|next
operator|=
name|hn
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hn
operator|->
name|canfree
condition|)
name|free
argument_list|(
name|hn
operator|->
name|nam
argument_list|)
expr_stmt|;
name|freefunc
argument_list|(
name|hn
argument_list|)
expr_stmt|;
name|hn
operator|=
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|ht
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ht
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remove a hash table entry and return a pointer to it */
end_comment

begin_function
name|vptr
name|remhnode
parameter_list|(
name|nam
parameter_list|,
name|ht
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
name|Hashtab
name|ht
decl_stmt|;
block|{
name|int
name|hval
init|=
name|hasher
argument_list|(
name|nam
argument_list|)
operator|%
name|ht
operator|->
name|hsize
decl_stmt|;
name|struct
name|hashnode
modifier|*
name|hn
init|=
name|ht
operator|->
name|nodes
index|[
name|hval
index|]
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|!
name|hn
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hn
operator|->
name|nam
argument_list|,
name|nam
argument_list|)
condition|)
block|{
name|ht
operator|->
name|nodes
index|[
name|hval
index|]
operator|=
name|hn
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hn
operator|->
name|canfree
condition|)
name|free
argument_list|(
name|hn
operator|->
name|nam
argument_list|)
expr_stmt|;
name|ht
operator|->
name|ct
operator|--
expr_stmt|;
return|return
operator|(
name|vptr
operator|)
name|hn
return|;
block|}
for|for
control|(
name|hp
operator|=
name|hn
operator|,
name|hn
operator|=
name|hn
operator|->
name|next
init|;
name|hn
condition|;
name|hn
operator|=
operator|(
name|hp
operator|=
name|hn
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hn
operator|->
name|nam
argument_list|,
name|nam
argument_list|)
condition|)
block|{
name|hp
operator|->
name|next
operator|=
name|hn
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hn
operator|->
name|canfree
condition|)
name|free
argument_list|(
name|hn
operator|->
name|nam
argument_list|)
expr_stmt|;
name|ht
operator|->
name|ct
operator|--
expr_stmt|;
return|return
operator|(
name|vptr
operator|)
name|hn
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* insert a node in a linked list after 'llast' */
end_comment

begin_function
name|void
name|insnode
parameter_list|(
name|list
parameter_list|,
name|llast
parameter_list|,
name|dat
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
name|Lknode
name|llast
decl_stmt|;
name|vptr
name|dat
decl_stmt|;
block|{
name|Lknode
name|tmp
decl_stmt|;
name|tmp
operator|=
name|llast
operator|->
name|next
expr_stmt|;
name|llast
operator|->
name|next
operator|=
operator|(
name|Lknode
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|tmp
argument_list|)
expr_stmt|;
name|llast
operator|->
name|next
operator|->
name|last
operator|=
name|llast
expr_stmt|;
name|llast
operator|->
name|next
operator|->
name|dat
operator|=
name|dat
expr_stmt|;
name|llast
operator|->
name|next
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|tmp
operator|->
name|last
operator|=
name|llast
operator|->
name|next
expr_stmt|;
else|else
name|list
operator|->
name|last
operator|=
name|llast
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_function
name|void
name|addnodeinorder
parameter_list|(
name|x
parameter_list|,
name|dat
parameter_list|)
comment|/**/
name|Lklist
name|x
decl_stmt|;
name|char
modifier|*
name|dat
decl_stmt|;
block|{
name|Lknode
name|y
decl_stmt|,
name|l
init|=
name|NULL
decl_stmt|;
name|int
name|val
init|=
literal|123
decl_stmt|;
for|for
control|(
name|y
operator|=
name|firstnode
argument_list|(
name|x
argument_list|)
init|;
name|y
condition|;
name|incnode
argument_list|(
name|y
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|forstrcmp
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|y
operator|->
name|dat
argument_list|,
operator|&
name|dat
argument_list|)
operator|)
operator|>=
literal|0
condition|)
break|break;
name|l
operator|=
name|y
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|val
condition|)
return|return;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
name|insnode
argument_list|(
name|x
argument_list|,
operator|(
name|Lknode
operator|)
name|x
argument_list|,
name|dat
argument_list|)
expr_stmt|;
else|else
name|insnode
argument_list|(
name|x
argument_list|,
name|l
argument_list|,
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remove a node from a linked list */
end_comment

begin_function
name|vptr
name|remnode
parameter_list|(
name|list
parameter_list|,
name|nd
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
name|Lknode
name|nd
decl_stmt|;
block|{
name|vptr
name|dat
decl_stmt|;
name|nd
operator|->
name|last
operator|->
name|next
operator|=
name|nd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|next
condition|)
name|nd
operator|->
name|next
operator|->
name|last
operator|=
name|nd
operator|->
name|last
expr_stmt|;
else|else
name|list
operator|->
name|last
operator|=
name|nd
operator|->
name|last
expr_stmt|;
name|dat
operator|=
name|nd
operator|->
name|dat
expr_stmt|;
name|free
argument_list|(
name|nd
argument_list|)
expr_stmt|;
return|return
name|dat
return|;
block|}
end_function

begin_comment
comment|/* remove a node from a linked list */
end_comment

begin_function
name|vptr
name|uremnode
parameter_list|(
name|list
parameter_list|,
name|nd
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
name|Lknode
name|nd
decl_stmt|;
block|{
name|vptr
name|dat
decl_stmt|;
name|nd
operator|->
name|last
operator|->
name|next
operator|=
name|nd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|next
condition|)
name|nd
operator|->
name|next
operator|->
name|last
operator|=
name|nd
operator|->
name|last
expr_stmt|;
else|else
name|list
operator|->
name|last
operator|=
name|nd
operator|->
name|last
expr_stmt|;
name|dat
operator|=
name|nd
operator|->
name|dat
expr_stmt|;
return|return
name|dat
return|;
block|}
end_function

begin_comment
comment|/* delete a character in a string */
end_comment

begin_function
name|void
name|chuck
parameter_list|(
name|str
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
name|str
index|[
literal|0
index|]
operator|=
name|str
index|[
literal|1
index|]
condition|)
name|str
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get top node in a linked list */
end_comment

begin_function
name|vptr
name|getnode
parameter_list|(
name|list
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
block|{
name|vptr
name|dat
decl_stmt|;
name|Lknode
name|node
init|=
name|list
operator|->
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|NULL
return|;
name|dat
operator|=
name|node
operator|->
name|dat
expr_stmt|;
name|list
operator|->
name|first
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next
condition|)
name|node
operator|->
name|next
operator|->
name|last
operator|=
operator|(
name|Lknode
operator|)
name|list
expr_stmt|;
else|else
name|list
operator|->
name|last
operator|=
operator|(
name|Lknode
operator|)
name|list
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|dat
return|;
block|}
end_function

begin_comment
comment|/* get top node in a linked list without freeing */
end_comment

begin_function
name|vptr
name|ugetnode
parameter_list|(
name|list
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
block|{
name|vptr
name|dat
decl_stmt|;
name|Lknode
name|node
init|=
name|list
operator|->
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|NULL
return|;
name|dat
operator|=
name|node
operator|->
name|dat
expr_stmt|;
name|list
operator|->
name|first
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|next
condition|)
name|node
operator|->
name|next
operator|->
name|last
operator|=
operator|(
name|Lknode
operator|)
name|list
expr_stmt|;
else|else
name|list
operator|->
name|last
operator|=
operator|(
name|Lknode
operator|)
name|list
expr_stmt|;
return|return
name|dat
return|;
block|}
end_function

begin_function
name|void
name|freetable
parameter_list|(
name|tab
parameter_list|,
name|freefunc
parameter_list|)
comment|/**/
name|Lklist
name|tab
decl_stmt|;
name|FFunc
name|freefunc
decl_stmt|;
block|{
name|Lknode
name|node
init|=
name|tab
operator|->
name|first
decl_stmt|,
name|next
decl_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|freefunc
condition|)
name|freefunc
argument_list|(
name|node
operator|->
name|dat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|ztrstr
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
for|for
control|(
name|p1
operator|=
name|s
operator|,
name|p2
operator|=
name|t
init|;
operator|*
name|p2
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
if|if
condition|(
operator|*
name|p1
operator|!=
operator|*
name|p2
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|p2
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* insert a list in another list */
end_comment

begin_function
name|void
name|inslist
parameter_list|(
name|l
parameter_list|,
name|where
parameter_list|,
name|x
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
name|Lknode
name|where
decl_stmt|;
name|Lklist
name|x
decl_stmt|;
block|{
name|Lknode
name|nx
init|=
name|where
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|->
name|first
condition|)
return|return;
name|where
operator|->
name|next
operator|=
name|l
operator|->
name|first
expr_stmt|;
name|l
operator|->
name|last
operator|->
name|next
operator|=
name|nx
expr_stmt|;
name|l
operator|->
name|first
operator|->
name|last
operator|=
name|where
expr_stmt|;
if|if
condition|(
name|nx
condition|)
name|nx
operator|->
name|last
operator|=
name|l
operator|->
name|last
expr_stmt|;
else|else
name|x
operator|->
name|last
operator|=
name|l
operator|->
name|last
expr_stmt|;
block|}
end_function

begin_function
name|int
name|countnodes
parameter_list|(
name|x
parameter_list|)
comment|/**/
name|Lklist
name|x
decl_stmt|;
block|{
name|Lknode
name|y
decl_stmt|;
name|int
name|ct
init|=
literal|0
decl_stmt|;
for|for
control|(
name|y
operator|=
name|firstnode
argument_list|(
name|x
argument_list|)
init|;
name|y
condition|;
name|incnode
argument_list|(
name|y
argument_list|)
operator|,
name|ct
operator|++
control|)
empty_stmt|;
return|return
name|ct
return|;
block|}
end_function

end_unit

