begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * zle_main.c - main routines for line editor  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_define
define|#
directive|define
name|ZLEGLOBALS
end_define

begin_define
define|#
directive|define
name|ZLE
end_define

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SYS_SELECT
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Key
name|cky
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set up terminal */
end_comment

begin_function
name|void
name|setterm
parameter_list|()
comment|/**/
block|{
name|struct
name|ttyinfo
name|ti
decl_stmt|;
ifdef|#
directive|ifdef
name|FIONREAD
name|long
name|val
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLOBBERS_TYPEAHEAD
ifdef|#
directive|ifdef
name|FIONREAD
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return;
endif|#
directive|endif
endif|#
directive|endif
name|inittty
argument_list|()
expr_stmt|;
name|ti
operator|=
name|shttyinfo
expr_stmt|;
ifdef|#
directive|ifdef
name|TIO
name|ti
operator|.
name|tio
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
ifdef|#
directive|ifdef
name|FLUSHO
operator||
name|FLUSHO
endif|#
directive|endif
operator|)
expr_stmt|;
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
ifdef|#
directive|ifdef
name|VDISCARD
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VDISCARD
index|]
operator|=
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSUSP
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VDSUSP
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSWTCH
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VSWTCH
index|]
operator|=
endif|#
directive|endif
name|VDISABLEVAL
expr_stmt|;
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|ti
operator|.
name|tio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|ti
operator|.
name|tio
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|INLCR
operator||
name|ICRNL
operator|)
expr_stmt|;
else|#
directive|else
name|ti
operator|.
name|sgttyb
operator|.
name|sg_flags
operator|=
operator|(
name|ti
operator|.
name|sgttyb
operator|.
name|sg_flags
operator||
name|CBREAK
operator|)
operator|&
operator|~
name|ECHO
expr_stmt|;
name|ti
operator|.
name|lmodes
operator|&=
operator|~
name|LFLUSHO
expr_stmt|;
name|ti
operator|.
name|tchars
operator|.
name|t_quitc
operator|=
name|ti
operator|.
name|ltchars
operator|.
name|t_suspc
operator|=
name|ti
operator|.
name|ltchars
operator|.
name|t_flushc
operator|=
name|ti
operator|.
name|ltchars
operator|.
name|t_dsuspc
operator|=
name|ti
operator|.
name|ltchars
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TTY_NEEDS_DRAINING
name|drainoutput
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|settyinfo
argument_list|(
operator|&
name|ti
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unsetterm
parameter_list|()
comment|/**/
block|{
name|settyinfo
argument_list|(
operator|&
name|shttyinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|kungetbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kungetct
decl_stmt|,
name|kungetsz
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ungetkey
parameter_list|(
name|ch
parameter_list|)
comment|/**/
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|kungetct
operator|==
name|kungetsz
condition|)
name|kungetbuf
operator|=
name|realloc
argument_list|(
name|kungetbuf
argument_list|,
name|kungetsz
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|kungetbuf
index|[
name|kungetct
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ungetkeys
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|s
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|ungetkey
argument_list|(
operator|*
operator|--
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|getkey
parameter_list|(
name|tmok
parameter_list|)
comment|/**/
name|int
name|tmok
decl_stmt|;
block|{
name|char
name|cc
decl_stmt|;
name|unsigned
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|die
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_SELECT
name|fd_set
name|foofd
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|kungetct
condition|)
name|ret
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|kungetbuf
index|[
operator|--
name|kungetct
index|]
expr_stmt|;
else|else
block|{
while|while
condition|(
ifdef|#
directive|ifdef
name|HAS_SELECT
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|foofd
argument_list|)
operator|,
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|foofd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
operator|||
endif|#
directive|endif
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
operator|!
name|errflag
condition|)
continue|continue;
name|errflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmok
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|3
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EIO
operator|&&
operator|!
name|die
condition|)
block|{
name|ret
operator|=
name|jobbing
expr_stmt|;
name|jobbing
operator|=
literal|1
expr_stmt|;
name|attachtty
argument_list|(
name|mypgrp
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* kludge! */
name|jobbing
operator|=
name|ret
expr_stmt|;
name|die
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|zerr
argument_list|(
literal|"error on TTY read: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|vichgflag
condition|)
block|{
if|if
condition|(
name|vichgbufptr
operator|==
name|vichgbufsz
condition|)
name|vichgbuf
operator|=
name|realloc
argument_list|(
name|vichgbuf
argument_list|,
name|vichgbufsz
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|vichgbuf
index|[
name|vichgbufptr
operator|++
index|]
operator|=
name|ret
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* read a line */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|zleread
parameter_list|(
name|ppt
parameter_list|,
name|ppt2
parameter_list|,
name|plen
parameter_list|)
comment|/**/
name|unsigned
name|char
modifier|*
name|ppt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ppt2
decl_stmt|;
name|int
name|plen
decl_stmt|;
block|{
name|int
name|z
decl_stmt|;
name|long
name|costmult
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_SELECT
name|struct
name|timeval
name|tv
decl_stmt|;
name|fd_set
name|foofd
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|intr
argument_list|()
expr_stmt|;
name|costmult
operator|=
literal|3840000L
operator|/
operator|(
operator|(
name|baud
operator|)
condition|?
name|baud
else|:
literal|2400
operator|)
expr_stmt|;
name|insmode
operator|=
name|unset
argument_list|(
name|OVERSTRIKE
argument_list|)
expr_stmt|;
name|eofsent
operator|=
literal|0
expr_stmt|;
name|resetneeded
operator|=
literal|0
expr_stmt|;
name|pmpt
operator|=
operator|(
name|char
operator|*
operator|)
name|ppt
expr_stmt|;
name|pmpt2
operator|=
operator|(
name|char
operator|*
operator|)
name|ppt2
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
name|histline
operator|=
name|curhist
expr_stmt|;
name|pptlen
operator|=
name|plen
expr_stmt|;
name|resetneeded
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_SELECT
name|FD_ZERO
argument_list|(
operator|&
name|foofd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|undoing
operator|=
literal|1
expr_stmt|;
name|line
operator|=
name|zalloc
argument_list|(
name|linesz
operator|=
literal|256
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
name|virangeflag
operator|=
name|lastcmd
operator|=
name|done
operator|=
name|cs
operator|=
name|ll
operator|=
name|mark
operator|=
literal|0
expr_stmt|;
name|curhistline
operator|=
name|NULL
expr_stmt|;
name|mult
operator|=
literal|1
expr_stmt|;
name|vibufspec
operator|=
literal|0
expr_stmt|;
name|bindtab
operator|=
name|mainbindtab
expr_stmt|;
name|addedslash
operator|=
name|vichgflag
operator|=
literal|0
expr_stmt|;
name|viinsbegin
operator|=
literal|0
expr_stmt|;
name|statusline
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|getnode
argument_list|(
name|bufstack
argument_list|)
condition|)
block|{
name|setline
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|stackcs
operator|!=
operator|-
literal|1
condition|)
block|{
name|cs
operator|=
name|stackcs
expr_stmt|;
name|stackcs
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cs
operator|>
name|ll
condition|)
name|cs
operator|=
name|ll
expr_stmt|;
block|}
if|if
condition|(
name|stackhist
operator|!=
operator|-
literal|1
condition|)
block|{
name|histline
operator|=
name|stackhist
expr_stmt|;
name|stackhist
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|initundo
argument_list|()
expr_stmt|;
if|if
condition|(
name|unset
argument_list|(
name|NOPROMPTCR
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmout
condition|)
name|alarm
argument_list|(
name|tmout
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|errflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
operator|!
name|errflag
condition|)
block|{
name|struct
name|zlecmd
modifier|*
name|zc
decl_stmt|;
name|statusline
operator|=
name|NULL
expr_stmt|;
name|bindk
operator|=
name|getkeycmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|4
operator|&&
operator|!
name|ll
condition|)
block|{
name|eofsent
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bindk
operator|!=
operator|-
literal|1
condition|)
block|{
name|zc
operator|=
name|zlecmds
operator|+
name|bindk
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lastcmd
operator|&
name|ZLE_ARG
operator|)
condition|)
name|mult
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|lastcmd
operator|&
name|ZLE_UNDO
operator|)
operator|!=
operator|(
name|zc
operator|->
name|flags
operator|&
name|ZLE_UNDO
operator|)
operator|&&
name|undoing
condition|)
name|addundo
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zc
operator|->
name|flags
operator|&
name|ZLE_MENUCMP
operator|)
condition|)
block|{
if|if
condition|(
name|menucmp
condition|)
name|freemenu
argument_list|()
expr_stmt|;
if|if
condition|(
name|addedslash
operator|&&
operator|!
operator|(
operator|(
name|zc
operator|->
name|flags
operator|&
name|ZLE_INSERT
operator|)
operator|&&
name|c
operator|!=
literal|' '
operator|)
condition|)
block|{
name|backdel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addedslash
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zc
operator|->
name|func
condition|)
call|(
modifier|*
name|zc
operator|->
name|func
call|)
argument_list|()
expr_stmt|;
name|lastcmd
operator|=
name|zc
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lastcmd
operator|&
name|ZLE_UNDO
operator|)
operator|&&
name|undoing
condition|)
name|addundo
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|errflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|HAS_SELECT
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|foofd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tv
operator|.
name|tv_usec
operator|=
name|cost
operator|*
name|costmult
operator|)
operator|>
literal|500000
condition|)
name|tv
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|kungetct
ifdef|#
directive|ifdef
name|HAS_SELECT
operator|&&
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|foofd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
operator|<=
literal|0
endif|#
directive|endif
condition|)
name|refresh
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|menucmp
condition|)
name|freemenu
argument_list|()
expr_stmt|;
name|statusline
operator|=
name|NULL
expr_stmt|;
name|trashzle
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|z
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
name|line
index|[
name|z
index|]
operator|=
literal|'\n'
expr_stmt|;
name|line
index|[
name|z
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|curhistline
condition|)
name|free
argument_list|(
name|curhistline
argument_list|)
expr_stmt|;
if|if
condition|(
name|eofsent
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
block|}
name|zleactive
operator|=
literal|0
expr_stmt|;
name|freeundo
argument_list|()
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|int
name|getkeycmd
parameter_list|()
comment|/**/
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|ret
decl_stmt|;
name|Key
name|ky
decl_stmt|;
name|t0
operator|=
literal|1
expr_stmt|;
name|cky
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getkey
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|bindtab
index|[
name|c
index|]
operator|)
operator|==
name|z_sequenceleadin
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|c
operator|)
condition|?
name|c
else|:
literal|0x80
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|buf
index|[
name|t0
operator|++
index|]
operator|=
operator|(
name|c
operator|)
condition|?
name|c
else|:
literal|0x80
expr_stmt|;
name|buf
index|[
name|t0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ky
operator|=
operator|(
name|Key
operator|)
name|gethnode
argument_list|(
name|buf
argument_list|,
name|xbindtab
argument_list|)
operator|)
condition|)
return|return
name|z_undefinedkey
return|;
if|if
condition|(
name|ky
operator|->
name|func
operator|!=
name|z_sequenceleadin
condition|)
block|{
name|cky
operator|=
name|ky
expr_stmt|;
name|ret
operator|=
name|ky
operator|->
name|func
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|z_vidigitorbeginningofline
condition|)
name|ret
operator|=
operator|(
name|lastcmd
operator|&
name|ZLE_ARG
operator|)
condition|?
name|z_digitargument
else|:
name|z_beginningofline
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|z_executenamedcmd
condition|)
name|ret
operator|=
name|executenamedcommand
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|z_executelastnamedcmd
condition|)
name|ret
operator|=
name|lastnamed
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|sendstring
parameter_list|()
comment|/**/
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|cky
condition|)
name|cky
operator|=
operator|(
name|Key
operator|)
name|gethnode
argument_list|(
name|buf
argument_list|,
name|xbindtab
argument_list|)
expr_stmt|;
name|ungetkeys
argument_list|(
name|cky
operator|->
name|str
argument_list|,
name|cky
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Key
name|makefunckey
parameter_list|(
name|fun
parameter_list|)
comment|/**/
name|int
name|fun
decl_stmt|;
block|{
name|Key
name|ky
init|=
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|ky
argument_list|)
decl_stmt|;
name|ky
operator|->
name|func
operator|=
name|fun
expr_stmt|;
return|return
name|ky
return|;
block|}
end_function

begin_comment
comment|/* initialize the bindings */
end_comment

begin_function
name|void
name|initxbindtab
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|,
name|vi
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|lastnamed
operator|=
name|z_undefinedkey
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|zgetenv
argument_list|(
literal|"VISUAL"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ztrstr
argument_list|(
name|s
argument_list|,
literal|"vi"
argument_list|)
condition|)
name|vi
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|=
name|zgetenv
argument_list|(
literal|"EDITOR"
argument_list|)
operator|)
operator|&&
name|ztrstr
argument_list|(
name|s
argument_list|,
literal|"vi"
argument_list|)
condition|)
name|vi
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vi
condition|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|32
condition|;
name|t0
operator|++
control|)
name|mainbindtab
index|[
name|t0
index|]
operator|=
name|viinsbind
index|[
name|t0
index|]
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|32
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|mainbindtab
index|[
name|t0
index|]
operator|=
name|z_selfinsert
expr_stmt|;
name|mainbindtab
index|[
literal|127
index|]
operator|=
name|z_backwarddeletechar
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|128
condition|;
name|t0
operator|++
control|)
name|mainbindtab
index|[
name|t0
index|]
operator|=
name|emacsbind
index|[
name|t0
index|]
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|128
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|mainbindtab
index|[
name|t0
index|]
operator|=
name|z_selfinsert
expr_stmt|;
block|}
for|for
control|(
name|t0
operator|=
literal|0200
init|;
name|t0
operator|!=
literal|0240
condition|;
name|t0
operator|++
control|)
name|mainbindtab
index|[
name|t0
index|]
operator|=
name|z_undefinedkey
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|128
condition|;
name|t0
operator|++
control|)
name|altbindtab
index|[
name|t0
index|]
operator|=
name|vicmdbind
index|[
name|t0
index|]
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|128
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|altbindtab
index|[
name|t0
index|]
operator|=
name|emacsbind
index|[
name|t0
index|]
expr_stmt|;
name|bindtab
operator|=
name|mainbindtab
expr_stmt|;
name|kungetbuf
operator|=
name|zalloc
argument_list|(
name|kungetsz
operator|=
literal|32
argument_list|)
expr_stmt|;
name|kungetct
operator|=
literal|0
expr_stmt|;
name|xbindtab
operator|=
name|newhtable
argument_list|(
literal|67
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\33\133C"
argument_list|,
name|makefunckey
argument_list|(
name|z_forwardchar
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\33\133D"
argument_list|,
name|makefunckey
argument_list|(
name|z_backwardchar
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\33\133A"
argument_list|,
name|makefunckey
argument_list|(
name|z_uplineorhistory
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\33\133B"
argument_list|,
name|makefunckey
argument_list|(
name|z_downlineorhistory
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30*"
argument_list|,
name|makefunckey
argument_list|(
name|z_expandword
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30g"
argument_list|,
name|makefunckey
argument_list|(
name|z_listexpand
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30G"
argument_list|,
name|makefunckey
argument_list|(
name|z_listexpand
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\16"
argument_list|,
name|makefunckey
argument_list|(
name|z_infernexthistory
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\13"
argument_list|,
name|makefunckey
argument_list|(
name|z_killbuffer
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\6"
argument_list|,
name|makefunckey
argument_list|(
name|z_vifindnextchar
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\17"
argument_list|,
name|makefunckey
argument_list|(
name|z_overwritemode
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\25"
argument_list|,
name|makefunckey
argument_list|(
name|z_undo
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\26"
argument_list|,
name|makefunckey
argument_list|(
name|z_vicmdmode
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\12"
argument_list|,
name|makefunckey
argument_list|(
name|z_vijoin
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\2"
argument_list|,
name|makefunckey
argument_list|(
name|z_vimatchbracket
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30s"
argument_list|,
name|makefunckey
argument_list|(
name|z_historyincrementalsearchforward
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30r"
argument_list|,
name|makefunckey
argument_list|(
name|z_historyincrementalsearchbackward
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30u"
argument_list|,
name|makefunckey
argument_list|(
name|z_undo
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"\30\30"
argument_list|,
name|makefunckey
argument_list|(
name|z_exchangepointandmark
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"run-help"
argument_list|,
name|mkanode
argument_list|(
name|ztrdup
argument_list|(
literal|"man"
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|aliastab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addhperm
argument_list|(
literal|"which-command"
argument_list|,
name|mkanode
argument_list|(
name|ztrdup
argument_list|(
literal|"whence"
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|aliastab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\33q"
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|128
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|emacsbind
index|[
name|t0
index|]
operator|!=
name|z_undefinedkey
condition|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
name|t0
operator|&
literal|0x7f
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|buf
argument_list|)
argument_list|,
name|makefunckey
argument_list|(
name|emacsbind
index|[
name|t0
index|]
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|36
condition|;
name|t0
operator|++
control|)
name|vibuf
index|[
name|t0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|26
condition|;
name|t0
operator|++
control|)
name|vimarkline
index|[
name|t0
index|]
operator|=
literal|0
expr_stmt|;
name|stackhist
operator|=
name|stackcs
operator|=
operator|-
literal|1
expr_stmt|;
name|vichgbufsz
operator|=
literal|0
expr_stmt|;
name|vichgbuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|getkeystring
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|buf
decl_stmt|;
name|int
name|x
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|,
name|metanext
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
condition|)
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'a'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\07'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\010'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
name|metanext
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
name|x
operator|=
name|x
operator|*
literal|8
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
operator|*
name|t
operator|++
operator|=
name|x
expr_stmt|;
block|}
else|else
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'^'
condition|)
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'?'
condition|)
operator|*
name|t
operator|++
operator|=
literal|0x7f
expr_stmt|;
else|else
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|&
literal|0x9f
expr_stmt|;
else|else
operator|*
name|t
operator|++
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|metanext
operator|&&
operator|!
operator|(
operator|--
name|metanext
operator|)
condition|)
block|{
name|t
index|[
operator|-
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
name|metanext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|>
name|buf
operator|+
literal|500
condition|)
break|break;
name|first
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|len
operator|=
name|t
operator|-
name|buf
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|printbind
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|&
literal|0x80
condition|)
block|{
name|printf
argument_list|(
literal|"\\M-"
argument_list|)
expr_stmt|;
name|ch
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|icntrl
argument_list|(
name|ch
argument_list|)
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x7f
case|:
name|printf
argument_list|(
literal|"^?"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"^%c"
argument_list|,
operator|(
name|ch
operator||
literal|0x40
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|printbinding
parameter_list|(
name|str
parameter_list|,
name|k
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
name|Key
name|k
decl_stmt|;
block|{
if|if
condition|(
name|k
operator|->
name|func
operator|==
name|z_sequenceleadin
condition|)
return|return;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|printbind
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|func
operator|==
name|z_sendstring
condition|)
block|{
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|printbind
argument_list|(
name|k
operator|->
name|str
argument_list|,
name|k
operator|->
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zlecmds
index|[
name|k
operator|->
name|func
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bin_bindkey
parameter_list|(
name|name
parameter_list|,
name|argv
parameter_list|,
name|ops
parameter_list|,
name|junc
parameter_list|)
comment|/**/
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
name|int
name|junc
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|func
decl_stmt|,
modifier|*
name|tab
decl_stmt|;
name|tab
operator|=
operator|(
name|ops
index|[
literal|'a'
index|]
operator|)
condition|?
name|altbindtab
else|:
name|mainbindtab
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'v'
index|]
operator|||
name|ops
index|[
literal|'e'
index|]
operator|||
name|ops
index|[
literal|'d'
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"too many arguments"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ops
index|[
literal|'d'
index|]
operator|||
name|ops
index|[
literal|'e'
index|]
condition|)
if|if
condition|(
name|ops
index|[
literal|'m'
index|]
condition|)
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|tab
index|[
name|t0
index|]
operator|=
name|emacsbind
index|[
name|t0
index|]
expr_stmt|;
else|else
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|128
condition|;
name|t0
operator|++
control|)
name|tab
index|[
name|t0
index|]
operator|=
name|emacsbind
index|[
name|t0
index|]
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|128
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|tab
index|[
name|t0
index|]
operator|=
name|z_selfinsert
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|32
condition|;
name|t0
operator|++
control|)
name|mainbindtab
index|[
name|t0
index|]
operator|=
name|viinsbind
index|[
name|t0
index|]
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|32
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|mainbindtab
index|[
name|t0
index|]
operator|=
name|z_selfinsert
expr_stmt|;
name|mainbindtab
index|[
literal|127
index|]
operator|=
name|z_backwarddeletechar
expr_stmt|;
block|}
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|128
condition|;
name|t0
operator|++
control|)
name|altbindtab
index|[
name|t0
index|]
operator|=
name|vicmdbind
index|[
name|t0
index|]
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|128
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
name|altbindtab
index|[
name|t0
index|]
operator|=
name|emacsbind
index|[
name|t0
index|]
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0200
init|;
name|t0
operator|!=
literal|0240
condition|;
name|t0
operator|++
control|)
name|tab
index|[
name|t0
index|]
operator|=
name|z_undefinedkey
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'x'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|256
condition|;
name|t0
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|printbind
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t0
operator|<
literal|254
operator|&&
name|tab
index|[
name|t0
index|]
operator|==
name|tab
index|[
name|t0
operator|+
literal|1
index|]
operator|&&
name|tab
index|[
name|t0
index|]
operator|==
name|tab
index|[
name|t0
operator|+
literal|2
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"\" to \""
argument_list|)
expr_stmt|;
while|while
condition|(
name|tab
index|[
name|t0
index|]
operator|==
name|tab
index|[
name|t0
operator|+
literal|1
index|]
condition|)
name|t0
operator|++
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|t0
expr_stmt|;
name|printbind
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\"\t%s\n"
argument_list|,
name|zlecmds
index|[
name|tab
index|[
name|t0
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|listhtable
argument_list|(
name|xbindtab
argument_list|,
operator|(
name|HFunc
operator|)
name|printbinding
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|*
name|argv
condition|)
block|{
name|s
operator|=
name|getkeystring
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|8
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"in-string too long"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
operator|||
name|ops
index|[
literal|'r'
index|]
condition|)
block|{
name|Key
name|ky
decl_stmt|;
name|ky
operator|=
name|gethnode
argument_list|(
name|s
argument_list|,
name|xbindtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
name|func
operator|=
name|tab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
expr_stmt|;
else|else
name|func
operator|=
operator|(
name|ky
operator|)
condition|?
name|ky
operator|->
name|func
else|:
name|z_undefinedkey
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|z_undefinedkey
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"in-string is not bound"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ops
index|[
literal|'r'
index|]
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
condition|)
name|tab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|=
name|z_undefinedkey
expr_stmt|;
else|else
block|{
while|while
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|remhnode
argument_list|(
name|s
argument_list|,
name|xbindtab
argument_list|)
argument_list|)
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|func
operator|==
name|z_sendstring
condition|)
block|{
name|printbind
argument_list|(
name|ky
operator|->
name|str
argument_list|,
name|ky
operator|->
name|len
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|zlecmds
index|[
name|func
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ops
index|[
literal|'s'
index|]
condition|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|ZLECMDCOUNT
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|zlecmds
index|[
name|t0
index|]
operator|.
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|t0
operator|==
name|ZLECMDCOUNT
condition|)
block|{
name|zerr
argument_list|(
literal|"undefined function: %s"
argument_list|,
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|func
operator|=
name|t0
expr_stmt|;
block|}
else|else
name|func
operator|=
name|z_sendstring
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|Key
name|ky
decl_stmt|;
name|tab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|=
operator|(
name|ops
index|[
literal|'s'
index|]
operator|)
condition|?
name|z_sendstring
else|:
name|t0
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'s'
index|]
condition|)
block|{
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|s
argument_list|)
argument_list|,
name|ky
operator|=
name|makefunckey
argument_list|(
name|z_sendstring
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|freekey
argument_list|)
expr_stmt|;
name|ky
operator|->
name|str
operator|=
name|ztrdup
argument_list|(
name|getkeystring
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ky
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|t1
decl_stmt|;
name|Key
name|ky
decl_stmt|;
if|if
condition|(
name|tab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|!=
name|z_undefinedkey
operator|&&
name|tab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|!=
name|z_sequenceleadin
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"in-string has already bound prefix"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|tab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
operator|=
name|z_sequenceleadin
expr_stmt|;
if|if
condition|(
operator|!
name|s
index|[
literal|1
index|]
condition|)
name|s
index|[
literal|1
index|]
operator|=
literal|0x80
expr_stmt|;
for|for
control|(
name|t1
operator|=
literal|1
init|;
name|t1
operator|!=
name|len
operator|-
literal|1
condition|;
name|t1
operator|++
control|)
block|{
name|char
name|sav
decl_stmt|;
name|sav
operator|=
name|s
index|[
name|t1
operator|+
literal|1
index|]
expr_stmt|;
name|s
index|[
name|t1
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ky
operator|=
name|gethnode
argument_list|(
name|s
argument_list|,
name|xbindtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|ky
operator|&&
name|ky
operator|->
name|func
operator|!=
name|z_sequenceleadin
condition|)
block|{
name|zerrnam
argument_list|(
name|name
argument_list|,
literal|"in-string has already bound prefix"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|ky
condition|)
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|s
argument_list|)
argument_list|,
name|makefunckey
argument_list|(
name|z_sequenceleadin
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|freekey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sav
condition|)
name|sav
operator|=
literal|0x80
expr_stmt|;
name|s
index|[
name|t1
operator|+
literal|1
index|]
operator|=
name|sav
expr_stmt|;
block|}
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|s
argument_list|)
argument_list|,
name|ky
operator|=
name|makefunckey
argument_list|(
name|func
argument_list|)
argument_list|,
name|xbindtab
argument_list|,
name|freekey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
index|[
literal|'s'
index|]
condition|)
name|ky
operator|->
name|str
operator|=
name|ztrdup
argument_list|(
name|getkeystring
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ky
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|freekey
parameter_list|(
name|x
parameter_list|)
comment|/**/
name|vptr
name|x
decl_stmt|;
block|{
name|Key
name|k
init|=
name|x
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|str
condition|)
name|free
argument_list|(
name|k
operator|->
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this is mostly stolen from bash's draino() */
end_comment

begin_function
name|void
name|drainoutput
parameter_list|()
comment|/**/
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|baud
condition|)
return|return;
ifdef|#
directive|ifdef
name|TIOCOUTQ
ifdef|#
directive|ifdef
name|HAS_SELECT
while|while
condition|(
operator|(
name|ioctl
argument_list|(
name|SHTTY
argument_list|,
name|TIOCOUTQ
argument_list|,
operator|&
name|n
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
name|n
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|n
operator|/
name|baud
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
name|n
operator|%
name|baud
operator|)
operator|*
literal|1000000
operator|)
operator|/
name|baud
expr_stmt|;
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

end_unit

