begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * zle_tricky.c - expansion and completion  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_define
define|#
directive|define
name|ZLE
end_define

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|we
decl_stmt|,
name|wb
decl_stmt|,
name|usemenu
decl_stmt|,
name|useglob
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|menub
decl_stmt|,
name|menue
decl_stmt|,
name|menuw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Lklist
name|menulist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Lknode
name|menunode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|inststr
parameter_list|(
name|X
parameter_list|)
value|inststrlen((X),-1)
end_define

begin_function
name|int
name|usetab
parameter_list|()
comment|/**/
block|{
name|unsigned
name|char
modifier|*
name|s
init|=
name|line
operator|+
name|cs
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|s
operator|>=
name|line
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|;
name|s
operator|--
control|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\t'
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|COMP_COMPLETE
value|0
end_define

begin_define
define|#
directive|define
name|COMP_LIST_COMPLETE
value|1
end_define

begin_define
define|#
directive|define
name|COMP_SPELL
value|2
end_define

begin_define
define|#
directive|define
name|COMP_EXPAND
value|3
end_define

begin_define
define|#
directive|define
name|COMP_EXPAND_COMPLETE
value|4
end_define

begin_define
define|#
directive|define
name|COMP_LIST_EXPAND
value|5
end_define

begin_define
define|#
directive|define
name|COMP_ISEXPAND
parameter_list|(
name|X
parameter_list|)
value|((X)>= COMP_EXPAND)
end_define

begin_function
name|void
name|completeword
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
name|isset
argument_list|(
name|MENUCOMPLETE
argument_list|)
operator|||
operator|(
name|useglob
operator|=
name|isset
argument_list|(
name|GLOBCOMPLETE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|&&
name|usetab
argument_list|()
condition|)
name|selfinsert
argument_list|()
expr_stmt|;
else|else
name|docomplete
argument_list|(
name|COMP_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|menucompleteword
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
literal|1
expr_stmt|;
name|useglob
operator|=
name|isset
argument_list|(
name|GLOBCOMPLETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|&&
name|usetab
argument_list|()
condition|)
name|selfinsert
argument_list|()
expr_stmt|;
else|else
name|docomplete
argument_list|(
name|COMP_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listchoices
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
name|isset
argument_list|(
name|MENUCOMPLETE
argument_list|)
operator|||
operator|(
name|useglob
operator|=
name|isset
argument_list|(
name|GLOBCOMPLETE
argument_list|)
operator|)
expr_stmt|;
name|docomplete
argument_list|(
name|COMP_LIST_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spellword
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
name|useglob
operator|=
literal|0
expr_stmt|;
name|docomplete
argument_list|(
name|COMP_SPELL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deletecharorlist
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
name|isset
argument_list|(
name|MENUCOMPLETE
argument_list|)
operator|||
operator|(
name|useglob
operator|=
name|isset
argument_list|(
name|GLOBCOMPLETE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cs
operator|!=
name|ll
condition|)
name|deletechar
argument_list|()
expr_stmt|;
else|else
name|docomplete
argument_list|(
name|COMP_LIST_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expandword
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
name|useglob
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|&&
name|usetab
argument_list|()
condition|)
name|selfinsert
argument_list|()
expr_stmt|;
else|else
name|docomplete
argument_list|(
name|COMP_EXPAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expandorcomplete
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
name|isset
argument_list|(
name|MENUCOMPLETE
argument_list|)
operator|||
operator|(
name|useglob
operator|=
name|isset
argument_list|(
name|GLOBCOMPLETE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|&&
name|usetab
argument_list|()
condition|)
name|selfinsert
argument_list|()
expr_stmt|;
else|else
name|docomplete
argument_list|(
name|COMP_EXPAND_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|menuexpandorcomplete
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
literal|1
expr_stmt|;
name|useglob
operator|=
name|isset
argument_list|(
name|GLOBCOMPLETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|&&
name|usetab
argument_list|()
condition|)
name|selfinsert
argument_list|()
expr_stmt|;
else|else
name|docomplete
argument_list|(
name|COMP_EXPAND_COMPLETE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|listexpand
parameter_list|()
comment|/**/
block|{
name|usemenu
operator|=
name|isset
argument_list|(
name|MENUCOMPLETE
argument_list|)
expr_stmt|;
name|useglob
operator|=
name|isset
argument_list|(
name|GLOBCOMPLETE
argument_list|)
expr_stmt|;
name|docomplete
argument_list|(
name|COMP_LIST_EXPAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reversemenucomplete
parameter_list|()
comment|/**/
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|menucmp
condition|)
name|menucompleteword
argument_list|()
expr_stmt|;
comment|/* better than just feep'ing, pem */
if|if
condition|(
operator|!
name|menucmp
condition|)
return|return;
name|cs
operator|=
name|menub
expr_stmt|;
name|foredel
argument_list|(
name|menue
operator|-
name|menub
argument_list|)
expr_stmt|;
if|if
condition|(
name|menunode
operator|==
name|firstnode
argument_list|(
name|menulist
argument_list|)
condition|)
name|menunode
operator|=
name|lastnode
argument_list|(
name|menulist
argument_list|)
expr_stmt|;
else|else
name|menunode
operator|=
name|prevnode
argument_list|(
name|menunode
argument_list|)
expr_stmt|;
name|inststr
argument_list|(
name|s
operator|=
name|menunode
operator|->
name|dat
argument_list|)
expr_stmt|;
name|menue
operator|=
name|cs
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Accepts the current completion and starts a new arg,  * with the next completions. This gives you a way to accept  * several selections from the list of matches.  */
end_comment

begin_function
name|void
name|acceptandmenucomplete
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|,
name|t1
decl_stmt|;
if|if
condition|(
operator|!
name|menucmp
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
return|return;
block|}
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|spaceinline
argument_list|(
name|menub
operator|-
name|menuw
argument_list|)
expr_stmt|;
name|t1
operator|=
name|cs
expr_stmt|;
for|for
control|(
name|t0
operator|=
name|menuw
init|;
name|t0
operator|!=
name|menub
condition|;
name|t0
operator|++
control|)
name|line
index|[
name|cs
operator|++
index|]
operator|=
name|line
index|[
name|t0
index|]
expr_stmt|;
name|menue
operator|=
name|menub
operator|=
name|cs
expr_stmt|;
name|menuw
operator|=
name|t1
expr_stmt|;
name|menucompleteword
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastmenu
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastmenupos
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lincmd
decl_stmt|,
name|linredir
decl_stmt|,
name|lastambig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cmdstr
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|docomplete
parameter_list|(
name|lst
parameter_list|)
comment|/**/
name|int
name|lst
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|AUTOMENU
argument_list|)
operator|&&
operator|!
name|menucmp
operator|&&
name|c
operator|==
literal|'\t'
operator|&&
operator|(
name|lastcmd
operator|&
name|ZLE_MENUCMP
operator|)
operator|&&
name|lastambig
condition|)
name|usemenu
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|menucmp
condition|)
block|{
name|do_menucmp
argument_list|(
name|lst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|doexpandhist
argument_list|()
condition|)
return|return;
name|s
operator|=
name|get_comp_string
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|lst
operator|==
name|COMP_EXPAND_COMPLETE
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
name|Tilde
condition|)
name|q
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
name|Equals
condition|)
block|{
name|q
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|gethnode
argument_list|(
name|q
argument_list|,
name|cmdnamtab
argument_list|)
operator|||
name|hashcmd
argument_list|(
name|q
argument_list|,
name|pathchecked
argument_list|)
condition|)
name|lst
operator|=
name|COMP_EXPAND
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
name|String
condition|;
name|q
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
name|String
operator|&&
name|q
index|[
literal|1
index|]
operator|!=
name|Inpar
condition|)
block|{
if|if
condition|(
name|getsparam
argument_list|(
name|q
operator|+
literal|1
argument_list|)
condition|)
name|lst
operator|=
name|COMP_EXPAND
expr_stmt|;
else|else
name|lst
operator|=
name|COMP_COMPLETE
expr_stmt|;
block|}
name|q
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|lst
operator|==
name|COMP_EXPAND_COMPLETE
condition|)
block|{
for|for
control|(
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|itok
argument_list|(
operator|*
name|q
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|q
condition|)
name|lst
operator|=
name|COMP_COMPLETE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lst
operator|==
name|COMP_SPELL
condition|)
block|{
name|char
modifier|*
modifier|*
name|x
init|=
operator|&
name|s
decl_stmt|;
name|untokenize
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cs
operator|=
name|wb
expr_stmt|;
name|foredel
argument_list|(
name|we
operator|-
name|wb
argument_list|)
expr_stmt|;
comment|/* call the real spell checker, ash@aaii.oz.zu */
name|spckword
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|!
name|lincmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inststr
argument_list|(
operator|*
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|COMP_ISEXPAND
argument_list|(
name|lst
argument_list|)
condition|)
name|doexpansion
argument_list|(
name|s
argument_list|,
name|lst
argument_list|,
name|lincmd
argument_list|)
expr_stmt|;
else|else
block|{
name|docompletion
argument_list|(
name|s
argument_list|,
name|lst
argument_list|,
name|lincmd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|popheap
argument_list|()
expr_stmt|;
name|lexrestore
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_menucmp
parameter_list|(
name|lst
parameter_list|)
comment|/**/
name|int
name|lst
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|LASTMENU
argument_list|)
operator|&&
name|lastmenu
condition|)
block|{
if|if
condition|(
name|COMP_ISEXPAND
argument_list|(
name|lst
argument_list|)
operator|||
name|cs
operator|!=
name|lastmenupos
operator|||
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|,
name|lastmenu
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|lastmenu
argument_list|)
expr_stmt|;
name|lastmenu
operator|=
name|NULL
expr_stmt|;
name|lastmenupos
operator|=
operator|-
literal|1
expr_stmt|;
name|freemenu
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lst
operator|==
name|COMP_LIST_COMPLETE
condition|)
block|{
name|listmatches
argument_list|(
name|menulist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|cs
operator|=
name|menub
expr_stmt|;
name|foredel
argument_list|(
name|menue
operator|-
name|menub
argument_list|)
expr_stmt|;
name|incnode
argument_list|(
name|menunode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menunode
condition|)
name|menunode
operator|=
name|firstnode
argument_list|(
name|menulist
argument_list|)
expr_stmt|;
name|s
operator|=
name|menunode
operator|->
name|dat
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|inststr
argument_list|(
name|s
operator|=
name|menunode
operator|->
name|dat
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|LASTMENU
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastmenu
condition|)
name|free
argument_list|(
name|lastmenu
argument_list|)
expr_stmt|;
name|lastmenu
operator|=
name|ztrdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|lastmenupos
operator|=
name|cs
expr_stmt|;
block|}
name|menue
operator|=
name|cs
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_comp_string
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|linptr
decl_stmt|;
name|linptr
operator|=
name|line
expr_stmt|;
name|start
label|:
name|lincmd
operator|=
name|incmdpos
expr_stmt|;
name|linredir
operator|=
name|inredir
expr_stmt|;
name|cmdstr
operator|=
name|NULL
expr_stmt|;
name|zleparse
operator|=
literal|1
expr_stmt|;
name|lexsave
argument_list|()
expr_stmt|;
name|hungets
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* KLUDGE! */
name|hungets
argument_list|(
name|linptr
argument_list|)
expr_stmt|;
name|strinbeg
argument_list|()
expr_stmt|;
name|pushheap
argument_list|()
expr_stmt|;
do|do
block|{
name|lincmd
operator|=
name|incmdpos
expr_stmt|;
name|linredir
operator|=
name|inredir
expr_stmt|;
name|ctxtlex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|ENDINPUT
condition|)
break|break;
if|if
condition|(
name|lincmd
operator|&&
name|tok
operator|==
name|STRING
condition|)
name|cmdstr
operator|=
name|strdup
argument_list|(
name|tokstr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|!=
name|ENDINPUT
operator|&&
name|zleparse
condition|)
do|;
name|t0
operator|=
name|tok
expr_stmt|;
if|if
condition|(
name|t0
operator|==
name|ENDINPUT
condition|)
block|{
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ztrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|we
operator|=
name|wb
operator|=
name|cs
expr_stmt|;
name|t0
operator|=
name|STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t0
operator|==
name|STRING
condition|)
block|{
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ztrdup
argument_list|(
name|tokstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t0
operator|==
name|ENVSTRING
condition|)
block|{
for|for
control|(
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tokstr
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
operator|(
name|unsigned
name|char
operator|)
literal|'='
condition|;
name|s
operator|++
operator|,
name|wb
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|wb
operator|++
expr_stmt|;
name|t0
operator|=
name|STRING
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ztrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|lincmd
operator|=
literal|1
expr_stmt|;
block|}
name|hflush
argument_list|()
expr_stmt|;
name|strinend
argument_list|()
expr_stmt|;
name|errflag
operator|=
name|zleparse
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|we
operator|>
name|ll
condition|)
name|we
operator|=
name|ll
expr_stmt|;
if|if
condition|(
name|t0
operator|==
name|LEXERR
operator|&&
name|parbegin
operator|!=
operator|-
literal|1
condition|)
block|{
name|linptr
operator|+=
name|ll
operator|+
literal|1
operator|-
name|parbegin
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
name|lexrestore
argument_list|()
expr_stmt|;
goto|goto
name|start
goto|;
block|}
if|if
condition|(
name|t0
operator|!=
name|STRING
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

begin_function
name|void
name|doexpansion
parameter_list|(
name|s
parameter_list|,
name|lst
parameter_list|,
name|lincmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|lst
decl_stmt|;
name|int
name|lincmd
decl_stmt|;
block|{
name|Lklist
name|vl
init|=
name|newlist
argument_list|()
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
name|pushheap
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|vl
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|prefork
argument_list|(
name|vl
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
goto|goto
name|end
goto|;
name|postfork
argument_list|(
name|vl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|full
argument_list|(
name|vl
argument_list|)
operator|||
operator|!
operator|*
operator|(
name|char
operator|*
operator|)
name|peekfirst
argument_list|(
name|vl
argument_list|)
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|lst
operator|==
name|COMP_LIST_EXPAND
condition|)
block|{
name|listmatches
argument_list|(
name|vl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|peekfirst
argument_list|(
name|vl
argument_list|)
operator|==
name|s
condition|)
block|{
if|if
condition|(
name|lst
operator|==
name|COMP_EXPAND_COMPLETE
condition|)
block|{
name|docompletion
argument_list|(
name|s
argument_list|,
name|COMP_COMPLETE
argument_list|,
name|lincmd
argument_list|)
expr_stmt|;
block|}
else|else
name|feep
argument_list|()
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|cs
operator|=
name|wb
expr_stmt|;
name|foredel
argument_list|(
name|we
operator|-
name|wb
argument_list|)
expr_stmt|;
while|while
condition|(
name|ss
operator|=
name|ugetnode
argument_list|(
name|vl
argument_list|)
condition|)
block|{
name|untokenize
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|inststr
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (full(vl)) { 			spaceinline(1); 			line[cs++] = ' '; 		}
endif|#
directive|endif
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|end
label|:
name|popheap
argument_list|()
expr_stmt|;
name|setterm
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gotword
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|we
operator|=
name|ll
operator|+
literal|1
operator|-
name|inbufct
expr_stmt|;
if|if
condition|(
name|cs
operator|<=
name|we
condition|)
block|{
name|wb
operator|=
name|ll
operator|-
name|wordbeg
expr_stmt|;
name|zleparse
operator|=
literal|0
expr_stmt|;
comment|/* major hack ahead */
if|if
condition|(
name|wb
operator|&&
name|line
index|[
name|wb
index|]
operator|==
literal|'!'
operator|&&
name|line
index|[
name|wb
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|wb
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|inststrlen
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|t
operator|=
name|halloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|u
operator|=
name|s
expr_stmt|;
name|v
operator|=
name|t
expr_stmt|;
for|for
control|(
init|;
operator|*
name|u
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|l
operator|--
condition|)
break|break;
if|if
condition|(
name|ispecial
argument_list|(
operator|*
name|u
argument_list|)
condition|)
if|if
condition|(
operator|*
name|u
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|v
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|v
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|v
operator|++
operator|=
literal|'\''
expr_stmt|;
continue|continue;
block|}
else|else
operator|*
name|v
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|v
operator|++
operator|=
operator|*
name|u
expr_stmt|;
block|}
operator|*
name|v
operator|=
literal|'\0'
expr_stmt|;
name|spaceinline
argument_list|(
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
operator|+
name|cs
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ambig
decl_stmt|,
name|haspath
decl_stmt|,
name|exact
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Lklist
name|matches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pat
decl_stmt|,
modifier|*
name|exactstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typechar
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|addmatch
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|full
argument_list|(
name|matches
argument_list|)
condition|)
block|{
name|int
name|y
init|=
name|pfxlen
argument_list|(
name|peekfirst
argument_list|(
name|matches
argument_list|)
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|<
name|ambig
condition|)
name|ambig
operator|=
name|y
expr_stmt|;
block|}
else|else
name|ambig
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pat
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|exact
operator|=
literal|1
expr_stmt|;
name|exactstr
operator|=
name|pat
expr_stmt|;
block|}
name|addnodeinorder
argument_list|(
name|matches
argument_list|,
name|strdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|addcmdmatch
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|s
argument_list|)
condition|)
name|addmatch
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|addcmddirparam
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|Param
name|pm
init|=
operator|(
name|Param
operator|)
name|t
decl_stmt|;
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|s
argument_list|)
operator|&&
name|pmtype
argument_list|(
name|pm
argument_list|)
operator|==
name|PMFLAG_s
condition|)
block|{
name|t
operator|=
name|pm
operator|->
name|gets
operator|.
name|cfn
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
operator|*
name|t
operator|==
literal|'/'
condition|)
name|addmatch
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|addcmdnodis
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|s
argument_list|)
operator|&&
operator|(
operator|(
name|Cmdnam
operator|)
name|t
operator|)
operator|->
name|type
operator|!=
name|DISABLED
condition|)
name|addmatch
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|maketildelist
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|int
name|len
decl_stmt|;
name|s
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|addmatch
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|errflag
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|addmatch
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * opendir that handles '~' and '=' and '$'.  * orig. by ash@aaii.oz.au, mod. by pf  */
end_comment

begin_function
name|DIR
modifier|*
name|OPENDIR
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'~'
operator|&&
operator|*
name|s
operator|!=
literal|'='
operator|&&
operator|*
name|s
operator|!=
literal|'$'
condition|)
return|return
operator|(
name|opendir
argument_list|(
name|s
argument_list|)
operator|)
return|;
name|s
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|==
literal|'='
operator|)
condition|?
name|Equals
else|:
operator|(
operator|*
name|s
operator|==
literal|'~'
operator|)
condition|?
name|Tilde
else|:
name|String
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|opendir
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dirname
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
name|s
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|==
literal|'='
operator|)
condition|?
name|Equals
else|:
operator|(
operator|*
name|s
operator|==
literal|'~'
operator|)
condition|?
name|Tilde
else|:
name|String
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|int
name|Isdir
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|S_ISDIR
argument_list|(
name|sbuf
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* this will work whether s is tokenized or not */
end_comment

begin_function
name|int
name|isdir
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|typechar
operator|!=
literal|'$'
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|(
name|s
operator|)
condition|?
name|s
else|:
literal|"."
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$%s"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'~'
operator|&&
operator|*
name|s
operator|!=
literal|'='
operator|&&
operator|*
name|s
operator|!=
name|Tilde
operator|&&
operator|*
name|s
operator|!=
name|Equals
operator|&&
operator|*
name|s
operator|!=
literal|'$'
operator|&&
operator|*
name|s
operator|!=
name|String
condition|)
return|return
operator|(
name|Isdir
argument_list|(
name|s
argument_list|)
operator|)
return|;
name|s
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
operator|*
name|s
operator|=
operator|(
operator|*
name|s
operator|==
literal|'='
operator|)
condition|?
name|Equals
else|:
operator|(
operator|*
name|s
operator|==
literal|'~'
operator|)
condition|?
name|Tilde
else|:
name|String
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|Isdir
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SLASH_YES
value|0
end_define

begin_define
define|#
directive|define
name|SLASH_NO
value|1
end_define

begin_define
define|#
directive|define
name|SLASH_MAYBE
value|2
end_define

begin_decl_stmt
name|int
name|slashflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|addedstar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pathprefix
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|docompletion
parameter_list|(
name|s
parameter_list|,
name|lst
parameter_list|,
name|incmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|lst
decl_stmt|;
name|int
name|incmd
decl_stmt|;
block|{
name|char
modifier|*
name|tokorigs
decl_stmt|;
name|char
modifier|*
name|origs
decl_stmt|;
name|Compctl
name|cc
decl_stmt|;
name|char
modifier|*
name|pfx
init|=
name|s
decl_stmt|;
name|slashflag
operator|=
name|SLASH_MAYBE
expr_stmt|;
name|addedstar
operator|=
literal|0
expr_stmt|;
name|lastambig
operator|=
literal|0
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
name|pushheap
argument_list|()
expr_stmt|;
if|if
condition|(
name|useglob
condition|)
name|tokorigs
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|untokenize
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|origs
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|matches
operator|=
name|newlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|incmd
condition|)
name|cc
operator|=
operator|&
name|cc_compos
expr_stmt|;
elseif|else
if|if
condition|(
name|linredir
operator|||
operator|!
operator|(
name|cmdstr
operator|&&
operator|(
name|cc
operator|=
name|gethnode
argument_list|(
name|cmdstr
argument_list|,
name|compctltab
argument_list|)
operator|)
operator|)
condition|)
name|cc
operator|=
operator|&
name|cc_default
expr_stmt|;
name|exact
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|mask
operator|&
name|CC_COMMPATH
condition|)
name|gen_matches_reg
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|(
name|cc
operator|->
name|mask
operator|&
name|CC_FILES
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cc
operator|->
name|mask
operator|&
name|CC_FILES
condition|)
name|gen_matches_reg
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|haspath
operator|=
literal|0
expr_stmt|;
name|slashflag
operator|=
name|SLASH_NO
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|->
name|mask
operator|&
operator|(
name|CC_FILES
operator||
name|CC_COMMPATH
operator|)
condition|)
block|{
comment|/* only do "globbed" completion if regular completion fails. 		   pem, 7Oct91 */
if|if
condition|(
operator|(
operator|!
name|full
argument_list|(
name|matches
argument_list|)
operator|||
name|errflag
operator|)
operator|&&
name|useglob
condition|)
block|{
name|gen_matches_glob
argument_list|(
name|tokorigs
argument_list|,
name|incmd
argument_list|)
expr_stmt|;
comment|/* 		     * gen_matches_glob changes the insert line to be correct up 		     * to the match, so the prefix string must be "". ash, 7Oct91 		     */
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|pat
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|->
name|mask
operator|&
name|CC_HOSTS
operator|)
operator|&&
operator|!
name|haspath
condition|)
block|{
name|char
modifier|*
modifier|*
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|hosts
init|;
operator|*
name|x
condition|;
name|x
operator|++
control|)
name|addcmdmatch
argument_list|(
operator|*
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc
operator|->
name|mask
operator|&
name|CC_OPTIONS
operator|)
operator|&&
operator|!
name|haspath
condition|)
block|{
name|struct
name|option
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|optns
init|;
name|o
operator|->
name|name
condition|;
name|o
operator|++
control|)
name|addcmdmatch
argument_list|(
name|o
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc
operator|->
name|mask
operator|&
name|CC_VARS
operator|)
operator|&&
operator|!
name|haspath
condition|)
name|listhtable
argument_list|(
name|paramtab
argument_list|,
name|addcmdmatch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|->
name|mask
operator|&
name|CC_BINDINGS
operator|)
operator|&&
operator|!
name|haspath
condition|)
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|ZLECMDCOUNT
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|*
name|zlecmds
index|[
name|t0
index|]
operator|.
name|name
condition|)
name|addcmdmatch
argument_list|(
name|zlecmds
index|[
name|t0
index|]
operator|.
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|->
name|mask
operator|&
name|CC_USRKEYS
condition|)
block|{
name|char
modifier|*
modifier|*
name|usr
init|=
name|get_user_var
argument_list|(
name|cc
operator|->
name|keyvar
argument_list|)
decl_stmt|;
if|if
condition|(
name|usr
condition|)
while|while
condition|(
operator|*
name|usr
condition|)
name|addcmdmatch
argument_list|(
operator|*
name|usr
operator|++
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lst
operator|!=
name|COMP_LIST_COMPLETE
condition|)
name|do_fignore
argument_list|(
name|origs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|full
argument_list|(
name|matches
argument_list|)
operator|||
name|errflag
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lst
operator|==
name|COMP_LIST_COMPLETE
condition|)
block|{
name|listmatches
argument_list|(
name|matches
argument_list|,
name|unset
argument_list|(
name|LISTTYPES
argument_list|)
condition|?
name|NULL
else|:
operator|(
name|haspath
operator|)
condition|?
name|pathprefix
else|:
literal|"./"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|matches
argument_list|)
argument_list|)
condition|)
block|{
name|do_ambiguous
argument_list|(
name|pfx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_single
argument_list|(
name|pfx
argument_list|)
expr_stmt|;
block|}
name|ll
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
name|setterm
argument_list|()
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|get_user_var
parameter_list|(
name|nam
parameter_list|)
comment|/**/
name|char
modifier|*
name|nam
decl_stmt|;
block|{
return|return
operator|(
name|nam
operator|)
condition|?
name|getaparam
argument_list|(
name|nam
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|gen_matches_glob
parameter_list|(
name|s
parameter_list|,
name|incmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|incmd
decl_stmt|;
block|{
name|char
modifier|*
name|pt
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|int
name|hasp
init|=
literal|0
decl_stmt|;
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
comment|/* 	 * Find the longest prefix string without any 	 * chars special to glob - ash. 	 */
for|for
control|(
name|pt
operator|=
name|s
init|;
operator|*
name|pt
condition|;
name|pt
operator|++
control|)
block|{
if|if
condition|(
name|pt
operator|==
name|s
operator|&&
operator|(
operator|*
name|pt
operator|==
name|Tilde
operator|||
operator|*
name|pt
operator|==
name|Equals
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ispecial
argument_list|(
operator|*
name|pt
argument_list|)
operator|||
name|itok
argument_list|(
operator|*
name|pt
argument_list|)
condition|)
break|break;
block|}
for|for
control|(
init|;
name|pt
operator|>
name|s
operator|&&
operator|*
name|pt
operator|!=
literal|'/'
condition|;
name|pt
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|pt
operator|==
literal|'/'
condition|)
block|{
operator|*
name|pt
operator|=
literal|0
expr_stmt|;
name|u
operator|=
name|pt
operator|+
literal|1
expr_stmt|;
name|wb
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|hasp
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|u
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|hasp
operator|&&
operator|(
operator|*
name|s
operator|==
name|Tilde
operator|||
operator|*
name|s
operator|==
name|Equals
operator|)
condition|)
block|{
comment|/* string contains only ~xx, so do tilde expansion */
name|maketildelist
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wb
operator|++
expr_stmt|;
name|pathprefix
operator|=
name|s
expr_stmt|;
name|slashflag
operator|=
name|SLASH_YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incmd
operator|&&
operator|!
name|hasp
condition|)
block|{
name|slashflag
operator|=
name|SLASH_NO
expr_stmt|;
name|pat
operator|=
name|s
expr_stmt|;
name|listhtable
argument_list|(
name|aliastab
argument_list|,
name|addcmdmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|HASHLISTALL
argument_list|)
condition|)
name|fullhash
argument_list|()
expr_stmt|;
name|listhtable
argument_list|(
name|cmdnamtab
argument_list|,
name|addcmdnodis
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|AUTOCD
argument_list|)
condition|)
name|listhtable
argument_list|(
name|paramtab
argument_list|,
name|addcmddirparam
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
operator|!
name|errflag
condition|)
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|q
operator|=
name|de
operator|->
name|d_name
argument_list|)
operator|&&
operator|(
operator|*
name|q
operator|!=
literal|'.'
operator|||
operator|*
name|u
operator|==
literal|'.'
operator|||
name|isset
argument_list|(
name|GLOBDOTS
argument_list|)
operator|)
condition|)
name|addmatch
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|commonprefix
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|Lknode
name|n
decl_stmt|;
name|int
name|nonomatch
init|=
name|isset
argument_list|(
name|NONOMATCH
argument_list|)
decl_stmt|;
name|opts
index|[
name|NONOMATCH
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hasp
condition|)
block|{
comment|/* Find the longest common prefix string 			 * after globbing the input. All expansions 			 * ~foo/bar/* will turn into something like 			 * /tmp_mnt/hosts/somehost/home/foo/... 			 * We will remove this common prefix from the matches. 			 * ash, 7 May '91 			 */
name|pathprefix
operator|=
name|s
expr_stmt|;
name|addnode
argument_list|(
name|matches
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|prefork
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errflag
condition|)
name|postfork
argument_list|(
name|matches
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errflag
condition|)
block|{
name|prefix
operator|=
name|peekfirst
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|commonprefix
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|pt
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* if strings ends in a '/' always add a '*' */
name|s
operator|=
name|dyncat
argument_list|(
name|s
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|=
name|Star
expr_stmt|;
name|addedstar
operator|=
literal|1
expr_stmt|;
block|}
name|matches
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|matches
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|prefork
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errflag
condition|)
name|postfork
argument_list|(
name|matches
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|opts
index|[
name|NONOMATCH
index|]
operator|=
name|nonomatch
expr_stmt|;
if|if
condition|(
name|errflag
operator|||
operator|!
name|full
argument_list|(
name|matches
argument_list|)
operator|||
operator|!
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|matches
argument_list|)
argument_list|)
condition|)
block|{
comment|/* if there were no matches (or only one) 				add a trailing * and try again */
name|s
operator|=
name|dyncat
argument_list|(
name|s
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|=
name|Star
expr_stmt|;
name|addedstar
operator|=
literal|1
expr_stmt|;
name|matches
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|matches
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|prefork
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
name|postfork
argument_list|(
name|matches
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
block|}
comment|/* remove the common prefix from all the matches */
if|if
condition|(
name|commonprefix
condition|)
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|matches
argument_list|)
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
name|n
operator|->
name|dat
operator|=
operator|(
name|char
operator|*
operator|)
name|n
operator|->
name|dat
operator|+
name|commonprefix
expr_stmt|;
name|s
operator|=
name|pt
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gen_matches_reg
parameter_list|(
name|s
parameter_list|,
name|incmd
parameter_list|,
name|regfiles
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|incmd
decl_stmt|;
name|int
name|regfiles
decl_stmt|;
block|{
name|char
modifier|*
name|u
decl_stmt|;
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
name|haspath
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
init|;
name|u
operator|>=
name|s
condition|;
name|u
operator|--
control|)
if|if
condition|(
operator|*
name|u
operator|==
literal|'/'
operator|||
operator|*
name|u
operator|==
literal|'@'
operator|||
operator|*
name|u
operator|==
literal|'$'
condition|)
break|break;
if|if
condition|(
name|u
operator|>=
name|s
condition|)
block|{
name|typechar
operator|=
operator|*
name|u
expr_stmt|;
operator|*
name|u
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|haspath
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
name|typechar
operator|=
literal|'='
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|u
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|haspath
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|u
operator|=
name|s
expr_stmt|;
name|pat
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|typechar
operator|==
literal|'$'
operator|&&
name|haspath
condition|)
block|{
comment|/* slashflag = SLASH_NO; */
name|listhtable
argument_list|(
name|paramtab
argument_list|,
name|addcmdmatch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typechar
operator|==
literal|'='
operator|&&
name|haspath
condition|)
block|{
name|slashflag
operator|=
name|SLASH_NO
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|HASHLISTALL
argument_list|)
condition|)
name|fullhash
argument_list|()
expr_stmt|;
name|listhtable
argument_list|(
name|cmdnamtab
argument_list|,
name|addcmdnodis
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typechar
operator|==
literal|'@'
operator|&&
name|haspath
condition|)
block|{
name|char
modifier|*
modifier|*
name|x
decl_stmt|;
name|slashflag
operator|=
name|SLASH_NO
expr_stmt|;
for|for
control|(
name|x
operator|=
name|hosts
init|;
operator|*
name|x
condition|;
name|x
operator|++
control|)
name|addcmdmatch
argument_list|(
operator|*
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
operator|&&
operator|!
name|haspath
condition|)
block|{
name|maketildelist
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pathprefix
operator|=
name|s
expr_stmt|;
name|slashflag
operator|=
name|SLASH_YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incmd
operator|&&
operator|!
name|haspath
condition|)
block|{
name|slashflag
operator|=
name|SLASH_NO
expr_stmt|;
name|listhtable
argument_list|(
name|aliastab
argument_list|,
name|addcmdmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|HASHLISTALL
argument_list|)
condition|)
name|fullhash
argument_list|()
expr_stmt|;
name|listhtable
argument_list|(
name|cmdnamtab
argument_list|,
name|addcmdnodis
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|AUTOCD
argument_list|)
operator|&&
name|isset
argument_list|(
name|CDABLEVARS
argument_list|)
condition|)
name|listhtable
argument_list|(
name|paramtab
argument_list|,
name|addcmddirparam
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|regfiles
condition|)
block|{
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
operator|!
name|errflag
condition|)
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|q
operator|=
name|de
operator|->
name|d_name
argument_list|)
operator|&&
operator|(
operator|*
name|q
operator|!=
literal|'.'
operator|||
operator|*
name|u
operator|==
literal|'.'
operator|||
name|isset
argument_list|(
name|GLOBDOTS
argument_list|)
operator|)
condition|)
name|addmatch
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isset
argument_list|(
name|AUTOCD
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
operator|!
name|errflag
condition|)
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|q
operator|=
name|de
operator|->
name|d_name
argument_list|)
operator|&&
operator|(
operator|*
name|q
operator|!=
literal|'.'
operator|||
operator|*
name|u
operator|==
literal|'.'
operator|||
name|isset
argument_list|(
name|GLOBDOTS
argument_list|)
operator|)
operator|&&
name|stat
argument_list|(
name|q
argument_list|,
operator|&
name|buf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|buf
operator|.
name|st_mode
operator|&
name|S_IEXEC
operator|)
operator|==
name|S_IEXEC
condition|)
name|addmatch
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
operator|!
name|errflag
condition|)
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|q
operator|=
name|de
operator|->
name|d_name
argument_list|)
operator|&&
operator|(
operator|*
name|q
operator|!=
literal|'.'
operator|||
operator|*
name|u
operator|==
literal|'.'
operator|||
name|isset
argument_list|(
name|GLOBDOTS
argument_list|)
operator|)
operator|&&
name|stat
argument_list|(
name|q
argument_list|,
operator|&
name|buf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|buf
operator|.
name|st_mode
operator|&
operator|(
name|S_IFMT
operator||
name|S_IEXEC
operator|)
operator|)
operator|==
operator|(
name|S_IFREG
operator||
name|S_IEXEC
operator|)
condition|)
name|addmatch
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|=
name|OPENDIR
argument_list|(
name|pathprefix
operator|=
operator|(
operator|(
name|haspath
operator|||
operator|*
name|s
operator|==
literal|'~'
operator|)
condition|?
operator|(
operator|(
operator|*
name|s
operator|)
condition|?
name|s
else|:
literal|"/"
operator|)
else|:
literal|"."
operator|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|,
name|buf2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|char
name|dn
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|dn
argument_list|,
name|dirname
argument_list|(
name|pathprefix
argument_list|)
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|&&
operator|!
name|errflag
condition|)
if|if
condition|(
name|strpfx
argument_list|(
name|pat
argument_list|,
name|q
operator|=
name|de
operator|->
name|d_name
argument_list|)
operator|&&
operator|(
operator|*
name|q
operator|!=
literal|'.'
operator|||
operator|*
name|u
operator|==
literal|'.'
operator|||
name|isset
argument_list|(
name|GLOBDOTS
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|incmd
condition|)
block|{
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"%s/%s"
argument_list|,
name|dn
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buf2
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|buf
operator|.
name|st_mode
operator|&
name|S_IEXEC
operator|)
operator|==
name|S_IEXEC
condition|)
block|{
name|addmatch
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addmatch
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|do_fignore
parameter_list|(
name|origstr
parameter_list|)
comment|/**/
name|char
modifier|*
name|origstr
decl_stmt|;
block|{
if|if
condition|(
name|full
argument_list|(
name|matches
argument_list|)
operator|&&
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|matches
argument_list|)
argument_list|)
condition|)
block|{
name|Lknode
name|z
decl_stmt|,
name|zn
decl_stmt|;
name|z
operator|=
name|firstnode
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|ambig
operator|=
literal|1000
expr_stmt|;
for|for
control|(
name|z
operator|=
name|firstnode
argument_list|(
name|matches
argument_list|)
init|;
name|z
condition|;
name|z
operator|=
name|zn
control|)
block|{
name|char
modifier|*
name|q
init|=
name|getdata
argument_list|(
name|z
argument_list|)
decl_stmt|;
name|int
name|namlen
init|=
name|strlen
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|int
name|slen
init|=
name|strlen
argument_list|(
name|origstr
argument_list|)
decl_stmt|;
name|int
name|slpt
decl_stmt|;
name|char
modifier|*
modifier|*
name|pt
init|=
name|fignore
decl_stmt|;
name|zn
operator|=
name|nextnode
argument_list|(
name|z
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|pt
condition|;
name|pt
operator|++
control|)
block|{
comment|/* We try to be smart here and override the 				   fignore variable if the user has explicity 				   used the ignored prefix, pem, 7 May 1991 */
name|slpt
operator|=
name|strlen
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addedstar
operator|&&
name|slen
operator|>
name|slpt
operator|&&
name|strcmp
argument_list|(
name|origstr
operator|+
name|slen
operator|-
name|slpt
argument_list|,
operator|*
name|pt
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|slpt
operator|<
name|namlen
operator|&&
operator|!
name|strcmp
argument_list|(
name|q
operator|+
name|namlen
operator|-
name|slpt
argument_list|,
operator|*
name|pt
argument_list|)
condition|)
block|{
name|uremnode
argument_list|(
name|matches
argument_list|,
name|z
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|pt
condition|)
block|{
name|int
name|y
init|=
name|pfxlen
argument_list|(
name|peekfirst
argument_list|(
name|matches
argument_list|)
argument_list|,
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|y
operator|<
name|ambig
condition|)
name|ambig
operator|=
name|y
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|do_ambiguous
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|lastambig
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usemenu
condition|)
block|{
name|do_ambig_menu
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|useglob
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|AUTOLIST
argument_list|)
condition|)
name|listmatches
argument_list|(
name|matches
argument_list|,
name|unset
argument_list|(
name|LISTTYPES
argument_list|)
condition|?
name|NULL
else|:
operator|(
name|haspath
operator|)
condition|?
name|pathprefix
else|:
literal|"./"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cs
operator|=
name|wb
expr_stmt|;
name|foredel
argument_list|(
name|we
operator|-
name|wb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haspath
condition|)
block|{
name|inststr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
name|typechar
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|RECEXACT
argument_list|)
operator|&&
name|exact
condition|)
block|{
name|lastambig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pat
operator|==
literal|'~'
operator|||
operator|*
name|pat
operator|==
literal|'='
operator|||
operator|*
name|pat
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|haspath
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|inststr
argument_list|(
name|exactstr
argument_list|)
expr_stmt|;
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|slashflag
condition|)
block|{
case|case
name|SLASH_YES
case|:
name|line
index|[
name|cs
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
name|SLASH_NO
case|:
name|line
index|[
name|cs
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
name|SLASH_MAYBE
case|:
name|line
index|[
name|cs
operator|++
index|]
operator|=
name|isdir
argument_list|(
name|exactstr
argument_list|,
name|pathprefix
argument_list|)
condition|?
literal|'/'
else|:
literal|' '
expr_stmt|;
break|break;
block|}
return|return;
block|}
name|s
operator|=
name|peekfirst
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|haspath
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|ambig
operator|--
expr_stmt|;
block|}
name|inststrlen
argument_list|(
name|s
argument_list|,
name|ambig
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|AUTOLIST
argument_list|)
condition|)
block|{
if|if
condition|(
name|unset
argument_list|(
name|NOLISTBEEP
argument_list|)
condition|)
name|feep
argument_list|()
expr_stmt|;
name|listmatches
argument_list|(
name|matches
argument_list|,
name|unset
argument_list|(
name|LISTTYPES
argument_list|)
condition|?
name|NULL
else|:
operator|(
name|haspath
operator|)
condition|?
name|pathprefix
else|:
literal|"./"
argument_list|)
expr_stmt|;
block|}
else|else
name|feep
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_single
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|cs
operator|=
name|wb
expr_stmt|;
name|foredel
argument_list|(
name|we
operator|-
name|wb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haspath
condition|)
block|{
name|inststr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
name|typechar
expr_stmt|;
block|}
name|s
operator|=
name|peekfirst
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|haspath
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|inststr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|slashflag
condition|)
block|{
case|case
name|SLASH_YES
case|:
name|line
index|[
name|cs
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
name|SLASH_NO
case|:
name|line
index|[
name|cs
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
name|SLASH_MAYBE
case|:
name|line
index|[
name|cs
operator|++
index|]
operator|=
name|isdir
argument_list|(
name|s
argument_list|,
name|pathprefix
argument_list|)
condition|?
literal|'/'
else|:
literal|' '
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isset
argument_list|(
name|AUTOREMOVESLASH
argument_list|)
operator|&&
name|line
index|[
name|cs
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|addedslash
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_ambig_menu
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|menucmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|MENUCOMPLETEBEEP
argument_list|)
condition|)
name|feep
argument_list|()
expr_stmt|;
name|cs
operator|=
name|wb
expr_stmt|;
name|menuw
operator|=
name|cs
expr_stmt|;
name|foredel
argument_list|(
name|we
operator|-
name|wb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haspath
condition|)
block|{
name|inststr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
name|typechar
expr_stmt|;
block|}
name|menub
operator|=
name|cs
expr_stmt|;
name|s
operator|=
name|peekfirst
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'~'
operator|||
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
operator|!
name|haspath
condition|)
block|{
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|inststr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|menue
operator|=
name|cs
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
name|menulist
operator|=
name|duplist
argument_list|(
name|matches
argument_list|,
operator|(
name|VFunc
operator|)
name|ztrdup
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
name|menunode
operator|=
name|firstnode
argument_list|(
name|menulist
argument_list|)
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|LASTMENU
argument_list|)
condition|)
block|{
if|if
condition|(
name|lastmenu
condition|)
name|free
argument_list|(
name|lastmenu
argument_list|)
expr_stmt|;
name|lastmenu
operator|=
name|ztrdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|lastmenupos
operator|=
name|cs
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|strpfx
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|==
operator|*
name|t
condition|)
name|s
operator|++
operator|,
name|t
operator|++
expr_stmt|;
return|return
operator|!
operator|*
name|s
return|;
block|}
end_function

begin_function
name|int
name|pfxlen
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|==
operator|*
name|t
condition|)
name|s
operator|++
operator|,
name|t
operator|++
operator|,
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|listmatches
parameter_list|(
name|l
parameter_list|,
name|apps
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
name|char
modifier|*
name|apps
decl_stmt|;
block|{
name|int
name|longest
init|=
literal|1
decl_stmt|,
name|fct
decl_stmt|,
name|fw
init|=
literal|0
decl_stmt|,
name|colsz
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|ct
decl_stmt|;
name|Lknode
name|n
decl_stmt|;
name|char
modifier|*
modifier|*
name|arr
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|trashzle
argument_list|()
expr_stmt|;
name|ct
operator|=
name|countnodes
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|listmax
operator|&&
name|ct
operator|>
name|listmax
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"zsh: do you wish to see all %d possibilities? "
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|getquery
argument_list|()
operator|!=
literal|'y'
condition|)
return|return;
block|}
name|ap
operator|=
name|arr
operator|=
name|alloc
argument_list|(
operator|(
name|countnodes
argument_list|(
name|l
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|l
argument_list|)
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
operator|*
name|ap
operator|++
operator|=
name|getdata
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|arr
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
operator|>
name|longest
condition|)
name|longest
operator|=
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|apps
condition|)
block|{
name|apps
operator|=
name|strdup
argument_list|(
name|apps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|apps
operator|==
literal|'~'
condition|)
operator|*
name|apps
operator|=
name|Tilde
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|apps
operator|==
literal|'='
condition|)
operator|*
name|apps
operator|=
name|Equals
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|apps
operator|==
literal|'$'
condition|)
operator|*
name|apps
operator|=
name|String
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|apps
argument_list|)
expr_stmt|;
name|longest
operator|++
expr_stmt|;
block|}
name|qsort
argument_list|(
name|arr
argument_list|,
name|ct
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|forstrcmp
argument_list|)
expr_stmt|;
name|fct
operator|=
operator|(
name|columns
operator|-
literal|1
operator|)
operator|/
operator|(
name|longest
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|fct
operator|==
literal|0
condition|)
name|fct
operator|=
literal|1
expr_stmt|;
else|else
name|fw
operator|=
operator|(
name|columns
operator|-
literal|1
operator|)
operator|/
name|fct
expr_stmt|;
name|colsz
operator|=
operator|(
name|ct
operator|+
name|fct
operator|-
literal|1
operator|)
operator|/
name|fct
expr_stmt|;
for|for
control|(
name|t1
operator|=
literal|0
init|;
name|t1
operator|!=
name|colsz
condition|;
name|t1
operator|++
control|)
block|{
name|ap
operator|=
name|arr
operator|+
name|t1
expr_stmt|;
if|if
condition|(
name|apps
condition|)
block|{
do|do
block|{
name|int
name|t2
init|=
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
name|pbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|apps
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|pbuf
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|buf
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
comment|/* screw POSIX */
block|{
case|case
name|S_IFDIR
case|:
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|S_IFIFO
case|case
name|S_IFIFO
case|:
name|putchar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|S_IFCHR
case|:
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
name|S_IFLNK
case|:
name|putchar
argument_list|(
operator|(
name|access
argument_list|(
name|pbuf
argument_list|,
name|F_OK
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|?
literal|'&'
else|:
literal|'@'
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFSOCK
case|case
name|S_IFSOCK
case|:
name|putchar
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|buf
operator|.
name|st_mode
operator|&
literal|0111
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
name|t2
operator|<
name|fw
condition|;
name|t2
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
name|colsz
init|;
name|t0
operator|&&
operator|*
name|ap
condition|;
name|t0
operator|--
operator|,
name|ap
operator|++
control|)
empty_stmt|;
block|}
do|while
condition|(
operator|*
name|ap
condition|)
do|;
block|}
else|else
do|do
block|{
name|int
name|t2
init|=
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t2
operator|<
name|fw
condition|;
name|t2
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
name|colsz
init|;
name|t0
operator|&&
operator|*
name|ap
condition|;
name|t0
operator|--
operator|,
name|ap
operator|++
control|)
empty_stmt|;
block|}
do|while
condition|(
operator|*
name|ap
condition|)
do|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|resetneeded
operator|=
literal|1
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|selectlist
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
block|{
name|int
name|longest
init|=
literal|1
decl_stmt|,
name|fct
decl_stmt|,
name|fw
init|=
literal|0
decl_stmt|,
name|colsz
decl_stmt|,
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|ct
decl_stmt|;
name|Lknode
name|n
decl_stmt|;
name|char
modifier|*
modifier|*
name|arr
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|trashzle
argument_list|()
expr_stmt|;
name|ct
operator|=
name|countnodes
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ap
operator|=
name|arr
operator|=
name|alloc
argument_list|(
operator|(
name|countnodes
argument_list|(
name|l
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|l
argument_list|)
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
operator|*
name|ap
operator|++
operator|=
name|getdata
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|arr
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
operator|>
name|longest
condition|)
name|longest
operator|=
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
name|t0
operator|=
name|ct
expr_stmt|;
name|longest
operator|++
expr_stmt|;
while|while
condition|(
name|t0
condition|)
name|t0
operator|/=
literal|10
operator|,
name|longest
operator|++
expr_stmt|;
name|fct
operator|=
operator|(
name|columns
operator|-
literal|1
operator|)
operator|/
operator|(
name|longest
operator|+
literal|3
operator|)
expr_stmt|;
comment|/* to compensate for added ')' */
if|if
condition|(
name|fct
operator|==
literal|0
condition|)
name|fct
operator|=
literal|1
expr_stmt|;
else|else
name|fw
operator|=
operator|(
name|columns
operator|-
literal|1
operator|)
operator|/
name|fct
expr_stmt|;
name|colsz
operator|=
operator|(
name|ct
operator|+
name|fct
operator|-
literal|1
operator|)
operator|/
name|fct
expr_stmt|;
for|for
control|(
name|t1
operator|=
literal|0
init|;
name|t1
operator|!=
name|colsz
condition|;
name|t1
operator|++
control|)
block|{
name|ap
operator|=
name|arr
operator|+
name|t1
expr_stmt|;
do|do
block|{
name|int
name|t2
init|=
name|strlen
argument_list|(
operator|*
name|ap
argument_list|)
operator|+
literal|2
decl_stmt|,
name|t3
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d) %s"
argument_list|,
name|t3
operator|=
name|ap
operator|-
name|arr
operator|+
literal|1
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
while|while
condition|(
name|t3
condition|)
name|t2
operator|++
operator|,
name|t3
operator|/=
literal|10
expr_stmt|;
for|for
control|(
init|;
name|t2
operator|<
name|fw
condition|;
name|t2
operator|++
control|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
name|colsz
init|;
name|t0
operator|&&
operator|*
name|ap
condition|;
name|t0
operator|--
operator|,
name|ap
operator|++
control|)
empty_stmt|;
block|}
do|while
condition|(
operator|*
name|ap
condition|)
do|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Below is a simple attempt at doing it the Korn Way..  	ap = arr; 	t0 = 0; 	do 		{ 		t0++; 		fprintf(stderr,"%d) %s\n",t0,*ap); 		ap++; 		} 	while (*ap);*/
name|resetneeded
operator|=
literal|1
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|doexpandhist
parameter_list|()
comment|/**/
block|{
name|unsigned
name|char
modifier|*
name|cc
decl_stmt|,
modifier|*
name|ce
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|oldcs
decl_stmt|,
name|oldll
decl_stmt|;
for|for
control|(
name|cc
operator|=
name|line
operator|,
name|ce
operator|=
name|line
operator|+
name|ll
init|;
name|cc
operator|<
name|ce
condition|;
name|cc
operator|++
control|)
if|if
condition|(
operator|*
name|cc
operator|==
literal|'\\'
operator|&&
name|cc
index|[
literal|1
index|]
condition|)
name|cc
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cc
operator|==
name|bangchar
operator|||
operator|(
operator|*
name|cc
operator|==
name|hatchar
operator|&&
operator|*
name|line
operator|==
name|hatchar
operator|&&
name|cc
operator|!=
name|line
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|cc
operator|==
name|bangchar
operator|&&
name|cc
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cc
operator|==
name|ce
condition|)
return|return
literal|0
return|;
name|oldcs
operator|=
name|cs
expr_stmt|;
name|oldll
operator|=
name|ll
expr_stmt|;
name|zleparse
operator|=
literal|1
expr_stmt|;
name|lexsave
argument_list|()
expr_stmt|;
name|hungets
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|strinbeg
argument_list|()
expr_stmt|;
name|pushheap
argument_list|()
expr_stmt|;
name|ll
operator|=
name|cs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|t0
operator|=
name|hgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|lexstop
condition|)
break|break;
name|spaceinline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
index|[
name|cs
operator|++
index|]
operator|=
name|t0
expr_stmt|;
block|}
name|hflush
argument_list|()
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
name|strinend
argument_list|()
expr_stmt|;
name|errflag
operator|=
name|zleparse
operator|=
literal|0
expr_stmt|;
name|t0
operator|=
name|histdone
expr_stmt|;
name|lexrestore
argument_list|()
expr_stmt|;
name|line
index|[
name|ll
operator|=
name|cs
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ll
operator|==
name|oldll
condition|)
name|cs
operator|=
name|oldcs
expr_stmt|;
return|return
name|t0
return|;
block|}
end_function

begin_function
name|void
name|magicspace
parameter_list|()
comment|/**/
block|{
name|c
operator|=
literal|' '
expr_stmt|;
name|selfinsert
argument_list|()
expr_stmt|;
name|doexpandhist
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expandhistory
parameter_list|()
comment|/**/
block|{
if|if
condition|(
operator|!
name|doexpandhist
argument_list|()
condition|)
name|feep
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|cmdwb
decl_stmt|,
name|cmdwe
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|getcurcmd
parameter_list|()
comment|/**/
block|{
name|int
name|lincmd
init|=
name|incmdpos
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|zleparse
operator|=
literal|1
expr_stmt|;
name|lexsave
argument_list|()
expr_stmt|;
name|hungets
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* KLUDGE! */
name|hungets
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|strinbeg
argument_list|()
expr_stmt|;
name|pushheap
argument_list|()
expr_stmt|;
do|do
block|{
name|lincmd
operator|=
name|incmdpos
expr_stmt|;
name|ctxtlex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|ENDINPUT
condition|)
break|break;
if|if
condition|(
name|tok
operator|==
name|STRING
operator|&&
name|lincmd
condition|)
block|{
if|if
condition|(
name|s
condition|)
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|ztrdup
argument_list|(
name|tokstr
argument_list|)
expr_stmt|;
name|cmdwb
operator|=
name|ll
operator|-
name|wordbeg
expr_stmt|;
name|cmdwe
operator|=
name|ll
operator|+
literal|1
operator|-
name|inbufct
expr_stmt|;
block|}
name|lincmd
operator|=
name|incmdpos
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|!=
name|ENDINPUT
operator|&&
name|zleparse
condition|)
do|;
name|hflush
argument_list|()
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
name|strinend
argument_list|()
expr_stmt|;
name|errflag
operator|=
name|zleparse
operator|=
literal|0
expr_stmt|;
name|lexrestore
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|processcmd
parameter_list|()
comment|/**/
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|s
operator|=
name|getcurcmd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|zlecmds
index|[
name|bindk
index|]
operator|.
name|name
expr_stmt|;
name|mult
operator|=
literal|1
expr_stmt|;
name|pushline
argument_list|()
expr_stmt|;
name|sizeline
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|strlen
argument_list|(
name|t
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|cs
operator|=
name|ll
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
name|inststr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|expandcmdpath
parameter_list|()
comment|/**/
block|{
name|int
name|oldcs
init|=
name|cs
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|s
operator|=
name|getcurcmd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|findcmd
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|feep
argument_list|()
expr_stmt|;
return|return;
block|}
name|cs
operator|=
name|cmdwb
expr_stmt|;
name|foredel
argument_list|(
name|cmdwe
operator|-
name|cmdwb
argument_list|)
expr_stmt|;
name|spaceinline
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
operator|+
name|cs
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|cs
operator|=
name|oldcs
expr_stmt|;
if|if
condition|(
name|cs
operator|>=
name|cmdwe
condition|)
name|cs
operator|+=
name|cmdwe
operator|-
name|cmdwb
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|>
name|ll
condition|)
name|cs
operator|=
name|ll
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freemenu
parameter_list|()
comment|/**/
block|{
if|if
condition|(
name|menucmp
operator|&&
operator|(
name|unset
argument_list|(
name|LASTMENU
argument_list|)
operator|||
name|lastmenu
operator|==
name|NULL
operator|)
condition|)
block|{
name|menucmp
operator|=
literal|0
expr_stmt|;
name|freetable
argument_list|(
name|menulist
argument_list|,
name|freestr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|inarray
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|a
condition|;
name|a
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|a
argument_list|,
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

