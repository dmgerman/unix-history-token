begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * glob.c - filename generation  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_define
define|#
directive|define
name|exists
parameter_list|(
name|X
parameter_list|)
value|(access(X,0) == 0 || readlink(X,NULL,0) == 0)
end_define

begin_decl_stmt
specifier|static
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* != 0 if we are parsing glob patterns */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pathpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position in pathbuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|matchsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of matchbuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|matchct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of matches found */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pathbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|matchbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of matches */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|matchptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*&matchbuf[matchct] */
end_comment

begin_decl_stmt
specifier|static
name|Comp
name|exclude
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pattern to exclude */
end_comment

begin_comment
comment|/* max # of qualifiers */
end_comment

begin_define
define|#
directive|define
name|QUALCT
value|16
end_define

begin_expr_stmt
specifier|static
name|int
argument_list|(
argument|*qualfuncs[QUALCT]
argument_list|)
name|DCLPROTO
argument_list|(
operator|(
expr|struct
name|stat
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|long
name|qualdata
index|[
name|QUALCT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qualsense
index|[
name|QUALCT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|qualct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gf_nullglob
decl_stmt|,
name|gf_markdirs
decl_stmt|,
name|gf_noglobdots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname component in filename patterns */
end_comment

begin_struct
struct|struct
name|complist
block|{
name|Complist
name|next
decl_stmt|;
name|Comp
name|comp
decl_stmt|;
name|int
name|closure
decl_stmt|;
comment|/* 1 if this is a (foo/)# */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|comp
block|{
name|Comp
name|left
decl_stmt|,
name|right
decl_stmt|,
name|next
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|closure
decl_stmt|,
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|glob
parameter_list|(
name|list
parameter_list|,
name|np
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
name|Lknode
modifier|*
name|np
decl_stmt|;
block|{
name|Lknode
name|node
init|=
name|prevnode
argument_list|(
operator|*
name|np
argument_list|)
decl_stmt|;
name|Lknode
name|next
init|=
name|nextnode
argument_list|(
operator|*
name|np
argument_list|)
decl_stmt|;
name|int
name|sl
decl_stmt|;
comment|/* length of the pattern */
name|char
modifier|*
name|ostr
decl_stmt|;
comment|/* the pattern before the parser chops it up */
name|Complist
name|q
decl_stmt|;
comment|/* pattern after parsing */
name|char
modifier|*
name|str
init|=
name|getdata
argument_list|(
operator|*
name|np
argument_list|)
decl_stmt|;
comment|/* the pattern */
name|sl
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ostr
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|uremnode
argument_list|(
name|list
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
name|qualct
operator|=
literal|0
expr_stmt|;
name|gf_nullglob
operator|=
name|isset
argument_list|(
name|NULLGLOB
argument_list|)
expr_stmt|;
name|gf_markdirs
operator|=
name|isset
argument_list|(
name|MARKDIRS
argument_list|)
expr_stmt|;
name|gf_noglobdots
operator|=
name|unset
argument_list|(
name|GLOBDOTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|sl
operator|-
literal|1
index|]
operator|==
name|Outpar
condition|)
comment|/* check for qualifiers */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|sense
init|=
literal|0
decl_stmt|;
name|long
name|data
decl_stmt|;
name|int
argument_list|(
argument|*func
argument_list|)
name|DCLPROTO
argument_list|(
operator|(
expr|struct
name|stat
operator|*
operator|,
name|long
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
operator|+
name|sl
operator|-
literal|2
init|;
name|s
operator|!=
name|str
condition|;
name|s
operator|--
control|)
if|if
condition|(
operator|*
name|s
operator|==
name|Bar
operator|||
operator|*
name|s
operator|==
name|Outpar
operator|||
operator|*
name|s
operator|==
name|Inpar
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
name|Inpar
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|func
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|Outpar
condition|)
block|{
name|func
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|data
operator|=
name|data
operator|*
literal|010
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|(
name|int
operator|)
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
case|case
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Hat
case|:
case|case
literal|'^'
case|:
name|sense
operator|=
literal|1
operator|-
name|sense
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
literal|'@'
case|:
name|func
operator|=
name|qualmode
expr_stmt|;
name|data
operator|=
name|S_IFLNK
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFSOCK
case|case
literal|'='
case|:
name|func
operator|=
name|qualmode
expr_stmt|;
name|data
operator|=
name|S_IFSOCK
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFIFO
case|case
literal|'p'
case|:
name|func
operator|=
name|qualmode
expr_stmt|;
name|data
operator|=
name|S_IFIFO
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'/'
case|:
name|func
operator|=
name|qualmode
expr_stmt|;
name|data
operator|=
name|S_IFDIR
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|func
operator|=
name|qualmode
expr_stmt|;
name|data
operator|=
name|S_IFREG
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|func
operator|=
name|qualisdev
expr_stmt|;
break|break;
case|case
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|Star
case|:
name|func
operator|=
name|qualiscom
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|0004
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|0002
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|0001
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|0400
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|0200
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|0100
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|04000
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|func
operator|=
name|qualflags
expr_stmt|;
name|data
operator|=
literal|02000
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|func
operator|=
name|qualdev
expr_stmt|;
name|data
operator|=
name|qgetnum
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|func
operator|=
name|qualnlink
expr_stmt|;
name|data
operator|=
name|qgetnum
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|func
operator|=
name|qualuid
expr_stmt|;
name|data
operator|=
name|geteuid
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|func
operator|=
name|qualgid
expr_stmt|;
name|data
operator|=
name|getegid
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|func
operator|=
name|qualuid
expr_stmt|;
name|data
operator|=
name|qgetnum
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|func
operator|=
name|qualgid
expr_stmt|;
name|data
operator|=
name|qgetnum
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|gf_markdirs
operator|=
operator|!
name|sense
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|gf_nullglob
operator|=
operator|!
name|sense
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|gf_noglobdots
operator|=
name|sense
expr_stmt|;
break|break;
default|default:
name|zerr
argument_list|(
literal|"unknown file attribute"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|func
condition|)
block|{
if|if
condition|(
name|qualct
operator|==
name|QUALCT
operator|-
literal|1
condition|)
block|{
name|zerr
argument_list|(
literal|"too many qualifiers"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|qualfuncs
index|[
name|qualct
index|]
operator|=
name|func
expr_stmt|;
name|qualsense
index|[
name|qualct
index|]
operator|=
name|sense
expr_stmt|;
name|qualdata
index|[
name|qualct
index|]
operator|=
name|data
expr_stmt|;
name|qualct
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errflag
condition|)
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|str
index|[
name|sl
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|!
operator|(
operator|(
name|str
index|[
name|sl
operator|-
literal|2
index|]
operator|==
name|Star
operator|)
operator|&&
operator|(
name|str
index|[
name|sl
operator|-
literal|3
index|]
operator|==
name|Star
operator|)
operator|&&
operator|(
name|str
index|[
name|sl
operator|-
literal|4
index|]
operator|==
name|Star
operator|)
operator|&&
operator|(
name|str
index|[
name|sl
operator|-
literal|5
index|]
operator|==
name|Star
operator|)
operator|)
condition|)
comment|/* foo/ == foo(/) */
block|{
name|str
index|[
name|sl
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qualfuncs
index|[
literal|0
index|]
operator|=
name|qualmode
expr_stmt|;
name|qualdata
index|[
literal|0
index|]
operator|=
name|S_IFDIR
expr_stmt|;
name|qualsense
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|qualct
operator|=
literal|1
expr_stmt|;
block|}
name|qualfuncs
index|[
name|qualct
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'/'
condition|)
comment|/* pattern has absolute path */
block|{
name|str
operator|++
expr_stmt|;
name|pathbuf
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|pathbuf
index|[
name|pathpos
operator|=
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* pattern is relative to pwd */
name|pathbuf
index|[
name|pathpos
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|parsepat
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|||
name|errflag
condition|)
comment|/* if parsing failed */
block|{
if|if
condition|(
name|isset
argument_list|(
name|NOBADPATTERN
argument_list|)
condition|)
block|{
name|insnode
argument_list|(
name|list
argument_list|,
name|node
argument_list|,
name|ostr
argument_list|)
expr_stmt|;
return|return;
block|}
name|errflag
operator|=
literal|0
expr_stmt|;
name|zerr
argument_list|(
literal|"bad pattern: %s"
argument_list|,
name|ostr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|matchptr
operator|=
name|matchbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
operator|(
name|matchsz
operator|=
literal|16
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matchct
operator|=
literal|0
expr_stmt|;
name|scanner
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* do the globbing */
if|if
condition|(
name|matchct
condition|)
name|badcshglob
operator||=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|gf_nullglob
condition|)
if|if
condition|(
name|isset
argument_list|(
name|CSHNULLGLOB
argument_list|)
condition|)
block|{
name|badcshglob
operator||=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unset
argument_list|(
name|NONOMATCH
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"no matches found: %s"
argument_list|,
name|ostr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matchbuf
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|*
name|matchptr
operator|++
operator|=
name|strdup
argument_list|(
name|ostr
argument_list|)
expr_stmt|;
name|matchct
operator|=
literal|1
expr_stmt|;
block|}
name|qsort
argument_list|(
operator|&
name|matchbuf
index|[
literal|0
index|]
argument_list|,
name|matchct
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|notstrcmp
argument_list|)
expr_stmt|;
name|matchptr
operator|=
name|matchbuf
expr_stmt|;
while|while
condition|(
name|matchct
operator|--
condition|)
comment|/* insert matches in the arg list */
name|insnode
argument_list|(
name|list
argument_list|,
name|node
argument_list|,
operator|*
name|matchptr
operator|++
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matchbuf
argument_list|)
expr_stmt|;
operator|*
name|np
operator|=
operator|(
name|next
operator|)
condition|?
name|prevnode
argument_list|(
name|next
argument_list|)
else|:
name|lastnode
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get number after qualifier */
end_comment

begin_function
name|long
name|qgetnum
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
block|{
name|long
name|v
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|idigit
argument_list|(
operator|*
operator|*
name|s
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"number expected"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|idigit
argument_list|(
operator|*
operator|*
name|s
argument_list|)
condition|)
name|v
operator|=
name|v
operator|*
literal|10
operator|+
operator|*
operator|(
operator|*
name|s
operator|)
operator|++
operator|-
literal|'0'
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|int
name|notstrcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
modifier|*
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|c
init|=
operator|*
name|b
decl_stmt|,
modifier|*
name|d
init|=
operator|*
name|a
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|;
for|for
control|(
init|;
operator|*
name|c
operator|==
operator|*
name|d
operator|&&
operator|*
name|c
condition|;
name|c
operator|++
operator|,
name|d
operator|++
control|)
empty_stmt|;
name|x1
operator|=
name|atoi
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|x2
operator|=
name|atoi
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1
operator|==
name|x2
operator|||
name|unset
argument_list|(
name|NUMERICGLOBSORT
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|c
operator|-
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|)
return|;
return|return
name|x1
operator|-
name|x2
return|;
block|}
end_function

begin_function
name|int
name|forstrcmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
modifier|*
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|c
init|=
operator|*
name|b
decl_stmt|,
modifier|*
name|d
init|=
operator|*
name|a
decl_stmt|;
for|for
control|(
init|;
operator|*
name|c
operator|==
operator|*
name|d
operator|&&
operator|*
name|c
condition|;
name|c
operator|++
operator|,
name|d
operator|++
control|)
empty_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
operator|-
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
operator|*
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* add a match to the list */
end_comment

begin_function
name|void
name|insert
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|statted
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exclude
operator|&&
name|domatch
argument_list|(
name|s
argument_list|,
name|exclude
argument_list|,
name|gf_noglobdots
argument_list|)
condition|)
return|return;
if|if
condition|(
name|gf_markdirs
operator|&&
operator|!
name|lstat
argument_list|(
name|s
argument_list|,
operator|&
name|buf
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|ll
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|t
operator|=
name|ncalloc
argument_list|(
name|ll
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|t
index|[
name|ll
index|]
operator|=
literal|'/'
expr_stmt|;
name|t
index|[
name|ll
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
name|statted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|qualct
condition|)
block|{
comment|/* do the (X) (^X) stuff */
name|int
argument_list|(
argument|**fptr
argument_list|)
name|DCLPROTO
argument_list|(
operator|(
expr|struct
name|stat
operator|*
operator|,
name|long
operator|)
argument_list|)
operator|=
name|qualfuncs
expr_stmt|;
name|int
modifier|*
name|sptr
init|=
name|qualsense
decl_stmt|;
name|long
modifier|*
name|lptr
init|=
name|qualdata
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|statted
operator|||
name|lstat
argument_list|(
name|s
argument_list|,
operator|&
name|buf
argument_list|)
operator|>=
literal|0
condition|)
while|while
condition|(
operator|*
name|fptr
condition|)
if|if
condition|(
operator|!
operator|(
operator|!
operator|!
operator|(
operator|(
operator|*
name|fptr
operator|++
operator|)
operator|(
operator|&
name|buf
operator|,
operator|*
name|lptr
operator|++
operator|)
operator|)
operator|^
operator|*
name|sptr
operator|++
operator|)
condition|)
return|return;
block|}
operator|*
name|matchptr
operator|++
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|++
name|matchct
operator|==
name|matchsz
condition|)
block|{
name|matchbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
operator|(
name|matchsz
operator|*=
literal|2
operator|)
argument_list|)
expr_stmt|;
name|matchptr
operator|=
name|matchbuf
operator|+
name|matchct
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* check to see if str is eligible for filename generation */
end_comment

begin_function
name|int
name|haswilds
parameter_list|(
name|str
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|str
operator|==
name|Inbrack
operator|||
operator|*
name|str
operator|==
name|Outbrack
operator|)
operator|&&
operator|!
name|str
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
name|Pound
operator|||
operator|*
name|str
operator|==
name|Hat
operator|||
operator|*
name|str
operator|==
name|Star
operator|||
operator|*
name|str
operator|==
name|Bar
operator|||
operator|*
name|str
operator|==
name|Inbrack
operator|||
operator|*
name|str
operator|==
name|Inang
operator|||
operator|*
name|str
operator|==
name|Quest
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* check to see if str is eligible for brace expansion */
end_comment

begin_function
name|int
name|hasbraces
parameter_list|(
name|str
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|mb
decl_stmt|,
name|bc
decl_stmt|,
name|cmct1
decl_stmt|,
name|cmct2
decl_stmt|;
name|char
modifier|*
name|lbr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
name|Inbrace
operator|&&
name|str
index|[
literal|1
index|]
operator|==
name|Outbrace
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isset
argument_list|(
name|BRACECCL
argument_list|)
condition|)
block|{
for|for
control|(
name|mb
operator|=
name|bc
operator|=
literal|0
init|;
operator|*
name|str
condition|;
operator|++
name|str
control|)
if|if
condition|(
operator|*
name|str
operator|==
name|Inbrace
condition|)
block|{
if|if
condition|(
operator|++
name|bc
operator|>
name|mb
condition|)
name|mb
operator|=
name|bc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|Outbrace
condition|)
if|if
condition|(
operator|--
name|bc
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|mb
operator|&&
name|bc
operator|==
literal|0
operator|)
return|;
block|}
for|for
control|(
name|mb
operator|=
name|bc
operator|=
name|cmct1
operator|=
name|cmct2
operator|=
literal|0
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|Inbrace
condition|)
block|{
if|if
condition|(
operator|!
name|bc
condition|)
name|lbr
operator|=
name|str
expr_stmt|;
name|bc
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|4
index|]
operator|==
name|Outbrace
operator|&&
name|str
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
comment|/* {a-z} */
block|{
name|cmct1
operator|++
expr_stmt|;
if|if
condition|(
name|bc
operator|==
literal|1
condition|)
name|cmct2
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|Outbrace
condition|)
block|{
name|bc
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|bc
condition|)
block|{
if|if
condition|(
operator|!
name|cmct2
condition|)
block|{
operator|*
name|lbr
operator|=
literal|'{'
expr_stmt|;
operator|*
name|str
operator|=
literal|'}'
expr_stmt|;
block|}
name|cmct2
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|Comma
operator|&&
name|bc
condition|)
block|{
name|cmct1
operator|++
expr_stmt|;
if|if
condition|(
name|bc
operator|==
literal|1
condition|)
name|cmct2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bc
operator|>
name|mb
condition|)
name|mb
operator|=
name|bc
expr_stmt|;
if|if
condition|(
name|bc
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|(
name|mb
operator|&&
name|bc
operator|==
literal|0
operator|&&
name|cmct1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* expand stuff like>>*.c */
end_comment

begin_function
name|int
name|xpandredir
parameter_list|(
name|fn
parameter_list|,
name|tab
parameter_list|)
comment|/**/
name|struct
name|redir
modifier|*
name|fn
decl_stmt|;
name|Lklist
name|tab
decl_stmt|;
block|{
name|Lklist
name|fake
decl_stmt|;
name|char
modifier|*
name|nam
decl_stmt|;
name|struct
name|redir
modifier|*
name|ff
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|fake
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|fake
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
name|prefork
argument_list|(
name|fake
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errflag
condition|)
name|postfork
argument_list|(
name|fake
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|full
argument_list|(
name|fake
argument_list|)
operator|&&
operator|!
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|fake
argument_list|)
argument_list|)
condition|)
block|{
name|fn
operator|->
name|name
operator|=
name|peekfirst
argument_list|(
name|fake
argument_list|)
expr_stmt|;
name|untokenize
argument_list|(
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|nam
operator|=
name|ugetnode
argument_list|(
name|fake
argument_list|)
condition|)
block|{
name|ff
operator|=
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|ff
argument_list|)
expr_stmt|;
operator|*
name|ff
operator|=
operator|*
name|fn
expr_stmt|;
name|ff
operator|->
name|name
operator|=
name|nam
expr_stmt|;
name|addnode
argument_list|(
name|tab
argument_list|,
name|ff
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* concatenate s1 and s2 in dynamically allocated buffer */
end_comment

begin_function
name|char
modifier|*
name|dyncat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
comment|/**/
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|ncalloc
argument_list|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* concatenate s1, s2, and s3 in dynamically allocated buffer */
end_comment

begin_function
name|char
modifier|*
name|tricat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
comment|/**/
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
name|s3
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|zalloc
argument_list|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ptr
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* brace expansion */
end_comment

begin_function
name|void
name|xpandbraces
parameter_list|(
name|list
parameter_list|,
name|np
parameter_list|)
comment|/**/
name|Lklist
name|list
decl_stmt|;
name|Lknode
modifier|*
name|np
decl_stmt|;
block|{
name|Lknode
name|node
init|=
operator|(
operator|*
name|np
operator|)
decl_stmt|,
name|last
init|=
name|prevnode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|getdata
argument_list|(
name|node
argument_list|)
decl_stmt|,
modifier|*
name|str3
init|=
name|str
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
name|int
name|prev
decl_stmt|,
name|bc
decl_stmt|,
name|comma
decl_stmt|;
for|for
control|(
init|;
operator|*
name|str
operator|!=
name|Inbrace
condition|;
name|str
operator|++
control|)
empty_stmt|;
for|for
control|(
name|str2
operator|=
name|str
operator|,
name|bc
operator|=
name|comma
operator|=
literal|0
init|;
operator|*
name|str2
condition|;
operator|++
name|str2
control|)
if|if
condition|(
operator|*
name|str2
operator|==
name|Inbrace
condition|)
operator|++
name|bc
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str2
operator|==
name|Outbrace
condition|)
block|{
if|if
condition|(
operator|--
name|bc
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|bc
operator|==
literal|1
operator|&&
operator|*
name|str2
operator|==
name|Comma
condition|)
operator|++
name|comma
expr_stmt|;
if|if
condition|(
operator|!
name|comma
operator|&&
operator|!
name|bc
operator|&&
name|isset
argument_list|(
name|BRACECCL
argument_list|)
condition|)
block|{
comment|/* {a-mnop} */
name|char
name|ccl
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|lastch
decl_stmt|;
name|uremnode
argument_list|(
name|list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ccl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ccl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ccl
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|str
operator|+
literal|1
operator|,
name|lastch
operator|=
literal|0
init|;
name|p
operator|<
name|str2
condition|;
control|)
block|{
if|if
condition|(
name|itok
argument_list|(
name|c1
operator|=
operator|*
name|p
operator|++
argument_list|)
condition|)
name|c1
operator|=
name|ztokens
index|[
name|c1
operator|-
operator|(
name|unsigned
name|char
operator|)
name|Pound
index|]
expr_stmt|;
if|if
condition|(
name|itok
argument_list|(
name|c2
operator|=
operator|*
name|p
argument_list|)
condition|)
name|c2
operator|=
name|ztokens
index|[
name|c2
operator|-
operator|(
name|unsigned
name|char
operator|)
name|Pound
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'-'
operator|&&
name|lastch
operator|&&
name|p
operator|<
name|str2
operator|&&
name|lastch
operator|<=
name|c2
condition|)
block|{
while|while
condition|(
name|lastch
operator|<
name|c2
condition|)
name|ccl
index|[
name|lastch
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|lastch
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ccl
index|[
name|lastch
operator|=
name|c1
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|str2
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ccl
operator|+
literal|255
init|;
name|p
operator|--
operator|>
name|ccl
condition|;
control|)
if|if
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|str
operator|=
name|p
operator|-
name|ccl
expr_stmt|;
name|insnode
argument_list|(
name|list
argument_list|,
name|last
argument_list|,
name|strdup
argument_list|(
name|str3
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|np
operator|=
name|nextnode
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|str
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
name|str
index|[
literal|4
index|]
operator|==
name|Outbrace
condition|)
comment|/* {a-z} */
block|{
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|uremnode
argument_list|(
name|list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|chuck
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|*
name|str
expr_stmt|;
name|chuck
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|chuck
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|c2
operator|=
operator|*
name|str
expr_stmt|;
name|chuck
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|itok
argument_list|(
name|c1
argument_list|)
condition|)
name|c1
operator|=
name|ztokens
index|[
name|c1
operator|-
name|Pound
index|]
expr_stmt|;
if|if
condition|(
name|itok
argument_list|(
name|c2
argument_list|)
condition|)
name|c2
operator|=
name|ztokens
index|[
name|c2
operator|-
name|Pound
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
for|for
control|(
init|;
name|c2
operator|>=
name|c1
condition|;
name|c2
operator|--
control|)
comment|/* {a-z} */
block|{
operator|*
name|str
operator|=
name|c2
expr_stmt|;
name|insnode
argument_list|(
name|list
argument_list|,
name|last
argument_list|,
name|strdup
argument_list|(
name|str3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|c2
operator|<=
name|c1
condition|;
name|c2
operator|++
control|)
comment|/* {z-a} */
block|{
operator|*
name|str
operator|=
name|c2
expr_stmt|;
name|insnode
argument_list|(
name|list
argument_list|,
name|last
argument_list|,
name|strdup
argument_list|(
name|str3
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|np
operator|=
name|nextnode
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|str
operator|-
name|str3
expr_stmt|;
name|str2
operator|=
name|getparen
argument_list|(
name|str
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str2
condition|)
block|{
name|zerr
argument_list|(
literal|"how did you get this error?"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|uremnode
argument_list|(
name|list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|last
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|zz
decl_stmt|,
modifier|*
name|str4
decl_stmt|;
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|str4
operator|=
name|str
operator|,
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|||
operator|*
name|str
operator|!=
name|Comma
operator|&&
operator|*
name|str
operator|!=
name|Outbrace
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
name|Inbrace
condition|)
name|cnt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|Outbrace
condition|)
name|cnt
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|exit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|zz
operator|=
name|zalloc
argument_list|(
name|prev
operator|+
operator|(
name|str
operator|-
name|str4
operator|)
operator|+
name|strlen
argument_list|(
name|str2
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ztrncpy
argument_list|(
name|zz
argument_list|,
name|str3
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|zz
argument_list|,
name|str4
argument_list|,
name|str
operator|-
name|str4
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|zz
argument_list|,
name|str2
argument_list|)
expr_stmt|;
name|insnode
argument_list|(
name|list
argument_list|,
name|node
argument_list|,
name|zz
argument_list|)
expr_stmt|;
name|incnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
name|Outbrace
condition|)
name|str
operator|++
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|np
operator|=
name|nextnode
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get closing paren, given pointer to opening paren */
end_comment

begin_function
name|char
modifier|*
name|getparen
parameter_list|(
name|str
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|cnt
init|=
literal|1
decl_stmt|;
name|char
name|typein
init|=
operator|*
name|str
operator|++
decl_stmt|,
name|typeout
init|=
name|typein
operator|+
literal|1
decl_stmt|;
for|for
control|(
init|;
operator|*
name|str
operator|&&
name|cnt
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
name|typein
condition|)
name|cnt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|typeout
condition|)
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|&&
name|cnt
condition|)
return|return
name|NULL
return|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* check to see if a matches b (b is not a filename pattern) */
end_comment

begin_function
name|int
name|matchpat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
comment|/**/
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
name|Comp
name|c
decl_stmt|;
name|int
name|val
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|b2
decl_stmt|;
name|remnulargs
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b2
operator|=
name|alloc
argument_list|(
name|len
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|b2
operator|+
literal|1
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b2
index|[
literal|0
index|]
operator|=
name|Inpar
expr_stmt|;
name|b2
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|Outpar
expr_stmt|;
name|b2
index|[
name|len
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
name|parsereg
argument_list|(
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|zerr
argument_list|(
literal|"bad pattern: %s"
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|val
operator|=
name|domatch
argument_list|(
name|a
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* do the ${foo%%bar}, ${foo#bar} stuff */
end_comment

begin_comment
comment|/* please do not laugh at this code. */
end_comment

begin_function
name|void
name|getmatch
parameter_list|(
name|sp
parameter_list|,
name|pat
parameter_list|,
name|dd
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
name|int
name|dd
decl_stmt|;
block|{
name|Comp
name|c
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|lng
init|=
name|NULL
decl_stmt|,
name|cc
decl_stmt|,
modifier|*
name|s
init|=
operator|*
name|sp
decl_stmt|;
name|remnulargs
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|c
operator|=
name|parsereg
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|zerr
argument_list|(
literal|"bad pattern: %s"
argument_list|,
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|dd
operator|&
literal|2
operator|)
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
init|;
name|t
operator|==
name|s
operator|||
name|t
index|[
operator|-
literal|1
index|]
condition|;
name|t
operator|++
control|)
block|{
name|cc
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|domatch
argument_list|(
name|s
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dd
operator|&
literal|1
operator|)
condition|)
block|{
operator|*
name|t
operator|=
name|cc
expr_stmt|;
name|t
operator|=
name|strdup
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|t
expr_stmt|;
return|return;
block|}
name|lng
operator|=
name|t
expr_stmt|;
block|}
operator|*
name|t
operator|=
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|lng
condition|)
block|{
name|t
operator|=
name|strdup
argument_list|(
name|lng
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|t
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
init|;
name|t
operator|>=
name|s
condition|;
name|t
operator|--
control|)
block|{
if|if
condition|(
name|domatch
argument_list|(
name|t
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dd
operator|&
literal|1
operator|)
condition|)
block|{
name|cc
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sp
operator|=
name|strdup
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|cc
expr_stmt|;
return|return;
block|}
name|lng
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lng
condition|)
block|{
name|cc
operator|=
operator|*
name|lng
expr_stmt|;
operator|*
name|lng
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sp
operator|=
name|strdup
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
operator|*
name|lng
operator|=
name|cc
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* add a component to pathbuf */
end_comment

begin_function
specifier|static
name|int
name|addpath
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|pathpos
operator|>=
name|MAXPATHLEN
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|pathbuf
index|[
name|pathpos
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
name|pathbuf
index|[
name|pathpos
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|pathbuf
index|[
name|pathpos
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getfullpath
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* do the globbing */
end_comment

begin_function
name|void
name|scanner
parameter_list|(
name|q
parameter_list|)
comment|/**/
name|Complist
name|q
decl_stmt|;
block|{
name|Comp
name|c
decl_stmt|;
name|int
name|closure
decl_stmt|;
if|if
condition|(
name|closure
operator|=
name|q
operator|->
name|closure
condition|)
comment|/* (foo/)# */
if|if
condition|(
name|q
operator|->
name|closure
operator|==
literal|2
condition|)
comment|/* (foo/)## */
name|q
operator|->
name|closure
operator|=
literal|1
expr_stmt|;
else|else
name|scanner
argument_list|(
name|q
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|q
operator|->
name|comp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|next
operator|||
name|c
operator|->
name|left
operator|)
operator|&&
operator|!
name|haswilds
argument_list|(
name|c
operator|->
name|str
argument_list|)
condition|)
if|if
condition|(
name|q
operator|->
name|next
condition|)
block|{
name|int
name|oppos
init|=
name|pathpos
decl_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
if|if
condition|(
name|q
operator|->
name|closure
operator|&&
operator|!
name|strcmp
argument_list|(
name|c
operator|->
name|str
argument_list|,
literal|"."
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|addpath
argument_list|(
name|c
operator|->
name|str
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|closure
operator|||
name|exists
argument_list|(
name|pathbuf
argument_list|)
condition|)
name|scanner
argument_list|(
operator|(
name|q
operator|->
name|closure
operator|)
condition|?
name|q
else|:
name|q
operator|->
name|next
argument_list|)
expr_stmt|;
name|pathbuf
index|[
name|pathpos
operator|=
name|oppos
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|s
operator|=
name|getfullpath
argument_list|(
name|c
operator|->
name|str
argument_list|)
argument_list|)
condition|)
name|insert
argument_list|(
name|strdup
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|fn
decl_stmt|;
name|int
name|dirs
init|=
operator|!
operator|!
name|q
operator|->
name|next
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
name|DIR
modifier|*
name|lock
init|=
name|opendir
argument_list|(
operator|(
operator|*
name|pathbuf
operator|)
condition|?
name|pathbuf
else|:
literal|"."
argument_list|)
decl_stmt|;
if|if
condition|(
name|lock
operator|==
name|NULL
condition|)
return|return;
name|readdir
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* skip . and .. */
while|while
condition|(
name|de
operator|=
name|readdir
argument_list|(
name|lock
argument_list|)
condition|)
block|{
if|if
condition|(
name|errflag
condition|)
break|break;
name|fn
operator|=
operator|&
name|de
operator|->
name|d_name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|domatch
argument_list|(
name|fn
argument_list|,
name|c
argument_list|,
name|gf_noglobdots
argument_list|)
condition|)
block|{
name|int
name|oppos
init|=
name|pathpos
decl_stmt|;
if|if
condition|(
name|dirs
condition|)
block|{
if|if
condition|(
name|closure
condition|)
block|{
name|int
name|type3
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|getfullpath
argument_list|(
name|fn
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|ENOTDIR
condition|)
block|{
name|zerr
argument_list|(
literal|"%e: %s"
argument_list|,
name|fn
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|errflag
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
name|type3
operator|=
name|buf
operator|.
name|st_mode
operator|&
name|S_IFMT
expr_stmt|;
if|if
condition|(
name|type3
operator|!=
name|S_IFDIR
condition|)
continue|continue;
block|}
if|if
condition|(
name|addpath
argument_list|(
name|fn
argument_list|)
condition|)
name|scanner
argument_list|(
operator|(
name|q
operator|->
name|closure
operator|)
condition|?
name|q
else|:
name|q
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* scan next level */
name|pathbuf
index|[
name|pathpos
operator|=
name|oppos
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|insert
argument_list|(
name|dyncat
argument_list|(
name|pathbuf
argument_list|,
name|fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|zerr
argument_list|(
literal|"no idea how you got this error message."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do the [..(foo)..] business */
end_comment

begin_function
name|int
name|minimatch
parameter_list|(
name|pat
parameter_list|,
name|str
parameter_list|)
comment|/**/
name|char
modifier|*
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|pt
init|=
operator|*
name|pat
operator|+
literal|1
decl_stmt|,
modifier|*
name|s
init|=
operator|*
name|str
decl_stmt|;
for|for
control|(
init|;
operator|*
name|pt
operator|!=
name|Outpar
condition|;
name|s
operator|++
operator|,
name|pt
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|pt
operator|!=
name|Quest
operator|||
operator|!
operator|*
name|s
operator|)
operator|&&
operator|*
name|pt
operator|!=
operator|*
name|s
condition|)
block|{
operator|*
name|pat
operator|=
name|getparen
argument_list|(
operator|*
name|pat
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|str
operator|=
name|s
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Comp
name|tail
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|first
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|domatch
parameter_list|(
name|str
parameter_list|,
name|c
parameter_list|,
name|fist
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
name|Comp
name|c
decl_stmt|;
name|int
name|fist
decl_stmt|;
block|{
name|pptr
operator|=
name|str
expr_stmt|;
name|first
operator|=
name|fist
expr_stmt|;
return|return
name|doesmatch
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* see if current pattern matches c */
end_comment

begin_function
name|int
name|doesmatch
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Comp
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|pat
init|=
name|c
operator|->
name|str
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|closure
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|saves
init|=
name|pptr
decl_stmt|;
if|if
condition|(
name|first
operator|&&
operator|*
name|pptr
operator|==
literal|'.'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|doesmatch
argument_list|(
name|c
operator|->
name|next
argument_list|)
condition|)
return|return
literal|1
return|;
name|pptr
operator|=
name|saves
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|pat
operator|||
operator|!
operator|*
name|pat
condition|)
block|{
name|char
modifier|*
name|saves
decl_stmt|;
name|int
name|savei
decl_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return
literal|0
return|;
name|saves
operator|=
name|pptr
expr_stmt|;
name|savei
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|left
operator|||
name|c
operator|->
name|right
condition|)
if|if
condition|(
operator|!
name|doesmatch
argument_list|(
name|c
operator|->
name|left
argument_list|)
condition|)
if|if
condition|(
name|c
operator|->
name|right
condition|)
block|{
name|pptr
operator|=
name|saves
expr_stmt|;
name|first
operator|=
name|savei
expr_stmt|;
if|if
condition|(
operator|!
name|doesmatch
argument_list|(
name|c
operator|->
name|right
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|closure
condition|)
return|return
name|doesmatch
argument_list|(
name|c
argument_list|)
return|;
if|if
condition|(
operator|!
name|c
operator|->
name|next
condition|)
return|return
operator|(
operator|!
name|c
operator|->
name|last
operator|||
operator|!
operator|*
name|pptr
operator|)
return|;
return|return
name|doesmatch
argument_list|(
name|c
operator|->
name|next
argument_list|)
return|;
block|}
if|if
condition|(
name|first
operator|&&
operator|*
name|pptr
operator|==
literal|'.'
operator|&&
operator|*
name|pat
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|pat
operator|==
name|Star
condition|)
comment|/* final * is not expanded to ?#; returns success */
block|{
while|while
condition|(
operator|*
name|pptr
condition|)
name|pptr
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|pat
operator|==
name|Quest
operator|&&
operator|*
name|pptr
condition|)
block|{
name|pptr
operator|++
expr_stmt|;
name|pat
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|pat
operator|==
name|Hat
condition|)
return|return
literal|1
operator|-
name|doesmatch
argument_list|(
name|c
operator|->
name|next
argument_list|)
return|;
if|if
condition|(
operator|*
name|pat
operator|==
name|Inbrack
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|pptr
condition|)
break|break;
if|if
condition|(
name|pat
index|[
literal|1
index|]
operator|==
name|Hat
operator|||
name|pat
index|[
literal|1
index|]
operator|==
literal|'^'
condition|)
block|{
name|pat
index|[
literal|1
index|]
operator|=
name|Hat
expr_stmt|;
for|for
control|(
name|pat
operator|+=
literal|2
init|;
operator|*
name|pat
operator|!=
name|Outbrack
operator|&&
operator|*
name|pat
condition|;
name|pat
operator|++
control|)
if|if
condition|(
operator|*
name|pat
operator|==
literal|'-'
operator|&&
name|pat
index|[
operator|-
literal|1
index|]
operator|!=
name|Hat
operator|&&
name|pat
index|[
literal|1
index|]
operator|!=
name|Outbrack
condition|)
block|{
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|<=
operator|*
name|pptr
operator|&&
name|pat
index|[
literal|1
index|]
operator|>=
operator|*
name|pptr
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|pptr
operator|==
operator|*
name|pat
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|pat
condition|)
block|{
name|zerr
argument_list|(
literal|"something is very wrong."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|pat
operator|!=
name|Outbrack
condition|)
break|break;
name|pat
operator|++
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
for|for
control|(
name|pat
operator|++
init|;
operator|*
name|pat
operator|!=
name|Outbrack
operator|&&
operator|*
name|pat
condition|;
name|pat
operator|++
control|)
if|if
condition|(
operator|*
name|pat
operator|==
name|Inpar
condition|)
block|{
if|if
condition|(
name|minimatch
argument_list|(
operator|&
name|pat
argument_list|,
operator|&
name|pptr
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|pat
operator|==
literal|'-'
operator|&&
name|pat
index|[
operator|-
literal|1
index|]
operator|!=
name|Inbrack
operator|&&
name|pat
index|[
literal|1
index|]
operator|!=
name|Outbrack
condition|)
block|{
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|<=
operator|*
name|pptr
operator|&&
name|pat
index|[
literal|1
index|]
operator|>=
operator|*
name|pptr
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|pptr
operator|==
operator|*
name|pat
condition|)
break|break;
if|if
condition|(
operator|!
name|pat
operator|||
operator|!
operator|*
name|pat
condition|)
block|{
name|zerr
argument_list|(
literal|"oh dear.  that CAN'T be right."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|pat
operator|==
name|Outbrack
condition|)
break|break;
for|for
control|(
name|pptr
operator|++
init|;
operator|*
name|pat
operator|!=
name|Outbrack
condition|;
name|pat
operator|++
control|)
empty_stmt|;
name|pat
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|*
name|pat
operator|==
name|Inang
condition|)
block|{
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|pat
operator|==
name|Outang
condition|)
comment|/* handle<> case */
block|{
operator|(
name|void
operator|)
name|zstrtol
argument_list|(
name|pptr
argument_list|,
operator|&
name|ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|pptr
condition|)
break|break;
name|pptr
operator|=
name|ptr
expr_stmt|;
name|pat
operator|++
expr_stmt|;
block|}
else|else
block|{
name|t1
operator|=
name|zstrtol
argument_list|(
name|pptr
argument_list|,
operator|&
name|ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|pptr
condition|)
break|break;
name|pptr
operator|=
name|ptr
expr_stmt|;
name|t2
operator|=
name|zstrtol
argument_list|(
name|pat
argument_list|,
operator|&
name|ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'-'
condition|)
name|exit
argument_list|(
literal|31
argument_list|)
expr_stmt|;
name|t3
operator|=
name|zstrtol
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|&
name|pat
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t3
condition|)
name|t3
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pat
operator|++
operator|!=
name|Outang
condition|)
name|exit
argument_list|(
literal|21
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|<
name|t2
operator|||
operator|(
name|t3
operator|!=
operator|-
literal|1
operator|&&
name|t1
operator|>
name|t3
operator|)
condition|)
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
operator|*
name|pptr
operator|==
operator|*
name|pat
condition|)
block|{
name|pptr
operator|++
expr_stmt|;
name|pat
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|Complist
name|parsepat
parameter_list|(
name|str
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|exclude
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|EXTENDEDGLOB
argument_list|)
condition|)
block|{
name|s
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|--
operator|>
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|Tilde
operator|&&
name|s
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|exclude
operator|=
name|parsereg
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exclude
condition|)
return|return
name|NULL
return|;
break|break;
block|}
block|}
block|}
name|mode
operator|=
literal|0
expr_stmt|;
name|pptr
operator|=
name|str
expr_stmt|;
return|return
name|parsecomplist
argument_list|()
return|;
block|}
end_function

begin_function
name|Comp
name|parsereg
parameter_list|(
name|str
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|mode
operator|=
literal|1
expr_stmt|;
name|pptr
operator|=
name|str
expr_stmt|;
return|return
name|parsecompsw
argument_list|()
return|;
block|}
end_function

begin_function
name|Complist
name|parsecomplist
parameter_list|()
comment|/**/
block|{
name|Comp
name|c1
decl_stmt|;
name|Complist
name|p1
decl_stmt|;
if|if
condition|(
name|pptr
index|[
literal|0
index|]
operator|==
name|Star
operator|&&
name|pptr
index|[
literal|1
index|]
operator|==
name|Star
operator|&&
operator|(
name|pptr
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
operator|(
name|pptr
index|[
literal|2
index|]
operator|==
name|Star
operator|&&
name|pptr
index|[
literal|3
index|]
operator|==
name|Star
operator|&&
name|pptr
index|[
literal|4
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
name|pptr
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|pptr
index|[
operator|-
literal|1
index|]
operator|==
name|Star
condition|)
name|pptr
operator|+=
literal|2
expr_stmt|;
name|p1
operator|=
operator|(
name|Complist
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|->
name|next
operator|=
name|parsecomplist
argument_list|()
expr_stmt|;
name|p1
operator|->
name|comp
operator|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|p1
operator|->
name|comp
argument_list|)
expr_stmt|;
name|p1
operator|->
name|comp
operator|->
name|last
operator|=
literal|1
expr_stmt|;
name|p1
operator|->
name|comp
operator|->
name|str
operator|=
name|strdup
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
operator|*
name|p1
operator|->
name|comp
operator|->
name|str
operator|=
name|Star
expr_stmt|;
name|p1
operator|->
name|closure
operator|=
literal|1
expr_stmt|;
return|return
name|p1
return|;
block|}
if|if
condition|(
operator|*
name|pptr
operator|==
name|Inpar
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|pars
init|=
literal|1
decl_stmt|;
for|for
control|(
name|str
operator|=
name|pptr
operator|+
literal|1
init|;
operator|*
name|str
operator|&&
name|pars
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
name|Inpar
condition|)
name|pars
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|Outpar
condition|)
name|pars
operator|--
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
name|Pound
operator|||
name|str
index|[
operator|-
literal|1
index|]
operator|!=
name|Outpar
operator|||
name|str
index|[
operator|-
literal|2
index|]
operator|!=
literal|'/'
condition|)
goto|goto
name|kludge
goto|;
name|pptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c1
operator|=
name|parsecompsw
argument_list|()
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pptr
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|pptr
index|[
literal|1
index|]
operator|==
name|Outpar
operator|&&
name|pptr
index|[
literal|2
index|]
operator|==
name|Pound
condition|)
block|{
name|int
name|pdflag
init|=
literal|0
decl_stmt|;
name|pptr
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|pptr
operator|==
name|Pound
condition|)
block|{
name|pdflag
operator|=
literal|1
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
block|}
name|p1
operator|=
operator|(
name|Complist
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|->
name|comp
operator|=
name|c1
expr_stmt|;
name|p1
operator|->
name|closure
operator|=
literal|1
operator|+
name|pdflag
expr_stmt|;
name|p1
operator|->
name|next
operator|=
name|parsecomplist
argument_list|()
expr_stmt|;
return|return
operator|(
name|p1
operator|->
name|comp
operator|)
condition|?
name|p1
else|:
name|NULL
return|;
block|}
block|}
else|else
block|{
name|kludge
label|:
if|if
condition|(
operator|!
operator|(
name|c1
operator|=
name|parsecompsw
argument_list|()
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|pptr
operator|==
literal|'/'
operator|||
operator|!
operator|*
name|pptr
condition|)
block|{
name|int
name|ef
init|=
operator|*
name|pptr
operator|==
literal|'/'
decl_stmt|;
name|p1
operator|=
operator|(
name|Complist
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|p1
argument_list|)
expr_stmt|;
name|p1
operator|->
name|comp
operator|=
name|c1
expr_stmt|;
name|p1
operator|->
name|closure
operator|=
literal|0
expr_stmt|;
name|p1
operator|->
name|next
operator|=
operator|(
operator|*
name|pptr
operator|==
literal|'/'
operator|)
condition|?
operator|(
name|pptr
operator|++
operator|,
name|parsecomplist
argument_list|()
operator|)
else|:
name|NULL
expr_stmt|;
return|return
operator|(
name|ef
operator|&&
operator|!
name|p1
operator|->
name|next
operator|)
condition|?
name|NULL
else|:
name|p1
return|;
block|}
block|}
name|errflag
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Comp
name|parsecomp
parameter_list|()
comment|/**/
block|{
name|Comp
name|c
init|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|c
operator|->
name|str
operator|=
name|alloc
argument_list|(
name|MAXPATHLEN
operator|*
literal|2
argument_list|)
decl_stmt|,
modifier|*
name|ls
init|=
name|NULL
decl_stmt|;
name|c
operator|->
name|next
operator|=
name|tail
expr_stmt|;
while|while
condition|(
operator|*
name|pptr
operator|&&
operator|(
name|mode
operator|||
operator|*
name|pptr
operator|!=
literal|'/'
operator|)
operator|&&
operator|*
name|pptr
operator|!=
name|Bar
operator|&&
operator|*
name|pptr
operator|!=
name|Outpar
condition|)
block|{
if|if
condition|(
operator|*
name|pptr
operator|==
name|Hat
condition|)
block|{
operator|*
name|s
operator|++
operator|=
name|Hat
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|next
operator|=
name|parsecomp
argument_list|()
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|c
return|;
block|}
if|if
condition|(
operator|*
name|pptr
operator|==
name|Star
operator|&&
name|pptr
index|[
literal|1
index|]
operator|&&
operator|(
name|mode
operator|||
name|pptr
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
name|c1
operator|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|c1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|c1
operator|->
name|str
operator|=
name|strdup
argument_list|(
literal|"?"
argument_list|)
operator|)
operator|=
name|Quest
expr_stmt|;
name|c1
operator|->
name|closure
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c2
operator|=
name|parsecomp
argument_list|()
operator|)
condition|)
return|return
name|NULL
return|;
name|c1
operator|->
name|next
operator|=
name|c2
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|c1
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
operator|*
name|pptr
operator|==
name|Inpar
condition|)
block|{
name|int
name|pars
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|startp
init|=
name|pptr
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|Comp
name|stail
init|=
name|tail
decl_stmt|;
name|int
name|dpnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pptr
operator|=
name|pptr
operator|+
literal|1
init|;
operator|*
name|pptr
operator|&&
name|pars
condition|;
name|pptr
operator|++
control|)
if|if
condition|(
operator|*
name|pptr
operator|==
name|Inpar
condition|)
name|pars
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|pptr
operator|==
name|Outpar
condition|)
name|pars
operator|--
expr_stmt|;
if|if
condition|(
name|pptr
index|[
operator|-
literal|1
index|]
operator|!=
name|Outpar
condition|)
block|{
name|errflag
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|pptr
operator|==
name|Pound
condition|)
block|{
name|dpnd
operator|=
literal|1
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pptr
operator|==
name|Pound
condition|)
block|{
name|pptr
operator|++
expr_stmt|;
name|dpnd
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|c1
operator|=
name|parsecomp
argument_list|()
operator|)
condition|)
return|return
name|NULL
return|;
name|tail
operator|=
name|c1
expr_stmt|;
name|endp
operator|=
name|pptr
expr_stmt|;
name|pptr
operator|=
name|startp
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|->
name|next
operator|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|next
operator|->
name|left
operator|=
name|parsecompsw
argument_list|()
expr_stmt|;
name|c
operator|->
name|next
operator|->
name|closure
operator|=
name|dpnd
expr_stmt|;
name|c
operator|->
name|next
operator|->
name|next
operator|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|pptr
operator|=
name|endp
expr_stmt|;
name|tail
operator|=
name|stail
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
operator|*
name|pptr
operator|==
name|Pound
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|pptr
operator|==
name|Pound
condition|)
block|{
name|pptr
operator|++
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|c1
operator|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c1
operator|->
name|str
operator|=
name|strdup
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
else|else
name|c1
operator|=
name|c
expr_stmt|;
name|c1
operator|->
name|next
operator|=
name|c2
operator|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c2
operator|->
name|str
operator|=
name|strdup
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|c2
operator|->
name|closure
operator|=
literal|1
expr_stmt|;
name|c2
operator|->
name|next
operator|=
name|parsecomp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|c2
operator|->
name|next
condition|)
return|return
name|NULL
return|;
operator|*
name|ls
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|c
return|;
block|}
name|ls
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|pptr
operator|==
name|Inang
condition|)
block|{
name|int
name|dshct
decl_stmt|;
name|dshct
operator|=
operator|(
name|pptr
index|[
literal|1
index|]
operator|==
name|Outang
operator|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|*
name|pptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|pptr
operator|&&
operator|(
operator|*
name|s
operator|++
operator|=
operator|*
name|pptr
operator|++
operator|)
operator|!=
name|Outang
condition|)
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
name|dshct
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|idigit
argument_list|(
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
name|Outang
operator|||
name|dshct
operator|!=
literal|1
condition|)
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pptr
operator|==
name|Inbrack
condition|)
block|{
while|while
condition|(
operator|*
name|pptr
operator|&&
operator|(
operator|*
name|s
operator|++
operator|=
operator|*
name|pptr
operator|++
operator|)
operator|!=
name|Outbrack
condition|)
empty_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
name|Outbrack
condition|)
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|itok
argument_list|(
operator|*
name|pptr
argument_list|)
operator|&&
operator|*
name|pptr
operator|!=
name|Star
operator|&&
operator|*
name|pptr
operator|!=
name|Quest
condition|)
operator|*
name|s
operator|++
operator|=
name|ztokens
index|[
operator|*
name|pptr
operator|++
operator|-
name|Pound
index|]
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|pptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pptr
operator|==
literal|'/'
operator|||
operator|!
operator|*
name|pptr
condition|)
name|c
operator|->
name|last
operator|=
literal|1
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|Comp
name|parsecompsw
parameter_list|()
comment|/**/
block|{
name|Comp
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|c1
operator|=
name|parsecomp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|c1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|pptr
operator|==
name|Bar
condition|)
block|{
name|c2
operator|=
operator|(
name|Comp
operator|)
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|c2
argument_list|)
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
name|c3
operator|=
name|parsecompsw
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|c3
condition|)
return|return
name|NULL
return|;
name|c2
operator|->
name|str
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|c2
operator|->
name|left
operator|=
name|c1
expr_stmt|;
name|c2
operator|->
name|right
operator|=
name|c3
expr_stmt|;
return|return
name|c2
return|;
block|}
return|return
name|c1
return|;
block|}
end_function

begin_comment
comment|/* tokenize and see if ss matches tt */
end_comment

begin_function
name|int
name|patmatch
parameter_list|(
name|ss
parameter_list|,
name|tt
parameter_list|)
comment|/**/
name|char
modifier|*
name|ss
decl_stmt|;
name|char
modifier|*
name|tt
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|ss
decl_stmt|,
modifier|*
name|t
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|chuck
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|t
operator|=
name|ztokens
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|t
operator|==
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|=
operator|(
name|t
operator|-
name|ztokens
operator|)
operator|+
name|Pound
expr_stmt|;
break|break;
block|}
return|return
name|matchpat
argument_list|(
name|ss
argument_list|,
name|tt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* remove unnecessary Nulargs */
end_comment

begin_function
name|void
name|remnulargs
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|nl
init|=
operator|*
name|s
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|==
name|Nularg
condition|)
name|chuck
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t
operator|&&
name|nl
condition|)
block|{
name|t
index|[
literal|0
index|]
operator|=
name|Nularg
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* qualifier functions */
end_comment

begin_function
name|int
name|qualdev
parameter_list|(
name|buf
parameter_list|,
name|dv
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|dv
decl_stmt|;
block|{
return|return
name|buf
operator|->
name|st_dev
operator|==
name|dv
return|;
block|}
end_function

begin_function
name|int
name|qualnlink
parameter_list|(
name|buf
parameter_list|,
name|ct
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|ct
decl_stmt|;
block|{
return|return
name|buf
operator|->
name|st_nlink
operator|==
name|ct
return|;
block|}
end_function

begin_function
name|int
name|qualuid
parameter_list|(
name|buf
parameter_list|,
name|uid
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|uid
decl_stmt|;
block|{
return|return
name|buf
operator|->
name|st_uid
operator|==
name|uid
return|;
block|}
end_function

begin_function
name|int
name|qualgid
parameter_list|(
name|buf
parameter_list|,
name|gid
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|gid
decl_stmt|;
block|{
return|return
name|buf
operator|->
name|st_gid
operator|==
name|gid
return|;
block|}
end_function

begin_function
name|int
name|qualisdev
parameter_list|(
name|buf
parameter_list|,
name|junk
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|junk
decl_stmt|;
block|{
name|junk
operator|=
name|buf
operator|->
name|st_mode
operator|&
name|S_IFMT
expr_stmt|;
return|return
name|junk
operator|==
name|S_IFBLK
operator|||
name|junk
operator|==
name|S_IFCHR
return|;
block|}
end_function

begin_function
name|int
name|qualmode
parameter_list|(
name|buf
parameter_list|,
name|mod
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|mod
decl_stmt|;
block|{
return|return
operator|(
name|buf
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|mod
return|;
block|}
end_function

begin_function
name|int
name|qualflags
parameter_list|(
name|buf
parameter_list|,
name|mod
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|mod
decl_stmt|;
block|{
return|return
name|buf
operator|->
name|st_mode
operator|&
name|mod
return|;
block|}
end_function

begin_function
name|int
name|qualiscom
parameter_list|(
name|buf
parameter_list|,
name|mod
parameter_list|)
comment|/**/
name|struct
name|stat
modifier|*
name|buf
decl_stmt|;
name|long
name|mod
decl_stmt|;
block|{
return|return
operator|(
name|buf
operator|->
name|st_mode
operator|&
operator|(
name|S_IFMT
operator||
name|S_IEXEC
operator|)
operator|)
operator|==
operator|(
name|S_IFREG
operator||
name|S_IEXEC
operator|)
return|;
block|}
end_function

end_unit

