begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * exec.c - command execution  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|execerr
parameter_list|()
value|{ if (forked) exit(1); \ 	closemnodes(mfds); errflag = 1; return; }
end_define

begin_decl_stmt
specifier|static
name|Lklist
name|args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cmdnam
name|cn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parse list in a string */
end_comment

begin_function
name|List
name|parselstring
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|List
name|l
decl_stmt|;
name|hungets
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|strinbeg
argument_list|()
expr_stmt|;
name|pushheap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|l
operator|=
name|parse_list
argument_list|()
operator|)
condition|)
block|{
name|strinend
argument_list|()
expr_stmt|;
name|hflush
argument_list|()
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strinend
argument_list|()
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* execute a string */
end_comment

begin_function
name|void
name|execstring
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|List
name|l
decl_stmt|;
if|if
condition|(
name|l
operator|=
name|parselstring
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|execlist
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|popheap
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* fork and set limits */
end_comment

begin_function
name|int
name|phork
parameter_list|()
comment|/**/
block|{
name|int
name|pid
decl_stmt|,
name|t0
decl_stmt|;
if|if
condition|(
name|thisjob
operator|>=
name|MAXJOB
operator|-
literal|1
condition|)
block|{
name|zerr
argument_list|(
literal|"job table full"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|zerr
argument_list|(
literal|"fork failed: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|RLIM_INFINITY
if|if
condition|(
operator|!
name|pid
condition|)
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|RLIM_NLIMITS
condition|;
name|t0
operator|++
control|)
name|setrlimit
argument_list|(
name|t0
argument_list|,
name|limits
operator|+
name|t0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* execute a current shell command */
end_comment

begin_function
name|int
name|execcursh
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
block|{
name|runlist
argument_list|(
name|cmd
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|u
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
return|return
name|lastval
return|;
block|}
end_function

begin_comment
comment|/* execve after handling $_ and #! */
end_comment

begin_define
define|#
directive|define
name|POUNDBANGLIMIT
value|64
end_define

begin_function
name|int
name|zexecve
parameter_list|(
name|pth
parameter_list|,
name|argv
parameter_list|)
comment|/**/
name|char
modifier|*
name|pth
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|eno
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
operator|*
literal|2
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|eep
decl_stmt|;
for|for
control|(
name|eep
operator|=
name|environ
init|;
operator|*
name|eep
condition|;
name|eep
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|eep
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|eep
operator|)
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
break|break;
name|buf
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
if|if
condition|(
operator|*
name|pth
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
name|pth
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
operator|+
literal|2
argument_list|,
literal|"%s/%s"
argument_list|,
name|pwd
argument_list|,
name|pth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|eep
condition|)
name|eep
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|eep
operator|=
name|buf
expr_stmt|;
name|execve
argument_list|(
name|pth
argument_list|,
name|argv
argument_list|,
name|environ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eno
operator|=
name|errno
operator|)
operator|==
name|ENOEXEC
condition|)
block|{
name|char
name|buf
index|[
name|POUNDBANGLIMIT
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|,
modifier|*
name|argv0
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|ct
decl_stmt|,
name|t0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|pth
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|argv0
operator|=
operator|*
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
name|pth
expr_stmt|;
name|ct
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|POUNDBANGLIMIT
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|ct
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|t0
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|t0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
name|POUNDBANGLIMIT
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
operator|+
literal|2
init|;
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|==
literal|' '
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
for|for
control|(
name|ptr2
operator|=
name|ptr
init|;
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|' '
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|argv
index|[
operator|-
literal|2
index|]
operator|=
name|ptr2
expr_stmt|;
name|argv
index|[
operator|-
literal|1
index|]
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
name|execve
argument_list|(
name|ptr2
argument_list|,
name|argv
operator|-
literal|2
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
operator|-
literal|1
index|]
operator|=
name|ptr2
expr_stmt|;
name|execve
argument_list|(
name|ptr2
argument_list|,
name|argv
operator|-
literal|1
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|argv
index|[
operator|-
literal|1
index|]
operator|=
literal|"sh"
expr_stmt|;
name|execve
argument_list|(
literal|"/bin/sh"
argument_list|,
name|argv
operator|-
literal|1
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|ct
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|buf
index|[
name|t0
index|]
condition|)
break|break;
if|if
condition|(
name|t0
operator|==
name|ct
condition|)
block|{
name|argv
index|[
operator|-
literal|1
index|]
operator|=
literal|"sh"
expr_stmt|;
name|execve
argument_list|(
literal|"/bin/sh"
argument_list|,
name|argv
operator|-
literal|1
argument_list|,
name|environ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|eno
operator|=
name|errno
expr_stmt|;
operator|*
name|argv
operator|=
name|argv0
expr_stmt|;
block|}
else|else
name|eno
operator|=
name|errno
expr_stmt|;
block|}
return|return
name|eno
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXCMDLEN
value|(MAXPATHLEN*4)
end_define

begin_comment
comment|/* execute an external command */
end_comment

begin_function
name|void
name|execute
parameter_list|(
name|dash
parameter_list|)
comment|/**/
name|int
name|dash
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
name|arg0
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|buf
index|[
name|MAXCMDLEN
index|]
decl_stmt|,
name|buf2
index|[
name|MAXCMDLEN
index|]
decl_stmt|;
name|int
name|ee
init|=
literal|0
decl_stmt|,
name|eno
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|full
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"no command"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cn
operator|=
operator|(
name|Cmdnam
operator|)
name|gethnode
argument_list|(
name|peekfirst
argument_list|(
name|args
argument_list|)
argument_list|,
name|cmdnamtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|type
operator|==
name|DISABLED
condition|)
name|cn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|zgetenv
argument_list|(
literal|"STTY"
argument_list|)
condition|)
name|zyztem
argument_list|(
literal|"stty"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|peekfirst
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|=
name|zgetenv
argument_list|(
literal|"ARGV0"
argument_list|)
condition|)
block|{
name|setdata
argument_list|(
name|firstnode
argument_list|(
name|args
argument_list|)
argument_list|,
name|ztrdup
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|delenv
argument_list|(
name|z
operator|-
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dash
condition|)
block|{
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"-%s"
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|setdata
argument_list|(
name|firstnode
argument_list|(
name|args
argument_list|)
argument_list|,
name|ztrdup
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argv
operator|=
name|makecline
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fixsigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|arg0
argument_list|)
operator|>
name|MAXPATHLEN
condition|)
block|{
name|zerr
argument_list|(
literal|"command too long: %s"
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|arg0
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
name|errno
operator|=
name|zexecve
argument_list|(
name|arg0
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|s
operator|||
name|unset
argument_list|(
name|PATHDIRS
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"%e: %s"
argument_list|,
name|arg0
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|cn
operator|&&
name|ISEXCMD
argument_list|(
name|cn
operator|->
name|type
argument_list|)
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|path
init|;
name|pp
operator|<
name|cn
operator|->
name|pcomp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'.'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ee
operator|=
name|zexecve
argument_list|(
name|arg0
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|ee
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'/'
condition|)
block|{
name|z
operator|=
name|buf
expr_stmt|;
name|strucpy
argument_list|(
operator|&
name|z
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|z
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|ee
operator|=
name|zexecve
argument_list|(
name|buf
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|ee
expr_stmt|;
block|}
name|ee
operator|=
name|zexecve
argument_list|(
name|cn
operator|->
name|u
operator|.
name|nam
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|ee
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
name|path
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
condition|)
block|{
name|ee
operator|=
name|zexecve
argument_list|(
name|arg0
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|ee
expr_stmt|;
block|}
else|else
block|{
name|z
operator|=
name|buf
expr_stmt|;
name|strucpy
argument_list|(
operator|&
name|z
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|z
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|ee
operator|=
name|zexecve
argument_list|(
name|buf
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|!=
name|ENOENT
condition|)
name|eno
operator|=
name|ee
expr_stmt|;
block|}
if|if
condition|(
name|eno
condition|)
name|zerr
argument_list|(
literal|"%e: %s"
argument_list|,
name|arg0
argument_list|,
name|eno
argument_list|)
expr_stmt|;
else|else
name|zerr
argument_list|(
literal|"command not found: %s"
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|try
parameter_list|(
name|X
parameter_list|)
value|{ if (iscom(X)) return ztrdup(X); }
end_define

begin_comment
comment|/* get the full pathname of an external command */
end_comment

begin_function
name|char
modifier|*
name|findcmd
parameter_list|(
name|arg0
parameter_list|)
comment|/**/
name|char
modifier|*
name|arg0
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|buf
index|[
name|MAXCMDLEN
index|]
decl_stmt|;
name|cn
operator|=
operator|(
name|Cmdnam
operator|)
name|gethnode
argument_list|(
name|arg0
argument_list|,
name|cmdnamtab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cn
operator|&&
name|isset
argument_list|(
name|HASHCMDS
argument_list|)
condition|)
name|hashcmd
argument_list|(
name|arg0
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|type
operator|==
name|DISABLED
condition|)
name|cn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|arg0
argument_list|)
operator|>
name|MAXPATHLEN
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|s
operator|=
name|arg0
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
name|try
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg0
operator|==
name|s
operator|||
name|unset
argument_list|(
name|PATHDIRS
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
break|break;
block|}
if|if
condition|(
name|cn
operator|&&
name|ISEXCMD
argument_list|(
name|cn
operator|->
name|type
argument_list|)
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|path
init|;
name|pp
operator|<
name|cn
operator|->
name|pcomp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'/'
condition|)
block|{
name|z
operator|=
name|buf
expr_stmt|;
name|strucpy
argument_list|(
operator|&
name|z
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|z
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|try
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|try
argument_list|(
name|cn
operator|->
name|u
operator|.
name|nam
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
name|path
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
block|{
name|z
operator|=
name|buf
expr_stmt|;
name|strucpy
argument_list|(
operator|&
name|z
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|z
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|try
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|iscom
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
return|return
operator|(
name|access
argument_list|(
name|s
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isrelative
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'/'
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|hashcmd
parameter_list|(
name|arg0
parameter_list|,
name|pp
parameter_list|)
comment|/**/
name|char
modifier|*
name|arg0
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|pq
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
for|for
control|(
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'/'
condition|)
block|{
name|s
operator|=
name|buf
expr_stmt|;
name|strucpy
argument_list|(
operator|&
name|s
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscom
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|pp
operator|||
name|isrelative
argument_list|(
operator|*
name|pp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cn
operator|=
operator|(
name|Cmdnam
operator|)
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|cn
argument_list|)
expr_stmt|;
name|cn
operator|->
name|type
operator|=
name|EXCMD
expr_stmt|;
name|cn
operator|->
name|pcomp
operator|=
name|pp
expr_stmt|;
name|cn
operator|->
name|u
operator|.
name|nam
operator|=
name|ztrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|cn
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|unset
argument_list|(
name|HASHDIRS
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|pq
operator|=
name|pathchecked
init|;
name|pq
operator|<=
name|pp
condition|;
name|pq
operator|++
control|)
block|{
if|if
condition|(
name|isrelative
argument_list|(
operator|*
name|pq
argument_list|)
operator|||
operator|!
operator|(
name|dir
operator|=
name|opendir
argument_list|(
operator|*
name|pq
argument_list|)
operator|)
condition|)
continue|continue;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
condition|)
name|addhcmdnode
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
name|pq
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|pathchecked
operator|=
name|pp
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|fullhash
parameter_list|()
comment|/**/
block|{
name|char
modifier|*
modifier|*
name|pq
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
for|for
control|(
name|pq
operator|=
name|pathchecked
init|;
operator|*
name|pq
condition|;
name|pq
operator|++
control|)
block|{
if|if
condition|(
name|isrelative
argument_list|(
operator|*
name|pq
argument_list|)
operator|||
operator|!
operator|(
name|dir
operator|=
name|opendir
argument_list|(
operator|*
name|pq
argument_list|)
operator|)
condition|)
continue|continue;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
condition|)
name|addhcmdnode
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
name|pq
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|pathchecked
operator|=
name|pq
expr_stmt|;
block|}
end_function

begin_function
name|void
name|execlist
parameter_list|(
name|list
parameter_list|)
comment|/**/
name|List
name|list
decl_stmt|;
block|{
if|if
condition|(
name|breaks
condition|)
return|return;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
name|simplifyright
argument_list|(
name|list
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|list
operator|->
name|type
condition|)
block|{
case|case
name|SYNC
case|:
case|case
name|ASYNC
case|:
name|execlist2
argument_list|(
name|list
operator|->
name|left
argument_list|,
name|list
operator|->
name|type
argument_list|,
operator|!
name|list
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtrapped
index|[
name|SIGDEBUG
index|]
condition|)
name|dotrap
argument_list|(
name|SIGDEBUG
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtrapped
index|[
name|SIGERR
index|]
operator|&&
name|lastval
condition|)
name|dotrap
argument_list|(
name|SIGERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|right
operator|&&
operator|!
name|retflag
condition|)
name|execlist
argument_list|(
name|list
operator|->
name|right
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|execlist2
parameter_list|(
name|list
parameter_list|,
name|type
parameter_list|,
name|last1
parameter_list|)
comment|/**/
name|Sublist
name|list
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|last1
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|list
condition|)
return|return;
switch|switch
condition|(
name|list
operator|->
name|type
condition|)
block|{
case|case
name|END
case|:
name|execpline
argument_list|(
name|list
argument_list|,
name|type
argument_list|,
name|last1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORNEXT
case|:
if|if
condition|(
operator|!
name|execpline
argument_list|(
name|list
argument_list|,
name|SYNC
argument_list|,
literal|0
argument_list|)
condition|)
name|execlist2
argument_list|(
name|list
operator|->
name|right
argument_list|,
name|type
argument_list|,
name|last1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|list
operator|=
name|list
operator|->
name|right
condition|)
if|if
condition|(
name|list
operator|->
name|type
operator|==
name|ANDNEXT
condition|)
block|{
name|execlist2
argument_list|(
name|list
operator|->
name|right
argument_list|,
name|type
argument_list|,
name|last1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|ANDNEXT
case|:
if|if
condition|(
name|execpline
argument_list|(
name|list
argument_list|,
name|SYNC
argument_list|,
literal|0
argument_list|)
condition|)
name|execlist2
argument_list|(
name|list
operator|->
name|right
argument_list|,
name|type
argument_list|,
name|last1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|list
operator|=
name|list
operator|->
name|right
condition|)
if|if
condition|(
name|list
operator|->
name|type
operator|==
name|ORNEXT
condition|)
block|{
name|execlist2
argument_list|(
name|list
operator|->
name|right
argument_list|,
name|type
argument_list|,
name|last1
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|int
name|execpline
parameter_list|(
name|l
parameter_list|,
name|how
parameter_list|,
name|last1
parameter_list|)
comment|/**/
name|Sublist
name|l
decl_stmt|;
name|int
name|how
decl_stmt|;
name|int
name|last1
decl_stmt|;
block|{
name|int
name|ipipe
index|[
literal|2
index|]
decl_stmt|,
name|opipe
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
return|return
literal|0
return|;
name|ipipe
index|[
literal|0
index|]
operator|=
name|ipipe
index|[
literal|1
index|]
operator|=
name|opipe
index|[
literal|0
index|]
operator|=
name|opipe
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|blockchld
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|thisjob
operator|=
name|getfreejob
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
name|initjob
argument_list|()
expr_stmt|;
if|if
condition|(
name|how
operator|==
name|TIMED
condition|)
block|{
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|stat
operator||=
name|STAT_TIMED
expr_stmt|;
name|how
operator|=
name|SYNC
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|->
name|flags
operator|&
name|PFLAG_COPROC
condition|)
block|{
name|how
operator|=
name|ASYNC
expr_stmt|;
if|if
condition|(
name|coprocin
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|coprocin
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|coprocout
argument_list|)
expr_stmt|;
block|}
name|mpipe
argument_list|(
name|ipipe
argument_list|)
expr_stmt|;
name|mpipe
argument_list|(
name|opipe
argument_list|)
expr_stmt|;
name|coprocin
operator|=
name|ipipe
index|[
literal|0
index|]
expr_stmt|;
name|coprocout
operator|=
name|opipe
index|[
literal|1
index|]
expr_stmt|;
block|}
name|execpline2
argument_list|(
name|l
operator|->
name|left
argument_list|,
name|how
argument_list|,
name|opipe
index|[
literal|0
index|]
argument_list|,
name|ipipe
index|[
literal|1
index|]
argument_list|,
name|last1
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|==
name|ASYNC
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|flags
operator|&
name|PFLAG_COPROC
condition|)
name|close
argument_list|(
name|ipipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|spawnjob
argument_list|()
expr_stmt|;
name|unblockchld
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|waitjobs
argument_list|()
expr_stmt|;
name|unblockchld
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|flags
operator|&
name|PFLAG_NOT
condition|)
name|lastval
operator|=
operator|!
name|lastval
expr_stmt|;
return|return
operator|!
name|lastval
return|;
block|}
block|}
end_function

begin_function
name|void
name|execpline2
parameter_list|(
name|pline
parameter_list|,
name|how
parameter_list|,
name|input
parameter_list|,
name|output
parameter_list|,
name|last1
parameter_list|)
comment|/**/
name|Pline
name|pline
decl_stmt|;
name|int
name|how
decl_stmt|;
name|int
name|input
decl_stmt|;
name|int
name|output
decl_stmt|;
name|int
name|last1
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|breaks
condition|)
return|return;
if|if
condition|(
operator|!
name|pline
condition|)
return|return;
if|if
condition|(
name|pline
operator|->
name|type
operator|==
name|END
condition|)
block|{
name|execcmd
argument_list|(
name|pline
operator|->
name|left
argument_list|,
name|input
argument_list|,
name|output
argument_list|,
name|how
operator|==
name|ASYNC
argument_list|,
name|last1
argument_list|)
expr_stmt|;
name|pline
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mpipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
if|if
condition|(
name|pline
operator|->
name|left
operator|->
name|type
operator|>=
name|CURSH
operator|&&
name|how
operator|==
name|SYNC
condition|)
block|{
comment|/* if we are doing "foo | bar" where foo is a current 				shell command, do foo in a subshell and do 				the rest of the pipeline in the current shell. */
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|entersubsh
argument_list|(
name|how
operator|==
name|ASYNC
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
name|execcmd
argument_list|(
name|pline
operator|->
name|left
argument_list|,
name|input
argument_list|,
name|pipes
index|[
literal|1
index|]
argument_list|,
name|how
operator|==
name|ASYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|lastval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|zerr
argument_list|(
literal|"fork failed: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|text
init|=
name|getjobtext
argument_list|(
operator|(
name|vptr
operator|)
name|pline
operator|->
name|left
argument_list|)
decl_stmt|;
name|addproc
argument_list|(
name|pid
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* otherwise just do the pipeline normally. */
name|execcmd
argument_list|(
name|pline
operator|->
name|left
argument_list|,
name|input
argument_list|,
name|pipes
index|[
literal|1
index|]
argument_list|,
name|how
operator|==
name|ASYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pline
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pline
operator|->
name|right
condition|)
block|{
name|execpline2
argument_list|(
name|pline
operator|->
name|right
argument_list|,
name|how
argument_list|,
name|pipes
index|[
literal|0
index|]
argument_list|,
name|output
argument_list|,
name|last1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* make the argv array */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|makecline
parameter_list|(
name|list
parameter_list|)
comment|/**/
name|struct
name|lklist
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|ct
init|=
literal|0
decl_stmt|;
name|Lknode
name|node
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|XTRACE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|prompt4
operator|)
condition|?
name|prompt4
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|list
argument_list|)
init|;
name|node
condition|;
name|incnode
argument_list|(
name|node
argument_list|)
operator|,
name|ct
operator|++
control|)
empty_stmt|;
name|ptr
operator|=
name|argv
operator|=
literal|2
operator|+
operator|(
name|char
operator|*
operator|*
operator|)
name|ncalloc
argument_list|(
operator|(
name|ct
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|list
argument_list|)
init|;
name|node
condition|;
name|incnode
argument_list|(
name|node
argument_list|)
control|)
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
name|getdata
argument_list|(
name|node
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|getdata
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|untokenize
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextnode
argument_list|(
name|node
argument_list|)
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
name|argv
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|list
argument_list|)
init|;
name|node
condition|;
name|incnode
argument_list|(
name|node
argument_list|)
operator|,
name|ct
operator|++
control|)
empty_stmt|;
name|ptr
operator|=
name|argv
operator|=
literal|2
operator|+
operator|(
name|char
operator|*
operator|*
operator|)
name|ncalloc
argument_list|(
operator|(
name|ct
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|list
argument_list|)
init|;
name|node
condition|;
name|incnode
argument_list|(
name|node
argument_list|)
control|)
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
name|getdata
argument_list|(
name|node
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|getdata
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|untokenize
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|argv
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* untokenize the command line and remove null arguments */
end_comment

begin_function
name|void
name|fixcline
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
block|{
name|Lknode
name|node
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|node
operator|=
name|firstnode
argument_list|(
name|l
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|next
control|)
block|{
name|next
operator|=
name|nextnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|(
name|char
operator|*
operator|)
name|getdata
argument_list|(
name|node
argument_list|)
condition|)
name|uremnode
argument_list|(
name|l
argument_list|,
name|node
argument_list|)
expr_stmt|;
else|else
name|untokenize
argument_list|(
name|getdata
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|untokenize
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|itok
argument_list|(
operator|*
name|s
argument_list|)
condition|)
if|if
condition|(
operator|*
name|s
operator|==
name|Nularg
condition|)
name|chuck
argument_list|(
name|s
operator|--
argument_list|)
expr_stmt|;
else|else
operator|*
name|s
operator|=
name|ztokens
index|[
operator|*
name|s
operator|-
name|Pound
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nonzero if we shouldn't clobber a file */
end_comment

begin_function
name|int
name|dontclob
parameter_list|(
name|f
parameter_list|)
comment|/**/
name|struct
name|redir
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|unset
argument_list|(
name|NOCLOBBER
argument_list|)
operator|||
name|f
operator|->
name|type
operator|&
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|stat
argument_list|(
name|f
operator|->
name|name
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
return|return
name|S_ISREG
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* close an multio (success) */
end_comment

begin_function
name|void
name|closemn
parameter_list|(
name|mfds
parameter_list|,
name|fd
parameter_list|)
comment|/**/
name|struct
name|multio
modifier|*
modifier|*
name|mfds
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|mfds
index|[
name|fd
index|]
condition|)
block|{
if|if
condition|(
name|mfds
index|[
name|fd
index|]
operator|->
name|ct
operator|>
literal|1
condition|)
if|if
condition|(
name|mfds
index|[
name|fd
index|]
operator|->
name|rflag
operator|==
literal|0
condition|)
name|catproc
argument_list|(
name|mfds
index|[
name|fd
index|]
argument_list|)
expr_stmt|;
else|else
name|teeproc
argument_list|(
name|mfds
index|[
name|fd
index|]
argument_list|)
expr_stmt|;
name|mfds
index|[
name|fd
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* close all the mnodes (failure) */
end_comment

begin_function
name|void
name|closemnodes
parameter_list|(
name|mfds
parameter_list|)
comment|/**/
name|struct
name|multio
modifier|*
modifier|*
name|mfds
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|,
name|t1
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|10
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|mfds
index|[
name|t0
index|]
condition|)
block|{
for|for
control|(
name|t1
operator|=
literal|0
init|;
name|t1
operator|!=
name|mfds
index|[
name|t0
index|]
operator|->
name|ct
condition|;
name|t1
operator|++
control|)
name|close
argument_list|(
name|mfds
index|[
name|t0
index|]
operator|->
name|fds
index|[
name|t1
index|]
argument_list|)
expr_stmt|;
name|mfds
index|[
name|t0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* add a fd to an multio */
end_comment

begin_comment
comment|/* an multio is a list of fds associated with a certain fd. 	thus if you do "foo>bar>ble", the multio for fd 1 will have 	two fds, the result of open("bar",...), and the result of 	open("ble",....). */
end_comment

begin_function
name|void
name|addfd
parameter_list|(
name|forked
parameter_list|,
name|save
parameter_list|,
name|mfds
parameter_list|,
name|fd1
parameter_list|,
name|fd2
parameter_list|,
name|rflag
parameter_list|)
comment|/**/
name|int
name|forked
decl_stmt|;
name|int
modifier|*
name|save
decl_stmt|;
name|struct
name|multio
modifier|*
modifier|*
name|mfds
decl_stmt|;
name|int
name|fd1
decl_stmt|;
name|int
name|fd2
decl_stmt|;
name|int
name|rflag
decl_stmt|;
block|{
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|mfds
index|[
name|fd1
index|]
condition|)
block|{
comment|/* starting a new multio */
name|mfds
index|[
name|fd1
index|]
operator|=
operator|(
expr|struct
name|multio
operator|*
operator|)
name|alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|multio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forked
operator|&&
name|fd1
operator|!=
name|fd2
operator|&&
name|fd1
operator|<
literal|10
condition|)
name|save
index|[
name|fd1
index|]
operator|=
name|movefd
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|redup
argument_list|(
name|fd2
argument_list|,
name|fd1
argument_list|)
expr_stmt|;
name|mfds
index|[
name|fd1
index|]
operator|->
name|ct
operator|=
literal|1
expr_stmt|;
name|mfds
index|[
name|fd1
index|]
operator|->
name|fds
index|[
literal|0
index|]
operator|=
name|fd1
expr_stmt|;
name|mfds
index|[
name|fd1
index|]
operator|->
name|rflag
operator|=
name|rflag
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mfds
index|[
name|fd1
index|]
operator|->
name|rflag
operator|!=
name|rflag
condition|)
block|{
name|zerr
argument_list|(
literal|"file mode mismatch on fd %d"
argument_list|,
name|NULL
argument_list|,
name|fd1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mfds
index|[
name|fd1
index|]
operator|->
name|ct
operator|==
literal|1
condition|)
block|{
comment|/* split the stream */
name|mfds
index|[
name|fd1
index|]
operator|->
name|fds
index|[
literal|0
index|]
operator|=
name|movefd
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
name|mfds
index|[
name|fd1
index|]
operator|->
name|fds
index|[
literal|1
index|]
operator|=
name|movefd
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
name|mpipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
name|mfds
index|[
name|fd1
index|]
operator|->
name|pipe
operator|=
name|pipes
index|[
literal|1
operator|-
name|rflag
index|]
expr_stmt|;
name|redup
argument_list|(
name|pipes
index|[
name|rflag
index|]
argument_list|,
name|fd1
argument_list|)
expr_stmt|;
name|mfds
index|[
name|fd1
index|]
operator|->
name|ct
operator|=
literal|2
expr_stmt|;
block|}
else|else
comment|/* add another fd to an already split stream */
name|mfds
index|[
name|fd1
index|]
operator|->
name|fds
index|[
name|mfds
index|[
name|fd1
index|]
operator|->
name|ct
operator|++
index|]
operator|=
name|movefd
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|addvars
parameter_list|(
name|l
parameter_list|,
name|export
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
name|int
name|export
decl_stmt|;
block|{
name|struct
name|varasg
modifier|*
name|v
decl_stmt|;
name|Lklist
name|vl
decl_stmt|;
while|while
condition|(
name|full
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|arr
decl_stmt|,
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|v
operator|=
operator|(
expr|struct
name|varasg
operator|*
operator|)
name|ugetnode
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
name|untokenize
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|type
operator|==
name|PMFLAG_s
condition|)
block|{
name|vl
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|vl
argument_list|,
name|v
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|vl
operator|=
name|v
operator|->
name|arr
expr_stmt|;
name|prefork
argument_list|(
name|vl
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
name|postfork
argument_list|(
name|vl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
if|if
condition|(
name|v
operator|->
name|type
operator|==
name|PMFLAG_s
operator|&&
operator|(
operator|!
name|full
argument_list|(
name|vl
argument_list|)
operator|||
operator|!
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|vl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|Param
name|pm
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|full
argument_list|(
name|vl
argument_list|)
condition|)
name|pm
operator|=
name|setsparam
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|val
operator|=
name|ztrdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|untokenize
argument_list|(
name|peekfirst
argument_list|(
name|vl
argument_list|)
argument_list|)
expr_stmt|;
name|pm
operator|=
name|setsparam
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|val
operator|=
name|ztrdup
argument_list|(
name|ugetnode
argument_list|(
name|vl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|export
operator|&&
operator|!
operator|(
name|pm
operator|->
name|flags
operator|&
name|PMFLAG_x
operator|)
condition|)
name|addenv
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ptr
operator|=
name|arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
operator|(
name|countnodes
argument_list|(
name|vl
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|full
argument_list|(
name|vl
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|ugetnode
argument_list|(
name|vl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
block|{
operator|*
name|ptr
operator|=
name|ztrdup
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|untokenize
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ptr
operator|=
name|NULL
expr_stmt|;
name|setaparam
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|arr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|execcmd
parameter_list|(
name|cmd
parameter_list|,
name|input
parameter_list|,
name|output
parameter_list|,
name|bkg
parameter_list|,
name|last1
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
name|int
name|input
decl_stmt|;
name|int
name|output
decl_stmt|;
name|int
name|bkg
decl_stmt|;
name|int
name|last1
decl_stmt|;
block|{
name|int
name|type
decl_stmt|;
name|long
name|pid
init|=
literal|0
decl_stmt|;
name|int
name|save
index|[
literal|10
index|]
decl_stmt|,
name|t0
decl_stmt|;
name|struct
name|redir
modifier|*
name|fn
decl_stmt|;
name|struct
name|multio
modifier|*
name|mfds
index|[
literal|10
index|]
decl_stmt|;
name|int
name|fil
decl_stmt|,
name|forked
init|=
literal|0
decl_stmt|,
name|iscursh
init|=
literal|0
decl_stmt|,
name|nullexec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|args
operator|=
name|cmd
operator|->
name|args
expr_stmt|;
name|cn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|10
condition|;
name|t0
operator|++
control|)
block|{
name|save
index|[
name|t0
index|]
operator|=
literal|0
expr_stmt|;
name|mfds
index|[
name|t0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|=
name|cmd
operator|->
name|type
operator|)
operator|==
name|SIMPLE
operator|&&
operator|!
name|full
argument_list|(
name|args
argument_list|)
condition|)
if|if
condition|(
name|full
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
condition|)
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|CFLAG_EXEC
condition|)
block|{
name|nullexec
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|nullcmd
condition|)
block|{
name|zerr
argument_list|(
literal|"redirection with no command"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errflag
operator|=
name|lastval
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|readnullcmd
operator|&&
operator|(
operator|(
name|Redir
operator|)
name|peekfirst
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
operator|)
operator|->
name|type
operator|==
name|READ
operator|&&
operator|!
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
argument_list|)
condition|)
block|{
name|addnode
argument_list|(
name|args
argument_list|,
name|strdup
argument_list|(
name|readnullcmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|addnode
argument_list|(
name|args
argument_list|,
name|strdup
argument_list|(
name|nullcmd
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|addvars
argument_list|(
name|cmd
operator|->
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|full
argument_list|(
name|args
argument_list|)
operator|&&
operator|*
operator|(
name|char
operator|*
operator|)
name|peekfirst
argument_list|(
name|args
argument_list|)
operator|==
literal|'%'
condition|)
block|{
name|insnode
argument_list|(
name|args
argument_list|,
operator|(
name|Lknode
operator|)
name|args
argument_list|,
name|strdup
argument_list|(
operator|(
name|bkg
operator|)
condition|?
literal|"bg"
else|:
literal|"fg"
argument_list|)
argument_list|)
expr_stmt|;
name|bkg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|AUTORESUME
argument_list|)
operator|&&
operator|!
name|bkg
operator|&&
operator|!
name|full
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
operator|&&
name|full
argument_list|(
name|args
argument_list|)
operator|&&
operator|!
name|input
operator|&&
name|type
operator|==
name|SIMPLE
operator|&&
operator|!
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|unset
argument_list|(
name|NOTIFY
argument_list|)
condition|)
name|scanjobs
argument_list|()
expr_stmt|;
if|if
condition|(
name|findjobnam
argument_list|(
name|peekfirst
argument_list|(
name|args
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|pushnode
argument_list|(
name|args
argument_list|,
name|strdup
argument_list|(
literal|"fg"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unset
argument_list|(
name|RMSTARSILENT
argument_list|)
operator|&&
name|interact
operator|&&
name|isset
argument_list|(
name|SHINSTDIN
argument_list|)
operator|&&
name|type
operator|==
name|SIMPLE
operator|&&
name|full
argument_list|(
name|args
argument_list|)
operator|&&
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|args
argument_list|)
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|peekfirst
argument_list|(
name|args
argument_list|)
argument_list|,
literal|"rm"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|getdata
argument_list|(
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
name|Star
operator|&&
operator|!
name|s
index|[
literal|1
index|]
condition|)
name|checkrmall
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|>
literal|2
operator|&&
name|s
index|[
name|l
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|&&
name|s
index|[
name|l
operator|-
literal|1
index|]
operator|==
name|Star
condition|)
block|{
name|char
name|t
init|=
name|s
index|[
name|l
operator|-
literal|2
index|]
decl_stmt|;
name|s
index|[
name|l
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|checkrmall
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
index|[
name|l
operator|-
literal|2
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|jobbing
condition|)
block|{
comment|/* get the text associated with this command */
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|text
operator|=
name|getjobtext
argument_list|(
operator|(
name|vptr
operator|)
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
name|text
operator|=
name|NULL
expr_stmt|;
name|prefork
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* do prefork substitutions */
if|if
condition|(
name|errflag
condition|)
block|{
name|lastval
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|full
argument_list|(
name|args
argument_list|)
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|peekfirst
argument_list|(
name|args
argument_list|)
operator|)
index|[
literal|0
index|]
operator|==
name|Inbrack
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|peekfirst
argument_list|(
name|args
argument_list|)
operator|)
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
name|char
operator|*
operator|)
name|peekfirst
argument_list|(
name|args
argument_list|)
operator|)
index|[
literal|0
index|]
operator|=
literal|'['
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SIMPLE
operator|&&
name|full
argument_list|(
name|args
argument_list|)
operator|&&
operator|!
operator|(
name|cmd
operator|->
name|flags
operator|&
name|CFLAG_COMMAND
operator|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|cn
operator|=
operator|(
name|Cmdnam
operator|)
name|gethnode
argument_list|(
name|t
operator|=
name|s
operator|=
name|peekfirst
argument_list|(
name|args
argument_list|)
argument_list|,
name|cmdnamtab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cn
operator|&&
name|isset
argument_list|(
name|HASHCMDS
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|t
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|'/'
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|t
condition|)
name|hashcmd
argument_list|(
name|s
argument_list|,
name|pathchecked
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|SIMPLE
operator|&&
operator|!
name|cn
operator|&&
name|isset
argument_list|(
name|AUTOCD
argument_list|)
operator|&&
name|isset
argument_list|(
name|SHINSTDIN
argument_list|)
operator|&&
name|full
argument_list|(
name|args
argument_list|)
operator|&&
operator|!
name|full
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
operator|&&
operator|!
name|nextnode
argument_list|(
name|firstnode
argument_list|(
name|args
argument_list|)
argument_list|)
operator|&&
name|cancd
argument_list|(
name|peekfirst
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
block|{
name|pushnode
argument_list|(
name|args
argument_list|,
name|strdup
argument_list|(
literal|"cd"
argument_list|)
argument_list|)
expr_stmt|;
name|cn
operator|=
operator|(
name|Cmdnam
operator|)
name|gethnode
argument_list|(
literal|"cd"
argument_list|,
name|cmdnamtab
argument_list|)
expr_stmt|;
block|}
comment|/* this is nonzero if cmd is a current shell procedure */
name|iscursh
operator|=
operator|(
name|type
operator|>=
name|CURSH
operator|)
operator|||
operator|(
name|type
operator|==
name|SIMPLE
operator|&&
name|cn
operator|&&
operator|(
name|cn
operator|->
name|type
operator|==
name|BUILTIN
operator|||
name|cn
operator|->
name|type
operator|==
name|SHFUNC
operator|)
operator|)
expr_stmt|;
comment|/* if this command is backgrounded or (this is an external 		command and we are not exec'ing it) or this is a builtin 		with output piped somewhere, then fork.  If this is the 		last stage in a subshell pipeline, don't fork, but make 		the rest of the function think we forked. */
if|if
condition|(
name|bkg
operator|||
operator|!
operator|(
name|iscursh
operator|||
operator|(
name|cmd
operator|->
name|flags
operator|&
name|CFLAG_EXEC
operator|)
operator|)
operator|||
operator|(
name|cn
operator|&&
operator|(
name|cn
operator|->
name|type
operator|==
name|BUILTIN
operator|||
name|cn
operator|->
name|type
operator|==
name|SHFUNC
operator|)
operator|&&
name|output
operator|)
condition|)
block|{
name|int
name|synch
index|[
literal|2
index|]
decl_stmt|;
name|pipe
argument_list|(
name|synch
argument_list|)
expr_stmt|;
name|pid
operator|=
operator|(
name|last1
operator|&&
name|execok
argument_list|()
operator|)
condition|?
literal|0
else|:
name|phork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|synch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|synch
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pid
condition|)
block|{
name|close
argument_list|(
name|synch
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|synch
index|[
literal|0
index|]
argument_list|,
literal|"foo"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|synch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|zerr
argument_list|(
literal|"%e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bkg
condition|)
name|lastpid
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|addproc
argument_list|(
name|pid
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|close
argument_list|(
name|synch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|entersubsh
argument_list|(
name|bkg
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|synch
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|forked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bkg
operator|&&
name|isset
argument_list|(
name|BGNICE
argument_list|)
condition|)
name|nice
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* perform postfork substitutions */
name|postfork
argument_list|(
name|args
argument_list|,
operator|!
operator|(
name|cmd
operator|->
name|flags
operator|&
name|CFLAG_NOGLOB
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
block|{
name|lastval
operator|=
literal|1
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
name|full
argument_list|(
name|args
argument_list|)
operator|&&
operator|(
name|s
operator|=
name|peekfirst
argument_list|(
name|args
argument_list|)
operator|)
operator|&&
operator|!
operator|*
name|s
condition|)
name|ugetnode
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input
condition|)
comment|/* add pipeline input/output to mnodes */
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
literal|0
argument_list|,
name|input
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
literal|1
argument_list|,
name|output
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|spawnpipes
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
expr_stmt|;
comment|/* do process substitutions */
while|while
condition|(
name|full
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
condition|)
if|if
condition|(
operator|(
name|fn
operator|=
operator|(
expr|struct
name|redir
operator|*
operator|)
name|ugetnode
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
operator|)
operator|->
name|type
operator|==
name|INPIPE
condition|)
block|{
if|if
condition|(
name|fn
operator|->
name|fd2
operator|==
operator|-
literal|1
condition|)
name|execerr
argument_list|()
expr_stmt|;
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|,
name|fn
operator|->
name|fd2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|OUTPIPE
condition|)
block|{
if|if
condition|(
name|fn
operator|->
name|fd2
operator|==
operator|-
literal|1
condition|)
name|execerr
argument_list|()
expr_stmt|;
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|,
name|fn
operator|->
name|fd2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|fn
operator|->
name|type
operator|==
name|HERESTR
operator|||
name|fn
operator|->
name|type
operator|==
name|CLOSE
operator|||
name|fn
operator|->
name|type
operator|==
name|MERGE
operator|||
name|fn
operator|->
name|type
operator|==
name|MERGEOUT
operator|)
condition|)
if|if
condition|(
name|xpandredir
argument_list|(
name|fn
argument_list|,
name|cmd
operator|->
name|redir
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|errflag
condition|)
name|execerr
argument_list|()
expr_stmt|;
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|HERESTR
condition|)
block|{
name|fil
operator|=
name|getherestr
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fil
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|zerr
argument_list|(
literal|"%e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|execerr
argument_list|()
expr_stmt|;
block|}
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|,
name|fil
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|READ
condition|)
block|{
name|fil
operator|=
name|open
argument_list|(
name|fn
operator|->
name|name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fil
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|zerr
argument_list|(
literal|"%e: %s"
argument_list|,
name|fn
operator|->
name|name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|execerr
argument_list|()
expr_stmt|;
block|}
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|,
name|fil
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|CLOSE
condition|)
block|{
if|if
condition|(
operator|!
name|forked
operator|&&
name|fn
operator|->
name|fd1
operator|<
literal|10
condition|)
name|save
index|[
name|fn
operator|->
name|fd1
index|]
operator|=
name|movefd
argument_list|(
name|fn
operator|->
name|fd1
argument_list|)
expr_stmt|;
name|closemn
argument_list|(
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fn
operator|->
name|fd1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|MERGE
operator|||
name|fn
operator|->
name|type
operator|==
name|MERGEOUT
condition|)
block|{
if|if
condition|(
name|fn
operator|->
name|fd2
operator|==
name|FD_COPROC
condition|)
name|fn
operator|->
name|fd2
operator|=
operator|(
name|fn
operator|->
name|type
operator|==
name|MERGEOUT
operator|)
condition|?
name|coprocout
else|:
name|coprocin
expr_stmt|;
if|if
condition|(
operator|!
name|forked
operator|&&
name|fn
operator|->
name|fd1
operator|<
literal|10
condition|)
name|save
index|[
name|fn
operator|->
name|fd1
index|]
operator|=
name|movefd
argument_list|(
name|fn
operator|->
name|fd1
argument_list|)
expr_stmt|;
name|closemn
argument_list|(
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|)
expr_stmt|;
name|fil
operator|=
name|dup
argument_list|(
name|fn
operator|->
name|fd2
argument_list|)
expr_stmt|;
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|,
name|fil
argument_list|,
name|fn
operator|->
name|type
operator|==
name|MERGEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fn
operator|->
name|type
operator|>=
name|APP
condition|)
name|fil
operator|=
name|open
argument_list|(
name|fn
operator|->
name|name
argument_list|,
operator|(
name|isset
argument_list|(
name|NOCLOBBER
argument_list|)
operator|&&
operator|!
operator|(
name|fn
operator|->
name|type
operator|&
literal|1
operator|)
operator|)
condition|?
name|O_WRONLY
operator||
name|O_APPEND
else|:
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
else|else
name|fil
operator|=
name|open
argument_list|(
name|fn
operator|->
name|name
argument_list|,
name|dontclob
argument_list|(
name|fn
argument_list|)
condition|?
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
else|:
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fil
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|zerr
argument_list|(
literal|"%e: %s"
argument_list|,
name|fn
operator|->
name|name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|execerr
argument_list|()
expr_stmt|;
block|}
name|addfd
argument_list|(
name|forked
argument_list|,
name|save
argument_list|,
name|mfds
argument_list|,
name|fn
operator|->
name|fd1
argument_list|,
name|fil
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we are done with redirection.  close the mnodes, spawning 		tee/cat processes as necessary. */
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|10
condition|;
name|t0
operator|++
control|)
name|closemn
argument_list|(
name|mfds
argument_list|,
name|t0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullexec
condition|)
return|return;
if|if
condition|(
name|unset
argument_list|(
name|NOEXEC
argument_list|)
condition|)
if|if
condition|(
name|type
operator|>=
name|CURSH
condition|)
block|{
specifier|static
name|int
argument_list|(
argument|*func[]
argument_list|)
name|DCLPROTO
argument_list|(
operator|(
name|Cmd
operator|)
argument_list|)
operator|=
block|{
name|execcursh
block|,
name|exectime
block|,
name|execfuncdef
block|,
name|execfor
block|,
name|execwhile
block|,
name|execrepeat
block|,
name|execif
block|,
name|execcase
block|,
name|execselect
block|,
name|execcond
block|}
expr_stmt|;
name|fixcline
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|lastval
operator|=
operator|(
name|func
index|[
name|type
operator|-
name|CURSH
index|]
operator|)
operator|(
name|cmd
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iscursh
condition|)
comment|/* builtin or shell function */
block|{
if|if
condition|(
name|cmd
operator|->
name|vars
condition|)
name|addvars
argument_list|(
name|cmd
operator|->
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixcline
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|&&
name|cn
operator|->
name|type
operator|==
name|SHFUNC
condition|)
name|execshfunc
argument_list|(
name|cmd
argument_list|,
name|cn
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|forked
condition|)
name|closem
argument_list|()
expr_stmt|;
name|lastval
operator|=
name|execbin
argument_list|(
name|args
argument_list|,
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|PRINTEXITVALUE
argument_list|)
operator|&&
name|isset
argument_list|(
name|SHINSTDIN
argument_list|)
operator|&&
name|lastval
operator|&&
operator|!
name|subsh
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"zsh: exit %d\n"
argument_list|,
name|lastval
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"write error: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|cmd
operator|->
name|vars
condition|)
name|addvars
argument_list|(
name|cmd
operator|->
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SIMPLE
condition|)
block|{
name|closem
argument_list|()
expr_stmt|;
name|execute
argument_list|(
name|cmd
operator|->
name|flags
operator|&
name|CFLAG_DASH
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ( ... ) */
name|execlist
argument_list|(
name|cmd
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
name|err
label|:
if|if
condition|(
name|forked
condition|)
name|_exit
argument_list|(
name|lastval
argument_list|)
expr_stmt|;
name|fixfds
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* restore fds after redirecting a builtin */
end_comment

begin_function
name|void
name|fixfds
parameter_list|(
name|save
parameter_list|)
comment|/**/
name|int
modifier|*
name|save
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|10
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|save
index|[
name|t0
index|]
condition|)
name|redup
argument_list|(
name|save
index|[
name|t0
index|]
argument_list|,
name|t0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|entersubsh
parameter_list|(
name|bkg
parameter_list|)
comment|/**/
name|int
name|bkg
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|jobbing
condition|)
block|{
if|if
condition|(
name|bkg
operator|&&
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
condition|)
block|{
name|zerr
argument_list|(
literal|"can't open /dev/null: %e"
argument_list|,
name|NULL
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
condition|)
block|{
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|setpgrp
argument_list|(
literal|0L
argument_list|,
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bkg
condition|)
name|attachtty
argument_list|(
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
argument_list|)
expr_stmt|;
block|}
else|else
name|setpgrp
argument_list|(
literal|0L
argument_list|,
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|gleader
argument_list|)
expr_stmt|;
name|subsh
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SHTTY
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|SHTTY
argument_list|)
expr_stmt|;
name|SHTTY
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|jobbing
condition|)
block|{
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interact
condition|)
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtrapped
index|[
name|SIGINT
index|]
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sigtrapped
index|[
name|SIGQUIT
index|]
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|opts
index|[
name|MONITOR
index|]
operator|=
name|OPT_UNSET
expr_stmt|;
name|clearjobtab
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* close all internal shell fds */
end_comment

begin_function
name|void
name|closem
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|10
init|;
name|t0
operator|!=
name|NOFILE
condition|;
name|t0
operator|++
control|)
name|close
argument_list|(
name|t0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert here document into a here string */
end_comment

begin_function
name|char
modifier|*
name|gethere
parameter_list|(
name|str
parameter_list|,
name|typ
parameter_list|)
comment|/**/
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|typ
decl_stmt|;
block|{
name|char
name|pbuf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|qt
init|=
literal|0
decl_stmt|,
name|siz
init|=
literal|0
decl_stmt|,
name|l
decl_stmt|,
name|strip
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|bptr
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
name|Nularg
condition|)
name|qt
operator|=
literal|1
expr_stmt|;
name|untokenize
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|typ
operator|==
name|HEREDOCDASH
condition|)
block|{
name|strip
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|'\t'
condition|)
name|str
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|ztrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|hgets
argument_list|(
name|pbuf
argument_list|,
literal|256
argument_list|)
condition|)
break|break;
name|bptr
operator|=
name|pbuf
expr_stmt|;
if|if
condition|(
name|strip
condition|)
while|while
condition|(
operator|*
name|bptr
operator|==
literal|'\t'
condition|)
name|bptr
operator|++
expr_stmt|;
for|for
control|(
name|u
operator|=
name|bptr
operator|,
name|v
operator|=
name|str
init|;
operator|*
name|u
operator|!=
literal|'\n'
operator|&&
operator|*
name|v
condition|;
name|u
operator|++
operator|,
name|v
operator|++
control|)
if|if
condition|(
operator|*
name|u
operator|!=
operator|*
name|v
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
operator|*
name|u
operator|==
literal|'\n'
operator|&&
operator|!
operator|*
name|v
operator|)
condition|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qt
operator|&&
name|l
operator|>
literal|1
operator|&&
name|bptr
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|bptr
index|[
name|l
operator|-
literal|2
index|]
operator|==
literal|'\\'
condition|)
name|bptr
index|[
name|l
operator|-=
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|=
name|realloc
argument_list|(
name|t
argument_list|,
name|siz
operator|+
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|t
operator|+
name|siz
argument_list|,
name|bptr
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|siz
operator|+=
name|l
expr_stmt|;
block|}
else|else
break|break;
block|}
name|t
index|[
name|siz
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|siz
operator|&&
name|t
index|[
name|siz
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|t
index|[
name|siz
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|qt
condition|)
for|for
control|(
name|s
operator|=
name|t
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
operator|*
name|s
operator|=
name|Qstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'`'
condition|)
block|{
operator|*
name|s
operator|=
name|Qtick
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
operator|*
name|s
operator|=
name|Inpar
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
block|{
operator|*
name|s
operator|=
name|Outpar
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'$'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'`'
operator|)
condition|)
name|chuck
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|strdup
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* open here string fd */
end_comment

begin_function
name|int
name|getherestr
parameter_list|(
name|fn
parameter_list|)
comment|/**/
name|struct
name|redir
modifier|*
name|fn
decl_stmt|;
block|{
name|Lklist
name|fake
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|gettemp
argument_list|()
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fake
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|fake
argument_list|,
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
name|prefork
argument_list|(
name|fake
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errflag
condition|)
name|postfork
argument_list|(
name|fake
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|s
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|t
operator|=
name|ugetnode
argument_list|(
name|fake
argument_list|)
condition|)
block|{
name|untokenize
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
argument_list|(
name|fake
argument_list|)
condition|)
name|write
argument_list|(
name|fd
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|s
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_function
name|void
name|catproc
parameter_list|(
name|mn
parameter_list|)
comment|/**/
name|struct
name|multio
modifier|*
name|mn
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|t0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|phork
argument_list|()
condition|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|mn
operator|->
name|ct
condition|;
name|t0
operator|++
control|)
name|close
argument_list|(
name|mn
operator|->
name|fds
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|mn
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|closeallelse
argument_list|(
name|mn
argument_list|)
expr_stmt|;
name|buf
operator|=
name|zalloc
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|mn
operator|->
name|ct
condition|;
name|t0
operator|++
control|)
while|while
condition|(
name|len
operator|=
name|read
argument_list|(
name|mn
operator|->
name|fds
index|[
name|t0
index|]
argument_list|,
name|buf
argument_list|,
literal|4096
argument_list|)
condition|)
name|write
argument_list|(
name|mn
operator|->
name|pipe
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teeproc
parameter_list|(
name|mn
parameter_list|)
comment|/**/
name|struct
name|multio
modifier|*
name|mn
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|t0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|phork
argument_list|()
condition|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|mn
operator|->
name|ct
condition|;
name|t0
operator|++
control|)
name|close
argument_list|(
name|mn
operator|->
name|fds
index|[
name|t0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|mn
operator|->
name|pipe
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|=
name|zalloc
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
name|closeallelse
argument_list|(
name|mn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|mn
operator|->
name|pipe
argument_list|,
name|buf
argument_list|,
literal|4096
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|mn
operator|->
name|ct
condition|;
name|t0
operator|++
control|)
name|write
argument_list|(
name|mn
operator|->
name|fds
index|[
name|t0
index|]
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|closeallelse
parameter_list|(
name|mn
parameter_list|)
comment|/**/
name|struct
name|multio
modifier|*
name|mn
decl_stmt|;
block|{
name|int
name|t0
decl_stmt|,
name|t1
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|NOFILE
condition|;
name|t0
operator|++
control|)
if|if
condition|(
name|mn
operator|->
name|pipe
operator|!=
name|t0
condition|)
block|{
for|for
control|(
name|t1
operator|=
literal|0
init|;
name|t1
operator|!=
name|mn
operator|->
name|ct
condition|;
name|t1
operator|++
control|)
if|if
condition|(
name|mn
operator|->
name|fds
index|[
name|t1
index|]
operator|==
name|t0
condition|)
break|break;
if|if
condition|(
name|t1
operator|==
name|mn
operator|->
name|ct
condition|)
name|close
argument_list|(
name|t0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|long
name|int
name|zstrtol
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|base
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|t
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
for|for
control|(
init|;
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<
operator|(
literal|'0'
operator|+
name|base
operator|)
condition|;
name|s
operator|++
control|)
name|ret
operator|=
name|ret
operator|*
name|base
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
else|else
for|for
control|(
init|;
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|(
operator|*
name|s
operator|>=
literal|'a'
operator|&&
operator|*
name|s
operator|<
operator|(
literal|'a'
operator|+
name|base
operator|-
literal|10
operator|)
operator|)
operator|||
operator|(
operator|*
name|s
operator|>=
literal|'A'
operator|&&
operator|*
name|s
operator|<
operator|(
literal|'A'
operator|+
name|base
operator|-
literal|10
operator|)
operator|)
condition|;
name|s
operator|++
control|)
name|ret
operator|=
name|ret
operator|*
name|base
operator|+
operator|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|?
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
else|:
operator|(
operator|*
name|s
operator|&
literal|0x1f
operator|)
operator|+
literal|9
operator|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
operator|*
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* $(...) */
end_comment

begin_function
name|Lklist
name|getoutput
parameter_list|(
name|cmd
parameter_list|,
name|qt
parameter_list|)
comment|/**/
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|qt
decl_stmt|;
block|{
name|List
name|list
decl_stmt|;
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'<'
condition|)
block|{
name|int
name|stream
decl_stmt|;
name|char
modifier|*
name|fi
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|cmd
operator|++
init|;
operator|*
name|cmd
operator|==
literal|' '
condition|;
name|cmd
operator|++
control|)
empty_stmt|;
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
operator|*
name|s
operator|=
name|String
expr_stmt|;
name|x
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|fi
operator|=
name|strdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|*
name|fi
operator|==
literal|'~'
condition|)
operator|*
name|fi
operator|=
name|Tilde
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fi
operator|==
literal|'='
condition|)
operator|*
name|fi
operator|=
name|Equals
expr_stmt|;
name|singsub
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return
name|NULL
return|;
name|stream
operator|=
name|open
argument_list|(
name|fi
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
operator|-
literal|1
condition|)
block|{
name|zerr
argument_list|(
literal|"%e: %s"
argument_list|,
name|fi
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|readoutput
argument_list|(
name|stream
argument_list|,
name|qt
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|parselstring
argument_list|(
name|cmd
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|mpipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
if|if
condition|(
name|phork
argument_list|()
condition|)
block|{
name|popheap
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* chldsuspend(); */
return|return
name|readoutput
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
name|qt
argument_list|)
return|;
block|}
name|subsh
operator|=
literal|1
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|redup
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|entersubsh
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
name|execlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* read output of command substitution */
end_comment

begin_function
name|Lklist
name|readoutput
parameter_list|(
name|in
parameter_list|,
name|qt
parameter_list|)
comment|/**/
name|int
name|in
decl_stmt|;
name|int
name|qt
decl_stmt|;
block|{
name|Lklist
name|ret
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|bsiz
decl_stmt|,
name|c
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|fdopen
argument_list|(
name|in
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|buf
operator|=
name|ncalloc
argument_list|(
name|bsiz
operator|=
literal|64
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|fin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|!
name|qt
operator|&&
name|isep
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|cnt
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|addnode
argument_list|(
name|ret
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
operator|=
name|ncalloc
argument_list|(
name|bsiz
operator|=
literal|64
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
name|cnt
operator|==
name|bsiz
condition|)
block|{
name|char
modifier|*
name|pp
init|=
name|ncalloc
argument_list|(
name|bsiz
operator|*=
literal|2
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|pp
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|buf
operator|=
name|pp
operator|)
operator|+
name|cnt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ptr
operator|!=
name|buf
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|ptr
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|addnode
argument_list|(
name|ret
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* =(...) */
end_comment

begin_function
name|char
modifier|*
name|getoutputfile
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|WAITPID
name|int
name|pid
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|nam
init|=
name|gettemp
argument_list|()
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|int
name|tfil
decl_stmt|;
name|List
name|list
decl_stmt|;
if|if
condition|(
name|thisjob
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|str
operator|=
name|cmd
init|;
operator|*
name|str
operator|&&
operator|*
name|str
operator|!=
name|Outpar
condition|;
name|str
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|zerr
argument_list|(
literal|"oops."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|parselstring
argument_list|(
name|cmd
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|permalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
condition|)
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
argument_list|,
name|ztrdup
argument_list|(
name|nam
argument_list|)
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|WAITPID
if|if
condition|(
name|pid
operator|=
name|phork
argument_list|()
condition|)
block|{
name|popheap
argument_list|()
expr_stmt|;
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
name|WUNTRACED
argument_list|)
expr_stmt|;
return|return
name|nam
return|;
block|}
else|#
directive|else
if|if
condition|(
name|waitfork
argument_list|()
condition|)
block|{
name|popheap
argument_list|()
expr_stmt|;
return|return
name|nam
return|;
block|}
endif|#
directive|endif
name|subsh
operator|=
literal|1
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|entersubsh
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tfil
operator|=
name|creat
argument_list|(
name|nam
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
name|execlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* get a temporary named pipe */
end_comment

begin_function
name|char
modifier|*
name|namedpipe
parameter_list|()
comment|/**/
block|{
ifndef|#
directive|ifndef
name|NO_FIFOS
name|char
modifier|*
name|tnam
init|=
name|gettemp
argument_list|()
decl_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|tnam
argument_list|,
literal|0010666
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|tnam
return|;
else|#
directive|else
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*<(...) */
end_comment

begin_function
name|char
modifier|*
name|getoutproc
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_FIFOS
name|zerr
argument_list|(
literal|"doesn't look like your system supports FIFOs."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
else|#
directive|else
name|List
name|list
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|pnam
decl_stmt|,
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|thisjob
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|str
operator|=
name|cmd
init|;
operator|*
name|str
operator|&&
operator|*
name|str
operator|!=
name|Outpar
condition|;
name|str
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|zerr
argument_list|(
literal|"oops."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|pnam
operator|=
name|namedpipe
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pnam
condition|)
return|return
name|NULL
return|;
name|permalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
condition|)
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
argument_list|,
name|ztrdup
argument_list|(
name|pnam
argument_list|)
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|parselstring
argument_list|(
name|cmd
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|phork
argument_list|()
condition|)
block|{
name|popheap
argument_list|()
expr_stmt|;
return|return
name|pnam
return|;
block|}
name|entersubsh
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|closem
argument_list|()
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|pnam
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|zerr
argument_list|(
literal|"can't open %s: %e"
argument_list|,
name|pnam
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|redup
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|redup
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
name|execlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*>(...) */
end_comment

begin_function
name|char
modifier|*
name|getinproc
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_FIFOS
name|zerr
argument_list|(
literal|"doesn't look like your system supports FIFOs."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
else|#
directive|else
name|List
name|list
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|fd
decl_stmt|;
name|char
modifier|*
name|pnam
decl_stmt|,
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|thisjob
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|str
operator|=
name|cmd
init|;
operator|*
name|str
operator|&&
operator|*
name|str
operator|!=
name|Outpar
condition|;
name|str
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|zerr
argument_list|(
literal|"oops."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|pnam
operator|=
name|namedpipe
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pnam
condition|)
return|return
name|NULL
return|;
name|permalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
condition|)
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|jobtab
index|[
name|thisjob
index|]
operator|.
name|filelist
argument_list|,
name|ztrdup
argument_list|(
name|pnam
argument_list|)
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|parselstring
argument_list|(
name|cmd
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pid
operator|=
name|phork
argument_list|()
condition|)
block|{
name|popheap
argument_list|()
expr_stmt|;
return|return
name|pnam
return|;
block|}
name|entersubsh
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|closem
argument_list|()
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|pnam
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|redup
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
name|execlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*>>(...) (does not use named pipes) */
end_comment

begin_function
name|int
name|getinpipe
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|List
name|list
decl_stmt|;
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|cmd
decl_stmt|;
for|for
control|(
name|str
operator|=
name|cmd
init|;
operator|*
name|str
operator|&&
operator|*
name|str
operator|!=
name|Outpar
condition|;
name|str
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|zerr
argument_list|(
literal|"oops."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|parselstring
argument_list|(
name|cmd
operator|+
literal|2
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|mpipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
if|if
condition|(
name|phork
argument_list|()
condition|)
block|{
name|popheap
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|pipes
index|[
literal|0
index|]
return|;
block|}
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|closem
argument_list|()
expr_stmt|;
name|entersubsh
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|redup
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
name|execlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*<<(...) */
end_comment

begin_function
name|int
name|getoutpipe
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|List
name|list
decl_stmt|;
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|str
operator|=
name|cmd
init|;
operator|*
name|str
operator|&&
operator|*
name|str
operator|!=
name|Outpar
condition|;
name|str
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|zerr
argument_list|(
literal|"oops."
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|list
operator|=
name|parselstring
argument_list|(
name|cmd
operator|+
literal|2
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|strinend
argument_list|()
expr_stmt|;
name|mpipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
if|if
condition|(
name|phork
argument_list|()
condition|)
block|{
name|popheap
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|pipes
index|[
literal|1
index|]
return|;
block|}
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|closem
argument_list|()
expr_stmt|;
name|entersubsh
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|redup
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exiting
operator|=
literal|1
expr_stmt|;
name|execlist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* run a list, saving the current job num */
end_comment

begin_function
name|void
name|runlist
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|List
name|l
decl_stmt|;
block|{
name|int
name|cj
init|=
name|thisjob
decl_stmt|;
name|execlist
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|thisjob
operator|=
name|cj
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|gettemp
parameter_list|()
comment|/**/
block|{
return|return
name|mktemp
argument_list|(
name|dyncat
argument_list|(
name|tmpprefix
argument_list|,
literal|"XXXXXX"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* my getwd; all the other ones I tried confused the SIGCHLD handler */
end_comment

begin_function
name|char
modifier|*
name|zgetwd
parameter_list|()
comment|/**/
block|{
specifier|static
name|char
name|buf0
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf3
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
modifier|*
name|buf2
init|=
name|buf0
operator|+
literal|1
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|ino_t
name|ino
init|=
operator|-
literal|1
decl_stmt|;
name|dev_t
name|dev
init|=
operator|-
literal|1
decl_stmt|;
name|holdintr
argument_list|()
expr_stmt|;
name|buf2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf0
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|chdir
argument_list|(
name|buf0
argument_list|)
expr_stmt|;
name|noholdintr
argument_list|()
expr_stmt|;
return|return
name|ztrdup
argument_list|(
literal|"."
argument_list|)
return|;
block|}
name|ino
operator|=
name|sbuf
operator|.
name|st_ino
expr_stmt|;
name|dev
operator|=
name|sbuf
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|".."
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|chdir
argument_list|(
name|buf0
argument_list|)
expr_stmt|;
name|noholdintr
argument_list|()
expr_stmt|;
return|return
name|ztrdup
argument_list|(
literal|"."
argument_list|)
return|;
block|}
if|if
condition|(
name|sbuf
operator|.
name|st_ino
operator|==
name|ino
operator|&&
name|sbuf
operator|.
name|st_dev
operator|==
name|dev
condition|)
block|{
name|chdir
argument_list|(
name|buf0
argument_list|)
expr_stmt|;
name|noholdintr
argument_list|()
expr_stmt|;
return|return
name|ztrdup
argument_list|(
name|buf0
argument_list|)
return|;
block|}
name|dir
operator|=
name|opendir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
block|{
name|chdir
argument_list|(
name|buf0
argument_list|)
expr_stmt|;
name|noholdintr
argument_list|()
expr_stmt|;
return|return
name|ztrdup
argument_list|(
literal|"."
argument_list|)
return|;
block|}
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
condition|)
if|if
condition|(
name|de
operator|->
name|d_ino
operator|==
name|ino
condition|)
block|{
name|lstat
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf
operator|.
name|st_dev
operator|==
name|dev
condition|)
goto|goto
name|match
goto|;
block|}
name|rewinddir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|readdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
name|de
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|lstat
argument_list|(
name|de
operator|->
name|d_name
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf
operator|.
name|st_dev
operator|==
name|dev
condition|)
goto|goto
name|match
goto|;
block|}
name|noholdintr
argument_list|()
expr_stmt|;
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|ztrdup
argument_list|(
literal|"."
argument_list|)
return|;
name|match
label|:
name|strcpy
argument_list|(
name|buf3
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf2
condition|)
name|strcat
argument_list|(
name|buf3
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf3
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* open pipes with fds>= 10 */
end_comment

begin_function
name|void
name|mpipe
parameter_list|(
name|pp
parameter_list|)
comment|/**/
name|int
modifier|*
name|pp
decl_stmt|;
block|{
name|pipe
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
index|[
literal|0
index|]
operator|=
name|movefd
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pp
index|[
literal|1
index|]
operator|=
name|movefd
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do process substitution with redirection */
end_comment

begin_function
name|void
name|spawnpipes
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
block|{
name|Lknode
name|n
init|=
name|firstnode
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|Redir
name|f
decl_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
block|{
name|f
operator|=
operator|(
name|Redir
operator|)
name|getdata
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|type
operator|==
name|OUTPIPE
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|f
operator|->
name|name
decl_stmt|;
name|f
operator|->
name|fd2
operator|=
name|getoutpipe
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|type
operator|==
name|INPIPE
condition|)
block|{
name|char
modifier|*
name|str
init|=
name|f
operator|->
name|name
decl_stmt|;
name|f
operator|->
name|fd2
operator|=
name|getinpipe
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* perform time ... command */
end_comment

begin_function
name|int
name|exectime
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
block|{
name|int
name|jb
init|=
name|thisjob
decl_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|->
name|u
operator|.
name|pline
condition|)
block|{
name|shelltime
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|execpline
argument_list|(
name|cmd
operator|->
name|u
operator|.
name|pline
argument_list|,
name|TIMED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisjob
operator|=
name|jb
expr_stmt|;
return|return
name|lastval
return|;
block|}
end_function

begin_comment
comment|/* define a function */
end_comment

begin_function
name|int
name|execfuncdef
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
block|{
name|Cmdnam
name|cc
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
while|while
condition|(
name|s
operator|=
name|ugetnode
argument_list|(
name|cmd
operator|->
name|args
argument_list|)
condition|)
block|{
name|cc
operator|=
operator|(
name|Cmdnam
operator|)
name|zalloc
argument_list|(
sizeof|sizeof
expr|*
name|cc
argument_list|)
expr_stmt|;
name|cc
operator|->
name|type
operator|=
name|SHFUNC
expr_stmt|;
name|cc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|->
name|u
operator|.
name|list
condition|)
name|cc
operator|->
name|u
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
else|else
name|cc
operator|->
name|u
operator|.
name|list
operator|=
operator|(
name|List
operator|)
name|dupstruct
argument_list|(
name|cmd
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
name|addhnode
argument_list|(
name|ztrdup
argument_list|(
name|s
argument_list|)
argument_list|,
name|cc
argument_list|,
name|cmdnamtab
argument_list|,
name|freecmdnam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"TRAP"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|t0
init|=
name|getsignum
argument_list|(
name|s
operator|+
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|t0
operator|!=
operator|-
literal|1
condition|)
name|settrap
argument_list|(
name|t0
argument_list|,
name|cmd
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|heapalloc
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* evaluate a [[ ... ]] */
end_comment

begin_function
name|int
name|execcond
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
block|{
return|return
operator|!
name|evalcond
argument_list|(
name|cmd
operator|->
name|u
operator|.
name|cond
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|execshfunc
parameter_list|(
name|cmd
parameter_list|,
name|cn
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
name|Cmdnam
name|cn
decl_stmt|;
block|{
name|List
name|l
decl_stmt|;
if|if
condition|(
name|errflag
condition|)
return|return;
name|l
operator|=
name|cn
operator|->
name|u
operator|.
name|list
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
block|{
name|char
modifier|*
name|nam
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cn
operator|->
name|flags
operator|&
name|PMFLAG_u
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|l
operator|=
name|getfpfunc
argument_list|(
name|nam
operator|=
name|peekfirst
argument_list|(
name|cmd
operator|->
name|args
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|zerr
argument_list|(
literal|"function not found: %s"
argument_list|,
name|nam
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|cn
operator|->
name|flags
operator|&=
operator|~
name|PMFLAG_u
expr_stmt|;
name|permalloc
argument_list|()
expr_stmt|;
name|cn
operator|->
name|u
operator|.
name|list
operator|=
operator|(
name|List
operator|)
name|dupstruct
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
block|}
name|doshfunc
argument_list|(
name|l
argument_list|,
name|cmd
operator|->
name|args
argument_list|,
name|cn
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|doshfuncnoval
parameter_list|(
name|list
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|)
comment|/**/
name|List
name|list
decl_stmt|;
name|Lklist
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|val
init|=
name|lastval
decl_stmt|;
name|doshfunc
argument_list|(
name|list
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
name|doshfunc
parameter_list|(
name|list
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|)
comment|/**/
name|List
name|list
decl_stmt|;
name|Lklist
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|tab
decl_stmt|,
modifier|*
modifier|*
name|x
decl_stmt|,
modifier|*
name|oargv0
decl_stmt|;
name|int
name|oxtr
init|=
name|opts
index|[
name|XTRACE
index|]
decl_stmt|,
name|opev
init|=
name|opts
index|[
name|PRINTEXITVALUE
index|]
decl_stmt|,
name|xexittr
decl_stmt|;
name|Lklist
name|olist
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|List
name|xexitfn
decl_stmt|;
name|xexittr
operator|=
name|sigtrapped
index|[
name|SIGEXIT
index|]
expr_stmt|;
name|xexitfn
operator|=
name|sigfuncs
index|[
name|SIGEXIT
index|]
expr_stmt|;
name|tab
operator|=
name|pparams
expr_stmt|;
name|oargv0
operator|=
name|argzero
expr_stmt|;
name|zoptind
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PMFLAG_t
condition|)
name|opts
index|[
name|XTRACE
index|]
operator|=
name|OPT_SET
expr_stmt|;
name|opts
index|[
name|PRINTEXITVALUE
index|]
operator|=
name|OPT_UNSET
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|pparams
operator|=
name|x
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|zcalloc
argument_list|(
operator|(
operator|(
sizeof|sizeof
expr|*
name|x
operator|)
operator|*
operator|(
literal|1
operator|+
name|countnodes
argument_list|(
name|args
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|argzero
operator|=
name|ztrdup
argument_list|(
name|ugetnode
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|x
operator|=
name|ugetnode
argument_list|(
name|args
argument_list|)
condition|)
operator|*
name|x
operator|=
name|ztrdup
argument_list|(
operator|*
name|x
argument_list|)
operator|,
name|x
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pparams
operator|=
name|zcalloc
argument_list|(
sizeof|sizeof
expr|*
name|pparams
argument_list|)
expr_stmt|;
name|argzero
operator|=
name|ztrdup
argument_list|(
name|argzero
argument_list|)
expr_stmt|;
block|}
name|permalloc
argument_list|()
expr_stmt|;
name|olist
operator|=
name|locallist
expr_stmt|;
name|locallist
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|heapalloc
argument_list|()
expr_stmt|;
name|runlist
argument_list|(
name|dupstruct
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|=
name|getnode
argument_list|(
name|locallist
argument_list|)
condition|)
name|unsetparam
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|locallist
argument_list|)
expr_stmt|;
name|locallist
operator|=
name|olist
expr_stmt|;
name|retflag
operator|=
literal|0
expr_stmt|;
name|freearray
argument_list|(
name|pparams
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argzero
argument_list|)
expr_stmt|;
name|argzero
operator|=
name|oargv0
expr_stmt|;
name|pparams
operator|=
name|tab
expr_stmt|;
if|if
condition|(
name|sigfuncs
index|[
name|SIGEXIT
index|]
operator|&&
name|sigfuncs
index|[
name|SIGEXIT
index|]
operator|!=
name|xexitfn
condition|)
block|{
name|dotrap
argument_list|(
name|SIGEXIT
argument_list|)
expr_stmt|;
name|freestruct
argument_list|(
name|sigfuncs
index|[
name|SIGEXIT
index|]
argument_list|)
expr_stmt|;
block|}
name|sigtrapped
index|[
name|SIGEXIT
index|]
operator|=
name|xexittr
expr_stmt|;
name|sigfuncs
index|[
name|SIGEXIT
index|]
operator|=
name|xexitfn
expr_stmt|;
name|opts
index|[
name|XTRACE
index|]
operator|=
name|oxtr
expr_stmt|;
name|opts
index|[
name|PRINTEXITVALUE
index|]
operator|=
name|opev
expr_stmt|;
block|}
end_function

begin_comment
comment|/* search fpath for an undefined function */
end_comment

begin_function
name|List
name|getfpfunc
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|pp
init|=
name|fpath
decl_stmt|,
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
for|for
control|(
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|*
name|pp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access
argument_list|(
name|buf
argument_list|,
name|R_OK
argument_list|)
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|len
init|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|=
name|zcalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|d
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|parselstring
argument_list|(
name|d
argument_list|)
return|;
block|}
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* check to see if AUTOCD applies here */
end_comment

begin_function
name|int
name|cancd
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|getsparam
argument_list|(
name|s
argument_list|)
operator|)
operator|&&
operator|*
name|t
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'/'
condition|)
block|{
name|char
name|sbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
modifier|*
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|cancd2
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|access
argument_list|(
name|s
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|cp
operator|=
name|cdpath
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|*
name|cp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancd2
argument_list|(
name|sbuf
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|cancd2
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|cancd2
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|stat
name|buf
decl_stmt|;
return|return
operator|!
operator|(
name|access
argument_list|(
name|s
argument_list|,
name|X_OK
argument_list|)
operator|||
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|buf
argument_list|)
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

