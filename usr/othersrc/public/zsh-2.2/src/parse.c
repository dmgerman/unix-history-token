begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * parse.c - parser  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_include
include|#
directive|include
file|"funcs.h"
end_include

begin_define
define|#
directive|define
name|YYERROR
value|{ tok = LEXERR; return NULL; }
end_define

begin_define
define|#
directive|define
name|YYERRORV
value|{ tok = LEXERR; return; }
end_define

begin_define
define|#
directive|define
name|make_list
parameter_list|()
value|allocnode(N_LIST)
end_define

begin_define
define|#
directive|define
name|make_sublist
parameter_list|()
value|allocnode(N_SUBLIST)
end_define

begin_define
define|#
directive|define
name|make_pline
parameter_list|()
value|allocnode(N_PLINE)
end_define

begin_define
define|#
directive|define
name|make_cmd
parameter_list|()
value|allocnode(N_CMD)
end_define

begin_define
define|#
directive|define
name|make_forcmd
parameter_list|()
value|allocnode(N_FOR)
end_define

begin_define
define|#
directive|define
name|make_casecmd
parameter_list|()
value|allocnode(N_CASE)
end_define

begin_define
define|#
directive|define
name|make_ifcmd
parameter_list|()
value|allocnode(N_IF)
end_define

begin_define
define|#
directive|define
name|make_whilecmd
parameter_list|()
value|allocnode(N_WHILE)
end_define

begin_define
define|#
directive|define
name|make_varnode
parameter_list|()
value|allocnode(N_VARASG)
end_define

begin_define
define|#
directive|define
name|make_cond
parameter_list|()
value|allocnode(N_COND)
end_define

begin_comment
comment|/*  * event	: ENDINPUT  *			| SEPER  *			| sublist [ SEPER | AMPER ]  */
end_comment

begin_function
name|List
name|parse_event
parameter_list|()
comment|/**/
block|{
name|tok
operator|=
name|ENDINPUT
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
return|return
name|par_event
argument_list|()
return|;
block|}
end_function

begin_function
name|List
name|par_event
parameter_list|()
comment|/**/
block|{
name|Sublist
name|sl
decl_stmt|;
name|List
name|l
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
block|{
if|if
condition|(
name|isnewlin
operator|>
literal|0
condition|)
return|return
name|NULL
return|;
name|yylex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|ENDINPUT
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sl
operator|=
name|par_sublist
argument_list|()
condition|)
if|if
condition|(
name|tok
operator|==
name|ENDINPUT
condition|)
block|{
name|l
operator|=
name|make_list
argument_list|()
expr_stmt|;
name|l
operator|->
name|type
operator|=
name|SYNC
expr_stmt|;
name|l
operator|->
name|left
operator|=
name|sl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|SEPER
condition|)
block|{
name|l
operator|=
name|make_list
argument_list|()
expr_stmt|;
name|l
operator|->
name|type
operator|=
name|SYNC
expr_stmt|;
name|l
operator|->
name|left
operator|=
name|sl
expr_stmt|;
if|if
condition|(
name|isnewlin
operator|<=
literal|0
condition|)
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|AMPER
condition|)
block|{
name|l
operator|=
name|make_list
argument_list|()
expr_stmt|;
name|l
operator|->
name|type
operator|=
name|ASYNC
expr_stmt|;
name|l
operator|->
name|left
operator|=
name|sl
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
else|else
name|l
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
block|{
if|if
condition|(
name|errflag
condition|)
block|{
name|yyerror
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|yyerror
argument_list|()
expr_stmt|;
name|errflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isnewlin
operator|<=
literal|0
condition|)
block|{
name|int
name|c
decl_stmt|;
name|hwbegin
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|hgetc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
operator|!
name|lexstop
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|hungetc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|hwaddc
argument_list|(
name|HISTSPACE
argument_list|)
expr_stmt|;
name|hwadd
argument_list|()
expr_stmt|;
block|}
name|errflag
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|l
operator|->
name|right
operator|=
name|par_event
argument_list|()
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_function
name|List
name|parse_list
parameter_list|()
comment|/**/
block|{
name|tok
operator|=
name|ENDINPUT
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
return|return
name|par_list
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*  * list	: { SEPER } [ sublist [ { SEPER | AMPER } list ] ]  */
end_comment

begin_function
name|List
name|par_list
parameter_list|()
comment|/**/
block|{
name|Sublist
name|sl
decl_stmt|;
name|List
name|l
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|sl
operator|=
name|par_sublist
argument_list|()
condition|)
if|if
condition|(
name|tok
operator|==
name|SEPER
operator|||
name|tok
operator|==
name|AMPER
condition|)
block|{
name|l
operator|=
name|make_list
argument_list|()
expr_stmt|;
name|l
operator|->
name|left
operator|=
name|sl
expr_stmt|;
name|l
operator|->
name|type
operator|=
operator|(
name|tok
operator|==
name|SEPER
operator|)
condition|?
name|SYNC
else|:
name|ASYNC
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
operator|||
name|tok
operator|==
name|AMPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
name|l
operator|->
name|right
operator|=
name|par_list
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|make_list
argument_list|()
expr_stmt|;
name|l
operator|->
name|left
operator|=
name|sl
expr_stmt|;
name|l
operator|->
name|type
operator|=
name|SYNC
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_function
name|List
name|par_list1
parameter_list|()
comment|/**/
block|{
name|Sublist
name|sl
decl_stmt|;
name|List
name|l
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sl
operator|=
name|par_sublist
argument_list|()
condition|)
block|{
name|l
operator|=
name|make_list
argument_list|()
expr_stmt|;
name|l
operator|->
name|type
operator|=
name|SYNC
expr_stmt|;
name|l
operator|->
name|left
operator|=
name|sl
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * sublist	: sublist2 [ ( DBAR | DAMPER ) { SEPER } sublist ]  */
end_comment

begin_function
name|Sublist
name|par_sublist
parameter_list|()
comment|/**/
block|{
name|Sublist
name|sl
decl_stmt|;
if|if
condition|(
name|sl
operator|=
name|par_sublist2
argument_list|()
condition|)
if|if
condition|(
name|tok
operator|==
name|DBAR
operator|||
name|tok
operator|==
name|DAMPER
condition|)
block|{
name|int
name|qtok
init|=
name|tok
decl_stmt|;
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
name|sl
operator|->
name|right
operator|=
name|par_sublist
argument_list|()
expr_stmt|;
name|sl
operator|->
name|type
operator|=
operator|(
name|qtok
operator|==
name|DBAR
operator|)
condition|?
name|ORNEXT
else|:
name|ANDNEXT
expr_stmt|;
block|}
return|return
name|sl
return|;
block|}
end_function

begin_comment
comment|/*  * sublist2	: [ COPROC | BANG ] pline  */
end_comment

begin_function
name|Sublist
name|par_sublist2
parameter_list|()
comment|/**/
block|{
name|Sublist
name|sl
decl_stmt|;
name|Pline
name|p
decl_stmt|;
name|sl
operator|=
name|make_sublist
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|COPROC
condition|)
block|{
name|sl
operator|->
name|flags
operator||=
name|PFLAG_COPROC
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|BANG
condition|)
block|{
name|sl
operator|->
name|flags
operator||=
name|PFLAG_NOT
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|par_pline
argument_list|()
operator|)
operator|&&
operator|!
name|sl
operator|->
name|flags
condition|)
return|return
name|NULL
return|;
name|sl
operator|->
name|left
operator|=
name|p
expr_stmt|;
return|return
name|sl
return|;
block|}
end_function

begin_comment
comment|/*  * pline	: cmd [ ( BAR | BARAMP ) { SEPER } pline ]  */
end_comment

begin_function
name|Pline
name|par_pline
parameter_list|()
comment|/**/
block|{
name|Cmd
name|c
decl_stmt|;
name|Pline
name|p
decl_stmt|,
name|p2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|par_cmd
argument_list|()
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|tok
operator|==
name|BAR
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
name|p2
operator|=
name|par_pline
argument_list|()
expr_stmt|;
name|p
operator|=
name|make_pline
argument_list|()
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|c
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|p2
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|PIPE
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|BARAMP
condition|)
block|{
name|struct
name|redir
modifier|*
name|rdr
init|=
name|alloc
argument_list|(
sizeof|sizeof
expr|*
name|rdr
argument_list|)
decl_stmt|;
name|rdr
operator|->
name|type
operator|=
name|MERGE
expr_stmt|;
name|rdr
operator|->
name|fd1
operator|=
literal|2
expr_stmt|;
name|rdr
operator|->
name|fd2
operator|=
literal|1
expr_stmt|;
name|addnode
argument_list|(
name|c
operator|->
name|redir
argument_list|,
name|rdr
argument_list|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|p2
operator|=
name|par_pline
argument_list|()
expr_stmt|;
name|p
operator|=
name|make_pline
argument_list|()
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|c
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|p2
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|PIPE
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
name|p
operator|=
name|make_pline
argument_list|()
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|c
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|END
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * cmd	: { redir } ( for | case | if | while | repeat |  *				subsh | funcdef | time | dinbrack | simple ) { redir }  */
end_comment

begin_function
name|Cmd
name|par_cmd
parameter_list|()
comment|/**/
block|{
name|Cmd
name|c
decl_stmt|;
name|c
operator|=
name|make_cmd
argument_list|()
expr_stmt|;
name|c
operator|->
name|args
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|c
operator|->
name|redir
operator|=
name|newlist
argument_list|()
expr_stmt|;
name|c
operator|->
name|vars
operator|=
name|newlist
argument_list|()
expr_stmt|;
while|while
condition|(
name|IS_REDIROP
argument_list|(
name|tok
argument_list|)
condition|)
name|par_redir
argument_list|(
name|c
operator|->
name|redir
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|FOR
case|:
case|case
name|FOREACH
case|:
case|case
name|SELECT
case|:
name|par_for
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|CASE
case|:
name|par_case
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF
case|:
name|par_if
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHILE
case|:
case|case
name|UNTIL
case|:
name|par_while
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPEAT
case|:
name|par_repeat
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|INPAR
case|:
case|case
name|INBRACE
case|:
name|par_subsh
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC
case|:
name|par_funcdef
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIME
case|:
name|par_time
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|DINBRACK
case|:
name|par_dinbrack
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|par_simple
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|NULL
return|;
break|break;
block|}
while|while
condition|(
name|IS_REDIROP
argument_list|(
name|tok
argument_list|)
condition|)
name|par_redir
argument_list|(
name|c
operator|->
name|redir
argument_list|)
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|incasepat
operator|=
literal|0
expr_stmt|;
name|incond
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * for	: ( FOR[EACH] | SELECT ) name ( "in" wordlist | INPAR wordlist OUTPAR ) 				{ SEPER } ( DO list DONE | INBRACE list OUTBRACE | 				list ZEND | list1 )  */
end_comment

begin_function
name|void
name|par_for
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|struct
name|forcmd
modifier|*
name|f
decl_stmt|;
name|int
name|csh
init|=
operator|(
name|tok
operator|==
name|FOREACH
operator|||
name|isset
argument_list|(
name|CSHJUNKIELOOPS
argument_list|)
operator|)
decl_stmt|;
name|f
operator|=
name|make_forcmd
argument_list|()
expr_stmt|;
name|c
operator|->
name|type
operator|=
operator|(
name|tok
operator|==
name|SELECT
operator|)
condition|?
name|CSELECT
else|:
name|CFOR
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERRORV
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|tokstr
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|tokstr
argument_list|,
literal|"in"
argument_list|)
condition|)
block|{
name|f
operator|->
name|inflag
operator|=
literal|1
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|args
operator|=
name|par_wordlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|SEPER
condition|)
name|YYERRORV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|INPAR
condition|)
block|{
name|f
operator|->
name|inflag
operator|=
literal|1
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|args
operator|=
name|par_nl_wordlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTPAR
condition|)
name|YYERRORV
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
name|incmdpos
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|DO
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|f
operator|->
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|DONE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|INBRACE
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|f
operator|->
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTBRACE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|csh
condition|)
block|{
name|f
operator|->
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|ZEND
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isset
argument_list|(
name|NOSHORTLOOPS
argument_list|)
condition|)
block|{
name|YYERRORV
expr_stmt|;
block|}
else|else
name|f
operator|->
name|list
operator|=
name|par_list1
argument_list|()
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|forcmd
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * case	: CASE STRING { SEPER } ( "in" | INBRACE ) 				{ { SEPER } STRING { BAR STRING } OUTPAR list [ DSEMI ] } 				{ SEPER } ( "esac" | OUTBRACE )  */
end_comment

begin_function
name|void
name|par_case
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|struct
name|casecmd
modifier|*
modifier|*
name|ccp
decl_stmt|;
name|int
name|brflag
decl_stmt|;
name|c
operator|->
name|type
operator|=
name|CCASE
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERRORV
expr_stmt|;
name|addnode
argument_list|(
name|c
operator|->
name|args
argument_list|,
name|tokstr
argument_list|)
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tok
operator|==
name|STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|tokstr
argument_list|,
literal|"in"
argument_list|)
operator|)
operator|&&
name|tok
operator|!=
name|INBRACE
condition|)
name|YYERRORV
expr_stmt|;
name|brflag
operator|=
operator|(
name|tok
operator|==
name|INBRACE
operator|)
expr_stmt|;
name|incasepat
operator|=
literal|1
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|ccp
operator|=
operator|&
name|c
operator|->
name|u
operator|.
name|casecmd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|casecmd
modifier|*
name|cc
decl_stmt|;
operator|*
name|ccp
operator|=
name|cc
operator|=
name|make_casecmd
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|OUTBRACE
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERRORV
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tokstr
argument_list|,
literal|"esac"
argument_list|)
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|tokstr
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|BAR
condition|)
block|{
name|char
modifier|*
name|str2
decl_stmt|;
name|int
name|sl
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERRORV
expr_stmt|;
name|str2
operator|=
name|alloc
argument_list|(
name|sl
operator|+
name|strlen
argument_list|(
name|tokstr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str2
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str2
index|[
name|sl
index|]
operator|=
name|Bar
expr_stmt|;
name|strcpy
argument_list|(
name|str2
operator|+
name|sl
operator|+
literal|1
argument_list|,
name|tokstr
argument_list|)
expr_stmt|;
name|str
operator|=
name|str2
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|!=
name|OUTPAR
condition|)
name|YYERRORV
expr_stmt|;
name|incasepat
operator|=
literal|0
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|cc
operator|->
name|pat
operator|=
name|str
expr_stmt|;
name|cc
operator|->
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
name|ccp
operator|=
operator|&
name|cc
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|tok
operator|==
name|ESAC
operator|&&
operator|!
name|brflag
operator|)
operator|||
operator|(
name|tok
operator|==
name|OUTBRACE
operator|&&
name|brflag
operator|)
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tok
operator|!=
name|DSEMI
condition|)
name|YYERRORV
expr_stmt|;
name|incasepat
operator|=
literal|1
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
operator|*
name|ccp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if	: { ( IF | ELIF ) { SEPER } ( INPAR list OUTPAR | list ) 			{ SEPER } ( THEN list | INBRACE list OUTBRACE | list1 ) } 			[ FI | ELSE list FI | ELSE { SEPER } INBRACE list OUTBRACE ] 			(you get the idea...?)  */
end_comment

begin_function
name|void
name|par_if
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|struct
name|ifcmd
modifier|*
name|i
decl_stmt|,
modifier|*
modifier|*
name|ip
decl_stmt|;
name|int
name|xtok
decl_stmt|;
name|c
operator|->
name|type
operator|=
name|CIF
expr_stmt|;
name|ip
operator|=
operator|&
name|c
operator|->
name|u
operator|.
name|ifcmd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|xtok
operator|=
name|tok
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|xtok
operator|==
name|FI
condition|)
break|break;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|xtok
operator|==
name|ELSE
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|xtok
operator|==
name|IF
operator|||
name|xtok
operator|==
name|ELIF
operator|)
condition|)
name|YYERRORV
expr_stmt|;
operator|*
name|ip
operator|=
name|i
operator|=
name|make_ifcmd
argument_list|()
expr_stmt|;
name|ip
operator|=
operator|&
name|i
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|INPAR
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|i
operator|->
name|ifl
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTPAR
condition|)
name|YYERRORV
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|ifl
operator|=
name|par_list
argument_list|()
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
name|xtok
operator|=
name|FI
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|THEN
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|i
operator|->
name|thenl
operator|=
name|par_list
argument_list|()
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|INBRACE
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|i
operator|->
name|thenl
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTBRACE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|SEPER
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isset
argument_list|(
name|NOSHORTLOOPS
argument_list|)
condition|)
block|{
name|YYERRORV
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|thenl
operator|=
name|par_list1
argument_list|()
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|xtok
operator|==
name|ELSE
condition|)
block|{
operator|*
name|ip
operator|=
name|i
operator|=
name|make_ifcmd
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|INBRACE
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|i
operator|->
name|thenl
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTBRACE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|thenl
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|FI
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * while	: ( WHILE | UNTIL ) ( INPAR list OUTPAR | list ) { SEPER } 				( DO list DONE | INBRACE list OUTBRACE | list ZEND )  */
end_comment

begin_function
name|void
name|par_while
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|struct
name|whilecmd
modifier|*
name|w
decl_stmt|;
name|c
operator|->
name|type
operator|=
name|CWHILE
expr_stmt|;
name|w
operator|=
name|c
operator|->
name|u
operator|.
name|whilecmd
operator|=
name|make_whilecmd
argument_list|()
expr_stmt|;
name|w
operator|->
name|cond
operator|=
operator|(
name|tok
operator|==
name|UNTIL
operator|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|INPAR
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|w
operator|->
name|cont
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTPAR
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|cont
operator|=
name|par_list
argument_list|()
expr_stmt|;
block|}
name|incmdpos
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|DO
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|w
operator|->
name|loop
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|DONE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|INBRACE
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|w
operator|->
name|loop
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTBRACE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isset
argument_list|(
name|CSHJUNKIELOOPS
argument_list|)
condition|)
block|{
name|w
operator|->
name|loop
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|ZEND
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
else|else
name|YYERRORV
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * repeat	: REPEAT STRING { SEPER } ( DO list DONE | list1 )  */
end_comment

begin_function
name|void
name|par_repeat
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|c
operator|->
name|type
operator|=
name|CREPEAT
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERRORV
expr_stmt|;
name|addnode
argument_list|(
name|c
operator|->
name|args
argument_list|,
name|tokstr
argument_list|)
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|DO
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|DONE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|u
operator|.
name|list
operator|=
name|par_list1
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * subsh	: ( INPAR | INBRACE ) list ( OUTPAR | OUTBRACE )  */
end_comment

begin_function
name|void
name|par_subsh
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|c
operator|->
name|type
operator|=
operator|(
name|tok
operator|==
name|INPAR
operator|)
condition|?
name|SUBSH
else|:
name|CURSH
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
operator|(
operator|(
name|c
operator|->
name|type
operator|==
name|SUBSH
operator|)
condition|?
name|OUTPAR
else|:
name|OUTBRACE
operator|)
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * funcdef	: FUNCTION wordlist [ INOUTPAR ] { SEPER }  *					( list1 | INBRACE list OUTBRACE )  */
end_comment

begin_function
name|void
name|par_funcdef
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|nocorrect
operator|=
literal|1
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|FUNCDEF
expr_stmt|;
name|c
operator|->
name|args
operator|=
name|newlist
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|STRING
condition|)
block|{
if|if
condition|(
operator|*
name|tokstr
operator|==
name|Inbrace
operator|&&
operator|!
name|tokstr
index|[
literal|1
index|]
condition|)
block|{
name|tok
operator|=
name|INBRACE
expr_stmt|;
break|break;
block|}
name|addnode
argument_list|(
name|c
operator|->
name|args
argument_list|,
name|tokstr
argument_list|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
name|nocorrect
operator|=
literal|0
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|INOUTPAR
condition|)
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|INBRACE
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTBRACE
condition|)
name|YYERRORV
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isset
argument_list|(
name|NOSHORTLOOPS
argument_list|)
condition|)
block|{
name|YYERRORV
expr_stmt|;
block|}
else|else
name|c
operator|->
name|u
operator|.
name|list
operator|=
name|par_list1
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * time	: TIME sublist2  */
end_comment

begin_function
name|void
name|par_time
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|ZCTIME
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|pline
operator|=
name|par_sublist2
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dinbrack	: DINBRACK cond DOUTBRACK  */
end_comment

begin_function
name|void
name|par_dinbrack
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|c
operator|->
name|type
operator|=
name|COND
expr_stmt|;
name|incond
operator|=
literal|1
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|cond
operator|=
name|par_cond
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|DOUTBRACK
condition|)
name|YYERRORV
expr_stmt|;
name|incond
operator|=
literal|0
expr_stmt|;
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * simple	: { COMMAND | EXEC | NOGLOB | NOCORRECT | DASH } 					{ STRING | ENVSTRING | ENVARRAY wordlist OUTPAR | redir } 					[ INOUTPAR { SEPER } ( list1 | INBRACE list OUTBRACE ) ]  */
end_comment

begin_function
name|Cmd
name|par_simple
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|Cmd
name|c
decl_stmt|;
block|{
name|int
name|isnull
init|=
literal|1
decl_stmt|;
name|c
operator|->
name|type
operator|=
name|SIMPLE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|tok
operator|==
name|COMMAND
condition|)
name|c
operator|->
name|flags
operator||=
name|CFLAG_COMMAND
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|EXEC
condition|)
name|c
operator|->
name|flags
operator||=
name|CFLAG_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|NOGLOB
condition|)
name|c
operator|->
name|flags
operator||=
name|CFLAG_NOGLOB
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|NOCORRECT
condition|)
name|nocorrect
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|DASH
condition|)
name|c
operator|->
name|flags
operator|=
name|CFLAG_DASH
expr_stmt|;
else|else
break|break;
name|yylex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|AMPER
condition|)
name|YYERROR
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|tok
operator|==
name|STRING
condition|)
block|{
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|addnode
argument_list|(
name|c
operator|->
name|args
argument_list|,
name|tokstr
argument_list|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|ENVSTRING
condition|)
block|{
name|struct
name|varasg
modifier|*
name|v
init|=
name|make_varnode
argument_list|()
decl_stmt|;
name|v
operator|->
name|type
operator|=
name|PMFLAG_s
expr_stmt|;
name|equalsplit
argument_list|(
name|v
operator|->
name|name
operator|=
name|tokstr
argument_list|,
operator|&
name|v
operator|->
name|str
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|c
operator|->
name|vars
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|ENVARRAY
condition|)
block|{
name|struct
name|varasg
modifier|*
name|v
init|=
name|make_varnode
argument_list|()
decl_stmt|;
name|int
name|oldcmdpos
init|=
name|incmdpos
decl_stmt|;
name|v
operator|->
name|type
operator|=
name|PMFLAG_A
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|tokstr
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|v
operator|->
name|arr
operator|=
name|par_nl_wordlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTPAR
condition|)
name|YYERROR
expr_stmt|;
name|incmdpos
operator|=
name|oldcmdpos
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|addnode
argument_list|(
name|c
operator|->
name|vars
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_REDIROP
argument_list|(
name|tok
argument_list|)
condition|)
block|{
name|par_redir
argument_list|(
name|c
operator|->
name|redir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|INOUTPAR
condition|)
block|{
name|incmdpos
operator|=
literal|1
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|INBRACE
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|->
name|u
operator|.
name|list
operator|=
name|par_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTBRACE
condition|)
name|YYERROR
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isset
argument_list|(
name|NOSHORTLOOPS
argument_list|)
condition|)
block|{
name|YYERROR
expr_stmt|;
block|}
else|else
name|c
operator|->
name|u
operator|.
name|list
operator|=
name|par_list1
argument_list|()
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|FUNCDEF
expr_stmt|;
block|}
else|else
break|break;
name|isnull
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isnull
operator|&&
operator|!
name|full
argument_list|(
name|c
operator|->
name|redir
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|full
argument_list|(
name|c
operator|->
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
name|underscore
condition|)
name|free
argument_list|(
name|underscore
argument_list|)
expr_stmt|;
name|underscore
operator|=
name|ztrdup
argument_list|(
name|getdata
argument_list|(
name|lastnode
argument_list|(
name|c
operator|->
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|untokenize
argument_list|(
name|underscore
argument_list|)
expr_stmt|;
block|}
name|incmdpos
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * cond	: cond_1 { SEPER } [ DBAR { SEPER } cond ]  */
end_comment

begin_function
name|Cond
name|par_cond
parameter_list|()
comment|/**/
block|{
name|Cond
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|c
operator|=
name|par_cond_1
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|DBAR
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
name|c2
operator|=
name|make_cond
argument_list|()
expr_stmt|;
name|c2
operator|->
name|left
operator|=
name|c
expr_stmt|;
name|c2
operator|->
name|right
operator|=
name|par_cond
argument_list|()
expr_stmt|;
name|c2
operator|->
name|type
operator|=
name|COND_OR
expr_stmt|;
return|return
name|c2
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * cond_1 : cond_2 { SEPER } [ DAMPER { SEPER } cond_1 ]  */
end_comment

begin_function
name|Cond
name|par_cond_1
parameter_list|()
comment|/**/
block|{
name|Cond
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|c
operator|=
name|par_cond_2
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|DAMPER
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
name|c2
operator|=
name|make_cond
argument_list|()
expr_stmt|;
name|c2
operator|->
name|left
operator|=
name|c
expr_stmt|;
name|c2
operator|->
name|right
operator|=
name|par_cond_1
argument_list|()
expr_stmt|;
name|c2
operator|->
name|type
operator|=
name|COND_AND
expr_stmt|;
return|return
name|c2
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * cond_2	: BANG cond_2 				| INPAR { SEPER } cond_2 { SEPER } OUTPAR 				| STRING STRING STRING 				| STRING STRING 				| STRING ( INANG | OUTANG ) STRING  */
end_comment

begin_function
name|Cond
name|par_cond_2
parameter_list|()
comment|/**/
block|{
name|Cond
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|int
name|xtok
decl_stmt|;
if|if
condition|(
name|tok
operator|==
name|BANG
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|=
name|par_cond_2
argument_list|()
expr_stmt|;
name|c2
operator|=
name|make_cond
argument_list|()
expr_stmt|;
name|c2
operator|->
name|left
operator|=
name|c
expr_stmt|;
name|c2
operator|->
name|type
operator|=
name|COND_NOT
expr_stmt|;
return|return
name|c2
return|;
block|}
if|if
condition|(
name|tok
operator|==
name|INPAR
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|=
name|par_cond
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|SEPER
condition|)
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|OUTPAR
condition|)
name|YYERROR
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERROR
expr_stmt|;
name|s1
operator|=
name|tokstr
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|xtok
operator|=
name|tok
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|INANG
operator|||
name|tok
operator|==
name|OUTANG
condition|)
block|{
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERROR
expr_stmt|;
name|s3
operator|=
name|tokstr
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
name|c
operator|=
name|make_cond
argument_list|()
expr_stmt|;
name|c
operator|->
name|left
operator|=
name|s1
expr_stmt|;
name|c
operator|->
name|right
operator|=
name|s3
expr_stmt|;
name|c
operator|->
name|type
operator|=
operator|(
name|xtok
operator|==
name|INANG
operator|)
condition|?
name|COND_STRLT
else|:
name|COND_STRGTR
expr_stmt|;
name|c
operator|->
name|types
index|[
literal|0
index|]
operator|=
name|c
operator|->
name|types
index|[
literal|1
index|]
operator|=
name|NT_STR
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|tok
operator|!=
name|STRING
condition|)
name|YYERROR
expr_stmt|;
name|s2
operator|=
name|tokstr
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|STRING
condition|)
block|{
name|s3
operator|=
name|tokstr
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
return|return
name|par_cond_triple
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
return|;
block|}
else|else
return|return
name|par_cond_double
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * redir	: ( OUTANG | ... | TRINANG ) STRING  */
end_comment

begin_function
name|void
name|par_redir
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
block|{
name|char
modifier|*
name|toks
decl_stmt|;
name|struct
name|redir
modifier|*
name|fn
init|=
name|allocnode
argument_list|(
name|N_REDIR
argument_list|)
decl_stmt|;
name|int
name|mergerror
init|=
literal|0
decl_stmt|;
name|int
name|oldcmdpos
decl_stmt|,
name|oldnc
decl_stmt|;
name|oldcmdpos
operator|=
name|incmdpos
expr_stmt|;
name|incmdpos
operator|=
literal|0
expr_stmt|;
name|oldnc
operator|=
name|nocorrect
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|INANG
condition|)
name|nocorrect
operator|=
literal|1
expr_stmt|;
name|fn
operator|->
name|type
operator|=
name|redirtab
index|[
name|tok
operator|-
name|OUTANG
index|]
expr_stmt|;
name|fn
operator|->
name|fd1
operator|=
name|tokfd
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|STRING
operator|&&
name|tok
operator|!=
name|ENVSTRING
condition|)
name|YYERRORV
expr_stmt|;
name|toks
operator|=
name|tokstr
expr_stmt|;
name|incmdpos
operator|=
name|oldcmdpos
expr_stmt|;
name|nocorrect
operator|=
name|oldnc
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
comment|/* assign default fd */
if|if
condition|(
name|fn
operator|->
name|fd1
operator|==
operator|-
literal|1
condition|)
name|fn
operator|->
name|fd1
operator|=
name|IS_READFD
argument_list|(
name|fn
operator|->
name|type
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/*>>(...) or<<(...) */
if|if
condition|(
operator|(
operator|*
name|toks
operator|==
name|Inang
operator|||
operator|*
name|toks
operator|==
name|Outang
operator|)
operator|&&
name|toks
index|[
literal|1
index|]
operator|==
name|Inpar
condition|)
block|{
if|if
condition|(
operator|(
name|fn
operator|->
name|type
operator|&
operator|~
literal|1
operator|)
operator|==
name|WRITE
condition|)
name|fn
operator|->
name|type
operator|=
name|OUTPIPE
expr_stmt|;
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|READ
condition|)
name|fn
operator|->
name|type
operator|=
name|INPIPE
expr_stmt|;
else|else
name|YYERRORV
expr_stmt|;
name|fn
operator|->
name|name
operator|=
name|toks
expr_stmt|;
comment|/*<<[-] name */
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|HEREDOC
operator|||
name|fn
operator|->
name|type
operator|==
name|HEREDOCDASH
condition|)
block|{
name|char
name|tbuf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|tlin
decl_stmt|;
name|int
name|tsiz
init|=
literal|0
decl_stmt|,
name|l
decl_stmt|;
comment|/* Save the rest of the current line for later tokenization */
if|if
condition|(
operator|!
name|isnewlin
condition|)
block|{
while|while
condition|(
name|hgets
argument_list|(
name|tbuf
argument_list|,
literal|256
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsiz
operator|==
literal|0
condition|)
block|{
name|tlin
operator|=
name|ztrdup
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
comment|/* Test for failure? */
name|tsiz
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
name|tlin
operator|=
name|realloc
argument_list|(
name|tlin
argument_list|,
name|tsiz
operator|+
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Test for failure? */
name|strcpy
argument_list|(
operator|&
name|tlin
index|[
name|tsiz
index|]
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|tsiz
operator|+=
name|l
expr_stmt|;
block|}
if|if
condition|(
name|tbuf
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
block|}
comment|/* Now grab the document */
name|fn
operator|->
name|name
operator|=
name|gethere
argument_list|(
name|toks
argument_list|,
name|fn
operator|->
name|type
argument_list|)
expr_stmt|;
name|fn
operator|->
name|type
operator|=
name|HERESTR
expr_stmt|;
comment|/* Put back the saved line to resume tokenizing */
if|if
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
name|hungets
argument_list|(
name|tlin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tlin
argument_list|)
expr_stmt|;
block|}
comment|/*>& name or>>& name */
block|}
elseif|else
if|if
condition|(
name|IS_ERROR_REDIR
argument_list|(
name|fn
operator|->
name|type
argument_list|)
operator|&&
name|getfdstr
argument_list|(
name|toks
argument_list|)
operator|==
name|FD_WORD
condition|)
block|{
name|mergerror
operator|=
literal|1
expr_stmt|;
name|fn
operator|->
name|name
operator|=
name|toks
expr_stmt|;
name|fn
operator|->
name|type
operator|=
name|UN_ERROR_REDIR
argument_list|(
name|fn
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/*>>& and>>&! are only valid with a name after them */
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|ERRAPP
operator|||
name|fn
operator|->
name|type
operator|==
name|ERRAPPNOW
condition|)
block|{
name|YYERRORV
expr_stmt|;
comment|/*>& # */
block|}
elseif|else
if|if
condition|(
name|fn
operator|->
name|type
operator|==
name|MERGE
operator|||
name|fn
operator|->
name|type
operator|==
name|MERGEOUT
condition|)
block|{
name|fn
operator|->
name|fd2
operator|=
name|getfdstr
argument_list|(
name|toks
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|->
name|fd2
operator|==
name|FD_CLOSE
condition|)
name|fn
operator|->
name|type
operator|=
name|CLOSE
expr_stmt|;
elseif|else
if|if
condition|(
name|fn
operator|->
name|fd2
operator|==
name|FD_WORD
condition|)
name|fn
operator|->
name|fd2
operator|=
operator|(
name|fn
operator|->
name|type
operator|==
name|MERGEOUT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
name|fn
operator|->
name|name
operator|=
name|toks
expr_stmt|;
name|addnode
argument_list|(
name|l
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergerror
condition|)
block|{
name|struct
name|redir
modifier|*
name|fe
init|=
name|allocnode
argument_list|(
name|N_REDIR
argument_list|)
decl_stmt|;
name|fe
operator|->
name|fd1
operator|=
literal|2
expr_stmt|;
name|fe
operator|->
name|fd2
operator|=
name|fn
operator|->
name|fd1
expr_stmt|;
name|fe
operator|->
name|type
operator|=
name|MERGEOUT
expr_stmt|;
name|addnode
argument_list|(
name|l
argument_list|,
name|fe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * wordlist	: { STRING }  */
end_comment

begin_function
name|Lklist
name|par_wordlist
parameter_list|()
comment|/**/
block|{
name|Lklist
name|l
decl_stmt|;
name|l
operator|=
name|newlist
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|STRING
condition|)
block|{
name|addnode
argument_list|(
name|l
argument_list|,
name|tokstr
argument_list|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * nl_wordlist	: { STRING | SEPER }  */
end_comment

begin_function
name|Lklist
name|par_nl_wordlist
parameter_list|()
comment|/**/
block|{
name|Lklist
name|l
decl_stmt|;
name|l
operator|=
name|newlist
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|STRING
operator|||
name|tok
operator|==
name|SEPER
condition|)
block|{
if|if
condition|(
name|tok
operator|!=
name|SEPER
condition|)
name|addnode
argument_list|(
name|l
argument_list|,
name|tokstr
argument_list|)
expr_stmt|;
name|yylex
argument_list|()
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* get fd associated with str */
end_comment

begin_function
name|int
name|getfdstr
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
return|return
name|FD_WORD
return|;
if|if
condition|(
name|idigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|*
name|s
operator|-
literal|'0'
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'p'
condition|)
return|return
name|FD_COPROC
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
return|return
name|FD_CLOSE
return|;
return|return
name|FD_WORD
return|;
block|}
end_function

begin_function
name|Cond
name|par_cond_double
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
comment|/**/
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
name|Cond
name|n
init|=
name|make_cond
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
operator|!
name|a
index|[
literal|1
index|]
operator|||
name|a
index|[
literal|2
index|]
condition|)
block|{
name|zerr
argument_list|(
literal|"parse error: condition expected: %s"
argument_list|,
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|->
name|left
operator|=
name|b
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|a
index|[
literal|1
index|]
expr_stmt|;
name|n
operator|->
name|types
index|[
literal|0
index|]
operator|=
name|n
operator|->
name|types
index|[
literal|1
index|]
operator|=
name|NT_STR
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|Cond
name|par_cond_triple
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
comment|/**/
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
block|{
name|Cond
name|n
init|=
name|make_cond
argument_list|()
decl_stmt|;
specifier|static
name|char
modifier|*
name|condstrs
index|[]
init|=
block|{
literal|"nt"
block|,
literal|"ot"
block|,
literal|"ef"
block|,
literal|"eq"
block|,
literal|"ne"
block|,
literal|"lt"
block|,
literal|"gt"
block|,
literal|"le"
block|,
literal|"ge"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|t0
decl_stmt|;
if|if
condition|(
operator|(
name|b
index|[
literal|0
index|]
operator|==
name|Equals
operator|||
name|b
index|[
literal|0
index|]
operator|==
literal|'='
operator|)
operator|&&
operator|!
name|b
index|[
literal|1
index|]
condition|)
name|n
operator|->
name|type
operator|=
name|COND_STREQ
expr_stmt|;
elseif|else
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|b
index|[
literal|1
index|]
operator|==
literal|'='
operator|&&
operator|!
name|b
index|[
literal|2
index|]
condition|)
name|n
operator|->
name|type
operator|=
name|COND_STRNEQ
expr_stmt|;
elseif|else
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|condstrs
index|[
name|t0
index|]
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|condstrs
index|[
name|t0
index|]
argument_list|,
name|b
operator|+
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|condstrs
index|[
name|t0
index|]
condition|)
name|n
operator|->
name|type
operator|=
name|t0
operator|+
name|COND_NT
expr_stmt|;
else|else
name|zerr
argument_list|(
literal|"unrecognized condition: %s"
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|zerr
argument_list|(
literal|"condition expected: %s"
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|->
name|left
operator|=
name|a
expr_stmt|;
name|n
operator|->
name|right
operator|=
name|c
expr_stmt|;
name|n
operator|->
name|types
index|[
literal|0
index|]
operator|=
name|n
operator|->
name|types
index|[
literal|1
index|]
operator|=
name|NT_STR
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|yyerror
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
literal|20
condition|;
name|t0
operator|++
control|)
if|if
condition|(
operator|!
name|yytext
index|[
name|t0
index|]
operator|||
name|yytext
index|[
name|t0
index|]
operator|==
literal|'\n'
operator|||
name|yytext
index|[
name|t0
index|]
operator|==
name|HISTSPACE
condition|)
break|break;
if|if
condition|(
name|t0
operator|==
literal|20
condition|)
name|zerr
argument_list|(
literal|"parse error near `%l...'"
argument_list|,
name|yytext
argument_list|,
literal|20
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t0
condition|)
name|zerr
argument_list|(
literal|"parse error near `%l'"
argument_list|,
name|yytext
argument_list|,
name|t0
argument_list|)
expr_stmt|;
else|else
name|zerr
argument_list|(
literal|"parse error"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

