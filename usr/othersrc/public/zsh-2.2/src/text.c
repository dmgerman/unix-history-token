begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * text.c - textual representations of syntax trees  *  * This file is part of zsh, the Z shell.  *  * This software is Copyright 1992 by Paul Falstad  *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  */
end_comment

begin_include
include|#
directive|include
file|"zsh.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tptr
decl_stmt|,
modifier|*
name|tbuf
decl_stmt|,
modifier|*
name|tlim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tsiz
decl_stmt|,
name|tindent
decl_stmt|,
name|tnewlins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add a character to the text buffer */
end_comment

begin_function
name|void
name|taddchr
parameter_list|(
name|c
parameter_list|)
comment|/**/
name|int
name|c
decl_stmt|;
block|{
operator|*
name|tptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tptr
operator|==
name|tlim
condition|)
block|{
if|if
condition|(
operator|!
name|tbuf
condition|)
block|{
name|tptr
operator|--
expr_stmt|;
return|return;
block|}
name|tbuf
operator|=
name|realloc
argument_list|(
name|tbuf
argument_list|,
name|tsiz
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|tlim
operator|=
name|tbuf
operator|+
name|tsiz
expr_stmt|;
name|tptr
operator|=
name|tbuf
operator|+
name|tsiz
operator|/
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* add a string to the text buffer */
end_comment

begin_function
name|void
name|taddstr
parameter_list|(
name|s
parameter_list|)
comment|/**/
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|sl
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
name|tptr
operator|+
name|sl
operator|>=
name|tlim
condition|)
block|{
name|int
name|x
init|=
name|tptr
operator|-
name|tbuf
decl_stmt|;
if|if
condition|(
operator|!
name|tbuf
condition|)
return|return;
name|tbuf
operator|=
name|realloc
argument_list|(
name|tbuf
argument_list|,
name|tsiz
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|tlim
operator|=
name|tbuf
operator|+
name|tsiz
expr_stmt|;
name|tptr
operator|=
name|tbuf
operator|+
name|x
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tptr
operator|+=
name|sl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add an integer to the text buffer */
end_comment

begin_function
name|void
name|taddint
parameter_list|(
name|x
parameter_list|)
comment|/**/
name|int
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add a newline, or something equivalent, to the text buffer */
end_comment

begin_function
name|void
name|taddnl
parameter_list|()
comment|/**/
block|{
name|int
name|t0
decl_stmt|;
if|if
condition|(
name|tnewlins
condition|)
block|{
name|taddchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|t0
operator|=
literal|0
init|;
name|t0
operator|!=
name|tindent
condition|;
name|t0
operator|++
control|)
name|taddchr
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
else|else
name|taddstr
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get a permanent textual representation of n */
end_comment

begin_function
name|char
modifier|*
name|getpermtext
parameter_list|(
name|n
parameter_list|)
comment|/**/
name|struct
name|node
modifier|*
name|n
decl_stmt|;
block|{
name|tnewlins
operator|=
literal|1
expr_stmt|;
name|tbuf
operator|=
name|zalloc
argument_list|(
name|tsiz
operator|=
literal|32
argument_list|)
expr_stmt|;
name|tptr
operator|=
name|tbuf
expr_stmt|;
name|tlim
operator|=
name|tbuf
operator|+
name|tsiz
expr_stmt|;
name|tindent
operator|=
literal|1
expr_stmt|;
name|gettext2
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
name|untokenize
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
return|return
name|tbuf
return|;
block|}
end_function

begin_comment
comment|/* get a representation of n in a job text buffer */
end_comment

begin_function
name|char
modifier|*
name|getjobtext
parameter_list|(
name|n
parameter_list|)
comment|/**/
name|struct
name|node
modifier|*
name|n
decl_stmt|;
block|{
specifier|static
name|char
name|jbuf
index|[
name|JOBTEXTSIZE
index|]
decl_stmt|;
name|tnewlins
operator|=
literal|0
expr_stmt|;
name|tbuf
operator|=
name|NULL
expr_stmt|;
name|tptr
operator|=
name|jbuf
expr_stmt|;
name|tlim
operator|=
name|tptr
operator|+
name|JOBTEXTSIZE
operator|-
literal|1
expr_stmt|;
name|tindent
operator|=
literal|1
expr_stmt|;
name|gettext2
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
name|untokenize
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
return|return
name|jbuf
return|;
block|}
end_function

begin_define
define|#
directive|define
name|gt2
parameter_list|(
name|X
parameter_list|)
value|gettext2((struct node *) (X))
end_define

begin_comment
comment|/* 	"gettext2" or "type checking and how to avoid it" 	an epic function by Paul Falstad */
end_comment

begin_define
define|#
directive|define
name|_Cond
parameter_list|(
name|X
parameter_list|)
value|((Cond) (X))
end_define

begin_define
define|#
directive|define
name|_Cmd
parameter_list|(
name|X
parameter_list|)
value|((Cmd) (X))
end_define

begin_define
define|#
directive|define
name|_Pline
parameter_list|(
name|X
parameter_list|)
value|((Pline) (X))
end_define

begin_define
define|#
directive|define
name|_Sublist
parameter_list|(
name|X
parameter_list|)
value|((Sublist) (X))
end_define

begin_define
define|#
directive|define
name|_List
parameter_list|(
name|X
parameter_list|)
value|((List) (X))
end_define

begin_define
define|#
directive|define
name|_casecmd
parameter_list|(
name|X
parameter_list|)
value|((struct casecmd *) (X))
end_define

begin_define
define|#
directive|define
name|_ifcmd
parameter_list|(
name|X
parameter_list|)
value|((struct ifcmd *) (X))
end_define

begin_define
define|#
directive|define
name|_whilecmd
parameter_list|(
name|X
parameter_list|)
value|((struct whilecmd *) (X))
end_define

begin_function
name|void
name|gettext2
parameter_list|(
name|n
parameter_list|)
comment|/**/
name|struct
name|node
modifier|*
name|n
decl_stmt|;
block|{
name|Cmd
name|nn
decl_stmt|;
name|Cond
name|nm
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|N_LIST
case|:
name|gt2
argument_list|(
name|_List
argument_list|(
name|n
argument_list|)
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|_List
argument_list|(
name|n
argument_list|)
operator|->
name|type
operator|==
name|ASYNC
condition|)
name|taddstr
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
name|simplifyright
argument_list|(
name|_List
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_List
argument_list|(
name|n
argument_list|)
operator|->
name|right
condition|)
block|{
if|if
condition|(
name|tnewlins
condition|)
name|taddnl
argument_list|()
expr_stmt|;
else|else
name|taddstr
argument_list|(
operator|(
name|_List
argument_list|(
name|n
argument_list|)
operator|->
name|type
operator|==
name|ASYNC
operator|)
condition|?
literal|" "
else|:
literal|"; "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|_List
argument_list|(
name|n
argument_list|)
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_SUBLIST
case|:
if|if
condition|(
name|_Sublist
argument_list|(
name|n
argument_list|)
operator|->
name|flags
operator|&
name|PFLAG_NOT
condition|)
name|taddstr
argument_list|(
literal|"! "
argument_list|)
expr_stmt|;
if|if
condition|(
name|_Sublist
argument_list|(
name|n
argument_list|)
operator|->
name|flags
operator|&
name|PFLAG_COPROC
condition|)
name|taddstr
argument_list|(
literal|"coproc "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|_Sublist
argument_list|(
name|n
argument_list|)
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|_Sublist
argument_list|(
name|n
argument_list|)
operator|->
name|right
condition|)
block|{
name|taddstr
argument_list|(
operator|(
name|_Sublist
argument_list|(
name|n
argument_list|)
operator|->
name|type
operator|==
name|ORNEXT
operator|)
condition|?
literal|" || "
else|:
literal|"&& "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|_Sublist
argument_list|(
name|n
argument_list|)
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_PLINE
case|:
name|gt2
argument_list|(
name|_Pline
argument_list|(
name|n
argument_list|)
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|_Pline
argument_list|(
name|n
argument_list|)
operator|->
name|type
operator|==
name|PIPE
condition|)
block|{
name|taddstr
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|_Pline
argument_list|(
name|n
argument_list|)
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_CMD
case|:
name|nn
operator|=
name|_Cmd
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|flags
operator|&
name|CFLAG_EXEC
condition|)
name|taddstr
argument_list|(
literal|"exec "
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|flags
operator|&
name|CFLAG_COMMAND
condition|)
name|taddstr
argument_list|(
literal|"command "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nn
operator|->
name|type
condition|)
block|{
case|case
name|SIMPLE
case|:
name|getsimptext
argument_list|(
name|nn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBSH
case|:
name|taddstr
argument_list|(
literal|"( "
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddstr
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZCTIME
case|:
name|taddstr
argument_list|(
literal|"time "
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|pline
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
break|break;
case|case
name|FUNCDEF
case|:
name|taddlist
argument_list|(
name|nn
operator|->
name|args
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|" () {"
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|taddstr
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CURSH
case|:
name|taddstr
argument_list|(
literal|"{ "
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddstr
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFOR
case|:
case|case
name|CSELECT
case|:
name|taddstr
argument_list|(
operator|(
name|nn
operator|->
name|type
operator|==
name|CFOR
operator|)
condition|?
literal|"for "
else|:
literal|"select "
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
name|nn
operator|->
name|u
operator|.
name|forcmd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|u
operator|.
name|forcmd
operator|->
name|inflag
condition|)
block|{
name|taddstr
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|taddlist
argument_list|(
name|nn
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
name|taddnl
argument_list|()
expr_stmt|;
name|taddstr
argument_list|(
literal|"do"
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|forcmd
operator|->
name|list
argument_list|)
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddstr
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIF
case|:
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|ifcmd
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|"fi"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CCASE
case|:
name|taddstr
argument_list|(
literal|"case "
argument_list|)
expr_stmt|;
name|taddlist
argument_list|(
name|nn
operator|->
name|args
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|" in"
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|casecmd
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
if|if
condition|(
name|tnewlins
condition|)
name|taddnl
argument_list|()
expr_stmt|;
else|else
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|"esac"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND
case|:
name|taddstr
argument_list|(
literal|"[[ "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|cond
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|" ]]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CREPEAT
case|:
name|taddstr
argument_list|(
literal|"repeat "
argument_list|)
expr_stmt|;
name|taddlist
argument_list|(
name|nn
operator|->
name|args
argument_list|)
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|taddstr
argument_list|(
literal|"do"
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|list
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|taddstr
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CWHILE
case|:
name|gt2
argument_list|(
name|nn
operator|->
name|u
operator|.
name|whilecmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|getredirs
argument_list|(
name|nn
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_COND
case|:
name|nm
operator|=
name|_Cond
argument_list|(
name|n
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nm
operator|->
name|type
condition|)
block|{
case|case
name|COND_NOT
case|:
name|taddstr
argument_list|(
literal|"! "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|nm
operator|->
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_AND
case|:
name|taddstr
argument_list|(
literal|"( "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|nm
operator|->
name|left
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|nm
operator|->
name|right
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_OR
case|:
name|taddstr
argument_list|(
literal|"( "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|nm
operator|->
name|left
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|nm
operator|->
name|right
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
specifier|static
name|char
modifier|*
name|c1
index|[]
init|=
block|{
literal|" = "
block|,
literal|" != "
block|,
literal|"< "
block|,
literal|"> "
block|,
literal|" -nt "
block|,
literal|" -ot "
block|,
literal|" -ef "
block|,
literal|" -eq "
block|,
literal|" -ne "
block|,
literal|" -lt "
block|,
literal|" -gt "
block|,
literal|" -le "
block|,
literal|" -ge "
block|}
decl_stmt|;
if|if
condition|(
name|nm
operator|->
name|right
condition|)
name|taddstr
argument_list|(
name|nm
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|->
name|type
operator|<=
name|COND_GE
condition|)
name|taddstr
argument_list|(
name|c1
index|[
name|nm
operator|->
name|type
operator|-
name|COND_STREQ
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|c2
index|[
literal|5
index|]
decl_stmt|;
name|c2
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|c2
index|[
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
name|c2
index|[
literal|2
index|]
operator|=
name|nm
operator|->
name|type
expr_stmt|;
name|c2
index|[
literal|3
index|]
operator|=
literal|' '
expr_stmt|;
name|c2
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|taddstr
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
name|taddstr
argument_list|(
operator|(
name|nm
operator|->
name|right
operator|)
condition|?
name|nm
operator|->
name|right
else|:
name|nm
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|N_CASE
case|:
name|taddstr
argument_list|(
name|_casecmd
argument_list|(
name|n
argument_list|)
operator|->
name|pat
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|gt2
argument_list|(
name|_casecmd
argument_list|(
name|n
argument_list|)
operator|->
name|list
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddstr
argument_list|(
literal|";;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnewlins
condition|)
name|taddnl
argument_list|()
expr_stmt|;
else|else
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|_casecmd
argument_list|(
name|n
argument_list|)
operator|->
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_IF
case|:
if|if
condition|(
name|_ifcmd
argument_list|(
name|n
argument_list|)
operator|->
name|ifl
condition|)
block|{
name|taddstr
argument_list|(
literal|"if "
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|gt2
argument_list|(
name|_ifcmd
argument_list|(
name|n
argument_list|)
operator|->
name|ifl
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|taddstr
argument_list|(
literal|"then"
argument_list|)
expr_stmt|;
block|}
else|else
name|taddchr
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|gt2
argument_list|(
name|_ifcmd
argument_list|(
name|n
argument_list|)
operator|->
name|thenl
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
if|if
condition|(
name|_ifcmd
argument_list|(
name|n
argument_list|)
operator|->
name|next
condition|)
block|{
name|taddstr
argument_list|(
literal|"els"
argument_list|)
expr_stmt|;
name|gt2
argument_list|(
name|_ifcmd
argument_list|(
name|n
argument_list|)
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|N_WHILE
case|:
name|taddstr
argument_list|(
operator|(
name|_whilecmd
argument_list|(
name|n
argument_list|)
operator|->
name|cond
operator|)
condition|?
literal|"until "
else|:
literal|"while "
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|gt2
argument_list|(
name|_whilecmd
argument_list|(
name|n
argument_list|)
operator|->
name|cont
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|taddstr
argument_list|(
literal|"do"
argument_list|)
expr_stmt|;
name|tindent
operator|++
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|gt2
argument_list|(
name|_whilecmd
argument_list|(
name|n
argument_list|)
operator|->
name|loop
argument_list|)
expr_stmt|;
name|tindent
operator|--
expr_stmt|;
name|taddnl
argument_list|()
expr_stmt|;
name|taddstr
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|getsimptext
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
block|{
name|Lknode
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|cmd
operator|->
name|vars
argument_list|)
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
block|{
name|struct
name|varasg
modifier|*
name|v
init|=
name|getdata
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|taddstr
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|type
operator|&
name|PMTYPE
operator|)
operator|==
name|PMFLAG_A
condition|)
block|{
name|taddchr
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|taddlist
argument_list|(
name|v
operator|->
name|arr
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taddstr
argument_list|(
name|v
operator|->
name|str
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|taddlist
argument_list|(
name|cmd
operator|->
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getredirs
parameter_list|(
name|cmd
parameter_list|)
comment|/**/
name|Cmd
name|cmd
decl_stmt|;
block|{
name|Lknode
name|n
decl_stmt|;
specifier|static
name|char
modifier|*
name|fstr
index|[]
init|=
block|{
literal|">"
block|,
literal|">!"
block|,
literal|">>"
block|,
literal|">>!"
block|,
literal|">&"
block|,
literal|">&!"
block|,
literal|">>&"
block|,
literal|">>&!"
block|,
literal|"<"
block|,
literal|"<<"
block|,
literal|"<<-"
block|,
literal|"<<<"
block|,
literal|"<&"
block|,
literal|">&-"
block|,
literal|".."
block|,
literal|".."
block|}
decl_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|cmd
operator|->
name|redir
argument_list|)
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
block|{
name|struct
name|redir
modifier|*
name|f
init|=
name|getdata
argument_list|(
name|n
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|f
operator|->
name|type
condition|)
block|{
case|case
name|WRITE
case|:
case|case
name|WRITENOW
case|:
case|case
name|APP
case|:
case|case
name|APPNOW
case|:
case|case
name|READ
case|:
case|case
name|HERESTR
case|:
if|if
condition|(
name|f
operator|->
name|fd1
operator|!=
operator|(
operator|(
name|f
operator|->
name|type
operator|==
name|READ
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
condition|)
name|taddchr
argument_list|(
literal|'0'
operator|+
name|f
operator|->
name|fd1
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
name|fstr
index|[
name|f
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|MERGE
case|:
case|case
name|MERGEOUT
case|:
if|if
condition|(
name|f
operator|->
name|fd1
operator|!=
operator|(
operator|(
name|f
operator|->
name|type
operator|==
name|MERGEOUT
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
condition|)
name|taddchr
argument_list|(
literal|'0'
operator|+
name|f
operator|->
name|fd1
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
name|fstr
index|[
name|f
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|taddint
argument_list|(
name|f
operator|->
name|fd2
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
name|taddchr
argument_list|(
name|f
operator|->
name|fd1
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
literal|">&- "
argument_list|)
expr_stmt|;
break|break;
case|case
name|INPIPE
case|:
case|case
name|OUTPIPE
case|:
if|if
condition|(
name|f
operator|->
name|fd1
operator|!=
operator|(
operator|(
name|f
operator|->
name|type
operator|==
name|INPIPE
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
condition|)
name|taddchr
argument_list|(
literal|'0'
operator|+
name|f
operator|->
name|fd1
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
operator|(
name|f
operator|->
name|type
operator|==
name|INPIPE
operator|)
condition|?
literal|"< "
else|:
literal|"> "
argument_list|)
expr_stmt|;
name|taddstr
argument_list|(
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|tptr
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|taddlist
parameter_list|(
name|l
parameter_list|)
comment|/**/
name|Lklist
name|l
decl_stmt|;
block|{
name|Lknode
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|firstnode
argument_list|(
name|l
argument_list|)
init|;
name|n
condition|;
name|incnode
argument_list|(
name|n
argument_list|)
control|)
block|{
name|taddstr
argument_list|(
name|getdata
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|taddchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|tptr
operator|--
expr_stmt|;
block|}
end_function

end_unit

