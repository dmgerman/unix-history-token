begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   C K C M D B . C  --  malloc debugger. */
end_comment

begin_comment
comment|/*   Author: Howie Kaye, Columbia University Center for Computing Activities.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_comment
comment|/*   memdebug:   variable to control memory debugging.   if memdebug ==  1, then action is always taken.   if memdebug ==  0, then no action is taken.   if memdebug == -1, then the user is asked (works well with gdb). */
end_comment

begin_decl_stmt
name|int
name|memdebug
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   To use this package, compile your program with:   -Dmalloc=dmalloc -Dfree=dfree =Dcalloc=dcalloc ... -DMDEBUG   and then link it with ckcmdb.c. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MDEBUG
end_ifdef

begin_comment
comment|/* Use the real ones in this module! */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|malloc
end_ifdef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* malloc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|calloc
end_ifdef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* calloc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|realloc
end_ifdef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* realloc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|free
end_ifdef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* free */
end_comment

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|set_range_check
argument_list|()
decl_stmt|,
modifier|*
name|check_range
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|RANGE
value|"ABCDEFGHIJKLMNOP"
end_define

begin_define
define|#
directive|define
name|INTSIZE
value|sizeof(int)
end_define

begin_define
define|#
directive|define
name|LONGSIZE
value|sizeof(long)
end_define

begin_define
define|#
directive|define
name|RSIZE
value|sizeof(RANGE)
end_define

begin_define
define|#
directive|define
name|RFRONT
value|min((RSIZE/2),LONGSIZE)
end_define

begin_define
define|#
directive|define
name|RBACK
value|min((RSIZE-RFRONT),LONGSIZE)
end_define

begin_function
name|char
modifier|*
name|dmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|size
operator|+
name|RSIZE
operator|+
name|INTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|=
name|set_range_check
argument_list|(
name|cp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|m_insert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dcalloc
parameter_list|(
name|nelem
parameter_list|,
name|elsize
parameter_list|)
name|int
name|nelem
decl_stmt|,
name|elsize
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|dmalloc
argument_list|(
name|nelem
operator|*
name|elsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|bzero
argument_list|(
name|cp
argument_list|,
name|nelem
operator|*
name|elsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|drealloc
parameter_list|(
name|bp
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|maybe_quit
argument_list|(
literal|"Freeing NULL pointer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_delete
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|check_range
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|realloc
argument_list|(
name|cp
argument_list|,
name|size
operator|+
name|RSIZE
operator|+
name|INTSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|=
name|set_range_check
argument_list|(
name|cp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|m_insert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_macro
name|dfree
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|maybe_quit
argument_list|(
literal|"Freeing NULL pointer"
argument_list|)
expr_stmt|;
else|else
block|{
name|m_delete
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|check_range
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|free
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|set_range_check
parameter_list|(
name|cp
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|tmp
init|=
name|size
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INTSIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* set the size in the string */
name|cp
index|[
name|i
index|]
operator|=
name|tmp
operator|&
literal|0xff
expr_stmt|;
name|tmp
operator|>>=
literal|8
expr_stmt|;
block|}
name|cp
operator|+=
name|INTSIZE
expr_stmt|;
comment|/* skip the size */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RFRONT
condition|;
name|i
operator|++
control|)
comment|/* set the front of the range check */
name|cp
index|[
name|i
index|]
operator|=
name|RANGE
index|[
name|i
index|]
expr_stmt|;
comment|/* string */
name|cp
operator|+=
name|RFRONT
expr_stmt|;
comment|/* skip the front range check */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RBACK
condition|;
name|i
operator|++
control|)
comment|/* set the back odf the range check */
name|cp
index|[
name|i
operator|+
name|size
index|]
operator|=
name|RANGE
index|[
name|i
operator|+
name|RFRONT
index|]
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   Put calls to this routine in your code any place where you want to   check whether you've copied too many characters into a malloc'd space. */
end_comment

begin_function
name|char
modifier|*
name|check_range
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
init|=
name|cp
operator|-
name|RFRONT
operator|-
name|INTSIZE
decl_stmt|;
name|char
modifier|*
name|xp
init|=
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INTSIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* get the size out of the string */
name|size
operator|<<=
literal|8
expr_stmt|;
name|size
operator||=
name|bp
index|[
name|INTSIZE
operator|-
name|i
operator|-
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|bp
operator|+=
name|INTSIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RFRONT
condition|;
name|i
operator|++
control|)
comment|/* check front range check */
if|if
condition|(
name|bp
index|[
name|i
index|]
operator|!=
name|RANGE
index|[
name|i
index|]
condition|)
block|{
name|maybe_quit
argument_list|(
literal|"leftside malloc buffer overrun"
argument_list|)
expr_stmt|;
break|break;
block|}
name|bp
operator|+=
name|RFRONT
expr_stmt|;
comment|/* skip front range check */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RBACK
condition|;
name|i
operator|++
control|)
comment|/* check back rnage check */
if|if
condition|(
name|bp
index|[
name|i
operator|+
name|size
index|]
operator|!=
name|RANGE
index|[
name|i
operator|+
name|RFRONT
index|]
condition|)
block|{
name|maybe_quit
argument_list|(
literal|"rightside malloc buffer overrun"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|xp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUCKETS
value|10000
end_define

begin_decl_stmt
name|char
modifier|*
name|m_used
index|[
name|BUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|m_insert
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m_used
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|m_used
index|[
name|i
index|]
operator|=
name|cp
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|VOID
name|m_delete
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m_used
index|[
name|i
index|]
operator|==
name|cp
condition|)
block|{
name|m_used
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|maybe_quit
argument_list|(
literal|"Freeing unmalloc'ed pointer"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VOID
name|m_init
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
name|m_used
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|VOID
name|m_done
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m_used
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|memdebug
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unfree'ed buffers, indices: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d, "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
name|maybe_quit
argument_list|(
literal|"Unfree'ed malloc buffers"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VOID
name|m_checkranges
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m_used
index|[
name|i
index|]
condition|)
name|check_range
argument_list|(
name|m_used
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|maybe_quit
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"mdebug maybe_quit"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|memdebug
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|memdebug
operator|==
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|memdebug
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|ask
argument_list|(
literal|"Quit? "
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ask
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|99
argument_list|,
name|in
argument_list|)
operator|==
name|NULL
condition|)
comment|/* EOF? */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'n'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"please answer y/n.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MDEBUG */
end_comment

end_unit

