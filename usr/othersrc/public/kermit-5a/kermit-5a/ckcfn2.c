begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  C K C F N 2  --  System-independent Kermit protocol support functions... */
end_comment

begin_comment
comment|/*  ...Part 2 (continued from ckcfns.c)  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@watsun.cc.columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/*  Note -- if you change this file, please amend the version number and date at  the top of ckcfns.c accordingly. */
end_comment

begin_include
include|#
directive|include
file|"ckcsym.h"
end_include

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
modifier|*
name|s_pkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
modifier|*
name|r_pkt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
name|s_pkt
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pktinfo
name|r_pkt
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pktinfo structures */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sseqtbl
index|[]
decl_stmt|,
name|rseqtbl
index|[]
decl_stmt|,
name|sbufuse
index|[]
decl_stmt|,
name|sacktbl
index|[]
decl_stmt|,
name|wslots
decl_stmt|,
name|winlo
decl_stmt|,
name|sbufnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ttprty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from ckutio.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|autopar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|spsiz
decl_stmt|,
name|spmax
decl_stmt|,
name|rpsiz
decl_stmt|,
name|timint
decl_stmt|,
name|npad
decl_stmt|,
name|ebq
decl_stmt|,
name|ebqflg
decl_stmt|,
name|pkttim
decl_stmt|,
name|rtimo
decl_stmt|,
name|rpt
decl_stmt|,
name|rptq
decl_stmt|,
name|rptflg
decl_stmt|,
name|capas
decl_stmt|,
name|spsizf
decl_stmt|,
name|en_fin
decl_stmt|,
name|tsecs
decl_stmt|,
name|network
decl_stmt|,
name|flow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pktnum
decl_stmt|,
name|sndtyp
decl_stmt|,
name|bctr
decl_stmt|,
name|bctu
decl_stmt|,
name|rsn
decl_stmt|,
name|rln
decl_stmt|,
name|maxtry
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|osize
decl_stmt|,
name|maxsize
decl_stmt|,
name|spktl
decl_stmt|,
name|nfils
decl_stmt|,
name|stdouf
decl_stmt|,
name|warn
decl_stmt|,
name|timef
decl_stmt|,
name|parity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|turn
decl_stmt|,
name|turnch
decl_stmt|,
name|delay
decl_stmt|,
name|displa
decl_stmt|,
name|pktlog
decl_stmt|,
name|tralog
decl_stmt|,
name|seslog
decl_stmt|,
name|xflg
decl_stmt|,
name|mypadn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hcflg
decl_stmt|,
name|binary
decl_stmt|,
name|local
decl_stmt|,
name|server
decl_stmt|,
name|cxseen
decl_stmt|,
name|czseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nakstate
decl_stmt|,
name|quiet
decl_stmt|,
name|success
decl_stmt|,
name|xitsta
decl_stmt|,
name|what
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|spackets
decl_stmt|,
name|rpackets
decl_stmt|,
name|timeouts
decl_stmt|,
name|retrans
decl_stmt|,
name|crunched
decl_stmt|,
name|wmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|filcnt
decl_stmt|,
name|ffc
decl_stmt|,
name|flci
decl_stmt|,
name|flco
decl_stmt|,
name|tlci
decl_stmt|,
name|tlco
decl_stmt|,
name|tfc
decl_stmt|,
name|fsize
decl_stmt|,
name|speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
name|filnam
index|[]
decl_stmt|,
modifier|*
name|hlptxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|padch
decl_stmt|,
name|mypadc
decl_stmt|,
name|eol
decl_stmt|,
name|seol
decl_stmt|,
name|ctlq
decl_stmt|,
name|myctlq
decl_stmt|,
name|sstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|recpkt
decl_stmt|,
modifier|*
name|data
decl_stmt|,
name|encbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|srvptr
decl_stmt|,
name|stchr
decl_stmt|,
name|mystch
decl_stmt|,
modifier|*
name|rdatap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|padbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_decl_stmt
specifier|extern
name|CHAR
modifier|*
name|srvcmd
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|CHAR
name|srvcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC */
end_comment

begin_decl_stmt
name|int
name|numerrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (PWP) total number packet errors so far */
end_comment

begin_decl_stmt
specifier|static
name|CHAR
name|partab
index|[]
init|=
block|{
comment|/* Even parity table for dopar(). */
operator|(
name|CHAR
operator|)
literal|'\000'
block|,
comment|/* ANSI C casts '\ooo' constants  */
operator|(
name|CHAR
operator|)
literal|'\201'
block|,
comment|/* to signed char, so we have to  */
operator|(
name|CHAR
operator|)
literal|'\202'
block|,
comment|/* cast back to unsigned char...  */
operator|(
name|CHAR
operator|)
literal|'\003'
block|,
operator|(
name|CHAR
operator|)
literal|'\204'
block|,
operator|(
name|CHAR
operator|)
literal|'\005'
block|,
operator|(
name|CHAR
operator|)
literal|'\006'
block|,
operator|(
name|CHAR
operator|)
literal|'\207'
block|,
operator|(
name|CHAR
operator|)
literal|'\210'
block|,
operator|(
name|CHAR
operator|)
literal|'\011'
block|,
operator|(
name|CHAR
operator|)
literal|'\012'
block|,
operator|(
name|CHAR
operator|)
literal|'\213'
block|,
operator|(
name|CHAR
operator|)
literal|'\014'
block|,
operator|(
name|CHAR
operator|)
literal|'\215'
block|,
operator|(
name|CHAR
operator|)
literal|'\216'
block|,
operator|(
name|CHAR
operator|)
literal|'\017'
block|,
operator|(
name|CHAR
operator|)
literal|'\220'
block|,
operator|(
name|CHAR
operator|)
literal|'\021'
block|,
operator|(
name|CHAR
operator|)
literal|'\022'
block|,
operator|(
name|CHAR
operator|)
literal|'\223'
block|,
operator|(
name|CHAR
operator|)
literal|'\024'
block|,
operator|(
name|CHAR
operator|)
literal|'\225'
block|,
operator|(
name|CHAR
operator|)
literal|'\226'
block|,
operator|(
name|CHAR
operator|)
literal|'\027'
block|,
operator|(
name|CHAR
operator|)
literal|'\030'
block|,
operator|(
name|CHAR
operator|)
literal|'\231'
block|,
operator|(
name|CHAR
operator|)
literal|'\232'
block|,
operator|(
name|CHAR
operator|)
literal|'\033'
block|,
operator|(
name|CHAR
operator|)
literal|'\234'
block|,
operator|(
name|CHAR
operator|)
literal|'\035'
block|,
operator|(
name|CHAR
operator|)
literal|'\036'
block|,
operator|(
name|CHAR
operator|)
literal|'\237'
block|,
operator|(
name|CHAR
operator|)
literal|'\240'
block|,
operator|(
name|CHAR
operator|)
literal|'\041'
block|,
operator|(
name|CHAR
operator|)
literal|'\042'
block|,
operator|(
name|CHAR
operator|)
literal|'\243'
block|,
operator|(
name|CHAR
operator|)
literal|'\044'
block|,
operator|(
name|CHAR
operator|)
literal|'\245'
block|,
operator|(
name|CHAR
operator|)
literal|'\246'
block|,
operator|(
name|CHAR
operator|)
literal|'\047'
block|,
operator|(
name|CHAR
operator|)
literal|'\050'
block|,
operator|(
name|CHAR
operator|)
literal|'\251'
block|,
operator|(
name|CHAR
operator|)
literal|'\252'
block|,
operator|(
name|CHAR
operator|)
literal|'\053'
block|,
operator|(
name|CHAR
operator|)
literal|'\254'
block|,
operator|(
name|CHAR
operator|)
literal|'\055'
block|,
operator|(
name|CHAR
operator|)
literal|'\056'
block|,
operator|(
name|CHAR
operator|)
literal|'\257'
block|,
operator|(
name|CHAR
operator|)
literal|'\060'
block|,
operator|(
name|CHAR
operator|)
literal|'\261'
block|,
operator|(
name|CHAR
operator|)
literal|'\262'
block|,
operator|(
name|CHAR
operator|)
literal|'\063'
block|,
operator|(
name|CHAR
operator|)
literal|'\264'
block|,
operator|(
name|CHAR
operator|)
literal|'\065'
block|,
operator|(
name|CHAR
operator|)
literal|'\066'
block|,
operator|(
name|CHAR
operator|)
literal|'\267'
block|,
operator|(
name|CHAR
operator|)
literal|'\270'
block|,
operator|(
name|CHAR
operator|)
literal|'\071'
block|,
operator|(
name|CHAR
operator|)
literal|'\072'
block|,
operator|(
name|CHAR
operator|)
literal|'\273'
block|,
operator|(
name|CHAR
operator|)
literal|'\074'
block|,
operator|(
name|CHAR
operator|)
literal|'\275'
block|,
operator|(
name|CHAR
operator|)
literal|'\276'
block|,
operator|(
name|CHAR
operator|)
literal|'\077'
block|,
operator|(
name|CHAR
operator|)
literal|'\300'
block|,
operator|(
name|CHAR
operator|)
literal|'\101'
block|,
operator|(
name|CHAR
operator|)
literal|'\102'
block|,
operator|(
name|CHAR
operator|)
literal|'\303'
block|,
operator|(
name|CHAR
operator|)
literal|'\104'
block|,
operator|(
name|CHAR
operator|)
literal|'\305'
block|,
operator|(
name|CHAR
operator|)
literal|'\306'
block|,
operator|(
name|CHAR
operator|)
literal|'\107'
block|,
operator|(
name|CHAR
operator|)
literal|'\110'
block|,
operator|(
name|CHAR
operator|)
literal|'\311'
block|,
operator|(
name|CHAR
operator|)
literal|'\312'
block|,
operator|(
name|CHAR
operator|)
literal|'\113'
block|,
operator|(
name|CHAR
operator|)
literal|'\314'
block|,
operator|(
name|CHAR
operator|)
literal|'\115'
block|,
operator|(
name|CHAR
operator|)
literal|'\116'
block|,
operator|(
name|CHAR
operator|)
literal|'\317'
block|,
operator|(
name|CHAR
operator|)
literal|'\120'
block|,
operator|(
name|CHAR
operator|)
literal|'\321'
block|,
operator|(
name|CHAR
operator|)
literal|'\322'
block|,
operator|(
name|CHAR
operator|)
literal|'\123'
block|,
operator|(
name|CHAR
operator|)
literal|'\324'
block|,
operator|(
name|CHAR
operator|)
literal|'\125'
block|,
operator|(
name|CHAR
operator|)
literal|'\126'
block|,
operator|(
name|CHAR
operator|)
literal|'\327'
block|,
operator|(
name|CHAR
operator|)
literal|'\330'
block|,
operator|(
name|CHAR
operator|)
literal|'\131'
block|,
operator|(
name|CHAR
operator|)
literal|'\132'
block|,
operator|(
name|CHAR
operator|)
literal|'\333'
block|,
operator|(
name|CHAR
operator|)
literal|'\134'
block|,
operator|(
name|CHAR
operator|)
literal|'\335'
block|,
operator|(
name|CHAR
operator|)
literal|'\336'
block|,
operator|(
name|CHAR
operator|)
literal|'\137'
block|,
operator|(
name|CHAR
operator|)
literal|'\140'
block|,
operator|(
name|CHAR
operator|)
literal|'\341'
block|,
operator|(
name|CHAR
operator|)
literal|'\342'
block|,
operator|(
name|CHAR
operator|)
literal|'\143'
block|,
operator|(
name|CHAR
operator|)
literal|'\344'
block|,
operator|(
name|CHAR
operator|)
literal|'\145'
block|,
operator|(
name|CHAR
operator|)
literal|'\146'
block|,
operator|(
name|CHAR
operator|)
literal|'\347'
block|,
operator|(
name|CHAR
operator|)
literal|'\350'
block|,
operator|(
name|CHAR
operator|)
literal|'\151'
block|,
operator|(
name|CHAR
operator|)
literal|'\152'
block|,
operator|(
name|CHAR
operator|)
literal|'\353'
block|,
operator|(
name|CHAR
operator|)
literal|'\154'
block|,
operator|(
name|CHAR
operator|)
literal|'\355'
block|,
operator|(
name|CHAR
operator|)
literal|'\356'
block|,
operator|(
name|CHAR
operator|)
literal|'\157'
block|,
operator|(
name|CHAR
operator|)
literal|'\360'
block|,
operator|(
name|CHAR
operator|)
literal|'\161'
block|,
operator|(
name|CHAR
operator|)
literal|'\162'
block|,
operator|(
name|CHAR
operator|)
literal|'\363'
block|,
operator|(
name|CHAR
operator|)
literal|'\164'
block|,
operator|(
name|CHAR
operator|)
literal|'\365'
block|,
operator|(
name|CHAR
operator|)
literal|'\366'
block|,
operator|(
name|CHAR
operator|)
literal|'\167'
block|,
operator|(
name|CHAR
operator|)
literal|'\170'
block|,
operator|(
name|CHAR
operator|)
literal|'\371'
block|,
operator|(
name|CHAR
operator|)
literal|'\372'
block|,
operator|(
name|CHAR
operator|)
literal|'\173'
block|,
operator|(
name|CHAR
operator|)
literal|'\374'
block|,
operator|(
name|CHAR
operator|)
literal|'\175'
block|,
operator|(
name|CHAR
operator|)
literal|'\176'
block|,
operator|(
name|CHAR
operator|)
literal|'\377'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CRC generation tables */
end_comment

begin_decl_stmt
specifier|static
name|long
name|crcta
index|[
literal|16
index|]
init|=
block|{
literal|0L
block|,
literal|010201L
block|,
literal|020402L
block|,
literal|030603L
block|,
literal|041004L
block|,
literal|051205L
block|,
literal|061406L
block|,
literal|071607L
block|,
literal|0102010L
block|,
literal|0112211L
block|,
literal|0122412L
block|,
literal|0132613L
block|,
literal|0143014L
block|,
literal|0153215L
block|,
literal|0163416L
block|,
literal|0173617L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|crctb
index|[
literal|16
index|]
init|=
block|{
literal|0L
block|,
literal|010611L
block|,
literal|021422L
block|,
literal|031233L
block|,
literal|043044L
block|,
literal|053655L
block|,
literal|062466L
block|,
literal|072277L
block|,
literal|0106110L
block|,
literal|0116701L
block|,
literal|0127532L
block|,
literal|0137323L
block|,
literal|0145154L
block|,
literal|0155745L
block|,
literal|0164576L
block|,
literal|0174367L
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  I N P U T  --  Attempt to read packet number 'pktnum'.  */
end_comment

begin_comment
comment|/*  This is the function that feeds input to Kermit's finite state machine,  in the form of a character in the range 32-126, normally a packet type  (uppercase letter) or pseudo-packet-type (lowercase letter).   If a special start state is in effect, that state is returned as if it were  the type of an incoming packet.  Otherwise:   (fill in...) */
end_comment

begin_function
name|int
name|input
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|,
name|y
decl_stmt|,
name|k
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sstate"
argument_list|,
literal|""
argument_list|,
name|sstate
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" nakstate"
argument_list|,
literal|""
argument_list|,
name|nakstate
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|" sndtyp"
argument_list|,
literal|""
argument_list|,
name|sndtyp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Big loop... */
if|if
condition|(
name|sstate
operator|!=
literal|0
condition|)
block|{
comment|/* If a start state is in effect, */
name|type
operator|=
name|sstate
expr_stmt|;
comment|/* return it like a packet type, */
name|sstate
operator|=
literal|0
expr_stmt|;
comment|/* and then nullify it. */
name|numerrs
operator|=
literal|0
expr_stmt|;
comment|/* (PWP) no errors so far */
return|return
operator|(
name|type
operator|)
return|;
block|}
if|if
condition|(
name|nakstate
condition|)
block|{
comment|/* This section for file receiver. */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
block|{
comment|/* If we're doing windows, */
name|x
operator|=
name|rseqtbl
index|[
name|winlo
index|]
expr_stmt|;
comment|/* see if desired packet already in. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" rseqtbl[winlo]"
argument_list|,
literal|""
argument_list|,
name|rseqtbl
index|[
name|winlo
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Already there? */
if|if
condition|(
name|r_pkt
index|[
name|x
index|]
operator|.
name|pk_seq
operator|==
name|winlo
condition|)
block|{
comment|/* (double check) */
name|rsn
operator|=
name|winlo
expr_stmt|;
comment|/* Yes, return its info */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input return pre-stashed packet"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|dumprbuf
argument_list|()
expr_stmt|;
name|rdatap
operator|=
name|r_pkt
index|[
name|x
index|]
operator|.
name|pk_adr
expr_stmt|;
comment|/* like rpack would do. */
name|rln
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rdatap
argument_list|)
expr_stmt|;
name|type
operator|=
name|r_pkt
index|[
name|x
index|]
operator|.
name|pk_typ
expr_stmt|;
break|break;
block|}
block|}
block|}
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
comment|/* Try to read a packet. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"input"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rdatap
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|==
name|sndtyp
condition|)
block|{
comment|/* Handle echoes */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"echo discarded"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|rseqtbl
index|[
name|rsn
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|<
operator|-
literal|1
condition|)
return|return
operator|(
literal|'q'
operator|)
return|;
comment|/* Ctrl-C */
if|if
condition|(
name|type
operator|<
literal|0
condition|)
block|{
comment|/* Receive window full */
comment|/* Another thing to do here would be to delete */
comment|/* the highest packet and NAK winlo.  But that */
comment|/* shouldn't be necessary since the other Kermit */
comment|/* should not have sent a packet outside the window. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack receive window full"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dumprbuf
argument_list|()
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Receive window full."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Receive window full."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
name|dumprbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|chkint
argument_list|()
operator|<
literal|0
condition|)
block|{
comment|/* Check for console interrupts. */
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"User cancelled."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"User cancelled."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
literal|'E'
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input got E, nakstate"
argument_list|,
literal|""
argument_list|,
name|nakstate
argument_list|)
expr_stmt|;
break|break;
comment|/* Error packet */
block|}
if|if
condition|(
name|type
operator|==
literal|'Q'
condition|)
block|{
comment|/* Crunched packet. */
name|crunched
operator|++
expr_stmt|;
name|numerrs
operator|++
expr_stmt|;
if|if
condition|(
name|nack
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Request resend of window-low.. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sent too many naks"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Sent too many NAKs."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
literal|'T'
condition|)
block|{
comment|/* Timeout */
ifdef|#
directive|ifdef
name|BULKNAKS
name|int
name|z
decl_stmt|;
endif|#
directive|endif
name|timeouts
operator|++
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input receive-state timeout, winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BULKNAKS
name|z
operator|=
name|winlo
operator|+
name|wslots
expr_stmt|;
comment|/* NAK all unACK'd packets */
if|if
condition|(
name|z
operator|>
literal|63
condition|)
name|z
operator|-=
literal|64
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sending bulk NAKs, winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|winlo
init|;
operator|(
name|x
operator|!=
name|z
operator|)
operator|&&
name|ttchk
argument_list|()
operator|==
literal|0
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|63
condition|)
break|break;
if|if
condition|(
name|rseqtbl
index|[
name|x
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|nack
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sent too many naks"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|recpkt
argument_list|,
literal|"Sent too many NAKs."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
block|}
block|}
else|#
directive|else
comment|/* NAK only the packet at window-low */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sending NAK for winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
if|if
condition|(
name|nack
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input sent too many naks"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Sent too many NAKs."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* BULKNAKS */
continue|continue;
block|}
comment|/* Got the packet we want, done. */
if|if
condition|(
name|rsn
operator|==
name|winlo
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input rsn=winlo"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Got a packet out of order. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input got data packet out of order"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|k
operator|=
name|rseqtbl
index|[
name|rsn
index|]
expr_stmt|;
comment|/* Get window slot of this packet. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input rseqtbl[rsn]"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input can't find index for rcvd pkt"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"internal error number 21"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"S/W Protocol Error."
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
name|y
operator|=
name|chkwin
argument_list|(
name|rsn
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
comment|/* See what window it's in. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input chkwin"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|1
condition|)
block|{
comment|/* Previous window. */
name|ackn
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Send empty ACK */
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Get rid of received packet */
continue|continue;
block|}
else|else
block|{
comment|/* In this window or out of range */
if|if
condition|(
name|y
operator|<
literal|0
condition|)
comment|/* If out of range entirely, */
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* release its buffer */
comment|/*   We have received a packet, but not the one we want.  If we do nothing,   we could be in for a lengthy timeout/retry cycle.  It would seem to   make sense to send a NAK for the most desired packet (winlo).  But   consider this scenario: a packet arrived damaged so we NAK'd it above;   then packets winlo+1, winlo+2, ... winlo+n arrive, each one making us   send a NAK for winlo, so the other Kermit gets n NAKs for winlo, and   either would have to resend it n times, or if n> retry limit, give up   because of too many retries.  So we compromise: If a packet arrives   that is not the most desired packet (winlo), we NAK winlo, BUT ONLY IF   it has not be NAK'd before. */
if|if
condition|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
operator|==
literal|0
condition|)
block|{
comment|/* Have we been here before? */
if|if
condition|(
name|nack
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* No, NAK winlo. */
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Too many retries."
argument_list|)
expr_stmt|;
comment|/* Too many */
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Timed out."
argument_list|)
expr_stmt|;
comment|/* Give up */
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
block|}
else|else
continue|continue;
block|}
comment|/*!!!*/
block|}
else|else
block|{
comment|/* Otherwise file sender... */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
block|{
comment|/* Packet at winlo already ACK'd? */
ifdef|#
directive|ifdef
name|COMMENT
name|x
operator|=
name|sseqtbl
index|[
name|winlo
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|s_pkt
index|[
name|x
index|]
operator|.
name|pk_flg
condition|)
block|{
comment|/* If so,  */
name|freesbuf
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
comment|/* Free its buffer */
else|#
directive|else
if|if
condition|(
name|sacktbl
index|[
name|winlo
index|]
condition|)
block|{
comment|/* If so,  */
name|sacktbl
index|[
name|winlo
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Turn off the ACK'd flag */
endif|#
directive|endif
name|winlo
operator|=
operator|(
name|winlo
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
comment|/* Rotate the window */
name|type
operator|=
literal|'Y'
expr_stmt|;
comment|/* And return ACK */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input returning pre-stashed ACK"
argument_list|,
literal|""
argument_list|,
name|winlo
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|COMMENT
block|}
endif|#
directive|endif
comment|/* COMMENT */
block|}
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
comment|/* Try to read an ack. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"input"
argument_list|,
name|rdatap
argument_list|,
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|==
name|sndtyp
condition|)
block|{
comment|/* Handle echoes */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"echo discarded"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|rseqtbl
index|[
name|rsn
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|rpack
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
operator|-
literal|2
condition|)
return|return
operator|(
literal|'q'
operator|)
return|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
block|{
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"Internal error number 18"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" wslots"
argument_list|,
literal|""
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" pktnum"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
name|dumprbuf
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Can't allocate receive buffer"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|'E'
expr_stmt|;
break|break;
block|}
name|dumprbuf
argument_list|()
expr_stmt|;
comment|/* debugging */
if|if
condition|(
name|chkint
argument_list|()
operator|<
literal|0
condition|)
block|{
comment|/* Check for console interrupts. */
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"User cancelled."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"User cancelled."
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|=
literal|'E'
operator|)
return|;
block|}
comment|/* got a packet */
if|if
condition|(
name|type
operator|==
literal|'E'
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input got E, nakstate"
argument_list|,
literal|""
argument_list|,
name|nakstate
argument_list|)
expr_stmt|;
break|break;
comment|/* Error packet */
block|}
if|if
condition|(
name|type
operator|==
literal|'Q'
condition|)
block|{
comment|/* Crunched packet */
name|crunched
operator|++
expr_stmt|;
comment|/* For statistics */
name|numerrs
operator|++
expr_stmt|;
comment|/* For packet resizing */
name|x
operator|=
name|resend
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
comment|/* Resend window-low */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
literal|'T'
condition|)
block|{
comment|/* Timeout waiting for ACKs. */
ifdef|#
directive|ifdef
name|BULKNAKS
name|int
name|z
decl_stmt|;
comment|/* Resend all un-ACK'd packets. */
endif|#
directive|endif
name|timeouts
operator|++
expr_stmt|;
name|numerrs
operator|++
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input send-state timeout, winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BULKNAKS
comment|/* Retransmit all un-ACK'd packets. */
name|z
operator|=
operator|(
name|pktnum
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input resending unack'd packets, winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" pktnum"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|winlo
init|;
operator|(
name|x
operator|!=
name|z
operator|)
operator|&&
operator|(
name|ttchk
argument_list|()
operator|==
literal|0
operator|)
condition|;
operator|(
name|x
operator|=
operator|(
name|x
operator|+
literal|1
operator|)
operator|%
literal|64
operator|)
control|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|63
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input resend invalid packet"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|sseqtbl
index|[
name|x
index|]
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|k
operator|>
literal|31
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input resend invalid slot"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If formed and unack'd, resend */
if|if
condition|(
ifdef|#
directive|ifdef
name|COMMENT
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_flg
operator|==
literal|0
else|#
directive|else
name|sacktbl
index|[
name|x
index|]
operator|==
literal|0
endif|#
directive|endif
operator|&&
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|!=
name|SP
condition|)
block|{
if|if
condition|(
name|resend
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Check retries */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input resend max"
argument_list|,
literal|""
argument_list|,
name|maxtry
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|=
literal|'E'
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Already ACK'd, don't retransmit */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input resend pkt already ack'd"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Shouldn't happen */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input resend can't find pkt"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* Just retransmit the oldest un-ACK'd packet. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input resending winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
if|if
condition|(
name|resend
argument_list|(
name|winlo
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Check retries */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input too many resends"
argument_list|,
literal|""
argument_list|,
name|maxtry
argument_list|)
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|=
literal|'E'
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* BULKNAKS */
continue|continue;
block|}
comment|/* Got an actual normal packet */
name|y
operator|=
name|chkwin
argument_list|(
name|rsn
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
expr_stmt|;
comment|/* Is it in the window? */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input rsn"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input chkwin"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'Y'
condition|)
block|{
comment|/* Got an ACK */
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
comment|/* In current window */
name|x
operator|=
name|sseqtbl
index|[
name|rsn
index|]
expr_stmt|;
comment|/* Mark the packet as ACK'd */
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
name|s_pkt
index|[
name|x
index|]
operator|.
name|pk_flg
operator|++
expr_stmt|;
comment|/* (old way) */
name|sacktbl
index|[
name|rsn
index|]
operator|++
expr_stmt|;
comment|/* (new way) */
comment|/*   NOTE: The following statement frees the buffer of the ACK we just got.   But the upper layers still need the data, like if it's the ACK to an I,   S, F, D, Z, or just about any kind of packet.  So for now, freerbuf()   deallocates the buffer, but does not erase the data or destroy the pointer   to it.  There's no other single place where these receive buffers can be   correctly freed (?) ... */
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Free the ACK's buffer */
name|freesbuf
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* *** Free the sent packet's buffer */
if|if
condition|(
name|rsn
operator|==
name|winlo
condition|)
block|{
comment|/* Got the one we want */
name|sacktbl
index|[
name|winlo
index|]
operator|=
literal|0
expr_stmt|;
name|winlo
operator|=
operator|(
name|winlo
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input rotated send window"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
break|break;
comment|/* Return the ACK */
block|}
else|else
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input mark pkt"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Otherwise go read another packet */
block|}
block|}
else|else
block|{
comment|/* ACK not in window, ignore */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input ACK out of window"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|'N'
condition|)
block|{
comment|/* NAK */
name|numerrs
operator|++
expr_stmt|;
comment|/* Count an error */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input NAK"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
comment|/* In current window */
name|debug
argument_list|(
name|F100
argument_list|,
literal|" in window"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Free buffer where NAK lies. */
name|k
operator|=
name|sseqtbl
index|[
name|rsn
index|]
expr_stmt|;
comment|/* Get pointer to NAK'd packet. */
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
operator|(
name|k
operator|>
operator|-
literal|1
operator|&&
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|==
literal|' '
operator|)
condition|)
block|{
name|x
operator|=
name|resend
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
comment|/* Packet we haven't sent yet. */
block|}
else|else
block|{
name|x
operator|=
name|resend
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
comment|/* Resend requested packet. */
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Resend error is fatal.  */
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
comment|/* Resend ok, go read another packet */
block|}
elseif|else
if|if
condition|(
operator|(
name|rsn
operator|==
operator|(
name|pktnum
operator|+
literal|1
operator|)
operator|%
literal|64
operator|)
condition|)
block|{
comment|/* NAK for next pkt */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"NAK for next packet, windowing"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|x
operator|=
name|resend
argument_list|(
name|winlo
argument_list|)
expr_stmt|;
comment|/* Resend window-low */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
name|recpkt
argument_list|)
expr_stmt|;
break|break;
block|}
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Go back and read another pkt */
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|" NAK for next packet, no windowing"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|freerpkt
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|rsn
operator|-
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|sseqtbl
index|[
name|x
index|]
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
name|sacktbl
index|[
name|x
index|]
operator|++
expr_stmt|;
comment|/* (new way) */
name|s_pkt
index|[
name|x
index|]
operator|.
name|pk_flg
operator|++
expr_stmt|;
comment|/* (old way) */
block|}
name|type
operator|=
literal|'Y'
expr_stmt|;
comment|/* Treat it as ACK for current pkt */
break|break;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
comment|/* NAK for pkt we can't resend */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" NAK out of window"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
comment|/* bad... */
name|type
operator|=
literal|'E'
expr_stmt|;
name|errpkt
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
literal|"NAK out of window"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"NAK out of window."
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
comment|/* Ignore other NAKs */
block|}
comment|/* End of file-sender NAK handler */
if|if
condition|(
name|rsn
operator|==
name|winlo
condition|)
block|{
comment|/* Not ACK, NAK, timeout, etc. */
name|debug
argument_list|(
name|F000
argument_list|,
literal|"input unexpected type"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* End of file-sender section */
block|}
comment|/* End of input() loop */
if|if
condition|(
name|wslots
operator|==
literal|1
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"input about to flush"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Got what we want, clear input buffer. */
block|}
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Old complicated and slow method */
if|if
condition|(
name|spktl
operator|&&
operator|!
name|spsizf
operator|&&
operator|!
operator|(
name|pktnum
operator|&
literal|007
operator|)
condition|)
comment|/* should we recalc pack len? */
name|rcalcpsz
argument_list|()
expr_stmt|;
comment|/* (PWP) recalc every 8 packets */
else|#
directive|else
comment|/* New simple and fast method */
if|if
condition|(
operator|!
name|nakstate
condition|)
comment|/* When sending */
name|rcalcpsz
argument_list|()
expr_stmt|;
comment|/* recalculate size every packet */
endif|#
directive|endif
name|debug
argument_list|(
name|F000
argument_list|,
literal|"input returning type"
argument_list|,
literal|""
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
comment|/* Success, return packet type. */
block|}
comment|/*  D O P A R  --  Add an appropriate parity bit to a character  */
comment|/*   (PWP) this is still used in the Mac terminal emulator, so we have to keep it */
name|CHAR
ifdef|#
directive|ifdef
name|CK_ANSIC
name|dopar
parameter_list|(
specifier|register
name|CHAR
name|ch
parameter_list|)
else|#
directive|else
function|dopar
parameter_list|(
name|ch
parameter_list|)
specifier|register
name|CHAR
name|ch
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
block|{
specifier|register
name|unsigned
name|int
name|a
decl_stmt|;
if|if
condition|(
operator|!
name|parity
condition|)
return|return
operator|(
call|(
name|CHAR
call|)
argument_list|(
name|ch
operator|&
literal|255
argument_list|)
operator|)
return|;
else|else
name|a
operator|=
name|ch
operator|&
literal|127
expr_stmt|;
switch|switch
condition|(
name|parity
condition|)
block|{
case|case
literal|'e'
case|:
return|return
operator|(
name|partab
index|[
name|a
index|]
operator|)
return|;
comment|/* Even */
case|case
literal|'m'
case|:
return|return
operator|(
call|(
name|CHAR
call|)
argument_list|(
name|a
operator||
literal|128
argument_list|)
operator|)
return|;
comment|/* Mark */
case|case
literal|'o'
case|:
return|return
operator|(
call|(
name|CHAR
call|)
argument_list|(
name|partab
index|[
name|a
index|]
operator|^
literal|128
argument_list|)
operator|)
return|;
comment|/* Odd */
case|case
literal|'s'
case|:
return|return
operator|(
operator|(
name|CHAR
operator|)
name|a
operator|)
return|;
comment|/* Space */
default|default:
return|return
operator|(
operator|(
name|CHAR
operator|)
name|a
operator|)
return|;
comment|/* Something illegal */
block|}
block|}
ifdef|#
directive|ifdef
name|PARSENSE
comment|/*  P A R C H K  --  Check if Kermit packet has parity  */
comment|/*   Call with s = pointer to packet, start = packet start character, n = length.   Returns 0 if packet has no parity, -1 on error, or, if packet has parity:     'e' for even, 'o' for odd, 'm' for mark.  Space parity cannot be sensed.   So a return value of 0 really means either space or none. */
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|parchk
parameter_list|(
name|CHAR
modifier|*
name|s
parameter_list|,
name|CHAR
name|start
parameter_list|,
name|int
name|n
parameter_list|)
else|#
directive|else
function|parchk
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|n
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|,
name|start
decl_stmt|;
name|int
name|n
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* parchk */
block|{
name|CHAR
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"parchk n"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"parchk start"
argument_list|,
literal|""
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|s0
operator|=
name|s
index|[
literal|0
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* Mark field (usually Ctrl-A) */
if|if
condition|(
name|s0
operator|!=
name|start
operator|||
name|n
operator|<
literal|5
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Not a valid packet */
comment|/* Look at packet control fields, which never have 8th bit set */
comment|/* First check for no parity, most common case. */
if|if
condition|(
operator|(
operator|(
name|s
index|[
literal|0
index|]
operator||
name|s
index|[
literal|1
index|]
operator||
name|s
index|[
literal|2
index|]
operator||
name|s
index|[
literal|3
index|]
operator|)
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No parity */
comment|/* Check for mark parity */
if|if
condition|(
operator|(
operator|(
name|s
index|[
literal|0
index|]
operator|&
name|s
index|[
literal|1
index|]
operator|&
name|s
index|[
literal|2
index|]
operator|&
name|s
index|[
literal|3
index|]
operator|)
operator|&
literal|0x80
operator|)
operator|==
literal|0x80
condition|)
return|return
operator|(
literal|'m'
operator|)
return|;
comment|/* Mark parity */
comment|/* Packet has some kind of parity */
comment|/* Make 7-bit copies of control fields */
name|s1
operator|=
name|s
index|[
literal|1
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* LEN */
name|s2
operator|=
name|s
index|[
literal|2
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* SEQ */
name|s3
operator|=
name|s
index|[
literal|3
index|]
operator|&
literal|0x7f
expr_stmt|;
comment|/* TYPE */
comment|/* Check for even parity */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
name|partab
index|[
name|s0
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
name|partab
index|[
name|s1
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
name|partab
index|[
name|s2
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|3
index|]
operator|==
name|partab
index|[
name|s3
index|]
operator|)
condition|)
return|return
operator|(
literal|'e'
operator|)
return|;
comment|/* Check for odd parity */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|!=
name|partab
index|[
name|s0
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|!=
name|partab
index|[
name|s1
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|!=
name|partab
index|[
name|s2
index|]
operator|)
operator|&&
operator|(
name|s
index|[
literal|3
index|]
operator|!=
name|partab
index|[
name|s3
index|]
operator|)
condition|)
return|return
operator|(
literal|'o'
operator|)
return|;
comment|/* Otherwise it's probably line noise.  Let checksum calculation catch it. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* PARSENSE */
comment|/*   Check to make sure timeout intervals are long enough to allow maximum   length packets to get through before the timer goes off. */
name|VOID
name|chktimo
parameter_list|()
block|{
name|int
name|cps
decl_stmt|;
name|long
name|z
decl_stmt|;
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
comment|/* Get latest speed */
if|if
condition|(
name|speed
operator|>
literal|0L
operator|&&
operator|!
name|network
condition|)
block|{
name|cps
operator|=
name|speed
operator|/
literal|10L
expr_stmt|;
if|if
condition|(
name|cps
operator|>
literal|0
condition|)
block|{
name|z
operator|=
operator|(
name|long
operator|)
name|cps
operator|*
operator|(
name|long
operator|)
name|timint
expr_stmt|;
comment|/* Chars per timeout interval */
if|if
condition|(
name|z
operator|<
name|spmax
condition|)
block|{
name|rtimo
operator|=
name|timint
operator|=
name|pkttim
operator|=
operator|(
name|spmax
operator|/
name|cps
operator|)
operator|+
literal|2
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo spmax"
argument_list|,
literal|""
argument_list|,
name|timint
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|<
name|rpsiz
operator|&&
name|rpsiz
operator|>
name|spmax
condition|)
block|{
name|rtimo
operator|=
name|timint
operator|=
name|pkttim
operator|=
operator|(
name|rpsiz
operator|/
name|cps
operator|)
operator|+
literal|2
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"chktimo rpsiz"
argument_list|,
literal|""
argument_list|,
name|timint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*  S P A C K  --  Construct and send a packet  */
comment|/*   spack() sends a packet of the given type, sequence number n, with len data   characters pointed to by d, in either a regular or extended- length packet,   depending on len.  Returns the number of bytes actually sent, or else -1   upon failure.  Uses global npad, padch, mystch, bctu, data.  Leaves packet    fully built and null-terminated for later retransmission by resend().   Updates global sndpktl (send-packet length).    NOTE: The global pointer "data" is assumed to point into the 7th position   of a character array (presumably in packet buffer for the current packet).   It was used by getpkt() to build the packet data field.  spack() fills in   the header to the left of the data pointer (the data pointer is defined   in getsbuf() in ckcfn3.c).  If the address "d" is the same as "data", then   the packet's data field has been built "in place" and need not be copied. */
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|spack
parameter_list|(
name|char
name|pkttyp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|len
parameter_list|,
name|CHAR
modifier|*
name|d
parameter_list|)
else|#
directive|else
function|spack
parameter_list|(
name|pkttyp
parameter_list|,
name|n
parameter_list|,
name|len
parameter_list|,
name|d
parameter_list|)
name|char
name|pkttyp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
name|CHAR
modifier|*
name|d
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* spack */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lp
decl_stmt|,
name|longpkt
decl_stmt|,
name|copy
decl_stmt|;
specifier|register
name|CHAR
modifier|*
name|cp
decl_stmt|,
modifier|*
name|mydata
decl_stmt|;
name|unsigned
name|crc
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"spack n"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" data"
argument_list|,
literal|""
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|" d"
argument_list|,
literal|""
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|copy
operator|=
operator|(
name|d
operator|!=
name|data
operator|)
expr_stmt|;
comment|/* Flag whether data must be copied  */
name|longpkt
operator|=
operator|(
name|len
operator|+
name|bctu
operator|+
literal|2
operator|)
operator|>
literal|94
expr_stmt|;
comment|/* Decide whether it's a long packet */
name|mydata
operator|=
name|data
operator|-
literal|7
operator|+
operator|(
name|longpkt
condition|?
literal|0
else|:
literal|3
operator|)
expr_stmt|;
comment|/* Starting position of header */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" mydata"
argument_list|,
literal|""
argument_list|,
name|mydata
argument_list|)
expr_stmt|;
name|k
operator|=
name|sseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* Packet structure info for pkt n */
name|debug
argument_list|(
name|F101
argument_list|,
literal|" sseqtbl[n]"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"spack sending packet out of window"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Record packet info */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_adr
operator|=
name|mydata
expr_stmt|;
comment|/* Remember address of packet. */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_seq
operator|=
name|n
expr_stmt|;
comment|/* Record sequence number */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|=
name|pkttyp
expr_stmt|;
comment|/* Record packet type */
block|}
name|spktl
operator|=
literal|0
expr_stmt|;
comment|/* Initialize length of this packet */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* and position in packet. */
comment|/* Now fill the packet */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|mystch
expr_stmt|;
comment|/* MARK */
name|lp
operator|=
name|i
operator|++
expr_stmt|;
comment|/* Position of LEN, fill in later */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* SEQ field */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|pkttyp
expr_stmt|;
comment|/* TYPE field */
name|sndtyp
operator|=
name|pkttyp
expr_stmt|;
comment|/* Keep a copy */
name|j
operator|=
name|len
operator|+
name|bctu
expr_stmt|;
comment|/* Length of data + block check */
if|if
condition|(
name|longpkt
condition|)
block|{
comment|/* Long packet? */
name|int
name|x
decl_stmt|;
comment|/* Work around SCO Xenix/286 */
name|x
operator|=
literal|95
expr_stmt|;
comment|/* compiler bug... */
name|x
operator|=
name|j
operator|/
literal|95
expr_stmt|;
name|mydata
index|[
name|lp
index|]
operator|=
name|tochar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes, set LEN to zero */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* High part */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|j
operator|%
literal|95
argument_list|)
expr_stmt|;
comment|/* Low part */
name|mydata
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Header checksum */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|chk1
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|mydata
index|[
name|lp
index|]
operator|=
name|tochar
argument_list|(
name|j
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Normal LEN */
if|if
condition|(
name|copy
condition|)
comment|/* Data field built in place? */
for|for
control|(
init|;
name|len
operator|--
condition|;
name|i
operator|++
control|)
name|mydata
index|[
name|i
index|]
operator|=
operator|*
name|d
operator|++
expr_stmt|;
comment|/* No, must copy. */
else|else
comment|/* Otherwise, */
name|i
operator|+=
name|len
expr_stmt|;
comment|/* Just skip past data field. */
name|mydata
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate for checksum calc. */
switch|switch
condition|(
name|bctu
condition|)
block|{
comment|/* Block check */
case|case
literal|1
case|:
comment|/* 1 = 6-bit chksum */
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|tochar
argument_list|(
name|chk1
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 2 = 12-bit chksum */
name|j
operator|=
name|chk2
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
operator|(
name|j
operator|>>
literal|6
operator|)
operator|&
literal|077
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
name|j
operator|&
literal|077
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 3 = 16-bit CRC */
name|crc
operator|=
name|chk3
argument_list|(
name|mydata
operator|+
name|lp
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
operator|(
operator|(
name|crc
operator|&
literal|0170000
operator|)
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
operator|(
name|crc
operator|>>
literal|6
operator|)
operator|&
literal|077
argument_list|)
expr_stmt|;
name|mydata
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
operator|)
name|tochar
argument_list|(
name|crc
operator|&
literal|077
argument_list|)
expr_stmt|;
break|break;
block|}
name|mydata
index|[
name|i
operator|++
index|]
operator|=
name|seol
expr_stmt|;
comment|/* End of line (packet terminator) */
name|mydata
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate string */
name|logpkt
argument_list|(
literal|'s'
argument_list|,
name|n
argument_list|,
name|mydata
argument_list|)
expr_stmt|;
comment|/* Log packet */
comment|/* (PWP) add the parity quickly at the end */
switch|switch
condition|(
name|parity
condition|)
block|{
case|case
literal|'e'
case|:
comment|/* Even */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator|=
name|partab
index|[
operator|*
name|cp
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Mark */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator||=
literal|128
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Odd */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator|=
name|partab
index|[
operator|*
name|cp
index|]
operator|^
literal|128
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Space */
for|for
control|(
name|cp
operator|=
operator|&
name|mydata
index|[
name|i
operator|-
literal|1
index|]
init|;
name|cp
operator|>=
name|mydata
condition|;
name|cp
operator|--
control|)
operator|*
name|cp
operator|&=
literal|127
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|npad
condition|)
name|ttol
argument_list|(
name|padbuf
argument_list|,
name|npad
argument_list|)
expr_stmt|;
comment|/* Send any padding */
name|spktl
operator|=
name|i
expr_stmt|;
comment|/* Remember packet length */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_len
operator|=
name|spktl
expr_stmt|;
comment|/* also in packet info structure */
if|if
condition|(
name|ttol
argument_list|(
name|mydata
argument_list|,
name|spktl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Send the packet */
name|spackets
operator|++
expr_stmt|;
comment|/* Count it. */
name|flco
operator|+=
name|spktl
expr_stmt|;
comment|/* Count the characters */
name|tlco
operator|+=
name|spktl
expr_stmt|;
comment|/* for statistics... */
name|dumpsbuf
argument_list|()
expr_stmt|;
comment|/* Dump send buffers to debug log */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
name|pkttyp
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mydata
argument_list|)
expr_stmt|;
comment|/* Update screen */
return|return
operator|(
name|spktl
operator|)
return|;
comment|/* Return length */
block|}
comment|/*  C H K 1  --  Compute a type-1 Kermit 6-bit checksum.  */
name|int
name|chk1
parameter_list|(
name|pkt
parameter_list|)
specifier|register
name|CHAR
modifier|*
name|pkt
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|chk
decl_stmt|;
name|chk
operator|=
name|chk2
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|chk
operator|=
operator|(
operator|(
operator|(
name|chk
operator|&
literal|0300
operator|)
operator|>>
literal|6
operator|)
operator|+
name|chk
operator|)
operator|&
literal|077
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|chk
operator|)
return|;
block|}
comment|/*  C H K 2  --  Compute the numeric sum of all the bytes in the packet.  */
name|unsigned
name|int
name|chk2
parameter_list|(
name|pkt
parameter_list|)
specifier|register
name|CHAR
modifier|*
name|pkt
decl_stmt|;
block|{
specifier|register
name|long
name|chk
decl_stmt|;
specifier|register
name|unsigned
name|int
name|m
decl_stmt|;
name|m
operator|=
operator|(
name|parity
operator|)
condition|?
literal|0177
else|:
literal|0377
expr_stmt|;
for|for
control|(
name|chk
operator|=
literal|0
init|;
operator|*
name|pkt
operator|!=
literal|'\0'
condition|;
name|pkt
operator|++
control|)
name|chk
operator|+=
operator|*
name|pkt
operator|&
name|m
expr_stmt|;
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|chk
operator|&
literal|07777
argument_list|)
operator|)
return|;
block|}
comment|/*  C H K 3  --  Compute a type-3 Kermit block check.  */
comment|/*  Calculate the 16-bit CRC-CCITT of a null-terminated string using a lookup   table.  Assumes the argument string contains no embedded nulls. */
name|unsigned
name|int
name|chk3
parameter_list|(
name|pkt
parameter_list|)
specifier|register
name|CHAR
modifier|*
name|pkt
decl_stmt|;
block|{
specifier|register
name|long
name|c
decl_stmt|,
name|crc
decl_stmt|;
specifier|register
name|unsigned
name|int
name|m
decl_stmt|;
name|m
operator|=
operator|(
name|parity
operator|)
condition|?
literal|0177
else|:
literal|0377
expr_stmt|;
for|for
control|(
name|crc
operator|=
literal|0
init|;
operator|*
name|pkt
operator|!=
literal|'\0'
condition|;
name|pkt
operator|++
control|)
block|{
name|c
operator|=
name|crc
operator|^
call|(
name|long
call|)
argument_list|(
operator|*
name|pkt
operator|&
name|m
argument_list|)
expr_stmt|;
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
operator|(
name|crcta
index|[
operator|(
name|c
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
index|]
operator|^
name|crctb
index|[
name|c
operator|&
literal|0x0F
index|]
operator|)
expr_stmt|;
block|}
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|crc
operator|&
literal|0xFFFF
argument_list|)
operator|)
return|;
block|}
name|int
name|nxtpkt
parameter_list|()
block|{
comment|/* Called by file sender */
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt pktnum"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt winlo "
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|pktnum
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
comment|/* Increment packet number mod 64 */
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   Suggested by Alan Grieg.  A packet can be sent out of window in    circumstances involving acks received out of order, ...  Have to think   about this... */
if|if
condition|(
name|chkwin
argument_list|(
name|n
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt n not in window"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|j
operator|=
name|getsbuf
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Get a buffer for packet n */
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt can't getsbuf"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pktnum
operator|=
name|n
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nxtpkt bumped pktnum to"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Functions for sending ACKs and NAKs */
comment|/* Note, we should only ACK the packet at window-low (winlo) */
comment|/* However, if an old packet arrives again (e.g. because the ACK we sent */
comment|/* earlier was lost), we ACK it again. */
name|int
name|ack
parameter_list|()
block|{
comment|/* Acknowledge the current packet. */
return|return
operator|(
name|ackns
argument_list|(
name|winlo
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
operator|)
return|;
block|}
name|int
name|ackns
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|int
name|n
decl_stmt|;
name|CHAR
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Acknowledge packet n */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"ackns"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|k
operator|=
name|rseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* First find received packet n. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns k"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/* No need to set ACK'd bit, because we're gonna free the buffer now */
if|if
condition|(
name|k
operator|>
operator|-
literal|1
condition|)
comment|/* If in window */
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_flg
operator|++
expr_stmt|;
comment|/* mark the ack'd bit. */
else|else
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns can't set ack'd bit"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freesbuf
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Free current send-buffer, if any */
if|if
condition|(
operator|(
name|j
operator|=
name|getsbuf
argument_list|(
name|n
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* This can happen if we have to re-ACK an old packet that has */
comment|/* already left the window.  It does no harm. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns can't getsbuf"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|spack
argument_list|(
literal|'Y'
argument_list|,
name|n
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Now send it. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns winlo"
argument_list|,
literal|""
argument_list|,
name|winlo
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ackns n"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|winlo
condition|)
block|{
comment|/* If we're acking winlo */
if|if
condition|(
name|k
operator|>
operator|-
literal|1
condition|)
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|/* don't need it any more */
if|if
condition|(
name|j
operator|>
operator|-
literal|1
condition|)
name|freesbuf
argument_list|(
name|j
argument_list|)
expr_stmt|;
comment|/* and don't need to keep ACK either */
name|winlo
operator|=
operator|(
name|winlo
operator|+
literal|1
operator|)
operator|%
literal|64
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|ackn
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* Send ACK for packet number n */
return|return
operator|(
name|ackns
argument_list|(
name|n
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
operator|)
return|;
block|}
name|int
name|ack1
parameter_list|(
name|s
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Send an ACK with data. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"ack1"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ackns
argument_list|(
name|winlo
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
comment|/* N A C K  --   Send a Negative ACKnowledgment. */
comment|/*  Call with the packet number, n, to be NAK'd.  Returns -1 if that packet has been NAK'd too many times, otherwise 0.  Btw, it is not right to return 0 under error conditions.  This is  done because the -1 code is used for cancelling the file transfer.  More work is needed here. */
name|int
name|nack
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|63
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nack bad pkt num"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nack"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|sseqtbl
index|[
name|n
index|]
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* If necessary */
if|if
condition|(
name|getsbuf
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* get a buffer for this NAK */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nack can't getsbuf"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|i
operator|=
name|sseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* New slot number */
block|}
if|if
condition|(
name|s_pkt
index|[
name|i
index|]
operator|.
name|pk_rtr
operator|++
operator|>
name|maxtry
condition|)
comment|/* How many times have we done this? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Too many... */
comment|/* Note, don't free this buffer.  Eventually an ACK will come, and that */
comment|/* will set it free.  If not, well, it's back to ground zero anyway...  */
name|spack
argument_list|(
literal|'N'
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
comment|/* NAKs never have data. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * (PWP) recalculate the optimal packet length in the face of errors.  * This is a modified version of the algorithm by John Chandler in Kermit/370,   * see "Dynamic Packet Size Control", Kermit News, V2 #1, June 1988.  *  * This implementation minimizes the total overhead equation, which is  *  *   Total chars = file_chars + (header_len * num_packs)  *                            + (errors * (header_len + packet_len))  *  * Differentiate with respect to number of chars, solve for packet_len, get:  *  *   packet_len = sqrt (file_chars * header_len / errors)  */
comment|/*  (FDC) New super-simple algorithm.  If there was an error in the most recent  packet exchange, cut the send-packet size in half, down to a minimum of 20.  If there was no error, increase the size by 5/4, up to the maximum negotiated  length.  Seems to be much more responsive than previous algorithm, which took  forever to recover the original packet length, and it also went crazy under  certain conditions.   Here's another idea for packet length resizing that keeps a history of the  last n packets.  Push a 1 into the left end of an n-bit shift register if the  current packet is good, otherwise push a zero.  The current n-bit value, w, of  this register is a weighted sum of the noise hits for the last n packets, with  the most recent weighing the most.  The current packet length is some function  of w and the negotiated packet length, like:     (2^n - 1 - w) / (2^n - 1) * (negotiated length)   If the present resizing method causes problems, think about this one a little  more. */
name|VOID
name|rcalcpsz
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|COMMENT
comment|/* Old way */
specifier|register
name|long
name|x
decl_stmt|,
name|q
decl_stmt|;
if|if
condition|(
name|numerrs
operator|==
literal|0
condition|)
return|return;
comment|/* bounds check just in case */
comment|/* overhead on a data packet is npad+5+bctr, plus 3 if extended packet */
comment|/* an ACK is 5+bctr */
comment|/* first set x = per packet overhead */
if|if
condition|(
name|wslots
operator|>
literal|1
condition|)
name|x
operator|=
call|(
name|long
call|)
argument_list|(
name|npad
operator|+
literal|5
operator|+
name|bctr
argument_list|)
expr_stmt|;
comment|/* only the packet, don't count the ack */
else|else
name|x
operator|=
call|(
name|long
call|)
argument_list|(
name|npad
operator|+
literal|5
operator|+
literal|3
operator|+
name|bctr
operator|+
literal|5
operator|+
name|bctr
argument_list|)
expr_stmt|;
comment|/* then set x = packet length ** 2 */
name|x
operator|=
name|x
operator|*
operator|(
name|ffc
operator|/
operator|(
name|long
operator|)
name|numerrs
operator|)
expr_stmt|;
comment|/* careful of overflow */
comment|/* calculate the long integer sqrt(x) quickly */
name|q
operator|=
literal|500
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
name|q
operator|=
operator|(
name|q
operator|+
name|x
operator|/
name|q
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* should converge in about 4 steps */
if|if
condition|(
operator|(
name|q
operator|>
literal|94
operator|)
operator|&&
operator|(
name|q
operator|<
literal|130
operator|)
condition|)
comment|/* break-even point for long packets */
name|q
operator|=
literal|94
expr_stmt|;
if|if
condition|(
name|q
operator|>
name|spmax
condition|)
name|q
operator|=
name|spmax
expr_stmt|;
comment|/* maximum bounds */
if|if
condition|(
name|q
operator|<
literal|10
condition|)
name|q
operator|=
literal|10
expr_stmt|;
comment|/* minimum bounds */
name|spsiz
operator|=
name|q
expr_stmt|;
comment|/* set new send packet size */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz"
argument_list|,
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* New way */
if|if
condition|(
name|spackets
operator|<
literal|3
condition|)
return|return;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz numerrs"
argument_list|,
literal|""
argument_list|,
name|numerrs
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz spsiz"
argument_list|,
literal|""
argument_list|,
name|spsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|numerrs
condition|)
name|spsiz
operator|=
name|spsiz
operator|/
literal|2
expr_stmt|;
else|else
name|spsiz
operator|=
operator|(
name|spsiz
operator|/
literal|4
operator|)
operator|*
literal|5
expr_stmt|;
if|if
condition|(
name|spsiz
operator|<
literal|20
condition|)
name|spsiz
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|spsiz
operator|>
name|spmax
condition|)
name|spsiz
operator|=
name|spmax
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rcalcpsiz new spsiz"
argument_list|,
literal|""
argument_list|,
name|spsiz
argument_list|)
expr_stmt|;
name|numerrs
operator|=
literal|0
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
comment|/*  R E S E N D  --  Retransmit packet n.  */
comment|/* Returns 0 or positive on success. */
comment|/* On failure, returns a negative number, and an error message is placed */
comment|/* in recpkt.  All errors are considered fatal.  */
ifdef|#
directive|ifdef
name|IOFATAL
undef|#
directive|undef
name|IOFATAL
endif|#
directive|endif
comment|/*   Let's try something new...  I/O errors are not fatal.  Let retry mechanisms   take care of giving up (edit 159). */
name|int
name|resend
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
comment|/* Send packet n again. */
name|int
name|k
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"resend seq"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|chkwin
argument_list|(
name|n
argument_list|,
name|winlo
argument_list|,
name|wslots
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Check if it's in the window */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"resend pkt not in win"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|nakstate
operator|&&
name|k
operator|==
literal|1
condition|)
block|{
comment|/* Take a chance... */
ifdef|#
directive|ifdef
name|IOFATAL
if|if
condition|(
name|spack
argument_list|(
literal|'Y'
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Send an ACK... */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"resend spack fails"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"resend i/o error: SPF, n=%d, k=%d."
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"resent ACK from prev window ok"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|spack
argument_list|(
literal|'Y'
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
comment|/* Just send the ACK... */
endif|#
directive|endif
comment|/* IOFATAL */
name|retrans
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"resend pkt not in window"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"resend error: NIW, n=%d, k=%d."
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
name|k
operator|=
name|sseqtbl
index|[
name|n
index|]
expr_stmt|;
comment|/* OK, it's in the window. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"resend pktinfo index"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
comment|/* But I can't find it! */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"resend sseqtbl failure for pkt"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"resend logic error: BPX, n=%d, k=%d."
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
operator|++
operator|>
name|maxtry
condition|)
block|{
comment|/* Found it but over retry limit */
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"Too many retries."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|" retry"
argument_list|,
literal|""
argument_list|,
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
argument_list|)
expr_stmt|;
comment|/* OK so far */
name|dumpsbuf
argument_list|()
expr_stmt|;
if|if
condition|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|==
literal|' '
condition|)
block|{
comment|/* Incompletely formed packet */
if|if
condition|(
name|nakstate
condition|)
block|{
comment|/* (This shouldn't happen any more) */
name|nack
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|retrans
operator|++
expr_stmt|;
return|return
operator|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
operator|)
return|;
block|}
else|else
block|{
comment|/* No packet to resend! */
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"resend logic error: NPS, n=%d, k=%d."
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|IOFATAL
if|if
condition|(
name|ttol
argument_list|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_adr
argument_list|,
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"resend ttol failed"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recpkt
argument_list|,
literal|"resend i/o error: TIO, n=%d, k=%d."
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|#
directive|else
name|ttol
argument_list|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_adr
argument_list|,
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IOFATAL */
name|retrans
operator|++
expr_stmt|;
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'%'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
literal|"(resend)"
argument_list|)
expr_stmt|;
comment|/* Say resend occurred */
name|logpkt
argument_list|(
literal|'S'
argument_list|,
name|n
argument_list|,
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_adr
argument_list|)
expr_stmt|;
comment|/* Log packet */
return|return
operator|(
name|s_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
operator|)
return|;
comment|/* Return retries. */
block|}
name|int
name|errpkt
parameter_list|(
name|reason
parameter_list|)
name|CHAR
modifier|*
name|reason
decl_stmt|;
block|{
comment|/* Send an error packet. */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|encstr
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|y
operator|=
name|spack
argument_list|(
literal|'E'
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
name|encbuf
operator|+
literal|7
argument_list|)
expr_stmt|;
name|x
operator|=
name|quiet
expr_stmt|;
name|quiet
operator|=
literal|1
expr_stmt|;
comment|/* Close files silently. */
name|clsif
argument_list|()
expr_stmt|;
name|clsof
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|quiet
operator|=
name|x
expr_stmt|;
name|screen
argument_list|(
name|SCR_TC
argument_list|,
literal|0
argument_list|,
literal|0l
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|<
name|W_CONNECT
condition|)
name|xitsta
operator||=
name|what
expr_stmt|;
comment|/* Remember what failed. */
name|success
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
comment|/* scmd()  --  Send a packet of the given type */
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|scmd
parameter_list|(
name|char
name|t
parameter_list|,
name|CHAR
modifier|*
name|dat
parameter_list|)
else|#
directive|else
function|scmd
parameter_list|(
name|t
parameter_list|,
name|dat
parameter_list|)
name|char
name|t
decl_stmt|;
name|CHAR
modifier|*
name|dat
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* scmd */
block|{
name|encstr
argument_list|(
name|dat
argument_list|)
expr_stmt|;
comment|/* Encode the command string */
name|spack
argument_list|(
name|t
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
operator|(
name|encbuf
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VOID
name|srinit
parameter_list|()
block|{
comment|/* Send R (GET) packet */
name|encstr
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
name|cmarg
argument_list|)
expr_stmt|;
comment|/* Encode the filename. */
name|spack
argument_list|(
literal|'R'
argument_list|,
name|pktnum
argument_list|,
name|size
argument_list|,
name|encbuf
operator|+
literal|7
argument_list|)
expr_stmt|;
comment|/* Send the packet. */
block|}
comment|/* R P A C K  --  Read a Packet */
comment|/*  rpack reads a packet and returns the packet type, or else Q if the  packet was invalid, or T if a timeout occurred.  Upon successful return, sets  the values of global rsn (received sequence number),  rln (received  data length), and rdatap (pointer to null-terminated data field). */
name|int
name|rpack
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|lp
decl_stmt|;
comment|/* Local variables */
name|int
name|k
decl_stmt|,
name|type
decl_stmt|,
name|chklen
decl_stmt|;
name|unsigned
name|crc
decl_stmt|;
name|CHAR
name|pbc
index|[
literal|4
index|]
decl_stmt|;
comment|/* Packet block check */
name|CHAR
modifier|*
name|sohp
decl_stmt|;
comment|/* Pointer to SOH */
name|CHAR
name|e
decl_stmt|;
comment|/* Packet end character */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"entering rpack, pktnum"
argument_list|,
literal|""
argument_list|,
name|pktnum
argument_list|)
expr_stmt|;
name|k
operator|=
name|getrbuf
argument_list|()
expr_stmt|;
comment|/* Get a new packet input buffer. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack getrbuf"
argument_list|,
literal|""
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Return like this if none free. */
name|recpkt
operator|=
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_adr
expr_stmt|;
operator|*
name|recpkt
operator|=
literal|'\0'
expr_stmt|;
comment|/* Clear receive buffer. */
name|sohp
operator|=
name|recpkt
expr_stmt|;
comment|/* Initialize pointers to it. */
name|rdatap
operator|=
name|recpkt
expr_stmt|;
name|rsn
operator|=
name|rln
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* In case of failure. */
name|e
operator|=
operator|(
name|turn
operator|)
condition|?
name|turnch
else|:
name|eol
expr_stmt|;
comment|/* Use any handshake char for eol */
comment|/* Try to get a "line". */
ifdef|#
directive|ifdef
name|PARSENSE
ifdef|#
directive|ifdef
name|UNIX
comment|/*   So far the final turn argument is only ckutio.c.  Should be added   to the others too. */
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|,
name|stchr
argument_list|,
name|turn
argument_list|)
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|,
name|stchr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|parity
operator|!=
name|ttprty
condition|)
name|autopar
operator|=
literal|1
expr_stmt|;
name|parity
operator|=
name|ttprty
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|ttinl
argument_list|(
name|recpkt
argument_list|,
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
operator|-
literal|1
argument_list|,
name|timint
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack: ttinl fails"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* Otherwise, */
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|/* Free this buffer */
if|if
condition|(
name|j
operator|<
operator|-
literal|1
condition|)
block|{
comment|/* Bail out if ^C^C typed. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack ^C server"
argument_list|,
literal|""
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack ^C en_fin"
argument_list|,
literal|""
argument_list|,
name|en_fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
comment|/* But not if in server mode */
elseif|else
if|if
condition|(
name|en_fin
condition|)
return|return
operator|(
name|j
operator|)
return|;
comment|/* with DISABLE FINISH */
block|}
if|if
condition|(
name|nakstate
condition|)
comment|/* call it a timeout. */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'T'
argument_list|,
operator|(
name|long
operator|)
name|winlo
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|screen
argument_list|(
name|SCR_PT
argument_list|,
literal|'T'
argument_list|,
operator|(
name|long
operator|)
name|pktnum
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<timeout>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow
operator|==
literal|1
condition|)
name|ttoc
argument_list|(
name|XON
argument_list|)
expr_stmt|;
comment|/* In case of Xoff blockage. */
return|return
operator|(
literal|'T'
operator|)
return|;
block|}
name|tlci
operator|+=
name|j
expr_stmt|;
comment|/* All OK, Count the characters. */
name|flci
operator|+=
name|j
expr_stmt|;
ifndef|#
directive|ifndef
name|PARSENSE
comment|/* THEN eliminate this loop... */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|recpkt
index|[
name|i
index|]
operator|!=
name|stchr
operator|)
operator|&&
operator|(
name|i
operator|<
name|j
operator|)
condition|;
name|i
operator|++
control|)
name|sohp
operator|++
expr_stmt|;
comment|/* Find mark */
if|if
condition|(
name|i
operator|++
operator|>=
name|j
condition|)
block|{
comment|/* Didn't find it. */
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
literal|"<timeout>"
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'T'
operator|)
return|;
block|}
else|#
directive|else
name|i
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* PARSENSE */
name|rpackets
operator|++
expr_stmt|;
name|lp
operator|=
name|i
expr_stmt|;
comment|/* Remember LEN position. */
if|if
condition|(
operator|(
name|j
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|i
operator|++
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|lp
operator|+
literal|5
operator|)
operator|>
name|MAXRP
condition|)
return|return
operator|(
literal|'Q'
operator|)
return|;
comment|/* Long packet */
name|x
operator|=
name|recpkt
index|[
name|j
index|]
expr_stmt|;
comment|/* Header checksum. */
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Calculate& compare. */
if|if
condition|(
name|xunchar
argument_list|(
name|x
argument_list|)
operator|!=
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:hdr>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
name|recpkt
index|[
name|j
index|]
operator|=
name|x
expr_stmt|;
comment|/* Checksum ok, put it back. */
name|rln
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|j
operator|-
literal|2
index|]
argument_list|)
operator|*
literal|95
operator|+
name|xunchar
argument_list|(
name|recpkt
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|-
name|bctu
expr_stmt|;
name|j
operator|=
literal|3
expr_stmt|;
comment|/* Data offset. */
block|}
elseif|else
if|if
condition|(
name|j
operator|<
literal|3
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack packet length less than 3"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:len>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
else|else
block|{
name|rln
operator|=
name|j
operator|-
name|bctu
operator|-
literal|2
expr_stmt|;
comment|/* Regular packet */
name|j
operator|=
literal|0
expr_stmt|;
comment|/* No extended header */
block|}
name|rsn
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* Sequence number */
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
name|sohp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsn
operator|<
literal|0
operator|||
name|rsn
operator|>
literal|63
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack bad sequence number"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:seq>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
name|type
operator|=
name|recpkt
index|[
name|i
operator|++
index|]
expr_stmt|;
comment|/* Packet type */
define|#
directive|define
name|XXX
ifdef|#
directive|ifdef
name|XXX
comment|/*     Heuristics to adjust for old block-check type on retransmitted packet     after block check has switched. */
if|if
condition|(
name|type
operator|==
literal|'I'
operator|||
name|type
operator|==
literal|'S'
condition|)
block|{
comment|/* These always have type 1 */
name|chklen
operator|=
literal|1
expr_stmt|;
name|rln
operator|=
name|rln
operator|+
name|bctu
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|'N'
condition|)
block|{
comment|/* NAK never has data */
name|chklen
operator|=
name|xunchar
argument_list|(
name|recpkt
index|[
name|lp
index|]
argument_list|)
operator|-
literal|2
expr_stmt|;
name|rln
operator|=
name|rln
operator|+
name|bctu
operator|-
name|chklen
expr_stmt|;
block|}
else|else
name|chklen
operator|=
name|bctu
expr_stmt|;
else|#
directive|else
name|chklen
operator|=
name|bctu
expr_stmt|;
endif|#
directive|endif
comment|/* XXX */
name|i
operator|+=
name|j
expr_stmt|;
comment|/* Where data begins */
name|rdatap
operator|=
name|recpkt
operator|+
name|i
expr_stmt|;
comment|/* The data itself */
if|if
condition|(
operator|(
name|j
operator|=
name|rln
operator|+
name|i
operator|)
operator|>
name|r_pkt
index|[
name|k
index|]
operator|.
name|bf_len
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"packet sticks out too far"
argument_list|,
literal|""
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<overflow>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|chklen
condition|;
name|x
operator|++
control|)
comment|/* Copy out the block check */
name|pbc
index|[
name|x
index|]
operator|=
name|recpkt
index|[
name|j
operator|+
name|x
index|]
expr_stmt|;
name|pbc
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate block check string */
name|recpkt
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*  and the packet data. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack chklen"
argument_list|,
literal|""
argument_list|,
name|chklen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chklen
condition|)
block|{
comment|/* Check the block check */
case|case
literal|1
case|:
if|if
condition|(
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
operator|!=
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|F110
argument_list|,
literal|"checked chars"
argument_list|,
name|recpkt
operator|+
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"block check"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"should be"
argument_list|,
literal|""
argument_list|,
name|chk1
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chk1>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
case|case
literal|2
case|:
name|x
operator|=
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
operator|<<
literal|6
operator||
name|xunchar
argument_list|(
name|pbc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|chk2
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|F110
argument_list|,
literal|"checked chars"
argument_list|,
name|recpkt
operator|+
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"block check"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"should be"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|chk2
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chk2>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
case|case
literal|3
case|:
name|crc
operator|=
operator|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|xunchar
argument_list|(
name|pbc
index|[
literal|2
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
name|chk3
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|F110
argument_list|,
literal|"checked chars"
argument_list|,
name|recpkt
operator|+
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"block check"
argument_list|,
literal|""
argument_list|,
name|xunchar
argument_list|(
operator|*
name|pbc
argument_list|)
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"should be"
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|chk3
argument_list|(
name|recpkt
operator|+
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chk3>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
break|break;
default|default:
comment|/* Shouldn't happen... */
name|freerbuf
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<crunched:chkx>"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'Q'
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack block check OK"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
comment|/* Now we can believe the sequence number, etc. */
comment|/* Here we violate strict principles of layering, etc, and look at the  */
comment|/* packet sequence number.  If there's already a packet with the same   */
comment|/* number in the window, we remove this one so that the window will not */
comment|/* fill up. */
if|if
condition|(
operator|(
name|x
operator|=
name|rseqtbl
index|[
name|rsn
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Already a packet with this number */
name|retrans
operator|++
expr_stmt|;
comment|/* Count it for statistics */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"rpack got dup"
argument_list|,
literal|""
argument_list|,
name|rsn
argument_list|)
expr_stmt|;
name|logpkt
argument_list|(
literal|'r'
argument_list|,
name|rsn
argument_list|,
operator|(
name|CHAR
operator|*
operator|)
literal|"<duplicate>"
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Free old buffer, keep new packet. */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_rtr
operator|++
expr_stmt|;
comment|/* Count this as a retransmission. */
block|}
comment|/* New packet, not seen before, enter it into the "database". */
name|rseqtbl
index|[
name|rsn
index|]
operator|=
name|k
expr_stmt|;
comment|/* Make back pointer */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_seq
operator|=
name|rsn
expr_stmt|;
comment|/* Record in packet info structure */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_typ
operator|=
name|type
expr_stmt|;
comment|/* Sequence, type,... */
name|r_pkt
index|[
name|k
index|]
operator|.
name|pk_adr
operator|=
name|rdatap
expr_stmt|;
comment|/* pointer to data buffer */
name|screen
argument_list|(
name|SCR_PT
argument_list|,
operator|(
name|char
operator|)
name|type
argument_list|,
operator|(
name|long
operator|)
name|rsn
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sohp
argument_list|)
expr_stmt|;
comment|/* Update screen */
return|return
operator|(
name|type
operator|)
return|;
comment|/* Return packet type */
block|}
comment|/*  L O G P K T  --  Log packet number n, pointed to by s.  */
comment|/* c = 's' (send) or 'r' (receive) */
name|VOID
ifdef|#
directive|ifdef
name|CK_ANSIC
name|logpkt
parameter_list|(
name|char
name|c
parameter_list|,
name|int
name|n
parameter_list|,
name|CHAR
modifier|*
name|s
parameter_list|)
else|#
directive|else
function|logpkt
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
name|CHAR
modifier|*
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* logpkt */
block|{
name|char
name|plog
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|pktlog
operator|&&
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|plog
argument_list|,
literal|"%c-xx-%02d-"
argument_list|,
name|c
argument_list|,
operator|(
name|gtimer
argument_list|()
operator|%
literal|60
operator|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|plog
argument_list|,
literal|"%c-%02d-%02d-"
argument_list|,
name|c
argument_list|,
name|n
argument_list|,
operator|(
name|gtimer
argument_list|()
operator|%
literal|60
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsout
argument_list|(
name|ZPFILE
argument_list|,
name|plog
argument_list|)
operator|<
literal|0
condition|)
name|pktlog
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|zsoutl
argument_list|(
name|ZPFILE
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
operator|<
literal|0
condition|)
name|pktlog
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TLOG
comment|/*  T S T A T S  --  Record statistics in transaction log  */
name|VOID
name|tstats
parameter_list|()
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|ztime
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
comment|/* Get time stamp */
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"End of transaction"
argument_list|,
name|tp
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* Record it */
if|if
condition|(
name|filcnt
operator|<
literal|1
condition|)
return|return;
comment|/* If no files, done. */
comment|/* If multiple files, record character totals for all files */
if|if
condition|(
name|filcnt
operator|>
literal|1
condition|)
block|{
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" files"
argument_list|,
literal|""
argument_list|,
name|filcnt
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" total file characters   "
argument_list|,
literal|""
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" communication line in   "
argument_list|,
literal|""
argument_list|,
name|tlci
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" communication line out  "
argument_list|,
literal|""
argument_list|,
name|tlco
argument_list|)
expr_stmt|;
block|}
comment|/* Record timing info for one or more files */
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" elapsed time (seconds)  "
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|tsecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsecs
operator|>
literal|0
condition|)
block|{
name|long
name|lx
decl_stmt|;
name|lx
operator|=
operator|(
name|tfc
operator|*
literal|10L
operator|)
operator|/
operator|(
name|long
operator|)
name|tsecs
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" effective data rate     "
argument_list|,
literal|""
argument_list|,
name|lx
operator|/
literal|10L
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<=
literal|0L
condition|)
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|0L
operator|&&
name|speed
operator|!=
literal|8880L
operator|&&
name|network
operator|==
literal|0
condition|)
block|{
name|lx
operator|=
operator|(
name|lx
operator|*
literal|100L
operator|)
operator|/
name|speed
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|" efficiency (percent)    "
argument_list|,
literal|""
argument_list|,
name|lx
argument_list|)
expr_stmt|;
block|}
block|}
name|tlog
argument_list|(
name|F100
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* Leave a blank line */
block|}
comment|/*  F S T A T S  --  Record file statistics in transaction log  */
name|VOID
name|fstats
parameter_list|()
block|{
name|tfc
operator|+=
name|ffc
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|" end of file"
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"  file characters        "
argument_list|,
literal|""
argument_list|,
name|ffc
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"  communication line in  "
argument_list|,
literal|""
argument_list|,
name|flci
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"  communication line out "
argument_list|,
literal|""
argument_list|,
name|flco
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* NOTLOG */
name|VOID
name|tstats
parameter_list|()
block|{}
name|VOID
name|fstats
parameter_list|()
block|{
name|tfc
operator|+=
name|ffc
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TLOG */
end_comment

end_unit

