begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|char
modifier|*
name|cknetv
init|=
literal|"Network support, 5A(008) 8 Feb 91"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  C K C N E T  --  Network support  */
end_comment

begin_comment
comment|/*   Authors:    Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),     Columbia University Center for Computing Activities.   netopen() routine for TCP/IP originally by Ken Yap, Rochester University     (ken@cs.rochester.edu) (no longer at that address).   SunLink X.25 support by Marcello Frutig, Catholic University,     Rio de Janeiro, Brazil (FRUTIG@BRLNCC.BITNET).   Missing pieces for Excelan sockets library from William Bader, Moravian     College<bader@moravian.edu>.   telnet protocol support by Frank da Cruz.   TGV MultiNet code by Frank da Cruz.   Other contributions as indicated below.    Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_comment
comment|/* Don't need these if there is no network support. */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ZILOG
end_ifndef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<setret.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZILOG */
end_comment

begin_function_decl
specifier|extern
name|SIGTYP
function_decl|(
modifier|*
name|saval
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* For saving alarm handler */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|duplex
decl_stmt|,
name|debses
decl_stmt|,
name|seslog
decl_stmt|,
name|ttyfd
decl_stmt|,
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External variables */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4
end_ifdef

begin_comment
comment|/*   These suggested by Rob Healey, rhealey@kas.helios.mn.org, to avoid   bugs in Berkeley compatibility library on Sys V R4 systems, but untested   by me (fdc).  Remove this bit if it gives you trouble.   (Later corrected by Marc Boucher<mboucher@iro.umontreal.ca> because   bzero/bcopy are not argument-compatible with memset/memcpy|memmove.) */
end_comment

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset(s,0,n)
end_define

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|h
parameter_list|,
name|a
parameter_list|,
name|l
parameter_list|)
value|memmove(a,h,l)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|PTX
end_ifdef

begin_comment
comment|/* Sequent DYNYX PTX 1.3 */
end_comment

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset(s,0,n)
end_define

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|h
parameter_list|,
name|a
parameter_list|,
name|l
parameter_list|)
value|memmove(a,h,l)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PTX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4 */
end_comment

begin_define
define|#
directive|define
name|NAMECPYL
value|100
end_define

begin_comment
comment|/* Local copy of hostname */
end_comment

begin_decl_stmt
specifier|static
name|char
name|namecopy
index|[
name|NAMECPYL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ipaddr
index|[
literal|20
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global copy of IP address */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MULTINET
end_ifdef

begin_comment
comment|/*   General global variables, but so far used only by MultiNet.   Kept within #ifdef MULTINET..#endif to keep strict compilers (and lint)   from complaining about unused variables. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|njbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For timeout longjumps */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTINET */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_decl_stmt
name|int
name|ttnet
init|=
name|NET_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Network type */
end_comment

begin_decl_stmt
name|int
name|ttnproto
init|=
name|NP_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Network virtual terminal protocol */
end_comment

begin_decl_stmt
name|int
name|tn_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Telnet protocol initialized flag */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NETCONN
end_ifndef

begin_comment
comment|/*   Network support not defined.     Dummy functions here in case #ifdef's forgotten elsewhere. */
end_comment

begin_function
name|int
comment|/* Open network connection */
name|netopen
parameter_list|(
name|name
parameter_list|,
name|lcl
parameter_list|,
name|nett
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|lcl
decl_stmt|,
name|nett
decl_stmt|;
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* Close network connection */
name|netclos
parameter_list|()
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* Check network input buffer */
name|nettchk
parameter_list|()
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* Flush network input buffer */
name|netflui
parameter_list|()
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* Send network BREAK */
name|netbreak
parameter_list|()
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
comment|/* Input character from network */
name|netinc
parameter_list|(
name|timo
parameter_list|)
name|int
name|timo
decl_stmt|;
block|{ }
end_function

begin_function
name|int
comment|/* Output character to network */
ifdef|#
directive|ifdef
name|CK_ANSIC
name|nettoc
parameter_list|(
name|char
name|c
parameter_list|)
else|#
directive|else
function|nettoc
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* nettoc */
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nettol
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NETCONN is defined (rest of this module...) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MULTINET
end_ifdef

begin_comment
comment|/* For buffered network reads... */
end_comment

begin_comment
comment|/*   If the buffering code is written right, it shouldn't matter how long this   buffer is -- it could even be shorter than a Kermit packet. */
end_comment

begin_define
define|#
directive|define
name|TTIBUFL
value|8192
end_define

begin_comment
comment|/* Maybe 8K?... */
end_comment

begin_decl_stmt
specifier|static
name|CHAR
name|ttibuf
index|[
name|TTIBUFL
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ttibp
init|=
literal|0
decl_stmt|,
name|ttibn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Read bytes from network into internal buffer ttibuf[].   To be called when input buffer is empty, i.e. when ttibn == 0.    Other network reading routines, like ttinc, ttinl, ttxin, should check the   internal buffer first, and call this routine for a refill if necessary.    Returns -1 on error, 0 if nothing happens.  When data is read successfully,   returns number of bytes read, and sets global ttibn to that number and   ttibp (the buffer pointer) to zero. */
end_comment

begin_function
name|int
name|ttbufr
parameter_list|()
block|{
comment|/* TT Buffer Read */
name|int
name|x
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|ttnet
operator|!=
name|NET_TCPB
condition|)
block|{
comment|/* First make sure current net is */
comment|/* Fill in support for DECnet, etc, here */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* TCP/IP; if not, do nothing. */
block|}
else|else
block|{
comment|/* Read as much as there us, up to our buffer size. */
name|count
operator|=
name|nettchk
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|count
operator|>
name|TTIBUFL
condition|)
name|count
operator|=
name|TTIBUFL
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ttbufr count"
argument_list|,
literal|""
argument_list|,
name|count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/*  This is for nonblocking reads, which we don't do any more.  This code didn't  work anyway, in the sense that a broken connection was never sensed. */
if|if
condition|(
operator|(
name|count
operator|=
name|socket_read
argument_list|(
name|ttyfd
argument_list|,
name|ttibuf
argument_list|,
name|count
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|count
operator|==
operator|-
literal|1
operator|&&
name|socket_errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"ttbufr finds nothing"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F100
argument_list|,
literal|"ttbufr socket eof"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ttbufr socket_read error"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|#
directive|else
comment|/* This is for blocking reads */
if|if
condition|(
operator|(
name|count
operator|=
name|socket_read
argument_list|(
name|ttyfd
argument_list|,
name|ttibuf
argument_list|,
name|count
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ttbufr socket_read"
argument_list|,
literal|""
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ttbufr socket_errno"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ttbufr"
argument_list|,
literal|""
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Got some bytes. */
name|ttibp
operator|=
literal|0
expr_stmt|;
comment|/* Reset buffer pointer. */
return|return
operator|(
name|ttibn
operator|=
name|count
operator|)
return|;
comment|/* Set and return buffer count. */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTINET */
end_comment

begin_comment
comment|/*   C-Kermit network open/close functions for BSD-sockets.   Much of this code shared by SunLink X.25, which also uses the socket library. */
end_comment

begin_comment
comment|/*  N E T O P E N  --  Open a network connection.  */
end_comment

begin_comment
comment|/*  Returns 0 on success, -1 on failure.  */
end_comment

begin_define
define|#
directive|define
name|TELNET_PORT
value|23
end_define

begin_comment
comment|/* Should do lookup, but it won't change */
end_comment

begin_comment
comment|/* This symbol is not known to, e.g., Ultrix 2.0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TELOPT_TTYPE
end_ifndef

begin_define
define|#
directive|define
name|TELOPT_TTYPE
value|24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TELOPT_TTYPE */
end_comment

begin_comment
comment|/*  N E T O P N  --  Open a network connection.  */
end_comment

begin_comment
comment|/*   Call with:     name of host (or host:service),     lcl - local-mode flag to be set if this function succeeds,     network type - value defined in ckunet.h. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCELAN
end_ifdef

begin_comment
comment|/*   Most other BSD sockets implementations define these in header files   and libraries. */
end_comment

begin_struct
struct|struct
name|servent
block|{
name|unsigned
name|short
name|s_port
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hostent
block|{
name|short
name|h_addrtype
decl_stmt|;
name|struct
name|in_addr
name|h_addr
decl_stmt|;
name|int
name|h_length
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|servent
modifier|*
name|getservbyname
parameter_list|(
name|service
parameter_list|,
name|connection
parameter_list|)
name|char
modifier|*
name|service
decl_stmt|,
decl|*
name|connection
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|struct
name|servent
name|servrec
decl_stmt|;
name|int
name|port
decl_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"telnet"
argument_list|)
operator|==
literal|0
condition|)
name|port
operator|=
literal|23
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"smtp"
argument_list|)
operator|==
literal|0
condition|)
name|port
operator|=
literal|25
expr_stmt|;
else|else
name|port
operator|=
name|atoi
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"getservbyname return port "
argument_list|,
literal|""
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|>
literal|0
condition|)
block|{
name|servrec
operator|.
name|s_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|servrec
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|servent
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|hostent
modifier|*
name|gethostbyname
parameter_list|(
name|hostname
parameter_list|)
name|char
modifier|*
name|hostname
decl_stmt|;
block|{
return|return
operator|(
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|inet_addr
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|addr
operator|=
name|rhost
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"inet_addr "
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|inet_ntoa
parameter_list|(
name|in
parameter_list|)
name|struct
name|in_addr
name|in
decl_stmt|;
block|{
specifier|static
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|in
operator|.
name|s_net
argument_list|,
name|in
operator|.
name|s_host
argument_list|,
name|in
operator|.
name|s_lh
argument_list|,
name|in
operator|.
name|s_impno
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCELAN */
end_comment

begin_comment
comment|/*  N E T O P E N  --  Open a network connection  */
end_comment

begin_comment
comment|/*   Calling conventions same as ttopen(), except third argument is network   type rather than modem type.  Designed to be called from within ttopen. */
end_comment

begin_function
name|int
name|netopen
parameter_list|(
name|name
parameter_list|,
name|lcl
parameter_list|,
name|nett
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|lcl
decl_stmt|,
name|nett
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|servent
modifier|*
name|service
decl_stmt|,
name|servrec
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|;
name|struct
name|sockaddr_in
name|saddr
decl_stmt|;
ifdef|#
directive|ifdef
name|EXCELAN
name|struct
name|sockaddr_in
name|send_socket
decl_stmt|;
endif|#
directive|endif
comment|/* EXCELAN */
ifdef|#
directive|ifdef
name|SUNX25
comment|/* Code for SunLink X.25 support */
define|#
directive|define
name|X29PID
value|1
comment|/* X.29 Protocol ID */
name|VOID
name|x25oobh
parameter_list|()
function_decl|;
name|CONN_DB
name|x25host
decl_stmt|;
name|FACILITY_DB
name|x25facil
decl_stmt|;
specifier|static
name|int
name|needh
init|=
literal|1
decl_stmt|;
name|PID_T
name|pid
decl_stmt|;
specifier|extern
name|int
name|linkid
decl_stmt|,
name|lcn
decl_stmt|,
name|x25ver
decl_stmt|;
specifier|extern
name|int
name|revcall
decl_stmt|,
name|closgr
decl_stmt|,
name|cudata
decl_stmt|;
specifier|extern
name|char
name|udata
index|[
name|MAXCUDATA
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* SUNX25 */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen nett"
argument_list|,
literal|""
argument_list|,
name|nett
argument_list|)
expr_stmt|;
operator|*
name|ipaddr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Initialize IP address string */
ifdef|#
directive|ifdef
name|SUNX25
if|if
condition|(
name|nett
operator|==
name|NET_SX25
condition|)
block|{
comment|/* If network type is X.25 */
name|netclos
argument_list|()
expr_stmt|;
comment|/* Close any previous net connection */
name|ttnproto
operator|=
name|NP_NONE
expr_stmt|;
comment|/* No protocol selected yet */
comment|/* Set up host structure */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|x25host
argument_list|,
sizeof|sizeof
argument_list|(
name|x25host
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x25host
operator|.
name|hostlen
operator|=
name|pkx121
argument_list|(
name|name
argument_list|,
name|x25host
operator|.
name|host
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid X.121 host address %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|x25host
operator|.
name|datalen
operator|=
name|X29PIDLEN
expr_stmt|;
name|x25host
operator|.
name|data
index|[
literal|0
index|]
operator|=
name|X29PID
expr_stmt|;
comment|/* Set call user data if specified */
if|if
condition|(
name|cudata
condition|)
block|{
name|strncpy
argument_list|(
name|x25host
operator|.
name|data
operator|+
name|X29PIDLEN
argument_list|,
name|udata
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|udata
argument_list|)
argument_list|)
expr_stmt|;
name|x25host
operator|.
name|datalen
operator|+=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|udata
argument_list|)
expr_stmt|;
block|}
comment|/* Open SunLink X.25 socket */
if|if
condition|(
operator|(
name|ttyfd
operator|=
name|socket
argument_list|(
name|AF_X25
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen socket error"
argument_list|,
literal|""
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"X.25 connect socket error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Setting X.25 out-of-band data handler */
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|SIOCSPGRP
argument_list|,
operator|&
name|pid
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Setting process group id"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|VOID
operator|)
name|signal
argument_list|(
name|SIGURG
argument_list|,
name|x25oobh
argument_list|)
expr_stmt|;
comment|/* Set reverse charge call and closed user group if requested */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|x25facil
argument_list|,
sizeof|sizeof
argument_list|(
name|x25facil
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revcall
condition|)
name|x25facil
operator|.
name|reverse_charge
operator|=
name|revcall
expr_stmt|;
if|if
condition|(
name|closgr
operator|>
operator|-
literal|1
condition|)
block|{
name|x25facil
operator|.
name|cug_req
operator|=
literal|1
expr_stmt|;
name|x25facil
operator|.
name|cug_index
operator|=
name|closgr
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_WR_FACILITY
argument_list|,
operator|&
name|x25facil
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Setting X.25 facilities"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  Need X.25 header with bits Q and M */
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_HEADER
argument_list|,
operator|&
name|needh
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Setting X.25 header"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Connects to remote host via SunLink X.25 */
if|if
condition|(
name|connect
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|x25host
argument_list|,
sizeof|sizeof
argument_list|(
name|x25host
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen connect errno"
argument_list|,
literal|""
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|i
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"netopen"
argument_list|)
expr_stmt|;
name|x25diag
argument_list|()
expr_stmt|;
block|}
operator|(
name|VOID
operator|)
name|close
argument_list|(
name|ttyfd
argument_list|)
expr_stmt|;
name|ttyfd
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|i
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Get X.25 link identification used for the connection */
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_GET_LINK
argument_list|,
operator|&
name|linkid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Getting X.25 link id"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Get X.25 logical channel number used for the connection */
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_RD_LCGN
argument_list|,
operator|&
name|lcn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Getting X.25 lcn"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Get SunLink X.25 version */
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_VERSION
argument_list|,
operator|&
name|x25ver
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Getting SunLink X.25 version"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ttnet
operator|=
name|nett
expr_stmt|;
comment|/* Sunlink X.25 network */
name|ttnproto
operator|=
name|NP_X3
expr_stmt|;
comment|/* PAD X.3, X.28, X.29 protocol */
if|if
condition|(
operator|*
name|lcl
operator|<
literal|0
condition|)
operator|*
name|lcl
operator|=
literal|1
expr_stmt|;
comment|/* Local mode */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
comment|/* Note that SUNX25 support can coexist with TCP/IP support. */
endif|#
directive|endif
comment|/* SUNX25 */
comment|/*   Add support for other networks here. */
if|if
condition|(
name|nett
operator|!=
name|NET_TCPB
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* BSD socket support */
name|netclos
argument_list|()
expr_stmt|;
comment|/* Close any previous connection. */
name|strncpy
argument_list|(
name|namecopy
argument_list|,
name|name
argument_list|,
name|NAMECPYL
argument_list|)
expr_stmt|;
comment|/* Copy the hostname. */
name|ttnproto
operator|=
name|NP_NONE
expr_stmt|;
comment|/* No protocol selected yet. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"netopen namecopy"
argument_list|,
name|namecopy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|namecopy
expr_stmt|;
comment|/* Was a service requested? */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Look for colon */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* Have a colon */
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get service name or number */
block|}
else|else
block|{
comment|/* Otherwise use telnet */
name|p
operator|=
literal|"telnet"
expr_stmt|;
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"netopen service requested"
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* Use socket number without lookup */
name|service
operator|=
operator|&
name|servrec
expr_stmt|;
name|service
operator|->
name|s_port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise lookup the service name */
name|service
operator|=
name|getservbyname
argument_list|(
name|p
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|service
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find port for service %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTINET
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen can't get service"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen can't get service"
argument_list|,
literal|""
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTINET */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* rather than mislead */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set up socket structure and get host address */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|host
operator|=
name|gethostbyname
argument_list|(
name|namecopy
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|saddr
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|host
operator|->
name|h_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|saddr
operator|.
name|sin_addr
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INADDRX
comment|/* inet_addr() is of type struct in_addr */
name|struct
name|in_addr
name|ina
decl_stmt|;
name|unsigned
name|long
name|uu
decl_stmt|;
name|ina
operator|=
name|inet_addr
argument_list|(
name|namecopy
argument_list|)
expr_stmt|;
name|uu
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|ina
expr_stmt|;
else|#
directive|else
comment|/* inet_addr() is unsigned long */
name|unsigned
name|long
name|uu
decl_stmt|;
name|uu
operator|=
name|inet_addr
argument_list|(
name|namecopy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INADDRX */
if|if
condition|(
operator|(
name|saddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|uu
operator|)
operator|!=
operator|(
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
operator|)
condition|)
name|saddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get address for %s\n"
argument_list|,
name|namecopy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTINET
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen can't get address"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen can't get address"
argument_list|,
literal|""
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTINET */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* rather than mislead */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* Get a file descriptor for the connection. */
name|saddr
operator|.
name|sin_port
operator|=
name|service
operator|->
name|s_port
expr_stmt|;
name|sprintf
argument_list|(
name|ipaddr
argument_list|,
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|saddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|*
name|ipaddr
condition|)
name|printf
argument_list|(
literal|" Trying %s...\n"
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXCELAN
name|send_socket
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|send_socket
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|send_socket
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ttyfd
operator|=
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
operator|(
expr|struct
name|sockproto
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|send_socket
argument_list|,
name|SO_REUSEADDR
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|ttyfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* EXCELAN */
block|{
ifdef|#
directive|ifdef
name|EXCELAN
name|experror
argument_list|(
literal|"TCP socket error"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MULTINET
name|socket_perror
argument_list|(
literal|"TCP socket error"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen socket error"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|perror
argument_list|(
literal|"TCP socket error"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen socket error"
argument_list|,
literal|""
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTINET */
endif|#
directive|endif
comment|/* EXCELAN */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Now connect to the socket on the other end. */
ifdef|#
directive|ifdef
name|EXCELAN
if|if
condition|(
name|connect
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|saddr
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|connect
argument_list|(
name|ttyfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* EXCELAN */
block|{
name|i
operator|=
name|errno
expr_stmt|;
comment|/* save error code */
name|close
argument_list|(
name|ttyfd
argument_list|)
expr_stmt|;
name|ttyfd
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|i
expr_stmt|;
comment|/* and report this error */
ifdef|#
directive|ifdef
name|EXCELAN
if|if
condition|(
name|errno
condition|)
name|experror
argument_list|(
literal|"netopen connect"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MULTINET
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen connect error"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|socket_perror
argument_list|(
literal|"netopen connect"
argument_list|)
expr_stmt|;
else|#
directive|else
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen connect errno"
argument_list|,
literal|""
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTINET */
endif|#
directive|endif
comment|/* EXCELAN */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SO_OOBINLINE
name|setsockopt
argument_list|(
name|ttyfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OOBINLINE
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
expr_stmt|;
comment|/* (void) */
comment|/* the symbol SO_OOBINLINE is not known to Ultrix 2.0 */
comment|/* it means "leave out of band data inline" */
comment|/* normal value is 0x0100 */
comment|/* better not to try this on systems where the symbol is undefined. */
endif|#
directive|endif
comment|/* SO_OOBINLINE */
comment|/* See if the service is TELNET. */
if|if
condition|(
operator|(
name|x
operator|=
name|ntohs
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|service
operator|->
name|s_port
argument_list|)
operator|)
operator|==
name|TELNET_PORT
condition|)
name|ttnproto
operator|=
name|NP_TELNET
expr_stmt|;
comment|/* Yes, set global flag. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netopen service"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ttnet
operator|=
name|nett
expr_stmt|;
comment|/* TCP/IP (sockets) network */
name|tn_init
operator|=
literal|0
expr_stmt|;
comment|/* Telnet protocol not init'd yet */
if|if
condition|(
operator|*
name|lcl
operator|<
literal|0
condition|)
operator|*
name|lcl
operator|=
literal|1
expr_stmt|;
comment|/* Local mode. */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Done. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  N E T C L O S  --  Close current network connection.  */
end_comment

begin_function
name|int
name|netclos
parameter_list|()
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ttyfd
operator|<
literal|0
condition|)
comment|/* Was open? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Wasn't. */
if|if
condition|(
name|ttyfd
operator|>
operator|-
literal|1
condition|)
comment|/* Was. */
ifdef|#
directive|ifdef
name|MULTINET
name|x
operator|=
name|socket_close
argument_list|(
name|ttyfd
argument_list|)
expr_stmt|;
comment|/* Close it. */
else|#
directive|else
name|x
operator|=
name|close
argument_list|(
name|ttyfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTINET */
name|ttyfd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark it as closed. */
name|tn_init
operator|=
literal|0
expr_stmt|;
comment|/* Remember about telnet protocol... */
operator|*
name|ipaddr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zero the IP address string */
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  N E T T C H K  --  Check if network up, and how many bytes can be read */
end_comment

begin_comment
comment|/*   Returns number of bytes waiting, or -1 if connection has been dropped. */
end_comment

begin_function
name|int
comment|/* Check how many bytes are ready */
name|nettchk
parameter_list|()
block|{
comment|/* for reading from network */
ifdef|#
directive|ifdef
name|MULTINET
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|char
name|c
decl_stmt|;
name|socket_errno
operator|=
literal|0
expr_stmt|;
comment|/*   Note: this socket_ioctl() call does NOT return an error if the   connection has been broken. */
if|if
condition|(
name|socket_ioctl
argument_list|(
name|ttyfd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|count
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nettchk socket_ioctl error"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttibn
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|ttibn
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/*   Here we need to tell the difference between a 0 count on an active   connection, and a 0 count because the remote end of the socket broke   the connection.  There is no mechanism in TGV MultiNet to query the   status of the connection, so we have to do a read.  -1 means there was   no data available (socket_errno == EWOULDBLOCK), 0 means the connection   is down.  But if, by chance, we actually get a character, we have to   put it where it won't be lost. */
name|y
operator|=
literal|1
expr_stmt|;
comment|/* Turn on nonblocking reads */
name|socket_ioctl
argument_list|(
name|ttyfd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|socket_read
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Returns -1 if no data */
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Turn them back off */
name|socket_ioctl
argument_list|(
name|ttyfd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Connection is broken. */
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
comment|/* Oops, actually got a byte? */
name|ttibuf
index|[
name|ttibp
operator|+
name|ttibn
index|]
operator|=
name|c
expr_stmt|;
name|ttibn
operator|++
expr_stmt|;
comment|/* Add it to the buffer. */
block|}
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nettchk count"
argument_list|,
literal|""
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|+
name|ttibn
operator|)
return|;
block|}
else|#
directive|else
comment|/*   Note, for regular UNIX TCP/IP connections, might be able to use the   same technique as for MultiNet.  But as yet there is no need for it. */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* MULTINET */
block|}
end_function

begin_comment
comment|/*  N E T T I N C --  Input character from network */
end_comment

begin_function
name|int
name|netinc
parameter_list|(
name|timo
parameter_list|)
name|int
name|timo
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MULTINET
name|int
name|x
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* The locals. */
if|if
condition|(
name|ttibn
operator|>
literal|0
condition|)
block|{
comment|/* Something in internal buffer? */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"netinc char in buf"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes. */
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Success. */
block|}
else|else
block|{
comment|/* Else must read from network. */
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Assume failure. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netinc goes to net, timo"
argument_list|,
literal|""
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
operator|<=
literal|0
condition|)
block|{
comment|/* Untimed case. */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Wait forever if necessary. */
if|if
condition|(
name|ttbufr
argument_list|()
operator|<
literal|0
condition|)
comment|/* Refill buffer. */
break|break;
comment|/* Error, fail. */
if|if
condition|(
name|ttibn
operator|>
literal|0
condition|)
block|{
comment|/* Success. */
name|x
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Timed case... */
name|saval
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|ttimoff
argument_list|)
expr_stmt|;
comment|/* Enable timer interrupt */
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
comment|/* for requested interval. */
if|if
condition|(
name|setjmp
argument_list|(
name|njbuf
argument_list|)
condition|)
block|{
comment|/* Timer went off? */
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Yes, fail. */
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ttbufr
argument_list|()
operator|<
literal|0
condition|)
comment|/* Keep trying to refill it. */
break|break;
comment|/* Till we get an error. */
if|if
condition|(
name|ttibn
operator|>
literal|0
condition|)
block|{
comment|/* Or we get a character. */
name|x
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ttimoff
argument_list|()
expr_stmt|;
comment|/* Timer off. */
block|}
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Return -1 if we failed. */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"netinc timed out"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Otherwise */
name|ttibn
operator|--
expr_stmt|;
comment|/* Return what we got. */
name|c
operator|=
name|ttibuf
index|[
name|ttibp
operator|++
index|]
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"netinc returning"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|)
return|;
block|}
else|#
directive|else
comment|/* Not MULTINET */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* MULTINET */
block|}
end_function

begin_comment
comment|/*  N E T T O L  --  Output a string of bytes to the network  */
end_comment

begin_comment
comment|/*   Call with s = pointer to string, n = length.   Returns number of bytes actuall written on success, or   -1 on i/o error, -2 if called improperly. */
end_comment

begin_function
name|int
name|nettol
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MULTINET
name|int
name|count
decl_stmt|;
if|if
condition|(
name|ttnet
operator|==
name|NET_TCPB
condition|)
block|{
if|if
condition|(
operator|(
name|count
operator|=
name|socket_write
argument_list|(
name|ttyfd
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nettol socket_write error"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"nettol socket_write"
argument_list|,
name|s
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
comment|/* MULTINET */
block|}
end_function

begin_comment
comment|/*  N E T T O C  --   Output character to network */
end_comment

begin_comment
comment|/*   Call with character to be transmitted.   Returns 0 if transmission was successful, or   -1 upon i/o error, or -2 if called improperly. */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|nettoc
parameter_list|(
name|char
name|c
parameter_list|)
else|#
directive|else
function|nettoc
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* nettoc */
block|{
ifdef|#
directive|ifdef
name|MULTINET
name|unsigned
name|char
name|cc
decl_stmt|;
name|cc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|ttnet
operator|==
name|NET_TCPB
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nettoc cc"
argument_list|,
literal|""
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket_write
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
operator|<
literal|1
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nettoc socket_write error"
argument_list|,
literal|""
argument_list|,
name|socket_errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"nettoc socket_write"
argument_list|,
literal|""
argument_list|,
name|cc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
comment|/* MULTINET */
block|}
end_function

begin_comment
comment|/*  N E T F L U I  --  Flush network input buffer  */
end_comment

begin_function
name|int
name|netflui
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|nettchk
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MULTINET
name|char
name|c
decl_stmt|;
if|if
condition|(
name|ttnet
operator|==
name|NET_TCPB
condition|)
while|while
condition|(
operator|(
name|n
operator|--
operator|)
operator|&&
name|socket_read
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|>
literal|1
condition|)
empty_stmt|;
endif|#
directive|endif
comment|/* MULTINET */
block|}
ifdef|#
directive|ifdef
name|MULTINET
name|ttibn
operator|=
name|ttibp
operator|=
literal|0
expr_stmt|;
comment|/* Also flush internal buffer. */
endif|#
directive|endif
comment|/* MULTINET */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TNCODE
end_ifdef

begin_comment
comment|/* Compile in telnet support code */
end_comment

begin_comment
comment|/* TCP/IP Telnet negotiation support code */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sgaflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* telnet SGA flag */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wttflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* telnet terminal type flag */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TELCMDS
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|telcmds
index|[]
init|=
block|{
literal|"SE"
block|,
literal|"NOP"
block|,
literal|"DMARK"
block|,
literal|"BRK"
block|,
literal|"IP"
block|,
literal|"AO"
block|,
literal|"AYT"
block|,
literal|"EC"
block|,
literal|"EL"
block|,
literal|"GA"
block|,
literal|"SB"
block|,
literal|"WILL"
block|,
literal|"WONT"
block|,
literal|"DO"
block|,
literal|"DONT"
block|,
literal|"IAC"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TELCMDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TELOPTS
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|telopts
index|[]
init|=
block|{
literal|"BINARY"
block|,
literal|"ECHO"
block|,
literal|"RCP"
block|,
literal|"SUPPRESS GO AHEAD"
block|,
literal|"NAME"
block|,
literal|"STATUS"
block|,
literal|"TIMING MARK"
block|,
literal|"RCTE"
block|,
literal|"NAOL"
block|,
literal|"NAOP"
block|,
literal|"NAOCRD"
block|,
literal|"NAOHTS"
block|,
literal|"NAOHTD"
block|,
literal|"NAOFFD"
block|,
literal|"NAOVTS"
block|,
literal|"NAOVTD"
block|,
literal|"NAOLFD"
block|,
literal|"EXTEND ASCII"
block|,
literal|"LOGOUT"
block|,
literal|"BYTE MACRO"
block|,
literal|"DATA ENTRY TERMINAL"
block|,
literal|"SUPDUP"
block|,
literal|"SUPDUP OUTPUT"
block|,
literal|"SEND LOCATION"
block|,
literal|"TERMINAL TYPE"
block|,
literal|"END OF RECORD"
ifdef|#
directive|ifdef
name|TELOPT_TUID
block|,
literal|"TACACS UID"
ifdef|#
directive|ifdef
name|TELOPT_OUTMRK
block|,
literal|"OUTPUT MARKING"
ifdef|#
directive|ifdef
name|TELOPT_TTYLOC
block|,
literal|"TTYLOC"
ifdef|#
directive|ifdef
name|TELOPT_3270REGIME
block|,
literal|"3270 REGIME"
ifdef|#
directive|ifdef
name|TELOPT_X3PAD
block|,
literal|"X.3 PAD"
ifdef|#
directive|ifdef
name|TELOPT_NAWS
block|,
literal|"NAWS"
ifdef|#
directive|ifdef
name|TELOPT_TSPEED
block|,
literal|"TSPEED"
ifdef|#
directive|ifdef
name|TELOPT_LFLOW
block|,
literal|"LFLOW"
ifdef|#
directive|ifdef
name|TELOPT_LINEMODE
block|,
literal|"LINEMODE"
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TELOPTS */
end_comment

begin_decl_stmt
name|int
name|ntelopts
init|=
sizeof|sizeof
argument_list|(
name|telopts
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TNCODE */
end_comment

begin_comment
comment|/* Send network BREAK */
end_comment

begin_comment
comment|/*   Returns -1 on error, 0 if nothing happens, 1 if BREAK sent successfully. */
end_comment

begin_function
name|int
name|netbreak
parameter_list|()
block|{
if|if
condition|(
name|ttnet
operator|==
name|NET_TCPB
condition|)
block|{
if|if
condition|(
name|ttnproto
operator|==
name|NP_TELNET
condition|)
block|{
ifdef|#
directive|ifdef
name|TNCODE
if|if
condition|(
name|ttoc
argument_list|(
name|IAC
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ttoc
argument_list|(
name|BREAK
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"telnet BREAK ok"
argument_list|,
literal|""
argument_list|,
name|BREAK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|debug
argument_list|(
name|F100
argument_list|,
literal|"netbreak no TNCODE"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* TNCODE */
block|}
comment|/* Insert other TCP/IP protocols here */
block|}
comment|/* Insert other networks here */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Send a telnet option, avoid loops. */
end_comment

begin_comment
comment|/* Returns 1 if command was sent, 0 if not, -1 on error */
end_comment

begin_function
name|int
name|tn_sopt
parameter_list|(
name|cmd
parameter_list|,
name|opt
parameter_list|)
name|int
name|cmd
decl_stmt|,
name|opt
decl_stmt|;
block|{
comment|/* TELNET SEND OPTION */
if|if
condition|(
name|ttnet
operator|!=
name|NET_TCPB
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Must be TCP/IP */
if|if
condition|(
name|ttnproto
operator|!=
name|NP_TELNET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Must be telnet protocol */
ifdef|#
directive|ifdef
name|TNCODE
if|if
condition|(
name|ttoc
argument_list|(
name|IAC
argument_list|)
operator|<
literal|0
condition|)
comment|/* Send Interpret As Command (IAC) */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ttoc
argument_list|(
name|cmd
argument_list|)
operator|<
literal|0
condition|)
comment|/* Command (WILL, WONT, DO, DONT) */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ttoc
argument_list|(
name|opt
argument_list|)
operator|<
literal|0
condition|)
comment|/* Option */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"telnet cmd>"
argument_list|,
name|telcmds
index|[
name|cmd
operator|-
name|SE
index|]
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"telnet opt>"
argument_list|,
operator|(
name|opt
operator|<
name|ntelopts
operator|)
condition|?
name|telopts
index|[
name|opt
index|]
else|:
literal|"UNKNOWN"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debses
operator|&&
name|cmd
operator|!=
name|SB
condition|)
name|printf
argument_list|(
literal|"[%s %s]"
argument_list|,
name|telcmds
index|[
name|cmd
operator|-
name|SE
index|]
argument_list|,
operator|(
name|opt
operator|<
name|ntelopts
operator|)
condition|?
name|telopts
index|[
name|opt
index|]
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|debug
argument_list|(
name|F100
argument_list|,
literal|"tn_sopt no TNCODE"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* TNCODE */
block|}
end_function

begin_comment
comment|/* Initialize a telnet connection. */
end_comment

begin_comment
comment|/* Returns -1 on error, 0 if nothing happens, 1 if init msgs sent ok */
end_comment

begin_function
name|int
name|tn_ini
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|TNCODE
name|debug
argument_list|(
name|F100
argument_list|,
literal|"tn_ini no TNCODE"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* TELNET protocol support */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"tn_ini ttnproto"
argument_list|,
literal|""
argument_list|,
name|ttnproto
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"tn_ini tn_init"
argument_list|,
literal|""
argument_list|,
name|tn_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttnet
operator|!=
name|NET_TCPB
condition|)
comment|/* Make sure connection is TCP/IP. */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tn_init
condition|)
comment|/* Have we done this already? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Don't do it again. */
name|duplex
operator|=
literal|1
expr_stmt|;
comment|/* Assume local echo. */
name|sgaflg
operator|=
literal|0
expr_stmt|;
comment|/* Assume Go-Ahead suppressed. */
name|wttflg
operator|=
literal|0
expr_stmt|;
comment|/* Did not send WILL TERM TYPE yet. */
if|if
condition|(
name|ttnproto
operator|==
name|NP_NONE
condition|)
block|{
comment|/* If not talking to a telnet port, */
name|ttnproto
operator|=
name|NP_TELNET
expr_stmt|;
comment|/* pretend it's telnet anyway, */
name|tn_init
operator|=
literal|1
expr_stmt|;
comment|/* but don't send initial options. */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"tn_ini skipping telnet negotiations"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Talking to telnet port, so send WILL TERMINAL TYPE and DO SGA */
if|if
condition|(
name|tn_sopt
argument_list|(
name|WILL
argument_list|,
name|TELOPT_TTYPE
argument_list|)
operator|<
literal|0
condition|)
comment|/* Will send terminal type. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wttflg
operator|=
literal|1
expr_stmt|;
comment|/* Remember I said I would. */
if|if
condition|(
name|tn_sopt
argument_list|(
name|DO
argument_list|,
name|TELOPT_SGA
argument_list|)
operator|<
literal|0
condition|)
comment|/* Please suppress go-ahead. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|COMMENT
if|if
condition|(
name|tn_sopt
argument_list|(
name|DO
argument_list|,
name|TELOPT_ECHO
argument_list|)
operator|<
literal|0
condition|)
comment|/* Ask the server to echo, since */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* I'm assuming it will. */
endif|#
directive|endif
comment|/* COMMENT */
name|tn_init
operator|=
literal|1
expr_stmt|;
comment|/* Set telnet-initialized flag. */
comment|/* Don't send anthing else! */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"tn_ini duplex"
argument_list|,
literal|""
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* TNCODE */
block|}
end_function

begin_comment
comment|/*   Process in-band Telnet negotiation characters from the remote host.   Call with the telnet IAC character and the current duplex setting   (0 = remote echo, 1 = local echo).   Returns:     3 if server has sent us a quoted IAC     2 if local echo must be changed to remote     1 if remote echo must be changed to local     0 if nothing happens or no action necessary    -1 on failure (= internal or i/o error) */
end_comment

begin_define
define|#
directive|define
name|TSBUFSIZ
value|41
end_define

begin_decl_stmt
name|char
name|sb
index|[
name|TSBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for subnegotiations */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
comment|/* TELNET DO OPTION */
name|tn_doop
parameter_list|(
name|CHAR
name|z
parameter_list|,
name|int
name|echo
parameter_list|)
else|#
directive|else
function|tn_doop
parameter_list|(
name|z
parameter_list|,
name|echo
parameter_list|)
name|CHAR
name|z
decl_stmt|;
name|int
name|echo
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* tn_doop */
block|{
name|int
name|c
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|e
decl_stmt|,
name|n
decl_stmt|,
name|flag
decl_stmt|;
ifndef|#
directive|ifndef
name|TNCODE
name|debug
argument_list|(
name|F100
argument_list|,
literal|"tn_doop no TNCODE"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|z
operator|!=
name|IAC
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"tn_doop bad call"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ttnet
operator|!=
name|NET_TCPB
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ttnproto
operator|!=
name|NP_TELNET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check protocol */
comment|/*   This is a weakness.  Because this module uses ttinc(), it prevents any   code that uses this routine from using any kind of buffering strategy.   Also, there's no reason why this module should have to know anything about   the session log.  It would be better to pass a character input function as   an argument to this routine -- that function could worry about buffering,   logging, etc. */
comment|/* Have IAC, read command character. */
name|c
operator|=
name|ttinc
argument_list|(
literal|0
argument_list|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Read command character */
if|if
condition|(
name|seslog
condition|)
block|{
comment|/* Copy to session log, if any. */
if|if
condition|(
name|zchout
argument_list|(
name|ZSFILE
argument_list|,
name|z
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
comment|/* Log the IAC. */
elseif|else
if|if
condition|(
name|zchout
argument_list|(
name|ZSFILE
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
comment|/* Log the command. */
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"telnet cmd<"
argument_list|,
name|telcmds
index|[
name|c
operator|-
name|SE
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Debug log. */
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
return|return
operator|(
literal|3
operator|)
return|;
comment|/* Quoted IAC */
if|if
condition|(
name|c
operator|<
name|SB
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Other command with no arguments. */
comment|/* SB, WILL, WONT, DO, or DONT need more bytes... */
if|if
condition|(
operator|(
name|x
operator|=
name|ttinc
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Get the option. */
name|x
operator|&=
literal|0xff
expr_stmt|;
comment|/* Trim to 8 bits. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"telnet opt<"
argument_list|,
operator|(
name|x
operator|<
name|ntelopts
operator|)
condition|?
name|telopts
index|[
name|x
index|]
else|:
literal|"UNKNOWN"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|seslog
condition|)
comment|/* Session log */
if|if
condition|(
name|zchout
argument_list|(
name|ZSFILE
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
comment|/* Now handle the command */
if|if
condition|(
name|debses
operator|&&
name|c
operator|!=
name|SB
condition|)
comment|/* Debug to screen. */
name|printf
argument_list|(
literal|"<%s %s>"
argument_list|,
name|telcmds
index|[
name|c
operator|-
name|SE
index|]
argument_list|,
operator|(
name|x
operator|<
name|ntelopts
operator|)
condition|?
name|telopts
index|[
name|x
index|]
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
comment|/* ECHO negotiation. */
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Command */
case|case
name|WILL
case|:
comment|/* Host says it will echo. */
if|if
condition|(
name|echo
condition|)
comment|/* Only reply if change required. */
return|return
operator|(
operator|(
name|tn_sopt
argument_list|(
name|DO
argument_list|,
name|x
argument_list|)
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|2
operator|)
return|;
comment|/* Please do. */
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Otherwise no change. */
case|case
name|WONT
case|:
comment|/* Host says it won't echo. */
if|if
condition|(
operator|!
name|echo
condition|)
comment|/* If I'm full duplex */
return|return
operator|(
operator|(
name|tn_sopt
argument_list|(
name|DONT
argument_list|,
name|x
argument_list|)
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
comment|/* Switch to half */
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Otherwise, no change.  */
case|case
name|DO
case|:
comment|/* Host wants me to echo */
if|if
condition|(
name|tn_sopt
argument_list|(
name|WONT
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
comment|/* but the client never echoes */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* back to the server. */
default|default:
comment|/* Don't reply to anything else */
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TELOPT_SGA
case|:
comment|/* Suppress Go-Ahead */
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Command... */
case|case
name|WONT
case|:
comment|/* Host says it won't. */
if|if
condition|(
operator|!
name|sgaflg
condition|)
block|{
name|sgaflg
operator|=
literal|1
expr_stmt|;
comment|/* Remember. */
if|if
condition|(
name|tn_sopt
argument_list|(
name|DONT
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
comment|/* acknowledge, */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|echo
condition|?
literal|0
else|:
literal|1
operator|)
return|;
comment|/* Switch to half duplex */
case|case
name|WILL
case|:
comment|/* Server says it will SGA */
if|if
condition|(
name|sgaflg
condition|)
block|{
comment|/* ACK only if necessary */
if|if
condition|(
name|tn_sopt
argument_list|(
name|DO
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sgaflg
operator|=
literal|0
expr_stmt|;
comment|/* Remember new SGA state. */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* But don't change echo state. */
block|}
ifdef|#
directive|ifdef
name|TELOPT_TTYPE
case|case
name|TELOPT_TTYPE
case|:
comment|/* Terminal Type */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|DO
case|:
comment|/* DO terminal type. */
if|if
condition|(
name|wttflg
operator|==
literal|0
condition|)
block|{
comment|/* If I haven't said so before, */
if|if
condition|(
name|tn_sopt
argument_list|(
name|WILL
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
comment|/* say I'll send it if asked. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wttflg
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SB
case|:
name|debug
argument_list|(
name|F100
argument_list|,
literal|"telnet subnegotiation:"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* Flag for when done reading SB */
while|while
condition|(
name|n
operator|<
name|TSBUFSIZ
condition|)
block|{
comment|/* Loop looking for IAC SE */
if|if
condition|(
operator|(
name|y
operator|=
name|ttinc
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|y
operator|&=
literal|0xff
expr_stmt|;
comment|/* Make sure it's just 8 bits. */
name|sb
index|[
name|n
operator|++
index|]
operator|=
name|y
expr_stmt|;
comment|/* Save what we got in buffer. */
if|if
condition|(
name|seslog
condition|)
comment|/* Log it if logging. */
if|if
condition|(
name|zchout
argument_list|(
name|ZSFILE
argument_list|,
name|y
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|IAC
condition|)
block|{
comment|/* If this is an IAC */
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* set the flag. */
block|}
else|else
block|{
comment|/* Otherwise, */
if|if
condition|(
name|flag
operator|&&
name|y
operator|==
name|SE
condition|)
comment|/* if this is SE which immediately */
break|break;
comment|/* follows IAC, we're done. */
else|else
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* Otherwise turn off flag. */
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"telnet subopt<"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Make sure we got a valid SB */
if|if
condition|(
name|debses
condition|)
block|{
comment|/* Debug to screen. */
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"<SB %s "
argument_list|,
name|telopts
index|[
name|TELOPT_TTYPE
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|sb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" IAC SE>"
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"telnet suboption"
argument_list|,
literal|""
argument_list|,
name|sb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
comment|/* SEND terminal type? */
if|if
condition|(
name|tn_sttyp
argument_list|()
operator|<
literal|0
condition|)
comment|/* Yes, so send it. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
default|default:
comment|/* Others, ignore */
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* TELOPT_TTYPE */
default|default:
comment|/* All others: refuse */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|WILL
case|:
comment|/* You will? */
if|if
condition|(
name|tn_sopt
argument_list|(
name|DONT
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
comment|/* Please don't. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|DO
case|:
comment|/* You want me to? */
if|if
condition|(
name|tn_sopt
argument_list|(
name|WONT
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
comment|/* I won't. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|DONT
case|:
comment|/* You don't want me to? */
if|if
condition|(
name|tn_sopt
argument_list|(
name|WONT
argument_list|,
name|x
argument_list|)
operator|<
literal|0
condition|)
comment|/* I won't. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|WONT
case|:
comment|/* You won't? */
break|break;
comment|/* Good. */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* TNCODE */
block|}
end_function

begin_comment
comment|/* Telnet send terminal type */
end_comment

begin_comment
comment|/* Returns -1 on error, 0 if nothing happens, 1 if type sent successfully */
end_comment

begin_function
name|int
name|tn_sttyp
parameter_list|()
block|{
comment|/* Send telnet terminal type. */
ifndef|#
directive|ifndef
name|TNCODE
name|debug
argument_list|(
name|F100
argument_list|,
literal|"tn_sttyp no TNCODE"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|char
modifier|*
name|ttn
decl_stmt|;
name|int
name|ttl
decl_stmt|;
comment|/* Name& length of terminal type. */
if|if
condition|(
name|ttnet
operator|!=
name|NET_TCPB
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ttnproto
operator|!=
name|NP_TELNET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ttn
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
comment|/* Get it from the environment. */
if|if
condition|(
operator|(
name|ttn
operator|==
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|ttl
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ttn
argument_list|)
operator|)
operator|>=
name|TSBUFSIZ
operator|)
condition|)
block|{
name|ttn
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|ttl
operator|=
literal|7
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|sb
argument_list|,
name|ttn
argument_list|)
expr_stmt|;
comment|/* Copy to subnegotiation buffer */
name|ttn
operator|=
name|sb
expr_stmt|;
comment|/* Point back to beginning */
if|if
condition|(
name|tn_sopt
argument_list|(
name|SB
argument_list|,
name|TELOPT_TTYPE
argument_list|)
operator|<
literal|0
condition|)
comment|/* Send: Terminal Type */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ttoc
argument_list|(
operator|(
name|char
operator|)
literal|0
argument_list|)
condition|)
comment|/* IS... */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|ttn
condition|)
block|{
comment|/* name of terminal */
if|if
condition|(
name|islower
argument_list|(
operator|*
name|ttn
argument_list|)
condition|)
operator|*
name|ttn
operator|=
name|toupper
argument_list|(
operator|*
name|ttn
argument_list|)
expr_stmt|;
comment|/* converted to uppercase. */
name|ttoc
argument_list|(
operator|*
name|ttn
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttoc
argument_list|(
name|IAC
argument_list|)
operator|<
literal|0
condition|)
comment|/* Terminate the subnegotiation. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ttoc
argument_list|(
name|SE
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"telnet SB sent ttype"
argument_list|,
name|sb
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|debses
condition|)
comment|/* Debug to screen. */
name|printf
argument_list|(
literal|"[SB TERMINAL TYPE 00 %s IAC SE]"
argument_list|,
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* TNCODE */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_comment
comment|/*   SunLink X.25 support by Marcello Frutig, Catholic University,   Rio de Janeiro, Brazil, 1990. */
end_comment

begin_comment
comment|/* PAD X.3, X.28 and X.29 support */
end_comment

begin_decl_stmt
specifier|static
name|CHAR
name|x29err
index|[
name|MAXPADPARMS
operator|+
literal|3
index|]
init|=
block|{
name|X29_ERROR
block|,
name|INVALID_PAD_PARM
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize PAD */
end_comment

begin_decl_stmt
specifier|extern
name|CHAR
name|padparms
index|[
name|MAXPADPARMS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|initpad
parameter_list|()
block|{
name|padparms
index|[
name|PAD_BREAK_CHARACTER
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Break character */
name|padparms
index|[
name|PAD_ESCAPE
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Escape permitted */
name|padparms
index|[
name|PAD_ECHO
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Kermit PAD does echo */
name|padparms
index|[
name|PAD_DATA_FORWARD_CHAR
index|]
operator|=
literal|2
expr_stmt|;
comment|/* forward character CR */
name|padparms
index|[
name|PAD_DATA_FORWARD_TIMEOUT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no timeout forward condition */
name|padparms
index|[
name|PAD_FLOW_CONTROL_BY_PAD
index|]
operator|=
literal|0
expr_stmt|;
comment|/* not used */
name|padparms
index|[
name|PAD_SUPPRESSION_OF_SIGNALS
index|]
operator|=
literal|1
expr_stmt|;
comment|/* allow PAD service signals */
name|padparms
index|[
name|PAD_BREAK_ACTION
index|]
operator|=
literal|21
expr_stmt|;
comment|/* brk action: INT pk + brk ind*/
name|padparms
index|[
name|PAD_SUPPRESSION_OF_DATA
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no supression of user data */
name|padparms
index|[
name|PAD_PADDING_AFTER_CR
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no padding after CR */
name|padparms
index|[
name|PAD_LINE_FOLDING
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no line fold */
name|padparms
index|[
name|PAD_LINE_SPEED
index|]
operator|=
literal|0
expr_stmt|;
comment|/* line speed - don't care */
name|padparms
index|[
name|PAD_FLOW_CONTROL_BY_USER
index|]
operator|=
literal|0
expr_stmt|;
comment|/* flow cont of PAD - not used */
name|padparms
index|[
name|PAD_LF_AFTER_CR
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no LF insertion after CR */
name|padparms
index|[
name|PAD_PADDING_AFTER_LF
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no padding after LF */
name|padparms
index|[
name|PAD_EDITING
index|]
operator|=
literal|1
expr_stmt|;
comment|/* can edit */
name|padparms
index|[
name|PAD_CHAR_DELETE_CHAR
index|]
operator|=
literal|8
expr_stmt|;
comment|/* character delete character */
name|padparms
index|[
name|PAD_BUFFER_DELETE_CHAR
index|]
operator|=
literal|21
expr_stmt|;
comment|/* buffer delete character */
name|padparms
index|[
name|PAD_BUFFER_DISPLAY_CHAR
index|]
operator|=
literal|18
expr_stmt|;
comment|/* buffer display character */
block|}
end_function

begin_comment
comment|/* Set PAD parameters */
end_comment

begin_function
name|VOID
name|setpad
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|CHAR
modifier|*
name|ps
init|=
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ps
operator|>
name|MAXPADPARMS
condition|)
name|x29err
index|[
name|i
operator|+
literal|2
index|]
operator|=
operator|*
name|ps
expr_stmt|;
else|else
name|padparms
index|[
operator|*
name|ps
index|]
operator|=
operator|*
operator|(
name|ps
operator|+
literal|1
operator|)
expr_stmt|;
name|ps
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read PAD parameters */
end_comment

begin_function
name|VOID
name|readpad
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|r
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
name|CHAR
modifier|*
name|r
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|CHAR
modifier|*
name|ps
init|=
name|s
decl_stmt|;
name|CHAR
modifier|*
name|pr
init|=
name|r
decl_stmt|;
operator|*
name|pr
operator|++
operator|=
name|X29_PARAMETER_INDICATION
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|ps
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ps
operator|>
name|MAXPADPARMS
condition|)
block|{
name|x29err
index|[
name|i
operator|+
literal|2
index|]
operator|=
operator|*
name|ps
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pr
operator|++
operator|=
operator|*
name|ps
expr_stmt|;
operator|*
name|pr
operator|++
operator|=
name|padparms
index|[
operator|*
name|ps
operator|++
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|qbitpkt
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|CHAR
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|CHAR
modifier|*
name|ps
init|=
name|s
decl_stmt|;
name|int
name|x29cmd
init|=
operator|*
name|ps
decl_stmt|;
name|CHAR
modifier|*
name|psa
init|=
name|s
operator|+
literal|1
decl_stmt|;
name|CHAR
name|x29resp
index|[
operator|(
name|MAXPADPARMS
operator|*
literal|2
operator|)
operator|+
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|x29cmd
condition|)
block|{
case|case
name|X29_SET_PARMS
case|:
name|setpad
argument_list|(
name|ps
operator|+
literal|1
argument_list|,
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|x29err
argument_list|)
operator|>
literal|2
condition|)
block|{
name|ttol
argument_list|(
name|x29err
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|x29err
argument_list|)
argument_list|)
expr_stmt|;
name|x29err
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|2
operator|)
return|;
case|case
name|X29_READ_PARMS
case|:
name|readpad
argument_list|(
name|ps
operator|+
literal|1
argument_list|,
name|n
operator|/
literal|2
argument_list|,
name|x29resp
argument_list|)
expr_stmt|;
name|setqbit
argument_list|()
expr_stmt|;
name|ttol
argument_list|(
name|x29resp
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|x29err
argument_list|)
operator|>
literal|2
condition|)
block|{
name|ttol
argument_list|(
name|x29err
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|x29err
argument_list|)
argument_list|)
expr_stmt|;
name|x29err
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|resetqbit
argument_list|()
expr_stmt|;
break|break;
case|case
name|X29_SET_AND_READ_PARMS
case|:
name|setpad
argument_list|(
name|ps
operator|+
literal|1
argument_list|,
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
name|readpad
argument_list|(
name|ps
operator|+
literal|1
argument_list|,
name|n
operator|/
literal|2
argument_list|,
name|x29resp
argument_list|)
expr_stmt|;
name|setqbit
argument_list|()
expr_stmt|;
name|ttol
argument_list|(
name|x29resp
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|x29err
argument_list|)
operator|>
literal|2
condition|)
block|{
name|ttol
argument_list|(
name|x29err
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|x29err
argument_list|)
argument_list|)
expr_stmt|;
name|x29err
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|resetqbit
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
case|case
name|X29_INVITATION_TO_CLEAR
case|:
operator|(
name|VOID
operator|)
name|x25clear
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|X29_INDICATION_OF_BREAK
case|:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PAD break action processor */
end_comment

begin_function
name|VOID
name|breakact
parameter_list|()
block|{
specifier|extern
name|char
name|x25obuf
index|[
name|MAXOX25
index|]
decl_stmt|;
specifier|extern
name|int
name|obufl
decl_stmt|;
specifier|extern
name|int
name|active
decl_stmt|;
specifier|extern
name|unsigned
name|char
name|tosend
decl_stmt|;
specifier|static
name|CHAR
name|indbrk
index|[
literal|3
index|]
init|=
block|{
name|X29_INDICATION_OF_BREAK
block|,
name|PAD_SUPPRESSION_OF_DATA
block|,
literal|1
block|}
decl_stmt|;
name|CHAR
name|intudat
decl_stmt|,
name|cause
decl_stmt|,
name|diag
decl_stmt|;
if|if
condition|(
name|x25stat
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore if no virtual call established */
if|if
condition|(
name|padparms
index|[
name|PAD_BREAK_ACTION
index|]
operator|!=
literal|0
condition|)
comment|/* Forward condition */
if|if
condition|(
name|ttol
argument_list|(
name|x25obuf
argument_list|,
name|obufl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"\r\nCan't send characters"
argument_list|)
expr_stmt|;
name|active
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|x25obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|x25obuf
argument_list|)
argument_list|)
expr_stmt|;
name|obufl
operator|=
literal|0
expr_stmt|;
name|tosend
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
switch|switch
condition|(
name|padparms
index|[
name|PAD_BREAK_ACTION
index|]
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* do nothing */
case|case
literal|1
case|:
comment|/* send interrupt packet with interrupt user data field = 1 */
name|intudat
operator|=
literal|1
expr_stmt|;
name|x25intr
argument_list|(
name|intudat
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* send reset packet with cause and diag = 0 */
name|cause
operator|=
name|diag
operator|=
literal|0
expr_stmt|;
name|x25reset
argument_list|(
name|cause
argument_list|,
name|diag
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* send interrupt packet with interrupt user data field = 0 */
name|intudat
operator|=
literal|0
expr_stmt|;
name|x25intr
argument_list|(
name|intudat
argument_list|)
expr_stmt|;
name|setqbit
argument_list|()
expr_stmt|;
comment|/* send indication of break without a parameter field */
name|ttoc
argument_list|(
name|X29_INDICATION_OF_BREAK
argument_list|)
expr_stmt|;
name|resetqbit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|active
operator|=
literal|0
expr_stmt|;
comment|/* leave data transfer */
name|conol
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
comment|/* send interrupt packet with interrupt user data field = 0 */
name|intudat
operator|=
literal|0
expr_stmt|;
name|x25intr
argument_list|(
name|intudat
argument_list|)
expr_stmt|;
name|setpad
argument_list|(
name|indbrk
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* set pad to discard input */
name|setqbit
argument_list|()
expr_stmt|;
comment|/* send indication of break with parameter field */
name|ttol
argument_list|(
name|indbrk
argument_list|,
sizeof|sizeof
argument_list|(
name|indbrk
argument_list|)
argument_list|)
expr_stmt|;
name|resetqbit
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* X.25 support functions */
end_comment

begin_decl_stmt
name|X25_CAUSE_DIAG
name|diag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Convert a null-terminated string representing an X.121 address   to a packed BCD form. */
end_comment

begin_function
name|int
name|pkx121
parameter_list|(
name|str
parameter_list|,
name|bcd
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|CHAR
modifier|*
name|bcd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|str
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|>=
literal|15
operator|||
name|str
index|[
name|i
index|]
operator|<
literal|'0'
operator|||
name|str
index|[
name|i
index|]
operator|>
literal|'9'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|c
operator|=
name|str
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|bcd
index|[
name|j
operator|++
index|]
operator||=
name|c
expr_stmt|;
else|else
name|bcd
index|[
name|j
index|]
operator|=
name|c
operator|<<
literal|4
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reads and prints X.25 diagnostic */
end_comment

begin_function
name|int
name|x25diag
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|diag
argument_list|,
sizeof|sizeof
argument_list|(
name|diag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_RD_CAUSE_DIAG
argument_list|,
operator|&
name|diag
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Reading X.25 diagnostic"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|diag
operator|.
name|datalen
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"X.25 Diagnostic :"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diag
operator|.
name|datalen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|diag
operator|.
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* X.25 Out-of-Band Signal Handler */
end_comment

begin_function
name|VOID
name|x25oobh
parameter_list|()
block|{
name|int
name|oobtype
decl_stmt|;
name|u_char
name|oobdata
decl_stmt|;
operator|(
name|VOID
operator|)
name|signal
argument_list|(
name|SIGURG
argument_list|,
name|x25oobh
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_OOB_TYPE
argument_list|,
operator|&
name|oobtype
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Getting signal type"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|oobtype
condition|)
block|{
case|case
name|INT_DATA
case|:
if|if
condition|(
name|recv
argument_list|(
name|ttyfd
argument_list|,
name|oobdata
argument_list|,
literal|1
argument_list|,
name|MSG_OOB
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Receiving X.25 interrupt data"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\r\nInterrupt received, data = %d\r\n"
argument_list|,
name|oobdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|VC_RESET
case|:
name|printf
argument_list|(
literal|"\r\nVirtual circuit reset\r\n"
argument_list|)
expr_stmt|;
name|x25diag
argument_list|()
expr_stmt|;
break|break;
case|case
name|N_RESETS
case|:
name|printf
argument_list|(
literal|"\r\nReset timeout\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_CLEARS
case|:
name|printf
argument_list|(
literal|"\r\nClear timeout\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_TOO_LONG
case|:
name|printf
argument_list|(
literal|"\r\nMessage discarded, too long\r\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|oobtype
condition|)
name|printf
argument_list|(
literal|"\r\nUnknown oob type %d\r\n"
argument_list|,
name|oobtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|oobtype
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Send a X.25 interrupt packet */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|x25intr
parameter_list|(
name|char
name|intr
parameter_list|)
else|#
directive|else
function|x25intr
parameter_list|(
name|intr
parameter_list|)
name|char
name|intr
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* x25intr */
block|{
if|if
condition|(
name|send
argument_list|(
name|ttyfd
argument_list|,
operator|&
name|intr
argument_list|,
literal|1
argument_list|,
name|MSG_OOB
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|debug
argument_list|(
name|F100
argument_list|,
literal|"X.25 intr"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reset X.25 virtual circuit */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|x25reset
parameter_list|(
name|char
name|cause
parameter_list|,
name|char
name|diagn
parameter_list|)
else|#
directive|else
function|x25reset
parameter_list|(
name|cause
parameter_list|,
name|diagn
parameter_list|)
name|char
name|cause
decl_stmt|;
name|char
name|diagn
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* x25reset */
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|diag
argument_list|,
sizeof|sizeof
argument_list|(
name|diag
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|diag
operator|.
name|datalen
operator|=
literal|2
expr_stmt|;
name|diag
operator|.
name|data
index|[
literal|0
index|]
operator|=
name|cause
expr_stmt|;
name|diag
operator|.
name|data
index|[
literal|1
index|]
operator|=
name|diagn
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_WR_CAUSE_DIAG
argument_list|,
operator|&
name|diag
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|debug
argument_list|(
name|F100
argument_list|,
literal|"X.25 reset"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear X.25 virtual circuit */
end_comment

begin_function
name|int
name|x25clear
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
name|F100
argument_list|,
literal|"X.25 clear"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|diag
argument_list|,
sizeof|sizeof
argument_list|(
name|diag
argument_list|)
argument_list|)
expr_stmt|;
name|diag
operator|.
name|flags
operator|=
operator|(
literal|1
operator|<<
name|DIAG_TYPE
operator|)
expr_stmt|;
name|diag
operator|.
name|datalen
operator|=
literal|2
expr_stmt|;
name|diag
operator|.
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|diag
operator|.
name|data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_WR_CAUSE_DIAG
argument_list|,
operator|&
name|diag
argument_list|)
expr_stmt|;
comment|/* Send Clear Request */
return|return
operator|(
name|ttclos
argument_list|(
literal|0
argument_list|)
operator|)
return|;
comment|/* Close socket */
block|}
end_function

begin_comment
comment|/* X.25 status */
end_comment

begin_function
name|int
name|x25stat
parameter_list|()
block|{
if|if
condition|(
name|ttyfd
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set Q_BIT on */
end_comment

begin_function
name|VOID
name|setqbit
parameter_list|()
block|{
specifier|static
name|int
name|qbiton
init|=
literal|1
operator|<<
name|Q_BIT
decl_stmt|;
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_SEND_TYPE
argument_list|,
operator|&
name|qbiton
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set Q_BIT off */
end_comment

begin_function
name|VOID
name|resetqbit
parameter_list|()
block|{
specifier|static
name|int
name|qbitoff
init|=
literal|0
decl_stmt|;
name|ioctl
argument_list|(
name|ttyfd
argument_list|,
name|X25_SEND_TYPE
argument_list|,
operator|&
name|qbitoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read n characters from X.25 circuit into buf */
end_comment

begin_function
name|int
name|x25xin
parameter_list|(
name|n
parameter_list|,
name|buf
parameter_list|)
name|int
name|n
decl_stmt|;
name|CHAR
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|c
decl_stmt|;
name|int
name|qpkt
decl_stmt|;
do|do
block|{
name|x
operator|=
name|read
argument_list|(
name|ttyfd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|&
operator|(
literal|1
operator|<<
name|Q_BIT
operator|)
condition|)
block|{
comment|/* If Q_BIT packet, process it */
comment|/* If return -1 : invitation to clear; -2 : PAD changes */
if|if
condition|(
operator|(
name|c
operator|=
name|qbitpkt
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|x
operator|-
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|qpkt
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|qpkt
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|qpkt
condition|)
do|;
if|if
condition|(
name|x
operator|>
literal|0
condition|)
name|buf
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* X.25 read a line */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|PARSENSE
ifdef|#
directive|ifdef
name|CK_ANSIC
name|x25inl
parameter_list|(
name|CHAR
modifier|*
name|dest
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|timo
parameter_list|,
name|CHAR
name|eol
parameter_list|,
name|CHAR
name|start
parameter_list|)
else|#
directive|else
function|x25inl
parameter_list|(
name|dest
parameter_list|,
name|max
parameter_list|,
name|timo
parameter_list|,
name|eol
parameter_list|,
name|start
parameter_list|)
name|int
name|max
decl_stmt|,
name|timo
decl_stmt|;
name|CHAR
modifier|*
name|dest
decl_stmt|,
name|eol
decl_stmt|,
name|start
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
else|#
directive|else
comment|/* not PARSENSE */
ifdef|#
directive|ifdef
name|CK_ANSIC
function|x25inl
parameter_list|(
name|CHAR
modifier|*
name|dest
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|timo
parameter_list|,
name|CHAR
name|eol
parameter_list|)
else|#
directive|else
function|x25inl
parameter_list|(
name|dest
parameter_list|,
name|max
parameter_list|,
name|timo
parameter_list|,
name|eol
parameter_list|)
name|int
name|max
decl_stmt|,
name|timo
decl_stmt|;
name|CHAR
modifier|*
name|dest
decl_stmt|,
name|eol
decl_stmt|;
endif|#
directive|endif
comment|/* __SDTC__ */
endif|#
directive|endif
comment|/* PARSENSE */
comment|/* x25inl */
block|{
name|CHAR
modifier|*
name|pdest
decl_stmt|;
name|int
name|pktype
decl_stmt|,
name|goteol
decl_stmt|,
name|rest
decl_stmt|,
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flag
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|ttprty
decl_stmt|;
name|int
name|ttpmsk
decl_stmt|;
name|ttpmsk
operator|=
operator|(
name|ttprty
operator|)
condition|?
literal|0177
else|:
literal|0377
expr_stmt|;
comment|/* Set parity stripping mask */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"x25inl max"
argument_list|,
literal|""
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"x25inl eol"
argument_list|,
literal|""
argument_list|,
name|eol
argument_list|)
expr_stmt|;
name|pdest
operator|=
name|dest
expr_stmt|;
name|rest
operator|=
name|max
expr_stmt|;
name|goteol
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|=
name|read
argument_list|(
name|ttyfd
argument_list|,
name|pdest
argument_list|,
name|rest
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|pktype
operator|=
operator|*
name|pdest
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|pktype
condition|)
block|{
case|case
literal|1
operator|<<
name|Q_BIT
case|:
if|if
condition|(
name|qbitpkt
argument_list|(
name|pdest
operator|+
literal|1
argument_list|,
operator|--
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
break|break;
default|default:
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
comment|/* if not in packet, search start */
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|i
operator|<
name|n
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|=
operator|(
operator|(
name|dest
index|[
name|i
index|]
operator|&
literal|0x7f
operator|)
operator|==
name|start
operator|)
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
comment|/* not found, discard junk */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"x25inl skipping"
argument_list|,
literal|""
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* found, discard junk before start */
name|int
name|k
decl_stmt|;
name|n
operator|=
name|n
operator|-
name|i
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|n
condition|;
name|k
operator|++
operator|,
name|i
operator|++
control|)
name|dest
index|[
name|k
index|]
operator|=
name|dest
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|n
operator|)
operator|&&
comment|/* search for eol */
operator|!
operator|(
name|goteol
operator|=
operator|(
operator|(
operator|(
operator|*
name|pdest
operator|=
operator|*
operator|(
name|pdest
operator|+
literal|1
operator|)
operator|&
name|ttpmsk
operator|)
operator|&
literal|0x7f
operator|)
operator|==
name|eol
operator|)
operator|)
condition|;
name|i
operator|++
operator|,
name|pdest
operator|++
control|)
empty_stmt|;
operator|*
name|pdest
operator|=
literal|'\0'
expr_stmt|;
name|rest
operator|-=
name|n
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|rest
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|!
name|goteol
operator|)
condition|)
do|;
if|if
condition|(
name|goteol
condition|)
block|{
name|n
operator|=
name|max
operator|-
name|rest
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"ttinl X.25 got"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dest
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
condition|)
name|ttimoff
argument_list|()
expr_stmt|;
if|if
condition|(
name|ttprty
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ttprty
operator|=
name|parchk
argument_list|(
name|dest
argument_list|,
name|start
argument_list|,
name|n
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ttinl senses parity"
argument_list|,
literal|""
argument_list|,
name|ttprty
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"ttinl packet before"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttpmsk
operator|=
literal|0x7f
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
name|dest
index|[
name|j
index|]
operator|&=
literal|0x7f
expr_stmt|;
comment|/* Strip parity from packet */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"ttinl packet after "
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"parchk"
argument_list|,
literal|""
argument_list|,
name|ttprty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttprty
operator|<
literal|0
condition|)
block|{
name|ttprty
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|ttimoff
argument_list|()
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|ttimoff
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

end_unit

