begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cp.c  -- file copying (main routines)    Copyright (C) 1989, 1990, 1991 Free Software Foundation.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|"cp.h"
end_include

begin_include
include|#
directive|include
file|"backupfile.h"
end_include

begin_comment
comment|/* Used by do_copy, make_path, and re_protect    to keep a list of leading directories whose protections    need to be fixed after copying. */
end_comment

begin_struct
struct|struct
name|dir_attr
block|{
name|int
name|is_new_dir
decl_stmt|;
name|int
name|slash_offset
decl_stmt|;
name|struct
name|dir_attr
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|char
modifier|*
name|dirname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|backup_type
name|get_version
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|eaccess_stat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|make_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|re_protect
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Initial number of entries in each hash table entry's table of inodes.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_HASH_MODULE
value|100
end_define

begin_comment
comment|/* Initial number of entries in the inode hash table.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_ENTRY_TAB_SIZE
value|70
end_define

begin_comment
comment|/* A pointer to either lstat or stat, depending on    whether dereferencing of symlinks is done.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|xstat
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The invocation name of this program.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, copy all files except directories and, if not dereferencing    them, symbolic links, as if they were regular files. */
end_comment

begin_decl_stmt
name|int
name|flag_copy_as_regular
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, dereference symbolic links (copy the files they point to). */
end_comment

begin_decl_stmt
name|int
name|flag_dereference
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, remove existing target nondirectories. */
end_comment

begin_decl_stmt
name|int
name|flag_force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, create hard links instead of copying files.    Create target directories as usual. */
end_comment

begin_decl_stmt
name|int
name|flag_hard_link
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, query before overwriting existing targets with regular files. */
end_comment

begin_decl_stmt
name|int
name|flag_interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, the command "cp x/e_file e_dir" uses "e_dir/x/e_file"    as its target instead of the usual "e_dir/e_file." */
end_comment

begin_decl_stmt
name|int
name|flag_path
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, give the copies the original files' permissions,    ownership, and timestamps. */
end_comment

begin_decl_stmt
name|int
name|flag_preserve
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, copy directories recursively and copy special files    as themselves rather than copying their contents. */
end_comment

begin_decl_stmt
name|int
name|flag_recursive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, create symbolic links instead of copying files.    Create target directories as usual. */
end_comment

begin_decl_stmt
name|int
name|flag_symbolic_link
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, when copying recursively, skip any subdirectories that are    on different filesystems from the one we started on. */
end_comment

begin_decl_stmt
name|int
name|flag_one_file_system
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, do not copy a nondirectory that has an existing destination    with the same or newer modification time. */
end_comment

begin_decl_stmt
name|int
name|flag_update
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, display the names of the files before copying them. */
end_comment

begin_decl_stmt
name|int
name|flag_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The error code to return to the system. */
end_comment

begin_decl_stmt
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bits to preserve in created files' modes. */
end_comment

begin_decl_stmt
name|int
name|umask_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_opts
index|[]
init|=
block|{
block|{
literal|"archive"
block|,
literal|0
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"backup"
block|,
literal|0
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"force"
block|,
literal|0
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"interactive"
block|,
literal|0
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"link"
block|,
literal|0
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"no-dereference"
block|,
literal|0
block|,
operator|&
name|flag_dereference
block|,
literal|0
block|}
block|,
block|{
literal|"one-file-system"
block|,
literal|0
block|,
operator|&
name|flag_one_file_system
block|,
literal|1
block|}
block|,
block|{
literal|"path"
block|,
literal|0
block|,
operator|&
name|flag_path
block|,
literal|1
block|}
block|,
block|{
literal|"preserve"
block|,
literal|0
block|,
operator|&
name|flag_preserve
block|,
literal|1
block|}
block|,
block|{
literal|"recursive"
block|,
literal|0
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"suffix"
block|,
literal|1
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"symbolic-link"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"update"
block|,
literal|0
block|,
operator|&
name|flag_update
block|,
literal|1
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
operator|&
name|flag_verbose
block|,
literal|1
block|}
block|,
block|{
literal|"version-control"
block|,
literal|1
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|make_backups
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|version
operator|=
name|getenv
argument_list|(
literal|"SIMPLE_BACKUP_SUFFIX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
condition|)
name|simple_backup_suffix
operator|=
name|version
expr_stmt|;
name|version
operator|=
name|getenv
argument_list|(
literal|"VERSION_CONTROL"
argument_list|)
expr_stmt|;
comment|/* Find out the current file creation mask, to knock the right bits      when using chmod.  The creation mask is set to to be liberal, so      that created directories can be written, even if it would not      have been allowed with the mask this process was started with.  */
name|umask_kill
operator|=
literal|0777777
operator|^
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abdfilprsuvxPRS:V:"
argument_list|,
name|long_opts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'a'
case|:
comment|/* Like -dpR. */
name|flag_dereference
operator|=
literal|0
expr_stmt|;
name|flag_preserve
operator|=
literal|1
expr_stmt|;
name|flag_recursive
operator|=
literal|1
expr_stmt|;
name|flag_copy_as_regular
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|make_backups
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flag_dereference
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|flag_force
operator|=
literal|1
expr_stmt|;
name|flag_interactive
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|flag_force
operator|=
literal|0
expr_stmt|;
name|flag_interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|flag_hard_link
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flag_preserve
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|flag_path
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flag_recursive
operator|=
literal|1
expr_stmt|;
name|flag_copy_as_regular
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|flag_recursive
operator|=
literal|1
expr_stmt|;
name|flag_copy_as_regular
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
ifdef|#
directive|ifdef
name|S_ISLNK
name|flag_symbolic_link
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"symbolic links not supported; making hard links"
argument_list|)
expr_stmt|;
name|flag_hard_link
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'u'
case|:
name|flag_update
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flag_verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|flag_one_file_system
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|simple_backup_suffix
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|version
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_hard_link
operator|&&
name|flag_symbolic_link
condition|)
name|usage
argument_list|(
literal|"cannot make both hard and symbolic links"
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_backups
condition|)
name|backup_type
operator|=
name|get_version
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_preserve
operator|==
literal|1
condition|)
name|umask_kill
operator|=
literal|0777777
expr_stmt|;
comment|/* The key difference between -d (+no-dereference) and not is the version      of `stat' to call.  */
if|if
condition|(
name|flag_dereference
condition|)
name|xstat
operator|=
name|stat
expr_stmt|;
else|else
name|xstat
operator|=
name|lstat
expr_stmt|;
comment|/* Allocate space for remembering copied and created files.  */
name|hash_init
argument_list|(
name|INITIAL_HASH_MODULE
argument_list|,
name|INITIAL_ENTRY_TAB_SIZE
argument_list|)
expr_stmt|;
name|exit_status
operator||=
name|do_copy
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan the arguments, and copy each by calling copy.    Return 0 if successful, 1 if any errors occur. */
end_comment

begin_function
name|int
name|do_copy
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|target
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|new_dst
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|usage
argument_list|(
literal|"missing file arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|(
literal|"missing file argument"
argument_list|)
expr_stmt|;
name|target
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|target
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|new_dst
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|sbx
decl_stmt|;
comment|/* If `target' is not a symlink to a nonexistent file, use 	 the results of stat instead of lstat, so we can copy files 	 into symlinks to directories. */
if|if
condition|(
name|stat
argument_list|(
name|target
argument_list|,
operator|&
name|sbx
argument_list|)
operator|==
literal|0
condition|)
name|sb
operator|=
name|sbx
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new_dst
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* cp file1...filen edir 	 Copy the files `file1' through `filen' 	 to the existing directory `edir'. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|dst_path
decl_stmt|;
name|int
name|parent_exists
init|=
literal|1
decl_stmt|;
comment|/* True if dirname (dst_path) exists. */
name|struct
name|dir_attr
modifier|*
name|attr_list
decl_stmt|;
name|arg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_path
condition|)
block|{
comment|/* Append all of `arg' to `target'.  */
name|dst_path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|target
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|dst_path
argument_list|,
name|target
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* For +path, we have to make sure that the directory 	         dirname (dst_path) exists.  We may have to create a few 	         leading directories. */
name|parent_exists
operator|=
operator|!
name|make_path
argument_list|(
name|dst_path
argument_list|,
name|strlen
argument_list|(
name|target
argument_list|)
operator|+
literal|1
argument_list|,
literal|0700
argument_list|,
name|flag_verbose
condition|?
literal|"%s -> %s\n"
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|attr_list
argument_list|,
operator|&
name|new_dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Append the last component of `arg' to `target'.  */
name|ap
operator|=
name|basename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* For `cp -R source/.. target', don't copy into `target/..'. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ap
argument_list|,
literal|".."
argument_list|)
condition|)
name|dst_path
operator|=
name|target
expr_stmt|;
else|else
block|{
name|dst_path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|target
argument_list|)
operator|+
name|strlen
argument_list|(
name|ap
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|dst_path
argument_list|,
name|target
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|parent_exists
condition|)
block|{
comment|/* make_path failed, so we shouldn't even attempt the copy. */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator||=
name|copy
argument_list|(
name|arg
argument_list|,
name|dst_path
argument_list|,
name|new_dst
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|dir_list
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|forget_all
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_path
condition|)
block|{
name|ret
operator||=
name|re_protect
argument_list|(
name|dst_path
argument_list|,
name|strlen
argument_list|(
name|target
argument_list|)
operator|+
literal|1
argument_list|,
name|attr_list
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|optind
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
break|break;
block|}
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|-
name|optind
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|flag_path
condition|)
name|usage
argument_list|(
literal|"when preserving paths, last argument must be a directory"
argument_list|)
expr_stmt|;
return|return
name|copy
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|target
argument_list|,
name|new_dst
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|dir_list
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
else|else
name|usage
argument_list|(
literal|"when copying multiple files, last argument must be a directory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the file SRC_PATH to the file DST_PATH.  The files may be of    any type.  NEW_DST should be non-zero if the file DST_PATH cannot    exist because its parent directory was just created; NEW_DST should    be zero if DST_PATH might already exist.  DEVICE is the device    number of the parent directory, or 0 if the parent of this file is    not known.  ANCESTORS points to a linked, null terminated list of    devices and inodes of parent directories of SRC_PATH.    Return 0 if successful, 1 if an error occurs. */
end_comment

begin_function
name|int
name|copy
parameter_list|(
name|src_path
parameter_list|,
name|dst_path
parameter_list|,
name|new_dst
parameter_list|,
name|device
parameter_list|,
name|ancestors
parameter_list|)
name|char
modifier|*
name|src_path
decl_stmt|;
name|char
modifier|*
name|dst_path
decl_stmt|;
name|int
name|new_dst
decl_stmt|;
name|dev_t
name|device
decl_stmt|;
name|struct
name|dir_list
modifier|*
name|ancestors
decl_stmt|;
block|{
name|struct
name|stat
name|src_sb
decl_stmt|;
name|struct
name|stat
name|dst_sb
decl_stmt|;
name|int
name|src_mode
decl_stmt|;
name|int
name|src_type
decl_stmt|;
name|char
modifier|*
name|earlier_file
decl_stmt|;
name|char
modifier|*
name|dst_backup
init|=
name|NULL
decl_stmt|;
name|int
name|dir_mode_changed
init|=
literal|0
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|src_path
argument_list|,
operator|&
name|src_sb
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Are we crossing a file system boundary?  */
if|if
condition|(
name|flag_one_file_system
operator|&&
name|device
operator|!=
literal|0
operator|&&
name|device
operator|!=
name|src_sb
operator|.
name|st_dev
condition|)
return|return
literal|0
return|;
comment|/* We wouldn't insert a node unless nlink> 1, except that we need to      find created files so as to not copy infinitely if a directory is      copied into itself.  */
name|earlier_file
operator|=
name|remember_copied
argument_list|(
name|dst_path
argument_list|,
name|src_sb
operator|.
name|st_ino
argument_list|,
name|src_sb
operator|.
name|st_dev
argument_list|)
expr_stmt|;
comment|/* Did we just create this file?  */
if|if
condition|(
name|earlier_file
operator|==
operator|&
name|new_file
condition|)
return|return
literal|0
return|;
name|src_mode
operator|=
name|src_sb
operator|.
name|st_mode
expr_stmt|;
name|src_type
operator|=
name|src_sb
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|src_type
argument_list|)
operator|&&
operator|!
name|flag_recursive
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: omitting directory"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|new_dst
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|dst_path
argument_list|,
operator|&
name|dst_sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|new_dst
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The file exists already.  */
if|if
condition|(
name|src_sb
operator|.
name|st_ino
operator|==
name|dst_sb
operator|.
name|st_ino
operator|&&
name|src_sb
operator|.
name|st_dev
operator|==
name|dst_sb
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
name|flag_hard_link
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' and `%s' are the same file"
argument_list|,
name|src_path
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|src_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dst_sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: cannot overwrite directory with non-directory"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|flag_update
operator|&&
name|src_sb
operator|.
name|st_mtime
operator|<=
name|dst_sb
operator|.
name|st_mtime
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|src_type
argument_list|)
operator|&&
operator|!
name|flag_force
condition|)
block|{
if|if
condition|(
name|flag_interactive
condition|)
block|{
if|if
condition|(
name|eaccess_stat
argument_list|(
operator|&
name|dst_sb
argument_list|,
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: overwrite `%s', overriding mode %04o? "
argument_list|,
name|program_name
argument_list|,
name|dst_path
argument_list|,
name|dst_sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: overwrite `%s'? "
argument_list|,
name|program_name
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yesno
argument_list|()
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|backup_type
operator|!=
name|none
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|dst_sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp_backup
init|=
name|find_backup_file_name
argument_list|(
name|dst_path
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp_backup
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|dst_backup
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tmp_backup
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dst_backup
argument_list|,
name|tmp_backup
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_backup
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|dst_path
argument_list|,
name|dst_backup
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot backup `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|dst_backup
operator|=
name|NULL
expr_stmt|;
block|}
name|new_dst
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_force
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dst_sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Temporarily change mode to allow overwriting. */
if|if
condition|(
name|eaccess_stat
argument_list|(
operator|&
name|dst_sb
argument_list|,
name|W_OK
operator||
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|dst_path
argument_list|,
literal|0700
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|dir_mode_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|unlink
argument_list|(
name|dst_path
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove old link to `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|new_dst
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If the source is a directory, we don't always create the target      directory.  So +verbose should not announce anything until we're      sure we'll create a directory. */
if|if
condition|(
name|flag_verbose
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|src_type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s -> %s\n"
argument_list|,
name|src_path
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
comment|/* Did we copy this inode somewhere else (in this command line argument)      and therefore this is a second hard link to the inode?  */
if|if
condition|(
operator|!
name|flag_dereference
operator|&&
name|src_sb
operator|.
name|st_nlink
operator|>
literal|1
operator|&&
name|earlier_file
condition|)
block|{
if|if
condition|(
name|link
argument_list|(
name|earlier_file
argument_list|,
name|dst_path
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|src_type
argument_list|)
condition|)
block|{
name|struct
name|dir_list
modifier|*
name|dir
decl_stmt|;
comment|/* If this directory has been copied before during the          recursion, there is a symbolic link to an ancestor          directory of the symbolic link.  It is impossible to          continue to copy this, unless we've got an infinite disk.  */
if|if
condition|(
name|is_ancestor
argument_list|(
operator|&
name|src_sb
argument_list|,
name|ancestors
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: cannot copy cyclic symbolic link"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
comment|/* Insert the current directory in the list of parents.  */
name|dir
operator|=
operator|(
expr|struct
name|dir_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dir_list
argument_list|)
argument_list|)
expr_stmt|;
name|dir
operator|->
name|parent
operator|=
name|ancestors
expr_stmt|;
name|dir
operator|->
name|ino
operator|=
name|src_sb
operator|.
name|st_ino
expr_stmt|;
name|dir
operator|->
name|dev
operator|=
name|src_sb
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|new_dst
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|dst_sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Create the new directory writable and searchable, so              we can create new entries in it.  */
if|if
condition|(
name|mkdir
argument_list|(
name|dst_path
argument_list|,
operator|(
name|src_mode
operator|&
name|umask_kill
operator|)
operator||
literal|0700
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create directory `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
comment|/* Insert the created directory's inode and device              numbers into the search structure, so that we can              avoid copying it again.  */
if|if
condition|(
name|remember_created
argument_list|(
name|dst_path
argument_list|)
condition|)
goto|goto
name|un_backup
goto|;
if|if
condition|(
name|flag_verbose
condition|)
name|printf
argument_list|(
literal|"%s -> %s\n"
argument_list|,
name|src_path
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the contents of the directory.  */
if|if
condition|(
name|copy_dir
argument_list|(
name|src_path
argument_list|,
name|dst_path
argument_list|,
name|new_dst
argument_list|,
operator|&
name|src_sb
argument_list|,
name|dir
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|S_ISLNK
elseif|else
if|if
condition|(
name|flag_symbolic_link
condition|)
block|{
if|if
condition|(
operator|*
name|src_path
operator|==
literal|'/'
operator|||
operator|(
operator|!
name|strncmp
argument_list|(
name|dst_path
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|&&
name|index
argument_list|(
name|dst_path
operator|+
literal|2
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|index
argument_list|(
name|dst_path
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symlink
argument_list|(
name|src_path
argument_list|,
name|dst_path
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can only make relative symbolic links in current directory"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|flag_hard_link
condition|)
block|{
if|if
condition|(
name|link
argument_list|(
name|src_path
argument_list|,
name|dst_path
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create link `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|src_type
argument_list|)
operator|||
operator|(
name|flag_copy_as_regular
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|src_type
argument_list|)
ifdef|#
directive|ifdef
name|S_ISLNK
operator|&&
operator|!
name|S_ISLNK
argument_list|(
name|src_type
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|copy_reg
argument_list|(
name|src_path
argument_list|,
name|dst_path
argument_list|)
condition|)
goto|goto
name|un_backup
goto|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|S_ISFIFO
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|src_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|mkfifo
argument_list|(
name|dst_path
argument_list|,
name|src_mode
operator|&
name|umask_kill
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create fifo `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|S_ISBLK
argument_list|(
name|src_type
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|src_type
argument_list|)
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|src_type
argument_list|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|mknod
argument_list|(
name|dst_path
argument_list|,
name|src_mode
operator|&
name|umask_kill
argument_list|,
name|src_sb
operator|.
name|st_rdev
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create special file `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|S_ISLNK
ifdef|#
directive|ifdef
name|_AIX
define|#
directive|define
name|LINK_BUF
value|PATH_MAX
else|#
directive|else
define|#
directive|define
name|LINK_BUF
value|src_sb.st_size
endif|#
directive|endif
if|if
condition|(
name|S_ISLNK
argument_list|(
name|src_type
argument_list|)
condition|)
block|{
name|char
modifier|*
name|link_val
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|LINK_BUF
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|link_size
decl_stmt|;
name|link_size
operator|=
name|readlink
argument_list|(
name|src_path
argument_list|,
name|link_val
argument_list|,
name|LINK_BUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_size
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read symbolic link `%s'"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
name|link_val
index|[
name|link_size
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|link_val
argument_list|,
name|dst_path
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create symbolic link `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
return|return
literal|0
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: unknown file type"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
goto|goto
name|un_backup
goto|;
block|}
if|if
condition|(
operator|(
name|flag_preserve
operator|||
name|new_dst
operator|)
operator|&&
operator|(
name|S_ISREG
argument_list|(
name|src_type
argument_list|)
operator|||
name|S_ISDIR
argument_list|(
name|src_type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|dst_path
argument_list|,
name|src_mode
operator|&
name|umask_kill
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|dir_mode_changed
condition|)
block|{
comment|/* Reset the temporarily changed mode.  */
if|if
condition|(
name|chmod
argument_list|(
name|dst_path
argument_list|,
name|dst_sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Adjust the times (and if possible, ownership) for the copy. */
if|if
condition|(
name|flag_preserve
condition|)
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|src_sb
operator|.
name|st_atime
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|src_sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|dst_path
argument_list|,
operator|&
name|utb
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|chown
argument_list|(
name|dst_path
argument_list|,
name|src_sb
operator|.
name|st_uid
argument_list|,
name|src_sb
operator|.
name|st_gid
argument_list|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
name|un_backup
label|:
if|if
condition|(
name|dst_backup
condition|)
block|{
if|if
condition|(
name|rename
argument_list|(
name|dst_backup
argument_list|,
name|dst_path
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot un-backup `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ensure that the parent directory of CONST_DIRPATH exists, for    the +path option.     SRC_OFFSET is the index in CONST_DIRPATH (which is a destination    path) of the beginning of the source directory name.    Create any leading directories that don't already exist,    giving them permissions MODE.    If VERBOSE_FMT_STRING is nonzero, use it as a printf format    string for printing a message after successfully making a directory.    The format should take two string arguments: the names of the    source and destination directories.    Creates a linked list of attributes of intermediate directories,    *ATTR_LIST, for re_protect to use after calling copy.    Sets *NEW_DST to 1 if this function creates parent of CONST_DIRPATH.     Return 0 if parent of CONST_DIRPATH exists as a directory with the proper    permissions when done, otherwise 1. */
end_comment

begin_function
specifier|static
name|int
name|make_path
parameter_list|(
name|const_dirpath
parameter_list|,
name|src_offset
parameter_list|,
name|mode
parameter_list|,
name|verbose_fmt_string
parameter_list|,
name|attr_list
parameter_list|,
name|new_dst
parameter_list|)
name|char
modifier|*
name|const_dirpath
decl_stmt|;
name|int
name|src_offset
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|char
modifier|*
name|verbose_fmt_string
decl_stmt|;
name|struct
name|dir_attr
modifier|*
modifier|*
name|attr_list
decl_stmt|;
name|int
modifier|*
name|new_dst
decl_stmt|;
block|{
name|struct
name|stat
name|stats
decl_stmt|;
name|char
modifier|*
name|dirpath
decl_stmt|;
comment|/* A copy of CONST_DIRPATH we can change. */
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Source name in `dirpath'. */
name|char
modifier|*
name|tmp_dst_dirname
decl_stmt|;
comment|/* Leading path of `dirpath', malloc. */
name|char
modifier|*
name|dst_dirname
decl_stmt|;
comment|/* Leading path of `dirpath', alloca. */
name|dirpath
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|const_dirpath
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirpath
argument_list|,
name|const_dirpath
argument_list|)
expr_stmt|;
name|src
operator|=
name|dirpath
operator|+
name|src_offset
expr_stmt|;
name|tmp_dst_dirname
operator|=
name|dirname
argument_list|(
name|dirpath
argument_list|)
expr_stmt|;
name|dst_dirname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tmp_dst_dirname
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dst_dirname
argument_list|,
name|tmp_dst_dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_dst_dirname
argument_list|)
expr_stmt|;
operator|*
name|attr_list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|dst_dirname
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
comment|/* Parent of CONST_DIRNAME does not exist. 	 Make all missing intermediate directories. */
name|char
modifier|*
name|slash
decl_stmt|;
name|slash
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
while|while
condition|(
name|slash
operator|=
name|index
argument_list|(
name|slash
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
comment|/* Add this directory to the list of directories whose modes need 	     fixing later. */
name|struct
name|dir_attr
modifier|*
name|new
init|=
operator|(
expr|struct
name|dir_attr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dir_attr
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|slash_offset
operator|=
name|slash
operator|-
name|dirpath
expr_stmt|;
name|new
operator|->
name|next
operator|=
operator|*
name|attr_list
expr_stmt|;
operator|*
name|attr_list
operator|=
name|new
expr_stmt|;
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|dirpath
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
comment|/* This element of the path does not exist.  We must set 		 *new_dst and new->is_new_dir inside this loop because, 		 for example, in the command `cp +path ../a/../b/c e_dir', 		 make_path creates only e_dir/../a if ./b already exists. */
operator|*
name|new_dst
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|is_new_dir
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|dirpath
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory `%s'"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|verbose_fmt_string
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
name|verbose_fmt_string
argument_list|,
name|src
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' exists but is not a directory"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|new
operator|->
name|is_new_dir
operator|=
literal|0
expr_stmt|;
operator|*
name|new_dst
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|slash
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Avoid unnecessary calls to `stat' when given 	     pathnames containing multiple adjacent slashes.  */
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
block|}
block|}
comment|/* We get here if the parent of `dirpath' already exists. */
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' exists but is not a directory"
argument_list|,
name|dst_dirname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|chmod
argument_list|(
name|dst_dirname
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_dirname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
operator|*
name|new_dst
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ensure that the parent directories of CONST_DST_PATH have the    correct protections, for the +path option.  This is done    after all copying has been completed, to allow permissions    that don't include user write/execute.     SRC_OFFSET is the index in CONST_DST_PATH of the beginning of the    source directory name.     ATTR_LIST is a null-terminated linked list of structures that    indicates the end of the filename of each intermediate directory    in CONST_DST_PATH that may need to have its attributes changed.    The command `cp +path +preserve a/b/c d/e_dir' changes the    attributes of the directories d/e_dir/a and d/e_dir/a/b to match    the corresponding source directories regardless of whether they    existed before the `cp' command was given.     Return 0 if the parent of CONST_DST_PATH and any intermediate    directories specified by ATTR_LIST have the proper permissions    when done, otherwise 1. */
end_comment

begin_function
specifier|static
name|int
name|re_protect
parameter_list|(
name|const_dst_path
parameter_list|,
name|src_offset
parameter_list|,
name|attr_list
parameter_list|)
name|char
modifier|*
name|const_dst_path
decl_stmt|;
name|int
name|src_offset
decl_stmt|;
name|struct
name|dir_attr
modifier|*
name|attr_list
decl_stmt|;
block|{
name|struct
name|dir_attr
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|dst_path
decl_stmt|;
comment|/* A copy of CONST_DST_PATH we can change. */
name|char
modifier|*
name|src_path
decl_stmt|;
comment|/* The source name in `dst_path'. */
name|dst_path
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|const_dst_path
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dst_path
argument_list|,
name|const_dst_path
argument_list|)
expr_stmt|;
name|src_path
operator|=
name|dst_path
operator|+
name|src_offset
expr_stmt|;
for|for
control|(
name|p
operator|=
name|attr_list
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|stat
name|src_sb
decl_stmt|;
name|dst_path
index|[
name|p
operator|->
name|slash_offset
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|src_path
argument_list|,
operator|&
name|src_sb
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|flag_preserve
operator|||
name|p
operator|->
name|is_new_dir
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|dst_path
argument_list|,
name|src_sb
operator|.
name|st_mode
operator|&
name|umask_kill
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Adjust the times (and if possible, ownership) for the copy. */
if|if
condition|(
name|flag_preserve
condition|)
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|src_sb
operator|.
name|st_atime
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|src_sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|dst_path
argument_list|,
operator|&
name|utb
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|chown
argument_list|(
name|dst_path
argument_list|,
name|src_sb
operator|.
name|st_uid
argument_list|,
name|src_sb
operator|.
name|st_gid
argument_list|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|dst_path
index|[
name|p
operator|->
name|slash_offset
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the contents of the directory SRC_PATH_IN, and recursively    copy the contents to DST_PATH_IN.  NEW_DST is non-zero if    DST_PATH_IN is a directory that was created previously in the    recursion.   SRC_SB and ANCESTORS describe SRC_PATH_IN.    Return 0 if successful, -1 if an error occurs. */
end_comment

begin_function
name|int
name|copy_dir
parameter_list|(
name|src_path_in
parameter_list|,
name|dst_path_in
parameter_list|,
name|new_dst
parameter_list|,
name|src_sb
parameter_list|,
name|ancestors
parameter_list|)
name|char
modifier|*
name|src_path_in
decl_stmt|;
name|char
modifier|*
name|dst_path_in
decl_stmt|;
name|int
name|new_dst
decl_stmt|;
name|struct
name|stat
modifier|*
name|src_sb
decl_stmt|;
name|struct
name|dir_list
modifier|*
name|ancestors
decl_stmt|;
block|{
name|char
modifier|*
name|name_space
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
name|char
modifier|*
name|src_path
decl_stmt|;
name|char
modifier|*
name|dst_path
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|name_space
operator|=
name|savedir
argument_list|(
name|src_path_in
argument_list|,
name|src_sb
operator|->
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_space
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|errno
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|src_path_in
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
block|}
name|namep
operator|=
name|name_space
expr_stmt|;
while|while
condition|(
operator|*
name|namep
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|fn_length
init|=
name|strlen
argument_list|(
name|namep
argument_list|)
operator|+
literal|1
decl_stmt|;
name|dst_path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dst_path_in
argument_list|)
operator|+
name|fn_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|src_path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|src_path_in
argument_list|)
operator|+
name|fn_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|src_path
argument_list|,
name|src_path_in
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|dst_path
argument_list|,
name|dst_path_in
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|ret
operator||=
name|copy
argument_list|(
name|src_path
argument_list|,
name|dst_path
argument_list|,
name|new_dst
argument_list|,
name|src_sb
operator|->
name|st_dev
argument_list|,
name|ancestors
argument_list|)
expr_stmt|;
comment|/* Free the memory for `src_path'.  The memory for `dst_path' 	 cannot be deallocated, since it is used to create multiple 	 hard links.  */
name|free
argument_list|(
name|src_path
argument_list|)
expr_stmt|;
name|namep
operator|+=
name|fn_length
expr_stmt|;
block|}
name|free
argument_list|(
name|name_space
argument_list|)
expr_stmt|;
return|return
operator|-
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy a regular file from SRC_PATH to DST_PATH.    If the source file contains holes, copies holes and blocks of zeros    in the source file as holes in the target file.    (Holes are read as zeroes by the `read' system call.)    Return 0 if successful, -1 if an error occurred. */
end_comment

begin_function
name|int
name|copy_reg
parameter_list|(
name|src_path
parameter_list|,
name|dst_path
parameter_list|)
name|char
modifier|*
name|src_path
decl_stmt|;
name|char
modifier|*
name|dst_path
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buf_size
decl_stmt|;
name|int
name|target_desc
decl_stmt|;
name|int
name|source_desc
decl_stmt|;
name|int
name|n_read
decl_stmt|;
name|int
name|n_written
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
name|int
name|return_val
init|=
literal|0
decl_stmt|;
name|long
name|n_read_total
init|=
literal|0
decl_stmt|;
name|int
name|last_write_made_hole
init|=
literal|0
decl_stmt|;
name|int
name|make_holes
init|=
literal|0
decl_stmt|;
name|source_desc
operator|=
name|open
argument_list|(
name|src_path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_desc
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Create the new regular file with small permissions initially,      to not create a security hole.  */
name|target_desc
operator|=
name|open
argument_list|(
name|dst_path
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_desc
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create regular file `%s'"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret2
goto|;
block|}
comment|/* Find out the optimal buffer size.  */
if|if
condition|(
name|fstat
argument_list|(
name|target_desc
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|buf_size
operator|=
name|ST_BLKSIZE
argument_list|(
name|sb
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ST_BLOCKS_MISSING
if|if
condition|(
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Find out whether the file contains any sparse blocks. */
if|if
condition|(
name|fstat
argument_list|(
name|source_desc
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* If the file has fewer blocks than would normally 	 be needed for a file of its size, then 	 at least one of the blocks in the file is a hole. */
if|if
condition|(
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|&&
name|sb
operator|.
name|st_size
operator|-
operator|(
name|sb
operator|.
name|st_blocks
operator|*
name|DEV_BSIZE
operator|)
operator|>=
name|DEV_BSIZE
condition|)
name|make_holes
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Make a buffer with space for a sentinel at the end.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|buf_size
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n_read
operator|=
name|read
argument_list|(
name|source_desc
argument_list|,
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|n_read
operator|==
literal|0
condition|)
break|break;
name|n_read_total
operator|+=
name|n_read
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|make_holes
condition|)
block|{
name|buf
index|[
name|n_read
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Sentinel to stop loop.  */
comment|/* Find first non-zero *word*, or the word with the sentinel.  */
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|ip
operator|++
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* Find the first non-zero *byte*, or the sentinel.  */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ip
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|++
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* If we found the sentinel, the whole input block was zero, 	     and we can make a hole.  */
if|if
condition|(
name|cp
operator|>
name|buf
operator|+
name|n_read
condition|)
block|{
comment|/* Make a hole.  */
if|if
condition|(
name|lseek
argument_list|(
name|target_desc
argument_list|,
operator|(
name|off_t
operator|)
name|n_read
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0L
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|last_write_made_hole
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* Clear to indicate that a normal write is needed. */
name|ip
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
block|{
name|n_written
operator|=
name|write
argument_list|(
name|target_desc
argument_list|,
name|buf
argument_list|,
name|n_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_written
operator|<
name|n_read
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|last_write_made_hole
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If the file ends with a `hole', something needs to be written at      the end.  Otherwise the kernel would truncate the file at the end      of the last write operation.  */
if|if
condition|(
name|last_write_made_hole
condition|)
block|{
ifndef|#
directive|ifndef
name|FTRUNCATE_MISSING
comment|/* Write a null character and truncate it again.  */
if|if
condition|(
name|write
argument_list|(
name|target_desc
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|||
name|ftruncate
argument_list|(
name|target_desc
argument_list|,
name|n_read_total
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
comment|/* Seek backwards one character and write a null.  */
if|if
condition|(
name|lseek
argument_list|(
name|target_desc
argument_list|,
operator|(
name|off_t
operator|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|<
literal|0L
operator|||
name|write
argument_list|(
name|target_desc
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
endif|#
directive|endif
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|ret
label|:
if|if
condition|(
name|close
argument_list|(
name|target_desc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|ret2
label|:
if|if
condition|(
name|close
argument_list|(
name|source_desc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|src_path
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|return_val
return|;
block|}
end_function

end_unit

