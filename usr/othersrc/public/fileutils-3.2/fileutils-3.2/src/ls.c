begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* `dir', `vdir' and `ls' directory listing programs for GNU.    Copyright (C) 1985, 1988, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* If the macro MULTI_COL is defined,    the multi-column format is the default regardless    of the type of output device.    This is for the `dir' program.     If the macro LONG_FORMAT is defined,    the long format is the default regardless of the    type of output device.    This is for the `vdir' program.     If neither is defined,    the output format depends on whether the output    device is a terminal.    This is for the `ls' program. */
end_comment

begin_comment
comment|/* Written by Richard Stallman and David MacKenzie. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_SOURCE
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_IEXEC
end_ifndef

begin_define
define|#
directive|define
name|S_IEXEC
value|S_IXUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return an int indicating the result of comparing two longs. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INT_16_BITS
end_ifdef

begin_define
define|#
directive|define
name|longdiff
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? -1 : (a)> (b) ? 1 : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|longdiff
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) - (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|mode_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xstrdup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getgroup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getuser
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|make_link_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|argmatch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_atime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rev_cmp_atime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rev_cmp_ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_mtime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rev_cmp_mtime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rev_cmp_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rev_cmp_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_extension
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|rev_cmp_extension
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|decode_switches
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|file_interesting
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gobble_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|is_not_dot_or_dotdot
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|length_of_file_name_and_frills
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_ignore_pattern
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|attach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clear_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|extract_dirs_from_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_link_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|indent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|invalid_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_current_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_dir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_file_name_and_frills
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_horizontal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_long_format
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_many_per_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_name_with_quoting
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_type_indicator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_with_commas
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|queue_directory
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sort_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_enum
enum|enum
name|filetype
block|{
name|symbolic_link
block|,
name|directory
block|,
name|arg_directory
block|,
comment|/* Directory given as command line arg. */
name|normal
comment|/* All others. */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|file
block|{
comment|/* The file name. */
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stat
name|stat
decl_stmt|;
comment|/* For symbolic link, name of the file linked to, otherwise zero. */
name|char
modifier|*
name|linkname
decl_stmt|;
comment|/* For symbolic link and long listing, st_mode of file linked to, otherwise      zero. */
name|unsigned
name|int
name|linkmode
decl_stmt|;
name|enum
name|filetype
name|filetype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The table of files in the current directory:     `files' points to a vector of `struct file', one per file.    `nfiles' is the number of elements space has been allocated for.    `files_index' is the number actually in use.  */
end_comment

begin_comment
comment|/* Address of block containing the files that are described.  */
end_comment

begin_decl_stmt
name|struct
name|file
modifier|*
name|files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of block that `files' points to, measured in files.  */
end_comment

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first unused in `files'.  */
end_comment

begin_decl_stmt
name|int
name|files_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record of one pending directory waiting to be listed.  */
end_comment

begin_struct
struct|struct
name|pending
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* If the directory is actually the file pointed to by a symbolic link we      were told to list, `realname' will contain the name of the symbolic      link, otherwise zero. */
name|char
modifier|*
name|realname
decl_stmt|;
name|struct
name|pending
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pending
modifier|*
name|pending_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current time (seconds since 1970).  When we are printing a file's time,    include the year if it is more than 6 months before this time.  */
end_comment

begin_decl_stmt
name|time_t
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of digits to use for block sizes.    4, or more if needed for bigger numbers.  */
end_comment

begin_decl_stmt
name|int
name|block_size_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name the program was run with, stripped of any leading path. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Option flags */
end_comment

begin_comment
comment|/* long_format for lots of info, one per line.    one_per_line for just names, one per line.    many_per_line for just names, many per line, sorted vertically.    horizontal for just names, many per line, sorted horizontally.    with_commas for just names, many per line, separated by commas.     -l, -1, -C, -x and -m control this parameter.  */
end_comment

begin_enum
enum|enum
name|format
block|{
name|long_format
block|,
comment|/* -l */
name|one_per_line
block|,
comment|/* -1 */
name|many_per_line
block|,
comment|/* -C */
name|horizontal
block|,
comment|/* -x */
name|with_commas
comment|/* -m */
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|format
name|format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of time to print or sort by.  Controlled by -c and -u.  */
end_comment

begin_enum
enum|enum
name|time_type
block|{
name|time_mtime
block|,
comment|/* default */
name|time_ctime
block|,
comment|/* -c */
name|time_atime
comment|/* -u */
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|time_type
name|time_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file characteristic to sort by.  Controlled by -t, -S, -U, -X. */
end_comment

begin_enum
enum|enum
name|sort_type
block|{
name|sort_none
block|,
comment|/* -U */
name|sort_name
block|,
comment|/* default */
name|sort_extension
block|,
comment|/* -X */
name|sort_time
block|,
comment|/* -t */
name|sort_size
comment|/* -S */
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|sort_type
name|sort_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Direction of sort.    0 means highest first if numeric,    lowest first if alphabetic;    these are the defaults.    1 means the opposite order in each case.  -r  */
end_comment

begin_decl_stmt
name|int
name|sort_reverse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print the user and group id's as numbers rather    than as names.  -n  */
end_comment

begin_decl_stmt
name|int
name|numeric_users
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means mention the size in 512 byte blocks of each file.  -s  */
end_comment

begin_decl_stmt
name|int
name|print_block_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means show file sizes in kilobytes instead of blocks    (the size of which is system-dependant).  -k */
end_comment

begin_decl_stmt
name|int
name|kilobyte_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* none means don't mention the type of files.    all means mention the types of all files.    not_programs means do so except for executables.     Controlled by -F and -p.  */
end_comment

begin_enum
enum|enum
name|indicator_style
block|{
name|none
block|,
comment|/* default */
name|all
block|,
comment|/* -F */
name|not_programs
comment|/* -p */
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|indicator_style
name|indicator_style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means mention the inode number of each file.  -i  */
end_comment

begin_decl_stmt
name|int
name|print_inode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means when a symbolic link is found, display info on    the file linked to.  -L  */
end_comment

begin_decl_stmt
name|int
name|trace_links
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means when a directory is found, display info on its    contents.  -R  */
end_comment

begin_decl_stmt
name|int
name|trace_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means when an argument is a directory name, display info    on it itself.  -d  */
end_comment

begin_decl_stmt
name|int
name|immediate_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't omit files whose names start with `.'.  -A */
end_comment

begin_decl_stmt
name|int
name|all_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't omit files `.' and `..'    This flag implies `all_files'.  -a  */
end_comment

begin_decl_stmt
name|int
name|really_all_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A linked list of shell-style globbing patterns.  If a non-argument    file name matches any of these patterns, it is omitted.    Controlled by -I.  Multiple -I options accumulate.    The -B option adds `*~' and `.*~' to this list.  */
end_comment

begin_struct
struct|struct
name|ignore_pattern
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
name|struct
name|ignore_pattern
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|ignore_pattern
modifier|*
name|ignore_patterns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means quote nongraphic chars in file names.  -b  */
end_comment

begin_decl_stmt
name|int
name|quote_funny_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means output nongraphic chars in file names as `?'.  -q  */
end_comment

begin_decl_stmt
name|int
name|qmark_funny_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means output each file name using C syntax for a string.    Always accompanied by `quote_funny_chars'.    This mode, together with -x or -C or -m,    and without such frills as -F or -s,    is guaranteed to make it possible for a program receiving    the output to tell exactly what file names are present.  -Q  */
end_comment

begin_decl_stmt
name|int
name|quote_as_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of chars per hardware tab stop.  -T */
end_comment

begin_decl_stmt
name|int
name|tabsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we are listing the working directory because no    non-option arguments were given. */
end_comment

begin_decl_stmt
name|int
name|dir_defaulted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print each directory name before listing it. */
end_comment

begin_decl_stmt
name|int
name|print_dir_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line length to use for breaking lines in many-per-line format.    Can be set with -w.  */
end_comment

begin_decl_stmt
name|int
name|line_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, the file listing format requires that stat be called on    each file. */
end_comment

begin_decl_stmt
name|int
name|format_needs_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The exit status to use if we don't get any fatal errors. */
end_comment

begin_decl_stmt
name|int
name|exit_status
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|pending
modifier|*
name|thispend
decl_stmt|;
name|exit_status
operator|=
literal|0
expr_stmt|;
name|dir_defaulted
operator|=
literal|1
expr_stmt|;
name|print_dir_name
operator|=
literal|1
expr_stmt|;
name|pending_dirs
operator|=
literal|0
expr_stmt|;
name|current_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
name|decode_switches
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|format_needs_stat
operator|=
name|sort_type
operator|==
name|sort_time
operator|||
name|sort_type
operator|==
name|sort_size
operator|||
name|format
operator|==
name|long_format
operator|||
name|trace_links
operator|||
name|trace_dirs
operator|||
name|indicator_style
operator|!=
name|none
operator|||
name|print_block_size
operator|||
name|print_inode
expr_stmt|;
name|nfiles
operator|=
literal|100
expr_stmt|;
name|files
operator|=
operator|(
expr|struct
name|file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file
argument_list|)
operator|*
name|nfiles
argument_list|)
expr_stmt|;
name|files_index
operator|=
literal|0
expr_stmt|;
name|clear_files
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|argc
condition|)
name|dir_defaulted
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|gobble_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_defaulted
condition|)
block|{
if|if
condition|(
name|immediate_dirs
condition|)
name|gobble_file
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|queue_directory
argument_list|(
literal|"."
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|files_index
condition|)
block|{
name|sort_files
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|immediate_dirs
condition|)
name|extract_dirs_from_files
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* `files_index' might be zero now.  */
block|}
if|if
condition|(
name|files_index
condition|)
block|{
name|print_current_files
argument_list|()
expr_stmt|;
if|if
condition|(
name|pending_dirs
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pending_dirs
operator|&&
name|pending_dirs
operator|->
name|next
operator|==
literal|0
condition|)
name|print_dir_name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pending_dirs
condition|)
block|{
name|thispend
operator|=
name|pending_dirs
expr_stmt|;
name|pending_dirs
operator|=
name|pending_dirs
operator|->
name|next
expr_stmt|;
name|print_dir
argument_list|(
name|thispend
operator|->
name|name
argument_list|,
name|thispend
operator|->
name|realname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thispend
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|thispend
operator|->
name|realname
condition|)
name|free
argument_list|(
name|thispend
operator|->
name|realname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thispend
argument_list|)
expr_stmt|;
name|print_dir_name
operator|=
literal|1
expr_stmt|;
block|}
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"all"
block|,
literal|0
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"escape"
block|,
literal|0
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"directory"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"inode"
block|,
literal|0
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"kilobytes"
block|,
literal|0
block|,
literal|0
block|,
literal|'k'
block|}
block|,
block|{
literal|"numeric-uid-gid"
block|,
literal|0
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"hide-control-chars"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
block|{
literal|"reverse"
block|,
literal|0
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"size"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"width"
block|,
literal|1
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|"almost-all"
block|,
literal|0
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"ignore-backups"
block|,
literal|0
block|,
literal|0
block|,
literal|'B'
block|}
block|,
block|{
literal|"classify"
block|,
literal|0
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"file-type"
block|,
literal|0
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"ignore"
block|,
literal|1
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"dereference"
block|,
literal|0
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"literal"
block|,
literal|0
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"quote-name"
block|,
literal|0
block|,
literal|0
block|,
literal|'Q'
block|}
block|,
block|{
literal|"recursive"
block|,
literal|0
block|,
literal|0
block|,
literal|'R'
block|}
block|,
block|{
literal|"format"
block|,
literal|1
block|,
literal|0
block|,
literal|12
block|}
block|,
block|{
literal|"sort"
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"tabsize"
block|,
literal|1
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"time"
block|,
literal|1
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|format_args
index|[]
init|=
block|{
literal|"verbose"
block|,
literal|"long"
block|,
literal|"commas"
block|,
literal|"horizontal"
block|,
literal|"across"
block|,
literal|"vertical"
block|,
literal|"single-column"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|format
name|formats
index|[]
init|=
block|{
name|long_format
block|,
name|long_format
block|,
name|with_commas
block|,
name|horizontal
block|,
name|horizontal
block|,
name|many_per_line
block|,
name|one_per_line
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sort_args
index|[]
init|=
block|{
literal|"none"
block|,
literal|"time"
block|,
literal|"size"
block|,
literal|"extension"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|sort_type
name|sort_types
index|[]
init|=
block|{
name|sort_none
block|,
name|sort_time
block|,
name|sort_size
block|,
name|sort_extension
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|time_args
index|[]
init|=
block|{
literal|"atime"
block|,
literal|"access"
block|,
literal|"use"
block|,
literal|"ctime"
block|,
literal|"status"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|time_type
name|time_types
index|[]
init|=
block|{
name|time_atime
block|,
name|time_atime
block|,
name|time_atime
block|,
name|time_ctime
block|,
name|time_ctime
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set all the option flags according to the switches specified.    Return the index of the first non-option argument.  */
end_comment

begin_function
name|int
name|decode_switches
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|qmark_funny_chars
operator|=
literal|0
expr_stmt|;
name|quote_funny_chars
operator|=
literal|0
expr_stmt|;
comment|/* initialize all switches to default settings */
ifdef|#
directive|ifdef
name|MULTI_COL
comment|/* This is for the `dir' program.  */
name|format
operator|=
name|many_per_line
expr_stmt|;
name|quote_funny_chars
operator|=
literal|1
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|LONG_FORMAT
comment|/* This is for the `vdir' program.  */
name|format
operator|=
name|long_format
expr_stmt|;
name|quote_funny_chars
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* This is for the `ls' program.  */
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|format
operator|=
name|many_per_line
expr_stmt|;
name|qmark_funny_chars
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|format
operator|=
name|one_per_line
expr_stmt|;
name|qmark_funny_chars
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|time_type
operator|=
name|time_mtime
expr_stmt|;
name|sort_type
operator|=
name|sort_name
expr_stmt|;
name|sort_reverse
operator|=
literal|0
expr_stmt|;
name|numeric_users
operator|=
literal|0
expr_stmt|;
name|print_block_size
operator|=
literal|0
expr_stmt|;
name|kilobyte_blocks
operator|=
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|indicator_style
operator|=
name|none
expr_stmt|;
name|print_inode
operator|=
literal|0
expr_stmt|;
name|trace_links
operator|=
literal|0
expr_stmt|;
name|trace_dirs
operator|=
literal|0
expr_stmt|;
name|immediate_dirs
operator|=
literal|0
expr_stmt|;
name|all_files
operator|=
literal|0
expr_stmt|;
name|really_all_files
operator|=
literal|0
expr_stmt|;
name|ignore_patterns
operator|=
literal|0
expr_stmt|;
name|quote_as_string
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
expr_stmt|;
name|line_length
operator|=
name|p
condition|?
name|atoi
argument_list|(
name|p
argument_list|)
else|:
literal|80
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|ws
operator|.
name|ws_col
operator|!=
literal|0
condition|)
name|line_length
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
block|}
endif|#
directive|endif
name|p
operator|=
name|getenv
argument_list|(
literal|"TABSIZE"
argument_list|)
expr_stmt|;
name|tabsize
operator|=
name|p
condition|?
name|atoi
argument_list|(
name|p
argument_list|)
else|:
literal|8
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abcdgiklmnpqrstuw:xABCFI:LNQRST:UX1"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|all_files
operator|=
literal|1
expr_stmt|;
name|really_all_files
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|quote_funny_chars
operator|=
literal|1
expr_stmt|;
name|qmark_funny_chars
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|time_type
operator|=
name|time_ctime
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|immediate_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* No effect.  For BSD compatibility. */
break|break;
case|case
literal|'i'
case|:
name|print_inode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|kilobyte_blocks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|format
operator|=
name|long_format
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|format
operator|=
name|with_commas
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|numeric_users
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|indicator_style
operator|=
name|not_programs
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|qmark_funny_chars
operator|=
literal|1
expr_stmt|;
name|quote_funny_chars
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|sort_reverse
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|print_block_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|sort_type
operator|=
name|sort_time
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|time_type
operator|=
name|time_atime
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|line_length
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid line width: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|format
operator|=
name|horizontal
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|all_files
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|add_ignore_pattern
argument_list|(
literal|"*~"
argument_list|)
expr_stmt|;
name|add_ignore_pattern
argument_list|(
literal|".*~"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|format
operator|=
name|many_per_line
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|indicator_style
operator|=
name|all
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|add_ignore_pattern
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|trace_links
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|quote_funny_chars
operator|=
literal|0
expr_stmt|;
name|qmark_funny_chars
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|quote_as_string
operator|=
literal|1
expr_stmt|;
name|quote_funny_chars
operator|=
literal|1
expr_stmt|;
name|qmark_funny_chars
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|trace_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|sort_type
operator|=
name|sort_size
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tabsize
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabsize
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid tab size: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|sort_type
operator|=
name|sort_none
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|sort_type
operator|=
name|sort_extension
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|format
operator|=
name|one_per_line
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* +sort */
name|i
operator|=
name|argmatch
argument_list|(
name|optarg
argument_list|,
name|sort_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|invalid_arg
argument_list|(
literal|"sort type"
argument_list|,
name|optarg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|sort_type
operator|=
name|sort_types
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|11
case|:
comment|/* +time */
name|i
operator|=
name|argmatch
argument_list|(
name|optarg
argument_list|,
name|time_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|invalid_arg
argument_list|(
literal|"time type"
argument_list|,
name|optarg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|time_type
operator|=
name|time_types
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* +format */
name|i
operator|=
name|argmatch
argument_list|(
name|optarg
argument_list|,
name|format_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|invalid_arg
argument_list|(
literal|"format type"
argument_list|,
name|optarg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|format
operator|=
name|formats
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|optind
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Request that the directory named `name' have its contents listed later.    If `realname' is nonzero, it will be used instead of `name' when the    directory name is printed.  This allows symbolic links to directories    to be treated as regular directories but still be listed under their    real names. */
end_comment

begin_function
name|void
name|queue_directory
parameter_list|(
name|name
parameter_list|,
name|realname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|realname
decl_stmt|;
block|{
name|struct
name|pending
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|pending_dirs
expr_stmt|;
name|pending_dirs
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|realname
condition|)
name|new
operator|->
name|realname
operator|=
name|xstrdup
argument_list|(
name|realname
argument_list|)
expr_stmt|;
else|else
name|new
operator|->
name|realname
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read directory `name', and list the files in it.    If `realname' is nonzero, print its name instead of `name';    this is used for symbolic links to directories. */
end_comment

begin_function
name|void
name|print_dir
parameter_list|(
name|name
parameter_list|,
name|realname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|realname
decl_stmt|;
block|{
specifier|register
name|DIR
modifier|*
name|reading
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|total_blocks
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|reading
operator|=
name|opendir
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reading
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Read the directory entries, and insert the subfiles into the `files'      table.  */
name|clear_files
argument_list|()
expr_stmt|;
while|while
condition|(
name|next
operator|=
name|readdir
argument_list|(
name|reading
argument_list|)
condition|)
if|if
condition|(
name|file_interesting
argument_list|(
name|next
argument_list|)
condition|)
name|total_blocks
operator|+=
name|gobble_file
argument_list|(
name|next
operator|->
name|d_name
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLOSEDIR
argument_list|(
name|reading
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
comment|/* Don't return; print whatever we got. */
block|}
comment|/* Sort the directory contents.  */
name|sort_files
argument_list|()
expr_stmt|;
comment|/* If any member files are subdirectories, perhaps they should have their      contents listed rather than being mentioned here as files.  */
if|if
condition|(
name|trace_dirs
condition|)
name|extract_dirs_from_files
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_dir_name
condition|)
block|{
if|if
condition|(
name|realname
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|realname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|==
name|long_format
operator|||
name|print_block_size
condition|)
name|printf
argument_list|(
literal|"total %u\n"
argument_list|,
name|total_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|files_index
condition|)
name|print_current_files
argument_list|()
expr_stmt|;
if|if
condition|(
name|pending_dirs
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add `pattern' to the list of patterns for which files that match are    not listed.  */
end_comment

begin_function
name|void
name|add_ignore_pattern
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
specifier|register
name|struct
name|ignore_pattern
modifier|*
name|ignore
decl_stmt|;
name|ignore
operator|=
operator|(
expr|struct
name|ignore_pattern
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ignore_pattern
argument_list|)
argument_list|)
expr_stmt|;
name|ignore
operator|->
name|pattern
operator|=
name|pattern
expr_stmt|;
comment|/* Add it to the head of the linked list. */
name|ignore
operator|->
name|next
operator|=
name|ignore_patterns
expr_stmt|;
name|ignore_patterns
operator|=
name|ignore
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the file in `next' should be listed. */
end_comment

begin_function
name|int
name|file_interesting
parameter_list|(
name|next
parameter_list|)
specifier|register
name|struct
name|direct
modifier|*
name|next
decl_stmt|;
block|{
specifier|register
name|struct
name|ignore_pattern
modifier|*
name|ignore
decl_stmt|;
for|for
control|(
name|ignore
operator|=
name|ignore_patterns
init|;
name|ignore
condition|;
name|ignore
operator|=
name|ignore
operator|->
name|next
control|)
if|if
condition|(
name|fnmatch
argument_list|(
name|ignore
operator|->
name|pattern
argument_list|,
name|next
operator|->
name|d_name
argument_list|,
name|FNM_PERIOD
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|really_all_files
operator|||
name|next
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|all_files
operator|&&
name|next
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|next
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|next
operator|->
name|d_name
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enter and remove entries in the table `files'.  */
end_comment

begin_comment
comment|/* Empty the table of files. */
end_comment

begin_function
name|void
name|clear_files
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files_index
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|linkname
condition|)
name|free
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|linkname
argument_list|)
expr_stmt|;
block|}
name|files_index
operator|=
literal|0
expr_stmt|;
name|block_size_size
operator|=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a file to the current table of files.    Verify that the file exists, and print an error message if it does not.    Return the number of blocks that the file occupies.  */
end_comment

begin_function
name|int
name|gobble_file
parameter_list|(
name|name
parameter_list|,
name|explicit_arg
parameter_list|,
name|dirname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|explicit_arg
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
specifier|register
name|int
name|blocks
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|files_index
operator|==
name|nfiles
condition|)
block|{
name|nfiles
operator|*=
literal|2
expr_stmt|;
name|files
operator|=
operator|(
expr|struct
name|file
operator|*
operator|)
name|xrealloc
argument_list|(
name|files
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file
argument_list|)
operator|*
name|nfiles
argument_list|)
expr_stmt|;
block|}
name|files
index|[
name|files_index
index|]
operator|.
name|linkname
operator|=
literal|0
expr_stmt|;
name|files
index|[
name|files_index
index|]
operator|.
name|linkmode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|explicit_arg
operator|||
name|format_needs_stat
condition|)
block|{
comment|/* `path' is the absolute pathname of this file. */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|dirname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|path
operator|=
name|name
expr_stmt|;
else|else
block|{
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|attach
argument_list|(
name|path
argument_list|,
name|dirname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_links
condition|)
block|{
name|val
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|files
index|[
name|files_index
index|]
operator|.
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
comment|/* Perhaps a symbolically-linked to file doesn't exist; stat 	       the link instead. */
name|val
operator|=
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|files
index|[
name|files_index
index|]
operator|.
name|stat
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|files
index|[
name|files_index
index|]
operator|.
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|S_ISLNK
if|if
condition|(
name|S_ISLNK
argument_list|(
name|files
index|[
name|files_index
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|linkpath
decl_stmt|;
name|struct
name|stat
name|linkstats
decl_stmt|;
name|get_link_name
argument_list|(
name|path
argument_list|,
operator|&
name|files
index|[
name|files_index
index|]
argument_list|)
expr_stmt|;
name|linkpath
operator|=
name|make_link_path
argument_list|(
name|path
argument_list|,
name|files
index|[
name|files_index
index|]
operator|.
name|linkname
argument_list|)
expr_stmt|;
comment|/* Stat the file linked to; automatically trace it in non-long 	     listings, get its mode for the filetype indicator in long 	     listings. */
if|if
condition|(
name|linkpath
operator|&&
name|lstat
argument_list|(
name|linkpath
argument_list|,
operator|&
name|linkstats
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|linkstats
operator|.
name|st_mode
argument_list|)
operator|&&
name|explicit_arg
operator|&&
name|format
operator|!=
name|long_format
condition|)
block|{
name|char
modifier|*
name|tempname
decl_stmt|;
comment|/* Symbolic links to directories that are mentioned on the 		     command line are automatically traced if not being 		     listed as files. */
if|if
condition|(
operator|!
name|immediate_dirs
condition|)
block|{
name|tempname
operator|=
name|name
expr_stmt|;
name|name
operator|=
name|linkpath
expr_stmt|;
name|linkpath
operator|=
name|files
index|[
name|files_index
index|]
operator|.
name|linkname
expr_stmt|;
name|files
index|[
name|files_index
index|]
operator|.
name|linkname
operator|=
name|tempname
expr_stmt|;
block|}
name|files
index|[
name|files_index
index|]
operator|.
name|stat
operator|=
name|linkstats
expr_stmt|;
block|}
else|else
name|files
index|[
name|files_index
index|]
operator|.
name|linkmode
operator|=
name|linkstats
operator|.
name|st_mode
expr_stmt|;
block|}
if|if
condition|(
name|linkpath
condition|)
name|free
argument_list|(
name|linkpath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISLNK
if|if
condition|(
name|S_ISLNK
argument_list|(
name|files
index|[
name|files_index
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
name|files
index|[
name|files_index
index|]
operator|.
name|filetype
operator|=
name|symbolic_link
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|S_ISDIR
argument_list|(
name|files
index|[
name|files_index
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|explicit_arg
operator|&&
operator|!
name|immediate_dirs
condition|)
name|files
index|[
name|files_index
index|]
operator|.
name|filetype
operator|=
name|arg_directory
expr_stmt|;
else|else
name|files
index|[
name|files_index
index|]
operator|.
name|filetype
operator|=
name|directory
expr_stmt|;
block|}
else|else
name|files
index|[
name|files_index
index|]
operator|.
name|filetype
operator|=
name|normal
expr_stmt|;
name|blocks
operator|=
name|convert_blocks
argument_list|(
name|ST_NBLOCKS
argument_list|(
name|files
index|[
name|files_index
index|]
operator|.
name|stat
argument_list|)
argument_list|,
name|kilobyte_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks
operator|>=
literal|10000
operator|&&
name|block_size_size
operator|<
literal|5
condition|)
name|block_size_size
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|blocks
operator|>=
literal|100000
operator|&&
name|block_size_size
operator|<
literal|6
condition|)
name|block_size_size
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|blocks
operator|>=
literal|1000000
operator|&&
name|block_size_size
operator|<
literal|7
condition|)
name|block_size_size
operator|=
literal|7
expr_stmt|;
block|}
else|else
name|blocks
operator|=
literal|0
expr_stmt|;
name|files
index|[
name|files_index
index|]
operator|.
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|files_index
operator|++
expr_stmt|;
return|return
name|blocks
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|S_ISLNK
end_ifdef

begin_comment
comment|/* Put the name of the file that `filename' is a symbolic link to    into the `linkname' field of `f'. */
end_comment

begin_function
name|void
name|get_link_name
parameter_list|(
name|filename
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|linkbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|_AIX
specifier|register
name|int
name|bufsiz
init|=
name|PATH_MAX
decl_stmt|;
comment|/* st_size is wrong. */
else|#
directive|else
specifier|register
name|int
name|bufsiz
init|=
name|f
operator|->
name|stat
operator|.
name|st_size
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|linksize
decl_stmt|;
name|linkbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsiz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|linksize
operator|=
name|readlink
argument_list|(
name|filename
argument_list|,
name|linkbuf
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|linksize
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|linkbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|_AIX
name|linkbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|linkbuf
argument_list|,
name|linksize
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linkbuf
index|[
name|linksize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|->
name|linkname
operator|=
name|linkbuf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If `linkname' is a relative path and `path' contains one or more    leading directories, return `linkname' with those directories    prepended; otherwise, return a copy of `linkname'.    If `linkname' is zero, return zero. */
end_comment

begin_function
name|char
modifier|*
name|make_link_path
parameter_list|(
name|path
parameter_list|,
name|linkname
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|linkname
decl_stmt|;
block|{
name|char
modifier|*
name|linkbuf
decl_stmt|;
name|int
name|bufsiz
decl_stmt|;
if|if
condition|(
name|linkname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|linkname
operator|==
literal|'/'
condition|)
return|return
name|xstrdup
argument_list|(
name|linkname
argument_list|)
return|;
comment|/* The link is to a relative path.  Prepend any leading path      in `path' to the link name. */
name|linkbuf
operator|=
name|rindex
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkbuf
operator|==
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
name|linkname
argument_list|)
return|;
name|bufsiz
operator|=
name|linkbuf
operator|-
name|path
operator|+
literal|1
expr_stmt|;
name|linkbuf
operator|=
name|xmalloc
argument_list|(
name|bufsiz
operator|+
name|strlen
argument_list|(
name|linkname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|linkbuf
argument_list|,
name|path
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|linkbuf
operator|+
name|bufsiz
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
return|return
name|linkbuf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Remove any entries from `files' that are for directories,    and queue them to be listed as directories instead.    `dirname' is the prefix to prepend to each dirname    to make it correct relative to ls's working dir.    `recursive' is nonzero if we should not treat `.' and `..' as dirs.    This is desirable when processing directories recursively.  */
end_comment

begin_function
name|void
name|extract_dirs_from_files
parameter_list|(
name|dirname
parameter_list|,
name|recursive
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|int
name|recursive
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|dirlen
decl_stmt|;
name|dirlen
operator|=
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Queue the directories last one first, because queueing reverses the      order.  */
for|for
control|(
name|i
operator|=
name|files_index
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|files
index|[
name|i
index|]
operator|.
name|filetype
operator|==
name|directory
operator|||
name|files
index|[
name|i
index|]
operator|.
name|filetype
operator|==
name|arg_directory
operator|)
operator|&&
operator|(
operator|!
name|recursive
operator|||
name|is_not_dot_or_dotdot
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|dirname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|queue_directory
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|linkname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
name|dirlen
argument_list|)
expr_stmt|;
name|attach
argument_list|(
name|path
argument_list|,
name|dirname
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|queue_directory
argument_list|(
name|path
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|linkname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|filetype
operator|==
name|arg_directory
condition|)
name|free
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Now delete the directories from the table, compacting all the remaining      entries.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|files_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|filetype
operator|!=
name|arg_directory
condition|)
name|files
index|[
name|j
operator|++
index|]
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
name|files_index
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if `name' doesn't end in `.' or `..'    This is so we don't try to recurse on `././././. ...' */
end_comment

begin_function
name|int
name|is_not_dot_or_dotdot
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|name
operator|=
name|t
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sort the files now in the table.  */
end_comment

begin_function
name|void
name|sort_files
parameter_list|()
block|{
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
switch|switch
condition|(
name|sort_type
condition|)
block|{
case|case
name|sort_none
case|:
return|return;
case|case
name|sort_time
case|:
switch|switch
condition|(
name|time_type
condition|)
block|{
case|case
name|time_ctime
case|:
name|func
operator|=
name|sort_reverse
condition|?
name|rev_cmp_ctime
else|:
name|compare_ctime
expr_stmt|;
break|break;
case|case
name|time_mtime
case|:
name|func
operator|=
name|sort_reverse
condition|?
name|rev_cmp_mtime
else|:
name|compare_mtime
expr_stmt|;
break|break;
case|case
name|time_atime
case|:
name|func
operator|=
name|sort_reverse
condition|?
name|rev_cmp_atime
else|:
name|compare_atime
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|sort_name
case|:
name|func
operator|=
name|sort_reverse
condition|?
name|rev_cmp_name
else|:
name|compare_name
expr_stmt|;
break|break;
case|case
name|sort_extension
case|:
name|func
operator|=
name|sort_reverse
condition|?
name|rev_cmp_extension
else|:
name|compare_extension
expr_stmt|;
break|break;
case|case
name|sort_size
case|:
name|func
operator|=
name|sort_reverse
condition|?
name|rev_cmp_size
else|:
name|compare_size
expr_stmt|;
break|break;
block|}
name|qsort
argument_list|(
name|files
argument_list|,
name|files_index
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Comparison routines for sorting the files. */
end_comment

begin_function
name|int
name|compare_ctime
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_ctime
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_ctime
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|rev_cmp_ctime
parameter_list|(
name|file2
parameter_list|,
name|file1
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_ctime
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_ctime
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|compare_mtime
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_mtime
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_mtime
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|rev_cmp_mtime
parameter_list|(
name|file2
parameter_list|,
name|file1
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_mtime
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_mtime
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|compare_atime
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_atime
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_atime
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|rev_cmp_atime
parameter_list|(
name|file2
parameter_list|,
name|file1
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_atime
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_atime
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|compare_size
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_size
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_size
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|rev_cmp_size
parameter_list|(
name|file2
parameter_list|,
name|file1
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|longdiff
argument_list|(
name|file2
operator|->
name|stat
operator|.
name|st_size
argument_list|,
name|file1
operator|->
name|stat
operator|.
name|st_size
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|compare_name
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|strcmp
argument_list|(
name|file1
operator|->
name|name
argument_list|,
name|file2
operator|->
name|name
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|rev_cmp_name
parameter_list|(
name|file2
parameter_list|,
name|file1
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|strcmp
argument_list|(
name|file1
operator|->
name|name
argument_list|,
name|file2
operator|->
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Compare file extensions.  Files with no extension are `smallest'.    If extensions are the same, compare by filenames instead. */
end_comment

begin_function
name|int
name|compare_extension
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|base1
decl_stmt|,
modifier|*
name|base2
decl_stmt|;
specifier|register
name|int
name|cmp
decl_stmt|;
name|base1
operator|=
name|rindex
argument_list|(
name|file1
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|base2
operator|=
name|rindex
argument_list|(
name|file2
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|base1
operator|==
literal|0
operator|&&
name|base2
operator|==
literal|0
condition|)
return|return
name|strcmp
argument_list|(
name|file1
operator|->
name|name
argument_list|,
name|file2
operator|->
name|name
argument_list|)
return|;
if|if
condition|(
name|base1
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|base2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|cmp
operator|=
name|strcmp
argument_list|(
name|base1
argument_list|,
name|base2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
name|strcmp
argument_list|(
name|file1
operator|->
name|name
argument_list|,
name|file2
operator|->
name|name
argument_list|)
return|;
return|return
name|cmp
return|;
block|}
end_block

begin_function
name|int
name|rev_cmp_extension
parameter_list|(
name|file2
parameter_list|,
name|file1
parameter_list|)
name|struct
name|file
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|base1
decl_stmt|,
modifier|*
name|base2
decl_stmt|;
specifier|register
name|int
name|cmp
decl_stmt|;
name|base1
operator|=
name|rindex
argument_list|(
name|file1
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|base2
operator|=
name|rindex
argument_list|(
name|file2
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|base1
operator|==
literal|0
operator|&&
name|base2
operator|==
literal|0
condition|)
return|return
name|strcmp
argument_list|(
name|file1
operator|->
name|name
argument_list|,
name|file2
operator|->
name|name
argument_list|)
return|;
if|if
condition|(
name|base1
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|base2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|cmp
operator|=
name|strcmp
argument_list|(
name|base1
argument_list|,
name|base2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
name|strcmp
argument_list|(
name|file1
operator|->
name|name
argument_list|,
name|file2
operator|->
name|name
argument_list|)
return|;
return|return
name|cmp
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* List all the files now in the table.  */
end_comment

begin_function
name|void
name|print_current_files
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|one_per_line
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files_index
condition|;
name|i
operator|++
control|)
block|{
name|print_file_name_and_frills
argument_list|(
name|files
operator|+
name|i
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|many_per_line
case|:
name|print_many_per_line
argument_list|()
expr_stmt|;
break|break;
case|case
name|horizontal
case|:
name|print_horizontal
argument_list|()
expr_stmt|;
break|break;
case|case
name|with_commas
case|:
name|print_with_commas
argument_list|()
expr_stmt|;
break|break;
case|case
name|long_format
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files_index
condition|;
name|i
operator|++
control|)
block|{
name|print_long_format
argument_list|(
name|files
operator|+
name|i
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|void
name|print_long_format
parameter_list|(
name|f
parameter_list|)
name|struct
name|file
modifier|*
name|f
decl_stmt|;
block|{
name|char
name|modebuf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|timebuf
index|[
literal|40
index|]
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|mode_string
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_mode
argument_list|,
name|modebuf
argument_list|)
expr_stmt|;
name|modebuf
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|time_type
condition|)
block|{
case|case
name|time_ctime
case|:
name|when
operator|=
name|f
operator|->
name|stat
operator|.
name|st_ctime
expr_stmt|;
break|break;
case|case
name|time_mtime
case|:
name|when
operator|=
name|f
operator|->
name|stat
operator|.
name|st_mtime
expr_stmt|;
break|break;
case|case
name|time_atime
case|:
name|when
operator|=
name|f
operator|->
name|stat
operator|.
name|st_atime
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|timebuf
argument_list|,
name|ctime
argument_list|(
operator|&
name|when
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_time
operator|>
name|when
operator|+
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
comment|/* Old. */
operator|||
name|current_time
operator|<
name|when
operator|-
literal|60L
operator|*
literal|60L
condition|)
comment|/* In the future. */
block|{
comment|/* The file is fairly old or in the future. 	 POSIX says the cutoff is 6 months old; 	 approximate this by 6*30 days. 	 Allow a 1 hour slop factor for what is considered "the future", 	 to allow for NFS server/client clock disagreement. 	 Show the year instead of the time of day.  */
name|strcpy
argument_list|(
name|timebuf
operator|+
literal|11
argument_list|,
name|timebuf
operator|+
literal|19
argument_list|)
expr_stmt|;
block|}
name|timebuf
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|print_inode
condition|)
name|printf
argument_list|(
literal|"%6u "
argument_list|,
name|f
operator|->
name|stat
operator|.
name|st_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_block_size
condition|)
name|printf
argument_list|(
literal|"%*u "
argument_list|,
name|block_size_size
argument_list|,
name|convert_blocks
argument_list|(
name|ST_NBLOCKS
argument_list|(
name|f
operator|->
name|stat
argument_list|)
argument_list|,
name|kilobyte_blocks
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The space between the mode and the number of links is the POSIX      "optional alternate access method flag". */
name|printf
argument_list|(
literal|"%s %3u "
argument_list|,
name|modebuf
argument_list|,
name|f
operator|->
name|stat
operator|.
name|st_nlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric_users
condition|)
name|printf
argument_list|(
literal|"%-8u "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|f
operator|->
name|stat
operator|.
name|st_uid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-8.8s "
argument_list|,
name|getuser
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_uid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric_users
condition|)
name|printf
argument_list|(
literal|"%-8u "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|f
operator|->
name|stat
operator|.
name|st_gid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-8.8s "
argument_list|,
name|getgroup
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISCHR
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISBLK
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%3u, %3u "
argument_list|,
name|major
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%8lu "
argument_list|,
name|f
operator|->
name|stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|timebuf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_name_with_quoting
argument_list|(
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|filetype
operator|==
name|symbolic_link
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|linkname
condition|)
block|{
name|fputs
argument_list|(
literal|" -> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_name_with_quoting
argument_list|(
name|f
operator|->
name|linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|indicator_style
operator|!=
name|none
condition|)
name|print_type_indicator
argument_list|(
name|f
operator|->
name|linkmode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|indicator_style
operator|!=
name|none
condition|)
name|print_type_indicator
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_name_with_quoting
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|quote_as_string
condition|)
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|quote_funny_chars
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|printf
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|printf
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|printf
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|printf
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|printf
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|printf
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|qmark_funny_chars
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote_as_string
condition|)
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the file name of `f' with appropriate quoting.    Also print file size, inode number, and filetype indicator character,    as requested by switches.  */
end_comment

begin_function
name|void
name|print_file_name_and_frills
parameter_list|(
name|f
parameter_list|)
name|struct
name|file
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|print_inode
condition|)
name|printf
argument_list|(
literal|"%6u "
argument_list|,
name|f
operator|->
name|stat
operator|.
name|st_ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_block_size
condition|)
name|printf
argument_list|(
literal|"%*u "
argument_list|,
name|block_size_size
argument_list|,
name|convert_blocks
argument_list|(
name|ST_NBLOCKS
argument_list|(
name|f
operator|->
name|stat
argument_list|)
argument_list|,
name|kilobyte_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|print_name_with_quoting
argument_list|(
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|indicator_style
operator|!=
name|none
condition|)
name|print_type_indicator
argument_list|(
name|f
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_type_indicator
parameter_list|(
name|mode
parameter_list|)
name|unsigned
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISLNK
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISFIFO
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|mode
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISSOCK
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|mode
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|S_ISREG
argument_list|(
name|mode
argument_list|)
operator|&&
name|indicator_style
operator|==
name|all
operator|&&
operator|(
name|mode
operator|&
operator|(
name|S_IEXEC
operator||
name|S_IEXEC
operator|>>
literal|3
operator||
name|S_IEXEC
operator|>>
literal|6
operator|)
operator|)
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|length_of_file_name_and_frills
parameter_list|(
name|f
parameter_list|)
name|struct
name|file
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|f
operator|->
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|print_inode
condition|)
name|len
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|print_block_size
condition|)
name|len
operator|+=
literal|1
operator|+
name|block_size_size
expr_stmt|;
if|if
condition|(
name|quote_as_string
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|quote_funny_chars
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|' '
case|:
name|len
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|quote_as_string
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
else|else
name|len
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
else|else
name|len
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
name|len
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|indicator_style
operator|!=
name|none
condition|)
block|{
name|unsigned
name|filetype
init|=
name|f
operator|->
name|stat
operator|.
name|st_mode
decl_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|filetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|indicator_style
operator|==
name|all
operator|&&
operator|(
name|f
operator|->
name|stat
operator|.
name|st_mode
operator|&
operator|(
name|S_IEXEC
operator||
name|S_IEXEC
operator|>>
literal|3
operator||
name|S_IEXEC
operator|>>
literal|6
operator|)
operator|)
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|filetype
argument_list|)
ifdef|#
directive|ifdef
name|S_ISLNK
operator|||
name|S_ISLNK
argument_list|(
name|filetype
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISFIFO
operator|||
name|S_ISFIFO
argument_list|(
name|filetype
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|filetype
argument_list|)
endif|#
directive|endif
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_many_per_line
parameter_list|()
block|{
name|int
name|filesno
decl_stmt|;
comment|/* Index into files. */
name|int
name|row
decl_stmt|;
comment|/* Current row. */
name|int
name|max_name_length
decl_stmt|;
comment|/* Length of longest file name + frills. */
name|int
name|name_length
decl_stmt|;
comment|/* Length of each file name + frills. */
name|int
name|pos
decl_stmt|;
comment|/* Current character column. */
name|int
name|cols
decl_stmt|;
comment|/* Number of files across. */
name|int
name|rows
decl_stmt|;
comment|/* Maximum number of files down. */
comment|/* Compute the maximum file name length.  */
name|max_name_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|filesno
operator|=
literal|0
init|;
name|filesno
operator|<
name|files_index
condition|;
name|filesno
operator|++
control|)
block|{
name|name_length
operator|=
name|length_of_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|max_name_length
condition|)
name|max_name_length
operator|=
name|name_length
expr_stmt|;
block|}
comment|/* Allow at least two spaces between names.  */
name|max_name_length
operator|+=
literal|2
expr_stmt|;
comment|/* Calculate the maximum number of columns that will fit. */
name|cols
operator|=
name|line_length
operator|/
name|max_name_length
expr_stmt|;
if|if
condition|(
name|cols
operator|==
literal|0
condition|)
name|cols
operator|=
literal|1
expr_stmt|;
comment|/* Calculate the number of rows that will be in each column except possibly      for a short column on the right. */
name|rows
operator|=
name|files_index
operator|/
name|cols
operator|+
operator|(
name|files_index
operator|%
name|cols
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Recalculate columns based on rows. */
name|cols
operator|=
name|files_index
operator|/
name|rows
operator|+
operator|(
name|files_index
operator|%
name|rows
operator|!=
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
name|filesno
operator|=
name|row
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
comment|/* Print the next row.  */
while|while
condition|(
literal|1
condition|)
block|{
name|print_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|length_of_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
name|filesno
operator|+=
name|rows
expr_stmt|;
if|if
condition|(
name|filesno
operator|>=
name|files_index
condition|)
break|break;
name|indent
argument_list|(
name|pos
operator|+
name|name_length
argument_list|,
name|pos
operator|+
name|max_name_length
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|max_name_length
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_horizontal
parameter_list|()
block|{
name|int
name|filesno
decl_stmt|;
name|int
name|max_name_length
decl_stmt|;
name|int
name|name_length
decl_stmt|;
name|int
name|cols
decl_stmt|;
name|int
name|pos
decl_stmt|;
comment|/* Compute the maximum file name length.  */
name|max_name_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|filesno
operator|=
literal|0
init|;
name|filesno
operator|<
name|files_index
condition|;
name|filesno
operator|++
control|)
block|{
name|name_length
operator|=
name|length_of_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|>
name|max_name_length
condition|)
name|max_name_length
operator|=
name|name_length
expr_stmt|;
block|}
comment|/* Allow two spaces between names.  */
name|max_name_length
operator|+=
literal|2
expr_stmt|;
name|cols
operator|=
name|line_length
operator|/
name|max_name_length
expr_stmt|;
if|if
condition|(
name|cols
operator|==
literal|0
condition|)
name|cols
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|name_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|filesno
operator|=
literal|0
init|;
name|filesno
operator|<
name|files_index
condition|;
name|filesno
operator|++
control|)
block|{
if|if
condition|(
name|filesno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|filesno
operator|%
name|cols
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|indent
argument_list|(
name|pos
operator|+
name|name_length
argument_list|,
name|pos
operator|+
name|max_name_length
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|max_name_length
expr_stmt|;
block|}
block|}
name|print_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|length_of_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_with_commas
parameter_list|()
block|{
name|int
name|filesno
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|old_pos
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|filesno
operator|=
literal|0
init|;
name|filesno
operator|<
name|files_index
condition|;
name|filesno
operator|++
control|)
block|{
name|old_pos
operator|=
name|pos
expr_stmt|;
name|pos
operator|+=
name|length_of_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesno
operator|+
literal|1
operator|<
name|files_index
condition|)
name|pos
operator|+=
literal|2
expr_stmt|;
comment|/* For the comma and space */
if|if
condition|(
name|old_pos
operator|!=
literal|0
operator|&&
name|pos
operator|>=
name|line_length
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|pos
operator|-=
name|old_pos
expr_stmt|;
block|}
name|print_file_name_and_frills
argument_list|(
name|files
operator|+
name|filesno
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesno
operator|+
literal|1
operator|<
name|files_index
condition|)
block|{
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming cursor is at position FROM, indent up to position TO.  */
end_comment

begin_function
name|void
name|indent
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
while|while
condition|(
name|from
operator|<
name|to
condition|)
block|{
if|if
condition|(
name|to
operator|/
name|tabsize
operator|>
name|from
operator|/
name|tabsize
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|from
operator|+=
name|tabsize
operator|-
name|from
operator|%
name|tabsize
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Put DIRNAME/NAME into DEST, handling `.' and `/' properly. */
end_comment

begin_function
name|void
name|attach
parameter_list|(
name|dest
parameter_list|,
name|dirname
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|,
decl|*
name|dirname
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|dirnamep
init|=
name|dirname
decl_stmt|;
comment|/* Copy dirname if it is not ".". */
if|if
condition|(
name|dirname
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dirname
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|dirnamep
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|dirnamep
operator|++
expr_stmt|;
comment|/* Add '/' if `dirname' doesn't already end with it. */
if|if
condition|(
name|dirnamep
operator|>
name|dirname
operator|&&
name|dirnamep
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|name
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-abcdgiklmnpqrstuxABCFLNQRSUX1] [-w cols] [-T cols] [-I pattern]\n\        [--all] [--escape] [--directory] [--inode] [--kilobytes] [--literal]\n\        [--numeric-uid-gid] [--hide-control-chars] [--reverse] [--size]\n\        [--width=cols] [--tabsize=cols] [--almost-all] [--ignore-backups]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\        [--classify] [--file-type] [--ignore=pattern] [--dereference]\n\        [--quote-name] [--recursive] [--sort={none,time,size,extension}]\n\        [--format={long,verbose,commas,across,vertical,single-column}]\n\        [--time={atime,access,use,ctime,status}] [path...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

