begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dd -- convert a file while copying it.    Copyright (C) 1985, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Paul Rubin, David MacKenzie, and Stuart Kemp. */
end_comment

begin_comment
comment|/* Options:     Numbers can be followed by a multiplier:    b=512, k=1024, w=2, xm=number m     if=FILE			Read from FILE instead of stdin.    of=FILE			Write to FILE instead of stdout; don't 				truncate FILE.    ibs=BYTES			Read BYTES bytes at a time.    obs=BYTES			Write BYTES bytes at a time.    bs=BYTES			Override ibs and obs.    cbs=BYTES			Convert BYTES bytes at a time.    skip=BLOCKS			Skip BLOCKS ibs-sized blocks at 				start of input.    seek=BLOCKS			Skip BLOCKS obs-sized blocks at 				start of output.    count=BLOCKS			Copy only BLOCKS input blocks.    conv=CONVERSION[,CONVERSION...]     Conversions:    ascii			Convert EBCDIC to ASCII.    ebcdic			Convert ASCII to EBCDIC.    ibm				Convert ASCII to alternate EBCDIC.    block			Pad newline-terminated records to size of 				cbs, replacing newline with trailing spaces.    unblock			Replace trailing spaces in cbs-sized block 				with newline.    lcase			Change uppercase characters to lowercase.    ucase			Change lowercase characters to uppercase.    swab				Swap every pair of input bytes. 				Unlike the Unix dd, this works when an odd 				number of bytes are read.    noerror			Continue after read errors.    sync				Pad every input block to size of ibs with 				trailing NULs. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_define
define|#
directive|define
name|ISLOWER
value|islower
end_define

begin_define
define|#
directive|define
name|ISUPPER
value|isupper
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISLOWER
parameter_list|(
name|c
parameter_list|)
value|(isascii ((c))&& islower ((c)))
end_define

begin_define
define|#
directive|define
name|ISUPPER
parameter_list|(
name|c
parameter_list|)
value|(isascii ((c))&& isupper ((c)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_define
define|#
directive|define
name|equal
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
value|(strcmp ((p),(q)) == 0)
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|output_char
parameter_list|(
name|c
parameter_list|)
define|\
value|do { \   obuf[oc++] = (c); if (oc>= output_blocksize) write_output (); \   } while (0)
end_define

begin_comment
comment|/* Default input and output blocksize. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_BLOCKSIZE
value|512
end_define

begin_comment
comment|/* Conversions bit masks. */
end_comment

begin_define
define|#
directive|define
name|C_ASCII
value|01
end_define

begin_define
define|#
directive|define
name|C_EBCDIC
value|02
end_define

begin_define
define|#
directive|define
name|C_IBM
value|04
end_define

begin_define
define|#
directive|define
name|C_BLOCK
value|010
end_define

begin_define
define|#
directive|define
name|C_UNBLOCK
value|020
end_define

begin_define
define|#
directive|define
name|C_LCASE
value|040
end_define

begin_define
define|#
directive|define
name|C_UCASE
value|0100
end_define

begin_define
define|#
directive|define
name|C_SWAB
value|0200
end_define

begin_define
define|#
directive|define
name|C_NOERROR
value|0400
end_define

begin_define
define|#
directive|define
name|C_NOTRUNC
value|01000
end_define

begin_define
define|#
directive|define
name|C_SYNC
value|02000
end_define

begin_comment
comment|/* Use separate input and output buffers, and combine partial input blocks. */
end_comment

begin_define
define|#
directive|define
name|C_TWOBUFS
value|04000
end_define

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|SIGTYPE
name|interrupt_handler
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bit_count
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|parse_integer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|apply_translations
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|copy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|copy_simple
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|copy_with_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|copy_with_unblock
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parse_conversion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_stats
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|translate_charset
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|quit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|scanargs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|skip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_output
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the input file, or NULL for the standard input. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The input file descriptor. */
end_comment

begin_decl_stmt
name|int
name|input_fd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the output file, or NULL for the standard output. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The output file descriptor. */
end_comment

begin_decl_stmt
name|int
name|output_fd
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of bytes in which atomic reads are done. */
end_comment

begin_decl_stmt
name|long
name|input_blocksize
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of bytes in which atomic writes are done. */
end_comment

begin_decl_stmt
name|long
name|output_blocksize
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conversion buffer size, in bytes.  0 prevents conversions. */
end_comment

begin_decl_stmt
name|long
name|conversion_blocksize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Skip this many records of `input_blocksize' bytes before input. */
end_comment

begin_decl_stmt
name|long
name|skip_records
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Skip this many records of `output_blocksize' bytes before output. */
end_comment

begin_decl_stmt
name|long
name|seek_record
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy only this many records.<0 means no limit. */
end_comment

begin_decl_stmt
name|int
name|max_records
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit vector of conversions to apply. */
end_comment

begin_decl_stmt
name|int
name|conversions_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, filter characters through the translation table.  */
end_comment

begin_decl_stmt
name|int
name|translation_needed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of partial blocks written. */
end_comment

begin_decl_stmt
name|unsigned
name|w_partial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of full blocks written. */
end_comment

begin_decl_stmt
name|unsigned
name|w_full
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of partial blocks read. */
end_comment

begin_decl_stmt
name|unsigned
name|r_partial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of full blocks read. */
end_comment

begin_decl_stmt
name|unsigned
name|r_full
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records truncated by conv=block. */
end_comment

begin_decl_stmt
name|unsigned
name|r_truncate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output representation of newline and space characters.    They change if we're converting to EBCDIC.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|newline_character
init|=
literal|'\n'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|space_character
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|conversion
block|{
name|char
modifier|*
name|convname
decl_stmt|;
name|int
name|conversion
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|conversion
name|conversions
index|[]
init|=
block|{
literal|"ascii"
block|,
name|C_ASCII
operator||
name|C_TWOBUFS
block|,
comment|/* EBCDIC to ASCII. */
literal|"ebcdic"
block|,
name|C_EBCDIC
operator||
name|C_TWOBUFS
block|,
comment|/* ASCII to EBCDIC. */
literal|"ibm"
block|,
name|C_IBM
operator||
name|C_TWOBUFS
block|,
comment|/* Slightly different ASCII to EBCDIC. */
literal|"block"
block|,
name|C_BLOCK
operator||
name|C_TWOBUFS
block|,
comment|/* Variable to fixed length records. */
literal|"unblock"
block|,
name|C_UNBLOCK
operator||
name|C_TWOBUFS
block|,
comment|/* Fixed to variable length records. */
literal|"lcase"
block|,
name|C_LCASE
operator||
name|C_TWOBUFS
block|,
comment|/* Translate upper to lower case. */
literal|"ucase"
block|,
name|C_UCASE
operator||
name|C_TWOBUFS
block|,
comment|/* Translate lower to upper case. */
literal|"swab"
block|,
name|C_SWAB
operator||
name|C_TWOBUFS
block|,
comment|/* Swap bytes of input. */
literal|"noerror"
block|,
name|C_NOERROR
block|,
comment|/* Ignore i/o errors. */
literal|"notrunc"
block|,
name|C_NOTRUNC
block|,
comment|/* Do not truncate output file. */
literal|"sync"
block|,
name|C_SYNC
block|,
comment|/* Pad input records to ibs with NULs. */
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table formed by applying successive transformations. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|trans_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|ascii_to_ebcdic
index|[]
init|=
block|{
literal|0
block|,
literal|01
block|,
literal|02
block|,
literal|03
block|,
literal|067
block|,
literal|055
block|,
literal|056
block|,
literal|057
block|,
literal|026
block|,
literal|05
block|,
literal|045
block|,
literal|013
block|,
literal|014
block|,
literal|015
block|,
literal|016
block|,
literal|017
block|,
literal|020
block|,
literal|021
block|,
literal|022
block|,
literal|023
block|,
literal|074
block|,
literal|075
block|,
literal|062
block|,
literal|046
block|,
literal|030
block|,
literal|031
block|,
literal|077
block|,
literal|047
block|,
literal|034
block|,
literal|035
block|,
literal|036
block|,
literal|037
block|,
literal|0100
block|,
literal|0117
block|,
literal|0177
block|,
literal|0173
block|,
literal|0133
block|,
literal|0154
block|,
literal|0120
block|,
literal|0175
block|,
literal|0115
block|,
literal|0135
block|,
literal|0134
block|,
literal|0116
block|,
literal|0153
block|,
literal|0140
block|,
literal|0113
block|,
literal|0141
block|,
literal|0360
block|,
literal|0361
block|,
literal|0362
block|,
literal|0363
block|,
literal|0364
block|,
literal|0365
block|,
literal|0366
block|,
literal|0367
block|,
literal|0370
block|,
literal|0371
block|,
literal|0172
block|,
literal|0136
block|,
literal|0114
block|,
literal|0176
block|,
literal|0156
block|,
literal|0157
block|,
literal|0174
block|,
literal|0301
block|,
literal|0302
block|,
literal|0303
block|,
literal|0304
block|,
literal|0305
block|,
literal|0306
block|,
literal|0307
block|,
literal|0310
block|,
literal|0311
block|,
literal|0321
block|,
literal|0322
block|,
literal|0323
block|,
literal|0324
block|,
literal|0325
block|,
literal|0326
block|,
literal|0327
block|,
literal|0330
block|,
literal|0331
block|,
literal|0342
block|,
literal|0343
block|,
literal|0344
block|,
literal|0345
block|,
literal|0346
block|,
literal|0347
block|,
literal|0350
block|,
literal|0351
block|,
literal|0112
block|,
literal|0340
block|,
literal|0132
block|,
literal|0137
block|,
literal|0155
block|,
literal|0171
block|,
literal|0201
block|,
literal|0202
block|,
literal|0203
block|,
literal|0204
block|,
literal|0205
block|,
literal|0206
block|,
literal|0207
block|,
literal|0210
block|,
literal|0211
block|,
literal|0221
block|,
literal|0222
block|,
literal|0223
block|,
literal|0224
block|,
literal|0225
block|,
literal|0226
block|,
literal|0227
block|,
literal|0230
block|,
literal|0231
block|,
literal|0242
block|,
literal|0243
block|,
literal|0244
block|,
literal|0245
block|,
literal|0246
block|,
literal|0247
block|,
literal|0250
block|,
literal|0251
block|,
literal|0300
block|,
literal|0152
block|,
literal|0320
block|,
literal|0241
block|,
literal|07
block|,
literal|040
block|,
literal|041
block|,
literal|042
block|,
literal|043
block|,
literal|044
block|,
literal|025
block|,
literal|06
block|,
literal|027
block|,
literal|050
block|,
literal|051
block|,
literal|052
block|,
literal|053
block|,
literal|054
block|,
literal|011
block|,
literal|012
block|,
literal|033
block|,
literal|060
block|,
literal|061
block|,
literal|032
block|,
literal|063
block|,
literal|064
block|,
literal|065
block|,
literal|066
block|,
literal|010
block|,
literal|070
block|,
literal|071
block|,
literal|072
block|,
literal|073
block|,
literal|04
block|,
literal|024
block|,
literal|076
block|,
literal|0341
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0142
block|,
literal|0143
block|,
literal|0144
block|,
literal|0145
block|,
literal|0146
block|,
literal|0147
block|,
literal|0150
block|,
literal|0151
block|,
literal|0160
block|,
literal|0161
block|,
literal|0162
block|,
literal|0163
block|,
literal|0164
block|,
literal|0165
block|,
literal|0166
block|,
literal|0167
block|,
literal|0170
block|,
literal|0200
block|,
literal|0212
block|,
literal|0213
block|,
literal|0214
block|,
literal|0215
block|,
literal|0216
block|,
literal|0217
block|,
literal|0220
block|,
literal|0232
block|,
literal|0233
block|,
literal|0234
block|,
literal|0235
block|,
literal|0236
block|,
literal|0237
block|,
literal|0240
block|,
literal|0252
block|,
literal|0253
block|,
literal|0254
block|,
literal|0255
block|,
literal|0256
block|,
literal|0257
block|,
literal|0260
block|,
literal|0261
block|,
literal|0262
block|,
literal|0263
block|,
literal|0264
block|,
literal|0265
block|,
literal|0266
block|,
literal|0267
block|,
literal|0270
block|,
literal|0271
block|,
literal|0272
block|,
literal|0273
block|,
literal|0274
block|,
literal|0275
block|,
literal|0276
block|,
literal|0277
block|,
literal|0312
block|,
literal|0313
block|,
literal|0314
block|,
literal|0315
block|,
literal|0316
block|,
literal|0317
block|,
literal|0332
block|,
literal|0333
block|,
literal|0334
block|,
literal|0335
block|,
literal|0336
block|,
literal|0337
block|,
literal|0352
block|,
literal|0353
block|,
literal|0354
block|,
literal|0355
block|,
literal|0356
block|,
literal|0357
block|,
literal|0372
block|,
literal|0373
block|,
literal|0374
block|,
literal|0375
block|,
literal|0376
block|,
literal|0377
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|ascii_to_ibm
index|[]
init|=
block|{
literal|0
block|,
literal|01
block|,
literal|02
block|,
literal|03
block|,
literal|067
block|,
literal|055
block|,
literal|056
block|,
literal|057
block|,
literal|026
block|,
literal|05
block|,
literal|045
block|,
literal|013
block|,
literal|014
block|,
literal|015
block|,
literal|016
block|,
literal|017
block|,
literal|020
block|,
literal|021
block|,
literal|022
block|,
literal|023
block|,
literal|074
block|,
literal|075
block|,
literal|062
block|,
literal|046
block|,
literal|030
block|,
literal|031
block|,
literal|077
block|,
literal|047
block|,
literal|034
block|,
literal|035
block|,
literal|036
block|,
literal|037
block|,
literal|0100
block|,
literal|0132
block|,
literal|0177
block|,
literal|0173
block|,
literal|0133
block|,
literal|0154
block|,
literal|0120
block|,
literal|0175
block|,
literal|0115
block|,
literal|0135
block|,
literal|0134
block|,
literal|0116
block|,
literal|0153
block|,
literal|0140
block|,
literal|0113
block|,
literal|0141
block|,
literal|0360
block|,
literal|0361
block|,
literal|0362
block|,
literal|0363
block|,
literal|0364
block|,
literal|0365
block|,
literal|0366
block|,
literal|0367
block|,
literal|0370
block|,
literal|0371
block|,
literal|0172
block|,
literal|0136
block|,
literal|0114
block|,
literal|0176
block|,
literal|0156
block|,
literal|0157
block|,
literal|0174
block|,
literal|0301
block|,
literal|0302
block|,
literal|0303
block|,
literal|0304
block|,
literal|0305
block|,
literal|0306
block|,
literal|0307
block|,
literal|0310
block|,
literal|0311
block|,
literal|0321
block|,
literal|0322
block|,
literal|0323
block|,
literal|0324
block|,
literal|0325
block|,
literal|0326
block|,
literal|0327
block|,
literal|0330
block|,
literal|0331
block|,
literal|0342
block|,
literal|0343
block|,
literal|0344
block|,
literal|0345
block|,
literal|0346
block|,
literal|0347
block|,
literal|0350
block|,
literal|0351
block|,
literal|0255
block|,
literal|0340
block|,
literal|0275
block|,
literal|0137
block|,
literal|0155
block|,
literal|0171
block|,
literal|0201
block|,
literal|0202
block|,
literal|0203
block|,
literal|0204
block|,
literal|0205
block|,
literal|0206
block|,
literal|0207
block|,
literal|0210
block|,
literal|0211
block|,
literal|0221
block|,
literal|0222
block|,
literal|0223
block|,
literal|0224
block|,
literal|0225
block|,
literal|0226
block|,
literal|0227
block|,
literal|0230
block|,
literal|0231
block|,
literal|0242
block|,
literal|0243
block|,
literal|0244
block|,
literal|0245
block|,
literal|0246
block|,
literal|0247
block|,
literal|0250
block|,
literal|0251
block|,
literal|0300
block|,
literal|0117
block|,
literal|0320
block|,
literal|0241
block|,
literal|07
block|,
literal|040
block|,
literal|041
block|,
literal|042
block|,
literal|043
block|,
literal|044
block|,
literal|025
block|,
literal|06
block|,
literal|027
block|,
literal|050
block|,
literal|051
block|,
literal|052
block|,
literal|053
block|,
literal|054
block|,
literal|011
block|,
literal|012
block|,
literal|033
block|,
literal|060
block|,
literal|061
block|,
literal|032
block|,
literal|063
block|,
literal|064
block|,
literal|065
block|,
literal|066
block|,
literal|010
block|,
literal|070
block|,
literal|071
block|,
literal|072
block|,
literal|073
block|,
literal|04
block|,
literal|024
block|,
literal|076
block|,
literal|0341
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0121
block|,
literal|0122
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0142
block|,
literal|0143
block|,
literal|0144
block|,
literal|0145
block|,
literal|0146
block|,
literal|0147
block|,
literal|0150
block|,
literal|0151
block|,
literal|0160
block|,
literal|0161
block|,
literal|0162
block|,
literal|0163
block|,
literal|0164
block|,
literal|0165
block|,
literal|0166
block|,
literal|0167
block|,
literal|0170
block|,
literal|0200
block|,
literal|0212
block|,
literal|0213
block|,
literal|0214
block|,
literal|0215
block|,
literal|0216
block|,
literal|0217
block|,
literal|0220
block|,
literal|0232
block|,
literal|0233
block|,
literal|0234
block|,
literal|0235
block|,
literal|0236
block|,
literal|0237
block|,
literal|0240
block|,
literal|0252
block|,
literal|0253
block|,
literal|0254
block|,
literal|0255
block|,
literal|0256
block|,
literal|0257
block|,
literal|0260
block|,
literal|0261
block|,
literal|0262
block|,
literal|0263
block|,
literal|0264
block|,
literal|0265
block|,
literal|0266
block|,
literal|0267
block|,
literal|0270
block|,
literal|0271
block|,
literal|0272
block|,
literal|0273
block|,
literal|0274
block|,
literal|0275
block|,
literal|0276
block|,
literal|0277
block|,
literal|0312
block|,
literal|0313
block|,
literal|0314
block|,
literal|0315
block|,
literal|0316
block|,
literal|0317
block|,
literal|0332
block|,
literal|0333
block|,
literal|0334
block|,
literal|0335
block|,
literal|0336
block|,
literal|0337
block|,
literal|0352
block|,
literal|0353
block|,
literal|0354
block|,
literal|0355
block|,
literal|0356
block|,
literal|0357
block|,
literal|0372
block|,
literal|0373
block|,
literal|0374
block|,
literal|0375
block|,
literal|0376
block|,
literal|0377
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|ebcdic_to_ascii
index|[]
init|=
block|{
literal|0
block|,
literal|01
block|,
literal|02
block|,
literal|03
block|,
literal|0234
block|,
literal|011
block|,
literal|0206
block|,
literal|0177
block|,
literal|0227
block|,
literal|0215
block|,
literal|0216
block|,
literal|013
block|,
literal|014
block|,
literal|015
block|,
literal|016
block|,
literal|017
block|,
literal|020
block|,
literal|021
block|,
literal|022
block|,
literal|023
block|,
literal|0235
block|,
literal|0205
block|,
literal|010
block|,
literal|0207
block|,
literal|030
block|,
literal|031
block|,
literal|0222
block|,
literal|0217
block|,
literal|034
block|,
literal|035
block|,
literal|036
block|,
literal|037
block|,
literal|0200
block|,
literal|0201
block|,
literal|0202
block|,
literal|0203
block|,
literal|0204
block|,
literal|012
block|,
literal|027
block|,
literal|033
block|,
literal|0210
block|,
literal|0211
block|,
literal|0212
block|,
literal|0213
block|,
literal|0214
block|,
literal|05
block|,
literal|06
block|,
literal|07
block|,
literal|0220
block|,
literal|0221
block|,
literal|026
block|,
literal|0223
block|,
literal|0224
block|,
literal|0225
block|,
literal|0226
block|,
literal|04
block|,
literal|0230
block|,
literal|0231
block|,
literal|0232
block|,
literal|0233
block|,
literal|024
block|,
literal|025
block|,
literal|0236
block|,
literal|032
block|,
literal|040
block|,
literal|0240
block|,
literal|0241
block|,
literal|0242
block|,
literal|0243
block|,
literal|0244
block|,
literal|0245
block|,
literal|0246
block|,
literal|0247
block|,
literal|0250
block|,
literal|0133
block|,
literal|056
block|,
literal|074
block|,
literal|050
block|,
literal|053
block|,
literal|041
block|,
literal|046
block|,
literal|0251
block|,
literal|0252
block|,
literal|0253
block|,
literal|0254
block|,
literal|0255
block|,
literal|0256
block|,
literal|0257
block|,
literal|0260
block|,
literal|0261
block|,
literal|0135
block|,
literal|044
block|,
literal|052
block|,
literal|051
block|,
literal|073
block|,
literal|0136
block|,
literal|055
block|,
literal|057
block|,
literal|0262
block|,
literal|0263
block|,
literal|0264
block|,
literal|0265
block|,
literal|0266
block|,
literal|0267
block|,
literal|0270
block|,
literal|0271
block|,
literal|0174
block|,
literal|054
block|,
literal|045
block|,
literal|0137
block|,
literal|076
block|,
literal|077
block|,
literal|0272
block|,
literal|0273
block|,
literal|0274
block|,
literal|0275
block|,
literal|0276
block|,
literal|0277
block|,
literal|0300
block|,
literal|0301
block|,
literal|0302
block|,
literal|0140
block|,
literal|072
block|,
literal|043
block|,
literal|0100
block|,
literal|047
block|,
literal|075
block|,
literal|042
block|,
literal|0303
block|,
literal|0141
block|,
literal|0142
block|,
literal|0143
block|,
literal|0144
block|,
literal|0145
block|,
literal|0146
block|,
literal|0147
block|,
literal|0150
block|,
literal|0151
block|,
literal|0304
block|,
literal|0305
block|,
literal|0306
block|,
literal|0307
block|,
literal|0310
block|,
literal|0311
block|,
literal|0312
block|,
literal|0152
block|,
literal|0153
block|,
literal|0154
block|,
literal|0155
block|,
literal|0156
block|,
literal|0157
block|,
literal|0160
block|,
literal|0161
block|,
literal|0162
block|,
literal|0313
block|,
literal|0314
block|,
literal|0315
block|,
literal|0316
block|,
literal|0317
block|,
literal|0320
block|,
literal|0321
block|,
literal|0176
block|,
literal|0163
block|,
literal|0164
block|,
literal|0165
block|,
literal|0166
block|,
literal|0167
block|,
literal|0170
block|,
literal|0171
block|,
literal|0172
block|,
literal|0322
block|,
literal|0323
block|,
literal|0324
block|,
literal|0325
block|,
literal|0326
block|,
literal|0327
block|,
literal|0330
block|,
literal|0331
block|,
literal|0332
block|,
literal|0333
block|,
literal|0334
block|,
literal|0335
block|,
literal|0336
block|,
literal|0337
block|,
literal|0340
block|,
literal|0341
block|,
literal|0342
block|,
literal|0343
block|,
literal|0344
block|,
literal|0345
block|,
literal|0346
block|,
literal|0347
block|,
literal|0173
block|,
literal|0101
block|,
literal|0102
block|,
literal|0103
block|,
literal|0104
block|,
literal|0105
block|,
literal|0106
block|,
literal|0107
block|,
literal|0110
block|,
literal|0111
block|,
literal|0350
block|,
literal|0351
block|,
literal|0352
block|,
literal|0353
block|,
literal|0354
block|,
literal|0355
block|,
literal|0175
block|,
literal|0112
block|,
literal|0113
block|,
literal|0114
block|,
literal|0115
block|,
literal|0116
block|,
literal|0117
block|,
literal|0120
block|,
literal|0121
block|,
literal|0122
block|,
literal|0356
block|,
literal|0357
block|,
literal|0360
block|,
literal|0361
block|,
literal|0362
block|,
literal|0363
block|,
literal|0134
block|,
literal|0237
block|,
literal|0123
block|,
literal|0124
block|,
literal|0125
block|,
literal|0126
block|,
literal|0127
block|,
literal|0130
block|,
literal|0131
block|,
literal|0132
block|,
literal|0364
block|,
literal|0365
block|,
literal|0366
block|,
literal|0367
block|,
literal|0370
block|,
literal|0371
block|,
literal|060
block|,
literal|061
block|,
literal|062
block|,
literal|063
block|,
literal|064
block|,
literal|065
block|,
literal|066
block|,
literal|067
block|,
literal|070
block|,
literal|071
block|,
literal|0372
block|,
literal|0373
block|,
literal|0374
block|,
literal|0375
block|,
literal|0376
block|,
literal|0377
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|struct
name|sigaction
name|sigact
decl_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VERSION */
name|int
name|i
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Initialize translation table to identity translation. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|trans_table
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Decode arguments. */
name|scanargs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|apply_translations
argument_list|()
expr_stmt|;
if|if
condition|(
name|input_file
operator|!=
name|NULL
condition|)
block|{
name|input_fd
operator|=
name|open
argument_list|(
name|input_file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
block|}
else|else
name|input_file
operator|=
literal|"standard input"
expr_stmt|;
if|if
condition|(
name|input_fd
operator|==
name|output_fd
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"standard %s is closed"
argument_list|,
name|input_fd
operator|==
literal|0
condition|?
literal|"input"
else|:
literal|"output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_file
operator|!=
name|NULL
condition|)
block|{
name|int
name|omode
init|=
name|O_RDWR
operator||
name|O_CREAT
decl_stmt|;
if|if
condition|(
name|seek_record
operator|==
literal|0
operator|&&
operator|!
operator|(
name|conversions_mask
operator|&
name|C_NOTRUNC
operator|)
condition|)
name|omode
operator||=
name|O_TRUNC
expr_stmt|;
name|output_fd
operator|=
name|open
argument_list|(
name|output_file
argument_list|,
name|omode
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FTRUNCATE_MISSING
if|if
condition|(
name|seek_record
operator|>
literal|0
operator|&&
operator|!
operator|(
name|conversions_mask
operator|&
name|C_NOTRUNC
operator|)
condition|)
block|{
if|if
condition|(
name|ftruncate
argument_list|(
name|output_fd
argument_list|,
name|seek_record
operator|*
name|output_blocksize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|output_file
operator|=
literal|"standard output"
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|sigact
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigact
operator|.
name|sa_handler
operator|=
name|interrupt_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sigact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sigact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !_POSIX_VERSION */
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !_POSIX_VERSION */
name|copy
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Throw away RECORDS blocks of BLOCKSIZE bytes on file descriptor FDESC,    which is open with read permission for FILE.  Store up to BLOCKSIZE    bytes of the data at a time in BUF, if necessary. */
end_comment

begin_function
name|void
name|skip
parameter_list|(
name|fdesc
parameter_list|,
name|file
parameter_list|,
name|records
parameter_list|,
name|blocksize
parameter_list|,
name|buf
parameter_list|)
name|int
name|fdesc
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|long
name|records
decl_stmt|;
name|long
name|blocksize
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|stat
name|stats
decl_stmt|;
comment|/* Use fstat instead of checking for errno == ESPIPE because      lseek doesn't work on some special files but doesn't return an      error, either. */
if|if
condition|(
name|fstat
argument_list|(
name|fdesc
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fdesc
argument_list|,
name|records
operator|*
name|blocksize
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|records
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|fdesc
argument_list|,
name|buf
argument_list|,
name|blocksize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME If fewer bytes were read than requested, meaning that 	     EOF was reached, POSIX wants the output file padded with NULs. */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Apply the character-set translations specified by the user    to the NREAD bytes in BUF.  */
end_comment

begin_function
name|void
name|translate_buffer
parameter_list|(
name|buf
parameter_list|,
name|nread
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nread
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nread
operator|,
name|cp
operator|=
name|buf
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|cp
operator|++
control|)
operator|*
name|cp
operator|=
name|trans_table
index|[
operator|*
name|cp
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If nonnzero, the last char from the previous call to `swab_buffer'    is saved in `saved_char'.  */
end_comment

begin_decl_stmt
name|int
name|char_is_saved
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Odd char from previous call.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|saved_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap NREAD bytes in BUF, plus possibly an initial char from the    previous call.  If NREAD is odd, save the last char for the    next call.   Return the new start of the BUF buffer.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|swab_buffer
parameter_list|(
name|buf
parameter_list|,
name|nread
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|nread
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|bufstart
init|=
name|buf
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Is a char left from last time?  */
if|if
condition|(
name|char_is_saved
condition|)
block|{
operator|*
operator|--
name|bufstart
operator|=
name|saved_char
expr_stmt|;
operator|*
name|nread
operator|++
expr_stmt|;
name|char_is_saved
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nread
operator|&
literal|1
condition|)
block|{
comment|/* An odd number of chars are in the buffer.  */
name|saved_char
operator|=
name|bufstart
index|[
operator|--
operator|*
name|nread
index|]
expr_stmt|;
name|char_is_saved
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Do the byte-swapping by moving every second character two      positions toward the end, working from the end of the buffer      toward the beginning.  This way we only move half of the data.  */
name|cp
operator|=
name|bufstart
operator|+
operator|*
name|nread
expr_stmt|;
comment|/* Start one char past the last.  */
for|for
control|(
name|i
operator|=
operator|*
name|nread
operator|/
literal|2
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|cp
operator|-=
literal|2
control|)
operator|*
name|cp
operator|=
operator|*
operator|(
name|cp
operator|-
literal|2
operator|)
expr_stmt|;
return|return
operator|++
name|bufstart
return|;
block|}
end_function

begin_comment
comment|/* Output buffer. */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current index into `obuf'. */
end_comment

begin_decl_stmt
name|int
name|oc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into current line, for `conv=block' and `conv=unblock'.  */
end_comment

begin_decl_stmt
name|int
name|col
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The main loop.  */
end_comment

begin_function
name|void
name|copy
parameter_list|()
block|{
name|unsigned
name|char
modifier|*
name|ibuf
decl_stmt|,
modifier|*
name|bufstart
decl_stmt|;
comment|/* Input buffer. */
name|int
name|nread
decl_stmt|;
comment|/* Bytes read in the current block. */
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
comment|/* Leave an extra byte at the beginning and end of `ibuf' for conv=swab.  */
name|ibuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|input_blocksize
operator|+
literal|2
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|conversions_mask
operator|&
name|C_TWOBUFS
condition|)
name|obuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|output_blocksize
argument_list|)
expr_stmt|;
else|else
name|obuf
operator|=
name|ibuf
expr_stmt|;
if|if
condition|(
name|skip_records
operator|>
literal|0
condition|)
name|skip
argument_list|(
name|input_fd
argument_list|,
name|input_file
argument_list|,
name|skip_records
argument_list|,
name|input_blocksize
argument_list|,
name|ibuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|seek_record
operator|>
literal|0
condition|)
name|skip
argument_list|(
name|output_fd
argument_list|,
name|output_file
argument_list|,
name|seek_record
argument_list|,
name|output_blocksize
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_records
operator|==
literal|0
condition|)
name|quit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|max_records
operator|>=
literal|0
operator|&&
name|r_partial
operator|+
name|r_full
operator|>=
name|max_records
condition|)
break|break;
comment|/* Zero the buffer before reading, so that if we get a read error, 	 whatever data we are able to read is followed by zeros. 	 This minimizes data loss. */
if|if
condition|(
operator|(
name|conversions_mask
operator|&
name|C_SYNC
operator|)
operator|&&
operator|(
name|conversions_mask
operator|&
name|C_NOERROR
operator|)
condition|)
name|bzero
argument_list|(
name|ibuf
argument_list|,
name|input_blocksize
argument_list|)
expr_stmt|;
name|nread
operator|=
name|read
argument_list|(
name|input_fd
argument_list|,
name|ibuf
argument_list|,
name|input_blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
break|break;
comment|/* EOF.  */
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|conversions_mask
operator|&
name|C_NOERROR
condition|)
block|{
name|print_stats
argument_list|()
expr_stmt|;
comment|/* Seek past the bad block if possible. */
name|lseek
argument_list|(
name|input_fd
argument_list|,
name|input_blocksize
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|conversions_mask
operator|&
name|C_SYNC
condition|)
comment|/* Replace the missing input with null bytes and 		   proceed normally.  */
name|nread
operator|=
literal|0
expr_stmt|;
else|else
continue|continue;
block|}
else|else
block|{
comment|/* Write any partial block. */
name|exit_status
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nread
operator|<
name|input_blocksize
condition|)
block|{
name|r_partial
operator|++
expr_stmt|;
if|if
condition|(
name|conversions_mask
operator|&
name|C_SYNC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|conversions_mask
operator|&
name|C_NOERROR
operator|)
condition|)
comment|/* If C_NOERROR, we zeroed the block before reading. */
name|bzero
argument_list|(
name|ibuf
operator|+
name|nread
argument_list|,
name|input_blocksize
operator|-
name|nread
argument_list|)
expr_stmt|;
name|nread
operator|=
name|input_blocksize
expr_stmt|;
block|}
block|}
else|else
name|r_full
operator|++
expr_stmt|;
if|if
condition|(
name|ibuf
operator|==
name|obuf
condition|)
comment|/* If not C_TWOBUFS. */
block|{
name|int
name|nwritten
init|=
name|write
argument_list|(
name|output_fd
argument_list|,
name|obuf
argument_list|,
name|nread
argument_list|)
decl_stmt|;
if|if
condition|(
name|nwritten
operator|!=
name|nread
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwritten
operator|>
literal|0
condition|)
name|w_partial
operator|++
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nread
operator|==
name|input_blocksize
condition|)
name|w_full
operator|++
expr_stmt|;
else|else
name|w_partial
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Do any translations on the whole buffer at once.  */
if|if
condition|(
name|translation_needed
condition|)
name|translate_buffer
argument_list|(
name|ibuf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|conversions_mask
operator|&
name|C_SWAB
condition|)
name|bufstart
operator|=
name|swab_buffer
argument_list|(
name|ibuf
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
else|else
name|bufstart
operator|=
name|ibuf
expr_stmt|;
if|if
condition|(
name|conversions_mask
operator|&
name|C_BLOCK
condition|)
name|copy_with_block
argument_list|(
name|bufstart
argument_list|,
name|nread
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|conversions_mask
operator|&
name|C_UNBLOCK
condition|)
name|copy_with_unblock
argument_list|(
name|bufstart
argument_list|,
name|nread
argument_list|)
expr_stmt|;
else|else
name|copy_simple
argument_list|(
name|bufstart
argument_list|,
name|nread
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a char left as a result of conv=swab, output it.  */
if|if
condition|(
name|char_is_saved
condition|)
block|{
if|if
condition|(
name|conversions_mask
operator|&
name|C_BLOCK
condition|)
name|copy_with_block
argument_list|(
operator|&
name|saved_char
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|conversions_mask
operator|&
name|C_UNBLOCK
condition|)
name|copy_with_unblock
argument_list|(
operator|&
name|saved_char
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|output_char
argument_list|(
name|saved_char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|conversions_mask
operator|&
name|C_BLOCK
operator|)
operator|&&
name|col
operator|>
literal|0
condition|)
block|{
comment|/* If the final input line didn't end with a '\n', pad 	 the output block to `conversion_blocksize' chars.  */
name|int
name|pending_spaces
init|=
name|max
argument_list|(
literal|0
argument_list|,
name|conversion_blocksize
operator|-
name|col
argument_list|)
decl_stmt|;
while|while
condition|(
name|pending_spaces
operator|--
condition|)
name|output_char
argument_list|(
name|space_character
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|conversions_mask
operator|&
name|C_UNBLOCK
operator|)
operator|&&
name|col
operator|==
name|conversion_blocksize
condition|)
comment|/* Add a final '\n' if there are exactly `conversion_blocksize'        characters in the final record. */
name|output_char
argument_list|(
name|newline_character
argument_list|)
expr_stmt|;
comment|/* Write out the last block. */
if|if
condition|(
name|oc
operator|>
literal|0
condition|)
block|{
name|int
name|nwritten
init|=
name|write
argument_list|(
name|output_fd
argument_list|,
name|obuf
argument_list|,
name|oc
argument_list|)
decl_stmt|;
if|if
condition|(
name|nwritten
operator|>
literal|0
condition|)
name|w_partial
operator|++
expr_stmt|;
if|if
condition|(
name|nwritten
operator|!=
name|oc
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ibuf
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obuf
operator|!=
name|ibuf
condition|)
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy NREAD bytes of BUF, with no conversions.  */
end_comment

begin_function
name|void
name|copy_simple
parameter_list|(
name|buf
parameter_list|,
name|nread
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nread
decl_stmt|;
block|{
name|int
name|nfree
decl_stmt|;
comment|/* Number of unused bytes in `obuf'.  */
name|unsigned
name|char
modifier|*
name|start
init|=
name|buf
decl_stmt|;
comment|/* First uncopied char in BUF.  */
do|do
block|{
name|nfree
operator|=
name|output_blocksize
operator|-
name|oc
expr_stmt|;
if|if
condition|(
name|nfree
operator|>
name|nread
condition|)
name|nfree
operator|=
name|nread
expr_stmt|;
name|bcopy
argument_list|(
name|start
argument_list|,
name|obuf
operator|+
name|oc
argument_list|,
name|nfree
argument_list|)
expr_stmt|;
name|nread
operator|-=
name|nfree
expr_stmt|;
comment|/* Update the number of bytes left to copy. */
name|start
operator|+=
name|nfree
expr_stmt|;
name|oc
operator|+=
name|nfree
expr_stmt|;
if|if
condition|(
name|oc
operator|>=
name|output_blocksize
condition|)
name|write_output
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|nread
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Copy NREAD bytes of BUF, doing conv=block    (pad newline-terminated records to `conversion_blocksize',    replacing the newline with trailing spaces).  */
end_comment

begin_function
name|void
name|copy_with_block
parameter_list|(
name|buf
parameter_list|,
name|nread
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nread
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nread
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|buf
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
name|newline_character
condition|)
block|{
name|int
name|pending_spaces
init|=
name|max
argument_list|(
literal|0
argument_list|,
name|conversion_blocksize
operator|-
name|col
argument_list|)
decl_stmt|;
while|while
condition|(
name|pending_spaces
operator|--
condition|)
name|output_char
argument_list|(
name|space_character
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|col
operator|==
name|conversion_blocksize
condition|)
name|r_truncate
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|col
operator|<
name|conversion_blocksize
condition|)
name|output_char
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy NREAD bytes of BUF, doing conv=unblock    (replace trailing spaces in `conversion_blocksize'-sized records    with a newline).  */
end_comment

begin_function
name|void
name|copy_with_unblock
parameter_list|(
name|buf
parameter_list|,
name|nread
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nread
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|static
name|int
name|pending_spaces
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nread
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|col
operator|++
operator|>=
name|conversion_blocksize
condition|)
block|{
name|col
operator|=
name|pending_spaces
operator|=
literal|0
expr_stmt|;
comment|/* Wipe out any pending spaces.  */
name|i
operator|--
expr_stmt|;
comment|/* Push the char back; get it later. */
name|output_char
argument_list|(
name|newline_character
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|space_character
condition|)
name|pending_spaces
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pending_spaces
condition|)
block|{
comment|/* `c' is the character after a run of spaces that were not 		 at the end of the conversion buffer.  Output them.  */
while|while
condition|(
name|pending_spaces
operator|--
condition|)
name|output_char
argument_list|(
name|space_character
argument_list|)
expr_stmt|;
block|}
name|output_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write, then empty, the output buffer `obuf'. */
end_comment

begin_function
name|void
name|write_output
parameter_list|()
block|{
name|int
name|nwritten
init|=
name|write
argument_list|(
name|output_fd
argument_list|,
name|obuf
argument_list|,
name|output_blocksize
argument_list|)
decl_stmt|;
if|if
condition|(
name|nwritten
operator|!=
name|output_blocksize
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwritten
operator|>
literal|0
condition|)
name|w_partial
operator|++
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|w_full
operator|++
expr_stmt|;
name|oc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scanargs
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|val
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
name|usage
argument_list|(
literal|"unrecognized option `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"if"
argument_list|)
condition|)
name|input_file
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"of"
argument_list|)
condition|)
name|output_file
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"conv"
argument_list|)
condition|)
name|parse_conversion
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|parse_integer
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid number `%s'"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"ibs"
argument_list|)
condition|)
block|{
name|input_blocksize
operator|=
name|n
expr_stmt|;
name|conversions_mask
operator||=
name|C_TWOBUFS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"obs"
argument_list|)
condition|)
block|{
name|output_blocksize
operator|=
name|n
expr_stmt|;
name|conversions_mask
operator||=
name|C_TWOBUFS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"bs"
argument_list|)
condition|)
name|output_blocksize
operator|=
name|input_blocksize
operator|=
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"cbs"
argument_list|)
condition|)
name|conversion_blocksize
operator|=
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"skip"
argument_list|)
condition|)
name|skip_records
operator|=
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"seek"
argument_list|)
condition|)
name|seek_record
operator|=
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|equal
argument_list|(
name|name
argument_list|,
literal|"count"
argument_list|)
condition|)
name|max_records
operator|=
name|n
expr_stmt|;
else|else
name|usage
argument_list|(
literal|"unrecognized option `%s=%s'"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If bs= was given, both `input_blocksize' and `output_blocksize' will      have been set to non-negative values.  If either has not been set,      bs= was not given, so make sure two buffers are used. */
if|if
condition|(
name|input_blocksize
operator|==
operator|-
literal|1
operator|||
name|output_blocksize
operator|==
operator|-
literal|1
condition|)
name|conversions_mask
operator||=
name|C_TWOBUFS
expr_stmt|;
if|if
condition|(
name|input_blocksize
operator|==
operator|-
literal|1
condition|)
name|input_blocksize
operator|=
name|DEFAULT_BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|output_blocksize
operator|==
operator|-
literal|1
condition|)
name|output_blocksize
operator|=
name|DEFAULT_BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|conversion_blocksize
operator|==
literal|0
condition|)
name|conversions_mask
operator|&=
operator|~
operator|(
name|C_BLOCK
operator||
name|C_UNBLOCK
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the value of STR, interpreted as a non-negative decimal integer,    optionally multiplied by various values.    Return -1 if STR does not represent a number in this format. */
end_comment

begin_function
name|int
name|parse_integer
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|loop
label|:
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|n
return|;
case|case
literal|'b'
case|:
name|n
operator|*=
literal|512
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'k'
case|:
name|n
operator|*=
literal|1024
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'w'
case|:
name|n
operator|*=
literal|2
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'x'
case|:
name|temp
operator|=
name|parse_integer
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|*=
name|temp
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Interpret one "conv=..." option. */
end_comment

begin_function
name|void
name|parse_conversion
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|i
decl_stmt|;
do|do
block|{
name|new
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
operator|*
name|new
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|conversions
index|[
name|i
index|]
operator|.
name|convname
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|conversions
index|[
name|i
index|]
operator|.
name|convname
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|conversions_mask
operator||=
name|conversions
index|[
name|i
index|]
operator|.
name|conversion
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|conversions
index|[
name|i
index|]
operator|.
name|convname
operator|==
name|NULL
condition|)
block|{
name|usage
argument_list|(
literal|"%s: invalid conversion"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|new
expr_stmt|;
block|}
do|while
condition|(
name|new
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Fix up translation table. */
end_comment

begin_function
name|void
name|apply_translations
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|MX
parameter_list|(
name|a
parameter_list|)
value|(bit_count (conversions_mask& (a)))
if|if
condition|(
operator|(
name|MX
argument_list|(
name|C_ASCII
operator||
name|C_EBCDIC
operator||
name|C_IBM
argument_list|)
operator|>
literal|1
operator|)
operator|||
operator|(
name|MX
argument_list|(
name|C_BLOCK
operator||
name|C_UNBLOCK
argument_list|)
operator|>
literal|1
operator|)
operator|||
operator|(
name|MX
argument_list|(
name|C_LCASE
operator||
name|C_UCASE
argument_list|)
operator|>
literal|1
operator|)
operator|||
operator|(
name|MX
argument_list|(
name|C_UNBLOCK
operator||
name|C_SYNC
argument_list|)
operator|>
literal|1
operator|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ only one conv in {ascii,ebcdic,ibm}, {lcase,ucase}, {block,unblock}, {unblock,sync}"
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|MX
if|if
condition|(
name|conversions_mask
operator|&
name|C_ASCII
condition|)
name|translate_charset
argument_list|(
name|ebcdic_to_ascii
argument_list|)
expr_stmt|;
if|if
condition|(
name|conversions_mask
operator|&
name|C_UCASE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISLOWER
argument_list|(
name|trans_table
index|[
name|i
index|]
argument_list|)
condition|)
name|trans_table
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|trans_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|translation_needed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conversions_mask
operator|&
name|C_LCASE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|trans_table
index|[
name|i
index|]
argument_list|)
condition|)
name|trans_table
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|trans_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|translation_needed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|conversions_mask
operator|&
name|C_EBCDIC
condition|)
block|{
name|translate_charset
argument_list|(
name|ascii_to_ebcdic
argument_list|)
expr_stmt|;
name|newline_character
operator|=
name|ascii_to_ebcdic
index|[
literal|'\n'
index|]
expr_stmt|;
name|space_character
operator|=
name|ascii_to_ebcdic
index|[
literal|' '
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conversions_mask
operator|&
name|C_IBM
condition|)
block|{
name|translate_charset
argument_list|(
name|ascii_to_ibm
argument_list|)
expr_stmt|;
name|newline_character
operator|=
name|ascii_to_ibm
index|[
literal|'\n'
index|]
expr_stmt|;
name|space_character
operator|=
name|ascii_to_ibm
index|[
literal|' '
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|translate_charset
parameter_list|(
name|new_trans
parameter_list|)
name|unsigned
name|char
modifier|*
name|new_trans
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|trans_table
index|[
name|i
index|]
operator|=
name|new_trans
index|[
name|trans_table
index|[
name|i
index|]
index|]
expr_stmt|;
name|translation_needed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of 1 bits in `i'. */
end_comment

begin_function
name|int
name|bit_count
parameter_list|(
name|i
parameter_list|)
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|int
name|set_bits
decl_stmt|;
for|for
control|(
name|set_bits
operator|=
literal|0
init|;
name|i
operator|!=
literal|0
condition|;
name|set_bits
operator|++
control|)
name|i
operator|&=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|set_bits
return|;
block|}
end_function

begin_function
name|void
name|print_stats
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%u+%u records in\n"
argument_list|,
name|r_full
argument_list|,
name|r_partial
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%u+%u records out\n"
argument_list|,
name|w_full
argument_list|,
name|w_partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_truncate
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%u truncated block%s\n"
argument_list|,
name|r_truncate
argument_list|,
name|r_truncate
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|quit
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
name|int
name|errcode
init|=
name|code
condition|?
name|code
else|:
literal|1
decl_stmt|;
name|print_stats
argument_list|()
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|input_fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|errcode
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|output_fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|errcode
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|output_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SIGTYPE
name|interrupt_handler
parameter_list|()
block|{
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|string
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|arg0
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [if=file] [of=file] [ibs=bytes] [obs=bytes] [bs=bytes] [cbs=bytes]\n\        [skip=blocks] [seek=blocks] [count=blocks]\n\        [conv={ascii,ebcdic,ibm,block,unblock,lcase,ucase,swab,noerror,notrunc,\n\        sync}]\n\ Numbers can be followed by a multiplier:\n\ b=512, k=1024, w=2, xm=number m\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

