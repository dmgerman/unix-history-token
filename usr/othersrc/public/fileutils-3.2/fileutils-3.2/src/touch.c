begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* touch -- change modification and access times of files    Copyright (C) 1987, 1989, 1990, 1991 Free Software Foundation Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Options:    -a, --time={atime,access,use}	Change access time only.    -c, --no-create		Do not create files that do not exist.    -d, --date=TIME		Specify time and date in various formats.    -m, --time={mtime,modify}	Change modification time only.    -r, --file=FILE		Use the time and date of reference file FILE.    -t TIME			Specify time and date in the form 				`MMDDhhmm[[CC]YY][.ss]'.        If no options are given, -am is the default, using the current time.    The -r, -t, and -d options are mutually exclusive.  If a file does not    exist, create it unless -c is given.     Written by Paul Rubin, Arnold Robbins, Jim Kingdon, David MacKenzie,    and Randy Smith. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|time_t
name|mktime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|argmatch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|touch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|get_date
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|posixtime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|invalid_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Bitmasks for `change_times'. */
end_comment

begin_define
define|#
directive|define
name|CH_ATIME
value|1
end_define

begin_define
define|#
directive|define
name|CH_MTIME
value|2
end_define

begin_comment
comment|/* Which timestamps to change. */
end_comment

begin_decl_stmt
name|int
name|change_times
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-c) If nonzero, don't create if not already there. */
end_comment

begin_decl_stmt
name|int
name|no_create
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-d) If nonzero, date supplied on command line in get_date formats. */
end_comment

begin_decl_stmt
name|int
name|flexible_date
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-r) If nonzero, use times from a reference file. */
end_comment

begin_decl_stmt
name|int
name|use_ref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (-t) If nonzero, date supplied on command line in POSIX format. */
end_comment

begin_decl_stmt
name|int
name|posix_date
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, the only thing we have to do is change both the    modification and access time to the current time, so we don't    have to own the file, just be able to read and write it.  */
end_comment

begin_decl_stmt
name|int
name|amtime_now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New time to use when setting time. */
end_comment

begin_decl_stmt
name|time_t
name|newtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File to use for -r. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ref_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info about the reference file. */
end_comment

begin_decl_stmt
name|struct
name|stat
name|ref_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name by which this program was run. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"time"
block|,
literal|1
block|,
literal|0
block|,
literal|130
block|}
block|,
block|{
literal|"no-create"
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"date"
block|,
literal|1
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Valid arguments to the `--time' option. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|time_args
index|[]
init|=
block|{
literal|"atime"
block|,
literal|"access"
block|,
literal|"use"
block|,
literal|"mtime"
block|,
literal|"modify"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bits in `change_times' that those arguments set. */
end_comment

begin_decl_stmt
name|int
name|time_masks
index|[]
init|=
block|{
name|CH_ATIME
block|,
name|CH_ATIME
block|,
name|CH_ATIME
block|,
name|CH_MTIME
block|,
name|CH_MTIME
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|date_set
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|change_times
operator|=
name|no_create
operator|=
name|use_ref
operator|=
name|posix_date
operator|=
name|flexible_date
operator|=
literal|0
expr_stmt|;
name|newtime
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"acd:mr:t:"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|change_times
operator||=
name|CH_ATIME
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|no_create
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flexible_date
operator|++
expr_stmt|;
name|newtime
operator|=
name|get_date
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid date format `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|date_set
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|change_times
operator||=
name|CH_MTIME
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|use_ref
operator|++
expr_stmt|;
name|ref_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|posix_date
operator|++
expr_stmt|;
name|newtime
operator|=
name|posixtime
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid date format `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|date_set
operator|++
expr_stmt|;
break|break;
case|case
literal|130
case|:
name|i
operator|=
name|argmatch
argument_list|(
name|optarg
argument_list|,
name|time_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|invalid_arg
argument_list|(
literal|"time selector"
argument_list|,
name|optarg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|change_times
operator||=
name|time_masks
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|change_times
operator|==
literal|0
condition|)
name|change_times
operator|=
name|CH_ATIME
operator||
name|CH_MTIME
expr_stmt|;
if|if
condition|(
operator|(
name|use_ref
operator|&&
operator|(
name|posix_date
operator|||
name|flexible_date
operator|)
operator|)
operator|||
operator|(
name|posix_date
operator|&&
name|flexible_date
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot specify times from more than one source"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|use_ref
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|ref_file
argument_list|,
operator|&
name|ref_stats
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|ref_file
argument_list|)
expr_stmt|;
name|date_set
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|date_set
operator|&&
name|optind
operator|<
name|argc
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|optind
operator|-
literal|1
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|newtime
operator|=
name|posixtime
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtime
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|optind
operator|++
expr_stmt|;
name|date_set
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|date_set
condition|)
block|{
if|if
condition|(
operator|(
name|change_times
operator|&
operator|(
name|CH_ATIME
operator||
name|CH_MTIME
operator|)
operator|)
operator|==
operator|(
name|CH_ATIME
operator||
name|CH_MTIME
operator|)
condition|)
name|amtime_now
operator|=
literal|1
expr_stmt|;
else|else
name|time
argument_list|(
operator|&
name|newtime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file arguments missing"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
name|err
operator|+=
name|touch
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|err
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the time of file FILE according to the options given.    Return 0 if successful, 1 if an error occurs. */
end_comment

begin_function
name|int
name|touch
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|no_create
condition|)
return|return
literal|0
return|;
name|fd
operator|=
name|creat
argument_list|(
name|file
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|amtime_now
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* We've done all we have to. */
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|amtime_now
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|UTIME_NULL_MISSING
argument_list|)
name|status
operator|=
name|utime_now
argument_list|(
name|file
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Pass NULL to utime so it will not fail if we just have 	 write access to the file, but don't own it.  */
name|status
operator|=
name|utime
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
if|if
condition|(
name|use_ref
condition|)
block|{
name|utb
operator|.
name|actime
operator|=
name|ref_stats
operator|.
name|st_atime
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|ref_stats
operator|.
name|st_mtime
expr_stmt|;
block|}
else|else
name|utb
operator|.
name|actime
operator|=
name|utb
operator|.
name|modtime
operator|=
name|newtime
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|change_times
operator|&
name|CH_ATIME
operator|)
condition|)
name|utb
operator|.
name|actime
operator|=
name|sbuf
operator|.
name|st_atime
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|change_times
operator|&
name|CH_MTIME
operator|)
condition|)
name|utb
operator|.
name|modtime
operator|=
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
name|status
operator|=
name|utime
argument_list|(
name|file
argument_list|,
operator|&
name|utb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UTIME_NULL_MISSING
argument_list|)
end_if

begin_comment
comment|/* Emulate utime (file, NULL) for systems (like 4.3BSD) that do not    interpret it to set the access and modification times of FILE to    the current time.  FILESIZE is the correct size of FILE, used to    make sure empty files are not lengthened to 1 byte.    Return 0 if successful, -1 if not. */
end_comment

begin_function
name|int
name|utime_now
parameter_list|(
name|file
parameter_list|,
name|filesize
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|off_t
name|filesize
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|<
literal|0
operator|||
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|filesize
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-acm] [-r reference-file] [-t MMDDhhmm[[CC]YY][.ss]]\n\        [-d time] [--time={atime,access,use,mtime,modify}] [--date=time]\n\        [--file=reference-file] [--no-create] file...\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

