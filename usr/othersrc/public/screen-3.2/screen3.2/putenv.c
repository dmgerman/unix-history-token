begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1991  *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)  *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)  * Copyright (c) 1987 Oliver Laumann  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 1, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program (see the file COPYING); if not, write to the  * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  *  * Noteworthy contributors to screen's design and implementation:  *	Wayne Davison (davison@borland.com)  *	Patrick Wolfe (pat@kai.com, kailand!pat)  *	Bart Schaefer (schaefer@cse.ogi.edu)  *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)  *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)  *	Howard Chu (hyc@hanauma.jpl.nasa.gov)  *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)  *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)  *	Marc Boucher (marc@CAM.ORG)  *  ****************************************************************  */
end_comment

begin_comment
comment|/*  *  putenv  --  put value into environment  *  *  Usage:  i = putenv (string)  *    int i;  *    char  *string;  *  *  where string is of the form<name>=<value>.  *  If "value" is 0, then "name" will be deleted from the environment.  *  Putenv returns 0 normally, -1 on error (not enough core for malloc).  *  *  Putenv may need to add a new name into the environment, or to  *  associate a value longer than the current value with a particular  *  name.  So, to make life simpler, putenv() copies your entire  *  environment into the heap (i.e. malloc()) from the stack  *  (i.e. where it resides when your process is initiated) the first  *  time you call it.  *  *  HISTORY  *  3-Sep-91 Michael Schroeder (mlschroe). Modified to behave as  *    as putenv.  * 16-Aug-91 Tim MacKenzie (tym) at Monash University. Modified for  *    use in screen (iScreen) (ignores final int parameter)  * 14-Oct-85 Michael Mauldin (mlm) at Carnegie-Mellon University  *      Ripped out of CMU lib for Rob-O-Matic portability  * 20-Nov-79  Steven Shafer (sas) at Carnegie-Mellon University  *    Created for VAX.  Too bad Bell Labs didn't provide this.  It's  *    unfortunate that you have to copy the whole environment onto the  *    heap, but the bookkeeping-and-not-so-much-copying approach turns  *    out to be much hairier.  So, I decided to do the simple thing,  *    copying the entire environment onto the heap the first time you  *    call putenv(), then doing realloc() uniformly later on.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEEDSETENV
argument_list|)
end_if

begin_define
define|#
directive|define
name|EXTRASIZE
value|5
end_define

begin_comment
comment|/* increment to add to env. size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|strlen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|envsize
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current size of environment */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the global which is your env. */
end_comment

begin_function_decl
specifier|static
name|int
name|findenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* look for a name in the env. */
end_comment

begin_function_decl
specifier|static
name|int
name|newenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* copy env. from stack to heap */
end_comment

begin_function_decl
specifier|static
name|int
name|moreenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* incr. size of env. */
end_comment

begin_function
name|int
name|unsetenv
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|findenv
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
comment|/* Already here */
name|free
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|envsize
operator|>
literal|0
condition|)
name|envsize
operator|--
expr_stmt|;
for|for
control|(
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|environ
index|[
name|i
index|]
operator|=
name|environ
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
name|int
name|putenv
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|envsize
operator|<
literal|0
condition|)
block|{
comment|/* first time putenv called */
if|if
condition|(
name|newenv
argument_list|()
operator|<
literal|0
condition|)
comment|/* copy env. to heap */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|i
operator|=
name|findenv
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* look for name in environment */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* name must be added */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
name|envsize
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* need new slot */
if|if
condition|(
name|moreenv
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
comment|/* not enough core */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|environ
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* new end of env. */
block|}
else|else
block|{
comment|/* name already in env. */
name|p
operator|=
name|realloc
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* copy into env. */
name|environ
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|findenv
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|namechar
decl_stmt|,
modifier|*
name|envchar
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
name|envchar
operator|=
name|environ
index|[
name|i
index|]
expr_stmt|;
name|namechar
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|namechar
operator|&&
operator|*
name|namechar
operator|!=
literal|'='
operator|&&
operator|(
operator|*
name|namechar
operator|==
operator|*
name|envchar
operator|)
condition|)
block|{
name|namechar
operator|++
expr_stmt|;
name|envchar
operator|++
expr_stmt|;
block|}
name|found
operator|=
operator|(
operator|(
operator|*
name|namechar
operator|==
literal|'\0'
operator|||
operator|*
name|namechar
operator|==
literal|'='
operator|)
operator|&&
operator|*
name|envchar
operator|==
literal|'='
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|found
condition|?
name|i
operator|-
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|newenv
parameter_list|()
block|{
specifier|register
name|char
modifier|*
modifier|*
name|env
decl_stmt|,
modifier|*
name|elem
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|esize
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|esize
operator|=
name|i
operator|+
name|EXTRASIZE
operator|+
literal|1
expr_stmt|;
name|env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|esize
operator|*
sizeof|sizeof
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|elem
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|env
index|[
name|i
index|]
operator|=
name|elem
expr_stmt|;
name|strcpy
argument_list|(
name|elem
argument_list|,
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|env
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|environ
operator|=
name|env
expr_stmt|;
name|envsize
operator|=
name|esize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|moreenv
parameter_list|()
block|{
specifier|register
name|int
name|esize
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
name|esize
operator|=
name|envsize
operator|+
name|EXTRASIZE
expr_stmt|;
name|env
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|environ
argument_list|,
name|esize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|environ
operator|=
name|env
expr_stmt|;
name|envsize
operator|=
name|esize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEEDSETENV */
end_comment

end_unit

