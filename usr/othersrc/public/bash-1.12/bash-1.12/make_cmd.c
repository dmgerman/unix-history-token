begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* make_cmd.c --    Functions for making instances of the various parser constructs. */
end_comment

begin_comment
comment|/* Copyright (C) 1989 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"filecntl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|WORD_DESC
modifier|*
name|make_word
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|WORD_DESC
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|WORD_DESC
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_DESC
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|word
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|temp
operator|->
name|quoted
operator|=
name|temp
operator|->
name|dollar_present
operator|=
name|temp
operator|->
name|assignment
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|'$'
condition|)
name|temp
operator|->
name|dollar_present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|member
argument_list|(
operator|*
name|string
argument_list|,
literal|"'`\\\""
argument_list|)
condition|)
block|{
name|temp
operator|->
name|quoted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\\'
condition|)
name|string
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string
condition|)
operator|(
name|string
operator|++
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|WORD_DESC
modifier|*
name|make_word_from_token
parameter_list|(
name|token
parameter_list|)
name|int
name|token
decl_stmt|;
block|{
name|char
name|tokenizer
index|[
literal|2
index|]
decl_stmt|;
name|tokenizer
index|[
literal|0
index|]
operator|=
name|token
expr_stmt|;
name|tokenizer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|make_word
argument_list|(
name|tokenizer
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|WORD_LIST
modifier|*
name|make_word_list
parameter_list|(
name|word
parameter_list|,
name|link
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
name|WORD_LIST
modifier|*
name|link
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|word
operator|=
name|word
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|link
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|WORD_LIST
modifier|*
name|add_string_to_list
parameter_list|(
name|string
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|temp
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_LIST
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|word
operator|=
name|make_word
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|list
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|WORD_DESC
modifier|*
name|coerce_to_word
parameter_list|(
name|number
parameter_list|)
name|int
name|number
decl_stmt|;
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
name|number
argument_list|)
expr_stmt|;
return|return
operator|(
name|make_word
argument_list|(
name|string
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|COMMAND
modifier|*
name|make_command
parameter_list|(
name|type
parameter_list|,
name|pointer
parameter_list|)
name|enum
name|command_type
name|type
decl_stmt|;
name|SIMPLE_COM
modifier|*
name|pointer
decl_stmt|;
block|{
name|COMMAND
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|value
operator|.
name|Simple
operator|=
name|pointer
expr_stmt|;
name|temp
operator|->
name|value
operator|.
name|Simple
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|redirects
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|COMMAND
modifier|*
name|command_connect
parameter_list|(
name|com1
parameter_list|,
name|com2
parameter_list|,
name|connector
parameter_list|)
name|COMMAND
modifier|*
name|com1
decl_stmt|,
decl|*
name|com2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|connector
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CONNECTION
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|CONNECTION
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CONNECTION
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|connector
operator|=
name|connector
expr_stmt|;
name|temp
operator|->
name|first
operator|=
name|com1
expr_stmt|;
name|temp
operator|->
name|second
operator|=
name|com2
expr_stmt|;
return|return
operator|(
name|make_command
argument_list|(
name|cm_connection
argument_list|,
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|temp
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|COMMAND
modifier|*
name|make_for_command
parameter_list|(
name|name
parameter_list|,
name|map_list
parameter_list|,
name|action
parameter_list|)
name|WORD_DESC
modifier|*
name|name
decl_stmt|;
name|WORD_LIST
modifier|*
name|map_list
decl_stmt|;
name|COMMAND
modifier|*
name|action
decl_stmt|;
block|{
name|FOR_COM
modifier|*
name|temp
init|=
operator|(
name|FOR_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FOR_COM
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|temp
operator|->
name|map_list
operator|=
name|map_list
expr_stmt|;
name|temp
operator|->
name|action
operator|=
name|action
expr_stmt|;
return|return
operator|(
name|make_command
argument_list|(
name|cm_for
argument_list|,
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|COMMAND
modifier|*
name|make_group_command
parameter_list|(
name|command
parameter_list|)
name|COMMAND
modifier|*
name|command
decl_stmt|;
block|{
name|GROUP_COM
modifier|*
name|temp
init|=
operator|(
name|GROUP_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GROUP_COM
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|command
operator|=
name|command
expr_stmt|;
return|return
operator|(
name|make_command
argument_list|(
name|cm_group
argument_list|,
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|COMMAND
modifier|*
name|make_case_command
parameter_list|(
name|word
parameter_list|,
name|clauses
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
name|PATTERN_LIST
modifier|*
name|clauses
decl_stmt|;
block|{
specifier|extern
name|GENERIC_LIST
modifier|*
name|reverse_list
parameter_list|()
function_decl|;
name|CASE_COM
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|CASE_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CASE_COM
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|word
operator|=
name|word
expr_stmt|;
name|temp
operator|->
name|clauses
operator|=
operator|(
name|PATTERN_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
return|return
operator|(
name|make_command
argument_list|(
name|cm_case
argument_list|,
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PATTERN_LIST
modifier|*
name|make_pattern_list
parameter_list|(
name|patterns
parameter_list|,
name|action
parameter_list|)
name|WORD_LIST
modifier|*
name|patterns
decl_stmt|;
name|COMMAND
modifier|*
name|action
decl_stmt|;
block|{
name|PATTERN_LIST
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|PATTERN_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PATTERN_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|patterns
operator|=
name|patterns
expr_stmt|;
name|temp
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|COMMAND
modifier|*
name|make_if_command
parameter_list|(
name|test
parameter_list|,
name|true_case
parameter_list|,
name|false_case
parameter_list|)
name|COMMAND
modifier|*
name|test
decl_stmt|,
decl|*
name|true_case
decl_stmt|,
modifier|*
name|false_case
decl_stmt|;
end_function

begin_block
block|{
name|IF_COM
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IF_COM
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|test
operator|=
name|test
expr_stmt|;
name|temp
operator|->
name|true_case
operator|=
name|true_case
expr_stmt|;
name|temp
operator|->
name|false_case
operator|=
name|false_case
expr_stmt|;
return|return
operator|(
name|make_command
argument_list|(
name|cm_if
argument_list|,
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|temp
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|COMMAND
modifier|*
name|make_until_or_while
parameter_list|(
name|test
parameter_list|,
name|action
parameter_list|,
name|which
parameter_list|)
name|COMMAND
modifier|*
name|test
decl_stmt|,
decl|*
name|action
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|command_type
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|WHILE_COM
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|WHILE_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WHILE_COM
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|test
operator|=
name|test
expr_stmt|;
name|temp
operator|->
name|action
operator|=
name|action
expr_stmt|;
return|return
operator|(
name|make_command
argument_list|(
name|which
argument_list|,
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|temp
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|COMMAND
modifier|*
name|make_while_command
parameter_list|(
name|test
parameter_list|,
name|action
parameter_list|)
name|COMMAND
modifier|*
name|test
decl_stmt|,
decl|*
name|action
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|make_until_or_while
argument_list|(
name|test
argument_list|,
name|action
argument_list|,
name|cm_while
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|COMMAND
modifier|*
name|make_until_command
parameter_list|(
name|test
parameter_list|,
name|action
parameter_list|)
name|COMMAND
modifier|*
name|test
decl_stmt|,
decl|*
name|action
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|make_until_or_while
argument_list|(
name|test
argument_list|,
name|action
argument_list|,
name|cm_until
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|COMMAND
modifier|*
name|make_bare_simple_command
parameter_list|()
block|{
name|COMMAND
modifier|*
name|command
decl_stmt|;
name|SIMPLE_COM
modifier|*
name|temp
init|=
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SIMPLE_COM
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|words
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
name|temp
operator|->
name|redirects
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
name|command
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|command
operator|->
name|type
operator|=
name|cm_simple
expr_stmt|;
name|command
operator|->
name|redirects
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
name|command
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|command
operator|->
name|value
operator|.
name|Simple
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|command
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a command which is the connection of the word or redirection    in ELEMENT, and the command * or NULL in COMMAND. */
end_comment

begin_function
name|COMMAND
modifier|*
name|make_simple_command
parameter_list|(
name|element
parameter_list|,
name|command
parameter_list|)
name|ELEMENT
name|element
decl_stmt|;
name|COMMAND
modifier|*
name|command
decl_stmt|;
block|{
comment|/* If we are starting from scratch, then make the initial command      structure.  Also note that we have to fill in all the slots, since      malloc doesn't return zeroed space. */
if|if
condition|(
operator|!
name|command
condition|)
name|command
operator|=
name|make_bare_simple_command
argument_list|()
expr_stmt|;
if|if
condition|(
name|element
operator|.
name|word
condition|)
block|{
name|WORD_LIST
modifier|*
name|tw
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_LIST
argument_list|)
argument_list|)
decl_stmt|;
name|tw
operator|->
name|word
operator|=
name|element
operator|.
name|word
expr_stmt|;
name|tw
operator|->
name|next
operator|=
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|words
expr_stmt|;
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|words
operator|=
name|tw
expr_stmt|;
block|}
else|else
block|{
name|REDIRECT
modifier|*
name|r
init|=
name|element
operator|.
name|redirect
decl_stmt|;
comment|/* Due to the way<> is implemented, there may be more than a single 	 redirection in element.redirect.  We just follow the chain as far 	 as it goes, and hook onto the end. */
while|while
condition|(
name|r
operator|->
name|next
condition|)
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|redirects
expr_stmt|;
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|redirects
operator|=
name|element
operator|.
name|redirect
expr_stmt|;
block|}
return|return
operator|(
name|command
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|POSIX_HERE_DOCUMENTS
end_define

begin_macro
name|make_here_document
argument_list|(
argument|temp
argument_list|)
end_macro

begin_decl_stmt
name|REDIRECT
modifier|*
name|temp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|kill_leading
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|temp
operator|->
name|instruction
condition|)
block|{
comment|/* Because we are Bourne compatible, we read the input for this<< or<<- redirection now, from wherever input is coming from. 	 We store the input read into a WORD_DESC.  Replace the text of 	 the redirectee.word with the new input text.  If<<- is on, 	 then remove leading TABS from each line. */
case|case
name|r_deblank_reading_until
case|:
comment|/*<<-foo */
name|kill_leading
operator|++
expr_stmt|;
comment|/* ... */
case|case
name|r_reading_until
case|:
comment|/*<<foo */
block|{
specifier|extern
name|char
modifier|*
name|redirection_expand
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|string_quote_removal
parameter_list|()
function_decl|;
name|char
modifier|*
name|redirectee_word
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|document
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|document_index
init|=
literal|0
decl_stmt|,
name|document_size
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|POSIX_HERE_DOCUMENTS
argument_list|)
comment|/* Because of Bourne shell semantics, we turn off globbing, but 	     only for this style of redirection.  I feel a little ill.  */
block|{
specifier|extern
name|int
name|disallow_filename_globbing
decl_stmt|;
name|int
name|old_value
init|=
name|disallow_filename_globbing
decl_stmt|;
name|disallow_filename_globbing
operator|=
literal|1
expr_stmt|;
name|redirectee_word
operator|=
name|redirection_expand
argument_list|(
name|temp
operator|->
name|redirectee
operator|.
name|filename
argument_list|)
expr_stmt|;
name|disallow_filename_globbing
operator|=
name|old_value
expr_stmt|;
block|}
else|#
directive|else
comment|/* POSIX_HERE_DOCUMENTS */
comment|/* Quote removal is the only expansion performed on the delimiter 	     for here documents, making it an extremely special case.  I 	     still feel ill. */
name|redirectee_word
operator|=
name|string_quote_removal
argument_list|(
name|temp
operator|->
name|redirectee
operator|.
name|filename
operator|->
name|word
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* POSIX_HERE_DOCUMENTS */
comment|/* redirection_expand will return NULL if the expansion results in 	     multiple words or no words.  Check for that here, and just abort 	     this here document if it does. */
if|if
condition|(
name|redirectee_word
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|redirectee_word
argument_list|)
expr_stmt|;
else|else
block|{
name|temp
operator|->
name|here_doc_eof
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|document_done
goto|;
block|}
name|free
argument_list|(
name|temp
operator|->
name|redirectee
operator|.
name|filename
operator|->
name|word
argument_list|)
expr_stmt|;
name|temp
operator|->
name|here_doc_eof
operator|=
name|redirectee_word
expr_stmt|;
comment|/* Read lines from wherever lines are coming from. 	     For each line read, if kill_leading, then kill the 	     leading tab characters. 	     If the line matches redirectee_word exactly, then we have 	     manufactured the document.  Otherwise, add the line to the 	     list of lines in the document. */
block|{
specifier|extern
name|char
modifier|*
name|read_secondary_line
parameter_list|()
function_decl|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|l
decl_stmt|;
while|while
condition|(
name|line
operator|=
name|read_secondary_line
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|line
condition|)
goto|goto
name|document_done
goto|;
if|if
condition|(
name|kill_leading
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Hack:  To be compatible with some Bourne shells, we  		       check the word before stripping the whitespace.  This 		       is a hack, though. */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|redirectee_word
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|line
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
goto|goto
name|document_done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
index|[
name|i
index|]
operator|==
literal|'\t'
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
condition|)
name|strcpy
argument_list|(
operator|&
name|line
index|[
literal|0
index|]
argument_list|,
operator|&
name|line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|redirectee_word
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|line
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
goto|goto
name|document_done
goto|;
name|l
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|+
name|document_index
operator|>=
name|document_size
condition|)
block|{
name|document
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|document
argument_list|,
operator|(
name|document_size
operator|+=
operator|(
literal|10
operator|*
name|l
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
operator|&
name|document
index|[
name|document_index
index|]
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|document_index
operator|+=
name|l
expr_stmt|;
block|}
block|}
name|document_done
label|:
if|if
condition|(
operator|!
name|document
condition|)
name|document
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|temp
operator|->
name|redirectee
operator|.
name|filename
operator|->
name|word
operator|=
name|document
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Generate a REDIRECT from SOURCE, DEST, and INSTRUCTION.     INSTRUCTION is the instruction type, SOURCE is an INT,    and DEST is an INT or a WORD_DESC *. */
end_comment

begin_function
name|REDIRECT
modifier|*
name|make_redirection
parameter_list|(
name|source
parameter_list|,
name|instruction
parameter_list|,
name|dest
parameter_list|)
name|enum
name|r_instruction
name|instruction
decl_stmt|;
block|{
name|REDIRECT
modifier|*
name|temp
init|=
operator|(
name|REDIRECT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REDIRECT
argument_list|)
argument_list|)
decl_stmt|;
comment|/* First do the common cases. */
name|temp
operator|->
name|redirector
operator|=
name|source
expr_stmt|;
name|temp
operator|->
name|redirectee
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
name|temp
operator|->
name|instruction
operator|=
name|instruction
expr_stmt|;
name|temp
operator|->
name|next
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
switch|switch
condition|(
name|instruction
condition|)
block|{
case|case
name|r_output_direction
case|:
comment|/*>foo */
case|case
name|r_output_force
case|:
comment|/*>| foo */
name|temp
operator|->
name|flags
operator|=
name|O_TRUNC
operator||
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
break|break;
case|case
name|r_input_direction
case|:
comment|/*<foo */
case|case
name|r_inputa_direction
case|:
comment|/* foo& makes this. */
name|temp
operator|->
name|flags
operator|=
name|O_RDONLY
expr_stmt|;
break|break;
case|case
name|r_appending_to
case|:
comment|/*>>foo */
name|temp
operator|->
name|flags
operator|=
name|O_APPEND
operator||
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
break|break;
case|case
name|r_deblank_reading_until
case|:
comment|/*<<-foo */
case|case
name|r_reading_until
case|:
comment|/*<< foo */
break|break;
case|case
name|r_duplicating_input
case|:
comment|/* 1<&2 */
case|case
name|r_duplicating_output
case|:
comment|/* 1>&2 */
case|case
name|r_close_this
case|:
comment|/*<&- */
case|case
name|r_duplicating_input_word
case|:
comment|/* 1<&$foo */
case|case
name|r_duplicating_output_word
case|:
comment|/* 1>&$foo */
break|break;
case|case
name|r_err_and_out
case|:
comment|/* command&>filename */
name|temp
operator|->
name|flags
operator|=
name|O_TRUNC
operator||
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
break|break;
case|case
name|r_input_output
case|:
name|temp
operator|->
name|flags
operator|=
name|O_RDWR
expr_stmt|;
break|break;
default|default:
name|programming_error
argument_list|(
literal|"Redirection instruction from yyparse () '%d' is\n\ out of range in make_redirection ()."
argument_list|,
name|instruction
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|COMMAND
modifier|*
name|make_function_def
parameter_list|(
name|name
parameter_list|,
name|command
parameter_list|)
name|WORD_DESC
modifier|*
name|name
decl_stmt|;
name|COMMAND
modifier|*
name|command
decl_stmt|;
block|{
name|FUNCTION_DEF
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|FUNCTION_DEF
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FUNCTION_DEF
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|make_command
argument_list|(
name|cm_function_def
argument_list|,
operator|(
name|SIMPLE_COM
operator|*
operator|)
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reverse the word list and redirection list in the simple command    has just been parsed.  It seems simpler to do this here the one    time then by any other method that I can think of. */
end_comment

begin_function
name|COMMAND
modifier|*
name|clean_simple_command
parameter_list|(
name|command
parameter_list|)
name|COMMAND
modifier|*
name|command
decl_stmt|;
block|{
specifier|extern
name|GENERIC_LIST
modifier|*
name|reverse_list
parameter_list|()
function_decl|;
if|if
condition|(
name|command
operator|->
name|type
operator|!=
name|cm_simple
condition|)
block|{
name|programming_error
argument_list|(
literal|"clean_simple_command () got a command with type %d."
argument_list|,
name|command
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|words
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|words
argument_list|)
expr_stmt|;
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|redirects
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|reverse_list
argument_list|(
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|redirects
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|command
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Cons up a new array of words.  The words are taken from LIST,    which is a WORD_LIST *.  Absolutely everything is malloc'ed,    so you should free everything in this array when you are done.    The array is NULL terminated. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_word_array
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|count
init|=
name|list_length
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|array
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|list
condition|;
name|count
operator|++
control|)
block|{
name|array
index|[
name|count
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|array
index|[
name|count
index|]
argument_list|,
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|array
index|[
name|count
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|array
operator|)
return|;
block|}
end_function

end_unit

