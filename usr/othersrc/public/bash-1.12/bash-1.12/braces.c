begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* braces.c -- code for doing word expansion in curly braces. */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with Bash; see the file COPYING.  If not, write to the Free    Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* Stuff in curly braces gets expanded after variable and command    substitution, but before filename globbing.     (Actually, this should be true for the sake of efficiency, but it    isn't because of quoting hacks.  Once I rebuild quoting it will be    true. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHELL */
end_comment

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_define
define|#
directive|define
name|brace_whitespace
parameter_list|(
name|c
parameter_list|)
value|(!(c) || (c) == ' ' || (c) == '\t' || (c) == '\n')
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NULL
argument_list|)
end_if

begin_define
define|#
directive|define
name|NULL
value|(char *)0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NULL */
end_comment

begin_comment
comment|/* Basic idea:     Segregate the text into 3 sections: preamble (stuff before an open brace),    postamble (stuff after the matching close brace) and amble (stuff after    preamble, and before postamble).  Expand amble, and then tack on the    expansions to preamble.  Expand postamble, and tack on the expansions to    the result so far.  */
end_comment

begin_comment
comment|/* The character which is used to separate arguments. */
end_comment

begin_decl_stmt
name|int
name|brace_arg_separator
init|=
literal|','
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|brace_gobbler
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|expand_amble
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|array_concat
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|copy_array
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return an array of strings; the brace expansion of TEXT. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|brace_expand
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|start
decl_stmt|;
name|char
modifier|*
name|preamble
decl_stmt|,
modifier|*
name|postamble
decl_stmt|,
modifier|*
name|amble
decl_stmt|;
name|char
modifier|*
modifier|*
name|tack
decl_stmt|,
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
comment|/* Find the text of the preamble. */
name|i
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|brace_gobbler
argument_list|(
name|text
argument_list|,
operator|&
name|i
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|preamble
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|preamble
argument_list|,
name|text
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|preamble
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|preamble
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Special case.  If we never found an exciting character, then      the preamble is all of the text, so just return that. */
if|if
condition|(
name|c
operator|!=
literal|'{'
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* Find the amble.  This is the stuff inside this set of braces. */
name|start
operator|=
operator|++
name|i
expr_stmt|;
name|c
operator|=
name|brace_gobbler
argument_list|(
name|text
argument_list|,
operator|&
name|i
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
comment|/* What if there isn't a matching close brace? */
if|if
condition|(
operator|!
name|c
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
specifier|register
name|int
name|j
decl_stmt|;
comment|/* Well, if we found BRACE_ARG_SEPARATOR between START and I, 	 then this should be an error.  Otherwise, it isn't. */
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|text
index|[
name|j
index|]
operator|==
name|brace_arg_separator
condition|)
block|{
name|free_array
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|report_error
argument_list|(
literal|"Missing `}'"
argument_list|)
expr_stmt|;
name|throw_to_top_level
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
comment|/* Same as result[0]; see initialization. */
name|result
index|[
literal|0
index|]
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|amble
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|amble
argument_list|,
operator|&
name|text
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|amble
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* If the amble does not contain BRACE_ARG_SEPARATOR, then just return      without doing any expansion.  */
if|if
condition|(
name|index
argument_list|(
name|amble
argument_list|,
name|brace_arg_separator
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|amble
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|preamble
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SHELL */
name|postamble
operator|=
operator|&
name|text
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|tack
operator|=
name|expand_amble
argument_list|(
name|amble
argument_list|)
expr_stmt|;
name|result
operator|=
name|array_concat
argument_list|(
name|result
argument_list|,
name|tack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|amble
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|tack
argument_list|)
expr_stmt|;
name|tack
operator|=
name|brace_expand
argument_list|(
name|postamble
argument_list|)
expr_stmt|;
name|result
operator|=
name|array_concat
argument_list|(
name|result
argument_list|,
name|tack
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|tack
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand the text found inside of braces.  We simply try to split the    text at BRACE_ARG_SEPARATORs into separate strings.  We then brace    expand each slot which needs it, until there are no more slots which    need it. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|expand_amble
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|result
decl_stmt|,
modifier|*
modifier|*
name|partial
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
name|int
name|start
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|start
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
operator|,
name|c
operator|=
literal|1
init|;
name|c
condition|;
name|start
operator|=
operator|++
name|i
control|)
block|{
name|c
operator|=
name|brace_gobbler
argument_list|(
name|text
argument_list|,
operator|&
name|i
argument_list|,
name|brace_arg_separator
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tem
argument_list|,
operator|&
name|text
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|tem
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|partial
operator|=
name|brace_expand
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|partial
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|lr
init|=
name|array_len
argument_list|(
name|result
argument_list|)
decl_stmt|;
specifier|register
name|int
name|lp
init|=
name|array_len
argument_list|(
name|partial
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
literal|1
operator|+
name|lp
operator|+
name|lr
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lp
condition|;
name|j
operator|++
control|)
name|result
index|[
name|lr
operator|+
name|j
index|]
operator|=
name|partial
index|[
name|j
index|]
expr_stmt|;
name|result
index|[
name|lr
operator|+
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|partial
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Start at INDEX, and skip characters in TEXT. Set INDEX to the    index of the character matching SATISFY.  This understands about    quoting.  Return the character that caused us to stop searching;    this is either the same as SATISFY, or 0. */
end_comment

begin_function
specifier|static
name|int
name|brace_gobbler
parameter_list|(
name|text
parameter_list|,
name|index
parameter_list|,
name|satisfy
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
modifier|*
name|index
decl_stmt|;
name|int
name|satisfy
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|quoted
decl_stmt|,
name|level
decl_stmt|;
name|level
operator|=
name|quoted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|index
init|;
name|c
operator|=
name|text
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
if|if
condition|(
operator|(
name|quoted
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|c
operator|==
name|quoted
operator|)
condition|)
name|quoted
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|quoted
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|satisfy
operator|&&
operator|!
name|level
operator|&&
operator|!
name|quoted
condition|)
block|{
comment|/* We ignore an open brace surrounded by whitespace, and also 	     an open brace followed immediately by a close brace, that 	     was preceded with whitespace.  */
if|if
condition|(
name|c
operator|==
literal|'{'
operator|&&
operator|(
operator|(
operator|!
name|i
operator|||
name|brace_whitespace
argument_list|(
name|text
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|brace_whitespace
argument_list|(
name|text
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|||
name|text
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'}'
operator|)
operator|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SHELL
comment|/* If this is being compiled as part of bash, ignore the `{' 	     in a `${}' construct */
if|if
condition|(
operator|(
name|c
operator|!=
literal|'{'
operator|)
operator|||
operator|!
name|i
operator|||
operator|(
name|text
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'$'
operator|)
condition|)
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
operator|&&
name|level
condition|)
name|level
operator|--
expr_stmt|;
block|}
operator|*
name|index
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new array of strings which is the result of appending each    string in ARR2 to each string in ARR1.  The resultant array is    len (arr1) * len (arr2) long.  For convenience, ARR1 (and its contents)    are free ()'ed.  ARR1 can be NULL, in that case, a new version of ARR2    is returned. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|array_concat
parameter_list|(
name|arr1
parameter_list|,
name|arr2
parameter_list|)
name|char
modifier|*
modifier|*
name|arr1
decl_stmt|,
decl|*
modifier|*
name|arr2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|,
name|len1
decl_stmt|,
name|len2
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|arr1
condition|)
return|return
operator|(
name|copy_array
argument_list|(
name|arr2
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|arr2
condition|)
return|return
operator|(
name|arr1
operator|)
return|;
name|len1
operator|=
name|array_len
argument_list|(
name|arr1
argument_list|)
expr_stmt|;
name|len2
operator|=
name|array_len
argument_list|(
name|arr2
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
operator|(
name|len1
operator|*
name|len2
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|strlen_1
init|=
name|strlen
argument_list|(
name|arr1
index|[
name|i
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|result
index|[
name|len
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen_1
operator|+
name|strlen
argument_list|(
name|arr2
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
index|[
name|len
index|]
argument_list|,
name|arr1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
index|[
name|len
index|]
operator|+
name|strlen_1
argument_list|,
name|arr2
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|arr1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|arr1
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|copy_array
parameter_list|(
name|array
parameter_list|)
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|array
condition|)
return|return
operator|(
name|array
operator|)
return|;
name|new
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|array_len
argument_list|(
name|array
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|new
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|new
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_macro
name|fatal_error
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|report_error
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|report_error
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|()
block|{
name|char
name|example
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"brace_expand> "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|fgets
argument_list|(
name|example
argument_list|,
literal|256
argument_list|,
name|stdin
argument_list|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|example
argument_list|,
literal|"quit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|example
argument_list|)
condition|)
name|example
index|[
name|strlen
argument_list|(
name|example
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|=
name|brace_expand
argument_list|(
name|example
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|result
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Local variables:  * compile-command: "gcc -g -Bstatic -DTEST -o brace_expand braces.c general.o"  * end:  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

