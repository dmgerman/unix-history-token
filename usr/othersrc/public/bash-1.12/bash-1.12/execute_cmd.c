begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* execute_command.c -- Execute a COMMAND structure. */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with Bash; see the file COPYING.  If not, write to the Free    Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_include
include|#
directive|include
file|"filecntl.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGABRT
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGABRT
value|SIGIOT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"sysdefs.h"
end_include

begin_include
include|#
directive|include
file|<glob/fnmatch.h>
end_include

begin_decl_stmt
name|int
name|builtin_pipe_in
init|=
name|NO_PIPE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|builtin_pipe_out
init|=
name|NO_PIPE
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|breaking
decl_stmt|,
name|continuing
decl_stmt|,
name|loop_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|interactive
decl_stmt|,
name|login_shell
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|job_control
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|set_job_control
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOB_CONTROL */
end_comment

begin_function_decl
specifier|extern
name|int
name|getdtablesize
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|string_list
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|pid_t
name|last_made_pid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|WORD_LIST
modifier|*
name|expand_words
argument_list|()
decl_stmt|,
modifier|*
name|expand_word
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|make_command_string
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|Function
modifier|*
name|find_shell_builtin
argument_list|()
decl_stmt|,
modifier|*
name|builtin_address
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static functions defined and used in this file. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTDEF
argument_list|)
end_if

begin_comment
comment|/* Currently unused. */
end_comment

begin_function_decl
specifier|static
name|void
name|close_all_files
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_function_decl
specifier|static
name|void
name|close_pipes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_piping
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|do_redirection_internal
argument_list|()
decl_stmt|,
name|do_redirections
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|expandable_redirection_filename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|execute_shell_script
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|execute_disk_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|execute_builtin_or_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|execute_subshell_builtin_or_function
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|cleanup_redirects
argument_list|()
decl_stmt|,
name|cleanup_func_redirects
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|bind_lastarg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_undo_redirect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_undo_close_redirect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_user_command_internal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_user_command_in_path
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The value returned by the last synchronous command. */
end_comment

begin_decl_stmt
name|int
name|last_command_exit_value
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of redirections to preform which will undo the redirections    that I made in the shell. */
end_comment

begin_decl_stmt
name|REDIRECT
modifier|*
name|redirection_undo_list
init|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use this as the function to call when adding unwind protects so we    don't need to know what free() returns. */
end_comment

begin_function
specifier|static
name|void
name|vfree
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FD_BITMAP_DEFAULT_SIZE
value|32
end_define

begin_comment
comment|/* Functions to allocate and deallocate the structures used to pass    information from the shell to its children about file descriptors    to close. */
end_comment

begin_function
name|struct
name|fd_bitmap
modifier|*
name|new_fd_bitmap
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
name|struct
name|fd_bitmap
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|fd_bitmap
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fd_bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
condition|)
block|{
name|ret
operator|->
name|bitmap
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ret
operator|->
name|bitmap
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|->
name|bitmap
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dispose_fd_bitmap
parameter_list|(
name|fdbp
parameter_list|)
name|struct
name|fd_bitmap
modifier|*
name|fdbp
decl_stmt|;
block|{
if|if
condition|(
name|fdbp
operator|->
name|bitmap
condition|)
name|free
argument_list|(
name|fdbp
operator|->
name|bitmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fdbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|close_fd_bitmap
parameter_list|(
name|fdbp
parameter_list|)
name|struct
name|fd_bitmap
modifier|*
name|fdbp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fdbp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdbp
operator|->
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fdbp
operator|->
name|bitmap
index|[
name|i
index|]
condition|)
block|{
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fdbp
operator|->
name|bitmap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Execute the command passed in COMMAND.  COMMAND is exactly what    read_command () places into GLOBAL_COMMAND.  See "shell.h" for the    details of the command structure.     EXECUTION_SUCCESS or EXECUTION_FAILURE are the only possible    return values.  Executing a command with nothing in it returns    success. */
end_comment

begin_macro
name|execute_command
argument_list|(
argument|command
argument_list|)
end_macro

begin_decl_stmt
name|COMMAND
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|fd_bitmap
modifier|*
name|fd_close_bmap
decl_stmt|;
name|int
name|r
decl_stmt|;
name|fd_close_bmap
operator|=
name|new_fd_bitmap
argument_list|(
name|FD_BITMAP_DEFAULT_SIZE
argument_list|)
expr_stmt|;
comment|/* Just do the command, but not asynchronously. */
name|r
operator|=
name|execute_command_internal
argument_list|(
name|command
argument_list|,
literal|0
argument_list|,
name|NO_PIPE
argument_list|,
name|NO_PIPE
argument_list|,
name|fd_close_bmap
argument_list|)
expr_stmt|;
name|dispose_fd_bitmap
argument_list|(
name|fd_close_bmap
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PROCESS_SUBSTITUTION
argument_list|)
name|unlink_fifo_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/* Returns 1 if TYPE is a shell control structure type. */
end_comment

begin_function
name|int
name|shell_control_structure
parameter_list|(
name|type
parameter_list|)
name|enum
name|command_type
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|cm_for
case|:
case|case
name|cm_case
case|:
case|case
name|cm_while
case|:
case|case
name|cm_until
case|:
case|case
name|cm_if
case|:
case|case
name|cm_group
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* A function to use to unwind_protect the redirection undo list    for loops. */
end_comment

begin_function
specifier|static
name|void
name|cleanup_redirects
parameter_list|(
name|list
parameter_list|)
name|REDIRECT
modifier|*
name|list
decl_stmt|;
block|{
name|do_redirections
argument_list|(
name|list
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dispose_redirects
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to unwind_protect the redirections for functions and builtins. */
end_comment

begin_function
specifier|static
name|void
name|cleanup_func_redirects
parameter_list|(
name|list
parameter_list|)
name|REDIRECT
modifier|*
name|list
decl_stmt|;
block|{
name|do_redirections
argument_list|(
name|list
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_comment
comment|/* A function to restore the signal mask to its proper value when the shell    is interrupted or errors occur while creating a pipeline. */
end_comment

begin_function
specifier|static
name|int
name|restore_signal_mask
parameter_list|(
name|set
parameter_list|)
name|sigset_t
name|set
decl_stmt|;
block|{
return|return
operator|(
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|set
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOB_CONTROL */
end_comment

begin_comment
comment|/* A debugging function that can be called from gdb, for instance. */
end_comment

begin_macro
name|open_files
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|f
decl_stmt|,
name|fd_table_size
decl_stmt|;
name|fd_table_size
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pid %d open files:"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|fd_table_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|fcntl
argument_list|(
name|i
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d (%s)"
argument_list|,
name|i
argument_list|,
name|f
condition|?
literal|"close"
else|:
literal|"open"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|execute_command_internal
argument_list|(
argument|command
argument_list|,
argument|asynchronous
argument_list|,
argument|pipe_in
argument_list|,
argument|pipe_out
argument_list|,
argument|fds_to_close
argument_list|)
end_macro

begin_decl_stmt
name|COMMAND
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|asynchronous
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pipe_in
decl_stmt|,
name|pipe_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fd_bitmap
modifier|*
name|fds_to_close
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|exec_result
init|=
name|EXECUTION_SUCCESS
decl_stmt|;
name|int
name|invert
decl_stmt|,
name|ignore_return
decl_stmt|;
name|REDIRECT
modifier|*
name|my_undo_list
decl_stmt|;
if|if
condition|(
operator|!
name|command
operator|||
name|breaking
operator|||
name|continuing
condition|)
return|return
operator|(
name|EXECUTION_SUCCESS
operator|)
return|;
name|run_pending_traps
argument_list|()
expr_stmt|;
name|invert
operator|=
operator|(
name|command
operator|->
name|flags
operator|&
name|CMD_INVERT_RETURN
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* If a command was being explicitly run in a subshell, or if it is      a shell control-structure, and it has a pipe, then we do the command      in a subshell. */
if|if
condition|(
operator|(
name|command
operator|->
name|flags
operator|&
name|CMD_WANT_SUBSHELL
operator|)
operator|||
operator|(
name|command
operator|->
name|flags
operator|&
name|CMD_FORCE_SUBSHELL
operator|)
operator|||
operator|(
name|shell_control_structure
argument_list|(
name|command
operator|->
name|type
argument_list|)
operator|&&
operator|(
name|pipe_out
operator|!=
name|NO_PIPE
operator|||
name|pipe_in
operator|!=
name|NO_PIPE
operator|||
name|asynchronous
operator|)
operator|)
condition|)
block|{
name|pid_t
name|paren_pid
decl_stmt|;
comment|/* Fork a subshell, turn off the subshell bit, turn off job 	 control and call execute_command () on the command again. */
name|paren_pid
operator|=
name|make_child
argument_list|(
name|savestring
argument_list|(
name|make_command_string
argument_list|(
name|command
argument_list|)
argument_list|)
argument_list|,
name|asynchronous
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren_pid
operator|==
literal|0
condition|)
block|{
name|int
name|user_subshell
decl_stmt|,
name|return_code
decl_stmt|;
name|user_subshell
operator|=
operator|(
name|command
operator|->
name|flags
operator|&
name|CMD_WANT_SUBSHELL
operator|)
operator|!=
literal|0
expr_stmt|;
name|command
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CMD_FORCE_SUBSHELL
operator||
name|CMD_WANT_SUBSHELL
operator|)
expr_stmt|;
comment|/* If a command is asynchronous in a subshell (like ( foo )& or 	     the special case of an asynchronous GROUP command where the 	     the subshell bit is turned on down in case cm_group: below),  	     turn off `asynchronous', so that two subshells aren't spawned.  	     This seems semantically correct to me.  For example,  	     ( foo )& seems to say ``do the command `foo' in a subshell 	     environment, but don't wait for that subshell to finish'', 	     and "{ foo ; bar }&" seems to me to be like functions or 	     builtins in the background, which executed in a subshell 	     environment.  I just don't see the need to fork two subshells. */
comment|/* Don't fork again, we are already in a subshell. */
name|asynchronous
operator|=
literal|0
expr_stmt|;
comment|/* Subshells are neither login nor interactive. */
name|login_shell
operator|=
name|interactive
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
comment|/* Delete all traces that there were any jobs running.  This is 	     only for subshells. */
name|without_job_control
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
name|do_piping
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds_to_close
condition|)
name|close_fd_bitmap
argument_list|(
name|fds_to_close
argument_list|)
expr_stmt|;
comment|/* Do redirections, then dispose of them before recursive call. */
if|if
condition|(
name|command
operator|->
name|redirects
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|do_redirections
argument_list|(
name|command
operator|->
name|redirects
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|exit
argument_list|(
name|EXECUTION_FAILURE
argument_list|)
expr_stmt|;
name|dispose_redirects
argument_list|(
name|command
operator|->
name|redirects
argument_list|)
expr_stmt|;
name|command
operator|->
name|redirects
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|return_code
operator|=
name|execute_command_internal
argument_list|(
name|command
argument_list|,
name|asynchronous
argument_list|,
name|NO_PIPE
argument_list|,
name|NO_PIPE
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
comment|/* If we were explicitly placed in a subshell with (), we need 	     to do the `shell cleanup' things, such as running traps[0]. */
if|if
condition|(
name|user_subshell
condition|)
name|run_exit_trap
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|return_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close_pipes
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
comment|/* If we are part of a pipeline, and not the end of the pipeline, 	     then we should simply return and let the last command in the 	     pipe be waited for.  If we are not in a pipeline, or are the 	     last command in the pipeline, then we wait for the subshell  	     and return its exit status as usual. */
if|if
condition|(
name|pipe_out
operator|!=
name|NO_PIPE
condition|)
return|return
operator|(
name|EXECUTION_SUCCESS
operator|)
return|;
name|stop_pipeline
argument_list|(
name|asynchronous
argument_list|,
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asynchronous
condition|)
block|{
name|last_command_exit_value
operator|=
name|wait_for
argument_list|(
name|paren_pid
argument_list|)
expr_stmt|;
comment|/* If we have to, invert the return value. */
if|if
condition|(
name|invert
condition|)
block|{
if|if
condition|(
name|last_command_exit_value
operator|==
name|EXECUTION_SUCCESS
condition|)
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
else|else
return|return
operator|(
name|EXECUTION_SUCCESS
operator|)
return|;
block|}
else|else
return|return
operator|(
name|last_command_exit_value
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|interactive
condition|)
name|describe_pid
argument_list|(
name|paren_pid
argument_list|)
expr_stmt|;
name|run_pending_traps
argument_list|()
expr_stmt|;
return|return
operator|(
name|EXECUTION_SUCCESS
operator|)
return|;
block|}
block|}
block|}
comment|/* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input      redirection.)  */
name|do_redirections
argument_list|(
name|command
operator|->
name|redirects
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_undo_list
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|copy_redirects
argument_list|(
name|redirection_undo_list
argument_list|)
expr_stmt|;
name|begin_unwind_frame
argument_list|(
literal|"loop_redirections"
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_undo_list
condition|)
name|add_unwind_protect
argument_list|(
operator|(
name|Function
operator|*
operator|)
name|cleanup_redirects
argument_list|,
name|my_undo_list
argument_list|)
expr_stmt|;
name|ignore_return
operator|=
operator|(
name|command
operator|->
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
operator|!=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
operator|->
name|type
condition|)
block|{
case|case
name|cm_for
case|:
if|if
condition|(
name|ignore_return
condition|)
name|command
operator|->
name|value
operator|.
name|For
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_for_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|For
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_case
case|:
if|if
condition|(
name|ignore_return
condition|)
name|command
operator|->
name|value
operator|.
name|Case
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_case_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Case
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_while
case|:
if|if
condition|(
name|ignore_return
condition|)
name|command
operator|->
name|value
operator|.
name|While
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_while_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|While
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_until
case|:
if|if
condition|(
name|ignore_return
condition|)
name|command
operator|->
name|value
operator|.
name|While
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_until_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|While
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_if
case|:
if|if
condition|(
name|ignore_return
condition|)
name|command
operator|->
name|value
operator|.
name|If
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_if_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|If
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_group
case|:
comment|/* This code can be executed from either of two paths: an explicit 	 '{}' command, or via a function call.  If we are executed via a 	 function call, we have already taken care of the function being 	 executed in the background (down there in execute_simple_command ()), 	 and this command should *not* be marked as asynchronous.  If we 	 are executing a regular '{}' group command, and asynchronous == 1, 	 we must want to execute the whole command in the background, so we 	 need a subshell, and we want the stuff executed in that subshell 	 (this group command) to be executed in the foreground of that 	 subshell (i.e. there will not be *another* subshell forked).  	 What we do is to force a subshell if asynchronous, and then call 	 execute_command_internal again with asynchronous still set to 1, 	 but with the original group command, so the printed command will 	 look right.  	 The code above that handles forking off subshells will note that 	 both subshell and async are on, and turn off async in the child 	 after forking the subshell (but leave async set in the parent, so 	 the normal call to describe_pid is made).  This turning off 	 async is *crucial*; if it is not done, this will fall into an 	 infinite loop of executions through this spot in subshell after 	 subshell until the process limit is exhausted. */
if|if
condition|(
name|asynchronous
condition|)
block|{
name|command
operator|->
name|flags
operator||=
name|CMD_FORCE_SUBSHELL
expr_stmt|;
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|command
argument_list|,
literal|1
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ignore_return
operator|&&
name|command
operator|->
name|value
operator|.
name|Group
operator|->
name|command
condition|)
name|command
operator|->
name|value
operator|.
name|Group
operator|->
name|command
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|command
operator|->
name|value
operator|.
name|Group
operator|->
name|command
argument_list|,
name|asynchronous
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|cm_simple
case|:
block|{
name|pid_t
name|last_pid
init|=
name|last_made_pid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
specifier|extern
name|int
name|already_making_children
decl_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
if|if
condition|(
name|ignore_return
operator|&&
name|command
operator|->
name|value
operator|.
name|Simple
condition|)
name|command
operator|->
name|value
operator|.
name|Simple
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_simple_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Simple
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|asynchronous
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
comment|/* The temporary environment should be used for only the simple 	   command immediately following its definition. */
name|dispose_used_env_vars
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Ultrix
argument_list|)
operator|&&
name|defined
argument_list|(
name|mips
argument_list|)
operator|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_ALLOCA
argument_list|)
comment|/* Reclaim memory allocated with alloca () on machines which 	   may be using the alloca emulation code. */
operator|(
name|void
operator|)
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (Ultrix&& mips) || !HAVE_ALLOCA */
comment|/* If we forked to do the command, then we must wait_for () 	   the child. */
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
if|if
condition|(
name|already_making_children
operator|&&
name|pipe_out
operator|==
name|NO_PIPE
condition|)
else|#
directive|else
if|if
condition|(
name|pipe_out
operator|==
name|NO_PIPE
condition|)
endif|#
directive|endif
comment|/* JOB_CONTROL */
block|{
if|if
condition|(
name|last_pid
operator|!=
name|last_made_pid
condition|)
block|{
name|stop_pipeline
argument_list|(
name|asynchronous
argument_list|,
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|asynchronous
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
name|describe_pid
argument_list|(
name|last_made_pid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
comment|/* Do not wait for asynchronous processes started from 		       startup files. */
if|if
condition|(
name|last_made_pid
operator|!=
name|last_asynchronous_pid
condition|)
endif|#
directive|endif
comment|/* When executing a shell function that executes other 			 commands, this causes the last simple command in 			 the function to be waited for twice. */
name|exec_result
operator|=
name|wait_for
argument_list|(
name|last_made_pid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ignore_return
operator|&&
name|exit_immediately_on_error
operator|&&
operator|!
name|invert
operator|&&
operator|(
name|exec_result
operator|!=
name|EXECUTION_SUCCESS
operator|)
condition|)
block|{
name|last_command_exit_value
operator|=
name|exec_result
expr_stmt|;
name|run_pending_traps
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|EXITPROG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|cm_connection
case|:
switch|switch
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|connector
condition|)
block|{
comment|/* Do the first command asynchronously. */
case|case
literal|'&'
case|:
block|{
name|COMMAND
modifier|*
name|tc
init|=
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
decl_stmt|;
if|if
condition|(
name|ignore_return
operator|&&
name|tc
condition|)
name|tc
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
block|{
name|REDIRECT
modifier|*
name|tr
init|=
name|make_redirection
argument_list|(
literal|0
argument_list|,
name|r_inputa_direction
argument_list|,
name|make_word
argument_list|(
literal|"/dev/null"
argument_list|)
argument_list|)
decl_stmt|;
name|tr
operator|->
name|next
operator|=
name|tc
operator|->
name|redirects
expr_stmt|;
name|tc
operator|->
name|redirects
operator|=
name|tr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !JOB_CONTROL */
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|tc
argument_list|,
literal|1
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
block|{
if|if
condition|(
name|ignore_return
operator|&&
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
argument_list|,
name|asynchronous
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|';'
case|:
comment|/* Just call execute command on both of them. */
if|if
condition|(
name|ignore_return
condition|)
block|{
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
condition|)
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
block|}
name|execute_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
argument_list|)
expr_stmt|;
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
argument_list|,
name|asynchronous
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
block|{
name|int
name|prev
decl_stmt|,
name|fildes
index|[
literal|2
index|]
decl_stmt|,
name|new_bitmap_size
decl_stmt|,
name|dummyfd
decl_stmt|;
name|COMMAND
modifier|*
name|cmd
decl_stmt|;
name|struct
name|fd_bitmap
modifier|*
name|fd_bitmap
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
name|prev
operator|=
name|pipe_in
expr_stmt|;
name|cmd
operator|=
name|command
expr_stmt|;
while|while
condition|(
name|cmd
operator|&&
name|cmd
operator|->
name|type
operator|==
name|cm_connection
operator|&&
name|cmd
operator|->
name|value
operator|.
name|Connection
operator|&&
name|cmd
operator|->
name|value
operator|.
name|Connection
operator|->
name|connector
operator|==
literal|'|'
condition|)
block|{
comment|/* Make a pipeline between the two commands. */
if|if
condition|(
name|pipe
argument_list|(
name|fildes
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report_error
argument_list|(
literal|"pipe error: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|terminate_current_pipeline
argument_list|()
expr_stmt|;
name|kill_current_pipeline
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
name|last_command_exit_value
operator|=
name|EXECUTION_FAILURE
expr_stmt|;
comment|/* The unwind-protects installed below will take care 		       of closing all of the open file descriptors. */
name|throw_to_top_level
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Here is a problem: with the new file close-on-exec 		       code, the read end of the pipe (fildes[0]) stays open 		       in the first process, so that process will never get a 		       SIGPIPE.  There is no way to signal the first process 		       that it should close fildes[0] after forking, so it 		       remains open.  No SIGPIPE is ever sent because there 		       is still a file descriptor open for reading connected 		       to the pipe.  We take care of that here.  This passes 		       around a bitmap of file descriptors that must be 		       closed after making a child process in 		       execute_simple_command. */
comment|/* We need fd_bitmap to be at least as big as fildes[0]. 		       If fildes[0] is less than fds_to_close->size, then 		       use fds_to_close->size. */
if|if
condition|(
name|fildes
index|[
literal|0
index|]
operator|<
name|fds_to_close
operator|->
name|size
condition|)
name|new_bitmap_size
operator|=
name|fds_to_close
operator|->
name|size
expr_stmt|;
else|else
name|new_bitmap_size
operator|=
name|fildes
index|[
literal|0
index|]
operator|+
literal|8
expr_stmt|;
name|fd_bitmap
operator|=
name|new_fd_bitmap
argument_list|(
name|new_bitmap_size
argument_list|)
expr_stmt|;
comment|/* Now copy the old information into the new bitmap. */
name|bcopy
argument_list|(
name|fds_to_close
operator|->
name|bitmap
argument_list|,
name|fd_bitmap
operator|->
name|bitmap
argument_list|,
name|fds_to_close
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* And mark the pipe file descriptors to be closed. */
name|fd_bitmap
operator|->
name|bitmap
index|[
name|fildes
index|[
literal|0
index|]
index|]
operator|=
literal|1
expr_stmt|;
comment|/* In case there are pipe or out-of-processes errors, we 		       want all these file descriptors to be closed when 		       unwind-protects are run, and the storage used for the 		       bitmaps freed up. */
name|begin_unwind_frame
argument_list|(
literal|"pipe-file-descriptors"
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|dispose_fd_bitmap
argument_list|,
name|fd_bitmap
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|close_fd_bitmap
argument_list|,
name|fd_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>=
literal|0
condition|)
name|add_unwind_protect
argument_list|(
name|close
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|dummyfd
operator|=
name|fildes
index|[
literal|1
index|]
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|close
argument_list|,
name|dummyfd
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|add_unwind_protect
argument_list|(
name|restore_signal_mask
argument_list|,
name|oset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
if|if
condition|(
name|ignore_return
operator|&&
name|cmd
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
condition|)
name|cmd
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|execute_command_internal
argument_list|(
name|cmd
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
argument_list|,
name|asynchronous
argument_list|,
name|prev
argument_list|,
name|fildes
index|[
literal|1
index|]
argument_list|,
name|fd_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|fildes
index|[
literal|0
index|]
expr_stmt|;
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dispose_fd_bitmap
argument_list|(
name|fd_bitmap
argument_list|)
expr_stmt|;
name|discard_unwind_frame
argument_list|(
literal|"pipe-file-descriptors"
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|cmd
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
expr_stmt|;
block|}
comment|/* Now execute the rightmost command in the pipeline.  */
if|if
condition|(
name|ignore_return
operator|&&
name|cmd
condition|)
name|cmd
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|cmd
argument_list|,
name|asynchronous
argument_list|,
name|prev
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|AND_AND
case|:
if|if
condition|(
name|asynchronous
condition|)
block|{
comment|/* If we have something like `a&& b&', run the&& stuff in a 		 subshell.  Force a subshell and just call 		 execute_command_internal again.  Leave asynchronous on 		 so that we get a report from the parent shell about the 		 background job. */
name|command
operator|->
name|flags
operator||=
name|CMD_FORCE_SUBSHELL
expr_stmt|;
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|command
argument_list|,
literal|1
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Execute the first command.  If the result of that is successful, 	     then execute the second command, otherwise return. */
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
condition|)
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_result
operator|==
name|EXECUTION_SUCCESS
condition|)
block|{
if|if
condition|(
name|ignore_return
operator|&&
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OR_OR
case|:
if|if
condition|(
name|asynchronous
condition|)
block|{
comment|/* If we have something like `a || b&', run the || stuff in a 		 subshell.  Force a subshell and just call 		 execute_command_internal again.  Leave asynchronous on 		 so that we get a report from the parent shell about the 		 background job. */
name|command
operator|->
name|flags
operator||=
name|CMD_FORCE_SUBSHELL
expr_stmt|;
name|exec_result
operator|=
name|execute_command_internal
argument_list|(
name|command
argument_list|,
literal|1
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Execute the first command.  If the result of that is successful, 	     then return, otherwise execute the second command. */
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
condition|)
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_result
operator|!=
name|EXECUTION_SUCCESS
condition|)
block|{
if|if
condition|(
name|ignore_return
operator|&&
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|exec_result
operator|=
name|execute_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|programming_error
argument_list|(
literal|"Bad connector `%d'!"
argument_list|,
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|connector
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|cm_function_def
case|:
name|exec_result
operator|=
name|intern_function
argument_list|(
name|command
operator|->
name|value
operator|.
name|Function_def
operator|->
name|name
argument_list|,
name|command
operator|->
name|value
operator|.
name|Function_def
operator|->
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|programming_error
argument_list|(
literal|"execute_command: Bad command type `%d'!"
argument_list|,
name|command
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|my_undo_list
condition|)
block|{
name|do_redirections
argument_list|(
name|my_undo_list
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dispose_redirects
argument_list|(
name|my_undo_list
argument_list|)
expr_stmt|;
block|}
name|discard_unwind_frame
argument_list|(
literal|"loop_redirections"
argument_list|)
expr_stmt|;
comment|/* Invert the return value if we have to */
if|if
condition|(
name|invert
condition|)
block|{
if|if
condition|(
name|exec_result
operator|==
name|EXECUTION_SUCCESS
condition|)
name|exec_result
operator|=
name|EXECUTION_FAILURE
expr_stmt|;
else|else
name|exec_result
operator|=
name|EXECUTION_SUCCESS
expr_stmt|;
block|}
name|last_command_exit_value
operator|=
name|exec_result
expr_stmt|;
name|run_pending_traps
argument_list|()
expr_stmt|;
return|return
operator|(
name|last_command_exit_value
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Execute a FOR command.  The syntax is: FOR word_desc IN word_list;    DO command; DONE */
end_comment

begin_macro
name|execute_for_command
argument_list|(
argument|for_command
argument_list|)
end_macro

begin_decl_stmt
name|FOR_COM
modifier|*
name|for_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* I just noticed that the Bourne shell leaves word_desc bound to the      last name in word_list after the FOR statement is done.  This seems      wrong to me; I thought that the variable binding should be lexically      scoped, i.e., only would last the duration of the FOR command.  This      behaviour can be gotten by turning on the lexical_scoping switch. */
specifier|register
name|WORD_LIST
modifier|*
name|releaser
decl_stmt|,
modifier|*
name|list
decl_stmt|;
name|WORD_DESC
modifier|*
name|temp
init|=
name|for_command
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|identifier
decl_stmt|;
name|SHELL_VAR
modifier|*
name|old_value
init|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Remember the old value of x. */
name|int
name|retval
init|=
name|EXECUTION_SUCCESS
decl_stmt|;
specifier|extern
name|int
name|dispose_words
parameter_list|()
function_decl|;
specifier|extern
name|int
name|dispose_variable
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|check_identifier
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
name|loop_level
operator|++
expr_stmt|;
name|identifier
operator|=
name|temp
operator|->
name|word
expr_stmt|;
name|list
operator|=
name|releaser
operator|=
name|expand_words
argument_list|(
name|for_command
operator|->
name|map_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|begin_unwind_frame
argument_list|(
literal|"for"
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|dispose_words
argument_list|,
name|releaser
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexical_scoping
condition|)
block|{
name|old_value
operator|=
name|copy_variable
argument_list|(
name|find_variable
argument_list|(
name|identifier
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_value
condition|)
name|add_unwind_protect
argument_list|(
name|dispose_variable
argument_list|,
name|old_value
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|list
condition|)
block|{
name|QUIT
expr_stmt|;
name|bind_variable
argument_list|(
name|identifier
argument_list|,
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_command
operator|->
name|flags
operator|&
name|CMD_IGNORE_RETURN
condition|)
name|for_command
operator|->
name|action
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|execute_command
argument_list|(
name|for_command
operator|->
name|action
argument_list|)
expr_stmt|;
name|retval
operator|=
name|last_command_exit_value
expr_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|breaking
condition|)
block|{
name|breaking
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|continuing
condition|)
block|{
name|continuing
operator|--
expr_stmt|;
if|if
condition|(
name|continuing
condition|)
break|break;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|loop_level
operator|--
expr_stmt|;
if|if
condition|(
name|lexical_scoping
condition|)
block|{
if|if
condition|(
operator|!
name|old_value
condition|)
name|makunbound
argument_list|(
name|identifier
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
else|else
block|{
name|SHELL_VAR
modifier|*
name|new_value
decl_stmt|;
name|new_value
operator|=
name|bind_variable
argument_list|(
name|identifier
argument_list|,
name|value_cell
argument_list|(
name|old_value
argument_list|)
argument_list|)
expr_stmt|;
name|new_value
operator|->
name|attributes
operator|=
name|old_value
operator|->
name|attributes
expr_stmt|;
block|}
block|}
name|run_unwind_frame
argument_list|(
literal|"for"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Execute a CASE command.  The syntax is: CASE word_desc IN pattern_list ESAC.    The pattern_list is a linked list of pattern clauses; each clause contains    some patterns to compare word_desc against, and an associated command to    execute. */
end_comment

begin_macro
name|execute_case_command
argument_list|(
argument|case_command
argument_list|)
end_macro

begin_decl_stmt
name|CASE_COM
modifier|*
name|case_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|dispose_words
parameter_list|()
function_decl|;
specifier|register
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
name|WORD_LIST
modifier|*
name|wlist
decl_stmt|;
name|PATTERN_LIST
modifier|*
name|clauses
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|wlist
operator|=
name|expand_word
argument_list|(
name|case_command
operator|->
name|word
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clauses
operator|=
name|case_command
operator|->
name|clauses
expr_stmt|;
name|word
operator|=
operator|(
name|wlist
operator|)
condition|?
name|string_list
argument_list|(
name|wlist
argument_list|)
else|:
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EXECUTION_SUCCESS
expr_stmt|;
name|begin_unwind_frame
argument_list|(
literal|"case"
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|dispose_words
argument_list|,
name|wlist
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
operator|(
name|Function
operator|*
operator|)
name|vfree
argument_list|,
name|word
argument_list|)
expr_stmt|;
while|while
condition|(
name|clauses
condition|)
block|{
name|QUIT
expr_stmt|;
name|list
operator|=
name|clauses
operator|->
name|patterns
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|WORD_LIST
modifier|*
name|es
init|=
name|expand_word
argument_list|(
name|list
operator|->
name|word
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pattern
init|=
operator|(
name|es
operator|)
condition|?
name|es
operator|->
name|word
operator|->
name|word
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|word
argument_list|,
name|FNM_NOESCAPE
argument_list|)
operator|!=
name|FNM_NOMATCH
condition|)
block|{
name|dispose_words
argument_list|(
name|es
argument_list|)
expr_stmt|;
if|if
condition|(
name|clauses
operator|->
name|action
operator|&&
operator|(
name|case_command
operator|->
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
condition|)
name|clauses
operator|->
name|action
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|execute_command
argument_list|(
name|clauses
operator|->
name|action
argument_list|)
expr_stmt|;
name|retval
operator|=
name|last_command_exit_value
expr_stmt|;
goto|goto
name|exit_command
goto|;
block|}
name|dispose_words
argument_list|(
name|es
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
name|clauses
operator|=
name|clauses
operator|->
name|next
expr_stmt|;
block|}
name|exit_command
label|:
name|run_unwind_frame
argument_list|(
literal|"case"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|CMD_WHILE
value|0
end_define

begin_define
define|#
directive|define
name|CMD_UNTIL
value|1
end_define

begin_comment
comment|/* The WHILE command.  Syntax: WHILE test DO action; DONE.    Repeatedly execute action while executing test produces    EXECUTION_SUCCESS. */
end_comment

begin_macro
name|execute_while_command
argument_list|(
argument|while_command
argument_list|)
end_macro

begin_decl_stmt
name|WHILE_COM
modifier|*
name|while_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|execute_while_or_until
argument_list|(
name|while_command
argument_list|,
name|CMD_WHILE
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* UNTIL is just like WHILE except that the test result is negated. */
end_comment

begin_macro
name|execute_until_command
argument_list|(
argument|while_command
argument_list|)
end_macro

begin_decl_stmt
name|WHILE_COM
modifier|*
name|while_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|execute_while_or_until
argument_list|(
name|while_command
argument_list|,
name|CMD_UNTIL
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* The body for both while and until.  The only difference between the    two is that the test value is treated differently.  TYPE is    CMD_WHILE or CMD_UNTIL.  The return value for both commands should    be EXECUTION_SUCCESS if no commands in the body are executed, and    the status of the last command executed in the body otherwise. */
end_comment

begin_macro
name|execute_while_or_until
argument_list|(
argument|while_command
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|WHILE_COM
modifier|*
name|while_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|breaking
decl_stmt|;
specifier|extern
name|int
name|continuing
decl_stmt|;
name|int
name|commands_executed
init|=
literal|0
decl_stmt|;
name|int
name|return_value
decl_stmt|;
name|loop_level
operator|++
expr_stmt|;
name|while_command
operator|->
name|test
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|return_value
operator|=
name|execute_command
argument_list|(
name|while_command
operator|->
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CMD_WHILE
operator|&&
name|return_value
operator|!=
name|EXECUTION_SUCCESS
condition|)
break|break;
if|if
condition|(
name|type
operator|==
name|CMD_UNTIL
operator|&&
name|return_value
operator|==
name|EXECUTION_SUCCESS
condition|)
break|break;
name|QUIT
expr_stmt|;
name|commands_executed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|while_command
operator|->
name|flags
operator|&
name|CMD_IGNORE_RETURN
condition|)
name|while_command
operator|->
name|action
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|execute_command
argument_list|(
name|while_command
operator|->
name|action
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|breaking
condition|)
block|{
name|breaking
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|continuing
condition|)
block|{
name|continuing
operator|--
expr_stmt|;
if|if
condition|(
name|continuing
condition|)
break|break;
block|}
block|}
name|loop_level
operator|--
expr_stmt|;
if|if
condition|(
name|commands_executed
condition|)
return|return
operator|(
name|last_command_exit_value
operator|)
return|;
else|else
return|return
operator|(
name|EXECUTION_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/* IF test THEN command [ELSE command].    IF also allows ELIF in the place of ELSE IF, but    the parser makes *that* stupidity transparent. */
end_comment

begin_macro
name|execute_if_command
argument_list|(
argument|if_command
argument_list|)
end_macro

begin_decl_stmt
name|IF_COM
modifier|*
name|if_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|return_value
decl_stmt|;
name|if_command
operator|->
name|test
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|return_value
operator|=
name|execute_command
argument_list|(
name|if_command
operator|->
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_value
operator|==
name|EXECUTION_SUCCESS
condition|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|if_command
operator|->
name|true_case
operator|&&
operator|(
name|if_command
operator|->
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
condition|)
name|if_command
operator|->
name|true_case
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
return|return
operator|(
name|execute_command
argument_list|(
name|if_command
operator|->
name|true_case
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|if_command
operator|->
name|false_case
operator|&&
operator|(
name|if_command
operator|->
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
condition|)
block|{
name|if_command
operator|->
name|false_case
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
block|}
return|return
operator|(
name|execute_command
argument_list|(
name|if_command
operator|->
name|false_case
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* The name of the command that is currently being executed.    `test' needs this, for example. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|this_command_name
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bind_lastarg
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|arg
operator|=
literal|""
expr_stmt|;
name|var
operator|=
name|bind_variable
argument_list|(
literal|"_"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|var
operator|->
name|attributes
operator|&=
operator|~
name|att_exported
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For catching RETURN in a function. */
end_comment

begin_decl_stmt
name|int
name|return_catch_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|return_catch_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|return_catch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The meaty part of all the executions.  We have to start hacking the    real execution of commands here.  Fork a process, set things up,    execute the command. */
end_comment

begin_macro
name|execute_simple_command
argument_list|(
argument|simple_command
argument_list|,
argument|pipe_in
argument_list|,
argument|pipe_out
argument_list|,
argument|async
argument_list|,
argument|fds_to_close
argument_list|)
end_macro

begin_decl_stmt
name|SIMPLE_COM
modifier|*
name|simple_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pipe_in
decl_stmt|,
name|pipe_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fd_bitmap
modifier|*
name|fds_to_close
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|command_string_index
decl_stmt|,
name|variable_context
decl_stmt|,
name|line_number
decl_stmt|;
specifier|extern
name|char
modifier|*
name|the_printed_command
decl_stmt|;
specifier|extern
name|pid_t
name|last_command_subst_pid
decl_stmt|;
name|WORD_LIST
modifier|*
name|expand_words
argument_list|()
decl_stmt|,
modifier|*
name|copy_word_list
argument_list|()
decl_stmt|;
name|WORD_LIST
modifier|*
name|words
decl_stmt|,
modifier|*
name|lastword
decl_stmt|;
name|char
modifier|*
name|command_line
decl_stmt|,
modifier|*
name|lastarg
decl_stmt|;
name|int
name|first_word_quoted
decl_stmt|,
name|result
decl_stmt|;
name|pid_t
name|old_last_command_subst_pid
decl_stmt|;
name|result
operator|=
name|EXECUTION_SUCCESS
expr_stmt|;
comment|/* If we're in a function, update the pseudo-line-number information. */
if|if
condition|(
name|variable_context
condition|)
name|line_number
operator|++
expr_stmt|;
comment|/* Remember what this command line looks like at invocation. */
name|command_string_index
operator|=
literal|0
expr_stmt|;
name|print_simple_command
argument_list|(
name|simple_command
argument_list|)
expr_stmt|;
name|command_line
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|the_printed_command
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|command_line
argument_list|,
name|the_printed_command
argument_list|)
expr_stmt|;
name|first_word_quoted
operator|=
name|simple_command
operator|->
name|words
condition|?
name|simple_command
operator|->
name|words
operator|->
name|word
operator|->
name|quoted
else|:
literal|0
expr_stmt|;
name|old_last_command_subst_pid
operator|=
name|last_command_subst_pid
expr_stmt|;
comment|/* If we are re-running this as the result of executing the `command'      builtin, do not expand the command words a second time. */
if|if
condition|(
operator|(
name|simple_command
operator|->
name|flags
operator|&
name|CMD_INHIBIT_EXPANSION
operator|)
operator|==
literal|0
condition|)
name|words
operator|=
name|expand_words
argument_list|(
name|simple_command
operator|->
name|words
argument_list|)
expr_stmt|;
else|else
name|words
operator|=
name|copy_word_list
argument_list|(
name|simple_command
operator|->
name|words
argument_list|)
expr_stmt|;
name|lastarg
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|begin_unwind_frame
argument_list|(
literal|"simple-command"
argument_list|)
expr_stmt|;
comment|/* It is possible for WORDS not to have anything left in it.      Perhaps all the words consisted of `$foo', and there was      no variable `$foo'. */
if|if
condition|(
name|words
condition|)
block|{
specifier|extern
name|int
name|dispose_words
parameter_list|()
function_decl|;
specifier|extern
name|Function
modifier|*
name|last_shell_builtin
decl_stmt|,
modifier|*
name|this_shell_builtin
decl_stmt|;
name|Function
modifier|*
name|builtin
decl_stmt|;
name|SHELL_VAR
modifier|*
name|func
decl_stmt|;
name|char
modifier|*
name|auto_resume_value
decl_stmt|;
if|if
condition|(
name|echo_command_at_execute
condition|)
block|{
specifier|extern
name|char
modifier|*
name|indirection_level_string
parameter_list|()
function_decl|;
name|char
modifier|*
name|line
init|=
name|string_list
argument_list|(
name|words
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
operator|&&
operator|*
name|line
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s\n"
argument_list|,
name|indirection_level_string
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|simple_command
operator|->
name|flags
operator|&
name|CMD_NO_FUNCTIONS
condition|)
name|func
operator|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
name|func
operator|=
name|find_function
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|dispose_words
argument_list|,
name|words
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
comment|/* Bind the last word in this command to "$_" after execution. */
for|for
control|(
name|lastword
operator|=
name|words
init|;
name|lastword
operator|->
name|next
condition|;
name|lastword
operator|=
name|lastword
operator|->
name|next
control|)
empty_stmt|;
name|lastarg
operator|=
name|lastword
operator|->
name|word
operator|->
name|word
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
comment|/* Is this command a job control related thing? */
if|if
condition|(
name|words
operator|->
name|word
operator|->
name|word
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|async
condition|)
name|this_command_name
operator|=
literal|"bg"
expr_stmt|;
else|else
name|this_command_name
operator|=
literal|"fg"
expr_stmt|;
name|last_shell_builtin
operator|=
name|this_shell_builtin
expr_stmt|;
name|this_shell_builtin
operator|=
name|builtin_address
argument_list|(
name|this_command_name
argument_list|)
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|this_shell_builtin
call|)
argument_list|(
name|words
argument_list|)
expr_stmt|;
goto|goto
name|return_result
goto|;
block|}
comment|/* One other possiblilty.  The user may want to resume an existing job. 	 If they do, find out whether this word is a candidate for a running 	 job. */
if|if
condition|(
operator|(
name|auto_resume_value
operator|=
name|get_string_value
argument_list|(
literal|"auto_resume"
argument_list|)
operator|)
operator|&&
operator|!
name|first_word_quoted
operator|&&
operator|!
name|words
operator|->
name|next
operator|&&
name|words
operator|->
name|word
operator|->
name|word
index|[
literal|0
index|]
operator|&&
operator|!
name|simple_command
operator|->
name|redirects
operator|&&
name|pipe_in
operator|==
name|NO_PIPE
operator|&&
name|pipe_out
operator|==
name|NO_PIPE
operator|&&
operator|!
name|async
condition|)
block|{
name|char
modifier|*
name|word
init|=
name|words
operator|->
name|word
operator|->
name|word
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|wl
init|=
name|strlen
argument_list|(
name|word
argument_list|)
decl_stmt|,
name|exact
decl_stmt|;
name|exact
operator|=
name|strcmp
argument_list|(
name|auto_resume_value
argument_list|,
literal|"exact"
argument_list|)
operator|==
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|job_slots
operator|-
literal|1
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|i
index|]
condition|)
block|{
specifier|register
name|PROCESS
modifier|*
name|p
init|=
name|jobs
index|[
name|i
index|]
operator|->
name|pipe
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|JOBSTATE
argument_list|(
name|i
argument_list|)
operator|==
name|JSTOPPED
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
operator|->
name|command
argument_list|,
name|word
argument_list|,
name|exact
condition|?
name|strlen
argument_list|(
name|p
operator|->
name|command
argument_list|)
else|:
name|wl
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|started_status
decl_stmt|;
name|run_unwind_frame
argument_list|(
literal|"simple-command"
argument_list|)
expr_stmt|;
name|last_shell_builtin
operator|=
name|this_shell_builtin
expr_stmt|;
name|this_shell_builtin
operator|=
name|builtin_address
argument_list|(
literal|"fg"
argument_list|)
expr_stmt|;
name|started_status
operator|=
name|start_job
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|started_status
operator|<
literal|0
condition|)
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
else|else
return|return
operator|(
name|started_status
operator|)
return|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|jobs
index|[
name|i
index|]
operator|->
name|pipe
condition|)
do|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* JOB_CONTROL */
comment|/* Remember the name of this command globally. */
name|this_command_name
operator|=
name|words
operator|->
name|word
operator|->
name|word
expr_stmt|;
name|QUIT
expr_stmt|;
comment|/* Not a running job.  Do normal command processing. */
name|maybe_make_export_env
argument_list|()
expr_stmt|;
comment|/* This command could be a shell builtin or a user-defined function. 	 If so, and we have pipes, then fork a subshell in here.  Else, just 	 do the command. */
if|if
condition|(
name|func
condition|)
name|builtin
operator|=
operator|(
name|Function
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
name|builtin
operator|=
name|find_shell_builtin
argument_list|(
name|this_command_name
argument_list|)
expr_stmt|;
name|last_shell_builtin
operator|=
name|this_shell_builtin
expr_stmt|;
name|this_shell_builtin
operator|=
name|builtin
expr_stmt|;
if|if
condition|(
name|builtin
operator|||
name|func
condition|)
block|{
name|put_command_name_into_env
argument_list|(
name|this_command_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pipe_in
operator|!=
name|NO_PIPE
operator|)
operator|||
operator|(
name|pipe_out
operator|!=
name|NO_PIPE
operator|)
operator|||
name|async
condition|)
block|{
if|if
condition|(
name|make_child
argument_list|(
name|savestring
argument_list|(
name|command_line
argument_list|)
argument_list|,
name|async
argument_list|)
operator|==
literal|0
condition|)
block|{
name|execute_subshell_builtin_or_function
argument_list|(
name|words
argument_list|,
name|simple_command
operator|->
name|redirects
argument_list|,
name|builtin
argument_list|,
name|func
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|async
argument_list|,
name|fds_to_close
argument_list|,
name|simple_command
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close_pipes
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
goto|goto
name|return_result
goto|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|execute_builtin_or_function
argument_list|(
name|words
argument_list|,
name|builtin
argument_list|,
name|func
argument_list|,
name|simple_command
operator|->
name|redirects
argument_list|,
name|fds_to_close
argument_list|,
name|simple_command
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|return_result
goto|;
block|}
block|}
name|execute_disk_command
argument_list|(
name|words
argument_list|,
name|simple_command
operator|->
name|redirects
argument_list|,
name|command_line
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|async
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
goto|goto
name|return_result
goto|;
block|}
elseif|else
if|if
condition|(
name|pipe_in
operator|!=
name|NO_PIPE
operator|||
name|pipe_out
operator|!=
name|NO_PIPE
operator|||
name|async
condition|)
block|{
comment|/* We have a null command, but we really want a subshell to take 	 care of it.  Just fork, do piping and redirections, and exit. */
if|if
condition|(
name|make_child
argument_list|(
name|savestring
argument_list|(
literal|""
argument_list|)
argument_list|,
name|async
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_piping
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_redirections
argument_list|(
name|simple_command
operator|->
name|redirects
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
name|EXECUTION_SUCCESS
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
name|EXECUTION_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close_pipes
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
name|result
operator|=
name|EXECUTION_SUCCESS
expr_stmt|;
goto|goto
name|return_result
goto|;
block|}
block|}
else|else
block|{
comment|/* Even if there aren't any command names, pretend to do the 	 redirections that are specified.  The user expects the side 	 effects to take place.  If the redirections fail, then return 	 failure.  Otherwise, if a command substitution took place while 	 expanding the command or a redirection, return the value of that 	 substition.  Otherwise, return EXECUTION_SUCCESS. */
if|if
condition|(
name|do_redirections
argument_list|(
name|simple_command
operator|->
name|redirects
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|EXECUTION_FAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|old_last_command_subst_pid
operator|!=
name|last_command_subst_pid
condition|)
name|result
operator|=
name|last_command_exit_value
expr_stmt|;
else|else
name|result
operator|=
name|EXECUTION_SUCCESS
expr_stmt|;
block|}
name|return_result
label|:
name|bind_lastarg
argument_list|(
name|lastarg
argument_list|)
expr_stmt|;
name|run_unwind_frame
argument_list|(
literal|"simple-command"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Execute a shell builtin or function in a subshell environment.  This    routine does not return; it only calls exit().  If BUILTIN is non-null,    it points to a function to call to execute a shell builtin; otherwise    VAR points at the body of a function to execute.  WORDS is the arguments    to the command, REDIRECTS specifies redirections to perform before the    command is executed. */
end_comment

begin_function
specifier|static
name|void
name|execute_subshell_builtin_or_function
parameter_list|(
name|words
parameter_list|,
name|redirects
parameter_list|,
name|builtin
parameter_list|,
name|var
parameter_list|,
name|pipe_in
parameter_list|,
name|pipe_out
parameter_list|,
name|async
parameter_list|,
name|fds_to_close
parameter_list|,
name|flags
parameter_list|)
name|WORD_LIST
modifier|*
name|words
decl_stmt|;
name|REDIRECT
modifier|*
name|redirects
decl_stmt|;
name|Function
modifier|*
name|builtin
decl_stmt|;
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
name|int
name|pipe_in
decl_stmt|,
name|pipe_out
decl_stmt|,
name|async
decl_stmt|;
name|struct
name|fd_bitmap
modifier|*
name|fds_to_close
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|extern
name|int
name|login_shell
decl_stmt|,
name|interactive
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
specifier|extern
name|int
name|jobs_builtin
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
comment|/* A subshell is neither a login shell nor interactive. */
name|login_shell
operator|=
name|interactive
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
comment|/* Eradicate all traces of job control after we fork the subshell, so      all jobs begun by this subshell are in the same process group as      the shell itself. */
comment|/* Allow the output of `jobs' to be piped. */
if|if
condition|(
name|builtin
operator|==
name|jobs_builtin
operator|&&
operator|!
name|async
operator|&&
operator|(
name|pipe_out
operator|!=
name|NO_PIPE
operator|||
name|pipe_in
operator|!=
name|NO_PIPE
operator|)
condition|)
name|kill_current_pipeline
argument_list|()
expr_stmt|;
else|else
name|without_job_control
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
name|do_piping
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds_to_close
condition|)
name|close_fd_bitmap
argument_list|(
name|fds_to_close
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_redirections
argument_list|(
name|redirects
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EXECUTION_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin
condition|)
block|{
specifier|extern
name|jmp_buf
name|top_level
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* Save the values of pipe_in and pipe_out for 	 possible later use by parse_and_execute (). */
name|builtin_pipe_in
operator|=
name|pipe_in
expr_stmt|;
name|builtin_pipe_out
operator|=
name|pipe_out
expr_stmt|;
comment|/* Give builtins a place to jump back to on failure, 	 so we don't go back up to main(). */
name|result
operator|=
name|setjmp
argument_list|(
name|top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|exit
argument_list|(
name|result
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
call|(
modifier|*
name|builtin
call|)
argument_list|(
name|words
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|int
name|variable_context
decl_stmt|,
name|line_number
decl_stmt|;
specifier|extern
name|void
name|dispose_command
parameter_list|()
function_decl|;
name|COMMAND
modifier|*
name|fc
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|int
name|result
decl_stmt|,
name|return_val
decl_stmt|;
name|tc
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|function_cell
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|fc
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
expr_stmt|;
name|remember_args
argument_list|(
name|words
operator|->
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|line_number
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|stop_pipeline
argument_list|(
name|async
argument_list|,
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|begin_unwind_frame
argument_list|(
literal|"subshell_function_calling"
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|variable_context
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|return_catch_flag
argument_list|)
expr_stmt|;
name|unwind_protect_jmp_buf
argument_list|(
name|return_catch
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|dispose_command
argument_list|,
name|fc
argument_list|)
expr_stmt|;
comment|/* We can do this because function bodies are always guaranteed to 	 be group commands, according to the grammar in parse.y.  If we 	 don't do this now, execute_command_internal will graciously fork 	 another subshell for us, and we'll lose contact with the rest of 	 the pipeline and fail to get any SIGPIPE that might be sent. */
if|if
condition|(
name|tc
operator|->
name|type
operator|==
name|cm_group
condition|)
name|fc
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|copy_command
argument_list|(
name|tc
operator|->
name|value
operator|.
name|Group
operator|->
name|command
argument_list|)
expr_stmt|;
else|else
name|fc
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|copy_command
argument_list|(
name|tc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|&&
operator|(
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
condition|)
name|fc
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
comment|/* result = execute_command (fc); doesn't work. 	 We need to explicitly specify the pipes in and out so that they 	 are closed in all the processes that rely on their being closed. 	 If they are not, it is possible to not get the SIGPIPE that we 	 need to kill all the processes sharing the pipe. */
name|variable_context
operator|++
expr_stmt|;
name|return_catch_flag
operator|++
expr_stmt|;
name|return_val
operator|=
name|setjmp
argument_list|(
name|return_catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_val
condition|)
name|result
operator|=
name|return_catch_value
expr_stmt|;
else|else
name|result
operator|=
name|execute_command_internal
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
name|pipe_in
argument_list|,
name|pipe_out
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
name|run_unwind_frame
argument_list|(
literal|"subshell_function_calling"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Execute a builtin or function in the current shell context.  If BUILTIN    is non-null, it is the builtin command to execute, otherwise VAR points    to the body of a function.  WORDS are the command's arguments, REDIRECTS    are the redirections to perform.  FDS_TO_CLOSE is the usual bitmap of    file descriptors to close.     If BUILTIN is exec_builtin, the redirections specified in REDIRECTS are    not undone before this function returns. */
end_comment

begin_function
specifier|static
name|int
name|execute_builtin_or_function
parameter_list|(
name|words
parameter_list|,
name|builtin
parameter_list|,
name|var
parameter_list|,
name|redirects
parameter_list|,
name|fds_to_close
parameter_list|,
name|flags
parameter_list|)
name|WORD_LIST
modifier|*
name|words
decl_stmt|;
name|Function
modifier|*
name|builtin
decl_stmt|;
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
name|REDIRECT
modifier|*
name|redirects
decl_stmt|;
name|struct
name|fd_bitmap
modifier|*
name|fds_to_close
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|extern
name|int
name|exec_builtin
argument_list|()
decl_stmt|,
name|eval_builtin
argument_list|()
decl_stmt|;
name|int
name|result
init|=
name|EXECUTION_FAILURE
decl_stmt|;
name|int
name|redir_result
decl_stmt|;
name|REDIRECT
modifier|*
name|saved_undo_list
decl_stmt|;
name|redir_result
operator|=
name|do_redirections
argument_list|(
name|redirects
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|redir_result
operator|!=
literal|0
condition|)
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
name|saved_undo_list
operator|=
name|redirection_undo_list
expr_stmt|;
comment|/* Calling the "exec" builtin changes redirections forever. */
if|if
condition|(
name|builtin
operator|==
name|exec_builtin
condition|)
block|{
name|dispose_redirects
argument_list|(
name|saved_undo_list
argument_list|)
expr_stmt|;
name|saved_undo_list
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|begin_unwind_frame
argument_list|(
literal|"saved redirects"
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|cleanup_func_redirects
argument_list|,
operator|(
name|char
operator|*
operator|)
name|saved_undo_list
argument_list|)
expr_stmt|;
block|}
name|redirection_undo_list
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|builtin
condition|)
block|{
name|int
name|old_e_flag
init|=
name|exit_immediately_on_error
decl_stmt|;
comment|/* The eval builtin calls parse_and_execute, which does not know about 	 the setting of flags, and always calls the execution functions with 	 flags that will exit the shell on an error if -e is set.  If the 	 eval builtin is being called, and we're supposed to ignore the exit 	 value of the command, we turn the -e flag off ourselves, then 	 restore it when the command completes. */
if|if
condition|(
operator|(
name|builtin
operator|==
name|eval_builtin
operator|)
operator|&&
operator|(
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
condition|)
block|{
name|begin_unwind_frame
argument_list|(
literal|"eval_builtin"
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|exit_immediately_on_error
argument_list|)
expr_stmt|;
name|exit_immediately_on_error
operator|=
literal|0
expr_stmt|;
block|}
name|result
operator|=
operator|(
call|(
modifier|*
name|builtin
call|)
argument_list|(
name|words
operator|->
name|next
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|builtin
operator|==
name|eval_builtin
operator|)
operator|&&
operator|(
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
condition|)
block|{
name|exit_immediately_on_error
operator|+=
name|old_e_flag
expr_stmt|;
name|discard_unwind_frame
argument_list|(
literal|"eval_builtin"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|extern
name|void
name|dispose_command
parameter_list|()
function_decl|;
specifier|extern
name|int
name|pop_context
parameter_list|()
function_decl|;
specifier|extern
name|int
name|line_number
decl_stmt|;
name|int
name|return_val
decl_stmt|;
name|COMMAND
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|copy_command
argument_list|(
name|function_cell
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|&&
operator|(
name|flags
operator|&
name|CMD_IGNORE_RETURN
operator|)
condition|)
name|tc
operator|->
name|flags
operator||=
name|CMD_IGNORE_RETURN
expr_stmt|;
name|begin_unwind_frame
argument_list|(
literal|"function_calling"
argument_list|)
expr_stmt|;
name|push_context
argument_list|()
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|pop_context
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|dispose_command
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tc
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|return_catch_flag
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|line_number
argument_list|)
expr_stmt|;
name|unwind_protect_jmp_buf
argument_list|(
name|return_catch
argument_list|)
expr_stmt|;
comment|/* Note the second argument of "1", meaning that we discard 	 the current value of "$*"!  This is apparently the right thing. */
name|remember_args
argument_list|(
name|words
operator|->
name|next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|line_number
operator|=
literal|0
expr_stmt|;
name|return_catch_flag
operator|++
expr_stmt|;
name|return_val
operator|=
name|setjmp
argument_list|(
name|return_catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_val
condition|)
name|result
operator|=
name|return_catch_value
expr_stmt|;
else|else
name|result
operator|=
name|execute_command_internal
argument_list|(
name|tc
argument_list|,
literal|0
argument_list|,
name|NO_PIPE
argument_list|,
name|NO_PIPE
argument_list|,
name|fds_to_close
argument_list|)
expr_stmt|;
name|run_unwind_frame
argument_list|(
literal|"function_calling"
argument_list|)
expr_stmt|;
block|}
name|redirection_undo_list
operator|=
name|saved_undo_list
expr_stmt|;
if|if
condition|(
name|builtin
operator|!=
name|exec_builtin
condition|)
name|discard_unwind_frame
argument_list|(
literal|"saved redirects"
argument_list|)
expr_stmt|;
name|do_redirections
argument_list|(
name|redirection_undo_list
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Execute a simple command that is hopefully defined in a disk file    somewhere.     1) fork ()    2) connect pipes    3) look up the command    4) do redirections    5) execve ()    6) If the execve failed, see if the file has executable mode set.    If so, and it isn't a directory, then execute its contents as    a shell script.     Note that the filename hashing stuff has to take place up here,    in the parent.  This is probably why the Bourne style shells    don't handle it, since that would require them to go through    this gnarly hair, for no good reason.  */
end_comment

begin_function
specifier|static
name|void
name|execute_disk_command
parameter_list|(
name|words
parameter_list|,
name|redirects
parameter_list|,
name|command_line
parameter_list|,
name|pipe_in
parameter_list|,
name|pipe_out
parameter_list|,
name|async
parameter_list|,
name|fds_to_close
parameter_list|)
name|WORD_LIST
modifier|*
name|words
decl_stmt|;
name|REDIRECT
modifier|*
name|redirects
decl_stmt|;
name|char
modifier|*
name|command_line
decl_stmt|;
name|int
name|pipe_in
decl_stmt|,
name|pipe_out
decl_stmt|,
name|async
decl_stmt|;
name|struct
name|fd_bitmap
modifier|*
name|fds_to_close
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|make_word_array
argument_list|()
decl_stmt|,
modifier|*
name|find_user_command
argument_list|()
decl_stmt|,
modifier|*
name|find_hashed_filename
argument_list|()
decl_stmt|;
name|char
modifier|*
name|hashed_file
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|command
decl_stmt|,
modifier|*
modifier|*
name|args
decl_stmt|;
comment|/* Don't waste time trying to find hashed data for a pathname      that is already completely specified. */
if|if
condition|(
operator|!
name|absolute_program
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
condition|)
name|hashed_file
operator|=
name|find_hashed_filename
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashed_file
condition|)
name|command
operator|=
name|savestring
argument_list|(
name|hashed_file
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* A command containing a slash is not looked up in PATH. */
if|if
condition|(
name|absolute_program
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
condition|)
name|command
operator|=
name|savestring
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
else|else
name|command
operator|=
name|find_user_command
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|&&
operator|!
name|hashing_disabled
condition|)
block|{
specifier|extern
name|int
name|dot_found_in_search
decl_stmt|;
comment|/* A command name containing a slash is not saved in the 	     hash table. */
if|if
condition|(
operator|!
name|absolute_program
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
condition|)
name|remember_filename
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|,
name|command
argument_list|,
name|dot_found_in_search
argument_list|)
expr_stmt|;
comment|/* Increase the number of hits to 1. */
name|find_hashed_filename
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|command
condition|)
block|{
name|put_command_name_into_env
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
comment|/* We have to make the child before we check for the non-existance      of COMMAND, since we want the error messages to be redirected. */
if|if
condition|(
name|make_child
argument_list|(
name|savestring
argument_list|(
name|command_line
argument_list|)
argument_list|,
name|async
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_piping
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
comment|/* Execve expects the command name to be in args[0].  So we 	 leave it there, in the same format that the user used to 	 type it in. */
name|args
operator|=
name|make_word_array
argument_list|(
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_redirections
argument_list|(
name|redirects
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EXECUTION_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|command
condition|)
block|{
name|report_error
argument_list|(
literal|"%s: command not found"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXECUTION_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* This functionality is now provided by close-on-exec of the 	 file descriptors manipulated by redirection and piping. 	 Some file descriptors still need to be closed in all children 	 because of the way bash does pipes; fds_to_close is a  	 bitmap of all such file descriptors. */
if|if
condition|(
name|fds_to_close
condition|)
name|close_fd_bitmap
argument_list|(
name|fds_to_close
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|shell_execve
argument_list|(
name|command
argument_list|,
name|args
argument_list|,
name|export_env
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure that the pipes are closed in the parent. */
name|close_pipes
argument_list|(
name|pipe_in
argument_list|,
name|pipe_out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the operating system on which we're running does not handle    the #! executable format, then help out.  SAMPLE is the text read    from the file, SAMPLE_LEN characters.  COMMAND is the name of    the script; it and ARGS, the arguments given by the user, will    become arguments to the specified interpreter.  ENV is the environment    to pass to the interpreter.     The word immediately following the #! is the interpreter to execute.    A single argument to the interpreter is allowed. */
end_comment

begin_function
specifier|static
name|int
name|execute_shell_script
parameter_list|(
name|sample
parameter_list|,
name|sample_len
parameter_list|,
name|command
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|unsigned
name|char
modifier|*
name|sample
decl_stmt|;
name|int
name|sample_len
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|,
decl|*
modifier|*
name|env
decl_stmt|;
end_function

begin_block
block|{
specifier|extern
name|char
modifier|*
name|shell_name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|execname
decl_stmt|,
modifier|*
name|firstarg
decl_stmt|;
name|int
name|start
decl_stmt|,
name|size_increment
decl_stmt|,
name|larry
decl_stmt|;
comment|/* Find the name of the interpreter to exec. */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|whitespace
argument_list|(
name|sample
index|[
name|i
index|]
argument_list|)
operator|&&
name|i
operator|<
name|sample_len
condition|;
name|i
operator|++
control|)
empty_stmt|;
for|for
control|(
name|start
operator|=
name|i
init|;
operator|!
name|whitespace
argument_list|(
name|sample
index|[
name|i
index|]
argument_list|)
operator|&&
name|sample
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
name|i
operator|<
name|sample_len
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|execname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|execname
argument_list|,
name|sample
operator|+
name|start
argument_list|,
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|execname
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|size_increment
operator|=
literal|1
expr_stmt|;
comment|/* Now the argument, if any. */
name|firstarg
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|start
operator|=
name|i
init|;
name|whitespace
argument_list|(
name|sample
index|[
name|i
index|]
argument_list|)
operator|&&
name|sample
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
name|i
operator|<
name|sample_len
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* If there is more text on the line, then it is an argument for the      interpreter. */
if|if
condition|(
name|i
operator|<
name|sample_len
operator|&&
name|sample
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
operator|!
name|whitespace
argument_list|(
name|sample
index|[
name|i
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|start
operator|=
name|i
init|;
operator|!
name|whitespace
argument_list|(
name|sample
index|[
name|i
index|]
argument_list|)
operator|&&
name|sample
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
name|i
operator|<
name|sample_len
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|firstarg
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|firstarg
argument_list|,
name|sample
operator|+
name|start
argument_list|,
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|firstarg
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|size_increment
operator|=
literal|2
expr_stmt|;
block|}
name|larry
operator|=
name|array_len
argument_list|(
name|args
argument_list|)
operator|+
name|size_increment
expr_stmt|;
name|args
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|args
argument_list|,
operator|(
literal|1
operator|+
name|larry
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|larry
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
name|args
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
operator|-
name|size_increment
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|execname
expr_stmt|;
if|if
condition|(
name|firstarg
condition|)
block|{
name|args
index|[
literal|1
index|]
operator|=
name|firstarg
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|command
expr_stmt|;
block|}
else|else
name|args
index|[
literal|1
index|]
operator|=
name|command
expr_stmt|;
name|args
index|[
name|larry
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|shell_execve
argument_list|(
name|execname
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Call execve (), handling interpreting shell scripts, and handling    exec failures. */
end_comment

begin_function
name|int
name|shell_execve
parameter_list|(
name|command
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|,
decl|*
modifier|*
name|env
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|isc386
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
name|__setostype
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Turn on USGr3 semantics. */
name|execve
argument_list|(
name|command
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|__setostype
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn the POSIX semantics back on. */
else|#
directive|else
name|execve
argument_list|(
name|command
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !(isc386&& _POSIX_SOURCE) */
comment|/* If we get to this point, then start checking out the file.      Maybe it is something we can hack ourselves. */
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOEXEC
condition|)
block|{
if|if
condition|(
operator|(
name|stat
argument_list|(
name|command
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|report_error
argument_list|(
literal|"%s: is a directory"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|file_error
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
block|}
else|else
block|{
comment|/* This file is executable. 	   If it begins with #!, then help out people with losing operating 	   systems.  Otherwise, check to see if it is a binary file by seeing 	   if the first line (or up to 30 characters) are in the ASCII set. 	   Execute the contents as shell commands. */
specifier|extern
name|char
modifier|*
name|shell_name
decl_stmt|;
name|int
name|larray
init|=
name|array_len
argument_list|(
name|args
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|should_exec
init|=
literal|0
decl_stmt|;
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|command
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|char
name|sample
index|[
literal|80
index|]
decl_stmt|;
name|int
name|sample_len
init|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|sample
index|[
literal|0
index|]
argument_list|,
literal|80
argument_list|)
decl_stmt|;
comment|/* Is this supposed to be an executable script? */
comment|/* If so, the format of the line is "#! interpreter [argument]". 		 A single argument is allowed.  The BSD kernel restricts 		 the length of the entire line to 32 characters (32 bytes 		 being the size of the BSD exec header), but we allow 80 		 characters. */
if|if
condition|(
name|sample
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|sample
index|[
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|execute_shell_script
argument_list|(
name|sample
argument_list|,
name|sample_len
argument_list|,
name|command
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|NOTDEF
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CSH
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|Bsd
argument_list|)
operator|||
name|defined
argument_list|(
name|Ultrix
argument_list|)
operator|)
comment|/* If this system has Csh, then keep the old 		 BSD semantics. */
elseif|else
if|if
condition|(
name|sample_len
operator|>
literal|0
operator|&&
name|sample
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* Scripts starting with a # are for Csh. */
name|shell_name
operator|=
name|savestring
argument_list|(
literal|"/bin/csh"
argument_list|)
expr_stmt|;
name|should_exec
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_CSH */
endif|#
directive|endif
comment|/* NOTDEF */
else|else
block|{
if|if
condition|(
name|sample_len
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|check_binary_file
argument_list|(
name|sample
argument_list|,
name|sample_len
argument_list|)
condition|)
block|{
name|report_error
argument_list|(
literal|"%s: cannot execute binary file"
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_BINARY_FILE
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
comment|/* Forget about the way that job control was working. We are 	   in a subshell. */
name|without_job_control
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
if|#
directive|if
name|defined
argument_list|(
name|ALIAS
argument_list|)
comment|/* Forget about any aliases that we knew of.  We are in a subshell. */
name|delete_all_aliases
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ALIAS */
comment|/* Insert the name of this shell into the argument list. */
name|args
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|args
argument_list|,
operator|(
literal|1
operator|+
name|larray
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|larray
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
name|args
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|shell_name
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|command
expr_stmt|;
name|args
index|[
name|larray
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|args
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|should_exec
condition|)
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|isc386
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
name|__setostype
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Turn on USGr3 semantics. */
name|execve
argument_list|(
name|shell_name
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|__setostype
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn the POSIX semantics back on. */
else|#
directive|else
name|execve
argument_list|(
name|shell_name
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* isc386&& _POSIX_SOURCE */
comment|/* Oh, no!  We couldn't even exec this! */
if|if
condition|(
operator|(
name|stat
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|report_error
argument_list|(
literal|"%s: is a directory"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|file_error
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
block|}
else|else
block|{
specifier|extern
name|jmp_buf
name|subshell_top_level
decl_stmt|;
specifier|extern
name|int
name|subshell_argc
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|subshell_argv
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|subshell_envp
decl_stmt|;
name|subshell_argc
operator|=
name|larray
expr_stmt|;
name|subshell_argv
operator|=
name|args
expr_stmt|;
name|subshell_envp
operator|=
name|env
expr_stmt|;
name|longjmp
argument_list|(
name|subshell_top_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Currently unused. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTDEF
argument_list|)
end_if

begin_function
specifier|static
name|void
name|close_all_files
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|fd_table_size
decl_stmt|;
name|fd_table_size
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|fd_table_size
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_function
specifier|static
name|void
name|close_pipes
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
block|{
if|if
condition|(
name|in
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redirect input and output to be from and to the specified pipes.    NO_PIPE and REDIRECT_BOTH are handled correctly. */
end_comment

begin_function
specifier|static
name|void
name|do_piping
parameter_list|(
name|pipe_in
parameter_list|,
name|pipe_out
parameter_list|)
name|int
name|pipe_in
decl_stmt|,
name|pipe_out
decl_stmt|;
block|{
if|if
condition|(
name|pipe_in
operator|!=
name|NO_PIPE
condition|)
block|{
name|dup2
argument_list|(
name|pipe_in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipe_out
operator|!=
name|NO_PIPE
condition|)
block|{
name|dup2
argument_list|(
name|pipe_out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipe_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe_out
operator|==
name|REDIRECT_BOTH
condition|)
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Defined in flags.c.  Non-zero means don't overwrite existing files. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|noclobber
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AMBIGUOUS_REDIRECT
value|-1
end_define

begin_define
define|#
directive|define
name|NOCLOBBER_REDIRECT
value|-2
end_define

begin_comment
comment|/* Perform the redirections on LIST.  If FOR_REAL, then actually make    input and output file descriptors, otherwise just do whatever is    neccessary for side effecting.  INTERNAL says to remember how to    undo the redirections later, if non-zero.  If SET_CLEXEC is non-zero,    file descriptors opened in do_redirection () have their close-on-exec    flag set. */
end_comment

begin_function
specifier|static
name|int
name|do_redirections
parameter_list|(
name|list
parameter_list|,
name|for_real
parameter_list|,
name|internal
parameter_list|,
name|set_clexec
parameter_list|)
name|REDIRECT
modifier|*
name|list
decl_stmt|;
name|int
name|for_real
decl_stmt|,
name|internal
decl_stmt|;
block|{
specifier|register
name|int
name|error
decl_stmt|;
specifier|register
name|REDIRECT
modifier|*
name|temp
init|=
name|list
decl_stmt|;
if|if
condition|(
name|internal
operator|&&
name|redirection_undo_list
condition|)
block|{
name|dispose_redirects
argument_list|(
name|redirection_undo_list
argument_list|)
expr_stmt|;
name|redirection_undo_list
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|temp
condition|)
block|{
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
name|error
operator|=
name|do_redirection_internal
argument_list|(
name|temp
argument_list|,
name|for_real
argument_list|,
name|internal
argument_list|,
name|set_clexec
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|char
modifier|*
name|redirection_expand
argument_list|()
decl_stmt|,
modifier|*
name|itos
argument_list|()
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|expandable_redirection_filename
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|filename
operator|=
name|redirection_expand
argument_list|(
name|temp
operator|->
name|redirectee
operator|.
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|filename
operator|=
name|itos
argument_list|(
name|temp
operator|->
name|redirectee
operator|.
name|dest
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|AMBIGUOUS_REDIRECT
case|:
name|report_error
argument_list|(
literal|"%s: Ambiguous redirect"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOCLOBBER_REDIRECT
case|:
name|report_error
argument_list|(
literal|"%s: Cannot clobber existing file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
default|default:
name|report_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the redirection pointed to by REDIRECT has a    redirectee.filename that can be expanded. */
end_comment

begin_function
specifier|static
name|int
name|expandable_redirection_filename
parameter_list|(
name|redirect
parameter_list|)
name|REDIRECT
modifier|*
name|redirect
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
switch|switch
condition|(
name|redirect
operator|->
name|instruction
condition|)
block|{
case|case
name|r_output_direction
case|:
case|case
name|r_appending_to
case|:
case|case
name|r_input_direction
case|:
case|case
name|r_inputa_direction
case|:
case|case
name|r_err_and_out
case|:
case|case
name|r_input_output
case|:
case|case
name|r_output_force
case|:
case|case
name|r_duplicating_input_word
case|:
case|case
name|r_duplicating_output_word
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expand the word in WORD returning a string.  If WORD expands to    multiple words (or no words), then return NULL. */
end_comment

begin_function
name|char
modifier|*
name|redirection_expand
parameter_list|(
name|word
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|WORD_LIST
modifier|*
name|make_word_list
argument_list|()
decl_stmt|,
modifier|*
name|expand_words_no_vars
argument_list|()
decl_stmt|;
name|WORD_LIST
modifier|*
name|tlist1
decl_stmt|,
modifier|*
name|tlist2
decl_stmt|;
name|tlist1
operator|=
name|make_word_list
argument_list|(
name|copy_word
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tlist2
operator|=
name|expand_words_no_vars
argument_list|(
name|tlist1
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|tlist1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tlist2
operator|||
name|tlist2
operator|->
name|next
condition|)
block|{
comment|/* We expanded to no words, or to more than a single word. 	 Dispose of the word list and return NULL. */
if|if
condition|(
name|tlist2
condition|)
name|dispose_words
argument_list|(
name|tlist2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|result
operator|=
name|string_list
argument_list|(
name|tlist2
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|tlist2
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the specific redirection requested.  Returns errno in case of error.    If FOR_REAL is zero, then just do whatever is neccessary to produce the    appropriate side effects.   REMEMBERING, if non-zero, says to remember    how to undo each redirection.  If SET_CLEXEC is non-zero, then    we set all file descriptors> 2 that we open to be close-on-exec.  */
end_comment

begin_function
specifier|static
name|int
name|do_redirection_internal
parameter_list|(
name|redirect
parameter_list|,
name|for_real
parameter_list|,
name|remembering
parameter_list|,
name|set_clexec
parameter_list|)
name|REDIRECT
modifier|*
name|redirect
decl_stmt|;
name|int
name|for_real
decl_stmt|,
name|remembering
decl_stmt|;
block|{
name|WORD_DESC
modifier|*
name|redirectee
init|=
name|redirect
operator|->
name|redirectee
operator|.
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|redirector
init|=
name|redirect
operator|->
name|redirector
decl_stmt|;
name|char
modifier|*
name|redirectee_word
decl_stmt|;
name|enum
name|r_instruction
name|ri
init|=
name|redirect
operator|->
name|instruction
decl_stmt|;
name|REDIRECT
modifier|*
name|new_redirect
decl_stmt|;
if|if
condition|(
name|ri
operator|==
name|r_duplicating_input_word
operator|||
name|ri
operator|==
name|r_duplicating_output_word
condition|)
block|{
comment|/* We have [N]>&WORD or [N]<&WORD.  Expand WORD, then translate 	 the redirection into a new one and continue. */
name|redirectee_word
operator|=
name|redirection_expand
argument_list|(
name|redirectee
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirectee_word
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|redirectee_word
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|new_redirect
operator|=
name|make_redirection
argument_list|(
name|redirector
argument_list|,
name|r_close_this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|all_digits
argument_list|(
name|redirectee_word
argument_list|)
condition|)
block|{
if|if
condition|(
name|ri
operator|==
name|r_duplicating_input_word
condition|)
block|{
name|new_redirect
operator|=
name|make_redirection
argument_list|(
name|redirector
argument_list|,
name|r_duplicating_input
argument_list|,
name|atoi
argument_list|(
name|redirectee_word
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_redirect
operator|=
name|make_redirection
argument_list|(
name|redirector
argument_list|,
name|r_duplicating_output
argument_list|,
name|atoi
argument_list|(
name|redirectee_word
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ri
operator|==
name|r_duplicating_output_word
operator|&&
name|redirector
operator|==
literal|1
condition|)
block|{
name|new_redirect
operator|=
name|make_redirection
argument_list|(
literal|1
argument_list|,
name|r_err_and_out
argument_list|,
name|make_word
argument_list|(
name|redirectee_word
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|redirectee_word
argument_list|)
expr_stmt|;
return|return
operator|(
name|AMBIGUOUS_REDIRECT
operator|)
return|;
block|}
name|free
argument_list|(
name|redirectee_word
argument_list|)
expr_stmt|;
comment|/* Set up the variables needed by the rest of the function from the 	 new redirection. */
if|if
condition|(
name|new_redirect
operator|->
name|instruction
operator|==
name|r_err_and_out
condition|)
block|{
name|char
modifier|*
name|alloca_hack
decl_stmt|;
comment|/* Copy the word without allocating any memory that must be 	     explicitly freed. */
name|redirectee
operator|=
operator|(
name|WORD_DESC
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_DESC
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|new_redirect
operator|->
name|redirectee
operator|.
name|filename
argument_list|,
name|redirectee
argument_list|,
sizeof|sizeof
argument_list|(
name|WORD_DESC
argument_list|)
argument_list|)
expr_stmt|;
name|alloca_hack
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|new_redirect
operator|->
name|redirectee
operator|.
name|filename
operator|->
name|word
argument_list|)
argument_list|)
expr_stmt|;
name|redirectee
operator|->
name|word
operator|=
name|alloca_hack
expr_stmt|;
name|strcpy
argument_list|(
name|redirectee
operator|->
name|word
argument_list|,
name|new_redirect
operator|->
name|redirectee
operator|.
name|filename
operator|->
name|word
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* It's guaranteed to be an integer, and shouldn't be freed. */
name|redirectee
operator|=
name|new_redirect
operator|->
name|redirectee
operator|.
name|filename
expr_stmt|;
name|redirector
operator|=
name|new_redirect
operator|->
name|redirector
expr_stmt|;
name|ri
operator|=
name|new_redirect
operator|->
name|instruction
expr_stmt|;
comment|/* Overwrite the flags element of the old redirect with the new value. */
name|redirect
operator|->
name|flags
operator|=
name|new_redirect
operator|->
name|flags
expr_stmt|;
name|dispose_redirects
argument_list|(
name|new_redirect
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ri
condition|)
block|{
case|case
name|r_output_direction
case|:
case|case
name|r_appending_to
case|:
case|case
name|r_input_direction
case|:
case|case
name|r_inputa_direction
case|:
case|case
name|r_err_and_out
case|:
comment|/* command&>filename */
case|case
name|r_input_output
case|:
case|case
name|r_output_force
case|:
if|if
condition|(
operator|!
operator|(
name|redirectee_word
operator|=
name|redirection_expand
argument_list|(
name|redirectee
argument_list|)
operator|)
condition|)
return|return
operator|(
name|AMBIGUOUS_REDIRECT
operator|)
return|;
comment|/* If we are in noclobber mode, you are not allowed to overwrite 	 existing files.  Check first. */
if|if
condition|(
name|noclobber
operator|&&
operator|(
name|ri
operator|==
name|r_output_direction
operator|||
name|ri
operator|==
name|r_input_output
operator|||
name|ri
operator|==
name|r_err_and_out
operator|)
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|redirectee_word
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|S_ISREG
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NOCLOBBER_REDIRECT
operator|)
return|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|redirectee_word
argument_list|,
name|redirect
operator|->
name|flags
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AFS_CREATE_BUG
argument_list|)
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|fd
operator|=
name|open
argument_list|(
name|redirectee_word
argument_list|,
operator|(
name|redirect
operator|->
name|flags
operator|&
operator|~
name|O_CREAT
operator|)
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AFS_CREATE_BUG */
name|free
argument_list|(
name|redirectee_word
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|for_real
condition|)
block|{
if|if
condition|(
name|remembering
condition|)
comment|/* Only setup to undo it if the thing to undo is active. */
if|if
condition|(
operator|(
name|fd
operator|!=
name|redirector
operator|)
operator|&&
operator|(
name|fcntl
argument_list|(
name|redirector
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
name|add_undo_redirect
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
else|else
name|add_undo_close_redirect
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|!=
name|redirector
operator|)
operator|&&
operator|(
name|dup2
argument_list|(
name|fd
argument_list|,
name|redirector
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* 	   * If we're remembering, then this is the result of a while, for 	   * or until loop with a loop redirection, or a function/builtin 	   * executing in the parent shell with a redirection.  In the 	   * function/builtin case, we want to set all file descriptors> 2 	   * to be close-on-exec to duplicate the effect of the old 	   * for i = 3 to NOFILE close(i) loop.  In the case of the loops, 	   * both sh and ksh leave the file descriptors open across execs. 	   * The Posix standard mentions only the exec builtin. 	   */
if|if
condition|(
name|set_clexec
operator|&&
operator|(
name|redirector
operator|>
literal|2
operator|)
condition|)
name|SET_CLOSE_ON_EXEC
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
name|redirector
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Don't close what we just opened! */
comment|/* If we are hacking both stdout and stderr, do the stderr 	 redirection here. */
if|if
condition|(
name|ri
operator|==
name|r_err_and_out
condition|)
block|{
if|if
condition|(
name|for_real
condition|)
block|{
if|if
condition|(
name|remembering
condition|)
name|add_undo_redirect
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
block|}
break|break;
case|case
name|r_reading_until
case|:
case|case
name|r_deblank_reading_until
case|:
block|{
comment|/* REDIRECTEE is a pointer to a WORD_DESC containing the text of 	   the new input.  Place it in a temporary file. */
name|int
name|document_index
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|document
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Expand the text if the word that was specified had no quoting. 	   Note that the text that we expand is treated exactly as if it 	   were surrounded by double-quotes.  */
if|if
condition|(
operator|!
name|redirectee
condition|)
name|document
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|redirectee
operator|->
name|quoted
condition|)
block|{
name|WORD_LIST
modifier|*
name|temp_word_list
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|expand_string
argument_list|(
name|redirectee
operator|->
name|word
argument_list|,
name|Q_HERE_DOCUMENT
argument_list|)
decl_stmt|;
name|document
operator|=
name|string_list
argument_list|(
name|temp_word_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|document
condition|)
name|document
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|temp_word_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|document
operator|=
name|redirectee
operator|->
name|word
expr_stmt|;
block|}
name|document_index
operator|=
name|strlen
argument_list|(
name|document
argument_list|)
expr_stmt|;
block|{
name|char
name|filename
index|[
literal|40
index|]
decl_stmt|;
name|pid_t
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
comment|/* Make the filename for the temp file. */
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"/tmp/t%d-sh"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_TRUNC
operator||
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|redirectee
operator|->
name|quoted
condition|)
name|free
argument_list|(
name|document
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|write
argument_list|(
name|fd
argument_list|,
name|document
argument_list|,
name|document_index
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|redirectee
operator|->
name|quoted
condition|)
name|free
argument_list|(
name|document
argument_list|)
expr_stmt|;
comment|/* Make the document really temporary.  Also make it the 		 input. */
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|filename
argument_list|)
operator|<
literal|0
operator|||
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|for_real
condition|)
block|{
if|if
condition|(
name|remembering
condition|)
comment|/* Only setup to undo it if the thing to undo is active. */
if|if
condition|(
operator|(
name|fd
operator|!=
name|redirector
operator|)
operator|&&
operator|(
name|fcntl
argument_list|(
name|redirector
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
name|add_undo_redirect
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
else|else
name|add_undo_close_redirect
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fd
argument_list|,
name|redirector
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|set_clexec
operator|&&
operator|(
name|redirector
operator|>
literal|2
operator|)
condition|)
name|SET_CLOSE_ON_EXEC
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|r_duplicating_input
case|:
case|case
name|r_duplicating_output
case|:
if|if
condition|(
name|for_real
condition|)
block|{
if|if
condition|(
name|remembering
condition|)
comment|/* Only setup to undo it if the thing to undo is active. */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|redirectee
operator|!=
name|redirector
operator|)
operator|&&
operator|(
name|fcntl
argument_list|(
name|redirector
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
name|add_undo_redirect
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
else|else
name|add_undo_close_redirect
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
comment|/* This is correct.  2>&1 means dup2 (1, 2); */
if|if
condition|(
name|dup2
argument_list|(
operator|(
name|int
operator|)
name|redirectee
argument_list|,
name|redirector
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* First duplicate the close-on-exec state of redirectee.  dup2 	     leaves the flag unset on the new descriptor, which means it 	     stays open.  Only set the close-on-exec bit for file descriptors 	     greater than 2 in any case, since 0-2 should always be open 	     unless closed by something like `exec 2<&-'. */
comment|/* if ((already_set || set_unconditionally)&& (ok_to_set)) 		set_it () */
if|if
condition|(
operator|(
operator|(
name|fcntl
argument_list|(
operator|(
name|int
operator|)
name|redirectee
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|)
operator|||
name|set_clexec
operator|)
operator|&&
operator|(
name|redirector
operator|>
literal|2
operator|)
condition|)
name|SET_CLOSE_ON_EXEC
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|r_close_this
case|:
if|if
condition|(
name|for_real
condition|)
block|{
if|if
condition|(
name|remembering
operator|&&
operator|(
name|fcntl
argument_list|(
name|redirector
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
name|add_undo_redirect
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|redirector
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SHELL_FD_BASE
value|10
end_define

begin_comment
comment|/* Remember the file descriptor associated with the slot FD,    on REDIRECTION_UNDO_LIST.  Note that the list will be reversed    before it is executed. */
end_comment

begin_function
specifier|static
name|int
name|add_undo_redirect
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|new_fd
decl_stmt|,
name|clexec_flag
decl_stmt|;
name|REDIRECT
modifier|*
name|new_redirect
decl_stmt|,
modifier|*
name|closer
decl_stmt|;
name|new_fd
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
name|SHELL_FD_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fd
operator|<
literal|0
condition|)
block|{
name|file_error
argument_list|(
literal|"redirection error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|clexec_flag
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|closer
operator|=
name|make_redirection
argument_list|(
name|new_fd
argument_list|,
name|r_close_this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_redirect
operator|=
name|make_redirection
argument_list|(
name|fd
argument_list|,
name|r_duplicating_output
argument_list|,
name|new_fd
argument_list|)
expr_stmt|;
name|new_redirect
operator|->
name|next
operator|=
name|closer
expr_stmt|;
name|closer
operator|->
name|next
operator|=
name|redirection_undo_list
expr_stmt|;
name|redirection_undo_list
operator|=
name|new_redirect
expr_stmt|;
comment|/*        * File descriptors used only for saving others should always be        * marked close-on-exec.  Unfortunately, we have to preserve the        * close-on-exec state of the file descriptor we are saving, since        * fcntl (F_DUPFD) sets the new file descriptor to remain open        * across execs.  If, however, the file descriptor whose state we        * are saving is<= 2, we can just set the close-on-exec flag,        * because file descriptors 0-2 should always be open-on-exec,        * and the restore above in do_redirection() will take care of it.        */
if|if
condition|(
name|clexec_flag
operator|||
name|fd
operator|<
literal|3
condition|)
name|SET_CLOSE_ON_EXEC
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set up to close FD when we are finished with the current command    and its redirections. */
end_comment

begin_function
specifier|static
name|void
name|add_undo_close_redirect
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|REDIRECT
modifier|*
name|closer
decl_stmt|;
name|closer
operator|=
name|make_redirection
argument_list|(
name|fd
argument_list|,
name|r_close_this
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|closer
operator|->
name|next
operator|=
name|redirection_undo_list
expr_stmt|;
name|redirection_undo_list
operator|=
name|closer
expr_stmt|;
block|}
end_function

begin_macro
name|intern_function
argument_list|(
argument|name
argument_list|,
argument|function
argument_list|)
end_macro

begin_decl_stmt
name|WORD_DESC
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|COMMAND
modifier|*
name|function
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
if|if
condition|(
operator|!
name|check_identifier
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
name|var
operator|=
name|find_function
argument_list|(
name|name
operator|->
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|&&
name|readonly_p
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|report_error
argument_list|(
literal|"%s: readonly function"
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXECUTION_FAILURE
operator|)
return|;
block|}
name|bind_function
argument_list|(
name|name
operator|->
name|word
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXECUTION_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Make sure that identifier is a valid shell identifier, i.e.    does not contain a dollar sign, nor is quoted in any way.  Nor    does it consist of all digits. */
end_comment

begin_macro
name|check_identifier
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|word
operator|->
name|dollar_present
operator|||
name|word
operator|->
name|quoted
operator|||
name|all_digits
argument_list|(
name|word
operator|->
name|word
argument_list|)
condition|)
block|{
name|report_error
argument_list|(
literal|"`%s' is not a valid identifier"
argument_list|,
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|u_mode_bits
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0000700)>> 6)
end_define

begin_define
define|#
directive|define
name|g_mode_bits
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0000070)>> 3)
end_define

begin_define
define|#
directive|define
name|o_mode_bits
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0000007)>> 0)
end_define

begin_define
define|#
directive|define
name|X_BIT
parameter_list|(
name|x
parameter_list|)
value|(x& 1)
end_define

begin_comment
comment|/* Return some flags based on information about this file.    The EXISTS bit is non-zero if the file is found.    The EXECABLE bit is non-zero the file is executble.    Zero is returned if the file is not found. */
end_comment

begin_function
name|int
name|file_status
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
specifier|static
name|int
name|user_id
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Determine whether this file exists or not. */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|finfo
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If the file is a directory, then it is not "executable" in the      sense of the shell. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|FS_EXISTS
operator|)
return|;
comment|/* Find out if the file is actually executable.  By definition, the      only other criteria is that the file has an execute bit set that      we can use. */
if|if
condition|(
name|user_id
operator|==
operator|-
literal|1
condition|)
name|user_id
operator|=
name|geteuid
argument_list|()
expr_stmt|;
comment|/* Root only requires execute permission for any of owner, group or      others to be able to exec a file. */
if|if
condition|(
name|user_id
operator|==
literal|0
condition|)
block|{
name|int
name|bits
decl_stmt|;
name|bits
operator|=
operator|(
name|u_mode_bits
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator||
name|g_mode_bits
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator||
name|o_mode_bits
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|X_BIT
argument_list|(
name|bits
argument_list|)
condition|)
return|return
operator|(
name|FS_EXISTS
operator||
name|FS_EXECABLE
operator|)
return|;
block|}
comment|/* If we are the owner of the file, the owner execute bit applies. */
if|if
condition|(
name|user_id
operator|==
name|finfo
operator|.
name|st_uid
operator|&&
name|X_BIT
argument_list|(
name|u_mode_bits
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FS_EXISTS
operator||
name|FS_EXECABLE
operator|)
return|;
comment|/* If we are in the owning group, the group permissions apply. */
if|if
condition|(
name|group_member
argument_list|(
name|finfo
operator|.
name|st_gid
argument_list|)
operator|&&
name|X_BIT
argument_list|(
name|g_mode_bits
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FS_EXISTS
operator||
name|FS_EXECABLE
operator|)
return|;
comment|/* If `others' have execute permission to the file, then so do we,      since we are also `others'. */
if|if
condition|(
name|X_BIT
argument_list|(
name|o_mode_bits
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FS_EXISTS
operator||
name|FS_EXECABLE
operator|)
return|;
else|else
return|return
operator|(
name|FS_EXISTS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if FILE exists and is executable.    Note that this function is the definition of what an    executable file is; do not change this unless YOU know    what an executable file is. */
end_comment

begin_function
name|int
name|executable_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|file_status
argument_list|(
name|file
argument_list|)
operator|&
name|FS_EXECABLE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* DOT_FOUND_IN_SEARCH becomes non-zero when find_user_command ()    encounters a `.' as the directory pathname while scanning the    list of possible pathnames; i.e., if `.' comes before the directory    containing the file of interest. */
end_comment

begin_decl_stmt
name|int
name|dot_found_in_search
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Locate the executable file referenced by NAME, searching along    the contents of the shell PATH variable.  Return a new string    which is the full pathname to the file, or NULL if the file    couldn't be found.  If a file is found that isn't executable,    and that is the only match, then return that. */
end_comment

begin_function
name|char
modifier|*
name|find_user_command
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|find_user_command_internal
argument_list|(
name|name
argument_list|,
name|FS_EXEC_PREFERRED
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Locate the file referenced by NAME, searching along the contents    of the shell PATH variable.  Return a new string which is the full    pathname to the file, or NULL if the file couldn't be found.  This    returns the first file found. */
end_comment

begin_function
name|char
modifier|*
name|find_path_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|find_user_command_internal
argument_list|(
name|name
argument_list|,
name|FS_EXISTS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|find_user_command_internal
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|char
modifier|*
name|path_list
decl_stmt|;
name|path_list
operator|=
name|get_string_value
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_list
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|name
argument_list|)
operator|)
return|;
return|return
operator|(
name|find_user_command_in_path
argument_list|(
name|name
argument_list|,
name|path_list
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the next element from PATH_LIST, a colon separated list of    paths.  PATH_INDEX_POINTER is the address of an index into PATH_LIST;    the index is modified by this function.    Return the next element of PATH_LIST or NULL if there are no more. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_next_path_element
parameter_list|(
name|path_list
parameter_list|,
name|path_index_pointer
parameter_list|)
name|char
modifier|*
name|path_list
decl_stmt|;
name|int
modifier|*
name|path_index_pointer
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|extract_colon_unit
parameter_list|()
function_decl|;
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|extract_colon_unit
argument_list|(
name|path_list
argument_list|,
name|path_index_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
return|return
operator|(
name|path
operator|)
return|;
if|if
condition|(
operator|!
operator|*
name|path
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|savestring
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|user_command_matches
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|state
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|path_list
decl_stmt|;
name|int
name|path_index
decl_stmt|;
name|char
modifier|*
name|path_element
decl_stmt|;
name|char
modifier|*
name|match
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|match_list
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|match_list_size
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|match_index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
comment|/* Create the list of matches. */
if|if
condition|(
operator|!
name|match_list
condition|)
block|{
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|match_list_size
operator|=
literal|5
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|match_list_size
condition|;
name|i
operator|++
control|)
name|match_list
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear out the old match list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|match_list_size
condition|;
name|i
operator|++
control|)
name|match_list
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* We haven't found any files yet. */
name|match_index
operator|=
literal|0
expr_stmt|;
name|path_list
operator|=
name|get_string_value
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
name|path_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|path_list
operator|&&
name|path_list
index|[
name|path_index
index|]
condition|)
block|{
name|char
modifier|*
name|find_user_command_in_path
parameter_list|()
function_decl|;
name|path_element
operator|=
name|get_next_path_element
argument_list|(
name|path_list
argument_list|,
operator|&
name|path_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_element
condition|)
break|break;
name|match
operator|=
name|find_user_command_in_path
argument_list|(
name|name
argument_list|,
name|path_element
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_element
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
if|if
condition|(
name|match_index
operator|+
literal|1
operator|==
name|match_list_size
condition|)
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|match_list
argument_list|,
operator|(
operator|(
name|match_list_size
operator|+=
literal|10
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
name|match_index
operator|++
index|]
operator|=
name|match
expr_stmt|;
name|match_list
index|[
name|match_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* We haven't returned any strings yet. */
name|match_index
operator|=
literal|0
expr_stmt|;
block|}
name|match
operator|=
name|match_list
index|[
name|match_index
index|]
expr_stmt|;
if|if
condition|(
name|match
condition|)
name|match_index
operator|++
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PATH1 and PATH2 are the same file.  This is kind of    expensive.  If non-NULL STP1 and STP2 point to stat structures    corresponding to PATH1 and PATH2, respectively. */
end_comment

begin_function
name|int
name|same_file
parameter_list|(
name|path1
parameter_list|,
name|path2
parameter_list|,
name|stp1
parameter_list|,
name|stp2
parameter_list|)
name|char
modifier|*
name|path1
decl_stmt|,
decl|*
name|path2
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|stat
modifier|*
name|stp1
decl_stmt|,
modifier|*
name|stp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|st1
decl_stmt|,
name|st2
decl_stmt|;
if|if
condition|(
name|stp1
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|path1
argument_list|,
operator|&
name|st1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|stp1
operator|=
operator|&
name|st1
expr_stmt|;
block|}
if|if
condition|(
name|stp2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|path2
argument_list|,
operator|&
name|st2
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|stp2
operator|=
operator|&
name|st2
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|stp1
operator|->
name|st_dev
operator|==
name|stp2
operator|->
name|st_dev
operator|)
operator|&&
operator|(
name|stp1
operator|->
name|st_ino
operator|==
name|stp2
operator|->
name|st_ino
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* This does the dirty work for find_path_file () and find_user_command ().    NAME is the name of the file to search for.    PATH_LIST is a colon separated list of directories to search.    FLAGS contains bit fields which control the files which are eligible.    Some values are:       FS_EXEC_ONLY:		The file must be an executable to be found.       FS_EXEC_PREFERRED:	If we can't find an executable, then the 				the first file matching NAME will do.       FS_EXISTS:		The first file found will do. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_user_command_in_path
parameter_list|(
name|name
parameter_list|,
name|path_list
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|path_list
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|char
modifier|*
name|full_path
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|file_to_lose_on
decl_stmt|;
name|int
name|status
decl_stmt|,
name|path_index
decl_stmt|,
name|name_len
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* The file name which we would try to execute, except that it isn't      possible to execute it.  This is the first file that matches the      name that we are looking for while we are searching $PATH for a      suitable one to execute.  If we cannot find a suitable executable      file, then we use this one. */
name|file_to_lose_on
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* We haven't started looking, so we certainly haven't seen      a `.' as the directory path yet. */
name|dot_found_in_search
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|absolute_program
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|full_path
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|name_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_path
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|file_status
argument_list|(
name|full_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|FS_EXISTS
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FS_EXEC_ONLY
operator|)
operator|&&
operator|(
name|status
operator|&
name|FS_EXECABLE
operator|)
condition|)
return|return
operator|(
name|full_path
operator|)
return|;
else|else
block|{
name|free
argument_list|(
name|full_path
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
comment|/* Find out the location of the current working directory. */
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
name|path_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|path_list
operator|&&
name|path_list
index|[
name|path_index
index|]
condition|)
block|{
comment|/* Allow the user to interrupt out of a lengthy path search. */
name|QUIT
expr_stmt|;
name|path
operator|=
name|get_next_path_element
argument_list|(
name|path_list
argument_list|,
operator|&
name|path_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
break|break;
if|if
condition|(
operator|*
name|path
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|tilde_expand
parameter_list|()
function_decl|;
name|char
modifier|*
name|t
init|=
name|tilde_expand
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|t
expr_stmt|;
block|}
comment|/* Remember the location of "." in the path, in all its forms 	 (as long as they begin with a `.', e.g. `./.') */
if|if
condition|(
operator|(
operator|*
name|path
operator|==
literal|'.'
operator|)
operator|&&
name|same_file
argument_list|(
literal|"."
argument_list|,
name|path
argument_list|,
operator|&
name|finfo
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|dot_found_in_search
operator|=
literal|1
expr_stmt|;
name|full_path
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|name_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|full_path
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|file_status
argument_list|(
name|full_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|FS_EXISTS
operator|)
condition|)
goto|goto
name|next_file
goto|;
comment|/* The file exists.  If the caller simply wants the first file, 	 here it is. */
if|if
condition|(
name|flags
operator|&
name|FS_EXISTS
condition|)
return|return
operator|(
name|full_path
operator|)
return|;
comment|/* If the file is executable, then it satisfies the cases of 	  EXEC_ONLY and EXEC_PREFERRED.  Return this file unconditionally. */
if|if
condition|(
name|status
operator|&
name|FS_EXECABLE
condition|)
block|{
if|if
condition|(
name|file_to_lose_on
condition|)
name|free
argument_list|(
name|file_to_lose_on
argument_list|)
expr_stmt|;
return|return
operator|(
name|full_path
operator|)
return|;
block|}
comment|/* The file is not executable, but it does exist.  If we prefer 	 an executable, then remember this one if it is the first one 	 we have found. */
if|if
condition|(
name|flags
operator|&
name|FS_EXEC_PREFERRED
condition|)
block|{
if|if
condition|(
operator|!
name|file_to_lose_on
condition|)
name|file_to_lose_on
operator|=
name|savestring
argument_list|(
name|full_path
argument_list|)
expr_stmt|;
block|}
name|next_file
label|:
name|free
argument_list|(
name|full_path
argument_list|)
expr_stmt|;
block|}
comment|/* We didn't find exactly what the user was looking for.  Return      the contents of FILE_TO_LOSE_ON which is NULL when the search      required an executable, or non-NULL if a file was found and the      search would accept a non-executable as a last resort. */
return|return
operator|(
name|file_to_lose_on
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a string containing units of information separated by colons,    return the next one pointed to by INDEX, or NULL if there are no more.    Advance INDEX to the character after the colon. */
end_comment

begin_function
name|char
modifier|*
name|extract_colon_unit
parameter_list|(
name|string
parameter_list|,
name|index
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|index
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
name|i
operator|=
operator|*
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|(
name|i
operator|>=
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Each call to this routine leaves the index pointing at a colon if      there is more to the path.  If I is> 0, then increment past the      `:'.  If I is 0, then the path has a leading colon.  Trailing colons      are handled OK by the `else' part of the if statement; an empty      string is returned in that case. */
if|if
condition|(
name|i
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|start
condition|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
operator|(
operator|*
name|index
operator|)
operator|++
expr_stmt|;
comment|/* Return "" in the case of a trailing `:'. */
return|return
operator|(
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
operator|&
name|string
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|value
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the characters from SAMPLE are not all valid    characters to be found in the first line of a shell script.  We    check up to the first newline, or SAMPLE_LEN, whichever comes first.    All of the characters must be printable or whitespace. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|isspace
argument_list|)
end_if

begin_define
define|#
directive|define
name|isspace
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\f')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|isprint
argument_list|)
end_if

begin_define
define|#
directive|define
name|isprint
parameter_list|(
name|c
parameter_list|)
value|(isletter(c) || digit(c) || ispunct(c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|check_binary_file
parameter_list|(
name|sample
parameter_list|,
name|sample_len
parameter_list|)
name|unsigned
name|char
modifier|*
name|sample
decl_stmt|;
name|int
name|sample_len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sample_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sample
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|sample
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|isprint
argument_list|(
name|sample
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

