begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* trap.c -- Not the trap command, but useful functions    for manipulating those objects.  The trap command is    in builtins.c */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1991 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"trap.h"
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|last_command_exit_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of things to do originally, before we started trapping. */
end_comment

begin_decl_stmt
name|SigHandler
modifier|*
name|original_signals
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each signal, a slot for a string, which is a command to be    executed when that signal is recieved.  The slot can also contain    DEFAULT_SIG, which means do whatever you were going to do before    you were so rudely interrupted, or IGNORE_SIG, which says ignore    this signal. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|trap_list
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A translation list so we can be polite to our users. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|signal_names
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bitmap of signals received for which we have trap handlers. */
end_comment

begin_decl_stmt
name|int
name|pending_traps
index|[
name|NSIG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|signal_names_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|initialize_traps
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|signal_names_initialized
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
name|signal_names
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|pending_traps
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* `signal' 0 is what we do on exit. */
name|signal_names
index|[
literal|0
index|]
operator|=
literal|"EXIT"
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGHUP
argument_list|)
comment|/* hangup */
name|signal_names
index|[
name|SIGHUP
index|]
operator|=
literal|"SIGHUP"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINT
argument_list|)
comment|/* interrupt */
name|signal_names
index|[
name|SIGINT
index|]
operator|=
literal|"SIGINT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGQUIT
argument_list|)
comment|/* quit */
name|signal_names
index|[
name|SIGQUIT
index|]
operator|=
literal|"SIGQUIT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
comment|/* illegal instruction (not reset when caught) */
name|signal_names
index|[
name|SIGILL
index|]
operator|=
literal|"SIGILL"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
comment|/* trace trap (not reset when caught) */
name|signal_names
index|[
name|SIGTRAP
index|]
operator|=
literal|"SIGTRAP"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGABRT
argument_list|)
comment|/*  */
name|signal_names
index|[
name|SIGABRT
index|]
operator|=
literal|"SIGABRT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIOT
argument_list|)
comment|/* IOT instruction */
name|signal_names
index|[
name|SIGIOT
index|]
operator|=
literal|"SIGIOT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGEMT
argument_list|)
comment|/* EMT instruction */
name|signal_names
index|[
name|SIGEMT
index|]
operator|=
literal|"SIGEMT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
comment|/* floating point exception */
name|signal_names
index|[
name|SIGFPE
index|]
operator|=
literal|"SIGFPE"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGKILL
argument_list|)
comment|/* kill (cannot be caught or ignored) */
name|signal_names
index|[
name|SIGKILL
index|]
operator|=
literal|"SIGKILL"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
comment|/* bus error */
name|signal_names
index|[
name|SIGBUS
index|]
operator|=
literal|"SIGBUS"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
comment|/* segmentation violation */
name|signal_names
index|[
name|SIGSEGV
index|]
operator|=
literal|"SIGSEGV"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSYS
argument_list|)
comment|/* bad argument to system call */
name|signal_names
index|[
name|SIGSYS
index|]
operator|=
literal|"SIGSYS"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
comment|/* write on a pipe with no one to read it */
name|signal_names
index|[
name|SIGPIPE
index|]
operator|=
literal|"SIGPIPE"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGALRM
argument_list|)
comment|/* alarm clock */
name|signal_names
index|[
name|SIGALRM
index|]
operator|=
literal|"SIGALRM"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTERM
argument_list|)
comment|/* software termination signal from kill */
name|signal_names
index|[
name|SIGTERM
index|]
operator|=
literal|"SIGTERM"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
comment|/* Like SIGCHLD.  */
name|signal_names
index|[
name|SIGCLD
index|]
operator|=
literal|"SIGCLD"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
comment|/* Magic thing for some machines. */
name|signal_names
index|[
name|SIGPWR
index|]
operator|=
literal|"SIGPWR"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
comment|/* For keyboard input?  */
name|signal_names
index|[
name|SIGPOLL
index|]
operator|=
literal|"SIGPOLL"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGURG
argument_list|)
comment|/* urgent condition on IO channel */
name|signal_names
index|[
name|SIGURG
index|]
operator|=
literal|"SIGURG"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSTOP
argument_list|)
comment|/* sendable stop signal not from tty */
name|signal_names
index|[
name|SIGSTOP
index|]
operator|=
literal|"SIGSTOP"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTSTP
argument_list|)
comment|/* stop signal from tty */
name|signal_names
index|[
name|SIGTSTP
index|]
operator|=
literal|"SIGTSTP"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCONT
argument_list|)
comment|/* continue a stopped process */
name|signal_names
index|[
name|SIGCONT
index|]
operator|=
literal|"SIGCONT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
comment|/* to parent on child stop or exit */
name|signal_names
index|[
name|SIGCHLD
index|]
operator|=
literal|"SIGCHLD"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTIN
argument_list|)
comment|/* to readers pgrp upon background tty read */
name|signal_names
index|[
name|SIGTTIN
index|]
operator|=
literal|"SIGTTIN"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTOU
argument_list|)
comment|/* like TTIN for output if (tp->t_local&LTOSTOP) */
name|signal_names
index|[
name|SIGTTOU
index|]
operator|=
literal|"SIGTTOU"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
comment|/* input/output possible signal */
name|signal_names
index|[
name|SIGIO
index|]
operator|=
literal|"SIGIO"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXCPU
argument_list|)
comment|/* exceeded CPU time limit */
name|signal_names
index|[
name|SIGXCPU
index|]
operator|=
literal|"SIGXCPU"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
comment|/* exceeded file size limit */
name|signal_names
index|[
name|SIGXFSZ
index|]
operator|=
literal|"SIGXFSZ"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGVTALRM
argument_list|)
comment|/* virtual time alarm */
name|signal_names
index|[
name|SIGVTALRM
index|]
operator|=
literal|"SIGVTALRM"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPROF
argument_list|)
comment|/* profiling time alarm */
name|signal_names
index|[
name|SIGPROF
index|]
operator|=
literal|"SIGPROF"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
comment|/* window changed */
name|signal_names
index|[
name|SIGWINCH
index|]
operator|=
literal|"SIGWINCH"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLOST
argument_list|)
comment|/* resource lost (eg, record-lock lost) */
name|signal_names
index|[
name|SIGLOST
index|]
operator|=
literal|"SIGLOST"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
comment|/* user defined signal 1 */
name|signal_names
index|[
name|SIGUSR1
index|]
operator|=
literal|"SIGUSR1"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
comment|/* user defined signal 2 */
name|signal_names
index|[
name|SIGUSR2
index|]
operator|=
literal|"SIGUSR2"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMSG
argument_list|)
comment|/* HFT input data pending */
name|signal_names
index|[
name|SIGMSG
index|]
operator|=
literal|"SIGMSG"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
comment|/* power failure imminent (save your data) */
name|signal_names
index|[
name|SIGPWR
index|]
operator|=
literal|"SIGPWR"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
comment|/* system crash imminent */
name|signal_names
index|[
name|SIGDANGER
index|]
operator|=
literal|"SIGDANGER"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMIGRATE
argument_list|)
comment|/* migrate process to another CPU */
name|signal_names
index|[
name|SIGMIGRATE
index|]
operator|=
literal|"SIGMIGRATE"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPRE
argument_list|)
comment|/* programming error */
name|signal_names
index|[
name|SIGPRE
index|]
operator|=
literal|"SIGPRE"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGGRANT
argument_list|)
comment|/* HFT monitor mode granted */
name|signal_names
index|[
name|SIGGRANT
index|]
operator|=
literal|"SIGGRANT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRETRACT
argument_list|)
comment|/* HFT monitor mode retracted */
name|signal_names
index|[
name|SIGRETRACT
index|]
operator|=
literal|"SIGRETRACT"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSOUND
argument_list|)
comment|/* HFT sound sequence has completed */
name|signal_names
index|[
name|SIGSOUND
index|]
operator|=
literal|"SIGSOUND"
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|signal_names
index|[
name|i
index|]
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|signal_names
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
literal|"SIGJUNK"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|signal_names
index|[
name|i
index|]
argument_list|,
literal|"SIGJUNK(%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|trap_list
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
name|trap_list
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
expr_stmt|;
name|original_signals
index|[
name|i
index|]
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|i
argument_list|,
name|original_signals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return the print name of this signal. */
end_comment

begin_function
name|char
modifier|*
name|signal_name
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
if|if
condition|(
name|signal
operator|>
name|NSIG
condition|)
return|return
operator|(
literal|"bad signal number"
operator|)
return|;
else|else
return|return
operator|(
name|signal_names
index|[
name|signal
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Turn a string into a signal number, or a number into    a signal number.  If STRING is "2", "SIGINT", or "INT",    then (int)2 is returned.  Return NO_SIG if STRING doesn't    contain a valid signal descriptor. */
end_comment

begin_function
name|int
name|decode_signal
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|sig
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|sig
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sig
operator|<
name|NSIG
operator|&&
name|sig
operator|>=
literal|0
condition|)
return|return
operator|(
name|sig
operator|)
return|;
else|else
return|return
operator|(
name|NO_SIG
operator|)
return|;
block|}
for|for
control|(
name|sig
operator|=
literal|0
init|;
name|sig
operator|<
name|NSIG
condition|;
name|sig
operator|++
control|)
if|if
condition|(
operator|(
name|stricmp
argument_list|(
name|string
argument_list|,
name|signal_names
index|[
name|sig
index|]
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|stricmp
argument_list|(
name|string
argument_list|,
operator|&
operator|(
name|signal_names
index|[
name|sig
index|]
operator|)
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|sig
operator|)
return|;
return|return
operator|(
name|NO_SIG
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Non-zero when we catch a trapped signal. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|catch_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USGr4
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_BSD_SIGNALS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|run_pending_traps
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|sig
decl_stmt|;
name|int
name|old_exit_value
decl_stmt|;
if|if
condition|(
name|catch_flag
operator|==
literal|0
condition|)
comment|/* simple optimization */
return|return;
name|catch_flag
operator|=
literal|0
expr_stmt|;
comment|/* Preserve $? when running trap. */
name|old_exit_value
operator|=
name|last_command_exit_value
expr_stmt|;
for|for
control|(
name|sig
operator|=
literal|0
init|;
name|sig
operator|<
name|NSIG
condition|;
name|sig
operator|++
control|)
block|{
if|if
condition|(
name|pending_traps
index|[
name|sig
index|]
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|oset
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_SIGNALS
argument_list|)
name|int
name|oldmask
init|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|sig
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* POSIX_VERSION */
name|parse_and_execute
argument_list|(
name|savestring
argument_list|(
name|trap_list
index|[
name|sig
index|]
argument_list|)
argument_list|,
literal|"trap"
argument_list|)
expr_stmt|;
name|pending_traps
index|[
name|sig
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_SIGNALS
argument_list|)
name|sigsetmask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* POSIX_VERSION */
block|}
block|}
name|last_command_exit_value
operator|=
name|old_exit_value
expr_stmt|;
block|}
end_block

begin_function
name|sighandler
name|trap_handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
specifier|extern
name|int
name|interrupt_immediately
decl_stmt|;
if|if
condition|(
operator|(
name|sig
operator|>=
name|NSIG
operator|)
operator|||
operator|(
name|trap_list
index|[
name|sig
index|]
operator|==
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
operator|)
operator|||
operator|(
name|trap_list
index|[
name|sig
index|]
operator|==
operator|(
name|char
operator|*
operator|)
name|IGNORE_SIG
operator|)
condition|)
name|programming_error
argument_list|(
literal|"trap_handler: Bad signal %d"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_BSD_SIGNALS
argument_list|)
name|signal
argument_list|(
name|sig
argument_list|,
name|trap_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG&& !HAVE_BSD_SIGNALS */
name|catch_flag
operator|=
literal|1
expr_stmt|;
name|pending_traps
index|[
name|sig
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|interrupt_immediately
condition|)
name|run_pending_traps
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VOID_SIGHANDLER
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* VOID_SIGHANDLER */
block|}
end_function

begin_comment
comment|/* Set SIG to call STRING as a command. */
end_comment

begin_function
name|void
name|set_signal
parameter_list|(
name|sig
parameter_list|,
name|string
parameter_list|)
name|int
name|sig
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|void
name|change_signal
parameter_list|()
function_decl|;
comment|/* A signal ignored on entry to the shell cannot be trapped or reset, but      no error is reported when attempting to do so.  -- Posix.2 */
if|if
condition|(
name|original_signals
index|[
name|sig
index|]
operator|==
name|SIG_IGN
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
comment|/* Don't change the function that catches SIGCHLD, but store the command      to be executed.  It will be run from jobs.c: flush_child(). */
if|if
condition|(
name|sig
operator|&&
name|sig
operator|!=
name|SIGINT
operator|&&
name|sig
operator|!=
name|SIGCHLD
condition|)
else|#
directive|else
if|if
condition|(
name|sig
operator|&&
name|sig
operator|!=
name|SIGINT
condition|)
endif|#
directive|endif
comment|/* SIGCHLD */
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|change_signal
argument_list|(
name|sig
argument_list|,
name|savestring
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
comment|/* Don't change the function that catches SIGCHLD, but store the command      to be executed.  It will be run from jobs.c: flush_child().  Do the      same thing for SIGINT; the trap commands are run from      run_interrupt_trap (), which is called from throw_to_top_level (). */
if|if
condition|(
name|sig
operator|&&
name|sig
operator|!=
name|SIGINT
operator|&&
name|sig
operator|!=
name|SIGCHLD
condition|)
else|#
directive|else
if|if
condition|(
name|sig
operator|&&
name|sig
operator|!=
name|SIGINT
condition|)
endif|#
directive|endif
comment|/* SIGCHLD */
name|signal
argument_list|(
name|sig
argument_list|,
name|trap_handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If SIG has a string assigned to it, get rid of it.  Then give it    VALUE. */
end_comment

begin_function
name|void
name|change_signal
parameter_list|(
name|sig
parameter_list|,
name|value
parameter_list|)
name|int
name|sig
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|int
operator|)
name|trap_list
index|[
name|sig
index|]
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|trap_list
index|[
name|sig
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|IGNORE_SIG
operator|)
condition|)
name|free
argument_list|(
name|trap_list
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
name|trap_list
index|[
name|sig
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the default action for SIG; i.e., the action the shell    would have taken before you used the trap command. */
end_comment

begin_function
name|void
name|restore_default_signal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
comment|/* Don't allow the signal catchers for SIGINT or SIGCHLD      to be overridden. */
if|if
condition|(
name|sig
operator|!=
name|SIGINT
operator|&&
name|sig
operator|!=
name|SIGCHLD
condition|)
else|#
directive|else
if|if
condition|(
name|sig
operator|!=
name|SIGINT
condition|)
endif|#
directive|endif
comment|/* !SIGCHLD */
name|signal
argument_list|(
name|sig
argument_list|,
name|original_signals
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
name|change_signal
argument_list|(
name|sig
argument_list|,
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make this signal be ignored. */
end_comment

begin_function
name|void
name|ignore_signal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* Don't allow the SIGCHLD signal catcher to be overridden. */
if|if
condition|(
name|sig
operator|!=
name|SIGCHLD
condition|)
endif|#
directive|endif
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|change_signal
argument_list|(
name|sig
argument_list|,
operator|(
name|char
operator|*
operator|)
name|IGNORE_SIG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the calling of "trap 0".  The only sticky situation is when    the command to be executed includes an "exit".  This is why we have    to provide our own place for top_level to jump to. */
end_comment

begin_function
name|void
name|run_exit_trap
parameter_list|()
block|{
if|if
condition|(
operator|(
name|trap_list
index|[
literal|0
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
operator|)
operator|&&
operator|(
name|trap_list
index|[
literal|0
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|IGNORE_SIG
operator|)
condition|)
block|{
name|char
modifier|*
name|trap_command
init|=
name|savestring
argument_list|(
name|trap_list
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|,
name|old_exit_value
decl_stmt|;
name|old_exit_value
operator|=
name|last_command_exit_value
expr_stmt|;
name|change_signal
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|code
operator|=
name|setjmp
argument_list|(
name|top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
name|parse_and_execute
argument_list|(
name|trap_command
argument_list|,
literal|"trap"
argument_list|)
expr_stmt|;
name|last_command_exit_value
operator|=
name|old_exit_value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reset all trapped signals to their original values.  Signals set to be    ignored with trap '' SIGNAL should be ignored, so we make sure that they    are. */
end_comment

begin_function
name|void
name|restore_original_signals
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trap_list
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
condition|)
block|{
if|if
condition|(
name|trap_list
index|[
name|i
index|]
operator|==
operator|(
name|char
operator|*
operator|)
name|IGNORE_SIG
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|else
name|restore_default_signal
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If it's one of the signals the shell handles specially, 	     make sure it gets set back to the value it had when the 	     shell was started. */
if|if
condition|(
name|i
operator|==
name|SIGINT
operator|||
name|i
operator|==
name|SIGQUIT
operator|||
name|i
operator|==
name|SIGTERM
condition|)
name|restore_default_signal
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Run a trap set on SIGINT.  This is called from throw_to_top_level (), and    declared here to localize the trap functions. */
end_comment

begin_macro
name|run_interrupt_trap
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|command
decl_stmt|,
modifier|*
name|saved_command
decl_stmt|;
name|int
name|old_exit_value
decl_stmt|;
if|if
condition|(
operator|(
name|trap_list
index|[
name|SIGINT
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
operator|)
operator|&&
operator|(
name|trap_list
index|[
name|SIGINT
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|IGNORE_SIG
operator|)
condition|)
block|{
name|command
operator|=
name|savestring
argument_list|(
name|trap_list
index|[
name|SIGINT
index|]
argument_list|)
expr_stmt|;
name|old_exit_value
operator|=
name|last_command_exit_value
expr_stmt|;
name|saved_command
operator|=
name|trap_list
index|[
name|SIGINT
index|]
expr_stmt|;
name|unwind_protect_string
argument_list|(
name|trap_list
index|[
name|SIGINT
index|]
argument_list|)
expr_stmt|;
name|trap_list
index|[
name|SIGINT
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|parse_and_execute
argument_list|(
name|command
argument_list|,
literal|"interrupt trap"
argument_list|)
expr_stmt|;
name|trap_list
index|[
name|SIGINT
index|]
operator|=
name|saved_command
expr_stmt|;
name|last_command_exit_value
operator|=
name|old_exit_value
expr_stmt|;
block|}
block|}
end_block

end_unit

