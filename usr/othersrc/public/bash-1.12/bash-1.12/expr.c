begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expr.c -- arithmetic expression evaluation.     Copyright (C) 1990, 1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with Bash; see the file COPYING.  If not, write to the Free    Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.   All arithmetic is done as long integers with no checking for overflow  (though division by 0 is caught and flagged as an error).   The following operators are handled, grouped into a set of levels in  order of decreasing precedence.  	"-"			[level 0 (unary negation)] 	"!"			[level 1] 	"*", "/", "%"		[level 2] 	"+", "-"		[level 3] 	"<=", ">=", "<", ">"	[level 4] 	"==", "!="		[level 5] 	"="			[level 6 (assignment)]   (Note that most of these operators have special meaning to bash, and an  entire expression should be quoted, e.g. "a=$a+1" or "a=a+1" to ensure  that it is passed intact to the evaluator when using `let'.  When using  the $[] form, the text between the `[' and `]' is treated as if in double  quotes.)   Sub-expressions within parentheses have a precedence level greater than  all of the above levels and are evaluated first.  Within a single prece-  dence group, evaluation is left-to-right, except for the arithmetic  assignment operator (`='), which is evaluated right-to-left (as in C).   The expression evaluator returns the value of the expression (assignment  statements have as a value what is returned by the RHS).  The `let'  builtin, on the other hand, returns 0 if the last expression evaluates to  a non-zero, and 1 otherwise.   Implementation is a recursive-descent parser.   Chet Ramey  chet@ins.CWRU.Edu */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_define
define|#
directive|define
name|variable_starter
parameter_list|(
name|c
parameter_list|)
value|(isletter(c) || (c == '_'))
end_define

begin_define
define|#
directive|define
name|variable_character
parameter_list|(
name|c
parameter_list|)
value|(isletter(c) || (c == '_') || digit(c))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NULL
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expression
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current expression */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token lexical position */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curtok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current token */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lasttok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the previous token */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tokstr
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current token string */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tokval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current token value */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|evalbuf
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|readtok
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* lexical analyzer */
end_comment

begin_decl_stmt
specifier|static
name|long
name|assignment
argument_list|()
decl_stmt|,
name|exp0
argument_list|()
decl_stmt|,
name|exp1
argument_list|()
decl_stmt|,
name|exp2
argument_list|()
decl_stmt|,
name|exp3
argument_list|()
decl_stmt|,
name|exp4
argument_list|()
decl_stmt|,
name|exp5
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|long
name|strlong
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evalerror
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Because of the $[...] construct, expressions may include newlines.  This  * redefines `whitespace' so that a newline is added.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|whitespace
end_ifdef

begin_undef
undef|#
directive|undef
name|whitespace
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t' || (c) == '\n')
end_define

begin_comment
comment|/* A structure defining a single expression context. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|curtok
decl_stmt|,
name|lasttok
decl_stmt|;
name|char
modifier|*
name|expression
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|int
name|tokval
decl_stmt|;
name|char
modifier|*
name|tokstr
decl_stmt|;
block|}
name|EXPR_CONTEXT
typedef|;
end_typedef

begin_comment
comment|/* Global var which contains the stack of expression contexts. */
end_comment

begin_decl_stmt
specifier|static
name|EXPR_CONTEXT
modifier|*
modifier|*
name|expr_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location in the stack. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|expr_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots already allocated. */
end_comment

begin_comment
comment|/* Size be which the expression stack grows when neccessary. */
end_comment

begin_define
define|#
directive|define
name|EXPR_STACK_GROW_SIZE
value|10
end_define

begin_comment
comment|/* Maximum amount of recursion allowed.  This prevents a non-integer    variable such as "num=num+2" from infinitely adding to itself when    "let num=num+2" is given.  I have to talk to Chet about this hack. */
end_comment

begin_define
define|#
directive|define
name|MAX_EXPR_RECURSION_LEVEL
value|1024
end_define

begin_function_decl
specifier|extern
name|long
name|atol
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The Tokens.  Singing "The Lion Sleeps Tonight". */
end_comment

begin_define
define|#
directive|define
name|EQEQ
value|1
end_define

begin_comment
comment|/* "==" */
end_comment

begin_define
define|#
directive|define
name|NEQ
value|2
end_define

begin_comment
comment|/* "!=" */
end_comment

begin_define
define|#
directive|define
name|LEQ
value|3
end_define

begin_comment
comment|/* "<=" */
end_comment

begin_define
define|#
directive|define
name|GEQ
value|4
end_define

begin_comment
comment|/* ">=" */
end_comment

begin_define
define|#
directive|define
name|STR
value|5
end_define

begin_comment
comment|/* string */
end_comment

begin_define
define|#
directive|define
name|NUM
value|6
end_define

begin_comment
comment|/* number */
end_comment

begin_define
define|#
directive|define
name|EQ
value|'='
end_define

begin_define
define|#
directive|define
name|GT
value|'>'
end_define

begin_define
define|#
directive|define
name|LT
value|'<'
end_define

begin_define
define|#
directive|define
name|PLUS
value|'+'
end_define

begin_define
define|#
directive|define
name|MINUS
value|'-'
end_define

begin_define
define|#
directive|define
name|MUL
value|'*'
end_define

begin_define
define|#
directive|define
name|DIV
value|'/'
end_define

begin_define
define|#
directive|define
name|MOD
value|'%'
end_define

begin_define
define|#
directive|define
name|NOT
value|'!'
end_define

begin_define
define|#
directive|define
name|LPAR
value|'('
end_define

begin_define
define|#
directive|define
name|RPAR
value|')'
end_define

begin_comment
comment|/* Push and save away the contents of the globals describing the    current expression context. */
end_comment

begin_function
specifier|static
name|void
name|pushexp
parameter_list|()
block|{
name|EXPR_CONTEXT
modifier|*
name|context
decl_stmt|;
name|context
operator|=
operator|(
name|EXPR_CONTEXT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EXPR_CONTEXT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_depth
operator|>=
name|MAX_EXPR_RECURSION_LEVEL
condition|)
name|evalerror
argument_list|(
literal|"expression recursion level exceeded"
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_depth
operator|>=
name|expr_stack_size
condition|)
block|{
name|expr_stack
operator|=
operator|(
name|EXPR_CONTEXT
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|expr_stack
argument_list|,
operator|(
name|expr_stack_size
operator|+=
name|EXPR_STACK_GROW_SIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EXPR_CONTEXT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|->
name|curtok
operator|=
name|curtok
expr_stmt|;
name|context
operator|->
name|lasttok
operator|=
name|lasttok
expr_stmt|;
name|context
operator|->
name|expression
operator|=
name|expression
expr_stmt|;
name|context
operator|->
name|tp
operator|=
name|tp
expr_stmt|;
name|context
operator|->
name|tokval
operator|=
name|tokval
expr_stmt|;
name|context
operator|->
name|tokstr
operator|=
name|tokstr
expr_stmt|;
name|expr_stack
index|[
name|expr_depth
operator|++
index|]
operator|=
name|context
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the the contents of the expression context stack into the    globals describing the current expression context. */
end_comment

begin_function
specifier|static
name|void
name|popexp
parameter_list|()
block|{
name|EXPR_CONTEXT
modifier|*
name|context
decl_stmt|;
if|if
condition|(
name|expr_depth
operator|==
literal|0
condition|)
name|evalerror
argument_list|(
literal|"Recursion stack underflow"
argument_list|)
expr_stmt|;
name|context
operator|=
name|expr_stack
index|[
operator|--
name|expr_depth
index|]
expr_stmt|;
name|curtok
operator|=
name|context
operator|->
name|curtok
expr_stmt|;
name|lasttok
operator|=
name|context
operator|->
name|lasttok
expr_stmt|;
name|expression
operator|=
name|context
operator|->
name|expression
expr_stmt|;
name|tp
operator|=
name|context
operator|->
name|tp
expr_stmt|;
name|tokval
operator|=
name|context
operator|->
name|tokval
expr_stmt|;
name|tokstr
operator|=
name|context
operator|->
name|tokstr
expr_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Evaluate EXPR, and return the arithmetic result.     The `while' loop after the longjmp is caught relies on the above    implementation of pushexp and popexp leaving in expr_stack[0] the    values that the variables had when the program started.  That is,    the first things saved are the initial values of the variables that     were assigned at program startup or by the compiler.  Therefore, it is    safe to let the loop terminate when expr_depth == 0, without freeing up    any of the expr_depth[0] stuff. */
end_comment

begin_function
name|long
name|evalexp
parameter_list|(
name|expr
parameter_list|)
name|char
modifier|*
name|expr
decl_stmt|;
block|{
name|long
name|val
init|=
literal|0L
decl_stmt|;
name|jmp_buf
name|old_evalbuf
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|NULL
operator|||
operator|*
name|expr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Save the value of evalbuf to protect it around possible recursive      calls to evalexp (). */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evalbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|old_evalbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|evalbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|tokstr
condition|)
comment|/* Clean up local allocation. */
name|free
argument_list|(
name|tokstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expression
condition|)
name|free
argument_list|(
name|expression
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|expr_depth
condition|)
block|{
if|if
condition|(
name|expr_stack
index|[
name|expr_depth
index|]
operator|->
name|tokstr
condition|)
name|free
argument_list|(
name|expr_stack
index|[
name|expr_depth
index|]
operator|->
name|tokstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_stack
index|[
name|expr_depth
index|]
operator|->
name|expression
condition|)
name|free
argument_list|(
name|expr_stack
index|[
name|expr_depth
index|]
operator|->
name|expression
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
name|pushexp
argument_list|()
expr_stmt|;
name|curtok
operator|=
name|lasttok
operator|=
literal|0
expr_stmt|;
name|expression
operator|=
name|savestring
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|tp
operator|=
name|expression
expr_stmt|;
name|tokstr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|tokval
operator|=
literal|0l
expr_stmt|;
name|readtok
argument_list|()
expr_stmt|;
name|val
operator|=
name|assignment
argument_list|()
expr_stmt|;
if|if
condition|(
name|curtok
operator|!=
literal|0
condition|)
name|evalerror
argument_list|(
literal|"syntax error in expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|expression
condition|)
name|free
argument_list|(
name|expression
argument_list|)
expr_stmt|;
name|popexp
argument_list|()
expr_stmt|;
comment|/* Restore the value of evalbuf so that any subsequent longjmp calls      will have a valid location to jump to. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old_evalbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|evalbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind/create a shell variable with the name LHS to the RHS.    This creates or modifies a variable such that it is an integer.     This should really be in variables.c, but it is here so that all of the    expression evaluation stuff is localized.  Since we don't want any    recursive evaluation from bind_variable() (possible without this code,    since bind_variable() calls the evaluator for variables with the integer    attribute set), we temporarily turn off the integer attribute for each    variable we set here, then turn it back on after binding as necessary. */
end_comment

begin_function
name|void
name|bind_int_variable
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|char
modifier|*
name|lhs
decl_stmt|,
decl|*
name|rhs
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SHELL_VAR
modifier|*
name|v
decl_stmt|;
name|int
name|isint
init|=
literal|0
decl_stmt|;
name|v
operator|=
name|find_variable
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|isint
operator|=
name|integer_p
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|->
name|attributes
operator|&=
operator|~
name|att_integer
expr_stmt|;
block|}
name|v
operator|=
name|bind_variable
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isint
condition|)
name|v
operator|->
name|attributes
operator||=
name|att_integer
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|long
name|assignment
parameter_list|()
block|{
specifier|register
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|lhs
decl_stmt|;
name|char
modifier|*
name|rhs
decl_stmt|;
name|value
operator|=
name|exp5
argument_list|()
expr_stmt|;
if|if
condition|(
name|curtok
operator|==
name|EQ
condition|)
block|{
if|if
condition|(
name|lasttok
operator|!=
name|STR
condition|)
name|evalerror
argument_list|(
literal|"attempted assignment to non-variable"
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|savestring
argument_list|(
name|tokstr
argument_list|)
expr_stmt|;
name|readtok
argument_list|()
expr_stmt|;
name|value
operator|=
name|assignment
argument_list|()
expr_stmt|;
name|rhs
operator|=
name|itos
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|bind_int_variable
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tokstr
argument_list|)
expr_stmt|;
name|tokstr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* For freeing on errors. */
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|exp5
parameter_list|()
block|{
specifier|register
name|long
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|val1
operator|=
name|exp4
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|curtok
operator|==
name|EQEQ
operator|)
operator|||
operator|(
name|curtok
operator|==
name|NEQ
operator|)
condition|)
block|{
name|int
name|op
init|=
name|curtok
decl_stmt|;
name|readtok
argument_list|()
expr_stmt|;
name|val2
operator|=
name|exp4
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|EQEQ
condition|)
name|val1
operator|=
operator|(
name|val1
operator|==
name|val2
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|NEQ
condition|)
name|val1
operator|=
operator|(
name|val1
operator|!=
name|val2
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|val1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|exp4
parameter_list|()
block|{
specifier|register
name|long
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|val1
operator|=
name|exp3
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|curtok
operator|==
name|LEQ
operator|)
operator|||
operator|(
name|curtok
operator|==
name|GEQ
operator|)
operator|||
operator|(
name|curtok
operator|==
name|LT
operator|)
operator|||
operator|(
name|curtok
operator|==
name|GT
operator|)
condition|)
block|{
name|int
name|op
init|=
name|curtok
decl_stmt|;
name|readtok
argument_list|()
expr_stmt|;
name|val2
operator|=
name|exp3
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|LEQ
condition|)
name|val1
operator|=
name|val1
operator|<=
name|val2
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|GEQ
condition|)
name|val1
operator|=
name|val1
operator|>=
name|val2
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|LT
condition|)
name|val1
operator|=
name|val1
operator|<
name|val2
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|GT
condition|)
name|val1
operator|=
name|val1
operator|>
name|val2
expr_stmt|;
block|}
return|return
operator|(
name|val1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|exp3
parameter_list|()
block|{
specifier|register
name|long
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|val1
operator|=
name|exp2
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|curtok
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|curtok
operator|==
name|MINUS
operator|)
condition|)
block|{
name|int
name|op
init|=
name|curtok
decl_stmt|;
name|readtok
argument_list|()
expr_stmt|;
name|val2
operator|=
name|exp2
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|PLUS
condition|)
name|val1
operator|+=
name|val2
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|MINUS
condition|)
name|val1
operator|-=
name|val2
expr_stmt|;
block|}
return|return
operator|(
name|val1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|exp2
parameter_list|()
block|{
specifier|register
name|long
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|val1
operator|=
name|exp1
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|curtok
operator|==
name|MUL
operator|)
operator|||
operator|(
name|curtok
operator|==
name|DIV
operator|)
operator|||
operator|(
name|curtok
operator|==
name|MOD
operator|)
condition|)
block|{
name|int
name|op
init|=
name|curtok
decl_stmt|;
name|readtok
argument_list|()
expr_stmt|;
name|val2
operator|=
name|exp1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|op
operator|==
name|DIV
operator|)
operator|||
operator|(
name|op
operator|==
name|MOD
operator|)
operator|)
operator|&&
operator|(
name|val2
operator|==
literal|0
operator|)
condition|)
name|evalerror
argument_list|(
literal|"division by 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|MUL
condition|)
name|val1
operator|*=
name|val2
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|DIV
condition|)
name|val1
operator|/=
name|val2
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|MOD
condition|)
name|val1
operator|%=
name|val2
expr_stmt|;
block|}
return|return
operator|(
name|val1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|exp1
parameter_list|()
block|{
specifier|register
name|long
name|val
decl_stmt|;
if|if
condition|(
name|curtok
operator|==
name|NOT
condition|)
block|{
name|readtok
argument_list|()
expr_stmt|;
name|val
operator|=
operator|!
name|exp0
argument_list|()
expr_stmt|;
block|}
else|else
name|val
operator|=
name|exp0
argument_list|()
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|exp0
parameter_list|()
block|{
specifier|register
name|long
name|val
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|curtok
operator|==
name|MINUS
condition|)
block|{
name|readtok
argument_list|()
expr_stmt|;
name|val
operator|=
operator|-
name|exp0
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curtok
operator|==
name|LPAR
condition|)
block|{
name|readtok
argument_list|()
expr_stmt|;
name|val
operator|=
name|assignment
argument_list|()
expr_stmt|;
if|if
condition|(
name|curtok
operator|!=
name|RPAR
condition|)
name|evalerror
argument_list|(
literal|"missing `)'"
argument_list|)
expr_stmt|;
comment|/* Skip over closing paren. */
name|readtok
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|curtok
operator|==
name|NUM
operator|)
operator|||
operator|(
name|curtok
operator|==
name|STR
operator|)
condition|)
block|{
name|val
operator|=
name|tokval
expr_stmt|;
name|readtok
argument_list|()
expr_stmt|;
block|}
else|else
name|evalerror
argument_list|(
literal|"syntax error in expression"
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lexical analyzer/token reader for the expression evaluator.  Reads the    next token and puts its value into curtok, while advancing past it.    Updates value of tp.  May also set tokval (for number) or tokstr (for    string). */
end_comment

begin_function
specifier|static
name|void
name|readtok
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|tp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|c1
decl_stmt|;
comment|/* Skip leading whitespace. */
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|&&
operator|(
name|whitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|cp
operator|++
expr_stmt|;
name|tp
operator|=
name|cp
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|lasttok
operator|=
name|curtok
expr_stmt|;
name|curtok
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|cp
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|variable_starter
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Semi-bogus K*rn shell compatibility feature -- variable 	 names not preceded with a dollar sign are shell variables. */
name|char
modifier|*
name|value
decl_stmt|;
while|while
condition|(
name|variable_character
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|c
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|tokstr
operator|=
name|savestring
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|value
operator|=
name|get_string_value
argument_list|(
name|tokstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
name|tokval
operator|=
name|evalexp
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|tokval
operator|=
literal|0
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
name|lasttok
operator|=
name|curtok
expr_stmt|;
name|curtok
operator|=
name|STR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
name|digit
argument_list|(
name|c
argument_list|)
operator|||
name|isletter
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'#'
condition|)
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|c
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|tokval
operator|=
name|strlong
argument_list|(
name|tp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
name|lasttok
operator|=
name|curtok
expr_stmt|;
name|curtok
operator|=
name|NUM
expr_stmt|;
block|}
else|else
block|{
name|c1
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|EQ
operator|)
operator|&&
operator|(
name|c1
operator|==
name|EQ
operator|)
condition|)
name|c
operator|=
name|EQEQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
name|NOT
operator|)
operator|&&
operator|(
name|c1
operator|==
name|EQ
operator|)
condition|)
name|c
operator|=
name|NEQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
name|GT
operator|)
operator|&&
operator|(
name|c1
operator|==
name|EQ
operator|)
condition|)
name|c
operator|=
name|GEQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
name|LT
operator|)
operator|&&
operator|(
name|c1
operator|==
name|EQ
operator|)
condition|)
name|c
operator|=
name|LEQ
expr_stmt|;
else|else
name|cp
operator|--
expr_stmt|;
comment|/* `unget' the character */
name|lasttok
operator|=
name|curtok
expr_stmt|;
name|curtok
operator|=
name|c
expr_stmt|;
block|}
name|tp
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evalerror
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|builtin_error
argument_list|(
literal|"%s: %s (remainder of expression is \"%s\")"
argument_list|,
name|expression
argument_list|,
name|msg
argument_list|,
operator|(
name|tp
operator|&&
operator|*
name|tp
operator|)
condition|?
name|tp
else|:
literal|""
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|evalbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a string to a long integer, with an arbitrary base.    0nnn -> base 8    0xnn -> base 16    Anything else: [base#]number (this is from the ISO Pascal spec). */
end_comment

begin_function
specifier|static
name|long
name|strlong
parameter_list|(
name|num
parameter_list|)
name|char
modifier|*
name|num
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|num
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
name|long
name|val
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
name|NULL
condition|)
return|return
literal|0L
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
name|NULL
condition|)
return|return
literal|0L
return|;
comment|/* Base 16? */
if|if
condition|(
operator|*
name|s
operator|==
literal|'x'
operator|||
operator|*
name|s
operator|==
literal|'X'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
operator|*
name|s
operator|++
init|;
name|c
condition|;
name|c
operator|=
operator|*
name|s
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|base
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
comment|/* Illegal base specifications are silently reset to base 10. 	     I don't think that this is a good idea? */
if|if
condition|(
name|base
operator|<
literal|2
operator|||
name|base
operator|>
literal|36
condition|)
name|base
operator|=
literal|10
expr_stmt|;
name|val
operator|=
literal|0L
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isletter
argument_list|(
name|c
argument_list|)
operator|||
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
name|c
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator|-=
literal|'A'
operator|-
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|base
condition|)
name|evalerror
argument_list|(
literal|"value too great for base"
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|val
operator|*
name|base
operator|)
operator|+
name|c
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

end_unit

