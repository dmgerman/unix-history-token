begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* shell.c -- GNU's idea of the POSIX shell specification.     This file is part of Bash, the Bourne Again SHell.  Bash is free    software; no one can prevent you from reading the source code, or    giving it to someone else.  This file is copyrighted under the GNU    General Public License, which can be found in the file called    COPYING.     Copyright (C) 1988, 1991 Free Software Foundation, Inc.     This file is part of GNU Bash.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY.  No author or distributor accepts responsibility to    anyone for the consequences of using it or for whether it serves    any particular purpose or works at all, unless he says so in    writing.  Refer to the GNU Emacs General Public License for full    details.     Everyone is granted permission to copy, modify and redistribute    Bash, but only under the conditions described in the GNU General    Public License.  A copy of this license is supposed to have been    given to you along with GNU Emacs so you can know your rights and    responsibilities.  It should be in a file named COPYING.     Among other things, the copyright notice and this notice must be    preserved on all copies.    Birthdate:   Sunday, January 10th, 1988.   Initial author: Brian Fox */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_include
include|#
directive|include
file|"filecntl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOB_CONTROL */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|isc386
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
end_if

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dist_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|build_version
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|using_history
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-zero means that this shell has already been run; i.e. you should    call shell_reinitialize () if you need to start afresh. */
end_comment

begin_decl_stmt
name|int
name|shell_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current maintainer of the shell.  You change this in the    Makefile. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAINTAINER
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAINTAINER
value|"deliberately-anonymous"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|the_current_maintainer
init|=
name|MAINTAINER
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PPROMPT
end_ifndef

begin_define
define|#
directive|define
name|PPROMPT
value|"bash\\$ "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|primary_prompt
init|=
name|PPROMPT
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SPROMPT
argument_list|)
end_if

begin_define
define|#
directive|define
name|SPROMPT
value|"> "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|secondary_prompt
init|=
name|SPROMPT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|COMMAND
modifier|*
name|global_command
init|=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero after SIGINT. */
end_comment

begin_decl_stmt
name|int
name|interrupt_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current user's name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_user_name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current host's name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_host_name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that this shell is a login shell.    Specifically:    0 = not login shell.    1 = login shell from getty (or equivalent fake out)   -1 = login shell from "-login" flag.   -2 = both from getty, and from flag.  */
end_comment

begin_decl_stmt
name|int
name|login_shell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that at this moment, the shell is interactive. */
end_comment

begin_decl_stmt
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the shell was started as an interactive shell. */
end_comment

begin_decl_stmt
name|int
name|interactive_shell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to remember lines typed to the shell on the history    list.  This is different than the user-controlled behaviour; this    becomes zero when we read lines from a file, for example. */
end_comment

begin_decl_stmt
name|int
name|remember_on_history
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means this shell is restricted. */
end_comment

begin_decl_stmt
name|int
name|restricted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special debugging helper. */
end_comment

begin_decl_stmt
name|int
name|debugging_login_shell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The environment that the shell passes to other commands. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|shell_environment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero when we are executing a top-level command. */
end_comment

begin_decl_stmt
name|int
name|executing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of commands executed so far. */
end_comment

begin_decl_stmt
name|int
name|current_command_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The environment at the top-level REP loop.  We use this in the case of    error return. */
end_comment

begin_decl_stmt
name|jmp_buf
name|top_level
decl_stmt|,
name|catch
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_comment
comment|/* The signal masks that this shell runs with. */
end_comment

begin_decl_stmt
name|sigset_t
name|top_level_mask
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOB_CONTROL */
end_comment

begin_comment
comment|/* Non-zero is the recursion depth for commands. */
end_comment

begin_decl_stmt
name|int
name|indirection_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of times BASH has been executed.  This is set    by initialize_variables () in variables.c. */
end_comment

begin_decl_stmt
name|int
name|shell_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of this shell, as taken from argv[0]. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shell_name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time in seconds when the shell was started */
end_comment

begin_decl_stmt
name|time_t
name|shell_start_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the .(shell)rc file. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bashrc_file
init|=
literal|"~/.bashrc"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to act more like the Bourne shell on startup. */
end_comment

begin_decl_stmt
name|int
name|act_like_sh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values for the long-winded argument names. */
end_comment

begin_decl_stmt
name|int
name|debugging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do debugging things. */
end_comment

begin_decl_stmt
name|int
name|no_rc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't execute ~/.bashrc */
end_comment

begin_decl_stmt
name|int
name|no_profile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't execute .profile */
end_comment

begin_decl_stmt
name|int
name|do_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Display interesting version info. */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Be quiet when starting up. */
end_comment

begin_decl_stmt
name|int
name|make_login_shell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make this shell be a `-bash' shell. */
end_comment

begin_decl_stmt
name|int
name|no_line_editing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't do fancy line editing. */
end_comment

begin_decl_stmt
name|int
name|no_brace_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means no foo{a,b} -> fooa fooa. */
end_comment

begin_comment
comment|/* Some long-winded argument names.  These are obviously new. */
end_comment

begin_define
define|#
directive|define
name|Int
value|1
end_define

begin_define
define|#
directive|define
name|Charp
value|2
end_define

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
name|long_args
index|[]
init|=
block|{
block|{
literal|"debug"
block|,
operator|&
name|debugging
block|,
name|Int
block|}
block|,
block|{
literal|"norc"
block|,
operator|&
name|no_rc
block|,
name|Int
block|}
block|,
block|{
literal|"noprofile"
block|,
operator|&
name|no_profile
block|,
name|Int
block|}
block|,
block|{
literal|"rcfile"
block|,
operator|(
name|int
operator|*
operator|)
operator|&
name|bashrc_file
block|,
name|Charp
block|}
block|,
block|{
literal|"version"
block|,
operator|&
name|do_version
block|,
name|Int
block|}
block|,
block|{
literal|"quiet"
block|,
operator|&
name|quiet
block|,
name|Int
block|}
block|,
block|{
literal|"login"
block|,
operator|&
name|make_login_shell
block|,
name|Int
block|}
block|,
block|{
literal|"nolineediting"
block|,
operator|&
name|no_line_editing
block|,
name|Int
block|}
block|,
block|{
literal|"nobraceexpansion"
block|,
operator|&
name|no_brace_expansion
block|,
name|Int
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
operator|*
operator|)
literal|0x0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* The number of lines that Bash has added to this history session. */
end_comment

begin_decl_stmt
name|int
name|history_lines_this_session
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of lines that Bash has read from the history file. */
end_comment

begin_decl_stmt
name|int
name|history_lines_in_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are extern so execute_simple_command can set them, and then    longjmp back to main to execute a shell script, instead of calling    main () again and resulting in indefinite, possibly fatal, stack    growth. */
end_comment

begin_decl_stmt
name|jmp_buf
name|subshell_top_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|subshell_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|subshell_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|subshell_envp
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|env
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|env
decl_stmt|;
end_function

begin_block
block|{
specifier|extern
name|int
name|last_command_exit_value
decl_stmt|;
specifier|extern
name|char
modifier|*
name|base_pathname
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|arg_index
decl_stmt|,
name|locally_skip_execution
decl_stmt|;
name|int
name|top_level_arg_index
decl_stmt|,
name|read_from_stdin
decl_stmt|;
name|FILE
modifier|*
name|default_input
decl_stmt|;
name|char
modifier|*
name|local_pending_command
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
specifier|extern
name|int
name|job_control
decl_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
if|#
directive|if
name|defined
argument_list|(
name|AUX
argument_list|)
include|#
directive|include
file|<compat.h>
name|set42sig
argument_list|()
expr_stmt|;
name|setcompat
argument_list|(
name|getcompat
argument_list|()
operator||
name|COMPAT_BSDGROUPS
operator||
name|COMPAT_BSDSIGNALS
operator||
name|COMPAT_BSDTTY
operator||
name|COMPAT_EXEC
operator||
name|COMPAT_SYSCALLS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUX */
comment|/* There is a bug in the NeXT 2.1 rlogind that causes opens      of /dev/tty to fail. */
if|#
directive|if
name|defined
argument_list|(
name|NeXT
argument_list|)
block|{
name|int
name|tty_fd
decl_stmt|;
name|tty_fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_fd
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|tty
decl_stmt|;
name|tty
operator|=
operator|(
name|char
operator|*
operator|)
name|ttyname
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|tty_fd
operator|=
name|open
argument_list|(
name|tty
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|tty_fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NeXT */
comment|/* Wait forever if we are debugging a login shell. */
while|while
condition|(
name|debugging_login_shell
condition|)
empty_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|subshell_top_level
argument_list|)
condition|)
block|{
name|argc
operator|=
name|subshell_argc
expr_stmt|;
name|argv
operator|=
name|subshell_argv
expr_stmt|;
name|env
operator|=
name|subshell_envp
expr_stmt|;
block|}
comment|/* Initialize local variables for all `invocations' of main (). */
name|arg_index
operator|=
literal|1
expr_stmt|;
name|local_pending_command
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|locally_skip_execution
operator|=
literal|0
expr_stmt|;
name|read_from_stdin
operator|=
literal|0
expr_stmt|;
name|default_input
operator|=
name|stdin
expr_stmt|;
comment|/* Fix for the `infinite process creation' bug when running shell scripts      from startup files on System V. */
name|login_shell
operator|=
name|make_login_shell
operator|=
literal|0
expr_stmt|;
comment|/* If this shell has already been run, then reinitialize it to a      vanilla state. */
if|if
condition|(
name|shell_initialized
operator|||
name|shell_name
condition|)
block|{
comment|/* Make sure that we do not infinitely recurse as a login shell. */
if|if
condition|(
operator|*
name|shell_name
operator|==
literal|'-'
condition|)
name|shell_name
operator|++
expr_stmt|;
name|shell_reinitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|top_level
argument_list|)
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Here's a hack.  If the name of this shell is "sh", then don't do      any startup files; just try to be more like /bin/sh. */
block|{
name|char
modifier|*
name|tshell_name
init|=
name|base_pathname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|tshell_name
operator|==
literal|'-'
condition|)
name|tshell_name
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tshell_name
argument_list|,
literal|"sh"
argument_list|)
operator|==
literal|0
condition|)
name|act_like_sh
operator|++
expr_stmt|;
block|}
name|yydebug
operator|=
literal|0
expr_stmt|;
name|shell_environment
operator|=
name|env
expr_stmt|;
name|shell_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|dollar_vars
index|[
literal|0
index|]
operator|=
name|savestring
argument_list|(
name|shell_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|shell_name
operator|==
literal|'-'
condition|)
block|{
name|shell_name
operator|++
expr_stmt|;
name|login_shell
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
if|if
condition|(
name|act_like_sh
condition|)
name|job_control
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
name|shell_start_time
operator|=
name|NOW
expr_stmt|;
comment|/* NOW now defined in general.h */
comment|/* A program may start an interactive shell with         "execl ("/bin/bash", "-", NULL)".      If so, default the name of this shell to our name. */
if|if
condition|(
operator|!
name|shell_name
operator|||
operator|!
operator|*
name|shell_name
operator|||
operator|(
name|strcmp
argument_list|(
name|shell_name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|shell_name
operator|=
literal|"bash"
expr_stmt|;
comment|/* Parse argument flags from the input line. */
comment|/* Find full word arguments first. */
while|while
condition|(
operator|(
name|arg_index
operator|!=
name|argc
operator|)
operator|&&
operator|*
operator|(
name|argv
index|[
name|arg_index
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|long_args
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|&
operator|(
name|argv
index|[
name|arg_index
index|]
index|[
literal|1
index|]
operator|)
argument_list|,
name|long_args
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|long_args
index|[
name|i
index|]
operator|.
name|type
operator|==
name|Int
condition|)
operator|*
operator|(
name|long_args
index|[
name|i
index|]
operator|.
name|value
operator|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|argv
index|[
operator|++
name|arg_index
index|]
condition|)
block|{
name|report_error
argument_list|(
literal|"%s: Flag `%s' expected an argument"
argument_list|,
name|shell_name
argument_list|,
name|long_args
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|long_args
index|[
name|i
index|]
operator|.
name|value
operator|=
operator|(
name|int
operator|)
name|argv
index|[
name|arg_index
index|]
expr_stmt|;
block|}
goto|goto
name|handle_next_arg
goto|;
block|}
block|}
break|break;
comment|/* No such argument.  Maybe flag arg. */
name|handle_next_arg
label|:
name|arg_index
operator|++
expr_stmt|;
block|}
comment|/* If user supplied the "-login" flag, then set and invert LOGIN_SHELL. */
if|if
condition|(
name|make_login_shell
condition|)
name|login_shell
operator|=
operator|-
operator|++
name|login_shell
expr_stmt|;
comment|/* All done with full word args; do standard shell arg parsing.*/
while|while
condition|(
name|arg_index
operator|!=
name|argc
operator|&&
name|argv
index|[
name|arg_index
index|]
operator|&&
operator|(
operator|*
operator|(
name|argv
index|[
name|arg_index
index|]
operator|)
operator|==
literal|'-'
operator|||
operator|(
operator|*
name|argv
index|[
name|arg_index
index|]
operator|==
literal|'+'
operator|)
operator|)
condition|)
block|{
comment|/* There are flag arguments, so parse them. */
name|int
name|arg_character
decl_stmt|;
name|int
name|on_or_off
init|=
operator|(
operator|*
name|argv
index|[
name|arg_index
index|]
operator|)
decl_stmt|;
name|char
modifier|*
name|o_option
decl_stmt|;
name|int
name|next_arg
init|=
name|arg_index
operator|+
literal|1
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* A single `-' signals the end of options.  From the 4.3 BSD sh. 	 An option `--' means the same thing; this is the standard 	 getopt () meaning. */
if|if
condition|(
operator|(
operator|(
name|argv
index|[
name|arg_index
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|argv
index|[
name|arg_index
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|arg_index
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|arg_index
operator|++
expr_stmt|;
goto|goto
name|after_flags
goto|;
block|}
while|while
condition|(
name|arg_character
operator|=
operator|(
name|argv
index|[
name|arg_index
index|]
operator|)
index|[
name|i
operator|++
index|]
condition|)
block|{
switch|switch
condition|(
name|arg_character
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* The next arg is a command to execute, and the following args 		 are $1 .. $n respectively. */
name|local_pending_command
operator|=
name|argv
index|[
operator|++
name|arg_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|local_pending_command
condition|)
block|{
name|report_error
argument_list|(
literal|"`%cc' requires an argument"
argument_list|,
name|on_or_off
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|arg_index
operator|++
expr_stmt|;
goto|goto
name|after_flags
goto|;
case|case
literal|'s'
case|:
name|read_from_stdin
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|o_option
operator|=
name|argv
index|[
name|next_arg
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|o_option
condition|)
block|{
name|report_error
argument_list|(
literal|"`%co' requires an argument"
argument_list|,
name|on_or_off
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_minus_o_option
argument_list|(
name|on_or_off
argument_list|,
name|o_option
argument_list|)
operator|!=
name|EXECUTION_SUCCESS
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|change_flag_char
argument_list|(
name|arg_character
argument_list|,
name|on_or_off
argument_list|)
operator|==
name|FLAG_ERROR
condition|)
block|{
name|report_error
argument_list|(
literal|"%c%c: bad option"
argument_list|,
name|on_or_off
argument_list|,
name|arg_character
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Can't do just a simple increment anymore -- what about 	 "bash -abouo emacs ignoreeof -hO"? */
name|arg_index
operator|=
name|next_arg
expr_stmt|;
block|}
name|after_flags
label|:
comment|/* First, let the outside world know about our interactive status.      A shell is interactive if the `-i' flag was given, or if all of      the following conditions are met: 	no -c command 	no arguments remaining or the -s flag given 	standard input is a terminal 	standard output is a terminal      Refer to Posix.2, the description of the `sh' utility. */
if|if
condition|(
name|forced_interactive
operator|||
comment|/* -i flag */
operator|(
operator|!
name|local_pending_command
operator|&&
comment|/* No -c command and ... */
operator|(
operator|(
name|arg_index
operator|==
name|argc
operator|)
operator|||
comment|/*   no remaining args or... */
name|read_from_stdin
operator|)
operator|&&
comment|/*   -s flag with args, and */
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
comment|/* Input is a terminal and */
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* output is a terminal. */
block|{
name|interactive_shell
operator|=
literal|1
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|history_expansion
operator|=
literal|0
expr_stmt|;
name|remember_on_history
operator|=
literal|0
expr_stmt|;
name|interactive_shell
operator|=
literal|0
expr_stmt|;
name|interactive
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|job_control
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
block|}
define|#
directive|define
name|CLOSE_FDS_AT_LOGIN
if|#
directive|if
name|defined
argument_list|(
name|CLOSE_FDS_AT_LOGIN
argument_list|)
comment|/*    * Some systems have the bad habit of starting login shells with lots of open    * file descriptors.  For instance, most systems that have picked up the    * pre-4.0 Sun YP code leave a file descriptor open each time you call one    * of the getpw* functions, and it's set to be open across execs.  That    * means one for login, one for xterm, one for shelltool, etc.    */
if|if
condition|(
name|login_shell
operator|&&
name|interactive_shell
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CLOSE_FDS_AT_LOGIN */
comment|/* From here on in, the shell must be a normal functioning shell.      Variables from the environment are expected to be set, etc. */
name|shell_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|interactive_shell
condition|)
block|{
name|char
modifier|*
name|term
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
if|if
condition|(
name|term
operator|&&
operator|(
name|strcmp
argument_list|(
name|term
argument_list|,
literal|"emacs"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|no_line_editing
operator|=
literal|1
expr_stmt|;
block|}
name|top_level_arg_index
operator|=
name|arg_index
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
name|do_version
condition|)
name|show_shell_version
argument_list|()
expr_stmt|;
comment|/* Give this shell a place to longjmp to before executing the      startup files.  This allows users to press C-c to abort the      lengthy startup. */
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|setjmp
argument_list|(
name|top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EXITPROG
condition|)
goto|goto
name|exit_shell
goto|;
else|else
name|locally_skip_execution
operator|++
expr_stmt|;
block|}
block|}
name|arg_index
operator|=
name|top_level_arg_index
expr_stmt|;
comment|/* Execute the start-up scripts. */
if|if
condition|(
operator|!
name|interactive_shell
condition|)
block|{
name|makunbound
argument_list|(
literal|"PS1"
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
name|makunbound
argument_list|(
literal|"PS2"
argument_list|,
name|shell_variables
argument_list|)
expr_stmt|;
name|interactive
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|change_flag_char
argument_list|(
literal|'i'
argument_list|,
name|FLAG_ON
argument_list|)
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|locally_skip_execution
condition|)
block|{
if|if
condition|(
name|login_shell
condition|)
block|{
comment|/* We don't execute .bashrc for login shells. */
name|no_rc
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NOTDEF
argument_list|)
if|if
condition|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
condition|)
endif|#
directive|endif
comment|/* NOTDEF */
name|maybe_execute_file
argument_list|(
literal|"/etc/profile"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|login_shell
operator|&&
operator|!
name|no_profile
condition|)
block|{
if|if
condition|(
name|act_like_sh
condition|)
name|maybe_execute_file
argument_list|(
literal|"~/.profile"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|maybe_execute_file
argument_list|(
literal|"~/.bash_profile"
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|maybe_execute_file
argument_list|(
literal|"~/.bash_login"
argument_list|)
operator|==
literal|0
condition|)
name|maybe_execute_file
argument_list|(
literal|"~/.profile"
argument_list|)
expr_stmt|;
block|}
comment|/* I turn on the restrictions afterwards because it is explictly 	   stated in the POSIX spec that PATH cannot be set in a restricted 	   shell, except in .profile. */
if|if
condition|(
operator|*
operator|++
operator|(
name|argv
index|[
literal|0
index|]
operator|)
operator|==
literal|'r'
condition|)
block|{
name|set_var_read_only
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
name|set_var_read_only
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
name|restricted
operator|++
expr_stmt|;
block|}
block|}
comment|/* Execute ~/.bashrc for most shells.  Never execute it if 	 ACT_LIKE_SH is set, or if NO_RC is set.  	 If the executable file "/usr/gnu/src/bash/foo" contains:  	   #!/usr/gnu/bin/bash 	   echo hello  	 then:  	 COMMAND	    EXECUTE BASHRC 	 -------------------------------- 	 bash -c foo		NO 	 bash foo		NO 	 foo			NO 	 rsh machine ls		YES (for rsh, which calls `bash -c') 	 rsh machine foo	YES (for shell started by rsh) NO (for foo!) 	 echo ls | bash		NO 	 login			YES 	 bash			YES       */
if|if
condition|(
operator|!
name|act_like_sh
operator|&&
operator|!
name|no_rc
operator|&&
operator|(
name|interactive_shell
operator|||
operator|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|local_pending_command
operator|)
operator|)
condition|)
name|maybe_execute_file
argument_list|(
name|bashrc_file
argument_list|)
expr_stmt|;
comment|/* Try a TMB suggestion.  If running a script, then execute the 	 file mentioned in the ENV variable. */
if|if
condition|(
operator|!
name|interactive_shell
condition|)
block|{
name|char
modifier|*
name|env_file
init|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"ENV"
argument_list|)
decl_stmt|;
if|if
condition|(
name|env_file
operator|&&
operator|*
name|env_file
condition|)
block|{
name|WORD_LIST
modifier|*
name|list
decl_stmt|,
modifier|*
name|expand_string_unsplit
argument_list|()
decl_stmt|;
name|char
modifier|*
name|expanded_file_name
decl_stmt|,
modifier|*
name|string_list
argument_list|()
decl_stmt|;
name|list
operator|=
name|expand_string_unsplit
argument_list|(
name|env_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|expanded_file_name
operator|=
name|string_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded_file_name
operator|&&
operator|*
name|expanded_file_name
condition|)
name|maybe_execute_file
argument_list|(
name|expanded_file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded_file_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|local_pending_command
condition|)
block|{
comment|/* Bind remaining args to $1 ... $n */
name|WORD_LIST
modifier|*
name|args
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|arg_index
operator|!=
name|argc
condition|)
name|args
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|argv
index|[
name|arg_index
operator|++
index|]
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|remember_args
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|with_input_from_string
argument_list|(
name|local_pending_command
argument_list|,
literal|"-c"
argument_list|)
expr_stmt|;
goto|goto
name|read_and_execute
goto|;
block|}
block|}
comment|/* Do the things that should be done only for interactive shells. */
if|if
condition|(
name|interactive_shell
condition|)
block|{
comment|/* Set up for checking for presence of mail. */
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
comment|/* Under System V, we can only tell if you have mail if the 	 modification date has changed.  So remember the current 	 modification dates. */
name|remember_mail_dates
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* Under 4.x, you have mail if there is something in your inbox. 	 I set the remembered mail dates to 1900.  */
name|reset_mail_files
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
comment|/* If this was a login shell, then assume that /bin/login has already 	 taken care of informing the user that they have new mail.  Otherwise, 	 we want to check right away. */
if|if
condition|(
name|login_shell
operator|==
literal|1
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
name|remember_mail_dates
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|reset_mail_timer
argument_list|()
expr_stmt|;
name|change_flag_char
argument_list|(
literal|'i'
argument_list|,
name|FLAG_ON
argument_list|)
expr_stmt|;
comment|/* Initialize the interactive history stuff. */
if|if
condition|(
operator|!
name|shell_initialized
condition|)
name|load_history
argument_list|()
expr_stmt|;
comment|/* Initialize terminal state for interactive shells after the 	 .bash_profile and .bashrc are interpreted. */
name|get_tty_state
argument_list|()
expr_stmt|;
block|}
comment|/* Get possible input filename. */
if|if
condition|(
operator|(
name|arg_index
operator|!=
name|argc
operator|)
operator|&&
operator|!
name|read_from_stdin
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
specifier|extern
name|char
modifier|*
name|find_path_file
parameter_list|()
function_decl|;
name|free
argument_list|(
name|dollar_vars
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dollar_vars
index|[
literal|0
index|]
operator|=
name|savestring
argument_list|(
name|argv
index|[
name|arg_index
index|]
argument_list|)
expr_stmt|;
name|filename
operator|=
name|savestring
argument_list|(
name|argv
index|[
name|arg_index
index|]
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|char
modifier|*
name|path_filename
decl_stmt|;
comment|/* If it's not in the current directory, try looking through PATH 	     for it. */
name|path_filename
operator|=
name|find_path_file
argument_list|(
name|argv
index|[
name|arg_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_filename
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|path_filename
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
block|}
name|arg_index
operator|++
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|file_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Only do this with file descriptors we can seek on. */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|char
name|sample
index|[
literal|80
index|]
decl_stmt|;
name|int
name|sample_len
decl_stmt|;
comment|/* Check to see if the `file' in `bash file' is a binary file 	     according to the same tests done by execute_simple_command (), 	     and report an error and exit if it is. */
name|sample_len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|sample
argument_list|,
sizeof|sizeof
argument_list|(
name|sample
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sample_len
operator|>
literal|0
condition|)
if|if
condition|(
name|check_binary_file
argument_list|(
name|sample
argument_list|,
name|sample_len
argument_list|)
condition|)
block|{
name|report_error
argument_list|(
literal|"%s: cannot execute binary file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BINARY_FILE
argument_list|)
expr_stmt|;
block|}
comment|/* Now rewind the file back to the beginning. */
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|default_input
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|default_input
condition|)
block|{
name|file_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|SET_CLOSE_ON_EXEC
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|default_input
argument_list|)
operator|!=
name|fd
condition|)
name|SET_CLOSE_ON_EXEC
argument_list|(
name|fileno
argument_list|(
name|default_input
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interactive_shell
operator|||
operator|(
operator|!
name|isatty
argument_list|(
name|fd
argument_list|)
operator|)
condition|)
block|{
name|history_expansion
operator|=
literal|0
expr_stmt|;
name|remember_on_history
operator|=
literal|0
expr_stmt|;
name|interactive
operator|=
name|interactive_shell
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|set_job_control
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
block|}
else|else
block|{
comment|/* I don't believe that this code is ever executed, even in 	     the presence of /dev/fd. */
name|dup2
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|default_input
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bind remaining args to $1 ... $n */
block|{
name|WORD_LIST
modifier|*
name|args
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|arg_index
operator|!=
name|argc
condition|)
name|args
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|argv
index|[
name|arg_index
operator|++
index|]
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|remember_args
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
name|unset_nodelay_mode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* with_input_from_stdin really means `with_input_from_readline' */
if|if
condition|(
name|interactive
operator|&&
operator|!
name|no_line_editing
condition|)
name|with_input_from_stdin
argument_list|()
expr_stmt|;
else|else
name|with_input_from_stream
argument_list|(
name|default_input
argument_list|,
name|dollar_vars
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read_and_execute
label|:
name|shell_initialized
operator|=
literal|1
expr_stmt|;
comment|/* Read commands until exit condition. */
name|reader_loop
argument_list|()
expr_stmt|;
name|exit_shell
label|:
comment|/* Do trap[0] if defined. */
name|run_exit_trap
argument_list|()
expr_stmt|;
name|maybe_save_shell_history
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
comment|/* If this shell is interactive, terminate all stopped jobs and      restore the original terminal process group. */
if|if
condition|(
name|interactive_shell
condition|)
block|{
name|terminate_stopped_jobs
argument_list|()
expr_stmt|;
if|if
condition|(
name|original_pgrp
operator|>=
literal|0
condition|)
name|give_terminal_to
argument_list|(
name|original_pgrp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* JOB_CONTROL */
comment|/* Always return the exit status of the last command to our parent. */
name|exit
argument_list|(
name|last_command_exit_value
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If this is an interactive shell, then append the lines executed    this session to the history file. */
end_comment

begin_function
name|int
name|maybe_save_shell_history
parameter_list|()
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|interactive
operator|&&
name|history_lines_this_session
condition|)
block|{
name|void
name|using_history
parameter_list|()
function_decl|;
name|char
modifier|*
name|hf
init|=
name|get_string_value
argument_list|(
literal|"HISTFILE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hf
operator|&&
operator|*
name|hf
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
comment|/* If the file doesn't exist, then create it. */
if|if
condition|(
name|stat
argument_list|(
name|hf
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|file
init|=
name|open
argument_list|(
name|hf
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Now actually append the lines if the history hasn't been 	     stifled. */
name|using_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|history_lines_this_session
operator|<=
name|where_history
argument_list|()
condition|)
block|{
name|result
operator|=
name|append_history
argument_list|(
name|history_lines_this_session
argument_list|,
name|hf
argument_list|)
expr_stmt|;
name|history_lines_in_file
operator|+=
name|history_lines_this_session
expr_stmt|;
name|history_lines_this_session
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Try to execute the contents of FNAME.  If FNAME doesn't exist,    that is not an error, but other kinds of errors are.  Returns    -1 in the case of an error, 0 in the case that the file was not    found, and 1 if the file was found and executed. */
end_comment

begin_macro
name|maybe_execute_file
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|tilde_expand
parameter_list|()
function_decl|;
specifier|extern
name|int
name|return_catch_flag
decl_stmt|;
specifier|extern
name|jmp_buf
name|return_catch
decl_stmt|;
name|jmp_buf
name|old_return_catch
decl_stmt|;
name|int
name|return_val
decl_stmt|,
name|fd
decl_stmt|,
name|tresult
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|struct
name|stat
name|file_info
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|file_error_and_exit
label|:
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|file_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|errno
operator|==
name|ENOENT
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|file_info
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|file_error_and_exit
goto|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|file_info
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|string
argument_list|,
name|file_info
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|{
name|int
name|tt
init|=
name|errno
decl_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tt
expr_stmt|;
block|}
if|if
condition|(
name|tresult
operator|!=
name|file_info
operator|.
name|st_size
condition|)
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
goto|goto
name|file_error_and_exit
goto|;
block|}
name|string
index|[
name|file_info
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|return_catch_flag
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|return_catch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|old_return_catch
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|return_val
operator|=
name|setjmp
argument_list|(
name|return_catch
argument_list|)
expr_stmt|;
comment|/* If `return' was seen outside of a function, but in the script, then      force parse_and_execute () to clean up. */
if|if
condition|(
name|return_val
condition|)
name|parse_and_execute_cleanup
argument_list|()
expr_stmt|;
else|else
name|tresult
operator|=
name|parse_and_execute
argument_list|(
name|string
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|return_catch_flag
operator|--
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old_return_catch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|return_catch
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|reader_loop
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|indirection_level
decl_stmt|;
name|int
name|our_indirection_level
decl_stmt|;
name|COMMAND
modifier|*
name|current_command
init|=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
decl_stmt|;
name|our_indirection_level
operator|=
operator|++
name|indirection_level
expr_stmt|;
while|while
condition|(
operator|!
name|EOF_Reached
condition|)
block|{
specifier|extern
name|char
modifier|*
name|trap_list
index|[]
decl_stmt|;
name|sighandler
name|sigint_sighandler
parameter_list|()
function_decl|;
name|int
name|code
decl_stmt|;
name|code
operator|=
name|setjmp
argument_list|(
name|top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive_shell
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
comment|/* If we are running on a posix-compliant system, then do 	     things the Posix way. */
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|sigint_sighandler
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_POSIX_VERSION */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint_sighandler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !_POSIX_VERSION */
block|}
if|if
condition|(
name|code
operator|!=
name|NOT_JUMPED
condition|)
block|{
name|indirection_level
operator|=
name|our_indirection_level
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Some kind of throw to top_level has occured. */
case|case
name|FORCE_EOF
case|:
case|case
name|EXITPROG
case|:
name|current_command
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
expr_stmt|;
name|EOF_Reached
operator|=
name|EOF
expr_stmt|;
goto|goto
name|exec_done
goto|;
case|case
name|DISCARD
case|:
comment|/* Obstack free command elements, etc. */
break|break;
default|default:
name|programming_error
argument_list|(
literal|"Bad jump %d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
name|executing
operator|=
literal|0
expr_stmt|;
name|dispose_used_env_vars
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|Ultrix
argument_list|)
operator|&&
name|defined
argument_list|(
name|mips
argument_list|)
operator|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_ALLOCA
argument_list|)
comment|/* Attempt to reclaim memory allocated with alloca (). */
operator|(
name|void
operator|)
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|read_command
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|global_command
condition|)
block|{
name|current_command
operator|=
name|global_command
expr_stmt|;
name|current_command_number
operator|++
expr_stmt|;
comment|/* POSIX spec: "-n: The shell reads commands but does 		 not execute them; this can be used to check for shell 		 script syntax errors.  The shell ignores the -n option 		 for interactive shells. " */
if|if
condition|(
name|interactive_shell
operator|||
operator|!
name|read_but_dont_execute
condition|)
block|{
name|executing
operator|=
literal|1
expr_stmt|;
name|execute_command
argument_list|(
name|current_command
argument_list|)
expr_stmt|;
block|}
name|exec_done
label|:
if|if
condition|(
name|current_command
condition|)
name|dispose_command
argument_list|(
name|current_command
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Parse error, maybe discard rest of stream if not interactive. */
if|if
condition|(
operator|!
name|interactive
condition|)
name|EOF_Reached
operator|=
name|EOF
expr_stmt|;
block|}
if|if
condition|(
name|just_one_command
condition|)
name|EOF_Reached
operator|=
name|EOF
expr_stmt|;
block|}
name|indirection_level
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a string denoting what our indirection level is. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|indirection_string
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|indirection_level_string
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|get_string_value
argument_list|()
decl_stmt|,
modifier|*
name|ps4
init|=
name|get_string_value
argument_list|(
literal|"PS4"
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|decode_prompt_string
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|ps4
condition|)
name|ps4
operator|=
name|savestring
argument_list|(
literal|"+ "
argument_list|)
expr_stmt|;
else|else
name|ps4
operator|=
name|decode_prompt_string
argument_list|(
name|ps4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indirection_level
operator|&&
name|i
operator|<
literal|99
condition|;
name|i
operator|++
control|)
name|indirection_string
index|[
name|i
index|]
operator|=
operator|*
name|ps4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|ps4
index|[
name|j
index|]
operator|&&
name|i
operator|<
literal|99
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|indirection_string
index|[
name|i
index|]
operator|=
name|ps4
index|[
name|j
index|]
expr_stmt|;
name|indirection_string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|ps4
argument_list|)
expr_stmt|;
return|return
operator|(
name|indirection_string
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|sighandler
name|alrm_catcher
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%ctimed out waiting for input: auto-logout\n"
argument_list|,
literal|'\07'
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|EXITPROG
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VOID_SIGHANDLER
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* !VOID_SIGHANDLER */
block|}
end_function

begin_macro
name|parse_command
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|need_here_doc
decl_stmt|,
name|current_command_line_count
decl_stmt|;
specifier|extern
name|REDIRECT
modifier|*
name|redirection_needing_here_doc
decl_stmt|;
name|int
name|r
decl_stmt|;
name|need_here_doc
operator|=
literal|0
expr_stmt|;
name|redirection_needing_here_doc
operator|=
operator|(
name|REDIRECT
operator|*
operator|)
name|NULL
expr_stmt|;
name|run_pending_traps
argument_list|()
expr_stmt|;
name|current_command_line_count
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_here_doc
condition|)
name|make_here_document
argument_list|(
name|redirection_needing_here_doc
argument_list|)
expr_stmt|;
name|need_here_doc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_block

begin_macro
name|read_command
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|ps1_prompt
decl_stmt|,
modifier|*
modifier|*
name|prompt_string_pointer
decl_stmt|;
specifier|extern
name|int
name|current_command_line_count
decl_stmt|;
name|SHELL_VAR
modifier|*
name|tmout_var
init|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|tmout_len
init|=
literal|0
decl_stmt|,
name|result
decl_stmt|;
name|SigHandler
modifier|*
name|old_alrm
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|NULL
decl_stmt|;
name|prompt_string_pointer
operator|=
operator|&
name|ps1_prompt
expr_stmt|;
name|global_command
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Only do timeouts if interactive. */
if|if
condition|(
name|interactive
condition|)
block|{
name|tmout_var
operator|=
name|find_variable
argument_list|(
literal|"TMOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmout_var
operator|&&
name|tmout_var
operator|->
name|value
condition|)
block|{
name|tmout_len
operator|=
name|atoi
argument_list|(
name|tmout_var
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmout_len
operator|>
literal|0
condition|)
block|{
name|old_alrm
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alrm_catcher
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|tmout_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|QUIT
expr_stmt|;
name|current_command_line_count
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|parse_command
argument_list|()
expr_stmt|;
if|if
condition|(
name|interactive
operator|&&
name|tmout_var
operator|&&
operator|(
name|tmout_len
operator|>
literal|0
operator|)
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|old_alrm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Do whatever is necessary to initialize the shell.    Put new initializations in here. */
end_comment

begin_macro
name|shell_initialize
argument_list|()
end_macro

begin_block
block|{
comment|/* Line buffer output for stderr.      If your machine doesn't have either of setlinebuf or setvbuf,      you can just comment out the buffering commands, and the shell      will still work.  It will take more cycles, though. */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLINEBUF
argument_list|)
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|_IOLBF
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|REVERSED_SETVBUF_ARGS
argument_list|)
name|setvbuf
argument_list|(
name|stderr
argument_list|,
name|_IOLBF
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|_IOLBF
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setvbuf
argument_list|(
name|stderr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !REVERSED_SETVBUF_ARGS */
endif|#
directive|endif
comment|/* _IOLBF */
endif|#
directive|endif
comment|/* HAVE_SETLINEBUF */
comment|/* Sort the array of shell builtins so that the binary search in      find_shell_builtin () works correctly. */
name|initialize_shell_builtins
argument_list|()
expr_stmt|;
comment|/* Initialize the trap signal handlers before installing our own      signal handlers.  traps.c:restore_default_signal () is responsible      for restoring the original default signal handler.  That function      is called from jobs.c when we make a new child. */
name|initialize_traps
argument_list|()
expr_stmt|;
name|initialize_signals
argument_list|()
expr_stmt|;
comment|/* Initialize current_user_name and current_host_name. */
block|{
name|struct
name|passwd
modifier|*
name|entry
init|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
decl_stmt|;
name|char
name|hostname
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
literal|255
argument_list|)
operator|<
literal|0
condition|)
name|current_host_name
operator|=
literal|"??host??"
expr_stmt|;
else|else
name|current_host_name
operator|=
name|savestring
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|current_user_name
operator|=
name|savestring
argument_list|(
name|entry
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
name|current_user_name
operator|=
name|savestring
argument_list|(
literal|"I have no name!"
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
block|}
comment|/* Initialize our interface to the tilde expander. */
name|tilde_initialize
argument_list|()
expr_stmt|;
comment|/* Initialize internal and environment variables. */
name|initialize_shell_variables
argument_list|(
name|shell_environment
argument_list|)
expr_stmt|;
comment|/* Initialize filename hash tables. */
name|initialize_filename_hashing
argument_list|()
expr_stmt|;
comment|/* Initialize the data structures for storing and running jobs. */
name|initialize_jobs
argument_list|()
expr_stmt|;
comment|/* Initialize input streams to null. */
name|initialize_bash_input
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Function called by main () when it appears that the shell has already    had some initialization preformed.  This is supposed to reset the world    back to a pristine state, as if we had been exec'ed. */
end_comment

begin_macro
name|shell_reinitialize
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|line_number
decl_stmt|,
name|last_command_exit_value
decl_stmt|;
comment|/* The default shell prompts. */
name|primary_prompt
operator|=
name|PPROMPT
expr_stmt|;
name|secondary_prompt
operator|=
name|SPROMPT
expr_stmt|;
comment|/* Things that get 1. */
name|current_command_number
operator|=
literal|1
expr_stmt|;
comment|/* We have decided that the ~/.bashrc file should not be executed      for the invocation of each shell script.  Perhaps some other file      should.  */
name|act_like_sh
operator|=
literal|1
expr_stmt|;
comment|/* Things that get 0. */
name|login_shell
operator|=
name|make_login_shell
operator|=
name|interactive
operator|=
name|restricted
operator|=
name|executing
operator|=
literal|0
expr_stmt|;
name|debugging
operator|=
name|no_rc
operator|=
name|no_profile
operator|=
name|do_version
operator|=
name|line_number
operator|=
literal|0
expr_stmt|;
name|last_command_exit_value
operator|=
name|remember_on_history
operator|=
literal|0
expr_stmt|;
name|forced_interactive
operator|=
name|interactive_shell
operator|=
literal|0
expr_stmt|;
comment|/* Ensure that the default startup file is used.  (Except that we don't      execute this file for reinitialized shells). */
name|bashrc_file
operator|=
literal|"~/.bashrc"
expr_stmt|;
comment|/* Delete all variables and functions.  They will be reinitialized when      the environment is parsed. */
name|delete_all_variables
argument_list|(
name|shell_variables
argument_list|)
expr_stmt|;
name|delete_all_variables
argument_list|(
name|shell_functions
argument_list|)
expr_stmt|;
comment|/* Pretend the PATH variable has changed. */
name|sv_path
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|initialize_signals
argument_list|()
end_macro

begin_block
block|{
name|initialize_terminating_signals
argument_list|()
expr_stmt|;
name|initialize_job_signals
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INITIALIZE_SIGLIST
argument_list|)
name|initialize_siglist
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* The list of signals that would terminate the shell if not caught.    We catch them, but just so that we can write the history file,    and so forth. */
end_comment

begin_decl_stmt
name|int
name|terminating_signals
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SIGHUP
name|SIGHUP
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
name|SIGINT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|SIGQUIT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGILL
name|SIGILL
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTRAP
name|SIGTRAP
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGIOT
name|SIGIOT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGDANGER
name|SIGDANGER
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGEMT
name|SIGEMT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGFPE
name|SIGFPE
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGKILL
name|SIGKILL
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGBUS
name|SIGBUS
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSEGV
name|SIGSEGV
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGSYS
name|SIGSYS
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|SIGPIPE
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGALRM
name|SIGALRM
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|SIGTERM
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
name|SIGXCPU
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|SIGXFSZ
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGVTALRM
name|SIGVTALRM
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPROF
name|SIGPROF
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGLOST
name|SIGLOST
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR1
name|SIGUSR1
block|,
name|SIGUSR2
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TERMSIGS_LENGTH
value|(sizeof (terminating_signals) / sizeof (int))
end_define

begin_comment
comment|/* This function belongs here? */
end_comment

begin_function
name|sighandler
name|termination_unwind_protect
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|sig
operator|==
name|SIGINT
condition|)
name|run_interrupt_trap
argument_list|()
expr_stmt|;
name|maybe_save_shell_history
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
if|if
condition|(
name|sig
operator|==
name|SIGHUP
condition|)
block|{
specifier|extern
name|void
name|hangup_all_jobs
parameter_list|()
function_decl|;
name|hangup_all_jobs
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* JOB_CONTROL */
name|run_exit_trap
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VOID_SIGHANDLER
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* VOID_SIGHANDLER */
block|}
end_function

begin_comment
comment|/* Initialize signals that will terminate the shell to do some    unwind protection. */
end_comment

begin_macro
name|initialize_terminating_signals
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
comment|/* If we're running on a Posix-compliant system, do things the Posix way. */
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|termination_unwind_protect
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TERMSIGS_LENGTH
condition|;
name|i
operator|++
control|)
name|sigaddset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|,
name|terminating_signals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TERMSIGS_LENGTH
condition|;
name|i
operator|++
control|)
name|sigaction
argument_list|(
name|terminating_signals
index|[
name|i
index|]
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* For interactive login shells, use an empty signal mask.  Other      shells use what they have been given. */
name|sigemptyset
argument_list|(
operator|&
name|top_level_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|login_shell
condition|)
block|{
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|top_level_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|top_level_mask
argument_list|)
expr_stmt|;
name|sigdelset
argument_list|(
operator|&
name|top_level_mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !_POSIX_VERSION */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TERMSIGS_LENGTH
condition|;
name|i
operator|++
control|)
name|signal
argument_list|(
name|terminating_signals
index|[
name|i
index|]
argument_list|,
name|termination_unwind_protect
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !_POSIX_VERSION */
comment|/* And, some signals that are specifically ignored by the shell. */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What to do when we've been interrupted, and it is safe to handle it. */
end_comment

begin_function
name|void
name|throw_to_top_level
parameter_list|()
block|{
specifier|extern
name|int
name|last_command_exit_value
decl_stmt|,
name|loop_level
decl_stmt|,
name|continuing
decl_stmt|,
name|breaking
decl_stmt|;
specifier|extern
name|int
name|return_catch_flag
decl_stmt|;
specifier|extern
name|int
name|parse_and_execute_level
decl_stmt|;
name|int
name|print_newline
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|interrupt_state
condition|)
block|{
name|print_newline
operator|=
literal|1
expr_stmt|;
name|interrupt_state
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|interrupt_state
condition|)
return|return;
comment|/* Run any traps set on SIGINT. */
name|run_interrupt_trap
argument_list|()
expr_stmt|;
comment|/* Cleanup string parser environment. */
while|while
condition|(
name|parse_and_execute_level
condition|)
name|parse_and_execute_cleanup
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|give_terminal_to
argument_list|(
name|shell_pgrp
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|top_level_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
name|reset_parser
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|READLINE
argument_list|)
if|if
condition|(
name|interactive
condition|)
name|bashline_reinitialize
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* READLINE */
name|run_unwind_protects
argument_list|()
expr_stmt|;
name|loop_level
operator|=
name|continuing
operator|=
name|breaking
operator|=
literal|0
expr_stmt|;
name|return_catch_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|interactive
operator|&&
name|print_newline
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|last_command_exit_value
operator||=
literal|128
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
else|else
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|EXITPROG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When non-zero, we throw_to_top_level (). */
end_comment

begin_decl_stmt
name|int
name|interrupt_immediately
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we really do when SIGINT occurs. */
end_comment

begin_function
name|sighandler
name|sigint_sighandler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
name|signal
argument_list|(
name|sig
argument_list|,
name|sigint_sighandler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* interrupt_state needs to be set for the stack of interrupts to work      right.  Should it be set unconditionally? */
if|if
condition|(
operator|!
name|interrupt_state
condition|)
name|interrupt_state
operator|++
expr_stmt|;
if|if
condition|(
name|interrupt_immediately
condition|)
block|{
name|interrupt_immediately
operator|=
literal|0
expr_stmt|;
name|throw_to_top_level
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VOID_SIGHANDLER
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* VOID_SIGHANDLER */
block|}
end_function

begin_comment
comment|/* Load the history list from the history file. */
end_comment

begin_macro
name|load_history
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|hf
decl_stmt|;
comment|/* Truncate history file for interactive shells which desire it.      Note that the history file is automatically truncated to the      size of HISTSIZE if the user does not explicitly set the size      differently. */
name|set_if_not
argument_list|(
literal|"HISTFILESIZE"
argument_list|,
name|get_string_value
argument_list|(
literal|"HISTSIZE"
argument_list|)
argument_list|)
expr_stmt|;
name|stupidly_hack_special_variables
argument_list|(
literal|"HISTFILESIZE"
argument_list|)
expr_stmt|;
comment|/* Read the history in HISTFILE into the history list. */
name|hf
operator|=
name|get_string_value
argument_list|(
literal|"HISTFILE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hf
operator|&&
operator|*
name|hf
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|hf
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_history
argument_list|(
name|hf
argument_list|)
expr_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|history_lines_in_file
operator|=
name|where_history
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Write the existing history out to the history file. */
end_comment

begin_macro
name|save_history
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|hf
init|=
name|get_string_value
argument_list|(
literal|"HISTFILE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hf
operator|&&
operator|*
name|hf
condition|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|hf
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Append only the lines that occurred this session to 	     the history file. */
name|using_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|history_lines_this_session
operator|<
name|where_history
argument_list|()
condition|)
name|append_history
argument_list|(
name|history_lines_this_session
argument_list|,
name|hf
argument_list|)
expr_stmt|;
else|else
name|write_history
argument_list|(
name|hf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAKE_BUG_REPORTS
argument_list|)
end_if

begin_comment
comment|/* Make a bug report, even to the extent of mailing it.  Hope that it    gets where it is supposed to go.  If not, maybe the user will send    it back to me. */
end_comment

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_comment
comment|/* Number of commands to place in the bug report. */
end_comment

begin_define
define|#
directive|define
name|LAST_INTERESTING_HISTORY_COUNT
value|6
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
end_if

begin_macro
name|make_bug_report
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_function
name|va_dcl
else|#
directive|else
name|make_bug_report
parameter_list|(
name|reason
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|reason
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_VFPRINTF */
block|{
specifier|extern
name|char
modifier|*
name|current_host_name
decl_stmt|,
modifier|*
name|current_user_name
decl_stmt|,
modifier|*
name|the_current_maintainer
decl_stmt|;
specifier|extern
name|int
name|interactive
decl_stmt|,
name|login_shell
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|where_history
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|len
operator|-
name|LAST_INTERESTING_HISTORY_COUNT
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|HIST_ENTRY
modifier|*
modifier|*
name|list
init|=
name|history_list
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
name|char
modifier|*
name|reason
decl_stmt|;
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_VFPRINTF */
name|stream
operator|=
name|popen
argument_list|(
literal|"/bin/rmail bash-maintainers@ai.mit.edu"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|save_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"To: bash-maintainers@ai.mit.edu\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"Subject: Bash-%s.%d bug-report: "
argument_list|,
name|dist_version
argument_list|,
name|build_version
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|reason
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stream
argument_list|,
name|reason
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stream
argument_list|,
name|reason
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_VFPRINTF */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Write the history into the mail file.  Maybe we can recreate 	 the bug? */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"This is a Bash bug report.  Bash maintainers should be getting this report.\n\ If this mail has bounced, for right now please send it to:\n\ \n\ 	%s\n\ \n\ since he is the current maintainer of this version of the shell.\n\ \n\ This is %s (invoked as `%s'), version %s.%d, on host %s, used by %s.\n\ This shell is %sinteractive, and it is %sa login shell.\n\ \n\ The host is a %s running %s.\n\ \n\ The current environment is:\n"
argument_list|,
name|the_current_maintainer
argument_list|,
name|get_string_value
argument_list|(
literal|"BASH"
argument_list|)
argument_list|,
name|full_pathname
argument_list|(
name|dollar_vars
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|dist_version
argument_list|,
name|build_version
argument_list|,
name|current_host_name
argument_list|,
name|current_user_name
argument_list|,
name|interactive
condition|?
literal|""
else|:
literal|"not "
argument_list|,
name|login_shell
condition|?
literal|""
else|:
literal|"not "
argument_list|,
name|SYSTEM_NAME
argument_list|,
name|OS_NAME
argument_list|)
expr_stmt|;
block|{
name|SHELL_VAR
modifier|*
modifier|*
name|vlist
decl_stmt|,
modifier|*
name|var
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|vlist
operator|=
name|all_shell_variables
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vlist
operator|&&
name|var
operator|=
name|vlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|invisible_p
argument_list|(
name|var
argument_list|)
operator|&&
name|exported_p
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s=%s"
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|value_cell
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nAnd here are the last %d commands.\n\n"
argument_list|,
name|LAST_INTERESTING_HISTORY_COUNT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
name|list
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't mail bug report!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKE_BUG_REPORTS */
end_comment

begin_comment
comment|/* Give version information about this shell. */
end_comment

begin_macro
name|show_shell_version
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|base_pathname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|shell_name
decl_stmt|;
specifier|extern
name|int
name|version
decl_stmt|;
name|printf
argument_list|(
literal|"GNU %s, version %s.%d\n"
argument_list|,
name|base_pathname
argument_list|(
name|shell_name
argument_list|)
argument_list|,
name|dist_version
argument_list|,
name|build_version
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

