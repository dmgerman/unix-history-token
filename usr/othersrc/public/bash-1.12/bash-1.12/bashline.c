begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bashline.c -- Bash's interface to the readline library. */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     Bash is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with Bash; see the file COPYING.  If not, write to the Free    Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_comment
comment|/* Functions bound to keys in Readline for Bash users. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|shell_expand_line
argument_list|()
decl_stmt|,
name|insert_last_arg
argument_list|()
decl_stmt|,
name|display_shell_version
argument_list|()
decl_stmt|,
name|operate_and_get_next
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper functions for Readline. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|bash_symbolic_link_hook
argument_list|()
decl_stmt|,
name|filename_completion_ignore
argument_list|()
decl_stmt|,
name|bash_push_line
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|attempt_shell_completion
argument_list|()
decl_stmt|,
modifier|*
name|variable_completion_function
argument_list|()
decl_stmt|,
modifier|*
name|hostname_completion_function
argument_list|()
decl_stmt|,
modifier|*
name|command_word_completion_function
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|snarf_hosts_from_file
argument_list|()
decl_stmt|,
name|add_host_name
argument_list|()
decl_stmt|,
name|sort_hostname_list
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Externally defined functions used by this file. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|get_string_value
argument_list|()
decl_stmt|,
modifier|*
name|filename_completion_function
argument_list|()
decl_stmt|,
modifier|*
name|username_completion_function
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|show_shell_version
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DYNAMIC_HISTORY_COMPLETION
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DYNAMIC_HISTORY_COMPLETION
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|dynamic_complete_history
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC_HISTORY_COMPLETION */
end_comment

begin_comment
comment|/* SPECIFIC_COMPLETION_FUNCTIONS specifies that we have individual    completion functions which indicate what type of completion should be    done (at or before point) that can be bound to key sequences with    the readline library. */
end_comment

begin_define
define|#
directive|define
name|SPECIFIC_COMPLETION_FUNCTIONS
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SPECIFIC_COMPLETION_FUNCTIONS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|bash_specific_completion
argument_list|()
decl_stmt|,
name|bash_complete_filename
argument_list|()
decl_stmt|,
name|bash_possible_filename_completions
argument_list|()
decl_stmt|,
name|bash_complete_filename_internal
argument_list|()
decl_stmt|,
name|bash_complete_username
argument_list|()
decl_stmt|,
name|bash_possible_username_completions
argument_list|()
decl_stmt|,
name|bash_complete_username_internal
argument_list|()
decl_stmt|,
name|bash_complete_hostname
argument_list|()
decl_stmt|,
name|bash_possible_hostname_completions
argument_list|()
decl_stmt|,
name|bash_complete_hostname_internal
argument_list|()
decl_stmt|,
name|bash_complete_variable
argument_list|()
decl_stmt|,
name|bash_possible_variable_completions
argument_list|()
decl_stmt|,
name|bash_complete_variable_internal
argument_list|()
decl_stmt|,
name|bash_complete_command
argument_list|()
decl_stmt|,
name|bash_possible_command_completions
argument_list|()
decl_stmt|,
name|bash_complete_command_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SPECIFIC_COMPLETION_FUNCTIONS */
end_comment

begin_comment
comment|/* Non-zero once initalize_readline () has been called. */
end_comment

begin_decl_stmt
name|int
name|bash_readline_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called once from parse.y if we are going to use readline. */
end_comment

begin_macro
name|initialize_readline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|bash_readline_initialized
condition|)
return|return;
name|rl_terminal_name
operator|=
name|get_string_value
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
name|rl_instream
operator|=
name|stdin
operator|,
name|rl_outstream
operator|=
name|stderr
expr_stmt|;
name|rl_special_prefixes
operator|=
literal|"$@%"
expr_stmt|;
comment|/* Allow conditional parsing of the ~/.inputrc file. */
name|rl_readline_name
operator|=
literal|"Bash"
expr_stmt|;
comment|/* Bind up our special shell functions. */
name|rl_add_defun
argument_list|(
literal|"shell-expand-line"
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|shell_expand_line
argument_list|,
name|META
argument_list|(
name|CTRL
argument_list|(
literal|'E'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"insert-last-argument"
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|insert_last_arg
argument_list|,
name|META
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
name|rl_bind_key
argument_list|(
name|META
argument_list|(
literal|'_'
argument_list|)
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|insert_last_arg
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"operate-and-get-next"
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|operate_and_get_next
argument_list|,
name|CTRL
argument_list|(
literal|'O'
argument_list|)
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"display-shell-version"
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|display_shell_version
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
name|CTRL
argument_list|(
literal|'V'
argument_list|)
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|display_shell_version
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
comment|/* In Bash, the user can switch editing modes with "set -o [vi emacs]",      so it is not necessary to allow C-M-j for context switching.  Turn      off this occasionally confusing behaviour. */
name|rl_unbind_key_in_map
argument_list|(
name|CTRL
argument_list|(
literal|'J'
argument_list|)
argument_list|,
name|emacs_meta_keymap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPECIFIC_COMPLETION_FUNCTIONS
name|rl_add_defun
argument_list|(
literal|"complete-filename"
argument_list|,
name|bash_complete_filename
argument_list|,
name|META
argument_list|(
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"possible-filename-completions"
argument_list|,
name|bash_possible_filename_completions
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'/'
argument_list|,
name|bash_possible_filename_completions
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"complete-username"
argument_list|,
name|bash_complete_username
argument_list|,
name|META
argument_list|(
literal|'~'
argument_list|)
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"possible-username-completions"
argument_list|,
name|bash_possible_username_completions
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'~'
argument_list|,
name|bash_possible_username_completions
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"complete-hostname"
argument_list|,
name|bash_complete_hostname
argument_list|,
name|META
argument_list|(
literal|'@'
argument_list|)
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"possible-hostname-completions"
argument_list|,
name|bash_possible_hostname_completions
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'@'
argument_list|,
name|bash_possible_hostname_completions
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"complete-variable"
argument_list|,
name|bash_complete_variable
argument_list|,
name|META
argument_list|(
literal|'$'
argument_list|)
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"possible-variable-completions"
argument_list|,
name|bash_possible_variable_completions
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'$'
argument_list|,
name|bash_possible_variable_completions
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"complete-command"
argument_list|,
name|bash_complete_command
argument_list|,
name|META
argument_list|(
literal|'!'
argument_list|)
argument_list|)
expr_stmt|;
name|rl_add_defun
argument_list|(
literal|"possible-command-completions"
argument_list|,
name|bash_possible_command_completions
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rl_bind_key_in_map
argument_list|(
literal|'!'
argument_list|,
name|bash_possible_command_completions
argument_list|,
name|emacs_ctlx_keymap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SPECIFIC_COMPLETION_FUNCTIONS */
if|#
directive|if
name|defined
argument_list|(
name|DYNAMIC_HISTORY_COMPLETION
argument_list|)
name|rl_add_defun
argument_list|(
literal|"dynamic-complete-history"
argument_list|,
name|dynamic_complete_history
argument_list|,
name|META
argument_list|(
name|TAB
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC_HISTORY_COMPLETION */
comment|/* Tell the completer that we want a crack first. */
name|rl_attempted_completion_function
operator|=
operator|(
name|Function
operator|*
operator|)
name|attempt_shell_completion
expr_stmt|;
comment|/* Tell the completer that we might want to follow symbolic links. */
name|rl_symbolic_link_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|bash_symbolic_link_hook
expr_stmt|;
comment|/* Tell the filename completer we want a chance to ignore some names. */
name|rl_ignore_some_completions_function
operator|=
operator|(
name|Function
operator|*
operator|)
name|filename_completion_ignore
expr_stmt|;
name|bash_readline_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* On Sun systems at least, rl_attempted_completion_function can end up    getting set to NULL, and rl_completion_entry_function set to do command    word completion if Bash is interrupted while trying to complete a command    word.  This just resets all the completion functions to the right thing.    It's called from throw_to_top_level(). */
end_comment

begin_macro
name|bashline_reinitialize
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|void
name|tilde_initialize
parameter_list|()
function_decl|;
name|tilde_initialize
argument_list|()
expr_stmt|;
name|rl_attempted_completion_function
operator|=
operator|(
name|Function
operator|*
operator|)
name|attempt_shell_completion
expr_stmt|;
name|rl_symbolic_link_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|bash_symbolic_link_hook
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Contains the line to push into readline. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|push_to_readline
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push the contents of push_to_readline into the    readline buffer. */
end_comment

begin_function
specifier|static
name|void
name|bash_push_line
parameter_list|()
block|{
if|if
condition|(
name|push_to_readline
condition|)
block|{
name|rl_insert_text
argument_list|(
name|push_to_readline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|push_to_readline
argument_list|)
expr_stmt|;
name|push_to_readline
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call this to set the initial text for the next line to read    from readline. */
end_comment

begin_function
name|int
name|bash_re_edit
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
if|if
condition|(
name|push_to_readline
condition|)
name|free
argument_list|(
name|push_to_readline
argument_list|)
expr_stmt|;
name|push_to_readline
operator|=
name|savestring
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|rl_startup_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|bash_push_line
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_shell_version
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|crlf
argument_list|()
expr_stmt|;
name|show_shell_version
argument_list|()
expr_stmt|;
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			     Readline Stuff			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* If the user requests hostname completion, then simply build a list    of hosts, and complete from that forever more. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ETCHOSTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|ETCHOSTS
value|"/etc/hosts"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The kept list of hostnames. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|hostname_list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The physical size of the above list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hostname_list_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The length of the above list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hostname_list_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether or not HOSTNAME_LIST has been initialized. */
end_comment

begin_decl_stmt
name|int
name|hostname_list_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that HOSTNAME_LIST needs to be sorted. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hostname_list_needs_sorting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the hostname completion table. */
end_comment

begin_function
specifier|static
name|void
name|initialize_hostname_list
parameter_list|()
block|{
name|char
modifier|*
name|temp
init|=
name|get_string_value
argument_list|(
literal|"hostname_completion_file"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|temp
operator|=
name|ETCHOSTS
expr_stmt|;
name|snarf_hosts_from_file
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|sort_hostname_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|hostname_list
condition|)
name|hostname_list_initialized
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add NAME to the list of hosts. */
end_comment

begin_function
specifier|static
name|void
name|add_host_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|hostname_list_length
operator|+
literal|2
operator|>
name|hostname_list_size
condition|)
block|{
name|hostname_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|hostname_list
argument_list|,
operator|(
literal|1
operator|+
operator|(
name|hostname_list_size
operator|+=
literal|100
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hostname_list
index|[
name|hostname_list_length
index|]
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|hostname_list
index|[
operator|++
name|hostname_list_length
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|hostname_list_needs_sorting
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After you have added some names, you should sort the list of names. */
end_comment

begin_function
specifier|static
name|void
name|sort_hostname_list
parameter_list|()
block|{
if|if
condition|(
name|hostname_list_needs_sorting
operator|&&
name|hostname_list
condition|)
name|sort_char_array
argument_list|(
name|hostname_list
argument_list|)
expr_stmt|;
name|hostname_list_needs_sorting
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|cr_whitespace
parameter_list|(
name|c
parameter_list|)
value|((c) == '\r' || (c) == '\n' || whitespace(c))
end_define

begin_function
specifier|static
name|void
name|snarf_hosts_from_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
name|buffer
index|[
literal|256
index|]
decl_stmt|,
name|name
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return;
while|while
condition|(
name|temp
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
literal|255
argument_list|,
name|file
argument_list|)
condition|)
block|{
comment|/* Skip to first character. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buffer
index|[
name|i
index|]
operator|&&
name|cr_whitespace
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* If comment, ignore. */
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* If `preprocessor' directive, do the include. */
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
literal|"$include "
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|includefile
init|=
operator|&
name|buffer
index|[
name|i
operator|+
literal|9
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
comment|/* Find start of filename. */
while|while
condition|(
operator|*
name|includefile
operator|&&
name|whitespace
argument_list|(
operator|*
name|includefile
argument_list|)
condition|)
name|includefile
operator|++
expr_stmt|;
name|t
operator|=
name|includefile
expr_stmt|;
comment|/* Find end of filename. */
while|while
condition|(
operator|*
name|t
operator|&&
operator|!
name|cr_whitespace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|snarf_hosts_from_file
argument_list|(
name|includefile
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip internet address. */
for|for
control|(
init|;
name|buffer
index|[
name|i
index|]
operator|&&
operator|!
name|cr_whitespace
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Gobble up names.  Each name is separated with whitespace. */
while|while
condition|(
name|buffer
index|[
name|i
index|]
operator|&&
name|buffer
index|[
name|i
index|]
operator|!=
literal|'#'
condition|)
block|{
for|for
control|(
init|;
name|i
operator|&&
name|cr_whitespace
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'#'
condition|)
continue|continue;
for|for
control|(
name|start
operator|=
name|i
init|;
name|buffer
index|[
name|i
index|]
operator|&&
operator|!
name|cr_whitespace
argument_list|(
name|buffer
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|i
operator|-
name|start
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|strncpy
argument_list|(
name|name
argument_list|,
name|buffer
operator|+
name|start
argument_list|,
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|name
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add_host_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated list of hostnames which begin with TEXT.    Initialize the hostname list the first time if neccessary.    The array is malloc ()'ed, but not the individual strings. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|hostnames_matching
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
specifier|register
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
name|int
name|last_search
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|hostname_list_initialized
condition|)
block|{
name|initialize_hostname_list
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hostname_list_initialized
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|sort_hostname_list
argument_list|()
expr_stmt|;
comment|/* The list is sorted.  Do a binary search on it for the first character      in TEXT, and then grovel the names of interest. */
name|begin
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|hostname_list_length
expr_stmt|;
comment|/* Special case.  If TEXT consists of nothing, then the whole list is      what is desired. */
if|if
condition|(
operator|!
operator|*
name|text
condition|)
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|hostname_list_length
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hostname_list_length
condition|;
name|i
operator|++
control|)
name|result
index|[
name|i
index|]
operator|=
name|hostname_list
index|[
name|i
index|]
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* Scan until found, or failure. */
while|while
condition|(
name|end
operator|!=
name|begin
condition|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|i
operator|=
operator|(
operator|(
name|end
operator|-
name|begin
operator|)
operator|/
literal|2
operator|)
operator|+
name|begin
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|last_search
condition|)
break|break;
if|if
condition|(
name|hostname_list
index|[
name|i
index|]
operator|&&
operator|(
name|r
operator|=
name|strncmp
argument_list|(
name|hostname_list
index|[
name|i
index|]
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|strncmp
argument_list|(
name|hostname_list
index|[
name|i
index|]
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|i
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|hostname_list
index|[
name|i
index|]
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|begin
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|hostname_list
index|[
name|i
index|]
operator|&&
name|strncmp
argument_list|(
name|hostname_list
index|[
name|i
index|]
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|end
operator|=
name|i
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
operator|(
name|end
operator|-
name|begin
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
name|begin
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|result
index|[
name|i
index|]
operator|=
name|hostname_list
index|[
name|begin
operator|+
name|i
index|]
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|last_search
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|begin
operator|=
name|i
expr_stmt|;
else|else
name|end
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is a K*rn shell style insert-last-arg function.  The    difference is that Bash puts stuff into the history file before    expansion and file name generation, so we deal with exactly what the    user typed.  Those wanting the other behavior, at least for the last    arg, can use `$_'.  This also `knows' about how rl_yank_nth_arg treats    `$'. */
end_comment

begin_function
specifier|static
name|void
name|insert_last_arg
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|extern
name|int
name|rl_explicit_arg
decl_stmt|;
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_yank_nth_arg
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|rl_yank_nth_arg
argument_list|(
literal|'$'
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The equivalent of the K*rn shell C-o operate-and-get-next-history-line    editing command. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|saved_history_line_to_use
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_saved_history
parameter_list|()
block|{
name|HIST_ENTRY
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|saved_history_line_to_use
condition|)
block|{
if|if
condition|(
name|history_set_pos
argument_list|(
name|saved_history_line_to_use
argument_list|)
condition|)
block|{
name|h
operator|=
name|current_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|rl_insert_text
argument_list|(
name|h
operator|->
name|line
argument_list|)
expr_stmt|;
comment|/* 	       * Get rid of any undo list created by the previous insert, 	       * so the line won't totally be erased when the edits are 	       * undone (they will be normally, because this is a history 	       * line -- cf. readline.c: line 380 or so). 	       */
if|if
condition|(
name|rl_undo_list
condition|)
block|{
name|free_undo_list
argument_list|()
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
name|saved_history_line_to_use
operator|=
literal|0
expr_stmt|;
name|rl_startup_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|operate_and_get_next
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|where
decl_stmt|;
specifier|extern
name|int
name|history_stifled
decl_stmt|,
name|history_length
decl_stmt|,
name|max_input_history
decl_stmt|;
comment|/* Accept the current line. */
name|rl_newline
argument_list|()
expr_stmt|;
comment|/* Find the current line, and find the next line to use. */
name|where
operator|=
name|where_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|history_stifled
operator|&&
operator|(
name|history_length
operator|>=
name|max_input_history
operator|)
condition|)
name|saved_history_line_to_use
operator|=
name|where
expr_stmt|;
else|else
name|saved_history_line_to_use
operator|=
name|where
operator|+
literal|1
expr_stmt|;
name|rl_startup_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|set_saved_history
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			How To Do Shell Completion		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Do some completion on TEXT.  The indices of TEXT in RL_LINE_BUFFER are    at START and END.  Return an array of matches, or NULL if none. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|attempt_shell_completion
parameter_list|(
name|text
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|int
name|in_command_position
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|matches
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|command_separator_chars
init|=
literal|";|&{("
decl_stmt|;
comment|/* Determine if this could be a command word.  It is if it appears at      the start of the line (ignoring preceding whitespace), or if it      appears after a character that separates commands.  It cannot be a      command word if we aren't at the top-level prompt. */
block|{
specifier|register
name|int
name|ti
init|=
name|start
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|ti
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|ti
index|]
argument_list|)
operator|)
condition|)
name|ti
operator|--
expr_stmt|;
if|if
condition|(
name|ti
operator|<
literal|0
condition|)
block|{
specifier|extern
name|char
modifier|*
name|current_prompt_string
decl_stmt|,
modifier|*
name|ps1_prompt
decl_stmt|;
comment|/* Only do command completion at the start of a line when we 	   are not prompting at top level. */
if|if
condition|(
name|current_prompt_string
operator|==
name|ps1_prompt
condition|)
name|in_command_position
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|member
argument_list|(
name|rl_line_buffer
index|[
name|ti
index|]
argument_list|,
name|command_separator_chars
argument_list|)
condition|)
name|in_command_position
operator|++
expr_stmt|;
block|}
block|}
comment|/* Variable name? */
if|if
condition|(
operator|*
name|text
operator|==
literal|'$'
condition|)
name|matches
operator|=
name|completion_matches
argument_list|(
name|text
argument_list|,
name|variable_completion_function
argument_list|)
expr_stmt|;
comment|/* If the word starts in `~', and there is no slash in the word, then      try completing this word as a username. */
if|if
condition|(
operator|!
name|matches
operator|&&
operator|*
name|text
operator|==
literal|'~'
operator|&&
operator|!
name|index
argument_list|(
name|text
argument_list|,
literal|'/'
argument_list|)
condition|)
name|matches
operator|=
name|completion_matches
argument_list|(
name|text
argument_list|,
name|username_completion_function
argument_list|)
expr_stmt|;
comment|/* Another one.  Why not?  If the word starts in '@', then look through      the world of known hostnames for completion first. */
if|if
condition|(
operator|!
name|matches
operator|&&
operator|*
name|text
operator|==
literal|'@'
condition|)
name|matches
operator|=
name|completion_matches
argument_list|(
name|text
argument_list|,
name|hostname_completion_function
argument_list|)
expr_stmt|;
comment|/* And last, (but not least) if this word is in a command position, then      complete over possible command names, including aliases, functions,      and command names. */
if|if
condition|(
operator|!
name|matches
operator|&&
name|in_command_position
operator|&&
operator|*
name|text
operator|!=
literal|'/'
condition|)
name|matches
operator|=
name|completion_matches
argument_list|(
name|text
argument_list|,
name|command_word_completion_function
argument_list|)
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is the function to call when the word to complete is at the start    of a line.  It grovels $PATH, looking for commands that match.  It also    scans aliases, function names, and the shell_builtin table. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|command_word_completion_function
parameter_list|(
name|hint_text
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|hint_text
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
specifier|extern
name|SHELL_VAR
modifier|*
modifier|*
name|all_visible_functions
parameter_list|()
function_decl|;
name|char
modifier|*
name|extract_colon_unit
parameter_list|()
function_decl|;
specifier|static
name|char
modifier|*
name|hint
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|path
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|filename_hint
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|path_index
decl_stmt|,
name|hint_len
decl_stmt|,
name|istate
decl_stmt|;
specifier|static
name|int
name|mapping_over
decl_stmt|,
name|local_index
decl_stmt|;
specifier|static
name|SHELL_VAR
modifier|*
modifier|*
name|varlist
init|=
operator|(
name|SHELL_VAR
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* We have to map over the possibilities for command words.  If we have      no state, then make one just for that purpose. */
if|if
condition|(
operator|!
name|state
condition|)
block|{
if|if
condition|(
name|hint
condition|)
name|free
argument_list|(
name|hint
argument_list|)
expr_stmt|;
name|path
operator|=
name|get_string_value
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
name|path_index
operator|=
literal|0
expr_stmt|;
name|hint
operator|=
name|savestring
argument_list|(
name|hint_text
argument_list|)
expr_stmt|;
name|hint_len
operator|=
name|strlen
argument_list|(
name|hint
argument_list|)
expr_stmt|;
name|mapping_over
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Initialize the variables for each type of command word. */
name|local_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|varlist
condition|)
name|free
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
name|varlist
operator|=
name|all_visible_functions
argument_list|()
expr_stmt|;
block|}
comment|/* mapping_over says what we are currently hacking.  Note that every case      in this list must fall through when there are no more possibilities. */
switch|switch
condition|(
name|mapping_over
condition|)
block|{
case|case
literal|0
case|:
comment|/* Aliases come first. */
if|#
directive|if
name|defined
argument_list|(
name|ALIAS
argument_list|)
while|while
condition|(
name|aliases
operator|&&
name|aliases
index|[
name|local_index
index|]
condition|)
block|{
specifier|register
name|char
modifier|*
name|alias
decl_stmt|;
name|alias
operator|=
name|aliases
index|[
name|local_index
operator|++
index|]
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|alias
argument_list|,
name|hint
argument_list|,
name|hint_len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|alias
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ALIAS */
name|local_index
operator|=
literal|0
expr_stmt|;
name|mapping_over
operator|++
expr_stmt|;
case|case
literal|1
case|:
comment|/* Then shell reserved words. */
block|{
specifier|extern
name|STRING_INT_ALIST
name|word_token_alist
index|[]
decl_stmt|;
while|while
condition|(
name|word_token_alist
index|[
name|local_index
index|]
operator|.
name|word
condition|)
block|{
specifier|register
name|char
modifier|*
name|reserved_word
decl_stmt|;
name|reserved_word
operator|=
name|word_token_alist
index|[
name|local_index
operator|++
index|]
operator|.
name|word
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|reserved_word
argument_list|,
name|hint
argument_list|,
name|hint_len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|reserved_word
argument_list|)
operator|)
return|;
block|}
name|local_index
operator|=
literal|0
expr_stmt|;
name|mapping_over
operator|++
expr_stmt|;
block|}
case|case
literal|2
case|:
comment|/* Then function names. */
while|while
condition|(
name|varlist
operator|&&
name|varlist
index|[
name|local_index
index|]
condition|)
block|{
specifier|register
name|char
modifier|*
name|varname
decl_stmt|;
name|varname
operator|=
name|varlist
index|[
name|local_index
operator|++
index|]
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|varname
argument_list|,
name|hint
argument_list|,
name|hint_len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|varname
argument_list|)
operator|)
return|;
block|}
name|local_index
operator|=
literal|0
expr_stmt|;
name|mapping_over
operator|++
expr_stmt|;
case|case
literal|3
case|:
comment|/* Then shell builtins. */
for|for
control|(
init|;
name|local_index
operator|<
name|num_shell_builtins
condition|;
name|local_index
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|shell_builtins
index|[
name|local_index
index|]
operator|.
name|function
operator|||
operator|!
name|shell_builtins
index|[
name|local_index
index|]
operator|.
name|enabled
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|shell_builtins
index|[
name|local_index
index|]
operator|.
name|name
argument_list|,
name|hint
argument_list|,
name|hint_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
init|=
name|local_index
operator|++
decl_stmt|;
return|return
operator|(
name|savestring
argument_list|(
name|shell_builtins
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
return|;
block|}
block|}
name|local_index
operator|=
literal|0
expr_stmt|;
name|mapping_over
operator|++
expr_stmt|;
block|}
comment|/* Repeatedly call filename_completion_function while we have      members of PATH left.  Question:  should we stat each file?      Answer: we call executable_file () on each file. */
name|outer
label|:
name|istate
operator|=
operator|(
name|val
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|istate
condition|)
block|{
name|char
modifier|*
name|current_path
decl_stmt|;
comment|/* Get the next directory from the path.  If there is none, then we 	 are all done. */
if|if
condition|(
operator|!
name|path
operator|||
operator|!
name|path
index|[
name|path_index
index|]
operator|||
operator|!
operator|(
name|current_path
operator|=
name|extract_colon_unit
argument_list|(
name|path
argument_list|,
operator|&
name|path_index
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
operator|*
name|current_path
condition|)
block|{
name|free
argument_list|(
name|current_path
argument_list|)
expr_stmt|;
name|current_path
operator|=
name|savestring
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|current_path
operator|==
literal|'~'
condition|)
block|{
specifier|extern
name|char
modifier|*
name|tilde_expand
parameter_list|()
function_decl|;
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|tilde_expand
argument_list|(
name|current_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|current_path
argument_list|)
expr_stmt|;
name|current_path
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|filename_hint
condition|)
name|free
argument_list|(
name|filename_hint
argument_list|)
expr_stmt|;
name|filename_hint
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|current_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|hint
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename_hint
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_path
argument_list|,
name|hint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|current_path
argument_list|)
expr_stmt|;
block|}
name|inner
label|:
name|val
operator|=
name|filename_completion_function
argument_list|(
name|filename_hint
argument_list|,
name|istate
argument_list|)
expr_stmt|;
name|istate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
goto|goto
name|outer
goto|;
block|}
else|else
block|{
name|char
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|temp
init|=
name|rindex
argument_list|(
name|val
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|temp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|hint
argument_list|,
name|temp
argument_list|,
name|hint_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|executable_file
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|temp
operator|=
operator|(
name|savestring
argument_list|(
name|temp
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
literal|""
expr_stmt|;
comment|/* So it won't be NULL. */
return|return
operator|(
name|temp
operator|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
goto|goto
name|inner
goto|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Okay, now we write the entry_function for variable completion. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|variable_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|SHELL_VAR
modifier|*
name|var
init|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|SHELL_VAR
modifier|*
modifier|*
name|varlist
init|=
operator|(
name|SHELL_VAR
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|varlist_index
decl_stmt|;
specifier|static
name|char
modifier|*
name|varname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|namelen
decl_stmt|;
specifier|static
name|int
name|first_char
decl_stmt|,
name|first_char_loc
decl_stmt|;
specifier|extern
name|SHELL_VAR
modifier|*
modifier|*
name|all_visible_variables
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
if|if
condition|(
name|varname
condition|)
name|free
argument_list|(
name|varname
argument_list|)
expr_stmt|;
name|first_char_loc
operator|=
literal|0
expr_stmt|;
name|first_char
operator|=
name|text
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|first_char
operator|==
literal|'$'
condition|)
name|first_char_loc
operator|++
expr_stmt|;
name|varname
operator|=
name|savestring
argument_list|(
operator|&
name|text
index|[
name|first_char_loc
index|]
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|varname
argument_list|)
expr_stmt|;
if|if
condition|(
name|varlist
condition|)
name|free
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
name|varlist
operator|=
name|all_visible_variables
argument_list|()
expr_stmt|;
name|varlist_index
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|varlist
operator|&&
name|varlist
index|[
name|varlist_index
index|]
condition|)
block|{
name|var
operator|=
name|varlist
index|[
name|varlist_index
index|]
expr_stmt|;
comment|/* Compare.  You can't do better than Zayre.  No text is also 	 a match.  */
if|if
condition|(
operator|!
operator|*
name|varname
operator|||
operator|(
name|strncmp
argument_list|(
name|varname
argument_list|,
name|var
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
name|varlist_index
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|varlist
operator|||
operator|!
name|varlist
index|[
name|varlist_index
index|]
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|var
operator|->
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|first_char_loc
condition|)
operator|*
name|value
operator|=
name|first_char
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|value
index|[
name|first_char_loc
index|]
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|varlist_index
operator|++
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* How about a completion function for hostnames? */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hostname_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|list_index
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|first_char
decl_stmt|,
name|first_char_loc
decl_stmt|;
comment|/* If we don't have any state, make some. */
if|if
condition|(
operator|!
name|state
condition|)
block|{
if|if
condition|(
name|list
condition|)
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|first_char_loc
operator|=
literal|0
expr_stmt|;
name|first_char
operator|=
operator|*
name|text
expr_stmt|;
if|if
condition|(
name|first_char
operator|==
literal|'@'
condition|)
name|first_char_loc
operator|++
expr_stmt|;
name|list
operator|=
name|hostnames_matching
argument_list|(
operator|&
name|text
index|[
name|first_char_loc
index|]
argument_list|)
expr_stmt|;
name|list_index
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|&&
name|list
index|[
name|list_index
index|]
condition|)
block|{
name|char
modifier|*
name|t
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|list
index|[
name|list_index
index|]
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|t
operator|=
name|first_char
expr_stmt|;
name|strcpy
argument_list|(
name|t
operator|+
name|first_char_loc
argument_list|,
name|list
index|[
name|list_index
index|]
argument_list|)
expr_stmt|;
name|list_index
operator|++
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* History and alias expand the line.  But maybe do more?  This    is a test to see what users like.  Do expand_string on the string. */
end_comment

begin_function
specifier|static
name|void
name|shell_expand_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|char
modifier|*
name|pre_process_line
argument_list|()
decl_stmt|,
modifier|*
name|new_line
decl_stmt|;
name|new_line
operator|=
name|pre_process_line
argument_list|(
name|rl_line_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ALIAS
argument_list|)
if|if
condition|(
name|new_line
condition|)
block|{
name|char
modifier|*
name|alias_expand
argument_list|()
decl_stmt|,
modifier|*
name|alias_line
decl_stmt|;
name|alias_line
operator|=
name|alias_expand
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|new_line
operator|=
name|alias_line
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALIAS */
if|if
condition|(
name|new_line
condition|)
block|{
name|int
name|old_point
init|=
name|rl_point
decl_stmt|;
name|int
name|at_end
init|=
name|rl_point
operator|==
name|rl_end
decl_stmt|;
comment|/* If the line was history and alias expanded, then make that 	 be one thing to undo. */
if|if
condition|(
name|strcmp
argument_list|(
name|new_line
argument_list|,
name|rl_line_buffer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rl_point
operator|=
name|rl_end
expr_stmt|;
name|rl_add_undo
argument_list|(
name|UNDO_BEGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
literal|0
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|rl_end
operator|=
literal|0
expr_stmt|;
name|rl_insert_text
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|rl_add_undo
argument_list|(
name|UNDO_END
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
comment|/* If there is variable expansion to perform, do that as a separate 	 operation to be undone. */
block|{
specifier|extern
name|char
modifier|*
name|string_list
parameter_list|()
function_decl|;
specifier|extern
name|WORD_LIST
modifier|*
name|expand_string
parameter_list|()
function_decl|;
name|WORD_LIST
modifier|*
name|expanded_string
decl_stmt|;
name|char
modifier|*
name|string_list
parameter_list|()
function_decl|;
name|expanded_string
operator|=
name|expand_string
argument_list|(
name|rl_line_buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expanded_string
condition|)
name|new_line
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|new_line
operator|=
name|string_list
argument_list|(
name|expanded_string
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|expanded_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|new_line
argument_list|,
name|rl_line_buffer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rl_add_undo
argument_list|(
name|UNDO_BEGIN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
literal|0
argument_list|,
name|rl_end
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|rl_end
operator|=
literal|0
expr_stmt|;
name|rl_insert_text
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
name|rl_add_undo
argument_list|(
name|UNDO_END
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|new_line
argument_list|)
expr_stmt|;
comment|/* Place rl_point where we think it should go. */
if|if
condition|(
name|at_end
condition|)
name|rl_point
operator|=
name|rl_end
expr_stmt|;
elseif|else
if|if
condition|(
name|old_point
operator|<
name|rl_end
condition|)
block|{
name|rl_point
operator|=
name|old_point
expr_stmt|;
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_forward_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* There was an error in expansion.  Let the preprocessor print 	 the error here.  Note that we know that pre_process_line () 	 will return NULL, since it just did. */
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\n\r"
argument_list|)
expr_stmt|;
name|pre_process_line
argument_list|(
name|rl_line_buffer
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Filename completion ignore.  Emulates the "fignore" facility of    tcsh.  If FIGNORE is set, then don't match files with the    given suffixes.  If only one of the possibilities has an acceptable    suffix, delete the others, else just return and let the completer    signal an error.  It is called by the completer when real    completions are done on filenames by the completer's internal    function, not for completion lists (M-?) and not on "other"    completion types, such as hostnames or commands.      It is passed a NULL-terminated array of (char *)'s that must be    free()'d if they are deleted.  The first element (names[0]) is the    least-common-denominator string of the matching patterns (i.e.    u<TAB> produces names[0] = "und", names[1] = "under.c", names[2] =    "undun.c", name[3] = NULL).  */
end_comment

begin_struct
struct|struct
name|ign
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ign
modifier|*
name|ignores
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store the ignore strings here */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_ignores
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many are there? */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_fignore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last value of fignore - cached for speed */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|extract_colon_unit
argument_list|()
decl_stmt|,
modifier|*
name|get_string_value
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setup_ignore_patterns
parameter_list|()
block|{
name|int
name|numitems
decl_stmt|,
name|maxitems
decl_stmt|,
name|ptr
decl_stmt|;
name|char
modifier|*
name|colon_bit
decl_stmt|;
name|struct
name|ign
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|this_fignore
init|=
name|get_string_value
argument_list|(
literal|"FIGNORE"
argument_list|)
decl_stmt|;
comment|/* If nothing has changed then just exit now. */
if|if
condition|(
name|this_fignore
operator|&&
name|last_fignore
operator|&&
name|strcmp
argument_list|(
name|this_fignore
argument_list|,
name|last_fignore
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|this_fignore
operator|&&
operator|!
name|last_fignore
operator|)
condition|)
block|{
return|return;
block|}
comment|/* Oops.  FIGNORE has changed.  Re-parse it. */
name|num_ignores
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignores
condition|)
block|{
for|for
control|(
name|p
operator|=
name|ignores
init|;
name|p
operator|->
name|val
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
name|p
operator|->
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ignores
argument_list|)
expr_stmt|;
name|ignores
operator|=
operator|(
expr|struct
name|ign
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|last_fignore
condition|)
name|free
argument_list|(
name|last_fignore
argument_list|)
expr_stmt|;
name|last_fignore
operator|=
name|savestring
argument_list|(
name|this_fignore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_fignore
operator|||
operator|!
operator|*
name|this_fignore
condition|)
return|return;
name|numitems
operator|=
name|maxitems
operator|=
name|ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|colon_bit
operator|=
name|extract_colon_unit
argument_list|(
name|this_fignore
argument_list|,
operator|&
name|ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|numitems
operator|+
literal|1
operator|>
name|maxitems
condition|)
name|ignores
operator|=
operator|(
expr|struct
name|ign
operator|*
operator|)
name|xrealloc
argument_list|(
name|ignores
argument_list|,
operator|(
name|maxitems
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ign
argument_list|)
argument_list|)
expr_stmt|;
name|ignores
index|[
name|numitems
index|]
operator|.
name|val
operator|=
name|colon_bit
expr_stmt|;
name|ignores
index|[
name|numitems
index|]
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|colon_bit
argument_list|)
expr_stmt|;
name|numitems
operator|++
expr_stmt|;
block|}
name|ignores
index|[
name|numitems
index|]
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
name|num_ignores
operator|=
name|numitems
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|name_is_acceptable
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|ign
modifier|*
name|p
decl_stmt|;
name|int
name|nlen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ignores
init|;
name|p
operator|->
name|val
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|nlen
operator|>
name|p
operator|->
name|len
operator|&&
name|p
operator|->
name|len
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|val
argument_list|,
operator|&
name|name
index|[
name|nlen
operator|-
name|p
operator|->
name|len
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filename_completion_ignore
parameter_list|(
name|names
parameter_list|)
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|setup_ignore_patterns
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|num_ignores
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|names
operator|+
literal|1
operator|,
name|idx
operator|=
operator|-
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|name_is_acceptable
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
comment|/* First match found. */
name|idx
operator|=
name|p
operator|-
name|names
expr_stmt|;
else|else
return|return;
comment|/* Too many matches. */
block|}
block|}
comment|/* If none are acceptable then let the completer handle it. */
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Delete all non-matching elements. */
name|free
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|names
operator|+
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|==
operator|(
name|p
operator|-
name|names
operator|)
condition|)
name|names
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle symbolic link references while hacking completion. */
end_comment

begin_function
specifier|static
name|void
name|bash_symbolic_link_hook
parameter_list|(
name|dirname
parameter_list|)
name|char
modifier|*
modifier|*
name|dirname
decl_stmt|;
block|{
specifier|extern
name|int
name|follow_symbolic_links
decl_stmt|;
name|char
modifier|*
name|make_absolute
argument_list|()
decl_stmt|,
modifier|*
name|temp_dirname
decl_stmt|;
if|if
condition|(
name|follow_symbolic_links
operator|&&
operator|(
name|strcmp
argument_list|(
operator|*
name|dirname
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp_dirname
operator|=
name|make_absolute
argument_list|(
operator|*
name|dirname
argument_list|,
name|get_working_directory
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_dirname
condition|)
block|{
name|free
argument_list|(
operator|*
name|dirname
argument_list|)
expr_stmt|;
operator|*
name|dirname
operator|=
name|temp_dirname
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DYNAMIC_HISTORY_COMPLETION
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|history_completion_array
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|harry_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|harry_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|build_history_completion_array
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* First, clear out the current dynamic history completion list. */
if|if
condition|(
name|harry_size
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|history_completion_array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|history_completion_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|history_completion_array
argument_list|)
expr_stmt|;
name|history_completion_array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|harry_size
operator|=
literal|0
expr_stmt|;
name|harry_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Next, grovel each line of history, making each shell-sized token      a separate entry in the history_completion_array. */
block|{
name|HIST_ENTRY
modifier|*
modifier|*
name|hlist
decl_stmt|;
name|hlist
operator|=
name|history_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|hlist
condition|)
block|{
specifier|extern
name|int
name|qsort_string_compare
parameter_list|()
function_decl|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hlist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|history_tokenize
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
comment|/* Separate each token, and place into an array. */
name|tokens
operator|=
name|history_tokenize
argument_list|(
name|hlist
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|tokens
operator|&&
name|tokens
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|harry_len
operator|+
literal|2
operator|>
name|harry_size
condition|)
name|history_completion_array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|history_completion_array
argument_list|,
operator|(
name|harry_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|history_completion_array
index|[
name|harry_len
operator|++
index|]
operator|=
name|tokens
index|[
name|j
index|]
expr_stmt|;
name|history_completion_array
index|[
name|harry_len
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the complete list of tokens. */
name|qsort
argument_list|(
name|history_completion_array
argument_list|,
name|harry_len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|qsort_string_compare
argument_list|)
expr_stmt|;
comment|/* Instead of removing the duplicate entries here, we let the 	   code in the completer handle it. */
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|history_completion_generator
parameter_list|(
name|hint_text
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|hint_text
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
specifier|static
name|int
name|local_index
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|text
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* If this is the first call to the generator, then initialize the      list of strings to complete over. */
if|if
condition|(
operator|!
name|state
condition|)
block|{
name|local_index
operator|=
literal|0
expr_stmt|;
name|build_history_completion_array
argument_list|()
expr_stmt|;
name|text
operator|=
name|hint_text
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|history_completion_array
operator|&&
name|history_completion_array
index|[
name|local_index
index|]
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|text
argument_list|,
name|history_completion_array
index|[
name|local_index
operator|++
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|history_completion_array
index|[
name|local_index
operator|-
literal|1
index|]
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_complete_history
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
specifier|extern
name|Function
modifier|*
name|rl_last_func
decl_stmt|;
name|Function
modifier|*
name|orig_func
decl_stmt|;
name|Function
modifier|*
name|orig_attempt_func
decl_stmt|;
name|orig_func
operator|=
name|rl_completion_entry_function
expr_stmt|;
name|orig_attempt_func
operator|=
name|rl_attempted_completion_function
expr_stmt|;
name|rl_completion_entry_function
operator|=
operator|(
name|Function
operator|*
operator|)
name|history_completion_generator
expr_stmt|;
name|rl_attempted_completion_function
operator|=
operator|(
name|Function
operator|*
operator|)
literal|0x0
expr_stmt|;
if|if
condition|(
name|rl_last_func
operator|==
operator|(
name|Function
operator|*
operator|)
name|dynamic_complete_history
condition|)
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
else|else
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
name|rl_completion_entry_function
operator|=
name|orig_func
expr_stmt|;
name|rl_attempted_completion_function
operator|=
name|orig_attempt_func
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC_HISTORY_COMPLETION */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SPECIFIC_COMPLETION_FUNCTIONS
argument_list|)
end_if

begin_function
specifier|static
name|void
name|bash_complete_username
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_username_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_possible_username_completions
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_username_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_username_internal
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
name|bash_specific_completion
argument_list|(
name|what_to_do
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|username_completion_function
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_filename
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_filename_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_possible_filename_completions
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_filename_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_filename_internal
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
name|Function
modifier|*
name|orig_func
decl_stmt|;
name|Function
modifier|*
name|orig_attempt_func
decl_stmt|;
name|char
modifier|*
name|orig_rl_completer_word_break_characters
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_completer_word_break_characters
decl_stmt|;
name|orig_func
operator|=
name|rl_completion_entry_function
expr_stmt|;
name|orig_attempt_func
operator|=
name|rl_attempted_completion_function
expr_stmt|;
name|orig_rl_completer_word_break_characters
operator|=
name|rl_completer_word_break_characters
expr_stmt|;
name|rl_completion_entry_function
operator|=
operator|(
name|Function
operator|*
operator|)
name|filename_completion_function
expr_stmt|;
name|rl_attempted_completion_function
operator|=
operator|(
name|Function
operator|*
operator|)
literal|0x0
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
literal|" \t\n\"\'"
expr_stmt|;
name|rl_complete_internal
argument_list|(
name|what_to_do
argument_list|)
expr_stmt|;
name|rl_completion_entry_function
operator|=
name|orig_func
expr_stmt|;
name|rl_attempted_completion_function
operator|=
name|orig_attempt_func
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|orig_rl_completer_word_break_characters
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_hostname
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_hostname_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_possible_hostname_completions
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_hostname_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_variable
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_variable_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_possible_variable_completions
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_variable_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_command
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_command_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_possible_command_completions
parameter_list|(
name|ignore
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|bash_complete_command_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_hostname_internal
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
name|bash_specific_completion
argument_list|(
name|what_to_do
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|hostname_completion_function
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_variable_internal
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
name|bash_specific_completion
argument_list|(
name|what_to_do
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|variable_completion_function
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_complete_command_internal
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
name|bash_specific_completion
argument_list|(
name|what_to_do
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|command_word_completion_function
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bash_specific_completion
parameter_list|(
name|what_to_do
parameter_list|,
name|generator
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
name|Function
modifier|*
name|generator
decl_stmt|;
block|{
name|Function
modifier|*
name|orig_func
decl_stmt|;
name|Function
modifier|*
name|orig_attempt_func
decl_stmt|;
name|orig_func
operator|=
name|rl_completion_entry_function
expr_stmt|;
name|orig_attempt_func
operator|=
name|rl_attempted_completion_function
expr_stmt|;
name|rl_completion_entry_function
operator|=
name|generator
expr_stmt|;
name|rl_attempted_completion_function
operator|=
operator|(
name|Function
operator|*
operator|)
literal|0x0
expr_stmt|;
name|rl_complete_internal
argument_list|(
name|what_to_do
argument_list|)
expr_stmt|;
name|rl_completion_entry_function
operator|=
name|orig_func
expr_stmt|;
name|rl_attempted_completion_function
operator|=
name|orig_attempt_func
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SPECIFIC_COMPLETION_FUNCTIONS */
end_comment

end_unit

