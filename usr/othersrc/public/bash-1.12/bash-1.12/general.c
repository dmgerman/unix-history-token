begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* general.c -- Stuff that is used by all files. */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1989 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"filecntl.h"
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_RESOURCE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|"maxpath.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make the functions index and rindex if they do not exist. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DGUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|index
argument_list|)
end_if

begin_function
name|char
modifier|*
name|index
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG&& !sgi&& !DGUX&& !index */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
operator|&&
operator|!
name|DGUX
operator|&&
operator|!
name|defined
argument_list|(
name|rindex
argument_list|)
end_if

begin_function
name|char
modifier|*
name|rindex
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|strrchr
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG&& !sgi&& !DUGX&& !rindex */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   Memory Allocation and Deallocation.		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|fatal_error
argument_list|(
literal|"Out of virtual memory!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|fatal_error
argument_list|(
literal|"Out of virtual memory!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     Integer to String Conversion		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Number of characters that can appear in a string representation    of an integer.  32 is larger than the string rep of 2^^31 - 1. */
end_comment

begin_define
define|#
directive|define
name|MAX_INT_LEN
value|32
end_define

begin_comment
comment|/* Integer to string conversion.  This conses the string; the    caller should free it. */
end_comment

begin_function
name|char
modifier|*
name|itos
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|MAX_INT_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|negative
operator|++
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
name|ui
operator|=
operator|(
name|unsigned
name|int
operator|)
name|i
expr_stmt|;
name|buf
index|[
name|MAX_INT_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
name|MAX_INT_LEN
operator|-
literal|2
index|]
expr_stmt|;
do|do
operator|*
name|p
operator|--
operator|=
operator|(
name|ui
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
do|while
condition|(
name|ui
operator|/=
literal|10
condition|)
do|;
if|if
condition|(
name|negative
condition|)
operator|*
name|p
operator|--
operator|=
literal|'-'
expr_stmt|;
name|ret
operator|=
name|savestring
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if all of the characters in STRING are digits. */
end_comment

begin_function
name|int
name|all_digits
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|!
name|digit
argument_list|(
operator|*
name|string
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|string
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A function to unset no-delay mode on a file descriptor.  Used in shell.c    to unset it on the fd passed as stdin.  Should be called on stdin if    readline gets an EAGAIN or EWOULDBLOCK when trying to read input. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FNDELAY
argument_list|)
end_if

begin_define
define|#
directive|define
name|O_NDELAY
value|FNDELAY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* O_NDELAY */
end_comment

begin_comment
comment|/* Make sure no-delay mode is not set on file descriptor FD. */
end_comment

begin_function
name|void
name|unset_nodelay_mode
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|,
name|set
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
name|set
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* O_NONBLOCK */
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_NDELAY
expr_stmt|;
name|set
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* O_NDELAY */
if|if
condition|(
name|set
condition|)
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Generic List Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Call FUNCTION on every member of LIST, a generic list. */
end_comment

begin_function
name|void
name|map_over_list
parameter_list|(
name|list
parameter_list|,
name|function
parameter_list|)
name|GENERIC_LIST
modifier|*
name|list
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
call|(
modifier|*
name|function
call|)
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call FUNCTION on every string in WORDS. */
end_comment

begin_function
name|void
name|map_over_words
parameter_list|(
name|words
parameter_list|,
name|function
parameter_list|)
name|WORD_LIST
modifier|*
name|words
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|{
while|while
condition|(
name|words
condition|)
block|{
call|(
modifier|*
name|function
call|)
argument_list|(
name|words
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|words
operator|=
name|words
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reverse the chain of structures in LIST.  Output the new head    of the chain.  You should always assign the output value of this    function to something, or you will lose the chain. */
end_comment

begin_function
name|GENERIC_LIST
modifier|*
name|reverse_list
parameter_list|(
name|list
parameter_list|)
specifier|register
name|GENERIC_LIST
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|GENERIC_LIST
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
init|=
operator|(
name|GENERIC_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of elements in LIST, a generic list. */
end_comment

begin_function
name|int
name|list_length
parameter_list|(
name|list
parameter_list|)
specifier|register
name|GENERIC_LIST
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete the element of LIST which satisfies the predicate function COMPARER.    Returns the element that was deleted, so you can dispose of it, or -1 if    the element wasn't found.  COMPARER is called with the list element and    then ARG.  Note that LIST contains the address of a variable which points    to the list.  You might call this function like this:     SHELL_VAR *elt = delete_element (&variable_list, check_var_has_name, "foo");    dispose_variable (elt); */
end_comment

begin_function
name|GENERIC_LIST
modifier|*
name|delete_element
parameter_list|(
name|list
parameter_list|,
name|comparer
parameter_list|,
name|arg
parameter_list|)
name|GENERIC_LIST
modifier|*
modifier|*
name|list
decl_stmt|;
name|Function
modifier|*
name|comparer
decl_stmt|;
block|{
specifier|register
name|GENERIC_LIST
modifier|*
name|prev
init|=
operator|(
name|GENERIC_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|GENERIC_LIST
modifier|*
name|temp
init|=
operator|*
name|list
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|comparer
call|)
argument_list|(
name|temp
argument_list|,
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|list
operator|=
name|temp
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|GENERIC_LIST
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find NAME in ARRAY.  Return the index of NAME, or -1 if not present.    ARRAY shoudl be NULL terminated. */
end_comment

begin_decl_stmt
name|int
name|find_name_in_list
argument_list|(
name|name
argument_list|,
name|array
argument_list|)
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|array
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|array
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return the length of ARRAY, a NULL terminated array of char *. */
end_comment

begin_function
name|int
name|array_len
parameter_list|(
name|array
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free the contents of ARRAY, a NULL terminated array of char *. */
end_comment

begin_function
name|void
name|free_array
parameter_list|(
name|array
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|array
condition|)
return|return;
while|while
condition|(
name|array
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|array
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append LIST2 to LIST1.  Return the header of the list. */
end_comment

begin_function
name|GENERIC_LIST
modifier|*
name|list_append
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|GENERIC_LIST
modifier|*
name|head
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|GENERIC_LIST
modifier|*
name|t_head
init|=
name|head
decl_stmt|;
if|if
condition|(
operator|!
name|t_head
condition|)
return|return
operator|(
name|tail
operator|)
return|;
while|while
condition|(
name|t_head
operator|->
name|next
condition|)
name|t_head
operator|=
name|t_head
operator|->
name|next
expr_stmt|;
name|t_head
operator|->
name|next
operator|=
name|tail
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Some random string stuff. */
end_comment

begin_comment
comment|/* Remove all leading whitespace from STRING.  This includes    newlines.  STRING should be terminated with a zero. */
end_comment

begin_function
name|void
name|strip_leading
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
name|string
decl_stmt|;
while|while
condition|(
operator|*
name|string
operator|&&
operator|(
name|whitespace
argument_list|(
operator|*
name|string
argument_list|)
operator|||
operator|*
name|string
operator|==
literal|'\n'
operator|)
condition|)
name|string
operator|++
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|start
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|start
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove all trailing whitespace from STRING.  This includes    newlines.  If NEWLINES_ONLY is non-zero, only trailing newlines    are removed.  STRING should be terminated with a zero. */
end_comment

begin_function
name|void
name|strip_trailing
parameter_list|(
name|string
parameter_list|,
name|newlines_only
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|newlines_only
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|newlines_only
operator|&&
name|string
index|[
name|len
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|!
name|newlines_only
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|len
index|]
argument_list|)
operator|)
condition|)
name|len
operator|--
expr_stmt|;
else|else
break|break;
block|}
name|string
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the last N directories from PATH.  Do not PATH blank.    PATH must contain enoung space for MAXPATHLEN characters. */
end_comment

begin_function
specifier|static
name|void
name|pathname_backup
parameter_list|(
name|path
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|path
condition|)
return|return;
name|p
operator|=
name|path
operator|+
operator|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|p
operator|!=
name|path
condition|)
name|p
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
name|p
operator|!=
name|path
condition|)
name|p
operator|--
expr_stmt|;
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|current_path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn STRING (a pathname) into an absolute pathname, assuming that    DOT_PATH contains the symbolic location of '.'.  This always    returns a new string, even if STRING was an absolute pathname to    begin with. */
end_comment

begin_function
name|char
modifier|*
name|make_absolute
parameter_list|(
name|string
parameter_list|,
name|dot_path
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|dot_path
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|dot_path
operator|||
operator|*
name|string
operator|==
literal|'/'
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|string
argument_list|)
operator|)
return|;
name|strcpy
argument_list|(
name|current_path
argument_list|,
name|dot_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_path
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|current_path
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|current_path
operator|+
operator|(
name|strlen
argument_list|(
name|current_path
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'/'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|string
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|current_path
argument_list|)
operator|)
return|;
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|string
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|string
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
operator|!
name|string
index|[
literal|2
index|]
operator|)
condition|)
block|{
name|string
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|string
operator|++
expr_stmt|;
name|pathname_backup
argument_list|(
name|current_path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|current_path
operator|+
name|strlen
argument_list|(
name|current_path
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
while|while
condition|(
operator|*
name|string
operator|&&
operator|*
name|string
operator|!=
literal|'/'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|string
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|savestring
argument_list|(
name|current_path
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if STRING contains an absolute pathname, else 0. */
end_comment

begin_function
name|int
name|absolute_pathname
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'/'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|string
operator|++
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|*
name|string
operator|)
operator|||
operator|*
name|string
operator|==
literal|'/'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|string
operator|++
operator|==
literal|'.'
condition|)
if|if
condition|(
operator|!
operator|*
name|string
operator|||
operator|*
name|string
operator|==
literal|'/'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if STRING is an absolute program name; it is absolute if it    contains any slashes.  This is used to decide whether or not to look    up through $PATH. */
end_comment

begin_function
name|int
name|absolute_program
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|string
argument_list|,
literal|'/'
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the `basename' of the pathname in STRING (the stuff after the    last '/').  If STRING is not a full pathname, simply return it. */
end_comment

begin_function
name|char
modifier|*
name|base_pathname
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|string
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|absolute_pathname
argument_list|(
name|string
argument_list|)
condition|)
return|return
operator|(
name|string
operator|)
return|;
if|if
condition|(
name|p
condition|)
return|return
operator|(
operator|++
name|p
operator|)
return|;
else|else
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if s2 occurs in s1.  If so, return a pointer to the    match in s1.  The compare is case insensitive. */
end_comment

begin_function
name|char
modifier|*
name|strindex
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|len
operator|-
name|i
operator|)
operator|>=
name|l
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strnicmp
argument_list|(
operator|&
name|s1
index|[
name|i
index|]
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|s1
operator|+
name|i
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|to_upper
argument_list|)
end_if

begin_define
define|#
directive|define
name|lowercase_p
parameter_list|(
name|c
parameter_list|)
value|(((c)> ('a' - 1)&& (c)< ('z' + 1)))
end_define

begin_define
define|#
directive|define
name|uppercase_p
parameter_list|(
name|c
parameter_list|)
value|(((c)> ('A' - 1)&& (c)< ('Z' + 1)))
end_define

begin_define
define|#
directive|define
name|pure_alphabetic
parameter_list|(
name|c
parameter_list|)
value|(lowercase_p(c) || uppercase_p(c))
end_define

begin_define
define|#
directive|define
name|to_upper
parameter_list|(
name|c
parameter_list|)
value|(lowercase_p(c) ? ((c) - 32) : (c))
end_define

begin_define
define|#
directive|define
name|to_lower
parameter_list|(
name|c
parameter_list|)
value|(uppercase_p(c) ? ((c) + 32) : (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* to_upper */
end_comment

begin_comment
comment|/* Compare at most COUNT characters from string1 to string2.  Case    doesn't matter. */
end_comment

begin_function
name|int
name|strnicmp
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
name|to_upper
argument_list|(
name|ch1
argument_list|)
operator|==
name|to_upper
argument_list|(
name|ch2
argument_list|)
condition|)
name|count
operator|--
expr_stmt|;
else|else
break|break;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_comment
comment|/* strcmp (), but caseless. */
end_comment

begin_function
name|int
name|stricmp
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
while|while
condition|(
operator|*
name|string1
operator|&&
operator|*
name|string2
condition|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
name|to_upper
argument_list|(
name|ch1
argument_list|)
operator|!=
name|to_upper
argument_list|(
name|ch2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|*
name|string1
operator||
operator|*
name|string2
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return a string corresponding to the error number E.  From    the ANSI C spec. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|strerror
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|strerror
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRERROR
argument_list|)
end_if

begin_function
name|char
modifier|*
name|strerror
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|emsg
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|>
literal|0
operator|&&
name|e
operator|<
name|sys_nerr
condition|)
return|return
operator|(
name|sys_errlist
index|[
name|e
index|]
operator|)
return|;
else|else
block|{
name|sprintf
argument_list|(
name|emsg
argument_list|,
literal|"Unknown error %d"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|emsg
index|[
literal|0
index|]
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRERROR */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_RESOURCE
argument_list|)
end_if

begin_comment
comment|/* Print the contents of a struct timeval * in a standard way. */
end_comment

begin_function
name|void
name|print_timeval
parameter_list|(
name|tvp
parameter_list|)
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
block|{
name|int
name|minutes
decl_stmt|,
name|seconds_fraction
decl_stmt|;
name|long
name|seconds
decl_stmt|;
name|seconds
operator|=
name|tvp
operator|->
name|tv_sec
expr_stmt|;
name|seconds_fraction
operator|=
name|tvp
operator|->
name|tv_usec
operator|%
literal|1000000
expr_stmt|;
name|seconds_fraction
operator|=
operator|(
name|seconds_fraction
operator|*
literal|100
operator|)
operator|/
literal|1000000
expr_stmt|;
name|minutes
operator|=
name|seconds
operator|/
literal|60
expr_stmt|;
name|seconds
operator|%=
literal|60
expr_stmt|;
name|printf
argument_list|(
literal|"%0dm%0d.%02ds"
argument_list|,
name|minutes
argument_list|,
name|seconds
argument_list|,
name|seconds_fraction
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print the time defined by a time_t (returned by the `times' and `time'    system calls) in a standard way.  This is scaled in terms of HZ, which    is what is returned by the `times' call. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BrainDeath
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HZ
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_define
define|#
directive|define
name|HZ
value|100
end_define

begin_comment
comment|/* From my Sys V.3.2 manual for times(2) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HZ
value|60
end_define

begin_comment
comment|/* HZ is always 60 on BSD systems */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HZ */
end_comment

begin_function
name|void
name|print_time_in_hz
parameter_list|(
name|t
parameter_list|)
name|time_t
name|t
decl_stmt|;
block|{
name|int
name|minutes
decl_stmt|,
name|seconds_fraction
decl_stmt|;
name|long
name|seconds
decl_stmt|;
name|seconds_fraction
operator|=
name|t
operator|%
name|HZ
expr_stmt|;
name|seconds_fraction
operator|=
operator|(
name|seconds_fraction
operator|*
literal|100
operator|)
operator|/
name|HZ
expr_stmt|;
name|seconds
operator|=
name|t
operator|/
name|HZ
expr_stmt|;
name|minutes
operator|=
name|seconds
operator|/
literal|60
expr_stmt|;
name|seconds
operator|%=
literal|60
expr_stmt|;
name|printf
argument_list|(
literal|"%0dm%0d.%02ds"
argument_list|,
name|minutes
argument_list|,
name|seconds
argument_list|,
name|seconds_fraction
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BrainDeath */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_DUP2
argument_list|)
end_if

begin_comment
comment|/* Replacement for dup2 (), for those systems which either don't have it,    or supply one with broken behaviour. */
end_comment

begin_function
name|int
name|dup2
parameter_list|(
name|fd1
parameter_list|,
name|fd2
parameter_list|)
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
block|{
name|int
name|saved_errno
decl_stmt|,
name|r
decl_stmt|;
comment|/* If FD1 is not a valid file descriptor, then return immediately with      an error. */
if|if
condition|(
name|fcntl
argument_list|(
name|fd1
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fd2
operator|<
literal|0
operator|||
name|fd2
operator|>=
name|getdtablesize
argument_list|()
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fd1
operator|==
name|fd2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|saved_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
name|r
operator|=
name|fcntl
argument_list|(
name|fd1
argument_list|,
name|F_DUPFD
argument_list|,
name|fd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
name|errno
operator|=
name|saved_errno
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
comment|/* Force the new file descriptor to remain open across exec () calls. */
name|SET_OPEN_ON_EXEC
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_DUP2 */
end_comment

begin_comment
comment|/*  * Return the total number of available file descriptors.  *  * On some systems, like 4.2BSD and its descendents, there is a system call  * that returns the size of the descriptor table: getdtablesize().  There are  * lots of ways to emulate this on non-BSD systems.  *  * On System V.3, this can be obtained via a call to ulimit:  *	return (ulimit(4, 0L));  *  * On other System V systems, NOFILE is defined in /usr/include/sys/param.h  * (this is what we assume below), so we can simply use it:  *	return (NOFILE);  *  * On POSIX systems, there are specific functions for retrieving various  * configuration parameters:  *	return (sysconf(_SC_OPEN_MAX));  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|HPUX
argument_list|)
end_if

begin_function
name|int
name|getdtablesize
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
return|return
operator|(
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
operator|)
return|;
comment|/* Posix systems use sysconf */
else|#
directive|else
comment|/* ! (_POSIX_VERSION&& _SC_OPEN_MAX) */
if|#
directive|if
name|defined
argument_list|(
name|USGr3
argument_list|)
return|return
operator|(
name|ulimit
argument_list|(
literal|4
argument_list|,
literal|0L
argument_list|)
operator|)
return|;
comment|/* System V.3 systems use ulimit(4, 0L) */
else|#
directive|else
comment|/* !USGr3 */
if|#
directive|if
name|defined
argument_list|(
name|NOFILE
argument_list|)
comment|/* Other systems use NOFILE */
return|return
operator|(
name|NOFILE
operator|)
return|;
else|#
directive|else
comment|/* !NOFILE */
return|return
operator|(
literal|20
operator|)
return|;
comment|/* XXX - traditional value is 20 */
endif|#
directive|endif
comment|/* !NOFILE */
endif|#
directive|endif
comment|/* !USGr3 */
endif|#
directive|endif
comment|/* ! (_POSIX_VERSION&& _SC_OPEN_MAX) */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG&& !defined USGr4 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|sgi
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|RISC6000
argument_list|)
end_if

begin_macro
name|bcopy
argument_list|(
argument|s
argument_list|,
argument|d
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bzero
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|memset
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RISC6000 */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_GETWD
argument_list|)
end_if

begin_function
name|char
modifier|*
name|getwd
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|getcwd
parameter_list|()
function_decl|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|getcwd
argument_list|(
name|string
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"getwd: cannot access parent directories"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_GETWD */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HPUX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_function
name|int
name|gethostname
parameter_list|(
name|name
parameter_list|,
name|namelen
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|utsname
name|ut
decl_stmt|;
operator|--
name|namelen
expr_stmt|;
name|uname
argument_list|(
operator|&
name|ut
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|ut
operator|.
name|nodename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|ut
operator|.
name|nodename
argument_list|,
name|i
operator|<
name|namelen
condition|?
name|i
else|:
name|namelen
argument_list|)
expr_stmt|;
name|name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HPUX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG&& !sgi */
end_comment

begin_comment
comment|/* A slightly related function.  Get the prettiest name of this    directory possible. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tdir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a pretty pathname.  If the first part of the pathname is    the same as $HOME, then replace that with `~'.  */
end_comment

begin_function
name|char
modifier|*
name|polite_directory_format
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|home
init|=
name|get_string_value
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|home
condition|?
name|strlen
argument_list|(
name|home
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|home
argument_list|,
name|name
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|name
index|[
name|l
index|]
operator|||
name|name
index|[
name|l
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|tdir
operator|+
literal|1
argument_list|,
name|name
operator|+
name|l
argument_list|)
expr_stmt|;
name|tdir
index|[
literal|0
index|]
operator|=
literal|'~'
expr_stmt|;
return|return
operator|(
name|tdir
operator|)
return|;
block|}
else|else
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|Ultrix
argument_list|)
operator|)
end_if

begin_function
name|int
name|sysv_getc
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|result
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* USG and POSIX systems do not have killpg ().  But we use it in    jobs.c, nojobs.c and builtins.c. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_define
define|#
directive|define
name|pid_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _POSIX_VERSION */
end_comment

begin_function
name|int
name|killpg
parameter_list|(
name|pgrp
parameter_list|,
name|sig
parameter_list|)
name|pid_t
name|pgrp
decl_stmt|;
name|int
name|sig
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
name|kill
argument_list|(
operator|-
name|pgrp
argument_list|,
name|sig
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG  || _POSIX_VERSION */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		    Tilde Initialization and Expansion		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* If tilde_expand hasn't been able to expand the text, perhaps it    is a special shell expansion.  This function is installed as the    tilde_expansion_failure_hook.  It knows how to expand ~- and ~+. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|bash_tilde_expand
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
name|get_string_value
argument_list|(
literal|"OLDPWD"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|text
argument_list|,
literal|"+"
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
name|get_string_value
argument_list|(
literal|"PWD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|result
operator|=
name|savestring
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the tilde expander.  In Bash, we handle `~-' and `~+', as    well as handling special tilde prefixes; `:~" and `=~' are indications    that we should do tilde expansion. */
end_comment

begin_function
name|void
name|tilde_initialize
parameter_list|()
block|{
specifier|extern
name|Function
modifier|*
name|tilde_expansion_failure_hook
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|tilde_additional_prefixes
decl_stmt|,
modifier|*
modifier|*
name|tilde_additional_suffixes
decl_stmt|;
specifier|static
name|int
name|times_called
init|=
literal|0
decl_stmt|;
comment|/* Tell the tilde expander that we want a crack if it fails. */
name|tilde_expansion_failure_hook
operator|=
operator|(
name|Function
operator|*
operator|)
name|bash_tilde_expand
expr_stmt|;
comment|/* Tell the tilde expander about special strings which start a tilde      expansion, and the special strings that end one.  Only do this once.      tilde_initialize () is called from within bashline_reinitialize (). */
if|if
condition|(
name|times_called
operator|==
literal|0
condition|)
block|{
name|tilde_additional_prefixes
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tilde_additional_prefixes
index|[
literal|0
index|]
operator|=
literal|"=~"
expr_stmt|;
name|tilde_additional_prefixes
index|[
literal|1
index|]
operator|=
literal|":~"
expr_stmt|;
name|tilde_additional_prefixes
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|tilde_additional_suffixes
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tilde_additional_suffixes
index|[
literal|0
index|]
operator|=
literal|":"
expr_stmt|;
name|tilde_additional_suffixes
index|[
literal|1
index|]
operator|=
literal|"=~"
expr_stmt|;
name|tilde_additional_suffixes
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|times_called
operator|++
expr_stmt|;
block|}
end_function

end_unit

