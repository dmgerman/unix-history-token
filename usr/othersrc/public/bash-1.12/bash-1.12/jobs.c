begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* The thing that makes children, remembers them, and contains wait loops. */
end_comment

begin_comment
comment|/* This file works with both POSIX and BSD systems. */
end_comment

begin_comment
comment|/* Copyright (C) 1989 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* Something that can be ignored. */
end_comment

begin_define
define|#
directive|define
name|IGNORE_ARG
value|(char *)0
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"nojobs.c"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* JOB_CONTROL */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"trap.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_RESOURCE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_RESOURCE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _POSIX_VERSION */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"filecntl.h"
end_include

begin_comment
comment|/* Terminal handling stuff, to save and restore tty state. */
end_comment

begin_define
define|#
directive|define
name|NEW_TTY_DRIVER
end_define

begin_comment
comment|/* Define this if your output is getting swallowed.  It's a no-op on    machines with the termio or termios tty drivers. */
end_comment

begin_comment
comment|/* #define DRAIN_OUTPUT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TERMIOS_MISSING
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|NEW_TTY_DRIVER
end_undef

begin_define
define|#
directive|define
name|TERMIOS_TTY_DRIVER
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|Xenix
argument_list|)
operator|||
name|defined
argument_list|(
name|sgi
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|NEW_TTY_DRIVER
end_undef

begin_define
define|#
directive|define
name|TERMIO_TTY_DRIVER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG | hpux | Xenix | sgi */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_comment
comment|/* Include the right header file for the specific type of terminal    handler installed on this system. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TERMIO_TTY_DRIVER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
end_if

begin_comment
comment|/* For Sun workstations we undefine a couple of defines so that    the inclusion of termios.h won't cause complaints. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|ECHO
end_undef

begin_undef
undef|#
directive|undef
name|NOFLSH
end_undef

begin_undef
undef|#
directive|undef
name|TOSTOP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TERMIOS_TTY_DRIVER */
end_comment

begin_comment
comment|/* For the TIOCGPGRP and TIOCSPGRP ioctl parameters on HP-UX */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<bsdtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hpux&& !TERMIOS_TTY_DRIVER */
end_comment

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_comment
comment|/* Not all systems define errno in errno.h. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|interactive
decl_stmt|,
name|asynchronous_notification
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|shell_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The array of known jobs. */
end_comment

begin_decl_stmt
name|JOB
modifier|*
modifier|*
name|jobs
init|=
operator|(
name|JOB
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of slots currently allocated to JOBS. */
end_comment

begin_decl_stmt
name|int
name|job_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of additional slots to allocate when we run out. */
end_comment

begin_define
define|#
directive|define
name|JOB_SLOTS
value|5
end_define

begin_comment
comment|/* The controlling tty for this shell. */
end_comment

begin_decl_stmt
name|int
name|shell_tty
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The shell's process group. */
end_comment

begin_decl_stmt
name|pid_t
name|shell_pgrp
init|=
name|NO_PID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The terminal's process group. */
end_comment

begin_decl_stmt
name|pid_t
name|terminal_pgrp
init|=
name|NO_PID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The process group of the shell's parent. */
end_comment

begin_decl_stmt
name|pid_t
name|original_pgrp
init|=
name|NO_PID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The process group of the pipeline currently being made. */
end_comment

begin_decl_stmt
name|pid_t
name|pipeline_pgrp
init|=
operator|(
name|pid_t
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
end_if

begin_comment
comment|/* Pipes which each shell uses to communicate with the process group leader    until all of the processes in a pipeline have been started.  Then the    process leader is allowed to continue. */
end_comment

begin_decl_stmt
name|int
name|pgrp_pipe
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The job which is current; i.e. the one that `%+' stands for. */
end_comment

begin_decl_stmt
name|int
name|current_job
init|=
name|NO_JOB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The previous job; i.e. the one that `%-' stands for. */
end_comment

begin_decl_stmt
name|int
name|previous_job
init|=
name|NO_JOB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last child made by the shell.  */
end_comment

begin_decl_stmt
name|pid_t
name|last_made_pid
init|=
name|NO_PID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid of the last asynchronous child. */
end_comment

begin_decl_stmt
name|pid_t
name|last_asynchronous_pid
init|=
name|NO_PID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pipeline currently being built. */
end_comment

begin_decl_stmt
name|PROCESS
modifier|*
name|the_pipeline
init|=
operator|(
name|PROCESS
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is non-zero, do job control. */
end_comment

begin_decl_stmt
name|int
name|job_control
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call this when you start making children. */
end_comment

begin_decl_stmt
name|int
name|already_making_children
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions local to this file. */
end_comment

begin_function_decl
specifier|static
name|sighandler
name|flush_child
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|PROCESS
modifier|*
name|find_pipeline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|job_working_directory
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pid_t
name|last_pid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|set_new_line_discipline
argument_list|()
decl_stmt|,
name|map_over_jobs
argument_list|()
decl_stmt|,
name|last_running_job
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|most_recent_job_in_state
argument_list|()
decl_stmt|,
name|last_stopped_job
argument_list|()
decl_stmt|,
name|find_job
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notify_of_job_status
argument_list|()
decl_stmt|,
name|cleanup_dead_jobs
argument_list|()
decl_stmt|,
name|discard_pipeline
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_process
argument_list|()
decl_stmt|,
name|set_current_job
argument_list|()
decl_stmt|,
name|reset_current
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pretty_print_job
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|pipe_read
argument_list|()
decl_stmt|,
name|pipe_close
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_comment
comment|/* These are definitions to map POSIX 1003.1 functions onto existing BSD    library functions and system calls. */
end_comment

begin_define
define|#
directive|define
name|setpgid
parameter_list|(
name|pid
parameter_list|,
name|pgrp
parameter_list|)
value|setpgrp (pid, pgrp)
end_define

begin_define
define|#
directive|define
name|tcsetpgrp
parameter_list|(
name|fd
parameter_list|,
name|pgrp
parameter_list|)
value|ioctl ((fd), TIOCSPGRP,&(pgrp))
end_define

begin_function
name|pid_t
name|tcgetpgrp
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|pid_t
name|pgrp
decl_stmt|;
comment|/* ioctl will handle setting errno correctly. */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|pgrp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|pgrp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform OPERATION on NEWSET, perhaps leaving information in OLDSET. */
end_comment

begin_macro
name|sigprocmask
argument_list|(
argument|operation
argument_list|,
argument|newset
argument_list|,
argument|oldset
argument_list|)
end_macro

begin_decl_stmt
name|int
name|operation
decl_stmt|,
modifier|*
name|newset
decl_stmt|,
modifier|*
name|oldset
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|SIG_BLOCK
case|:
operator|*
name|oldset
operator|=
name|sigblock
argument_list|(
operator|*
name|newset
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIG_SETMASK
case|:
name|sigsetmask
argument_list|(
operator|*
name|newset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|report_error
argument_list|(
literal|"Bad code in jobs.c: sigprocmask"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_comment
comment|/* Return the working directory for the current process. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|job_working_directory
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|get_working_directory
parameter_list|()
function_decl|;
name|char
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|get_string_value
argument_list|(
literal|"PWD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|dir
argument_list|)
operator|)
return|;
name|dir
operator|=
name|get_working_directory
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
return|return
operator|(
name|dir
operator|)
return|;
return|return
operator|(
name|savestring
argument_list|(
literal|"<unknown>"
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|making_children
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|already_making_children
condition|)
return|return;
name|already_making_children
operator|=
literal|1
expr_stmt|;
name|start_pipeline
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|stop_making_children
argument_list|()
end_macro

begin_block
block|{
name|already_making_children
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Start building a pipeline.  */
end_comment

begin_macro
name|start_pipeline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|the_pipeline
condition|)
block|{
name|discard_pipeline
argument_list|(
name|the_pipeline
argument_list|)
expr_stmt|;
name|the_pipeline
operator|=
operator|(
name|PROCESS
operator|*
operator|)
name|NULL
expr_stmt|;
name|pipeline_pgrp
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
name|pipe_close
argument_list|(
name|pgrp_pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
if|if
condition|(
name|job_control
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pgrp_pipe
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|report_error
argument_list|(
literal|"start_pipeline: pgrp pipe"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Stop building a pipeline.  Install the process list in the job array.    This returns the index of the newly installed job.    DEFERRED is a command structure to be executed upon satisfactory    execution exit of this pipeline. */
end_comment

begin_function
name|int
name|stop_pipeline
parameter_list|(
name|async
parameter_list|,
name|deferred
parameter_list|)
name|int
name|async
decl_stmt|;
name|COMMAND
modifier|*
name|deferred
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|JOB
modifier|*
name|newjob
init|=
operator|(
name|JOB
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|get_string_value
parameter_list|()
function_decl|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
comment|/* The parent closes the process group synchronization pipe. */
name|pipe_close
argument_list|(
name|pgrp_pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cleanup_dead_jobs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|job_slots
condition|)
block|{
name|jobs
operator|=
operator|(
name|JOB
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|job_slots
operator|=
name|JOB_SLOTS
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|JOB
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now blank out these new entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
name|jobs
index|[
name|i
index|]
operator|=
operator|(
name|JOB
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Scan from the last slot backward, looking for the next free one. */
for|for
control|(
name|i
operator|=
name|job_slots
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|jobs
index|[
name|i
operator|-
literal|1
index|]
condition|)
break|break;
comment|/* Do we need more room? */
if|if
condition|(
name|i
operator|==
name|job_slots
condition|)
block|{
name|jobs
operator|=
operator|(
name|JOB
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|jobs
argument_list|,
operator|(
literal|1
operator|+
operator|(
name|job_slots
operator|+=
name|JOB_SLOTS
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|JOB
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|job_slots
condition|;
name|j
operator|++
control|)
name|jobs
index|[
name|j
index|]
operator|=
operator|(
name|JOB
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Add the current pipeline to the job list. */
if|if
condition|(
name|the_pipeline
condition|)
block|{
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|newjob
operator|=
operator|(
name|JOB
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|JOB
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|the_pipeline
init|;
name|p
operator|->
name|next
operator|!=
name|the_pipeline
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
operator|(
name|PROCESS
operator|*
operator|)
name|NULL
expr_stmt|;
name|newjob
operator|->
name|pipe
operator|=
operator|(
name|PROCESS
operator|*
operator|)
name|reverse_list
argument_list|(
name|the_pipeline
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|newjob
operator|->
name|pipe
init|;
name|p
operator|->
name|next
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|newjob
operator|->
name|pipe
expr_stmt|;
name|the_pipeline
operator|=
operator|(
name|PROCESS
operator|*
operator|)
name|NULL
expr_stmt|;
name|newjob
operator|->
name|pgrp
operator|=
name|pipeline_pgrp
expr_stmt|;
name|pipeline_pgrp
operator|=
literal|0
expr_stmt|;
comment|/* Flag to see if in another pgrp. */
name|newjob
operator|->
name|job_control
operator|=
name|job_control
expr_stmt|;
comment|/* Set the state of this pipeline. */
block|{
specifier|register
name|PROCESS
modifier|*
name|p
init|=
name|newjob
operator|->
name|pipe
decl_stmt|;
specifier|register
name|int
name|any_alive
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|any_stopped
init|=
literal|0
decl_stmt|;
do|do
block|{
name|any_alive
operator||=
name|p
operator|->
name|running
expr_stmt|;
name|any_stopped
operator||=
name|WIFSTOPPED
argument_list|(
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|newjob
operator|->
name|pipe
condition|)
do|;
if|if
condition|(
name|any_alive
condition|)
block|{
name|newjob
operator|->
name|state
operator|=
name|JRUNNING
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|any_stopped
condition|)
name|newjob
operator|->
name|state
operator|=
name|JSTOPPED
expr_stmt|;
else|else
name|newjob
operator|->
name|state
operator|=
name|JDEAD
expr_stmt|;
block|}
block|}
name|newjob
operator|->
name|notified
operator|=
literal|0
expr_stmt|;
name|newjob
operator|->
name|wd
operator|=
name|job_working_directory
argument_list|()
expr_stmt|;
name|newjob
operator|->
name|deferred
operator|=
name|deferred
expr_stmt|;
name|jobs
index|[
name|i
index|]
operator|=
name|newjob
expr_stmt|;
block|}
if|if
condition|(
name|async
condition|)
block|{
if|if
condition|(
name|newjob
condition|)
name|newjob
operator|->
name|foreground
operator|=
literal|0
expr_stmt|;
name|reset_current
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newjob
condition|)
block|{
name|newjob
operator|->
name|foreground
operator|=
literal|1
expr_stmt|;
comment|/* 	   *		!!!!! NOTE !!!!!  (chet@ins.cwru.edu) 	   * 	   * The currently-accepted job control wisdom says to set the 	   * terminal's process group n+1 times in an n-step pipeline: 	   * once in the parent and once in each child.  This is where 	   * the parent gives it away. 	   * 	   */
if|if
condition|(
name|job_control
operator|&&
name|newjob
operator|->
name|pgrp
condition|)
name|give_terminal_to
argument_list|(
name|newjob
operator|->
name|pgrp
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_making_children
argument_list|()
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return
operator|(
name|current_job
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete all DEAD jobs that the user had received notification about. */
end_comment

begin_function
specifier|static
name|void
name|cleanup_dead_jobs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|jobs
index|[
name|i
index|]
operator|&&
name|JOBSTATE
argument_list|(
name|i
argument_list|)
operator|==
name|JDEAD
operator|&&
name|jobs
index|[
name|i
index|]
operator|->
name|notified
condition|)
name|delete_job
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete the job at INDEX from the job list. */
end_comment

begin_macro
name|delete_job
argument_list|(
argument|index
argument_list|)
end_macro

begin_decl_stmt
name|int
name|index
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|JOB
modifier|*
name|temp
init|=
name|jobs
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|current_job
operator|||
name|index
operator|==
name|previous_job
condition|)
name|reset_current
argument_list|()
expr_stmt|;
name|jobs
index|[
name|index
index|]
operator|=
operator|(
name|JOB
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|wd
argument_list|)
expr_stmt|;
name|discard_pipeline
argument_list|(
name|temp
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|deferred
condition|)
name|dispose_command
argument_list|(
name|temp
operator|->
name|deferred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Get rid of the data structure associated with a process chain. */
end_comment

begin_function
specifier|static
name|void
name|discard_pipeline
parameter_list|(
name|chain
parameter_list|)
specifier|register
name|PROCESS
modifier|*
name|chain
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|this
operator|=
name|chain
expr_stmt|;
do|do
block|{
name|next
operator|=
name|this
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|command
condition|)
name|free
argument_list|(
name|this
operator|->
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|this
operator|!=
name|chain
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Add this process to the chain being built in the_pipeline.    NAME is the command string that will be exec'ed later.    PID is the process id of the child. */
end_comment

begin_function
specifier|static
name|void
name|add_process
parameter_list|(
name|name
parameter_list|,
name|pid
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
block|{
name|PROCESS
modifier|*
name|t
init|=
operator|(
name|PROCESS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PROCESS
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|->
name|next
operator|=
name|the_pipeline
expr_stmt|;
name|t
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|WSTATUS
argument_list|(
name|t
operator|->
name|status
argument_list|)
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|command
operator|=
name|name
expr_stmt|;
name|the_pipeline
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|next
operator|)
condition|)
name|t
operator|->
name|next
operator|=
name|t
expr_stmt|;
else|else
block|{
specifier|register
name|PROCESS
modifier|*
name|p
init|=
name|t
operator|->
name|next
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|next
operator|!=
name|t
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Map FUNC over the list of jobs.  If FUNC returns non-zero,    then it is time to stop mapping, and that is the return value    for map_over_jobs.  FUNC is called with a JOB, arg1, arg2,    and INDEX. */
end_comment

begin_function
specifier|static
name|int
name|map_over_jobs
parameter_list|(
name|func
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|Function
modifier|*
name|func
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|i
index|]
condition|)
block|{
name|int
name|result
init|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|jobs
index|[
name|i
index|]
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Cause all the jobs in the current pipeline to exit. */
end_comment

begin_macro
name|terminate_current_pipeline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|pipeline_pgrp
operator|&&
name|pipeline_pgrp
operator|!=
name|shell_pgrp
condition|)
block|{
name|killpg
argument_list|(
name|pipeline_pgrp
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|killpg
argument_list|(
name|pipeline_pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Cause all stopped jobs to exit. */
end_comment

begin_function
name|void
name|terminate_stopped_jobs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|i
index|]
operator|&&
operator|(
name|JOBSTATE
argument_list|(
name|i
argument_list|)
operator|==
name|JSTOPPED
operator|)
condition|)
block|{
name|killpg
argument_list|(
name|jobs
index|[
name|i
index|]
operator|->
name|pgrp
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|killpg
argument_list|(
name|jobs
index|[
name|i
index|]
operator|->
name|pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Cause all jobs, running or stopped, to receive a hangup signal. */
end_comment

begin_function
name|void
name|hangup_all_jobs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|i
index|]
condition|)
block|{
name|killpg
argument_list|(
name|jobs
index|[
name|i
index|]
operator|->
name|pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|JOBSTATE
argument_list|(
name|i
argument_list|)
operator|==
name|JSTOPPED
condition|)
name|killpg
argument_list|(
name|jobs
index|[
name|i
index|]
operator|->
name|pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|kill_current_pipeline
argument_list|()
end_macro

begin_block
block|{
name|stop_making_children
argument_list|()
expr_stmt|;
name|start_pipeline
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the pipeline that PID belongs to.  Note that the pipeline    doesn't have to belong to a job. */
end_comment

begin_function
specifier|static
name|PROCESS
modifier|*
name|find_pipeline
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
name|int
name|job
decl_stmt|;
comment|/* See if this process is in the pipeline that we are building. */
if|if
condition|(
name|the_pipeline
condition|)
block|{
specifier|register
name|PROCESS
modifier|*
name|p
init|=
name|the_pipeline
decl_stmt|;
do|do
block|{
comment|/* Return it if we found it. */
if|if
condition|(
name|p
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|the_pipeline
condition|)
do|;
block|}
name|job
operator|=
name|find_job
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|==
name|NO_JOB
condition|)
return|return
operator|(
operator|(
name|PROCESS
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the job index that PID belongs to, or NO_JOB if it doesn't    belong to any job. */
end_comment

begin_function
specifier|static
name|int
name|find_job
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|i
index|]
condition|)
block|{
name|p
operator|=
name|jobs
index|[
name|i
index|]
operator|->
name|pipe
expr_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|jobs
index|[
name|i
index|]
operator|->
name|pipe
condition|)
do|;
block|}
block|}
return|return
operator|(
name|NO_JOB
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print descriptive information about the job with leader pid PID. */
end_comment

begin_macro
name|describe_pid
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|pid_t
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|job
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
name|job
operator|=
name|find_job
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|!=
name|NO_JOB
condition|)
name|printf
argument_list|(
literal|"[%d] %d\n"
argument_list|,
name|job
operator|+
literal|1
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|programming_error
argument_list|(
literal|"describe_pid: No such pid (%d)!\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This is the way to print out information on a job if you    know the index.  FORMAT is:      JLIST_NORMAL)   [1]+ Running	   emacs     JLIST_LONG  )   [1]+ 2378 Running      emacs     -1	  )   [1]+ 2378	      emacs      JLIST_NORMAL)   [1]+ Stopped	   ls | more     JLIST_LONG  )   [1]+ 2369 Stopped      ls 			 2367	    | more     JLIST_PID_ONLY) 	Just list the pid of the process group leader (really 	the process group).     JLIST_CHANGED_ONLY) 	Use format JLIST_NORMAL, but list only jobs about which 	the user has not been notified. */
end_comment

begin_function
specifier|static
name|void
name|pretty_print_job
parameter_list|(
name|index
parameter_list|,
name|format
parameter_list|,
name|stream
parameter_list|)
name|int
name|index
decl_stmt|,
name|format
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|name_padding
decl_stmt|;
name|char
name|retcode_name_buffer
index|[
literal|20
index|]
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
comment|/* Format only pid information about the process group leader? */
if|if
condition|(
name|format
operator|==
name|JLIST_PID_ONLY
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d\n"
argument_list|,
name|jobs
index|[
name|index
index|]
operator|->
name|pipe
operator|->
name|pid
argument_list|)
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format
operator|==
name|JLIST_CHANGED_ONLY
condition|)
block|{
if|if
condition|(
name|jobs
index|[
name|index
index|]
operator|->
name|notified
operator|==
literal|1
condition|)
block|{
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return;
block|}
name|format
operator|=
name|JLIST_STANDARD
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"[%d]%c "
argument_list|,
name|index
operator|+
literal|1
argument_list|,
operator|(
name|index
operator|==
name|current_job
operator|)
condition|?
literal|'+'
else|:
operator|(
name|index
operator|==
name|previous_job
operator|)
condition|?
literal|'-'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|first
operator|=
name|last
operator|=
name|p
operator|=
name|jobs
index|[
name|index
index|]
operator|->
name|pipe
expr_stmt|;
while|while
condition|(
name|last
operator|->
name|next
operator|!=
name|first
condition|)
name|last
operator|=
name|last
operator|->
name|next
expr_stmt|;
comment|/* We have printed information about this job.  When the job's      status changes, flush_child () sets the notification flag to 0. */
name|jobs
index|[
name|index
index|]
operator|->
name|notified
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|!=
name|first
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|format
condition|?
literal|"     "
else|:
literal|" |"
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|>
operator|-
literal|1
condition|)
block|{
name|PROCESS
modifier|*
name|show
init|=
name|format
condition|?
name|p
else|:
name|last
decl_stmt|;
name|char
modifier|*
name|temp
init|=
literal|"Done"
decl_stmt|;
if|if
condition|(
name|JOBSTATE
argument_list|(
name|index
argument_list|)
operator|==
name|JSTOPPED
operator|&&
operator|!
name|format
condition|)
name|temp
operator|=
literal|"Stopped"
expr_stmt|;
if|if
condition|(
name|JOBSTATE
argument_list|(
name|index
argument_list|)
operator|==
name|JRUNNING
condition|)
name|temp
operator|=
literal|"Running"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|show
operator|->
name|status
argument_list|)
condition|)
name|temp
operator|=
name|sys_siglist
index|[
name|WSTOPSIG
argument_list|(
name|show
operator|->
name|status
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|show
operator|->
name|status
argument_list|)
condition|)
name|temp
operator|=
name|sys_siglist
index|[
name|WTERMSIG
argument_list|(
name|show
operator|->
name|status
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|show
operator|->
name|status
argument_list|)
condition|)
block|{
name|temp
operator|=
name|retcode_name_buffer
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Exit %d"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|show
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
literal|"Unknown status"
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|first
condition|)
block|{
if|if
condition|(
name|format
condition|)
block|{
if|if
condition|(
name|show
operator|->
name|running
operator|==
name|first
operator|->
name|running
operator|&&
name|WSTATUS
argument_list|(
name|show
operator|->
name|status
argument_list|)
operator|==
name|WSTATUS
argument_list|(
name|first
operator|->
name|status
argument_list|)
condition|)
name|temp
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|temp
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
condition|)
name|name_padding
operator|=
name|LONGEST_SIGNAL_DESC
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|name_padding
operator|=
name|LONGEST_SIGNAL_DESC
operator|-
literal|2
expr_stmt|;
comment|/* strlen ("| ") */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%*s"
argument_list|,
name|name_padding
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|WIFSTOPPED
argument_list|(
name|show
operator|->
name|status
argument_list|)
operator|)
operator|&&
operator|(
name|WIFCORED
argument_list|(
name|show
operator|->
name|status
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"(core dumped) "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|first
operator|&&
name|format
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"| "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|last
condition|)
block|{
name|char
modifier|*
name|wd
init|=
name|job_working_directory
argument_list|()
decl_stmt|;
if|if
condition|(
name|JOBSTATE
argument_list|(
name|index
argument_list|)
operator|==
name|JRUNNING
operator|&&
name|jobs
index|[
name|index
index|]
operator|->
name|foreground
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|wd
argument_list|,
name|jobs
index|[
name|index
index|]
operator|->
name|wd
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  (wd: %s)"
argument_list|,
name|polite_directory_format
argument_list|(
name|jobs
index|[
name|index
index|]
operator|->
name|wd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|||
operator|(
name|p
operator|==
name|last
operator|)
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|last
condition|)
break|break;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|list_one_job
parameter_list|(
name|job
parameter_list|,
name|format
parameter_list|,
name|ignore
parameter_list|,
name|index
parameter_list|)
name|JOB
modifier|*
name|job
decl_stmt|;
name|int
name|format
decl_stmt|,
name|ignore
decl_stmt|,
name|index
decl_stmt|;
block|{
name|pretty_print_job
argument_list|(
name|index
argument_list|,
name|format
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* List jobs.  If FORMAT is non-zero, then the long form of the information    is printed, else just a short version. */
end_comment

begin_macro
name|list_jobs
argument_list|(
argument|format
argument_list|)
end_macro

begin_decl_stmt
name|int
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cleanup_dead_jobs
argument_list|()
expr_stmt|;
name|map_over_jobs
argument_list|(
name|list_one_job
argument_list|,
name|format
argument_list|,
operator|(
name|int
operator|)
name|IGNORE_ARG
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Fork, handling errors.  Returns the pid of the newly made child, or 0.    COMMAND is just for remembering the name of the command; we don't do    anything else with it.  ASYNC_P says what to do with the tty.  If    non-zero, then don't give it away. */
end_comment

begin_function
name|pid_t
name|make_child
parameter_list|(
name|command
parameter_list|,
name|async_p
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|async_p
decl_stmt|;
block|{
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|oset
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
name|making_children
argument_list|()
expr_stmt|;
comment|/* Make new environment array if neccessary. */
name|maybe_make_export_env
argument_list|()
expr_stmt|;
comment|/* Create the child, handle severe errors. */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|report_error
argument_list|(
literal|"fork: %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kill all of the processes in the current pipeline. */
name|terminate_current_pipeline
argument_list|()
expr_stmt|;
comment|/* Discard the current pipeline, if any. */
if|if
condition|(
name|the_pipeline
condition|)
name|kill_current_pipeline
argument_list|()
expr_stmt|;
name|throw_to_top_level
argument_list|()
expr_stmt|;
comment|/* Reset signals, etc. */
block|}
if|if
condition|(
operator|!
name|pid
condition|)
block|{
comment|/* In the child.  Give this child the right process group, set the 	 signals to the default state for a new process. */
specifier|extern
name|sigset_t
name|top_level_mask
decl_stmt|;
name|pid_t
name|mine
init|=
name|getpid
argument_list|()
decl_stmt|;
comment|/* Cancel traps, in trap.c. */
name|restore_original_signals
argument_list|()
expr_stmt|;
comment|/* Restore top-level signal mask. */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|top_level_mask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|job_control
condition|)
block|{
comment|/* All processes in this pipeline belong in the same 	     process group. */
if|if
condition|(
operator|!
name|pipeline_pgrp
condition|)
comment|/* Then this is the first child. */
name|pipeline_pgrp
operator|=
name|mine
expr_stmt|;
comment|/* Check for running command in backquotes. */
if|if
condition|(
name|pipeline_pgrp
operator|==
name|shell_pgrp
condition|)
block|{
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
comment|/* Set the process group before trying to mess with the terminal's 	     process group.  This is mandated by POSIX. */
comment|/* This is in accordance with the Posix 1003.1 standard, 	     section B.7.2.4, which says that trying to set the terminal 	     process group with tcsetpgrp() to an unused pgrp value (like 	     this would have for the first child) is an error.  Section 	     B.4.3.3, p. 237 also covers this, in the context of job control 	     shells. */
if|if
condition|(
name|setpgid
argument_list|(
name|mine
argument_list|,
name|pipeline_pgrp
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: child setpgid (%d to %d) error %d: %s\n"
argument_list|,
name|shell_name
argument_list|,
name|mine
argument_list|,
name|pipeline_pgrp
argument_list|,
name|errno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
if|if
condition|(
name|pipeline_pgrp
operator|==
name|mine
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|!
name|async_p
condition|)
name|give_terminal_to
argument_list|(
name|pipeline_pgrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
name|pipe_read
argument_list|(
name|pgrp_pipe
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
comment|/* Without job control... */
block|{
if|if
condition|(
operator|!
name|pipeline_pgrp
condition|)
name|pipeline_pgrp
operator|=
name|shell_pgrp
expr_stmt|;
comment|/* If these signals are set to SIG_DFL, we encounter the curious 	     situation of an interactive ^Z to a running process *working* 	     and stopping the process, but being unable to do anything with 	     that process to change its state.  On the other hand, if they 	     are set to SIG_IGN, jobs started from scripts do not stop when 	     the shell running the script gets a SIGTSTP and stops. */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|async_p
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
comment|/* Release the process group pipe, since our call to setpgid () 	 is done.  The last call to pipe_close is done in stop_pipeline. */
name|pipe_close
argument_list|(
name|pgrp_pipe
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PGRP_PIPE */
if|if
condition|(
name|async_p
condition|)
name|last_asynchronous_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* In the parent.  Remember the pid of the child just created 	 as the proper pgrp if this is the first child. */
if|if
condition|(
name|job_control
condition|)
block|{
if|if
condition|(
operator|!
name|pipeline_pgrp
condition|)
block|{
name|pipeline_pgrp
operator|=
name|pid
expr_stmt|;
comment|/* Don't twiddle terminal pgrps in the parent!  This is the bug, 		 not the good thing of twiddling them in the child! */
comment|/* give_terminal_to (pipeline_pgrp); */
block|}
comment|/* This is done on the recommendation of the Rationale section of 	     the POSIX 1003.1 standard, where it discusses job control and 	     shells.  It is done to avoid possible race conditions. (Ref. 	     1003.1 Rationale, section B.4.3.3, page 236). */
name|setpgid
argument_list|(
name|pid
argument_list|,
name|pipeline_pgrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pipeline_pgrp
condition|)
name|pipeline_pgrp
operator|=
name|shell_pgrp
expr_stmt|;
block|}
comment|/* Place all processes into the jobs array regardless of the 	 state of job_control. */
name|add_process
argument_list|(
name|command
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|async_p
condition|)
name|last_asynchronous_pid
operator|=
name|pid
expr_stmt|;
name|last_made_pid
operator|=
name|pid
expr_stmt|;
comment|/* Unblock SIGINT and SIGCHLD. */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* When we end a job abnormally, or if we stop a job, we set the tty to the    state kept in here.  When a job ends normally, we set the state in here    to the state of the tty. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|shell_tty_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|shell_tchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|shell_ltchars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEW_TTY_DRIVER */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TERMIO_TTY_DRIVER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|termio
name|shell_tty_info
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TERMIO_TTY_DRIVER */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|termios
name|shell_tty_info
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TERMIOS_TTY_DRIVER */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
operator|&&
name|defined
argument_list|(
name|DRAIN_OUTPUT
argument_list|)
end_if

begin_comment
comment|/* Since the BSD tty driver does not allow us to change the tty modes    while simultaneously waiting for output to drain and preserving    typeahead, we have to drain the output ourselves before calling    ioctl.  We cheat by finding the length of the output queue, and    using select to wait for an appropriate length of time.  This is    a hack, and should be labeled as such (it's a hastily-adapted    mutation of a `usleep' implementation).  It's only reason for    existing is the flaw in the BSD tty driver. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ttspeeds
index|[]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|75
block|,
literal|110
block|,
literal|134
block|,
literal|150
block|,
literal|200
block|,
literal|300
block|,
literal|600
block|,
literal|1200
block|,
literal|1800
block|,
literal|2400
block|,
literal|4800
block|,
literal|9600
block|,
literal|19200
block|,
literal|38400
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|draino
parameter_list|(
name|fd
parameter_list|,
name|ospeed
parameter_list|)
name|int
name|fd
decl_stmt|,
name|ospeed
decl_stmt|;
block|{
specifier|register
name|int
name|delay
init|=
name|ttspeeds
index|[
name|ospeed
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|delay
condition|)
return|return;
while|while
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCOUTQ
argument_list|,
operator|&
name|n
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|>
operator|(
name|delay
operator|/
literal|100
operator|)
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|n
operator|*=
literal|10
expr_stmt|;
comment|/* 2 bits more for conservativeness. */
name|tv
operator|.
name|tv_sec
operator|=
name|n
operator|/
name|delay
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
name|n
operator|%
name|delay
operator|)
operator|*
literal|1000000
operator|)
operator|/
name|delay
expr_stmt|;
name|select
argument_list|(
name|fd
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEW_TTY_DRIVER&& DRAIN_OUTPUT */
end_comment

begin_comment
comment|/* Return the fd from which we are actually getting input.  Should be    inlined by the compiler. */
end_comment

begin_function
specifier|static
name|int
name|input_tty
parameter_list|()
block|{
name|int
name|tty
init|=
name|shell_tty
decl_stmt|;
if|if
condition|(
name|tty
operator|==
operator|-
literal|1
condition|)
name|tty
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
return|return
operator|(
name|tty
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fill the contents of shell_tty_info with the current tty info. */
end_comment

begin_macro
name|get_tty_state
argument_list|()
end_macro

begin_block
block|{
name|int
name|tty
init|=
name|input_tty
argument_list|()
decl_stmt|;
if|if
condition|(
name|tty
operator|!=
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|shell_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|shell_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_TTY_DRIVER */
if|#
directive|if
name|defined
argument_list|(
name|TERMIO_TTY_DRIVER
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TERMIO_TTY_DRIVER */
if|#
directive|if
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
if|if
condition|(
name|tcgetattr
argument_list|(
name|tty
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
operator|<
literal|0
condition|)
block|{
specifier|extern
name|int
name|shell_level
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: [%d: %d] tcgetattr: %s\n"
argument_list|,
name|shell_name
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|shell_level
argument_list|,
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TERMIOS_TTY_DRIVER */
block|}
block|}
end_block

begin_comment
comment|/* Make the current tty use the state in shell_tty_info. */
end_comment

begin_macro
name|set_tty_state
argument_list|()
end_macro

begin_block
block|{
name|int
name|tty
init|=
name|input_tty
argument_list|()
decl_stmt|;
if|if
condition|(
name|tty
operator|!=
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|DRAIN_OUTPUT
argument_list|)
name|draino
argument_list|(
name|tty
argument_list|,
name|shell_tty_info
operator|.
name|sg_ospeed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DRAIN_OUTPUT */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|shell_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|shell_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_TTY_DRIVER */
if|#
directive|if
name|defined
argument_list|(
name|TERMIO_TTY_DRIVER
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TERMIO_TTY_DRIVER */
if|#
directive|if
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
if|if
condition|(
name|tcsetattr
argument_list|(
name|tty
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
operator|<
literal|0
condition|)
block|{
specifier|extern
name|int
name|shell_level
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: [%d: %d] tcsetattr: %s\n"
argument_list|,
name|shell_name
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|shell_level
argument_list|,
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TERMIOS_TTY_DRIVER */
block|}
block|}
end_block

begin_comment
comment|/* Given an index into the jobs array JOB, return the pid of the last    process in that job's pipeline.  This is the one whose exit status    counts. */
end_comment

begin_function
specifier|static
name|pid_t
name|last_pid
parameter_list|(
name|job
parameter_list|)
name|int
name|job
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
name|p
operator|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for a particular child of the shell to finish executing.    This low-level function prints an error message if PID is not    a child of this shell.  It returns -1 if it fails, or 0 if not. */
end_comment

begin_function
name|int
name|wait_for_single_pid
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|child
decl_stmt|;
name|child
operator|=
name|find_pipeline
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
condition|)
block|{
name|report_error
argument_list|(
literal|"wait: pid %d is not a child of this shell"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|127
operator|)
return|;
block|}
return|return
operator|(
name|wait_for
argument_list|(
name|pid
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for all of the backgrounds of this shell to finish. */
end_comment

begin_function
name|void
name|wait_for_background_pids
parameter_list|()
block|{
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|jobs
index|[
name|i
index|]
operator|&&
operator|(
name|JOBSTATE
argument_list|(
name|i
argument_list|)
operator|==
name|JRUNNING
operator|)
operator|&&
operator|!
operator|(
name|jobs
index|[
name|i
index|]
operator|->
name|foreground
operator|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|jobs
index|[
name|i
index|]
operator|&&
operator|(
name|JOBSTATE
argument_list|(
name|i
argument_list|)
operator|==
name|JRUNNING
operator|)
operator|&&
operator|!
name|jobs
index|[
name|i
index|]
operator|->
name|foreground
condition|)
block|{
name|pid_t
name|pid
init|=
name|last_pid
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
name|wait_for_single_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Wait for pid (one of our children) to terminate, then    return the termination state. */
end_comment

begin_function
name|int
name|wait_for
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
specifier|extern
name|int
name|last_command_exit_value
decl_stmt|;
name|int
name|job
decl_stmt|,
name|termination_state
decl_stmt|;
specifier|register
name|PROCESS
modifier|*
name|child
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
name|termination_state
operator|=
name|last_command_exit_value
expr_stmt|;
comment|/* If we say wait_for (), then we have a record of this child somewhere.      If this child and all of its peers are not running, then don't      sigpause (), since there is no need to. */
name|wait_loop
label|:
comment|/* If the shell is running interactively, and the shell is the foreground      process (e.g. executing a `wait' command) then let the user C-c out. */
if|if
condition|(
name|interactive
operator|&&
operator|(
name|terminal_pgrp
operator|==
name|shell_pgrp
operator|)
condition|)
name|QUIT
expr_stmt|;
name|child
operator|=
name|find_pipeline
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
condition|)
block|{
name|give_terminal_to
argument_list|(
name|shell_pgrp
argument_list|)
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
name|programming_error
argument_list|(
literal|"wait_for: No record of pid %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
comment|/* If this child is part of a job, then we are really waiting for the      job to finish.  Otherwise, we are waiting for the child to finish. */
name|job
operator|=
name|find_job
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|!=
name|NO_JOB
condition|)
block|{
specifier|register
name|int
name|job_state
init|=
literal|0
decl_stmt|,
name|any_stopped
init|=
literal|0
decl_stmt|;
specifier|register
name|PROCESS
modifier|*
name|p
init|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
decl_stmt|;
do|do
block|{
name|job_state
operator||=
name|p
operator|->
name|running
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|running
condition|)
name|any_stopped
operator||=
name|WIFSTOPPED
argument_list|(
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|)
do|;
if|if
condition|(
name|job_state
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|any_stopped
condition|)
name|jobs
index|[
name|job
index|]
operator|->
name|state
operator|=
name|JSTOPPED
expr_stmt|;
else|else
name|jobs
index|[
name|job
index|]
operator|->
name|state
operator|=
name|JDEAD
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|running
operator|||
operator|(
operator|(
name|job
operator|!=
name|NO_JOB
operator|)
operator|&&
operator|(
name|JOBSTATE
argument_list|(
name|job
argument_list|)
operator|==
name|JRUNNING
operator|)
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCO
argument_list|)
name|sigset_t
name|set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigsuspend
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SCO Unix */
name|struct
name|sigaction
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
expr_stmt|;
name|flush_child
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|oact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SCO */
goto|goto
name|wait_loop
goto|;
block|}
comment|/* The exit state of the command is either the termination state of the      child, or the termination state of the job.  If a job, the status      of the last child in the pipeline is the significant one. */
if|if
condition|(
name|job
operator|!=
name|NO_JOB
condition|)
block|{
specifier|register
name|PROCESS
modifier|*
name|p
init|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|next
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|p
operator|->
name|status
argument_list|)
condition|)
name|termination_state
operator|=
literal|128
operator|+
name|WTERMSIG
argument_list|(
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|p
operator|->
name|status
argument_list|)
condition|)
name|termination_state
operator|=
name|WEXITSTATUS
argument_list|(
name|p
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|child
operator|->
name|status
argument_list|)
condition|)
name|termination_state
operator|=
literal|128
operator|+
name|WTERMSIG
argument_list|(
name|child
operator|->
name|status
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|child
operator|->
name|status
argument_list|)
condition|)
name|termination_state
operator|=
name|WEXITSTATUS
argument_list|(
name|child
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|==
name|NO_JOB
operator|||
name|jobs
index|[
name|job
index|]
operator|->
name|job_control
condition|)
name|give_terminal_to
argument_list|(
name|shell_pgrp
argument_list|)
expr_stmt|;
comment|/* If the command did not exit cleanly, or the job is just      being stopped, then reset the tty state back to what it      was before this command.  Do this only if the shell is      interactive. */
if|if
condition|(
name|job
operator|!=
name|NO_JOB
operator|&&
name|interactive
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|child
operator|->
name|status
argument_list|)
operator|||
name|WIFSTOPPED
argument_list|(
name|child
operator|->
name|status
argument_list|)
condition|)
name|set_tty_state
argument_list|()
expr_stmt|;
else|else
name|get_tty_state
argument_list|()
expr_stmt|;
name|notify_and_cleanup
argument_list|()
expr_stmt|;
block|}
name|wait_exit
label|:
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return
operator|(
name|termination_state
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for the last process in the pipeline for JOB. */
end_comment

begin_function
name|int
name|wait_for_job
parameter_list|(
name|job
parameter_list|)
name|int
name|job
decl_stmt|;
block|{
name|pid_t
name|pid
init|=
name|last_pid
argument_list|(
name|job
argument_list|)
decl_stmt|;
return|return
operator|(
name|wait_for
argument_list|(
name|pid
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print info about dead jobs, and then delete them from the list    of known jobs. */
end_comment

begin_macro
name|notify_and_cleanup
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|interactive
condition|)
name|notify_of_job_status
argument_list|()
expr_stmt|;
name|cleanup_dead_jobs
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the next closest (chronologically) job to JOB which is in    STATE.  STATE can be JSTOPPED, JRUNNING.  NO_JOB is returned if    there is no next recent job. */
end_comment

begin_function
specifier|static
name|int
name|most_recent_job_in_state
parameter_list|(
name|job
parameter_list|,
name|state
parameter_list|)
name|int
name|job
decl_stmt|;
name|JOB_STATE
name|state
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|job
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|JOBSTATE
argument_list|(
name|i
argument_list|)
operator|==
name|state
condition|)
block|{
comment|/* Found it! */
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
block|}
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO_JOB
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the newest *stopped* job older than JOB, or NO_JOB if not    found. */
end_comment

begin_function
specifier|static
name|int
name|last_stopped_job
parameter_list|(
name|job
parameter_list|)
name|int
name|job
decl_stmt|;
block|{
return|return
operator|(
name|most_recent_job_in_state
argument_list|(
name|job
argument_list|,
name|JSTOPPED
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the newest *running* job older than JOB, or NO_JOB if not    found. */
end_comment

begin_function
specifier|static
name|int
name|last_running_job
parameter_list|(
name|job
parameter_list|)
name|int
name|job
decl_stmt|;
block|{
return|return
operator|(
name|most_recent_job_in_state
argument_list|(
name|job
argument_list|,
name|JRUNNING
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make JOB be the current job, and make previous be useful. */
end_comment

begin_function
specifier|static
name|void
name|set_current_job
parameter_list|(
name|job
parameter_list|)
name|int
name|job
decl_stmt|;
block|{
name|int
name|candidate
init|=
name|NO_JOB
decl_stmt|;
if|if
condition|(
name|current_job
operator|!=
name|job
condition|)
block|{
name|previous_job
operator|=
name|current_job
expr_stmt|;
name|current_job
operator|=
name|job
expr_stmt|;
block|}
comment|/* First choice for previous_job is the old current_job. */
if|if
condition|(
name|previous_job
operator|!=
name|current_job
operator|&&
name|previous_job
operator|!=
name|NO_JOB
operator|&&
name|jobs
index|[
name|previous_job
index|]
operator|&&
name|JOBSTATE
argument_list|(
name|previous_job
argument_list|)
operator|==
name|JSTOPPED
condition|)
return|return;
comment|/* Second choice:  Newest stopped job that is older than      the current job. */
if|if
condition|(
name|JOBSTATE
argument_list|(
name|current_job
argument_list|)
operator|==
name|JSTOPPED
condition|)
block|{
name|candidate
operator|=
name|last_stopped_job
argument_list|(
name|current_job
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidate
operator|!=
name|NO_JOB
condition|)
block|{
name|previous_job
operator|=
name|candidate
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we get here, there is either only one stopped job, in which case it is      the current job and the previous job should be set to the newest running      job, or there are only running jobs and the previous job should be set to      the newest running job older than the current job.  We decide on which      alternative to use based on whether or not JOBSTATE(current_job) is      JSTOPPED. */
if|if
condition|(
name|JOBSTATE
argument_list|(
name|current_job
argument_list|)
operator|==
name|JRUNNING
condition|)
name|candidate
operator|=
name|last_running_job
argument_list|(
name|current_job
argument_list|)
expr_stmt|;
else|else
name|candidate
operator|=
name|last_running_job
argument_list|(
name|job_slots
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidate
operator|!=
name|NO_JOB
condition|)
block|{
name|previous_job
operator|=
name|candidate
expr_stmt|;
return|return;
block|}
comment|/* There is only a single job, and it is both `+' and `-'. */
name|previous_job
operator|=
name|current_job
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make current_job be something useful, if it isn't already. */
end_comment

begin_comment
comment|/* Here's the deal:  The newest non-running job should be `+', and the    next-newest non-running job should be `-'.  If there is only a single    stopped job, the previous_job is the newest non-running job.  If there    are only running jobs, the newest running job is `+' and the    next-newest running job is `-'. */
end_comment

begin_function
specifier|static
name|void
name|reset_current
parameter_list|()
block|{
name|int
name|candidate
init|=
name|NO_JOB
decl_stmt|;
if|if
condition|(
name|current_job
operator|!=
name|NO_JOB
operator|&&
name|job_slots
operator|&&
name|jobs
index|[
name|current_job
index|]
operator|&&
name|JOBSTATE
argument_list|(
name|current_job
argument_list|)
operator|==
name|JSTOPPED
condition|)
block|{
name|candidate
operator|=
name|current_job
expr_stmt|;
block|}
else|else
block|{
comment|/* First choice: the previous job! */
if|if
condition|(
name|previous_job
operator|!=
name|NO_JOB
operator|&&
name|jobs
index|[
name|previous_job
index|]
operator|&&
name|JOBSTATE
argument_list|(
name|previous_job
argument_list|)
operator|==
name|JSTOPPED
condition|)
name|candidate
operator|=
name|previous_job
expr_stmt|;
comment|/* Second choice: the most recently stopped job. */
if|if
condition|(
name|candidate
operator|==
name|NO_JOB
condition|)
name|candidate
operator|=
name|last_stopped_job
argument_list|(
name|job_slots
argument_list|)
expr_stmt|;
if|if
condition|(
name|candidate
operator|==
name|NO_JOB
condition|)
block|{
comment|/* Third choice: the newest running job. */
name|candidate
operator|=
name|last_running_job
argument_list|(
name|job_slots
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we found a job to use, then use it.  Otherwise, there      are no jobs period. */
if|if
condition|(
name|candidate
operator|!=
name|NO_JOB
condition|)
name|set_current_job
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
else|else
name|current_job
operator|=
name|previous_job
operator|=
name|NO_JOB
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a job.  FOREGROUND if non-zero says to do that.  Otherwise,    start the job in the background.  JOB is a zero-based index into    JOBS.  Returns -1 if it is unable to start a job, and the return    status of the job otherwise. */
end_comment

begin_function
name|int
name|start_job
parameter_list|(
name|job
parameter_list|,
name|foreground
parameter_list|)
name|int
name|job
decl_stmt|,
name|foreground
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|int
name|already_running
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|char
modifier|*
name|wd
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
specifier|static
name|struct
name|sgttyb
name|save_stty
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TERMIO_TTY_DRIVER
argument_list|)
specifier|static
name|struct
name|termio
name|save_stty
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
specifier|static
name|struct
name|termios
name|save_stty
decl_stmt|;
endif|#
directive|endif
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
name|already_running
operator|=
operator|(
name|JOBSTATE
argument_list|(
name|job
argument_list|)
operator|==
name|JRUNNING
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|foreground
operator|&&
name|already_running
condition|)
block|{
specifier|extern
name|char
modifier|*
name|this_command_name
decl_stmt|;
name|report_error
argument_list|(
literal|"%s: bg background job?"
argument_list|,
name|this_command_name
argument_list|)
expr_stmt|;
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|wd
operator|=
name|job_working_directory
argument_list|()
expr_stmt|;
comment|/* You don't know about the state of this job.  Do you? */
name|jobs
index|[
name|job
index|]
operator|->
name|notified
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
block|{
name|set_current_job
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|jobs
index|[
name|job
index|]
operator|->
name|foreground
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Tell the outside world what we're doing. */
name|p
operator|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
expr_stmt|;
if|if
condition|(
operator|!
name|foreground
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d]%c "
argument_list|,
name|job
operator|+
literal|1
argument_list|,
operator|(
name|job
operator|==
name|current_job
operator|)
condition|?
literal|'+'
else|:
operator|(
operator|(
name|job
operator|==
name|previous_job
operator|)
condition|?
literal|'-'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s"
argument_list|,
name|p
operator|->
name|command
argument_list|,
name|p
operator|->
name|next
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|?
literal|" | "
else|:
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|)
do|;
if|if
condition|(
operator|!
name|foreground
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|wd
argument_list|,
name|jobs
index|[
name|job
index|]
operator|->
name|wd
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	(wd: %s)"
argument_list|,
name|polite_directory_format
argument_list|(
name|jobs
index|[
name|job
index|]
operator|->
name|wd
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wd
argument_list|)
expr_stmt|;
comment|/* Run the job. */
if|if
condition|(
operator|!
name|already_running
condition|)
block|{
comment|/* Each member of the pipeline is now running. */
name|p
operator|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
expr_stmt|;
do|do
block|{
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|p
operator|->
name|status
argument_list|)
condition|)
name|p
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|)
do|;
comment|/* This means that the job is running. */
name|JOBSTATE
argument_list|(
name|job
argument_list|)
operator|=
name|JRUNNING
expr_stmt|;
block|}
comment|/* Save the tty settings before we start the job in the foreground. */
if|if
condition|(
name|foreground
condition|)
block|{
name|get_tty_state
argument_list|()
expr_stmt|;
name|save_stty
operator|=
name|shell_tty_info
expr_stmt|;
block|}
comment|/* Give the terminal to this job. */
if|if
condition|(
name|foreground
condition|)
block|{
if|if
condition|(
name|jobs
index|[
name|job
index|]
operator|->
name|job_control
condition|)
name|give_terminal_to
argument_list|(
name|jobs
index|[
name|job
index|]
operator|->
name|pgrp
argument_list|)
expr_stmt|;
block|}
else|else
name|jobs
index|[
name|job
index|]
operator|->
name|foreground
operator|=
literal|0
expr_stmt|;
comment|/* If the job is already running, then don't bother jump-starting it. */
if|if
condition|(
operator|!
name|already_running
condition|)
block|{
name|jobs
index|[
name|job
index|]
operator|->
name|notified
operator|=
literal|1
expr_stmt|;
name|killpg
argument_list|(
name|jobs
index|[
name|job
index|]
operator|->
name|pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
block|{
name|pid_t
name|pid
init|=
name|last_pid
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|wait_for
argument_list|(
name|pid
argument_list|)
decl_stmt|;
name|shell_tty_info
operator|=
name|save_stty
expr_stmt|;
name|set_tty_state
argument_list|()
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
else|else
block|{
name|reset_current
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Give PID SIGNAL.  This determines what job the pid belongs to (if any).    If PID does belong to a job, and the job is stopped, then CONTinue the    job after giving it SIGNAL.  Returns -1 on failure.  If GROUP is non-null,    then kill the process group associated with PID. */
end_comment

begin_function
name|int
name|kill_pid
parameter_list|(
name|pid
parameter_list|,
name|signal
parameter_list|,
name|group
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
name|int
name|signal
decl_stmt|,
name|group
decl_stmt|;
block|{
specifier|register
name|PROCESS
modifier|*
name|p
decl_stmt|;
name|int
name|job
decl_stmt|,
name|result
init|=
name|EXECUTION_SUCCESS
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|BLOCK_CHILD
argument_list|(
name|set
argument_list|,
name|oset
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_pipeline
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|job
operator|=
name|find_job
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
condition|)
block|{
if|if
condition|(
name|job
operator|!=
name|NO_JOB
condition|)
block|{
name|jobs
index|[
name|job
index|]
operator|->
name|notified
operator|=
literal|0
expr_stmt|;
comment|/* Kill process in backquotes or one started without job control? */
if|if
condition|(
name|jobs
index|[
name|job
index|]
operator|->
name|pgrp
operator|==
name|shell_pgrp
condition|)
block|{
name|p
operator|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
expr_stmt|;
do|do
block|{
name|kill
argument_list|(
name|p
operator|->
name|pid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|running
operator|&&
operator|(
name|signal
operator|==
name|SIGTERM
operator|||
name|signal
operator|==
name|SIGHUP
operator|)
condition|)
name|kill
argument_list|(
name|p
operator|->
name|pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|)
do|;
block|}
else|else
block|{
name|result
operator|=
name|killpg
argument_list|(
name|jobs
index|[
name|job
index|]
operator|->
name|pgrp
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|JOBSTATE
argument_list|(
name|job
argument_list|)
operator|==
name|JSTOPPED
operator|)
operator|&&
operator|(
name|signal
operator|==
name|SIGTERM
operator|||
name|signal
operator|==
name|SIGHUP
operator|)
condition|)
name|killpg
argument_list|(
name|jobs
index|[
name|job
index|]
operator|->
name|pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|killpg
argument_list|(
name|pid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|kill
argument_list|(
name|pid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
name|UNBLOCK_CHILD
argument_list|(
name|oset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Take care of system dependencies that must be handled when waiting for    children.  The arguments to the WAITPID macro match those to the Posix.1    waitpid() function. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|Ultrix
argument_list|)
operator|&&
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_define
define|#
directive|define
name|WAITPID
parameter_list|(
name|pid
parameter_list|,
name|statusp
parameter_list|,
name|options
parameter_list|)
define|\
value|wait3 ((union wait *)statusp, options, (struct rusage *)0)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_define
define|#
directive|define
name|WAITPID
parameter_list|(
name|pid
parameter_list|,
name|statusp
parameter_list|,
name|options
parameter_list|)
define|\
value|waitpid ((pid_t)pid, statusp, options)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hpux
argument_list|)
end_if

begin_define
define|#
directive|define
name|WAITPID
parameter_list|(
name|pid
parameter_list|,
name|statusp
parameter_list|,
name|options
parameter_list|)
define|\
value|wait3 (statusp, options, (int *)0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WAITPID
parameter_list|(
name|pid
parameter_list|,
name|statusp
parameter_list|,
name|options
parameter_list|)
define|\
value|wait3 (statusp, options, (struct rusage *)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(Ultrix&& mips&& _POSIX_VERSION) */
end_comment

begin_comment
comment|/* If the system needs it, REINSTALL_SIGCHLD_HANDLER will reinstall the    handler for SIGCHLD. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_define
define|#
directive|define
name|REINSTALL_SIGCHLD_HANDLER
value|signal (SIGCHLD, flush_child)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REINSTALL_SIGCHLD_HANDLER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !hpux || _POSIX_VERSION */
end_comment

begin_comment
comment|/* Flush_child () flushes at least one of the children that we are waiting for.    It gets run when we have gotten a SIGCHLD signal, and stops when there    aren't any children terminating any more.  If SIG is 0, this is to be a    blocking wait for a single child.  It is here to get around SCO Unix's    broken sigsuspend (). */
end_comment

begin_function
specifier|static
name|sighandler
name|flush_child
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|WAIT
name|status
decl_stmt|;
name|PROCESS
modifier|*
name|child
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|call_set_current
init|=
literal|0
decl_stmt|,
name|last_stopped_job
init|=
name|NO_JOB
decl_stmt|;
name|int
name|children_exited
init|=
literal|0
decl_stmt|;
do|do
block|{
name|pid
operator|=
name|WAITPID
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|sig
condition|?
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
else|:
name|WUNTRACED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
name|REINSTALL_SIGCHLD_HANDLER
expr_stmt|;
comment|/* Locate our PROCESS for this pid. */
name|child
operator|=
name|find_pipeline
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* It is not an error to have a child terminate that we did 	     not have a record of.  This child could have been part of 	     a pipeline in backquote substitution. */
if|if
condition|(
name|child
condition|)
block|{
name|int
name|job
init|=
name|find_job
argument_list|(
name|pid
argument_list|)
decl_stmt|;
while|while
condition|(
name|child
operator|->
name|pid
operator|!=
name|pid
condition|)
name|child
operator|=
name|child
operator|->
name|next
expr_stmt|;
comment|/* Remember status, and fact that process is not running. */
name|child
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|child
operator|->
name|running
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|job
operator|!=
name|NO_JOB
condition|)
block|{
name|int
name|job_state
init|=
literal|0
decl_stmt|;
name|int
name|any_stopped
init|=
literal|0
decl_stmt|;
name|child
operator|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
expr_stmt|;
name|jobs
index|[
name|job
index|]
operator|->
name|notified
operator|=
literal|0
expr_stmt|;
comment|/* If all children are not running, but any of them is 		     stopped, then the job is stopped, not dead. */
do|do
block|{
name|job_state
operator||=
name|child
operator|->
name|running
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|->
name|running
condition|)
name|any_stopped
operator||=
operator|(
name|WIFSTOPPED
argument_list|(
name|child
operator|->
name|status
argument_list|)
operator|)
expr_stmt|;
name|child
operator|=
name|child
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|child
operator|!=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
condition|)
do|;
if|if
condition|(
name|job_state
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|any_stopped
condition|)
block|{
name|jobs
index|[
name|job
index|]
operator|->
name|state
operator|=
name|JSTOPPED
expr_stmt|;
name|jobs
index|[
name|job
index|]
operator|->
name|foreground
operator|=
literal|0
expr_stmt|;
name|call_set_current
operator|++
expr_stmt|;
name|last_stopped_job
operator|=
name|job
expr_stmt|;
block|}
else|else
block|{
name|jobs
index|[
name|job
index|]
operator|->
name|state
operator|=
name|JDEAD
expr_stmt|;
if|if
condition|(
name|job
operator|==
name|last_stopped_job
condition|)
name|last_stopped_job
operator|=
name|NO_JOB
expr_stmt|;
comment|/* If this job was not started with job control, 			     then the shell has already seen the SIGINT, since 			     the process groups are the same.  In that case, 			     don't send the SIGINT to the shell; it will 			     surprise people to have a stray interrupt 			     arriving some time after they killed the job. */
comment|/* XXX - should the `|| interactive' be there? */
if|if
condition|(
name|jobs
index|[
name|job
index|]
operator|->
name|foreground
operator|&&
operator|(
name|jobs
index|[
name|job
index|]
operator|->
name|job_control
operator|||
name|interactive
operator|)
operator|&&
name|WTERMSIG
argument_list|(
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
operator|->
name|status
argument_list|)
operator|==
name|SIGINT
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we have caught a child, and a trap was set for SIGCHLD, then 	     bump up the count of the number of children that have exited, 	     so we know how many times to call it. */
name|children_exited
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|SCO
argument_list|)
do|while
condition|(
name|sig
operator|&&
name|pid
operator|>
operator|(
name|pid_t
operator|)
literal|0
condition|)
do|;
comment|/* Hack for SCO, see earlier comment. */
else|#
directive|else
while|while
condition|(
name|pid
operator|>
operator|(
name|pid_t
operator|)
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
comment|/* SCO */
comment|/* If a job was running and became stopped, then set the current      job.  Otherwise, don't change a thing. */
if|if
condition|(
name|call_set_current
condition|)
if|if
condition|(
name|last_stopped_job
operator|!=
name|NO_JOB
condition|)
name|set_current_job
argument_list|(
name|last_stopped_job
argument_list|)
expr_stmt|;
else|else
name|reset_current
argument_list|()
expr_stmt|;
comment|/* Call a SIGCHLD trap handler for each child that exits, if one is set. */
block|{
specifier|extern
name|char
modifier|*
name|trap_list
index|[]
decl_stmt|;
if|if
condition|(
operator|(
name|trap_list
index|[
name|SIGCHLD
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
operator|)
operator|&&
operator|(
name|trap_list
index|[
name|SIGCHLD
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|IGNORE_SIG
operator|)
condition|)
block|{
specifier|extern
name|int
name|last_command_exit_value
decl_stmt|;
comment|/* It's quite dangerous to do this from a signal handler, so 	   we turn off the trap list temporarily while we parse and 	   execute the command.  This will protect us against (potentially 	   infinite) recursive calls.  We also preserve $? around the 	   execution of trap commands, by saving and restoring the value 	   of last_command_exit_value. */
name|char
modifier|*
name|trap_command
init|=
name|trap_list
index|[
name|SIGCHLD
index|]
decl_stmt|;
name|int
name|old_exit_value
init|=
name|last_command_exit_value
decl_stmt|;
name|trap_list
index|[
name|SIGCHLD
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|DEFAULT_SIG
expr_stmt|;
while|while
condition|(
name|children_exited
operator|--
condition|)
name|parse_and_execute
argument_list|(
name|savestring
argument_list|(
name|trap_command
argument_list|)
argument_list|,
literal|"trap"
argument_list|)
expr_stmt|;
name|trap_list
index|[
name|SIGCHLD
index|]
operator|=
name|trap_command
expr_stmt|;
name|last_command_exit_value
operator|=
name|old_exit_value
expr_stmt|;
block|}
block|}
comment|/* We have successfully recorded the useful information about this process      that has just changed state.  If we notify asynchronously, and the job      that this process belongs to is no longer running, then notify the user      of that fact now. */
if|if
condition|(
name|asynchronous_notification
operator|&&
name|interactive
condition|)
name|notify_of_job_status
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VOID_SIGHANDLER
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* VOID_SIGHANDLER */
block|}
end_function

begin_comment
comment|/* Function to call when you want to notify people of changes    in job status.  This prints out all jobs which are pending    notification to stderr, and marks those printed as already    notified, thus making them candidates for cleanup. */
end_comment

begin_function
specifier|static
name|void
name|notify_of_job_status
parameter_list|()
block|{
specifier|register
name|int
name|job
decl_stmt|,
name|termsig
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|job_working_directory
argument_list|()
decl_stmt|;
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGTTOU
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|oset
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
for|for
control|(
name|job
operator|=
literal|0
init|;
name|job
operator|<
name|job_slots
condition|;
name|job
operator|++
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|job
index|]
operator|&&
name|jobs
index|[
name|job
index|]
operator|->
name|notified
operator|==
literal|0
condition|)
block|{
name|WAIT
name|s
decl_stmt|;
name|s
operator|=
name|jobs
index|[
name|job
index|]
operator|->
name|pipe
operator|->
name|status
expr_stmt|;
name|termsig
operator|=
name|WTERMSIG
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|JOBSTATE
argument_list|(
name|job
argument_list|)
condition|)
block|{
comment|/* Print info on jobs that are running in the background, 		 and on foreground jobs that were killed by anything 		 except SIGINT. */
case|case
name|JDEAD
case|:
if|if
condition|(
name|jobs
index|[
name|job
index|]
operator|->
name|foreground
condition|)
block|{
if|if
condition|(
name|termsig
operator|&&
name|WIFSIGNALED
argument_list|(
name|s
argument_list|)
operator|&&
name|termsig
operator|!=
name|SIGINT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|sys_siglist
index|[
name|termsig
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFCORED
argument_list|(
name|s
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (core dumped)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pretty_print_job
argument_list|(
name|job
argument_list|,
literal|0
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|&&
name|strcmp
argument_list|(
name|dir
argument_list|,
name|jobs
index|[
name|job
index|]
operator|->
name|wd
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(wd now: %s)\n"
argument_list|,
name|polite_directory_format
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|jobs
index|[
name|job
index|]
operator|->
name|notified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|JSTOPPED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|pretty_print_job
argument_list|(
name|job
argument_list|,
literal|0
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|&&
operator|(
name|strcmp
argument_list|(
name|dir
argument_list|,
name|jobs
index|[
name|job
index|]
operator|->
name|wd
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(wd now: %s)\n"
argument_list|,
name|polite_directory_format
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|jobs
index|[
name|job
index|]
operator|->
name|notified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|JRUNNING
case|:
case|case
name|JMIXED
case|:
break|break;
default|default:
name|programming_error
argument_list|(
literal|"notify_of_job_status"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* getpgrp () varies between systems.  Even systems that claim to be    Posix.1 compatible lie sometimes (Ultrix, SunOS4, apollo). */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD_GETPGRP
argument_list|)
end_if

begin_define
define|#
directive|define
name|getpgid
parameter_list|(
name|p
parameter_list|)
value|getpgrp ()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|getpgid
parameter_list|(
name|p
parameter_list|)
value|getpgrp (p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_POSIX_VERSION || BSD_GETPGRP */
end_comment

begin_comment
comment|/* Initialize the job control mechanism, and set up the tty stuff. */
end_comment

begin_macro
name|initialize_jobs
argument_list|()
end_macro

begin_block
block|{
name|shell_pgrp
operator|=
name|getpgid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_pgrp
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: initialize_jobs: getpgrp failed: %s\n"
argument_list|,
name|shell_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We can only have job control if we are interactive?      I guess that makes sense. */
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
name|job_control
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure that we are using the new line discipline. */
comment|/* Get our controlling terminal.  If job_control is set, or 	 interactive is set, then this is an interactive shell no 	 matter what opening /dev/tty returns.  (It sometimes says 	 the wrong thing.) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCO
argument_list|)
comment|/* SCO Unix fails attempting job control on /dev/tty. */
if|if
condition|(
operator|(
name|shell_tty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* !SCO */
name|shell_tty
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the highest unused file descriptor we can. */
block|{
name|int
name|ignore
decl_stmt|,
name|nds
init|=
name|getdtablesize
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|nds
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|nds
argument_list|,
name|F_GETFD
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|shell_tty
operator|!=
name|nds
operator|&&
operator|(
name|dup2
argument_list|(
name|shell_tty
argument_list|,
name|nds
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|shell_tty
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
name|close
argument_list|(
name|shell_tty
argument_list|)
expr_stmt|;
name|shell_tty
operator|=
name|nds
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|NeXT
argument_list|)
comment|/* Compensate for a bug in the NeXT 2.0 /usr/etc/rlogind. */
if|if
condition|(
name|shell_pgrp
operator|==
literal|0
condition|)
block|{
name|shell_pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shell_pgrp
argument_list|)
expr_stmt|;
name|tcsetpgrp
argument_list|(
name|shell_tty
argument_list|,
name|shell_pgrp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NeXT */
while|while
condition|(
operator|(
name|terminal_pgrp
operator|=
name|tcgetpgrp
argument_list|(
name|shell_tty
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|shell_pgrp
operator|!=
name|terminal_pgrp
condition|)
block|{
name|SigHandler
modifier|*
name|old_ttin
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_DFL
argument_list|)
decl_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTTIN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|old_ttin
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|set_new_line_discipline
argument_list|(
name|shell_tty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: initialize_jobs: line discipline: %s"
argument_list|,
name|shell_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|job_control
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|original_pgrp
operator|=
name|shell_pgrp
expr_stmt|;
name|shell_pgrp
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|original_pgrp
operator|!=
name|shell_pgrp
operator|)
operator|&&
operator|(
name|setpgid
argument_list|(
literal|0
argument_list|,
name|shell_pgrp
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: initialize_jobs: setpgid: %s\n"
argument_list|,
name|shell_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|shell_pgrp
operator|=
name|original_pgrp
expr_stmt|;
block|}
name|job_control
operator|=
literal|1
expr_stmt|;
name|give_terminal_to
argument_list|(
name|shell_pgrp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shell_tty
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
name|SET_CLOSE_ON_EXEC
argument_list|(
name|shell_tty
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|flush_child
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Some Posix job control implementations (like SCO 3.2.x) set signals to      call sigaction with NOCLDSTOP set in sa_flags.  Make sure we get      signalled on child status changes by using sigaction instead of      signal. */
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|flush_child
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _POSIX_VERSION */
name|change_flag_char
argument_list|(
literal|'m'
argument_list|,
name|job_control
condition|?
literal|'-'
else|:
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|get_tty_state
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Set the line discipline to the best this system has to offer.    Return -1 if this is not possible. */
end_comment

begin_function
specifier|static
name|int
name|set_new_line_discipline
parameter_list|(
name|tty
parameter_list|)
name|int
name|tty
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
name|int
name|ldisc
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ldisc
operator|!=
name|NTTYDISC
condition|)
block|{
name|ldisc
operator|=
name|NTTYDISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* NEW_TTY_DRIVER */
if|#
directive|if
name|defined
argument_list|(
name|TERMIO_TTY_DRIVER
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|NTTYDISC
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|shell_tty_info
operator|.
name|c_line
operator|!=
name|NTTYDISC
condition|)
block|{
name|shell_tty_info
operator|.
name|c_line
operator|=
name|NTTYDISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* NTTYDISC */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* TERMIO_TTY_DRIVER */
if|#
directive|if
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Ultrix
argument_list|)
operator|||
name|defined
argument_list|(
name|SunOS4
argument_list|)
operator|||
name|defined
argument_list|(
name|aixpc
argument_list|)
if|if
condition|(
name|tcgetattr
argument_list|(
name|tty
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|shell_tty_info
operator|.
name|c_line
operator|!=
name|NTTYDISC
condition|)
block|{
name|shell_tty_info
operator|.
name|c_line
operator|=
name|NTTYDISC
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|tty
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|shell_tty_info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Ultrix || SunOS4 || aixpc */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* TERMIOS_TTY_DRIVER */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TERMIO_TTY_DRIVER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TERMIOS_TTY_DRIVER
argument_list|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Allow or disallow job control to take place.  Returns the old value    of job_control. */
end_comment

begin_function
name|int
name|set_job_control
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|int
name|old
decl_stmt|;
name|old
operator|=
name|job_control
expr_stmt|;
name|job_control
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|SigHandler
modifier|*
name|old_tstp
decl_stmt|,
modifier|*
name|old_ttou
decl_stmt|,
modifier|*
name|old_ttin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SigHandler
modifier|*
name|old_cont
init|=
operator|(
name|SigHandler
operator|*
operator|)
name|SIG_DFL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sighandler
name|stop_signal_handler
argument_list|()
decl_stmt|,
name|cont_signal_handler
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Setup this shell to handle C-C, etc. */
end_comment

begin_macro
name|initialize_job_signals
argument_list|()
end_macro

begin_block
block|{
name|sighandler
name|sigint_sighandler
parameter_list|()
function_decl|;
if|if
condition|(
name|interactive
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint_sighandler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|job_control
condition|)
block|{
name|old_tstp
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_signal_handler
argument_list|)
expr_stmt|;
name|old_ttou
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|stop_signal_handler
argument_list|)
expr_stmt|;
name|old_ttin
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|stop_signal_handler
argument_list|)
expr_stmt|;
block|}
comment|/* Leave these things alone for non-interactive shells without job      control. */
block|}
end_block

begin_comment
comment|/* Here we handle CONT signals. */
end_comment

begin_function
specifier|static
name|sighandler
name|cont_signal_handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|initialize_job_signals
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|old_cont
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VOID_SIGHANDLER
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* VOID_SIGHANDLER */
block|}
end_function

begin_comment
comment|/* Here we handle stop signals while we are running not as a login shell. */
end_comment

begin_function
specifier|static
name|sighandler
name|stop_signal_handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|old_tstp
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|old_ttou
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|old_ttin
argument_list|)
expr_stmt|;
name|old_cont
operator|=
operator|(
name|SigHandler
operator|*
operator|)
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|cont_signal_handler
argument_list|)
expr_stmt|;
name|give_terminal_to
argument_list|(
name|shell_pgrp
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VOID_SIGHANDLER
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* VOID_SIGHANDLER */
block|}
end_function

begin_comment
comment|/* Give the terminal to PGRP.  */
end_comment

begin_macro
name|give_terminal_to
argument_list|(
argument|pgrp
argument_list|)
end_macro

begin_decl_stmt
name|pid_t
name|pgrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
if|if
condition|(
name|job_control
condition|)
block|{
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGTTOU
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGTTIN
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|oset
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|shell_tty
argument_list|,
name|pgrp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Maybe we should print an error message? */
block|}
else|else
name|terminal_pgrp
operator|=
name|pgrp
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Clear out any jobs in the job array.  This is intended to be used by    children of the shell, who should not have any job structures as baggage    when they start executing (forking subshells for parenthesized execution    and functions with pipes are the two that spring to mind). */
end_comment

begin_macro
name|delete_all_jobs
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|job_slots
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|current_job
operator|=
name|previous_job
operator|=
name|NO_JOB
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|jobs
index|[
name|i
index|]
operator|!=
operator|(
name|JOB
operator|*
operator|)
name|NULL
condition|)
name|delete_job
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|jobs
argument_list|)
expr_stmt|;
name|job_slots
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Turn off all traces of job control.  This is run by children of the shell    which are going to do shellsy things, like wait (), etc. */
end_comment

begin_macro
name|without_job_control
argument_list|()
end_macro

begin_block
block|{
name|stop_making_children
argument_list|()
expr_stmt|;
name|start_pipeline
argument_list|()
expr_stmt|;
name|delete_all_jobs
argument_list|()
expr_stmt|;
name|set_job_control
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
end_if

begin_comment
comment|/* Read from the read end of a pipe.  This is how the process group leader    blocks until all of the processes in a pipeline have been made. */
end_comment

begin_function
specifier|static
name|void
name|pipe_read
parameter_list|(
name|pp
parameter_list|)
name|int
modifier|*
name|pp
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|pp
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pp
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pp
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|read
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
block|}
block|}
end_function

begin_comment
comment|/* Close the read and write ends of PP, an array of file descriptors. */
end_comment

begin_function
specifier|static
name|void
name|pipe_close
parameter_list|(
name|pp
parameter_list|)
name|int
modifier|*
name|pp
decl_stmt|;
block|{
if|if
condition|(
name|pp
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|pp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|pp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pp
index|[
literal|0
index|]
operator|=
name|pp
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functional interface closes our local-to-job-control pipes. */
end_comment

begin_macro
name|close_pgrp_pipe
argument_list|()
end_macro

begin_block
block|{
name|pipe_close
argument_list|(
name|pgrp_pipe
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PGRP_PIPE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOB_CONTROL */
end_comment

end_unit

