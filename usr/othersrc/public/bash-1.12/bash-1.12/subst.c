begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* substitutions.c -- The part of the shell that does parameter,    command, and globbing substitutions. */
end_comment

begin_comment
comment|/* Copyright (C) 1987,1989 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"filecntl.h"
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_include
include|#
directive|include
file|<glob/fnmatch.h>
end_include

begin_comment
comment|/* The size that strings change by. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_ARRAY_SIZE
value|512
end_define

begin_comment
comment|/* How to quote and dequote the character C. */
end_comment

begin_define
define|#
directive|define
name|QUOTE_CHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char)(c) | 0x80)
end_define

begin_define
define|#
directive|define
name|DEQUOTE_CHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char)(c)& 0x7f)
end_define

begin_define
define|#
directive|define
name|QUOTED_CHAR
parameter_list|(
name|c
parameter_list|)
value|((unsigned char)(c)> 0x7f)
end_define

begin_comment
comment|/* Process ID of the last command executed within command substitution. */
end_comment

begin_decl_stmt
name|pid_t
name|last_command_subst_pid
init|=
name|NO_PID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some forward declarations. */
end_comment

begin_decl_stmt
specifier|extern
name|WORD_LIST
modifier|*
name|expand_string
argument_list|()
decl_stmt|,
modifier|*
name|expand_word
argument_list|()
decl_stmt|,
modifier|*
name|list_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|string_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|WORD_DESC
modifier|*
name|make_word
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|WORD_DESC
modifier|*
name|copy_word
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|WORD_LIST
modifier|*
name|copy_word_list
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|WORD_LIST
modifier|*
name|expand_string_internal
argument_list|()
decl_stmt|,
modifier|*
name|expand_words_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|quote_string
argument_list|()
decl_stmt|,
modifier|*
name|dequote_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|unquoted_substring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quote_list
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Utility Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Cons a new string from STRING starting at START and ending at END,    not including END. */
end_comment

begin_function
name|char
modifier|*
name|substring
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|end
operator|-
name|start
decl_stmt|;
specifier|register
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Just like string_extract, but doesn't hack backslashes or any of    that other stuff. */
end_comment

begin_function
name|char
modifier|*
name|string_extract_verbatim
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|,
name|charlist
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|charlist
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|sindex
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|sindex
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|string
index|[
name|i
index|]
operator|)
operator|&&
operator|(
operator|!
name|member
argument_list|(
name|c
argument_list|,
name|charlist
argument_list|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
operator|*
name|sindex
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
operator|(
operator|*
name|sindex
operator|)
argument_list|,
name|i
operator|-
operator|(
operator|*
name|sindex
operator|)
argument_list|)
expr_stmt|;
name|temp
index|[
name|i
operator|-
operator|(
operator|*
name|sindex
operator|)
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sindex
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Extract a substring from STRING, starting at SINDEX and ending with    one of the characters in CHARLIST.  Don't make the ending character    part of the string.  Leave SINDEX pointing at the ending character.    Understand about backslashes in the string. */
end_comment

begin_function
name|char
modifier|*
name|string_extract
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|,
name|charlist
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|charlist
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|sindex
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
init|=
operator|*
name|sindex
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
name|c
operator|=
name|string
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|i
operator|++
expr_stmt|;
else|else
break|break;
elseif|else
if|if
condition|(
name|member
argument_list|(
name|c
argument_list|,
name|charlist
argument_list|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
operator|*
name|sindex
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
operator|(
operator|*
name|sindex
operator|)
argument_list|,
name|i
operator|-
operator|(
operator|*
name|sindex
operator|)
argument_list|)
expr_stmt|;
name|temp
index|[
name|i
operator|-
operator|(
operator|*
name|sindex
operator|)
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sindex
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Remove backslashes which are quoting backquotes from STRING.  Modifies    STRING, and returns a pointer to it. */
end_comment

begin_function
name|char
modifier|*
name|de_backslash
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'`'
operator|||
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\\'
operator|||
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
name|strcpy
argument_list|(
operator|&
name|string
index|[
name|i
index|]
argument_list|,
operator|&
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Replace instances of \! in a string with !. */
end_comment

begin_function
name|void
name|unquote_bang
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|temp
index|[
name|j
index|]
operator|=
name|string
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
name|temp
index|[
name|j
index|]
operator|=
literal|'!'
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|string
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract the $( construct in STRING, and return a new string.    Start extracting at (SINDEX) as if we had just seen "$(".    Make (SINDEX) get the position just after the matching ")". */
end_comment

begin_function
name|char
modifier|*
name|extract_command_subst
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|sindex
decl_stmt|;
block|{
name|char
modifier|*
name|extract_delimited_string
parameter_list|()
function_decl|;
return|return
operator|(
name|extract_delimited_string
argument_list|(
name|string
argument_list|,
name|sindex
argument_list|,
literal|"$("
argument_list|,
literal|"("
argument_list|,
literal|")"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Extract the $[ construct in STRING, and return a new string.    Start extracting at (SINDEX) as if we had just seen "$[".    Make (SINDEX) get the position just after the matching "]".     Strictly speaking, according to the letter of POSIX.2, arithmetic    substitutions cannot be nested.  This code allows nesting, however,    and it is fully implemented. */
end_comment

begin_function
name|char
modifier|*
name|extract_arithmetic_subst
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|sindex
decl_stmt|;
block|{
name|char
modifier|*
name|extract_delimited_string
parameter_list|()
function_decl|;
return|return
operator|(
name|extract_delimited_string
argument_list|(
name|string
argument_list|,
name|sindex
argument_list|,
literal|"$["
argument_list|,
literal|"["
argument_list|,
literal|"]"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Extract and create a new string from the contents of STRING, a    character string delimited with OPENER and CLOSER.  SINDEX is    the address of an int describing the current offset in STRING;    it should point to just after the first OPENER found.  On exit,    SINDEX gets the position just after the matching CLOSER.  If    OPENER is more than a single character, ALT_OPENER, if non-null,    contains a character string that can also match CLOSER and thus    needs to be skipped. */
end_comment

begin_function
name|char
modifier|*
name|extract_delimited_string
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|,
name|opener
parameter_list|,
name|alt_opener
parameter_list|,
name|closer
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|sindex
decl_stmt|;
name|char
modifier|*
name|opener
decl_stmt|,
decl|*
name|alt_opener
decl_stmt|,
modifier|*
name|closer
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|l
decl_stmt|;
name|int
name|pass_character
decl_stmt|,
name|nesting_level
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|delimited_nesting_level
decl_stmt|;
name|int
name|len_closer
decl_stmt|,
name|len_opener
decl_stmt|,
name|len_alt_opener
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|len_opener
operator|=
name|strlen
argument_list|(
name|opener
argument_list|)
expr_stmt|;
name|len_alt_opener
operator|=
name|alt_opener
condition|?
name|strlen
argument_list|(
name|alt_opener
argument_list|)
else|:
literal|0
expr_stmt|;
name|len_closer
operator|=
name|strlen
argument_list|(
name|closer
argument_list|)
expr_stmt|;
name|pass_character
operator|=
name|delimiter
operator|=
name|delimited_nesting_level
operator|=
literal|0
expr_stmt|;
name|nesting_level
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|sindex
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pass_character
condition|)
block|{
name|pass_character
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|delimiter
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|member
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|slashify_in_quotes
argument_list|)
operator|)
condition|)
block|{
name|pass_character
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|delimiter
operator|||
name|delimiter
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|opener
argument_list|,
name|len_opener
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|delimiter
condition|)
name|nesting_level
operator|++
expr_stmt|;
else|else
name|delimited_nesting_level
operator|++
expr_stmt|;
name|i
operator|+=
name|len_opener
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len_alt_opener
operator|&&
name|strncmp
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|alt_opener
argument_list|,
name|len_alt_opener
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|delimiter
condition|)
name|nesting_level
operator|++
expr_stmt|;
else|else
name|delimited_nesting_level
operator|++
expr_stmt|;
name|i
operator|+=
name|len_alt_opener
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|closer
argument_list|,
name|len_closer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|+=
name|len_closer
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|delimiter
operator|&&
name|delimited_nesting_level
condition|)
name|delimited_nesting_level
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|delimiter
condition|)
block|{
name|nesting_level
operator|--
expr_stmt|;
if|if
condition|(
name|nesting_level
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|delimiter
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|delimiter
operator|||
name|delimiter
operator|==
literal|'\\'
condition|)
name|delimiter
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|delimiter
operator|=
name|c
expr_stmt|;
block|}
block|}
name|l
operator|=
name|i
operator|-
operator|*
name|sindex
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|l
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
operator|&
name|string
index|[
operator|*
name|sindex
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|result
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sindex
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|&&
operator|(
name|delimiter
operator|||
name|nesting_level
operator|)
condition|)
block|{
name|report_error
argument_list|(
literal|"bad substitution: %s%s"
argument_list|,
name|opener
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* An artifact for extracting the contents of a quoted string.  Since the    string is about to be evaluated, we pass everything through, and only    strip backslash before backslash or quote. */
end_comment

begin_comment
comment|/* This is a mini state machine. */
end_comment

begin_function
name|char
modifier|*
name|string_extract_double_quoted
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|sindex
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|j
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* The new string we return. */
name|int
name|pass_next
decl_stmt|,
name|backquote
decl_stmt|;
comment|/* State variables for the machine. */
name|pass_next
operator|=
name|backquote
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
operator|*
name|sindex
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
operator|*
name|sindex
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* Process a character that was quoted by a backslash. */
if|if
condition|(
name|pass_next
condition|)
block|{
comment|/* Posix.2 sez:  	     ``The backslash shall retain its special meaning as an escape 	     character only when followed by one of the characters: 	     	$	`	"	\<newline>''.  	     We handle the double quotes here.  expand_word_internal handles 	     the rest. */
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|temp
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|pass_next
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* A backslash protects the next character.  The code just above          handles preserving the backslash in front of any character but          a double quote. */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|pass_next
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Inside backquotes, ``the portion of the quoted string from the 	 initial backquote and the characters up to the next backquote 	 that is not preceded by a backslash, having escape characters 	 removed, defines that command''. */
if|if
condition|(
name|backquote
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'`'
condition|)
name|backquote
operator|=
literal|0
expr_stmt|;
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'`'
condition|)
block|{
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|backquote
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Pass everything between `$(' and the matching `)' through verbatim. */
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|si
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|si
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|ret
operator|=
name|extract_delimited_string
argument_list|(
name|string
argument_list|,
operator|&
name|si
argument_list|,
literal|"$("
argument_list|,
literal|"("
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|temp
index|[
name|j
operator|++
index|]
operator|=
literal|'$'
expr_stmt|;
name|temp
index|[
name|j
operator|++
index|]
operator|=
literal|'('
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|ret
index|[
name|t
index|]
condition|;
name|t
operator|++
control|)
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|ret
index|[
name|t
index|]
expr_stmt|;
name|i
operator|=
name|si
expr_stmt|;
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* An unescaped double quote serves to terminate the string. */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
comment|/* Add the character to the quoted string we're accumulating. */
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|temp
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|sindex
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Extract the name of the variable to bind to from the assignment string. */
end_comment

begin_function
name|char
modifier|*
name|assignment_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|offset
init|=
name|assignment
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|offset
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|temp
index|[
name|offset
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a single string of all the words in LIST.  SEP is the separator    to put between individual elements of LIST in the output string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|string_list_internal
parameter_list|(
name|list
parameter_list|,
name|sep
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|sep_len
decl_stmt|;
name|sep_len
operator|=
name|strlen
argument_list|(
name|sep
argument_list|)
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
comment|/* Can't simply let xrealloc malloc the bytes for us the first time          because of the strcat (result, ...) -- we need to make sure result          is initialized to null after being allocated initially. */
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
literal|2
operator|+
name|sep_len
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
operator|+
name|strlen
argument_list|(
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|next
condition|)
name|strcat
argument_list|(
name|result
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a single string of all the words present in LIST, separating    each word with a space. */
end_comment

begin_function
name|char
modifier|*
name|string_list
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
return|return
operator|(
name|string_list_internal
argument_list|(
name|list
argument_list|,
literal|" "
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a single string of all the words present in LIST, obeying the    quoting rules for "$*", to wit: (P1003.2, draft 11, 3.5.2, "If the    expansion [of $*] appears within a double quoted string, it expands    to a single field with the value of each parameter separated by the    first character of the IFS variable, or by a<space> if IFS is unset    [or null]." */
end_comment

begin_function
name|char
modifier|*
name|string_list_dollar_star
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|char
modifier|*
name|ifs
init|=
name|get_string_value
argument_list|(
literal|"IFS"
argument_list|)
decl_stmt|;
name|char
name|sep
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ifs
condition|)
name|sep
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|*
name|ifs
condition|)
name|sep
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sep
index|[
literal|0
index|]
operator|=
operator|*
name|ifs
expr_stmt|;
name|sep
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|string_list_internal
argument_list|(
name|list
argument_list|,
name|sep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the list of words present in STRING.  Separate the string into    words at any of the characters found in SEPARATORS.  If QUOTED is    non-zero then word in the list will have its quoted flag set, otherwise    the quoted flag is left as make_word () deemed fit.     This obeys the P1003.2 draft 11 word splitting semantics.  If `separators'    is exactly<space><tab><newline>, then the splitting algorithm is that of    the Bourne shell, which treats any sequence of characters from `separators'    as a delimiter.  If IFS is unset, which results in `separators' being set    to "", no splitting occurs.  If separators has some other value, the    following rules are applied (`IFS white space' means zero or more    occurrences of<space>,<tab>, or<newline>, as long as those characters    are in `separators'):  	1) IFS white space is ignored at the start and the end of the 	   string. 	2) Each occurrence of a character in `separators' that is not 	   IFS white space, along with any adjacent occurrences of 	   IFS white space delimits a field. 	3) Any nonzero-length sequence of IFS white space delimits a field.    */
end_comment

begin_comment
comment|/* BEWARE!  list_string strips null arguments.  Don't call it twice and    expect to have "" preserved! */
end_comment

begin_comment
comment|/* Is C a quoted NULL character? */
end_comment

begin_define
define|#
directive|define
name|QUOTED_NULL
parameter_list|(
name|c
parameter_list|)
value|((unsigned char)(c) == (unsigned char)0x80)
end_define

begin_comment
comment|/* Perform quoted null character removal on STRING. */
end_comment

begin_function
name|void
name|remove_quoted_nulls
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|string
init|;
name|s
operator|&&
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|QUOTED_NULL
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|s
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform quoted null character removal on each element of LIST.    This modifies LIST. */
end_comment

begin_macro
name|word_list_remove_quoted_nulls
argument_list|(
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|WORD_LIST
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|remove_quoted_nulls
argument_list|(
name|t
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* This performs word splitting and quoted null character removal on    STRING. */
end_comment

begin_define
define|#
directive|define
name|issep
parameter_list|(
name|c
parameter_list|)
value|(member ((c), separators))
end_define

begin_define
define|#
directive|define
name|spctabnl
parameter_list|(
name|c
parameter_list|)
value|((c) == ' '|| (c) == '\t' || (c) == '\n')
end_define

begin_function
name|WORD_LIST
modifier|*
name|list_string
parameter_list|(
name|string
parameter_list|,
name|separators
parameter_list|,
name|quoted
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|separators
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|quoted
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|WORD_LIST
modifier|*
name|result
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|current_word
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|sindex
init|=
literal|0
decl_stmt|;
name|int
name|sh_style_split
decl_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
condition|)
return|return
operator|(
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
operator|)
return|;
name|sh_style_split
operator|=
name|separators
operator|&&
operator|*
name|separators
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|separators
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
expr_stmt|;
comment|/* Remove sequences of whitespace at the beginning and end of STRING, as      long as those characters appear in IFS. */
for|for
control|(
name|s
operator|=
name|string
init|;
operator|*
name|s
operator|&&
name|spctabnl
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|issep
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
operator|(
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
operator|)
return|;
name|string
operator|=
name|s
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|s
operator|>
name|string
operator|&&
operator|*
name|s
operator|&&
name|spctabnl
argument_list|(
operator|*
name|s
argument_list|)
operator|&
name|issep
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
operator|(
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
operator|)
return|;
operator|*
operator|++
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* OK, now STRING points to a word that does not begin with white space.      The splitting algorithm is:      	extract a word, stopping at a separator      	skip sequences of spc, tab, or nl as long as they are separators      This obeys the field splitting rules in Posix.2 draft 11.x. */
while|while
condition|(
name|string
index|[
name|sindex
index|]
condition|)
block|{
name|current_word
operator|=
name|string_extract_verbatim
argument_list|(
name|string
argument_list|,
operator|&
name|sindex
argument_list|,
name|separators
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_word
condition|)
break|break;
comment|/* If we have a quoted empty string, add a quoted null argument.  We 	 want to preserve the quoted null character iff this is a quoted 	 empty string; otherwise the quoted null characters are removed 	 below. */
if|if
condition|(
name|QUOTED_NULL
argument_list|(
name|current_word
index|[
literal|0
index|]
argument_list|)
operator|&&
name|current_word
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|WORD_DESC
modifier|*
name|t
init|=
name|make_word
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|t
operator|->
name|quoted
operator|++
expr_stmt|;
name|t
operator|->
name|word
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|QUOTE_CHAR
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|result
operator|=
name|make_word_list
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* If we have something, then add it regardless. */
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|current_word
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|temp_string
decl_stmt|;
comment|/* Perform quoted null character removal on the current word. */
for|for
control|(
name|temp_string
operator|=
name|current_word
init|;
operator|*
name|temp_string
condition|;
name|temp_string
operator|++
control|)
if|if
condition|(
name|QUOTED_NULL
argument_list|(
operator|*
name|temp_string
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|temp_string
argument_list|,
name|temp_string
operator|+
literal|1
argument_list|)
expr_stmt|;
name|temp_string
operator|--
expr_stmt|;
block|}
name|result
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|current_word
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
name|result
operator|->
name|word
operator|->
name|quoted
operator|++
expr_stmt|;
block|}
comment|/* If we're not doing sequences of separators in the traditional 	 Bourne shell style, then add a quoted null argument. */
elseif|else
if|if
condition|(
operator|!
name|sh_style_split
operator|&&
operator|!
name|spctabnl
argument_list|(
name|string
index|[
name|sindex
index|]
argument_list|)
condition|)
block|{
name|result
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
literal|""
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|->
name|word
operator|->
name|quoted
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|current_word
argument_list|)
expr_stmt|;
comment|/* Move past the current separator character. */
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
comment|/* Now skip sequences of space, tab, or newline characters if they are          in the list of separators. */
while|while
condition|(
name|string
index|[
name|sindex
index|]
operator|&&
name|spctabnl
argument_list|(
name|string
index|[
name|sindex
index|]
argument_list|)
operator|&&
name|issep
argument_list|(
name|string
index|[
name|sindex
index|]
argument_list|)
condition|)
name|sindex
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|result
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Given STRING, an assignment string, get the value of the right side    of the `=', and bind it to the left side.  If EXPAND is true, then    perform parameter expansion, command substitution, and arithmetic    expansion on the right-hand side.  Perform tilde expansion in any    case.  Do not perform word splitting on the result of expansion. */
end_comment

begin_macro
name|do_assignment_internal
argument_list|(
argument|string
argument_list|,
argument|expand
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expand
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|offset
init|=
name|assignment
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|savestring
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|SHELL_VAR
modifier|*
name|entry
init|=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|name
index|[
name|offset
index|]
operator|==
literal|'='
condition|)
block|{
name|char
modifier|*
name|tilde_expand
argument_list|()
decl_stmt|,
modifier|*
name|string_list
argument_list|()
decl_stmt|;
name|WORD_LIST
modifier|*
name|list
decl_stmt|,
modifier|*
name|expand_string_unsplit
argument_list|()
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|name
index|[
name|offset
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|name
operator|+
name|offset
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|expand
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|temp
argument_list|,
literal|'~'
argument_list|)
condition|)
name|temp
operator|=
name|tilde_expand
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|list
operator|=
name|expand_string_unsplit
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|value
operator|=
name|string_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|value
condition|)
name|value
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|entry
operator|=
name|bind_variable
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo_command_at_execute
condition|)
block|{
specifier|extern
name|char
modifier|*
name|indirection_level_string
parameter_list|()
function_decl|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s=%s\n"
argument_list|,
name|indirection_level_string
argument_list|()
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Yes, here is where the special shell variables get tested for.      Don't ask me, I just work here.  This is really stupid.  I would      swear, but I've decided that that is an impolite thing to do in      source that is to be distributed around the net, even if this code      is totally brain-damaged. */
comment|/* if (strcmp (name, "PATH") == 0) Yeeecchhh!!!*/
name|stupidly_hack_special_variables
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry
operator|->
name|attributes
operator|&=
operator|~
name|att_invisible
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Perform the assignment statement in STRING, and expand the    right side by doing command and parameter expansion. */
end_comment

begin_macro
name|do_assignment
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|do_assignment_internal
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Given STRING, an assignment string, get the value of the right side    of the `=', and bind it to the left side.  Do not do command and    parameter substitution on the right hand side. */
end_comment

begin_macro
name|do_assignment_no_expand
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|do_assignment_internal
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Most of the substitutions must be done in parallel.  In order    to avoid using tons of unclear goto's, I have some functions    for manipulating malloc'ed strings.  They all take INDEX, a    pointer to an integer which is the offset into the string    where manipulation is taking place.  They also take SIZE, a    pointer to an integer which is the current length of the    character array for this string. */
end_comment

begin_comment
comment|/* Append SOURCE to TARGET at INDEX.  SIZE is the current amount    of space allocated to TARGET.  SOURCE can be NULL, in which    case nothing happens.  Gets rid of SOURCE by free ()ing it.    Returns TARGET in case the location has changed. */
end_comment

begin_function
name|char
modifier|*
name|sub_append_string
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|,
name|index
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|source
decl_stmt|,
decl|*
name|target
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|index
decl_stmt|,
modifier|*
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|source
condition|)
block|{
while|while
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|source
argument_list|)
operator|>=
call|(
name|int
call|)
argument_list|(
operator|*
name|size
operator|-
operator|*
name|index
argument_list|)
condition|)
name|target
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|target
argument_list|,
operator|*
name|size
operator|+=
name|DEFAULT_ARRAY_SIZE
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
operator|*
name|index
operator|+=
name|strlen
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|target
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Append the textual representation of NUMBER to TARGET.    INDEX and SIZE are as in SUB_APPEND_STRING. */
end_comment

begin_function
name|char
modifier|*
name|sub_append_number
parameter_list|(
name|number
parameter_list|,
name|target
parameter_list|,
name|index
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
decl|*
name|index
decl_stmt|,
modifier|*
name|size
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|target
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|number
argument_list|)
expr_stmt|;
return|return
operator|(
name|sub_append_string
argument_list|(
name|temp
argument_list|,
name|target
argument_list|,
name|index
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return the word list that corresponds to `$*'. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|list_rest_of_args
parameter_list|()
block|{
specifier|register
name|WORD_LIST
modifier|*
name|list
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|WORD_LIST
modifier|*
name|args
init|=
name|rest_of_args
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dollar_vars
index|[
name|i
index|]
condition|)
name|list
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|dollar_vars
index|[
name|i
index|]
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|args
condition|)
block|{
name|list
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|args
operator|->
name|word
operator|->
name|word
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|args
operator|=
name|args
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|list
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make a single large string out of the dollar digit variables,    and the rest_of_args.  If DOLLAR_STAR is 1, then obey the special    case of "$*" with respect to IFS. */
end_comment

begin_function
name|char
modifier|*
name|string_rest_of_args
parameter_list|(
name|dollar_star
parameter_list|)
name|int
name|dollar_star
decl_stmt|;
block|{
specifier|register
name|WORD_LIST
modifier|*
name|list
init|=
name|list_rest_of_args
argument_list|()
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
operator|!
name|dollar_star
condition|)
name|string
operator|=
name|string_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
name|string
operator|=
name|string_list_dollar_star
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  *						   *  *	   Functions to Expand a String		   *  *						   *  ***************************************************/
end_comment

begin_comment
comment|/* Perform parameter expansion, command substitution, and arithmetic    expansion on STRING, as if it were a word.  Leave the result quoted. */
end_comment

begin_function
specifier|static
name|WORD_LIST
modifier|*
name|expand_string_internal
parameter_list|(
name|string
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_DESC
modifier|*
name|make_word
argument_list|()
decl_stmt|,
modifier|*
name|temp
init|=
name|make_word
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|WORD_LIST
modifier|*
name|tresult
decl_stmt|,
modifier|*
name|expand_word_internal
argument_list|()
decl_stmt|;
name|tresult
operator|=
name|expand_word_internal
argument_list|(
name|temp
argument_list|,
name|quoted
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|dispose_word
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|tresult
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand STRING by performing parameter expansion, command substitution,    and arithmetic expansion.  Dequote the resulting WORD_LIST before    returning it, but do not perform word splitting.  The call to    remove_quoted_nulls () is in here because word splitting normally    takes care of quote removal. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|expand_string_unsplit
parameter_list|(
name|string
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|value
init|=
name|expand_string_internal
argument_list|(
name|string
argument_list|,
name|quoted
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|&&
name|value
operator|->
name|word
condition|)
name|remove_quoted_nulls
argument_list|(
name|value
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|dequote_list
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand STRING just as if you were expanding a word.  This also returns    a list of words.  Note that filename globbing is *NOT* done for word    or string expansion, just when the shell is expanding a command.  This    does parameter expansion, command substitution, arithmetic expansion,    and word splitting.  Dequote the resultant WORD_LIST before returning. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|expand_string
parameter_list|(
name|string
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|value
init|=
name|expand_string_internal
argument_list|(
name|string
argument_list|,
name|quoted
argument_list|)
decl_stmt|;
name|WORD_LIST
modifier|*
name|result
decl_stmt|,
modifier|*
name|word_list_split
argument_list|()
decl_stmt|;
name|result
operator|=
name|word_list_split
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|dequote_list
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand STRING just as if you were expanding a word, but do not dequote    the resultant WORD_LIST.  This is called only from within this file,    and is used to correctly preserve quoted characters when expanding    things like ${1+"$@"}.  This does parameter expansion, command    subsitution, arithmetic expansion, and word splitting. */
end_comment

begin_function
specifier|static
name|WORD_LIST
modifier|*
name|expand_string_leave_quoted
parameter_list|(
name|string
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|tlist
init|=
name|expand_string_internal
argument_list|(
name|string
argument_list|,
name|quoted
argument_list|)
decl_stmt|;
name|WORD_LIST
modifier|*
name|tresult
decl_stmt|,
modifier|*
name|word_list_split
argument_list|()
decl_stmt|;
name|tresult
operator|=
name|word_list_split
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|tresult
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  *						   *  *	Functions to handle quoting chars	   *  *						   *  ***************************************************/
end_comment

begin_comment
comment|/* I'm going to have to rewrite expansion because filename globbing is    beginning to make the entire arrangement ugly.  I'll do this soon. */
end_comment

begin_expr_stmt
name|dequote_list
argument_list|(
name|list
argument_list|)
specifier|register
name|WORD_LIST
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|s
operator|=
name|dequote_string
argument_list|(
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|list
operator|->
name|word
operator|->
name|word
operator|=
name|s
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Quote the string S.  Return a new string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|quote_string
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
comment|/* If S is an empty string then simply create a string consisting of a      quoted null. */
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|QUOTE_CHAR
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
name|result
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|savestring
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|result
init|;
name|t
operator|&&
operator|*
name|t
condition|;
name|t
operator|++
control|)
operator|*
name|t
operator||=
literal|0x80
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* De-quoted quoted characters in string s. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dequote_string
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
name|unsigned
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|savestring
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|result
init|;
name|t
operator|&&
operator|*
name|t
condition|;
name|t
operator|++
control|)
operator|*
name|t
operator|=
name|DEQUOTE_CHAR
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Quote the entire WORD_LIST list. */
end_comment

begin_function
specifier|static
name|void
name|quote_list
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|WORD_LIST
modifier|*
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
name|list
init|;
name|w
condition|;
name|w
operator|=
name|w
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|t
init|=
name|w
operator|->
name|word
operator|->
name|word
decl_stmt|;
name|w
operator|->
name|word
operator|->
name|word
operator|=
name|quote_string
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|w
operator|->
name|word
operator|->
name|quoted
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		    Functions for Removing Patterns		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Remove the portion of PARAM matched by PATTERN according to OP, where OP    can have one of 4 values: 	RP_LONG_LEFT	remove longest matching portion at start of PARAM 	RP_SHORT_LEFT	remove shortest matching portion at start of PARAM 	RP_LONG_RIGHT	remove longest matching portion at end of PARAM 	RP_SHORT_RIGHT	remove shortest matching portion at end of PARAM */
end_comment

begin_define
define|#
directive|define
name|RP_LONG_LEFT
value|1
end_define

begin_define
define|#
directive|define
name|RP_SHORT_LEFT
value|2
end_define

begin_define
define|#
directive|define
name|RP_LONG_RIGHT
value|3
end_define

begin_define
define|#
directive|define
name|RP_SHORT_RIGHT
value|4
end_define

begin_function
specifier|static
name|char
modifier|*
name|remove_pattern
parameter_list|(
name|param
parameter_list|,
name|pattern
parameter_list|,
name|op
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|,
decl|*
name|pattern
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|param
condition|?
name|strlen
argument_list|(
name|param
argument_list|)
else|:
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|param
operator|+
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
comment|/* minor optimization */
return|return
operator|(
name|savestring
argument_list|(
name|param
argument_list|)
operator|)
return|;
if|if
condition|(
name|param
operator|==
name|NULL
operator|||
operator|*
name|param
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|param
operator|)
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RP_LONG_LEFT
case|:
comment|/* remove longest match at start */
for|for
control|(
name|p
operator|=
name|end
init|;
name|p
operator|>=
name|param
condition|;
name|p
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|param
argument_list|,
literal|0
argument_list|)
operator|!=
name|FNM_NOMATCH
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|savestring
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
name|RP_SHORT_LEFT
case|:
comment|/* remove shortest match at start */
for|for
control|(
name|p
operator|=
name|param
init|;
name|p
operator|<=
name|end
condition|;
name|p
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|param
argument_list|,
literal|0
argument_list|)
operator|!=
name|FNM_NOMATCH
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|savestring
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
name|RP_LONG_RIGHT
case|:
comment|/* remove longest match at end */
for|for
control|(
name|p
operator|=
name|param
init|;
name|p
operator|<=
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
name|FNM_NOMATCH
condition|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|savestring
argument_list|(
name|param
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
break|break;
case|case
name|RP_SHORT_RIGHT
case|:
comment|/* remove shortest match at end */
for|for
control|(
name|p
operator|=
name|end
init|;
name|p
operator|>=
name|param
condition|;
name|p
operator|--
control|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|pattern
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
operator|!=
name|FNM_NOMATCH
condition|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|savestring
argument_list|(
name|param
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
break|break;
block|}
return|return
operator|(
name|savestring
argument_list|(
name|param
argument_list|)
operator|)
return|;
comment|/* no match, return original string */
block|}
end_block

begin_comment
comment|/*******************************************  *					   *  *	Functions to expand WORD_DESCs	   *  *					   *  *******************************************/
end_comment

begin_comment
comment|/* Expand WORD, performing word splitting on the result.  This does    parameter expansion, command substitution, arithmetic expansion,    word splitting, and quote removal. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|expand_word
parameter_list|(
name|word
parameter_list|,
name|quoted
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|word_list_split
argument_list|()
decl_stmt|,
modifier|*
name|expand_word_internal
argument_list|()
decl_stmt|;
name|WORD_LIST
modifier|*
name|result
decl_stmt|,
modifier|*
name|tresult
decl_stmt|;
name|tresult
operator|=
name|expand_word_internal
argument_list|(
name|word
argument_list|,
name|quoted
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|word_list_split
argument_list|(
name|tresult
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|tresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|dequote_list
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand WORD, but do not perform word splitting on the result.  This    does parameter expansion, command substitution, arithmetic expansion,    and quote removal. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|expand_word_no_split
parameter_list|(
name|word
parameter_list|,
name|quoted
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|expand_word_internal
parameter_list|()
function_decl|;
name|WORD_LIST
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|expand_word_internal
argument_list|(
name|word
argument_list|,
name|quoted
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|dequote_list
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|WORD_LIST
modifier|*
name|expand_word_leave_quoted
parameter_list|(
name|word
parameter_list|,
name|quoted
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|expand_word_internal
argument_list|()
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|expand_word_internal
argument_list|(
name|word
argument_list|,
name|quoted
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of a positional parameter.  This handles values> 10. */
end_comment

begin_function
name|char
modifier|*
name|get_dollar_var_value
parameter_list|(
name|ind
parameter_list|)
name|int
name|ind
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|ind
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|dollar_vars
index|[
name|ind
index|]
condition|)
name|temp
operator|=
name|savestring
argument_list|(
name|dollar_vars
index|[
name|ind
index|]
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
comment|/* We want something like ${11} */
block|{
name|WORD_LIST
modifier|*
name|p
init|=
name|rest_of_args
decl_stmt|;
name|ind
operator|-=
literal|10
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|ind
operator|--
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|temp
operator|=
name|savestring
argument_list|(
name|p
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform command substitution on STRING.  This returns a string,    possibly quoted. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|command_substitute
parameter_list|(
name|string
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|pid_t
name|pid
decl_stmt|,
name|old_pid
decl_stmt|;
name|int
name|fildes
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|istring
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|istring_index
decl_stmt|,
name|istring_size
decl_stmt|,
name|c
init|=
literal|1
decl_stmt|;
specifier|extern
name|int
name|interactive
decl_stmt|,
name|last_command_exit_value
decl_stmt|;
name|istring_index
operator|=
name|istring_size
operator|=
literal|0
expr_stmt|;
comment|/* Don't fork () if there is no need to.  In the case of no command to      run, just return NULL. */
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Pipe the output of executing STRING into the current shell. */
if|if
condition|(
name|pipe
argument_list|(
name|fildes
argument_list|)
operator|<
literal|0
condition|)
block|{
name|report_error
argument_list|(
literal|"Can't make pipes for command substitution!"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|old_pid
operator|=
name|last_made_pid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
block|{
name|pid_t
name|old_pipeline_pgrp
init|=
name|pipeline_pgrp
decl_stmt|;
name|pipeline_pgrp
operator|=
name|shell_pgrp
expr_stmt|;
name|pid
operator|=
name|make_child
argument_list|(
name|savestring
argument_list|(
literal|"command substitution"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_making_children
argument_list|()
expr_stmt|;
name|pipeline_pgrp
operator|=
name|old_pipeline_pgrp
expr_stmt|;
block|}
else|#
directive|else
comment|/* JOB_CONTROL */
name|pid
operator|=
name|make_child
argument_list|(
name|savestring
argument_list|(
literal|"command substitution"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|report_error
argument_list|(
literal|"Can't make a child for command substitution!"
argument_list|)
expr_stmt|;
name|error_exit
label|:
if|if
condition|(
name|istring
condition|)
name|free
argument_list|(
name|istring
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
name|set_job_control
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dup2
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|report_error
argument_list|(
literal|"command_substitute: cannot duplicate pipe as fd 1: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXECUTION_FAILURE
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* If standard output is closed in the parent shell 	 (such as after `exec>&-'), file descriptor 1 will be 	 the lowest available file descriptor, and end up in 	 fildes[0].  This can happen for stdin and stderr as well, 	 but stdout is more important -- it will cause no output 	 to be generated from this command. */
if|if
condition|(
name|fildes
index|[
literal|0
index|]
operator|>
literal|2
condition|)
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|interactive
operator|=
literal|0
expr_stmt|;
name|exit
argument_list|(
name|parse_and_execute
argument_list|(
name|string
argument_list|,
literal|"command substitution"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FILE
modifier|*
name|istream
decl_stmt|;
name|istream
operator|=
name|fdopen
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
operator|&&
name|defined
argument_list|(
name|PGRP_PIPE
argument_list|)
name|close_pgrp_pipe
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL&& PGRP_PIPE */
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istream
condition|)
block|{
name|report_error
argument_list|(
literal|"Can't reopen pipe to command substitution"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* Read the output of the command through the pipe. */
while|while
condition|(
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|Ultrix
argument_list|)
operator|)
name|c
operator|=
name|sysv_getc
argument_list|(
name|istream
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|getc
argument_list|(
name|istream
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Add the character to ISTRING. */
while|while
condition|(
name|istring_index
operator|+
literal|1
operator|>=
name|istring_size
condition|)
name|istring
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|istring
argument_list|,
name|istring_size
operator|+=
name|DEFAULT_ARRAY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
name|istring
index|[
name|istring_index
operator|++
index|]
operator|=
name|QUOTE_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|istring
index|[
name|istring_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|istring
index|[
name|istring_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|fclose
argument_list|(
name|istream
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|last_command_exit_value
operator|=
name|wait_for
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|last_command_subst_pid
operator|=
name|pid
expr_stmt|;
name|last_made_pid
operator|=
name|old_pid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
comment|/* If last_command_exit_value> 128, then the substituted command 	 was terminated by a signal.  If that signal was SIGINT, then send 	 SIGINT to ourselves.  This will break out of loops, for instance. */
if|if
condition|(
name|last_command_exit_value
operator|==
operator|(
literal|128
operator|+
name|SIGINT
operator|)
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
comment|/* wait_for gives the terminal back to shell_pgrp.  If some other          process group should have it, give it away to that group here. */
if|if
condition|(
name|pipeline_pgrp
operator|!=
operator|(
name|pid_t
operator|)
literal|0
condition|)
name|give_terminal_to
argument_list|(
name|pipeline_pgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JOB_CONTROL */
comment|/* If we read no output, just return now and save ourselves some 	 trouble. */
if|if
condition|(
name|istring_index
operator|==
literal|0
condition|)
goto|goto
name|error_exit
goto|;
comment|/* Strip trailing newlines from the output of the command. */
if|if
condition|(
name|quoted
condition|)
block|{
while|while
condition|(
name|istring_index
operator|>
literal|0
operator|&&
name|DEQUOTE_CHAR
argument_list|(
name|istring
index|[
name|istring_index
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|'\n'
condition|)
operator|--
name|istring_index
expr_stmt|;
name|istring
index|[
name|istring_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|strip_trailing
argument_list|(
name|istring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|istring_index
operator|=
name|strlen
argument_list|(
name|istring
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|istring
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/********************************************************  *							*  *	Utility functions for parameter expansion	*  *							*  ********************************************************/
end_comment

begin_comment
comment|/* Handle removing a pattern from a string as a result of ${name%[%]value}    or ${name#[#]value}. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parameter_brace_remove_pattern
parameter_list|(
name|value
parameter_list|,
name|temp
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|,
decl|*
name|temp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pattern_specifier
decl_stmt|;
name|WORD_LIST
modifier|*
name|l
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
operator|*
name|value
operator|==
literal|'#'
condition|)
block|{
name|value
operator|++
expr_stmt|;
name|pattern_specifier
operator|=
name|RP_LONG_LEFT
expr_stmt|;
block|}
else|else
name|pattern_specifier
operator|=
name|RP_SHORT_LEFT
expr_stmt|;
block|}
else|else
comment|/* c == '%' */
block|{
if|if
condition|(
operator|*
name|value
operator|==
literal|'%'
condition|)
block|{
name|value
operator|++
expr_stmt|;
name|pattern_specifier
operator|=
name|RP_LONG_RIGHT
expr_stmt|;
block|}
else|else
name|pattern_specifier
operator|=
name|RP_SHORT_RIGHT
expr_stmt|;
block|}
name|l
operator|=
name|expand_string
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pattern
operator|=
operator|(
name|char
operator|*
operator|)
name|string_list
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|t
operator|=
name|remove_pattern
argument_list|(
name|temp
argument_list|,
name|pattern
argument_list|,
name|pattern_specifier
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Parameter expand NAME, and return a new string which is the expansion,    or NULL if there was no expansion.    VAR_IS_SPECIAL is non-zero if NAME is one of the special variables in    the shell, e.g., "@", "$", "*", etc.  QUOTED, if non-zero, means that    NAME was found inside of a double-quoted expression. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parameter_brace_expand_word
parameter_list|(
name|name
parameter_list|,
name|var_is_special
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|var_is_special
decl_stmt|,
name|quoted
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Handle multiple digit arguments, as in ${11}. */
if|if
condition|(
name|digit
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
name|int
name|arg_index
init|=
name|atoi
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|temp
operator|=
name|get_dollar_var_value
argument_list|(
name|arg_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|var_is_special
condition|)
comment|/* ${@} */
block|{
name|char
modifier|*
name|tt
decl_stmt|;
name|WORD_LIST
modifier|*
name|l
decl_stmt|;
name|tt
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|tt
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|tt
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|tt
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|l
operator|=
name|expand_string_leave_quoted
argument_list|(
name|tt
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
name|temp
operator|=
name|string_list
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SHELL_VAR
modifier|*
name|var
init|=
name|find_variable
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|var
operator|&&
operator|!
name|invisible_p
argument_list|(
name|var
argument_list|)
operator|&&
operator|(
name|temp
operator|=
name|value_cell
argument_list|(
name|var
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expand the right side of a parameter expansion of the form ${NAMEcVALUE},    depending on the value of C, the separating character.  C can be one of    "-", "+", or "=". */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|parameter_brace_expand_rhs
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|c
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|tilde_expand
parameter_list|()
function_decl|;
name|WORD_LIST
modifier|*
name|l
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'~'
operator|||
operator|(
name|index
argument_list|(
name|value
argument_list|,
literal|'~'
argument_list|)
operator|&&
name|unquoted_substring
argument_list|(
literal|"=~"
argument_list|,
name|value
argument_list|)
operator|)
condition|)
name|temp
operator|=
name|tilde_expand
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|l
operator|=
name|expand_string_leave_quoted
argument_list|(
name|temp
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|string_list
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
return|return
operator|(
name|temp
operator|)
return|;
comment|/* c == '=' */
if|if
condition|(
name|temp
condition|)
name|t
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|t1
operator|=
name|dequote_string
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|t1
expr_stmt|;
name|bind_variable
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Deal with the right hand side of a ${name:?value} expansion in the case    that NAME is null or not set.  If VALUE is non-null it is expanded and    used as the error message to print, otherwise a standard message is    printed. */
end_comment

begin_function
specifier|static
name|void
name|parameter_brace_expand_error
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
specifier|extern
name|int
name|interactive
decl_stmt|;
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|WORD_LIST
modifier|*
name|l
init|=
name|expand_string
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp1
init|=
name|string_list
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|temp1
condition|?
name|temp1
else|:
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
condition|)
name|free
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|report_error
argument_list|(
literal|"%s: parameter null or not set"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Free the data we have allocated during this expansion, since we      are about to longjmp out. */
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|FORCE_EOF
argument_list|)
expr_stmt|;
else|else
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Handle the parameter brace expansion that requires us to return the    length of a parameter. */
end_comment

begin_function
specifier|static
name|int
name|parameter_brace_expand_length
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|number
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* ${#} */
block|{
name|WORD_LIST
modifier|*
name|l
init|=
name|list_rest_of_args
argument_list|()
decl_stmt|;
name|number
operator|=
name|list_length
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|!=
literal|'*'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
block|{
name|number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digit
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* ${#1} */
block|{
if|if
condition|(
name|t
operator|=
name|get_dollar_var_value
argument_list|(
name|atoi
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|number
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* ${#PS1} */
block|{
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|newname
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|newname
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|list
operator|=
name|expand_string
argument_list|(
name|newname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|string_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|number
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* ${#@} and ${#*} */
block|{
if|if
condition|(
name|t
operator|=
name|string_rest_of_args
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|number
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|number
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make a word list which is the parameter and variable expansion,    command substitution, arithmetic substitution, and quote removed    expansion of WORD.  Return a pointer to a WORD_LIST which is the    result of the expansion.  If WORD contains a null word, the word    list returned is also null.     QUOTED, when non-zero specifies that the text of WORD is treated    as if it were surrounded by double quotes.    CONTAINS_DOLLAR_AT and EXPANDED_SOMETHING are return values; when non-null    they point to an integer value which receives information about expansion.    CONTAINS_DOLLAR_AT gets non-zero if WORD contained "$@", else zero.    EXPANDED_SOMETHING get non-zero if WORD contained any parameter expansions,    else zero.     This only does word splitting in the case of $@ expansion.  In that    case, we split on ' '. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|expand_word_internal
parameter_list|(
name|word
parameter_list|,
name|quoted
parameter_list|,
name|contains_dollar_at
parameter_list|,
name|expanded_something
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
name|int
name|quoted
decl_stmt|;
name|int
modifier|*
name|contains_dollar_at
decl_stmt|;
name|int
modifier|*
name|expanded_something
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
specifier|extern
name|int
name|last_command_exit_value
decl_stmt|;
comment|/* The thing that we finally output. */
name|WORD_LIST
modifier|*
name|result
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* The intermediate string that we build while expanding. */
name|char
modifier|*
name|istring
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|DEFAULT_ARRAY_SIZE
argument_list|)
decl_stmt|;
comment|/* The current size of the above object. */
name|int
name|istring_size
init|=
name|DEFAULT_ARRAY_SIZE
decl_stmt|;
comment|/* Index into ISTRING. */
name|int
name|istring_index
init|=
literal|0
decl_stmt|;
comment|/* Temporary string storage. */
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* The text of WORD. */
specifier|register
name|char
modifier|*
name|string
init|=
name|word
operator|->
name|word
decl_stmt|;
comment|/* The index into STRING. */
specifier|register
name|int
name|sindex
init|=
literal|0
decl_stmt|;
comment|/* This gets 1 if we see a $@ while quoted. */
name|int
name|quoted_dollar_at
init|=
literal|0
decl_stmt|;
comment|/* This gets 1 if we are to treat backslashes as if we are within double      quotes, but not otherwise behave as if the word is quoted.  This is      used for things like expansion of patterns in case statement pattern      lists.  This is a private variable, but the incoming value of      Q_KEEP_BACKSLASH is passed to recursive invocations of this function. */
name|int
name|preserve_backslashes
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Current character. */
name|int
name|number
decl_stmt|;
comment|/* Temporary number value. */
name|int
name|t_index
decl_stmt|;
comment|/* For calls to string_extract_xxx. */
specifier|extern
name|int
name|interactive
decl_stmt|;
name|char
modifier|*
name|command_subst_result
decl_stmt|;
comment|/* For calls to command_substitute (). */
name|istring
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
goto|goto
name|final_exit
goto|;
if|if
condition|(
name|quoted
operator|&
name|Q_KEEP_BACKSLASH
condition|)
block|{
name|preserve_backslashes
operator|=
literal|1
expr_stmt|;
name|quoted
operator|&=
operator|~
name|Q_KEEP_BACKSLASH
expr_stmt|;
block|}
if|if
condition|(
name|contains_dollar_at
condition|)
operator|*
name|contains_dollar_at
operator|=
literal|0
expr_stmt|;
comment|/* Begin the expansion. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|string
index|[
name|sindex
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Case on toplevel character. */
case|case
literal|'\0'
case|:
goto|goto
name|finished_with_string
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|expanded_something
condition|)
operator|*
name|expanded_something
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|string
index|[
operator|++
name|sindex
index|]
expr_stmt|;
comment|/* Do simple cases first. Switch on what follows '$'. */
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* $0 .. $9? */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|dollar_vars
index|[
name|digit_value
argument_list|(
name|c
argument_list|)
index|]
condition|)
name|temp
operator|=
name|savestring
argument_list|(
name|dollar_vars
index|[
name|digit_value
argument_list|(
name|c
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
goto|goto
name|dollar_add_string
goto|;
case|case
literal|'$'
case|:
comment|/* $$ -- pid of the invoking shell. */
block|{
specifier|extern
name|int
name|dollar_dollar_pid
decl_stmt|;
name|number
operator|=
name|dollar_dollar_pid
expr_stmt|;
block|}
name|add_number
label|:
name|temp
operator|=
name|itos
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|dollar_add_string
label|:
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
comment|/* Add TEMP to ISTRING. */
name|add_string
label|:
name|istring
operator|=
name|sub_append_string
argument_list|(
name|temp
argument_list|,
name|istring
argument_list|,
operator|&
name|istring_index
argument_list|,
operator|&
name|istring_size
argument_list|)
expr_stmt|;
break|break;
comment|/* $# -- number of positional parameters. */
case|case
literal|'#'
case|:
block|{
name|WORD_LIST
modifier|*
name|list
init|=
name|list_rest_of_args
argument_list|()
decl_stmt|;
name|number
operator|=
name|list_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
goto|goto
name|add_number
goto|;
block|}
comment|/* $? -- return value of the last synchronous command. */
case|case
literal|'?'
case|:
name|number
operator|=
name|last_command_exit_value
expr_stmt|;
goto|goto
name|add_number
goto|;
comment|/* $- -- flags supplied to the shell on invocation or by `set'. */
case|case
literal|'-'
case|:
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|which_set_flags
argument_list|()
expr_stmt|;
goto|goto
name|dollar_add_string
goto|;
comment|/* $! -- Pid of the last asynchronous command. */
case|case
literal|'!'
case|:
block|{
name|number
operator|=
operator|(
name|int
operator|)
name|last_asynchronous_pid
expr_stmt|;
comment|/* If no asynchronous pids have been created, echo nothing. */
if|if
condition|(
name|number
operator|==
operator|(
name|int
operator|)
name|NO_PID
condition|)
block|{
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|expanded_something
condition|)
operator|*
name|expanded_something
operator|=
literal|0
expr_stmt|;
break|break;
block|}
goto|goto
name|add_number
goto|;
block|}
comment|/* The only difference between this and $@ is when the 	     arg is quoted. */
case|case
literal|'*'
case|:
comment|/* `$*' */
name|temp
operator|=
name|string_rest_of_args
argument_list|(
name|quoted
argument_list|)
expr_stmt|;
comment|/* In the case of a quoted string, quote the entire arg-list. 	     "$1 $2 $3". */
if|if
condition|(
name|quoted
operator|&&
name|temp
condition|)
block|{
name|char
modifier|*
name|james_brown
init|=
name|temp
decl_stmt|;
name|temp
operator|=
name|quote_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|james_brown
argument_list|)
expr_stmt|;
block|}
goto|goto
name|dollar_add_string
goto|;
comment|/* When we have "$@" what we want is "$1" "$2" "$3" ... This 	     means that we have to turn quoting off after we split into 	     the individually quoted arguments so that the final split 	     on the first character of $IFS is still done.  */
case|case
literal|'@'
case|:
comment|/* `$@' */
block|{
name|WORD_LIST
modifier|*
name|tlist
init|=
name|list_rest_of_args
argument_list|()
decl_stmt|;
if|if
condition|(
name|quoted
operator|&&
name|tlist
condition|)
name|quote_list
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
comment|/* We want to flag the fact that we saw this.  We can't turn off 	       quoting entirely, because other characters in the string might 	       need it (consider "\"$@\""), but we need some way to signal 	       that the final split on the first character of $IFS should be 	       done, even though QUOTED is 1. */
if|if
condition|(
name|quoted
condition|)
name|quoted_dollar_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|contains_dollar_at
condition|)
operator|*
name|contains_dollar_at
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|string_list
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
goto|goto
name|dollar_add_string
goto|;
block|}
comment|/* ${[#]name[[:]#[#]%[%]-=?+[word]]} */
case|case
literal|'{'
case|:
block|{
name|int
name|check_nullness
init|=
literal|0
decl_stmt|;
name|int
name|var_is_set
init|=
literal|0
decl_stmt|;
name|int
name|var_is_null
init|=
literal|0
decl_stmt|;
name|int
name|var_is_special
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|sindex
operator|++
expr_stmt|;
name|t_index
operator|=
name|sindex
expr_stmt|;
name|name
operator|=
name|string_extract
argument_list|(
name|string
argument_list|,
operator|&
name|t_index
argument_list|,
literal|"#%:-=?+}"
argument_list|)
expr_stmt|;
comment|/* If the name really consists of a special variable, then 	       make sure that we have the entire name. */
if|if
condition|(
name|sindex
operator|==
name|t_index
operator|&&
operator|(
name|string
index|[
name|sindex
index|]
operator|==
literal|'-'
operator|||
name|string
index|[
name|sindex
index|]
operator|==
literal|'?'
operator|||
name|string
index|[
name|sindex
index|]
operator|==
literal|'#'
operator|)
condition|)
block|{
name|char
modifier|*
name|tt
decl_stmt|;
name|t_index
operator|++
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tt
operator|=
operator|(
name|string_extract
argument_list|(
name|string
argument_list|,
operator|&
name|t_index
argument_list|,
literal|"#%:-=?+}"
argument_list|)
operator|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
operator|(
name|strlen
argument_list|(
name|tt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|string
index|[
name|sindex
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
name|sindex
operator|=
name|t_index
expr_stmt|;
comment|/* Find out what character ended the variable name.  Then 	       do the appropriate thing. */
if|if
condition|(
name|c
operator|=
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|check_nullness
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
block|}
comment|/* Determine the value of this variable. */
if|if
condition|(
name|digit
argument_list|(
operator|*
name|name
argument_list|)
operator|||
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|1
operator|&&
name|member
argument_list|(
operator|*
name|name
argument_list|,
literal|"#-?$!@*"
argument_list|)
operator|)
condition|)
name|var_is_special
operator|++
expr_stmt|;
comment|/* Check for special expansion things. */
if|if
condition|(
operator|*
name|name
operator|==
literal|'#'
condition|)
block|{
comment|/* Handle ${#-} and ${#?}.  They return the lengths of 		   $- and $?, respectively. */
if|if
condition|(
name|string
index|[
name|sindex
index|]
operator|==
literal|'}'
operator|&&
operator|!
name|name
index|[
literal|1
index|]
operator|&&
operator|!
name|check_nullness
operator|&&
operator|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'?'
operator|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|which_set_flags
argument_list|()
expr_stmt|;
else|else
name|s
operator|=
name|itos
argument_list|(
name|last_command_exit_value
argument_list|)
expr_stmt|;
name|number
operator|=
name|s
condition|?
name|strlen
argument_list|(
name|s
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|add_number
goto|;
block|}
comment|/* Don't allow things like ${#:-foo} to go by; they are 		   errors.  If we are not pointing at the character just 		   after the closing brace, then we haven't gotten all of 		   the name.  Since it begins with a special character, 		   this is a bad substitution.  Explicitly check for ${#:}, 		   which the rules do not catch. */
if|if
condition|(
name|string
index|[
name|sindex
operator|-
literal|1
index|]
operator|!=
literal|'}'
operator|||
name|member
argument_list|(
name|c
argument_list|,
literal|"?-=+"
argument_list|)
operator|||
operator|(
name|string
index|[
name|sindex
operator|-
literal|1
index|]
operator|==
literal|'}'
operator|&&
operator|!
name|name
index|[
literal|1
index|]
operator|&&
name|c
operator|==
literal|'}'
operator|&&
name|check_nullness
operator|)
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|string
expr_stmt|;
goto|goto
name|bad_substitution
goto|;
block|}
name|number
operator|=
name|parameter_brace_expand_length
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* We are pointing one character after the brace which 		   closes this expression.  Since the code at add_number 		   increments SINDEX, we back up a single character here. */
name|sindex
operator|--
expr_stmt|;
goto|goto
name|add_number
goto|;
block|}
comment|/* ${@} is identical to $@. */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|quoted
condition|)
name|quoted_dollar_at
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|contains_dollar_at
condition|)
operator|*
name|contains_dollar_at
operator|=
literal|1
expr_stmt|;
block|}
name|temp
operator|=
name|parameter_brace_expand_word
argument_list|(
name|name
argument_list|,
name|var_is_special
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|var_is_set
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|var_is_set
operator|||
operator|!
name|temp
operator|||
operator|!
operator|*
name|temp
condition|)
name|var_is_null
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|check_nullness
condition|)
name|var_is_null
operator|=
literal|0
expr_stmt|;
comment|/* Get the rest of the stuff inside the braces. */
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
literal|'}'
condition|)
block|{
comment|/* Scan forward searching for last `{'.  This is a hack, 		   it will always be a hack, and it always has been a hack. */
name|t_index
operator|=
name|sindex
expr_stmt|;
name|value
operator|=
name|extract_delimited_string
argument_list|(
name|string
argument_list|,
operator|&
name|t_index
argument_list|,
literal|"{"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|t_index
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
operator|==
literal|'}'
condition|)
name|sindex
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|string
expr_stmt|;
goto|goto
name|bad_substitution
goto|;
block|}
block|}
else|else
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Do the right thing based on which character ended the variable 	       name. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
name|bad_substitution
label|:
name|report_error
argument_list|(
literal|"%s: bad substitution"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"??"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
case|case
literal|'}'
case|:
break|break;
case|case
literal|'#'
case|:
comment|/* ${param#[#]pattern} */
case|case
literal|'%'
case|:
comment|/* ${param%[%]pattern} */
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
operator|||
operator|!
name|temp
operator|||
operator|!
operator|*
name|temp
condition|)
break|break;
name|t
operator|=
name|parameter_brace_remove_pattern
argument_list|(
name|value
argument_list|,
name|temp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|temp
operator|=
name|t
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
case|case
literal|'='
case|:
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
if|if
condition|(
name|var_is_set
operator|&&
operator|!
name|var_is_null
condition|)
block|{
comment|/* We don't want the value of the named variable for 		       anything, just the value of the right hand side. */
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|temp
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|temp
operator|=
name|parameter_brace_expand_rhs
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|c
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Otherwise do nothing.  Just use the value in temp. */
block|}
else|else
comment|/* var not set or var is null */
block|{
if|if
condition|(
name|temp
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
operator|&&
name|var_is_special
condition|)
block|{
name|report_error
argument_list|(
literal|"$%s: cannot assign in this way"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|parameter_brace_expand_error
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'+'
condition|)
name|temp
operator|=
name|parameter_brace_expand_rhs
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|c
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* end case on closing character. */
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
goto|goto
name|add_string
goto|;
block|}
comment|/* end case '{' */
comment|/* break; */
case|case
literal|'('
case|:
comment|/* Do command or arithmetic substitution. */
comment|/* We have to extract the contents of this paren substitution. */
block|{
name|char
modifier|*
name|extract_command_subst
parameter_list|()
function_decl|;
name|int
name|old_index
init|=
operator|++
name|sindex
decl_stmt|;
name|temp
operator|=
name|extract_command_subst
argument_list|(
name|string
argument_list|,
operator|&
name|old_index
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|old_index
expr_stmt|;
comment|/* For the Posix.2-style $(( )) form of arithmetic substitution, 	       extract the expression and pass it to the evaluator. */
if|if
condition|(
name|temp
operator|&&
operator|*
name|temp
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|temp
operator|+
literal|1
decl_stmt|;
name|int
name|last
init|=
name|strlen
argument_list|(
name|t
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|extern
name|long
name|evalexp
parameter_list|()
function_decl|;
if|if
condition|(
name|t
index|[
name|last
index|]
operator|!=
literal|')'
condition|)
block|{
name|report_error
argument_list|(
literal|"%s: bad arithmetic substitution"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* XXX - these are mem leaks */
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
comment|/* Cut off ending `)' */
name|t
index|[
name|last
index|]
operator|=
literal|'\0'
expr_stmt|;
name|number
operator|=
operator|(
name|int
operator|)
name|evalexp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
goto|goto
name|add_number
goto|;
block|}
goto|goto
name|handle_command_substitution
goto|;
block|}
comment|/* Do straight arithmetic substitution. */
case|case
literal|'['
case|:
comment|/* We have to extract the contents of this 	     arithmetic substitution. */
block|{
name|char
modifier|*
name|extract_arithmetic_subst
argument_list|()
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|old_index
init|=
operator|++
name|sindex
decl_stmt|;
name|WORD_LIST
modifier|*
name|l
decl_stmt|;
specifier|extern
name|long
name|evalexp
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|this_command_name
decl_stmt|;
name|temp
operator|=
name|extract_arithmetic_subst
argument_list|(
name|string
argument_list|,
operator|&
name|old_index
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|old_index
expr_stmt|;
comment|/* Do initial variable expansion. */
name|l
operator|=
name|expand_string
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|string_list
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* No error messages. */
name|this_command_name
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|number
operator|=
operator|(
name|int
operator|)
name|evalexp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|add_number
goto|;
block|}
default|default:
block|{
comment|/* Find the variable in VARIABLE_LIST. */
name|int
name|old_index
init|=
name|sindex
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|SHELL_VAR
modifier|*
name|var
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
init|;
operator|(
name|c
operator|=
name|string
index|[
name|sindex
index|]
operator|)
operator|&&
operator|(
name|isletter
argument_list|(
name|c
argument_list|)
operator|||
name|digit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|)
condition|;
name|sindex
operator|++
control|)
empty_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|substring
argument_list|(
name|string
argument_list|,
name|old_index
argument_list|,
name|sindex
argument_list|)
expr_stmt|;
comment|/* If this isn't a variable name, then just output the `$'. */
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|temp
operator|=
name|savestring
argument_list|(
literal|"$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded_something
condition|)
operator|*
name|expanded_something
operator|=
literal|0
expr_stmt|;
goto|goto
name|add_string
goto|;
block|}
comment|/* If the variable exists, return its value cell. */
name|var
operator|=
name|find_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|&&
operator|!
name|invisible_p
argument_list|(
name|var
argument_list|)
operator|&&
name|value_cell
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|temp
operator|=
name|savestring
argument_list|(
name|value_cell
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
goto|goto
name|add_string
goto|;
block|}
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|unbound_vars_is_error
condition|)
name|report_error
argument_list|(
literal|"%s: unbound variable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
goto|goto
name|add_string
goto|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* End case '$': */
case|case
literal|'`'
case|:
comment|/* Backquoted command substitution. */
block|{
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|expanded_something
condition|)
operator|*
name|expanded_something
operator|=
literal|1
expr_stmt|;
name|t_index
operator|=
name|sindex
expr_stmt|;
name|temp
operator|=
name|string_extract
argument_list|(
name|string
argument_list|,
operator|&
name|t_index
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|t_index
expr_stmt|;
name|de_backslash
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|handle_command_substitution
label|:
name|command_subst_result
operator|=
name|command_substitute
argument_list|(
name|temp
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|command_subst_result
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
goto|goto
name|add_string
goto|;
block|}
case|case
literal|'\\'
case|:
if|if
condition|(
name|string
index|[
name|sindex
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|sindex
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|char
modifier|*
name|slashify_chars
init|=
literal|""
decl_stmt|;
name|c
operator|=
name|string
index|[
operator|++
name|sindex
index|]
expr_stmt|;
if|if
condition|(
name|quoted
operator|==
name|Q_HERE_DOCUMENT
condition|)
name|slashify_chars
operator|=
name|slashify_in_here_document
expr_stmt|;
elseif|else
if|if
condition|(
name|quoted
operator|==
name|Q_DOUBLE_QUOTES
condition|)
name|slashify_chars
operator|=
name|slashify_in_quotes
expr_stmt|;
if|if
condition|(
name|preserve_backslashes
operator|||
operator|(
name|quoted
operator|&&
operator|!
name|member
argument_list|(
name|c
argument_list|,
name|slashify_chars
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|temp
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|sindex
operator|++
expr_stmt|;
goto|goto
name|add_string
goto|;
block|}
else|else
block|{
comment|/* This character is quoted, so add it in quoted mode. */
name|c
operator|=
name|QUOTE_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|add_character
goto|;
block|}
block|}
case|case
literal|'"'
case|:
if|if
condition|(
name|quoted
condition|)
goto|goto
name|add_character
goto|;
name|sindex
operator|++
expr_stmt|;
block|{
name|WORD_LIST
modifier|*
name|tresult
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
name|t_index
operator|=
name|sindex
expr_stmt|;
name|temp
operator|=
name|string_extract_double_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|t_index
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|t_index
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|*
name|temp
condition|)
block|{
name|int
name|dollar_at_flag
decl_stmt|;
name|int
name|quoting_flags
init|=
name|Q_DOUBLE_QUOTES
decl_stmt|;
name|WORD_DESC
modifier|*
name|temp_word
init|=
name|make_word
argument_list|(
name|temp
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|preserve_backslashes
condition|)
name|quoting_flags
operator||=
name|Q_KEEP_BACKSLASH
expr_stmt|;
name|tresult
operator|=
name|expand_word_internal
argument_list|(
name|temp_word
argument_list|,
name|quoting_flags
argument_list|,
operator|&
name|dollar_at_flag
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|dispose_word
argument_list|(
name|temp_word
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tresult
operator|&&
name|dollar_at_flag
condition|)
break|break;
comment|/* If we get "$@", we know we have expanded something, so we 	       need to remember it for the final split on $IFS.  This is 	       a special case; it's the only case where a quoted string 	       can expand into more than one word.  It's going to come back 	       from the above call to expand_word_internal as a list with 	       a single word, in which all characters are quoted and 	       separated by blanks.  What we want to do is to turn it back 	       into a list for the next piece of code. */
name|dequote_list
argument_list|(
name|tresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|dollar_at_flag
condition|)
name|quoted_dollar_at
operator|++
expr_stmt|;
if|if
condition|(
name|expanded_something
condition|)
operator|*
name|expanded_something
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* What we have is "".  This is a minor optimization. */
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|tresult
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* The code above *might* return a list (consider the case of "$@", 	   where it returns "$1", "$2", etc.).  We can't throw away the rest 	   of the list, and we have to make sure each word gets added as 	   quoted.  We test on tresult->next:  if it is non-NULL, we quote 	   the whole list, save it to a string with string_list, and add that 	   string. We don't need to quote the results of this (and it would be 	   wrong, since that would quote the separators as well), so we go 	   directly to add_string. */
if|if
condition|(
name|tresult
condition|)
block|{
if|if
condition|(
name|tresult
operator|->
name|next
condition|)
block|{
name|quote_list
argument_list|(
name|tresult
argument_list|)
expr_stmt|;
name|temp
operator|=
name|string_list
argument_list|(
name|tresult
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|tresult
argument_list|)
expr_stmt|;
goto|goto
name|add_string
goto|;
block|}
else|else
block|{
name|temp
operator|=
name|savestring
argument_list|(
name|tresult
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|tresult
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|add_quoted_string
label|:
if|if
condition|(
name|temp
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|temp
decl_stmt|;
name|temp
operator|=
name|quote_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add NULL arg. */
name|temp
operator|=
name|savestring
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|QUOTE_CHAR
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
goto|goto
name|add_string
goto|;
block|}
comment|/* break; */
case|case
literal|'\''
case|:
block|{
if|if
condition|(
operator|!
name|quoted
condition|)
block|{
name|sindex
operator|++
expr_stmt|;
name|t_index
operator|=
name|sindex
expr_stmt|;
name|temp
operator|=
name|string_extract_verbatim
argument_list|(
name|string
argument_list|,
operator|&
name|t_index
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|t_index
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|temp
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
goto|goto
name|add_quoted_string
goto|;
block|}
else|else
goto|goto
name|add_character
goto|;
break|break;
block|}
default|default:
comment|/* This is the fix for " $@ " */
if|if
condition|(
name|quoted
condition|)
name|c
operator|=
name|QUOTE_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|add_character
label|:
while|while
condition|(
name|istring_index
operator|+
literal|1
operator|>=
name|istring_size
condition|)
name|istring
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|istring
argument_list|,
name|istring_size
operator|+=
name|DEFAULT_ARRAY_SIZE
argument_list|)
expr_stmt|;
name|istring
index|[
name|istring_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|istring
index|[
name|istring_index
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Next character. */
name|sindex
operator|++
expr_stmt|;
block|}
block|}
name|finished_with_string
label|:
name|final_exit
label|:
comment|/* OK, we're ready to return.  If we have a quoted string, and      quoted_dollar_at is not set, we do no splitting at all; otherwise      we split on ' '.  The routines that call this will handle what to      do if nothing has been expanded. */
if|if
condition|(
name|istring
condition|)
block|{
name|WORD_LIST
modifier|*
name|temp_list
decl_stmt|;
if|if
condition|(
name|quoted_dollar_at
condition|)
name|temp_list
operator|=
name|list_string
argument_list|(
name|istring
argument_list|,
literal|" "
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|istring
condition|)
block|{
name|temp_list
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|istring
argument_list|)
argument_list|,
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|temp_list
operator|->
name|word
operator|->
name|quoted
operator|=
name|quoted
expr_stmt|;
block|}
else|else
name|temp_list
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|istring
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|list_append
argument_list|(
name|reverse_list
argument_list|(
name|result
argument_list|)
argument_list|,
name|temp_list
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*              Functions for Quote Removal			    */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Perform quote removal on STRING.  If QUOTED> 0, assume we are obeying the    backslash quoting rules for within double quotes. */
end_comment

begin_function
name|char
modifier|*
name|string_quote_removal
parameter_list|(
name|string
parameter_list|,
name|quoted
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|result_string
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp1
decl_stmt|;
name|int
name|sindex
decl_stmt|,
name|tindex
decl_stmt|,
name|c
decl_stmt|;
comment|/* The result can be no longer than the original string. */
name|r
operator|=
name|result_string
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|string
index|[
name|sindex
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|c
operator|=
name|string
index|[
operator|++
name|sindex
index|]
expr_stmt|;
if|if
condition|(
name|quoted
operator|&&
operator|!
name|member
argument_list|(
name|c
argument_list|,
name|slashify_in_quotes
argument_list|)
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
operator|*
name|r
operator|++
operator|=
name|c
expr_stmt|;
name|sindex
operator|++
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|tindex
operator|=
operator|++
name|sindex
expr_stmt|;
name|temp
operator|=
name|string_extract_double_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|tindex
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|tindex
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
name|temp1
operator|=
name|string_quote_removal
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX is this needed? */
if|if
condition|(
name|temp
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp1
condition|)
block|{
name|strcpy
argument_list|(
name|r
argument_list|,
name|temp1
argument_list|)
expr_stmt|;
name|r
operator|+=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|quoted
condition|)
block|{
operator|*
name|r
operator|++
operator|=
name|c
expr_stmt|;
name|sindex
operator|++
expr_stmt|;
block|}
else|else
block|{
name|tindex
operator|=
operator|++
name|sindex
expr_stmt|;
name|temp
operator|=
name|string_extract_verbatim
argument_list|(
name|string
argument_list|,
operator|&
name|tindex
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|tindex
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|strcpy
argument_list|(
name|r
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|r
operator|+=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
operator|*
name|r
operator|++
operator|=
name|c
expr_stmt|;
name|sindex
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result_string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform quote removal on word WORD.  This allocates and returns a new    WORD_DESC *. */
end_comment

begin_function
name|WORD_DESC
modifier|*
name|word_quote_removal
parameter_list|(
name|word
parameter_list|,
name|quoted
parameter_list|)
name|WORD_DESC
modifier|*
name|word
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_DESC
modifier|*
name|w
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|string_quote_removal
argument_list|(
name|word
operator|->
name|word
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
name|w
operator|=
name|make_word
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform quote removal on all words in LIST.  If QUOTED is non-zero,    the members of the list are treated as if they are surrounded by    double quotes.  Return a new list, or NULL if LIST is NULL. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|word_list_quote_removal
parameter_list|(
name|list
parameter_list|,
name|quoted
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
name|int
name|quoted
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|result
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|tresult
decl_stmt|;
name|t
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|tresult
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|->
name|word
operator|=
name|word_quote_removal
argument_list|(
name|t
operator|->
name|word
argument_list|,
name|quoted
argument_list|)
expr_stmt|;
name|tresult
operator|->
name|next
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
name|result
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|list_append
argument_list|(
name|result
argument_list|,
name|tresult
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTDEF
argument_list|)
end_if

begin_comment
comment|/* Currently unused. */
end_comment

begin_comment
comment|/* Return 1 if CHARACTER appears in an unquoted portion of    STRING.  Return 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|unquoted_member
parameter_list|(
name|character
parameter_list|,
name|string
parameter_list|)
name|int
name|character
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|sindex
decl_stmt|,
name|tindex
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|sindex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|string
index|[
name|sindex
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|character
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|tindex
operator|=
operator|++
name|sindex
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|temp
operator|=
name|string_extract_double_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|tindex
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|string_extract_verbatim
argument_list|(
name|string
argument_list|,
operator|&
name|tindex
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|tindex
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sindex
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_comment
comment|/* Return 1 if SUBSTR appears in an unquoted portion of STRING. */
end_comment

begin_function
specifier|static
name|int
name|unquoted_substring
parameter_list|(
name|substr
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|substr
decl_stmt|,
decl|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|sindex
decl_stmt|,
name|tindex
decl_stmt|,
name|c
decl_stmt|,
name|sublen
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|substr
operator|||
operator|!
operator|*
name|substr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sublen
operator|=
name|strlen
argument_list|(
name|substr
argument_list|)
expr_stmt|;
name|sindex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|string
index|[
name|sindex
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|substr
operator|&&
name|strncmp
argument_list|(
name|string
operator|+
name|sindex
argument_list|,
name|substr
argument_list|,
name|sublen
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|tindex
operator|=
operator|++
name|sindex
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|temp
operator|=
name|string_extract_double_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|tindex
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|string_extract_verbatim
argument_list|(
name|string
argument_list|,
operator|&
name|tindex
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|sindex
operator|=
name|tindex
expr_stmt|;
if|if
condition|(
name|string
index|[
name|sindex
index|]
condition|)
name|sindex
operator|++
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sindex
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************  *					   *  *    Functions to perform word splitting  *  *					   *  *******************************************/
end_comment

begin_comment
comment|/* This splits a single word into a WORD LIST on $IFS, but only if the word    is not quoted.  list_string () performs quote removal for us, even if we    don't do any splitting. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|word_split
parameter_list|(
name|w
parameter_list|)
name|WORD_DESC
modifier|*
name|w
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|w
condition|)
block|{
name|SHELL_VAR
modifier|*
name|ifs
init|=
name|find_variable
argument_list|(
literal|"IFS"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ifs_chars
decl_stmt|;
comment|/* If IFS is unset, it defaults to " \t\n". */
if|if
condition|(
name|ifs
condition|)
name|ifs_chars
operator|=
name|value_cell
argument_list|(
name|ifs
argument_list|)
expr_stmt|;
else|else
name|ifs_chars
operator|=
literal|" \t\n"
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|quoted
operator|||
operator|!
name|ifs_chars
condition|)
name|ifs_chars
operator|=
literal|""
expr_stmt|;
name|result
operator|=
name|list_string
argument_list|(
name|w
operator|->
name|word
argument_list|,
name|ifs_chars
argument_list|,
name|w
operator|->
name|quoted
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform word splitting on LIST and return the RESULT.  It is possible    to return (WORD_LIST *)NULL. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|word_list_split
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|result
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|tresult
decl_stmt|;
name|t
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|tresult
operator|=
name|word_split
argument_list|(
name|t
operator|->
name|word
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|list_append
argument_list|(
name|result
argument_list|,
name|tresult
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************  * 						  *  *	Functions to expand an entire WORD_LIST	  *  *						  *  **************************************************/
end_comment

begin_comment
comment|/* Do all of the assignments in LIST up to a word which isn't an    assignment. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|get_rid_of_variable_assignments
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|WORD_LIST
modifier|*
name|orig
init|=
name|list
decl_stmt|;
while|while
condition|(
name|list
condition|)
if|if
condition|(
operator|!
name|list
operator|->
name|word
operator|->
name|assignment
condition|)
block|{
name|WORD_LIST
modifier|*
name|new_list
init|=
name|copy_word_list
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|dispose_words
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
else|else
block|{
name|do_assignment
argument_list|(
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
name|dispose_words
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check and handle the case where there are some variable assignments    in LIST which go into the environment for this command. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|get_rid_of_environment_assignments
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|WORD_LIST
modifier|*
name|tlist
init|=
name|list
decl_stmt|;
specifier|register
name|WORD_LIST
modifier|*
name|new_list
decl_stmt|;
while|while
condition|(
name|tlist
condition|)
block|{
if|if
condition|(
operator|!
name|tlist
operator|->
name|word
operator|->
name|assignment
condition|)
goto|goto
name|make_assignments
goto|;
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
block|}
comment|/* Since all of the assignments are variable assignments. */
return|return
operator|(
name|list
operator|)
return|;
name|make_assignments
label|:
name|tlist
operator|=
name|list
expr_stmt|;
while|while
condition|(
name|tlist
condition|)
block|{
if|if
condition|(
name|tlist
operator|->
name|word
operator|->
name|assignment
condition|)
name|assign_in_env
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|place_keywords_in_env
condition|)
block|{
name|new_list
operator|=
name|copy_word_list
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
block|}
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
block|}
comment|/* We got all of the keywords assigned.  Now return the remainder      of the words. */
block|{
specifier|register
name|WORD_LIST
modifier|*
name|new_list
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
name|tlist
operator|=
name|list
expr_stmt|;
comment|/* Skip the ones at the start. */
while|while
condition|(
name|tlist
operator|&&
name|tlist
operator|->
name|word
operator|->
name|assignment
condition|)
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
comment|/* If we placed all the keywords in the list into the environment,        then remove them from the output list. */
if|if
condition|(
name|place_keywords_in_env
condition|)
block|{
while|while
condition|(
name|tlist
condition|)
block|{
if|if
condition|(
operator|!
name|tlist
operator|->
name|word
operator|->
name|assignment
condition|)
name|new_list
operator|=
name|make_word_list
argument_list|(
name|copy_word
argument_list|(
name|tlist
operator|->
name|word
argument_list|)
argument_list|,
name|new_list
argument_list|)
expr_stmt|;
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
block|}
name|new_list
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|new_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just copy the list. */
name|new_list
operator|=
name|copy_word_list
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
block|}
name|dispose_words
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Take the list of words in LIST and do the various substitutions.  Return    a new list of words which is the expanded list, and without things like    variable assignments. */
end_comment

begin_function_decl
specifier|static
name|WORD_LIST
modifier|*
name|expand_words_internal
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|WORD_LIST
modifier|*
name|expand_words
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
return|return
operator|(
name|expand_words_internal
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Same as expand_words (), but doesn't hack variable or environment    variables. */
end_comment

begin_function
name|WORD_LIST
modifier|*
name|expand_words_no_vars
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
return|return
operator|(
name|expand_words_internal
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Non-zero means to allow unmatched globbed filenames to expand to    a null file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_null_glob_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The workhorse for expand_words () and expand_words_no_var ().    First arg is LIST, a WORD_LIST of words.    Second arg DO_VARS is non-zero if you want to do environment and    variable assignments, else zero.     This does all of the subsitutions: brace expansion, tilde expansion,    parameter expansion, command substitution, arithmetic expansion,    word splitting, and pathname expansion. */
end_comment

begin_function
specifier|static
name|WORD_LIST
modifier|*
name|expand_words_internal
parameter_list|(
name|list
parameter_list|,
name|do_vars
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
name|int
name|do_vars
decl_stmt|;
block|{
specifier|register
name|WORD_LIST
modifier|*
name|tlist
decl_stmt|,
modifier|*
name|new_list
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
name|WORD_LIST
modifier|*
name|orig_list
decl_stmt|;
specifier|extern
name|int
name|no_brace_expansion
decl_stmt|;
name|tlist
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|copy_word_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_vars
condition|)
block|{
comment|/* Handle the case where the arguments are assignments for 	 the environment of this command. */
name|tlist
operator|=
name|get_rid_of_environment_assignments
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
comment|/* Handle the case where the arguments are all variable assignments. */
name|tlist
operator|=
name|get_rid_of_variable_assignments
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
block|}
comment|/* Begin expanding the words that remain.  The expansions take place on      things that aren't really variable assignments. */
if|if
condition|(
operator|!
name|tlist
condition|)
return|return
operator|(
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Do brace expansion on this word if there are any brace characters      in the string. */
if|if
condition|(
operator|!
name|no_brace_expansion
condition|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|brace_expand
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
modifier|*
name|expansions
decl_stmt|;
name|WORD_LIST
modifier|*
name|braces
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|eindex
decl_stmt|;
name|orig_list
operator|=
name|tlist
expr_stmt|;
while|while
condition|(
name|tlist
condition|)
block|{
comment|/* Only do brace expansion if the word has a brace character.  If 	     not, just copy the word list element, add it to braces, and 	     continue.  In the common case, at least when running shell 	     scripts, this will degenerate to a bunch of calls to `index', 	     and then what is basically the body of copy_word_list. */
if|if
condition|(
name|index
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|,
literal|'{'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|expansions
operator|=
name|brace_expand
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
for|for
control|(
name|eindex
operator|=
literal|0
init|;
name|expansions
index|[
name|eindex
index|]
condition|;
name|eindex
operator|++
control|)
block|{
name|braces
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|expansions
index|[
name|eindex
index|]
argument_list|)
argument_list|,
name|braces
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansions
index|[
name|eindex
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|expansions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WORD_LIST
modifier|*
name|new
init|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WORD_LIST
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|word
operator|=
name|copy_word
argument_list|(
name|tlist
operator|->
name|word
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|braces
expr_stmt|;
name|braces
operator|=
name|new
expr_stmt|;
block|}
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
block|}
name|dispose_words
argument_list|(
name|orig_list
argument_list|)
expr_stmt|;
name|tlist
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|braces
argument_list|)
expr_stmt|;
block|}
name|orig_list
operator|=
name|tlist
expr_stmt|;
comment|/* We do tilde expansion all the time.  This is what 1003.2 says. */
while|while
condition|(
name|tlist
condition|)
block|{
specifier|register
name|char
modifier|*
name|current_word
decl_stmt|;
name|WORD_LIST
modifier|*
name|expanded
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|expanded_something
init|=
literal|0
decl_stmt|;
name|current_word
operator|=
name|tlist
operator|->
name|word
operator|->
name|word
expr_stmt|;
if|if
condition|(
name|current_word
index|[
literal|0
index|]
operator|==
literal|'~'
operator|||
operator|(
name|index
argument_list|(
name|current_word
argument_list|,
literal|'~'
argument_list|)
operator|&&
name|unquoted_substring
argument_list|(
literal|"=~"
argument_list|,
name|current_word
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|tilde_expand
argument_list|()
decl_stmt|,
modifier|*
name|tt
decl_stmt|;
name|tt
operator|=
name|tlist
operator|->
name|word
operator|->
name|word
expr_stmt|;
name|tlist
operator|->
name|word
operator|->
name|word
operator|=
name|tilde_expand
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tt
argument_list|)
expr_stmt|;
block|}
name|expanded
operator|=
name|expand_word_internal
argument_list|(
name|tlist
operator|->
name|word
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|expanded_something
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded_something
condition|)
name|t
operator|=
name|word_list_split
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If no parameter expansion, command substitution, or arithmetic 	     substitution took place, then do not do word splitting.  We 	     still have to remove quoted null characters from the result. */
name|word_list_remove_quoted_nulls
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
name|t
operator|=
name|copy_word_list
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
block|}
name|new_list
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|list_append
argument_list|(
name|reverse_list
argument_list|(
name|t
argument_list|)
argument_list|,
name|new_list
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|expanded
argument_list|)
expr_stmt|;
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
block|}
name|new_list
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|reverse_list
argument_list|(
name|new_list
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|orig_list
argument_list|)
expr_stmt|;
comment|/* Okay, we're almost done.  Now let's just do some filename      globbing. */
block|{
name|char
modifier|*
modifier|*
name|shell_glob_filename
argument_list|()
decl_stmt|,
modifier|*
modifier|*
name|temp_list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|list_index
decl_stmt|;
name|WORD_LIST
modifier|*
name|glob_list
decl_stmt|;
name|orig_list
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
name|tlist
operator|=
name|new_list
expr_stmt|;
if|if
condition|(
operator|!
name|disallow_filename_globbing
condition|)
block|{
while|while
condition|(
name|tlist
condition|)
block|{
comment|/* If the word isn't quoted, then glob it. */
if|if
condition|(
operator|!
name|tlist
operator|->
name|word
operator|->
name|quoted
operator|&&
name|glob_pattern_p
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|temp_list
operator|=
name|shell_glob_filename
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
comment|/* Fix the hi-bits. (This is how we quoted 		   special characters.) */
block|{
specifier|register
name|char
modifier|*
name|t
init|=
name|dequote_string
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|tlist
operator|->
name|word
operator|->
name|word
operator|=
name|t
expr_stmt|;
block|}
comment|/* Handle error cases. 		   I don't think we should report errors like "No such file 		   or directory".  However, I would like to report errors 		   like "Read failed". */
if|#
directive|if
name|defined
argument_list|(
name|USE_GLOB_LIBRARY
argument_list|)
if|if
condition|(
operator|!
name|temp_list
condition|)
else|#
directive|else
if|if
condition|(
name|temp_list
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
endif|#
directive|endif
comment|/* !USE_GLOB_LIBRARY */
block|{
comment|/* file_error (tlist->word->word); */
comment|/* A small memory leak, I think */
name|temp_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|temp_list
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_GLOB_LIBRARY
argument_list|)
if|if
condition|(
operator|!
name|temp_list
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !USE_GLOB_LIBRARY */
comment|/* Make the array into a word list. */
name|glob_list
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|list_index
operator|=
literal|0
init|;
name|temp_list
index|[
name|list_index
index|]
condition|;
name|list_index
operator|++
control|)
name|glob_list
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
name|temp_list
index|[
name|list_index
index|]
argument_list|)
argument_list|,
name|glob_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|glob_list
condition|)
name|orig_list
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|list_append
argument_list|(
name|glob_list
argument_list|,
name|orig_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|allow_null_glob_expansion
condition|)
name|orig_list
operator|=
name|make_word_list
argument_list|(
name|copy_word
argument_list|(
name|tlist
operator|->
name|word
argument_list|)
argument_list|,
name|orig_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fix the hi-bits. (This is how we quoted special 		   characters.) */
specifier|register
name|char
modifier|*
name|t
init|=
name|dequote_string
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|tlist
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|tlist
operator|->
name|word
operator|->
name|word
operator|=
name|t
expr_stmt|;
name|orig_list
operator|=
name|make_word_list
argument_list|(
name|copy_word
argument_list|(
name|tlist
operator|->
name|word
argument_list|)
argument_list|,
name|orig_list
argument_list|)
expr_stmt|;
block|}
name|free_array
argument_list|(
name|temp_list
argument_list|)
expr_stmt|;
name|temp_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|tlist
operator|=
name|tlist
operator|->
name|next
expr_stmt|;
block|}
name|dispose_words
argument_list|(
name|new_list
argument_list|)
expr_stmt|;
name|new_list
operator|=
name|orig_list
expr_stmt|;
block|}
else|else
block|{
comment|/* Fix the hi-bits. (This is how we quoted special characters.) */
specifier|register
name|WORD_LIST
modifier|*
name|wl
init|=
name|new_list
decl_stmt|;
specifier|register
name|char
modifier|*
name|wp
decl_stmt|;
while|while
condition|(
name|wl
condition|)
block|{
name|wp
operator|=
name|dequote_string
argument_list|(
name|wl
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wl
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|wl
operator|->
name|word
operator|->
name|word
operator|=
name|wp
expr_stmt|;
name|wl
operator|=
name|wl
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|new_list
operator|)
return|;
block|}
block|}
return|return
operator|(
name|WORD_LIST
operator|*
operator|)
operator|(
name|reverse_list
argument_list|(
name|new_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Call the glob library to do globbing on PATHNAME.    PATHNAME can contain characters with the hi bit set; this indicates    that the character is to be quoted.  We quote it here. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|shell_glob_filename
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_GLOB_LIBRARY
argument_list|)
block|{
specifier|extern
name|int
name|glob_dot_filenames
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
modifier|*
name|return_value
decl_stmt|;
name|glob_t
name|filenames
decl_stmt|;
name|int
name|glob_flags
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
literal|2
operator|*
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|pathname
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|QUOTED_CHAR
argument_list|(
name|pathname
index|[
name|i
index|]
argument_list|)
condition|)
name|temp
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|temp
index|[
name|j
index|]
operator|=
name|DEQUOTE_CHAR
argument_list|(
name|pathname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|temp
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filenames
operator|.
name|gl_offs
operator|=
literal|0
expr_stmt|;
name|glob_flags
operator|=
name|glob_dot_filenames
condition|?
name|GLOB_PERIOD
else|:
literal|0
expr_stmt|;
name|glob_flags
operator||=
operator|(
name|GLOB_ERR
operator||
name|GLOB_DOOFFS
operator|)
expr_stmt|;
name|i
operator|=
name|glob
argument_list|(
name|temp
argument_list|,
name|glob_flags
argument_list|,
operator|(
name|Function
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|filenames
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|GLOB_NOSPACE
operator|||
name|i
operator|==
name|GLOB_ABEND
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|i
operator|==
name|GLOB_NOMATCH
condition|)
name|filenames
operator|.
name|gl_pathv
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|filenames
operator|.
name|gl_pathv
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_GLOB_LIBRARY */
end_comment

begin_block
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|glob_filename
parameter_list|()
function_decl|;
specifier|extern
name|int
name|glob_dot_filenames
decl_stmt|,
name|noglob_dot_filenames
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
modifier|*
name|results
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
operator|(
literal|2
operator|*
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|noglob_dot_filenames
operator|=
operator|!
name|glob_dot_filenames
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|pathname
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|QUOTED_CHAR
argument_list|(
name|pathname
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|temp
index|[
name|j
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|temp
index|[
name|j
index|]
operator|=
name|DEQUOTE_CHAR
argument_list|(
name|pathname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
index|[
name|j
index|]
operator|=
name|pathname
index|[
name|i
index|]
expr_stmt|;
block|}
name|temp
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|results
operator|=
name|glob_filename
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|&&
name|results
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
name|sort_char_array
argument_list|(
name|results
argument_list|)
expr_stmt|;
return|return
operator|(
name|results
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_GLOB_LIBRARY */
end_comment

begin_comment
comment|/*************************************************  *						 *  *	Functions to manage special variables	 *  *						 *  *************************************************/
end_comment

begin_comment
comment|/* An alist of name.function for each special variable.  Most of the    functions don't do much, and in fact, this would be faster with a    switch statement, but by the end of this file, I am sick of switch    statements. */
end_comment

begin_comment
comment|/* The functions that get called. */
end_comment

begin_decl_stmt
name|int
name|sv_path
argument_list|()
decl_stmt|,
name|sv_mail
argument_list|()
decl_stmt|,
name|sv_terminal
argument_list|()
decl_stmt|,
name|sv_histsize
argument_list|()
decl_stmt|,
name|sv_histfilesize
argument_list|()
decl_stmt|,
name|sv_uids
argument_list|()
decl_stmt|,
name|sv_ignoreeof
argument_list|()
decl_stmt|,
name|sv_glob_dot_filenames
argument_list|()
decl_stmt|,
name|sv_histchars
argument_list|()
decl_stmt|,
name|sv_nolinks
argument_list|()
decl_stmt|,
name|sv_hostname_completion_file
argument_list|()
decl_stmt|,
name|sv_history_control
argument_list|()
decl_stmt|,
name|sv_noclobber
argument_list|()
decl_stmt|,
name|sv_allow_null_glob_expansion
argument_list|()
decl_stmt|,
name|sv_command_oriented_history
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GETOPTS_BUILTIN
argument_list|)
end_if

begin_decl_stmt
name|int
name|sv_optind
argument_list|()
decl_stmt|,
name|sv_opterr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GETOPTS_BUILTIN */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_function_decl
specifier|extern
name|int
name|sv_notify
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|name_and_function
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|}
name|special_vars
index|[]
init|=
block|{
block|{
literal|"PATH"
block|,
name|sv_path
block|}
block|,
block|{
literal|"MAIL"
block|,
name|sv_mail
block|}
block|,
block|{
literal|"MAILPATH"
block|,
name|sv_mail
block|}
block|,
block|{
literal|"MAILCHECK"
block|,
name|sv_mail
block|}
block|,
block|{
literal|"TERMCAP"
block|,
name|sv_terminal
block|}
block|,
block|{
literal|"TERM"
block|,
name|sv_terminal
block|}
block|,
block|{
literal|"HISTSIZE"
block|,
name|sv_histsize
block|}
block|,
block|{
literal|"HISTFILESIZE"
block|,
name|sv_histfilesize
block|}
block|,
block|{
literal|"EUID"
block|,
name|sv_uids
block|}
block|,
block|{
literal|"UID"
block|,
name|sv_uids
block|}
block|,
block|{
literal|"IGNOREEOF"
block|,
name|sv_ignoreeof
block|}
block|,
block|{
literal|"ignoreeof"
block|,
name|sv_ignoreeof
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|GETOPTS_BUILTIN
argument_list|)
block|{
literal|"OPTIND"
block|,
name|sv_optind
block|}
block|,
block|{
literal|"OPTERR"
block|,
name|sv_opterr
block|}
block|,
endif|#
directive|endif
comment|/* GETOPTS_BUILTIN */
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
block|{
literal|"notify"
block|,
name|sv_notify
block|}
block|,
endif|#
directive|endif
comment|/* JOB_CONTROL */
block|{
literal|"glob_dot_filenames"
block|,
name|sv_glob_dot_filenames
block|}
block|,
block|{
literal|"allow_null_glob_expansion"
block|,
name|sv_allow_null_glob_expansion
block|}
block|,
block|{
literal|"command_oriented_history"
block|,
name|sv_command_oriented_history
block|}
block|,
block|{
literal|"histchars"
block|,
name|sv_histchars
block|}
block|,
block|{
literal|"hostname_completion_file"
block|,
name|sv_hostname_completion_file
block|}
block|,
block|{
literal|"history_control"
block|,
name|sv_history_control
block|}
block|,
block|{
literal|"noclobber"
block|,
name|sv_noclobber
block|}
block|,
block|{
literal|"nolinks"
block|,
name|sv_nolinks
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0x00
block|,
operator|(
name|Function
operator|*
operator|)
literal|0x00
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* The variable in NAME has just had its state changed.  Check to see if it    is one of the special ones where something special happens. */
end_comment

begin_macro
name|stupidly_hack_special_variables
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|special_vars
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|special_vars
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|(
operator|*
operator|(
name|special_vars
index|[
name|i
index|]
operator|.
name|function
operator|)
operator|)
operator|(
name|name
operator|)
expr_stmt|;
return|return;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Set/unset noclobber. */
end_comment

begin_macro
name|sv_noclobber
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|noclobber
decl_stmt|;
if|if
condition|(
name|find_variable
argument_list|(
name|name
argument_list|)
condition|)
name|noclobber
operator|=
literal|1
expr_stmt|;
else|else
name|noclobber
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What to do just after the PATH variable has changed. */
end_comment

begin_macro
name|sv_path
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* hash -r */
name|WORD_LIST
modifier|*
name|args
decl_stmt|;
name|args
operator|=
name|make_word_list
argument_list|(
name|make_word
argument_list|(
literal|"-r"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hash_builtin
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What to do just after one of the MAILxxxx variables has changed.  NAME    is the name of the variable.  */
end_comment

begin_macro
name|sv_mail
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If the time interval for checking the files has changed, then      reset the mail timer.  Otherwise, one of the pathname vars      to the users mailbox has changed, so rebuild the array of      filenames. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MAILCHECK"
argument_list|)
operator|==
literal|0
condition|)
name|reset_mail_timer
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MAIL"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MAILPATH"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free_mail_files
argument_list|()
expr_stmt|;
name|remember_mail_dates
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* What to do just after one of the TERMxxx variables has changed.    If we are an interactive shell, then try to reset the terminal    information in readline. */
end_comment

begin_macro
name|sv_terminal
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|interactive
decl_stmt|;
if|if
condition|(
name|interactive
condition|)
name|rl_reset_terminal
argument_list|(
name|get_string_value
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What to do after the HISTSIZE variable changes.    If there is a value for this variable (and it is numeric), then stifle    the history.  Otherwise, if there is NO value for this variable,    unstifle the history. */
end_comment

begin_macro
name|sv_histsize
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
init|=
name|get_string_value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|int
name|num
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|num
argument_list|)
operator|==
literal|1
condition|)
block|{
specifier|extern
name|int
name|history_lines_this_session
decl_stmt|;
name|stifle_history
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|history_lines_this_session
operator|>
name|where_history
argument_list|()
condition|)
name|history_lines_this_session
operator|=
name|where_history
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|unstifle_history
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* What to do if the HISTFILESIZE variable changes. */
end_comment

begin_macro
name|sv_histfilesize
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
init|=
name|get_string_value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
specifier|extern
name|int
name|history_lines_in_file
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|num
argument_list|)
operator|==
literal|1
condition|)
block|{
name|history_truncate_file
argument_list|(
name|get_string_value
argument_list|(
literal|"HISTFILE"
argument_list|)
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<=
name|history_lines_in_file
condition|)
name|history_lines_in_file
operator|=
name|num
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* A nit for picking at history saving.    Value of 0 means save all lines parsed by the shell on the history.    Value of 1 means save all lines that do not start with a space.    Value of 2 means save all lines that do not match the last line saved. */
end_comment

begin_decl_stmt
name|int
name|history_control
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What to do after the HISTORY_CONTROL variable changes. */
end_comment

begin_macro
name|sv_history_control
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
init|=
name|get_string_value
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|history_control
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|*
name|temp
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"ignorespace"
argument_list|)
operator|==
literal|0
condition|)
name|history_control
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"ignoredups"
argument_list|)
operator|==
literal|0
condition|)
name|history_control
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* By default, every line is saved in the history individually.  I.e.,    if the user enters: 	bash$ for i in a b c> do> echo $i> done    Each line will be individually saved in the history.  	bash$ history 	10  for i in a b c         11  do         12  echo $i         13  done         14  history    If the variable command_oriented_history is set, multiple lines    which form one command will be saved as one history entry. 	bash$ for i in a b c> do> echo $i> done         bash$ history 	10  for i in a b c     do     echo $i     done         11  history    The user can then recall the whole command all at once instead    of just being able to recall one line at a time.    */
end_comment

begin_decl_stmt
name|int
name|command_oriented_history
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What to do after the COMMAND_ORIENTED_HISTORY variable changes. */
end_comment

begin_macro
name|sv_command_oriented_history
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|find_variable
argument_list|(
name|name
argument_list|)
operator|!=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
condition|)
name|command_oriented_history
operator|=
literal|1
expr_stmt|;
else|else
name|command_oriented_history
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If the variable exists, then the value of it can be the number    of times we actually ignore the EOF.  The default is small,    (smaller than csh, anyway). */
end_comment

begin_macro
name|sv_ignoreeof
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|eof_encountered
decl_stmt|,
name|eof_encountered_limit
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|get_string_value
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|new_limit
decl_stmt|;
name|eof_encountered
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
operator|(
name|sscanf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|new_limit
argument_list|)
operator|==
literal|1
operator|)
condition|)
name|eof_encountered_limit
operator|=
name|new_limit
expr_stmt|;
else|else
name|eof_encountered_limit
operator|=
literal|10
expr_stmt|;
comment|/* csh uses 26. */
block|}
end_block

begin_comment
comment|/* Control whether * matches .files in globbing.  Yechh. */
end_comment

begin_decl_stmt
name|int
name|glob_dot_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|sv_glob_dot_filenames
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|find_variable
argument_list|(
name|name
argument_list|)
operator|!=
operator|(
name|SHELL_VAR
operator|*
operator|)
name|NULL
condition|)
name|glob_dot_filenames
operator|=
literal|1
expr_stmt|;
else|else
name|glob_dot_filenames
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Setting/unsetting of the history expansion character. */
end_comment

begin_decl_stmt
name|char
name|old_history_expansion_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|old_history_comment_char
init|=
literal|'#'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|old_history_subst_char
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_macro
name|sv_histchars
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
name|history_expansion_char
decl_stmt|;
specifier|extern
name|char
name|history_comment_char
decl_stmt|;
specifier|extern
name|char
name|history_subst_char
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|get_string_value
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|old_history_expansion_char
operator|=
name|history_expansion_char
expr_stmt|;
name|history_expansion_char
operator|=
operator|*
name|temp
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|1
index|]
condition|)
block|{
name|old_history_subst_char
operator|=
name|history_subst_char
expr_stmt|;
name|history_subst_char
operator|=
name|temp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|2
index|]
condition|)
block|{
name|old_history_comment_char
operator|=
name|history_comment_char
expr_stmt|;
name|history_comment_char
operator|=
name|temp
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|history_expansion_char
operator|=
literal|'!'
expr_stmt|;
name|history_subst_char
operator|=
literal|'^'
expr_stmt|;
name|history_comment_char
operator|=
literal|'#'
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_comment
comment|/* Job notification feature desired? */
end_comment

begin_macro
name|sv_notify
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|asynchronous_notification
decl_stmt|;
if|if
condition|(
name|get_string_value
argument_list|(
name|name
argument_list|)
condition|)
name|asynchronous_notification
operator|=
literal|1
expr_stmt|;
else|else
name|asynchronous_notification
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOB_CONTROL */
end_comment

begin_comment
comment|/* If the variable `nolinks' exists, it specifies that symbolic links are    not to be followed in `cd' commands. */
end_comment

begin_macro
name|sv_nolinks
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|follow_symbolic_links
decl_stmt|;
name|follow_symbolic_links
operator|=
operator|!
name|find_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Don't let users hack the user id variables. */
end_comment

begin_macro
name|sv_uids
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|uid
init|=
name|getuid
argument_list|()
decl_stmt|;
name|int
name|euid
init|=
name|geteuid
argument_list|()
decl_stmt|;
name|char
name|buff
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|SHELL_VAR
modifier|*
name|v
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|v
operator|=
name|find_variable
argument_list|(
literal|"UID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|v
operator|->
name|attributes
operator|&=
operator|~
name|att_readonly
expr_stmt|;
name|v
operator|=
name|bind_variable
argument_list|(
literal|"UID"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|v
operator|->
name|attributes
operator||=
operator|(
name|att_readonly
operator||
name|att_integer
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d"
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|v
operator|=
name|find_variable
argument_list|(
literal|"EUID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|v
operator|->
name|attributes
operator|&=
operator|~
name|att_readonly
expr_stmt|;
name|v
operator|=
name|bind_variable
argument_list|(
literal|"EUID"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|v
operator|->
name|attributes
operator||=
operator|(
name|att_readonly
operator||
name|att_integer
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|sv_hostname_completion_file
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|hostname_list_initialized
decl_stmt|;
name|hostname_list_initialized
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|sv_allow_null_glob_expansion
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|allow_null_glob_expansion
operator|=
operator|(
name|int
operator|)
name|find_variable
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GETOPTS_BUILTIN
argument_list|)
end_if

begin_macro
name|sv_optind
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tt
init|=
name|get_string_value
argument_list|(
literal|"OPTIND"
argument_list|)
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tt
operator|&&
operator|*
name|tt
condition|)
block|{
name|s
operator|=
name|atoi
argument_list|(
name|tt
argument_list|)
expr_stmt|;
comment|/* According to POSIX, setting OPTIND=1 resets the internal state 	 of getopt (). */
if|if
condition|(
name|s
operator|<
literal|0
operator|||
name|s
operator|==
literal|1
condition|)
name|s
operator|=
literal|0
expr_stmt|;
block|}
name|getopts_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|sv_opterr
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|tt
init|=
name|get_string_value
argument_list|(
literal|"OPTERR"
argument_list|)
decl_stmt|;
name|int
name|s
init|=
literal|1
decl_stmt|;
specifier|extern
name|int
name|opterr
decl_stmt|;
if|if
condition|(
name|tt
condition|)
name|s
operator|=
name|atoi
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|opterr
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GETOPTS_BUILTIN */
end_comment

end_unit

