begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mkbuiltins.c - Create builtins.c, builtext.h, and builtdoc.c from    a single source file called builtins.def. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1991 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"../filecntl.h"
end_include

begin_define
define|#
directive|define
name|DOCFILE
value|"builtins.texi"
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|savestring
parameter_list|(
name|x
parameter_list|)
value|(char *)strcpy (xmalloc (1 + strlen (x)), (x))
end_define

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == ' ') || ((c) == '\t'))
end_define

begin_comment
comment|/* If this stream descriptor is non-zero, then write    texinfo documentation to it. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|documentation_file
init|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to only produce documentation. */
end_comment

begin_decl_stmt
name|int
name|only_documentation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to not do any productions. */
end_comment

begin_decl_stmt
name|int
name|inhibit_production
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of a directory to precede the filename when reporting    errors. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|error_directory
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the structure file. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|struct_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the external declaration file. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|extern_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is a structure for manipulating arrays of data. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|size
decl_stmt|;
comment|/* Number of slots allocated to array. */
name|int
name|index
decl_stmt|;
comment|/* Current location in array. */
name|int
name|width
decl_stmt|;
comment|/* Size of each element. */
name|int
name|growth_rate
decl_stmt|;
comment|/* How fast to grow. */
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
comment|/* The array itself. */
block|}
name|ARRAY
typedef|;
end_typedef

begin_comment
comment|/* Here is a structure defining a single BUILTIN. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The name of this builtin. */
name|char
modifier|*
name|function
decl_stmt|;
comment|/* The name of the function to call. */
name|char
modifier|*
name|shortdoc
decl_stmt|;
comment|/* The short documentation for this builtin. */
name|char
modifier|*
name|docname
decl_stmt|;
comment|/* Possible name for documentation string. */
name|ARRAY
modifier|*
name|longdoc
decl_stmt|;
comment|/* The long documentation for this builtin. */
name|ARRAY
modifier|*
name|dependencies
decl_stmt|;
comment|/* Null terminated array of #define names. */
block|}
name|BUILTIN_DESC
typedef|;
end_typedef

begin_comment
comment|/* Here is a structure which defines a DEF file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The name of the input def file. */
name|ARRAY
modifier|*
name|lines
decl_stmt|;
comment|/* The contents of the file. */
name|int
name|line_number
decl_stmt|;
comment|/* The current line number. */
name|char
modifier|*
name|production
decl_stmt|;
comment|/* The name of the production file. */
name|FILE
modifier|*
name|output
decl_stmt|;
comment|/* Open file stream for PRODUCTION. */
name|ARRAY
modifier|*
name|builtins
decl_stmt|;
comment|/* Null terminated array of BUILTIN_DESC *. */
block|}
name|DEF_FILE
typedef|;
end_typedef

begin_comment
comment|/* The array of all builtins encountered during execution of this code. */
end_comment

begin_decl_stmt
name|ARRAY
modifier|*
name|saved_builtins
init|=
operator|(
name|ARRAY
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* For each file mentioned on the command line, process it and    write the information to STRUCTFILE and EXTERNFILE, while    creating the production file if neccessary. */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|arg_index
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|structfile
decl_stmt|,
modifier|*
name|externfile
decl_stmt|;
name|char
modifier|*
name|documentation_filename
decl_stmt|,
modifier|*
name|temp_struct_filename
decl_stmt|;
name|structfile
operator|=
name|externfile
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
name|documentation_filename
operator|=
name|DOCFILE
expr_stmt|;
name|temp_struct_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|arg_index
operator|<
name|argc
operator|&&
name|argv
index|[
name|arg_index
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|arg_index
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-externfile"
argument_list|)
operator|==
literal|0
condition|)
name|extern_filename
operator|=
name|argv
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-structfile"
argument_list|)
operator|==
literal|0
condition|)
name|struct_filename
operator|=
name|argv
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-noproduction"
argument_list|)
operator|==
literal|0
condition|)
name|inhibit_production
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-document"
argument_list|)
operator|==
literal|0
condition|)
name|documentation_file
operator|=
name|fopen
argument_list|(
name|documentation_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-D"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|error_directory
condition|)
name|free
argument_list|(
name|error_directory
argument_list|)
expr_stmt|;
name|error_directory
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|argv
index|[
name|arg_index
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|error_directory
argument_list|,
name|argv
index|[
name|arg_index
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|error_directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|error_directory
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|error_directory
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|arg_index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-documentonly"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|only_documentation
operator|=
literal|1
expr_stmt|;
name|documentation_file
operator|=
name|fopen
argument_list|(
name|documentation_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown flag %s.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there are no files to process, just quit now. */
if|if
condition|(
name|arg_index
operator|==
name|argc
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|only_documentation
condition|)
block|{
comment|/* Open the files. */
if|if
condition|(
name|struct_filename
condition|)
block|{
name|temp_struct_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp_struct_filename
argument_list|,
literal|"mk-%d"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|structfile
operator|=
name|fopen
argument_list|(
name|temp_struct_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|structfile
condition|)
name|file_error
argument_list|(
name|temp_struct_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extern_filename
condition|)
block|{
name|externfile
operator|=
name|fopen
argument_list|(
name|extern_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|externfile
condition|)
name|file_error
argument_list|(
name|extern_filename
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the headers. */
name|write_file_headers
argument_list|(
name|structfile
argument_list|,
name|externfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|documentation_file
condition|)
block|{
name|fprintf
argument_list|(
name|documentation_file
argument_list|,
literal|"@c Table of builtins created with %s.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|documentation_file
argument_list|,
literal|"@ftable @asis\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Process the .def files. */
while|while
condition|(
name|arg_index
operator|<
name|argc
condition|)
block|{
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
name|argv
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
name|extract_info
argument_list|(
name|arg
argument_list|,
name|structfile
argument_list|,
name|externfile
argument_list|)
expr_stmt|;
block|}
comment|/* Close the files. */
if|if
condition|(
operator|!
name|only_documentation
condition|)
block|{
comment|/* Write the footers. */
name|write_file_footers
argument_list|(
name|structfile
argument_list|,
name|externfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|structfile
condition|)
block|{
name|write_longdocs
argument_list|(
name|structfile
argument_list|,
name|saved_builtins
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|structfile
argument_list|)
expr_stmt|;
name|link
argument_list|(
name|temp_struct_filename
argument_list|,
name|struct_filename
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|temp_struct_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|externfile
condition|)
name|fclose
argument_list|(
name|externfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|documentation_file
condition|)
block|{
name|fprintf
argument_list|(
name|documentation_file
argument_list|,
literal|"@end ftable\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|documentation_file
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		  Array Functions and Manipulators		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Make a new array, and return a pointer to it.  The array will    contain elements of size WIDTH, and is initialized to no elements. */
end_comment

begin_function
name|ARRAY
modifier|*
name|array_create
parameter_list|(
name|width
parameter_list|)
name|int
name|width
decl_stmt|;
block|{
name|ARRAY
modifier|*
name|array
decl_stmt|;
name|array
operator|=
operator|(
name|ARRAY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ARRAY
argument_list|)
argument_list|)
expr_stmt|;
name|array
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|array
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|array
operator|->
name|width
operator|=
name|width
expr_stmt|;
comment|/* Default to increasing size in units of 20. */
name|array
operator|->
name|growth_rate
operator|=
literal|20
expr_stmt|;
name|array
operator|->
name|array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|array
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the array of strings in ARRAY. */
end_comment

begin_function
name|ARRAY
modifier|*
name|copy_string_array
parameter_list|(
name|array
parameter_list|)
name|ARRAY
modifier|*
name|array
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|ARRAY
modifier|*
name|copy
decl_stmt|;
if|if
condition|(
operator|!
name|array
condition|)
return|return
operator|(
name|ARRAY
operator|*
operator|)
name|NULL
return|;
name|copy
operator|=
name|array_create
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|size
operator|=
name|array
operator|->
name|size
expr_stmt|;
name|copy
operator|->
name|index
operator|=
name|array
operator|->
name|index
expr_stmt|;
name|copy
operator|->
name|width
operator|=
name|array
operator|->
name|width
expr_stmt|;
name|copy
operator|->
name|array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|array
operator|->
name|index
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array
operator|->
name|index
condition|;
name|i
operator|++
control|)
name|copy
operator|->
name|array
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|array
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|copy
operator|->
name|array
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add ELEMENT to ARRAY, growing the array if neccessary. */
end_comment

begin_macro
name|array_add
argument_list|(
argument|element
argument_list|,
argument|array
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|element
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ARRAY
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|array
operator|->
name|index
operator|+
literal|2
operator|>
name|array
operator|->
name|size
condition|)
name|array
operator|->
name|array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|array
operator|->
name|array
argument_list|,
operator|(
name|array
operator|->
name|size
operator|+=
name|array
operator|->
name|growth_rate
operator|)
operator|*
name|array
operator|->
name|width
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BCOPY
argument_list|)
name|bcopy
argument_list|(
operator|&
name|element
argument_list|,
operator|&
operator|(
name|array
operator|->
name|array
index|[
name|array
operator|->
name|index
index|]
operator|)
argument_list|,
name|array
operator|->
name|width
argument_list|)
expr_stmt|;
name|array
operator|->
name|index
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|&
operator|(
name|array
operator|->
name|array
index|[
name|array
operator|->
name|index
index|]
operator|)
argument_list|,
name|array
operator|->
name|width
argument_list|)
expr_stmt|;
else|#
directive|else
name|array
operator|->
name|array
index|[
name|array
operator|->
name|index
operator|++
index|]
operator|=
name|element
expr_stmt|;
name|array
operator|->
name|array
index|[
name|array
operator|->
name|index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* !HAVE_BCOPY */
block|}
end_block

begin_comment
comment|/* Free an allocated array and data pointer. */
end_comment

begin_macro
name|array_free
argument_list|(
argument|array
argument_list|)
end_macro

begin_decl_stmt
name|ARRAY
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|array
operator|->
name|array
condition|)
name|free
argument_list|(
name|array
operator|->
name|array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		       Processing a DEF File			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The definition of a function. */
end_comment

begin_typedef
typedef|typedef
name|int
name|Function
parameter_list|()
function_decl|;
end_typedef

begin_comment
comment|/* Structure handles processor directives. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|directive
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|}
name|HANDLER_ENTRY
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|builtin_handler
argument_list|()
decl_stmt|,
name|function_handler
argument_list|()
decl_stmt|,
name|short_doc_handler
argument_list|()
decl_stmt|,
name|comment_handler
argument_list|()
decl_stmt|,
name|depends_on_handler
argument_list|()
decl_stmt|,
name|produces_handler
argument_list|()
decl_stmt|,
name|end_handler
argument_list|()
decl_stmt|,
name|docname_handler
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HANDLER_ENTRY
name|handlers
index|[]
init|=
block|{
block|{
literal|"BUILTIN"
block|,
name|builtin_handler
block|}
block|,
block|{
literal|"DOCNAME"
block|,
name|docname_handler
block|}
block|,
block|{
literal|"FUNCTION"
block|,
name|function_handler
block|}
block|,
block|{
literal|"SHORT_DOC"
block|,
name|short_doc_handler
block|}
block|,
block|{
literal|"$"
block|,
name|comment_handler
block|}
block|,
block|{
literal|"COMMENT"
block|,
name|comment_handler
block|}
block|,
block|{
literal|"DEPENDS_ON"
block|,
name|depends_on_handler
block|}
block|,
block|{
literal|"PRODUCES"
block|,
name|produces_handler
block|}
block|,
block|{
literal|"END"
block|,
name|end_handler
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|Function
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the entry in the table of handlers for NAME. */
end_comment

begin_function
name|HANDLER_ENTRY
modifier|*
name|find_directive
parameter_list|(
name|directive
parameter_list|)
name|char
modifier|*
name|directive
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|handlers
index|[
name|i
index|]
operator|.
name|directive
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|handlers
index|[
name|i
index|]
operator|.
name|directive
argument_list|,
name|directive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
name|handlers
index|[
name|i
index|]
operator|)
return|;
return|return
operator|(
operator|(
name|HANDLER_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Non-zero indicates that a $BUILTIN has been seen, but not    the corresponding $END. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|building_builtin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to output cpp line and file information before    printing the current line to the production file. */
end_comment

begin_decl_stmt
name|int
name|output_cpp_line_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The main function of this program.  Read FILENAME and act on what is    found.  Lines not starting with a dollar sign are copied to the    $PRODUCES target, if one is present.  Lines starting with a dollar sign    are directives to this program, specifying the name of the builtin, the    function to call, the short documentation and the long documentation    strings.  FILENAME can contain multiple $BUILTINs, but only one $PRODUCES    target.  After the file has been processed, write out the names of    builtins found in each $BUILTIN.  Plain text found before the $PRODUCES    is ignored, as is "$$ comment text". */
end_comment

begin_macro
name|extract_info
argument_list|(
argument|filename
argument_list|,
argument|structfile
argument_list|,
argument|externfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|structfile
decl_stmt|,
modifier|*
name|externfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|file_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|file_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|finfo
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|finfo
operator|.
name|st_size
argument_list|)
operator|!=
name|finfo
operator|.
name|st_size
condition|)
name|file_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Create and fill in the initial structure describing this file. */
name|defs
operator|=
operator|(
name|DEF_FILE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEF_FILE
argument_list|)
argument_list|)
expr_stmt|;
name|defs
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|defs
operator|->
name|lines
operator|=
name|array_create
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|defs
operator|->
name|line_number
operator|=
literal|0
expr_stmt|;
name|defs
operator|->
name|production
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|defs
operator|->
name|output
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
name|defs
operator|->
name|builtins
operator|=
operator|(
name|ARRAY
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Build the array of lines. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|finfo
operator|.
name|st_size
condition|)
block|{
name|array_add
argument_list|(
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
name|defs
operator|->
name|lines
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
name|i
operator|<
name|finfo
operator|.
name|st_size
condition|)
name|i
operator|++
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Begin processing the input file.  We don't write any output      until we have a file to write output to. */
name|output_cpp_line_info
operator|=
literal|1
expr_stmt|;
comment|/* Process each line in the array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
operator|=
name|defs
operator|->
name|lines
operator|->
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|defs
operator|->
name|line_number
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'$'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|directive
decl_stmt|;
name|HANDLER_ENTRY
modifier|*
name|handler
decl_stmt|;
comment|/* Isolate the directive. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|line
index|[
name|j
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|line
index|[
name|j
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
name|directive
operator|=
name|xmalloc
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|directive
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|j
operator|-
literal|1
argument_list|)
expr_stmt|;
name|directive
index|[
name|j
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get the function handler and call it. */
name|handler
operator|=
name|find_directive
argument_list|(
name|directive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handler
condition|)
block|{
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"Unknown directive `%s'"
argument_list|,
name|directive
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Advance to the first non-whitespace character. */
while|while
condition|(
name|whitespace
argument_list|(
name|line
index|[
name|j
index|]
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
comment|/* Call the directive handler with the FILE, and ARGS. */
operator|(
operator|*
operator|(
name|handler
operator|->
name|function
operator|)
operator|)
operator|(
name|directive
operator|,
name|defs
operator|,
name|line
operator|+
name|j
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|building_builtin
condition|)
name|add_documentation
argument_list|(
name|defs
argument_list|,
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defs
operator|->
name|output
condition|)
block|{
if|if
condition|(
name|output_cpp_line_info
condition|)
block|{
name|fprintf
argument_list|(
name|defs
operator|->
name|output
argument_list|,
literal|"#line %d \"%s%s\"\n"
argument_list|,
name|defs
operator|->
name|line_number
operator|+
literal|1
argument_list|,
name|error_directory
argument_list|,
name|defs
operator|->
name|filename
argument_list|)
expr_stmt|;
name|output_cpp_line_info
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|defs
operator|->
name|output
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Close the production file. */
if|if
condition|(
name|defs
operator|->
name|output
condition|)
name|fclose
argument_list|(
name|defs
operator|->
name|output
argument_list|)
expr_stmt|;
comment|/* The file has been processed.  Write the accumulated builtins to      the builtins.c file, and write the extern definitions to the      builtext.h file. */
name|write_builtins
argument_list|(
name|defs
argument_list|,
name|structfile
argument_list|,
name|externfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free_defs
argument_list|(
name|defs
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|free_safely
parameter_list|(
name|x
parameter_list|)
value|if (x) free (x)
end_define

begin_comment
comment|/* Free all of the memory allocated to a DEF_FILE. */
end_comment

begin_macro
name|free_defs
argument_list|(
argument|defs
argument_list|)
end_macro

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
if|if
condition|(
name|defs
operator|->
name|production
condition|)
name|free
argument_list|(
name|defs
operator|->
name|production
argument_list|)
expr_stmt|;
if|if
condition|(
name|defs
operator|->
name|builtins
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|builtin
operator|=
operator|(
name|BUILTIN_DESC
operator|*
operator|)
name|defs
operator|->
name|builtins
operator|->
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free_safely
argument_list|(
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_safely
argument_list|(
name|builtin
operator|->
name|function
argument_list|)
expr_stmt|;
name|free_safely
argument_list|(
name|builtin
operator|->
name|shortdoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin
operator|->
name|dependencies
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|builtin
operator|->
name|dependencies
operator|->
name|array
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|builtin
operator|->
name|dependencies
operator|->
name|array
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|array_free
argument_list|(
name|builtin
operator|->
name|dependencies
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|builtin
operator|->
name|longdoc
condition|)
name|array_free
argument_list|(
name|builtin
operator|->
name|longdoc
argument_list|)
expr_stmt|;
block|}
name|array_free
argument_list|(
name|defs
operator|->
name|builtins
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|defs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     The Handler Functions Themselves		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Strip surrounding whitespace from STRING, and    return a pointer to the start of it. */
end_comment

begin_function
name|char
modifier|*
name|strip_whitespace
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|string
operator|++
expr_stmt|;
name|remove_trailing_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove only the trailing whitespace from STRING. */
end_comment

begin_macro
name|remove_trailing_whitespace
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
name|string
index|[
operator|++
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Ensure that there is a argument in STRING and return it.    FOR_WHOM is the name of the directive which needs the argument.    DEFS is the DEF_FILE in which the directive is found.    If there is no argument, produce an error. */
end_comment

begin_function
name|char
modifier|*
name|get_arg
parameter_list|(
name|for_whom
parameter_list|,
name|defs
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|for_whom
decl_stmt|,
decl|*
name|string
decl_stmt|;
end_function

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|strip_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|new
condition|)
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"%s requires an argument"
argument_list|,
name|for_whom
argument_list|)
expr_stmt|;
return|return
operator|(
name|savestring
argument_list|(
name|new
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Error if not building a builtin. */
end_comment

begin_macro
name|must_be_building
argument_list|(
argument|directive
argument_list|,
argument|defs
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|directive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|building_builtin
condition|)
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"%s must be inside of a $BUILTIN block"
argument_list|,
name|directive
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the current builtin. */
end_comment

begin_function
name|BUILTIN_DESC
modifier|*
name|current_builtin
parameter_list|(
name|directive
parameter_list|,
name|defs
parameter_list|)
name|char
modifier|*
name|directive
decl_stmt|;
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
block|{
name|must_be_building
argument_list|(
name|directive
argument_list|,
name|defs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BUILTIN_DESC
operator|*
operator|)
name|defs
operator|->
name|builtins
operator|->
name|array
index|[
name|defs
operator|->
name|builtins
operator|->
name|index
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add LINE to the long documentation for the current builtin.    Ignore blank lines until the first non-blank line has been seen. */
end_comment

begin_macro
name|add_documentation
argument_list|(
argument|defs
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
name|builtin
operator|=
name|current_builtin
argument_list|(
literal|"(implied LONGDOC)"
argument_list|,
name|defs
argument_list|)
expr_stmt|;
name|remove_trailing_whitespace
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
operator|&&
operator|!
name|builtin
operator|->
name|longdoc
condition|)
return|return;
if|if
condition|(
operator|!
name|builtin
operator|->
name|longdoc
condition|)
name|builtin
operator|->
name|longdoc
operator|=
name|array_create
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|array_add
argument_list|(
name|line
argument_list|,
name|builtin
operator|->
name|longdoc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* How to handle the $BUILTIN directive. */
end_comment

begin_function
name|int
name|builtin_handler
parameter_list|(
name|self
parameter_list|,
name|defs
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|self
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If we are already building a builtin, we cannot start a new one. */
if|if
condition|(
name|building_builtin
condition|)
return|return
operator|(
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"%s found before $END"
argument_list|,
name|self
argument_list|)
operator|)
return|;
name|output_cpp_line_info
operator|++
expr_stmt|;
comment|/* Get the name of this builtin, and stick it in the array. */
block|{
name|BUILTIN_DESC
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|get_arg
argument_list|(
name|self
argument_list|,
name|defs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* If this is the first builtin, create the array to hold them. */
if|if
condition|(
operator|!
name|defs
operator|->
name|builtins
condition|)
name|defs
operator|->
name|builtins
operator|=
name|array_create
argument_list|(
sizeof|sizeof
argument_list|(
name|BUILTIN_DESC
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
name|BUILTIN_DESC
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BUILTIN_DESC
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|function
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|shortdoc
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|docname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|longdoc
operator|=
operator|(
name|ARRAY
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|dependencies
operator|=
operator|(
name|ARRAY
operator|*
operator|)
name|NULL
expr_stmt|;
name|array_add
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
name|defs
operator|->
name|builtins
argument_list|)
expr_stmt|;
name|building_builtin
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* How to handle the $FUNCTION directive. */
end_comment

begin_function
name|int
name|function_handler
parameter_list|(
name|self
parameter_list|,
name|defs
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|self
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
name|builtin
operator|=
name|current_builtin
argument_list|(
name|self
argument_list|,
name|defs
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin
operator|->
name|function
condition|)
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"%s already has a function (%s)"
argument_list|,
name|builtin
operator|->
name|name
argument_list|,
name|builtin
operator|->
name|function
argument_list|)
expr_stmt|;
else|else
name|builtin
operator|->
name|function
operator|=
name|get_arg
argument_list|(
name|self
argument_list|,
name|defs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* How to handle the $DOCNAME directive. */
end_comment

begin_function
name|int
name|docname_handler
parameter_list|(
name|self
parameter_list|,
name|defs
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|self
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
name|builtin
operator|=
name|current_builtin
argument_list|(
name|self
argument_list|,
name|defs
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin
operator|->
name|docname
condition|)
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"%s already had a docname (%s)"
argument_list|,
name|builtin
operator|->
name|name
argument_list|,
name|builtin
operator|->
name|docname
argument_list|)
expr_stmt|;
else|else
name|builtin
operator|->
name|docname
operator|=
name|get_arg
argument_list|(
name|self
argument_list|,
name|defs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* How to handle the $SHORT_DOC directive. */
end_comment

begin_macro
name|short_doc_handler
argument_list|(
argument|self
argument_list|,
argument|defs
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|self
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
name|builtin
operator|=
name|current_builtin
argument_list|(
name|self
argument_list|,
name|defs
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin
operator|->
name|shortdoc
condition|)
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"%s already has short documentation (%s)"
argument_list|,
name|builtin
operator|->
name|name
argument_list|,
name|builtin
operator|->
name|shortdoc
argument_list|)
expr_stmt|;
else|else
name|builtin
operator|->
name|shortdoc
operator|=
name|get_arg
argument_list|(
name|self
argument_list|,
name|defs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* How to handle the $COMMENT directive. */
end_comment

begin_macro
name|comment_handler
argument_list|(
argument|self
argument_list|,
argument|defs
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|self
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* How to handle the $DEPENDS_ON directive. */
end_comment

begin_macro
name|depends_on_handler
argument_list|(
argument|self
argument_list|,
argument|defs
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|self
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
name|char
modifier|*
name|dependent
decl_stmt|;
name|builtin
operator|=
name|current_builtin
argument_list|(
name|self
argument_list|,
name|defs
argument_list|)
expr_stmt|;
name|dependent
operator|=
name|get_arg
argument_list|(
name|self
argument_list|,
name|defs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|builtin
operator|->
name|dependencies
condition|)
name|builtin
operator|->
name|dependencies
operator|=
name|array_create
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|array_add
argument_list|(
name|dependent
argument_list|,
name|builtin
operator|->
name|dependencies
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* How to handle the $PRODUCES directive. */
end_comment

begin_macro
name|produces_handler
argument_list|(
argument|self
argument_list|,
argument|defs
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|self
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If just hacking documentation, don't change any of the production      files. */
if|if
condition|(
name|only_documentation
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|output_cpp_line_info
operator|++
expr_stmt|;
if|if
condition|(
name|defs
operator|->
name|production
condition|)
name|line_error
argument_list|(
name|defs
argument_list|,
literal|"%s already has a %s definition"
argument_list|,
name|defs
operator|->
name|filename
argument_list|,
name|self
argument_list|)
expr_stmt|;
else|else
block|{
name|defs
operator|->
name|production
operator|=
name|get_arg
argument_list|(
name|self
argument_list|,
name|defs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|inhibit_production
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|defs
operator|->
name|output
operator|=
name|fopen
argument_list|(
name|defs
operator|->
name|production
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defs
operator|->
name|output
condition|)
name|file_error
argument_list|(
name|defs
operator|->
name|production
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|defs
operator|->
name|output
argument_list|,
literal|"/* %s, created from %s. */\n"
argument_list|,
name|defs
operator|->
name|production
argument_list|,
name|defs
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* How to handle the $END directive. */
end_comment

begin_macro
name|end_handler
argument_list|(
argument|self
argument_list|,
argument|defs
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|self
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|must_be_building
argument_list|(
name|self
argument_list|,
name|defs
argument_list|)
expr_stmt|;
name|building_builtin
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		    Error Handling Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Produce an error for DEFS with FORMAT and ARGS. */
end_comment

begin_macro
name|line_error
argument_list|(
argument|defs
argument_list|,
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s:%d:"
argument_list|,
name|error_directory
argument_list|,
name|defs
operator|->
name|filename
argument_list|,
name|defs
operator|->
name|line_number
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message for FILENAME. */
end_comment

begin_macro
name|file_error
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			xmalloc and xrealloc ()		     	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mkbuiltins: Out of virtual memory!\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		  Creating the Struct and Extern Files		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return a pointer to a newly allocated builtin which is    an exact copy of BUILTIN. */
end_comment

begin_function
name|BUILTIN_DESC
modifier|*
name|copy_builtin
parameter_list|(
name|builtin
parameter_list|)
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
block|{
name|BUILTIN_DESC
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|BUILTIN_DESC
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BUILTIN_DESC
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
name|new
operator|->
name|shortdoc
operator|=
name|savestring
argument_list|(
name|builtin
operator|->
name|shortdoc
argument_list|)
expr_stmt|;
name|new
operator|->
name|longdoc
operator|=
name|copy_string_array
argument_list|(
name|builtin
operator|->
name|longdoc
argument_list|)
expr_stmt|;
name|new
operator|->
name|dependencies
operator|=
name|copy_string_array
argument_list|(
name|builtin
operator|->
name|dependencies
argument_list|)
expr_stmt|;
name|new
operator|->
name|function
operator|=
name|builtin
operator|->
name|function
condition|?
name|savestring
argument_list|(
name|builtin
operator|->
name|function
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|docname
operator|=
name|builtin
operator|->
name|docname
condition|?
name|savestring
argument_list|(
name|builtin
operator|->
name|docname
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to save away a builtin. */
end_comment

begin_macro
name|save_builtin
argument_list|(
argument|builtin
argument_list|)
end_macro

begin_decl_stmt
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BUILTIN_DESC
modifier|*
name|newbuiltin
decl_stmt|;
name|newbuiltin
operator|=
name|copy_builtin
argument_list|(
name|builtin
argument_list|)
expr_stmt|;
comment|/* If this is the first builtin to be saved, create the array      to hold it. */
if|if
condition|(
operator|!
name|saved_builtins
condition|)
name|saved_builtins
operator|=
name|array_create
argument_list|(
sizeof|sizeof
argument_list|(
name|BUILTIN_DESC
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|array_add
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newbuiltin
argument_list|,
name|saved_builtins
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Flags that mean something to write_documentation (). */
end_comment

begin_define
define|#
directive|define
name|STRING_ARRAY
value|1
end_define

begin_define
define|#
directive|define
name|TEXINFO
value|2
end_define

begin_decl_stmt
name|char
modifier|*
name|structfile_header
index|[]
init|=
block|{
literal|"/* builtins.c -- the built in shell commands. */"
block|,
literal|""
block|,
literal|"/* This file is manufactured by ./mkbuiltins, and should not be"
block|,
literal|"   edited by hand.  See the source to mkbuiltins for details. */"
block|,
literal|""
block|,
literal|"/* Copyright (C) 1987, 1991 Free Software Foundation, Inc."
block|,
literal|""
block|,
literal|"   This file is part of GNU Bash, the Bourne Again SHell."
block|,
literal|""
block|,
literal|"   Bash is free software; you can redistribute it and/or modify it"
block|,
literal|"   under the terms of the GNU General Public License as published by"
block|,
literal|"   the Free Software Foundation; either version 1, or (at your option)"
block|,
literal|"   any later version."
block|,
literal|""
block|,
literal|"   Bash is distributed in the hope that it will be useful, but WITHOUT"
block|,
literal|"   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY"
block|,
literal|"   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public"
block|,
literal|"   License for more details."
block|,
literal|""
block|,
literal|"   You should have received a copy of the GNU General Public License"
block|,
literal|"   along with Bash; see the file COPYING.  If not, write to the Free"
block|,
literal|"   Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */"
block|,
literal|""
block|,
literal|"/* The list of shell builtins.  Each element is name, function, enabled-p,"
block|,
literal|"   long-doc, short-doc.  The long-doc field contains a pointer to an array"
block|,
literal|"   of help lines.  The function takes a WORD_LIST *; the first word in the"
block|,
literal|"   list is the first arg to the command.  The list has already had word"
block|,
literal|"   expansion performed."
block|,
literal|""
block|,
literal|"   Functions which need to look at only the simple commands (e.g."
block|,
literal|"   the enable_builtin ()), should ignore entries where"
block|,
literal|"   (array[i].function == (Function *)NULL).  Such entries are for"
block|,
literal|"   the list of shell reserved control structures, like `if' and `while'."
block|,
literal|"   The end of the list is denoted with a NULL name field. */"
block|,
literal|""
block|,
literal|"#include \"../builtins.h\""
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|structfile_footer
index|[]
init|=
block|{
literal|"  { (char *)0x0, (Function *)0x0, 0, (char **)0x0, (char *)0x0 }"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"int num_shell_builtins ="
block|,
literal|"\tsizeof (shell_builtins) / sizeof (struct builtin) - 1;"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write out any neccessary opening information for    STRUCTFILE and EXTERNFILE. */
end_comment

begin_macro
name|write_file_headers
argument_list|(
argument|structfile
argument_list|,
argument|externfile
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|structfile
decl_stmt|,
modifier|*
name|externfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|structfile
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|structfile_header
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"%s\n"
argument_list|,
name|structfile_header
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|extern_filename
condition|?
name|extern_filename
else|:
literal|"builtext.h"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"\nstruct builtin shell_builtins[] = {\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|externfile
condition|)
name|fprintf
argument_list|(
name|externfile
argument_list|,
literal|"/* %s - The list of builtins found in libbuiltins.a. */\n"
argument_list|,
name|extern_filename
condition|?
name|extern_filename
else|:
literal|"builtext.h"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write out any necessary closing information for    STRUCTFILE and EXTERNFILE. */
end_comment

begin_macro
name|write_file_footers
argument_list|(
argument|structfile
argument_list|,
argument|externfile
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|structfile
decl_stmt|,
modifier|*
name|externfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Write out the footers. */
if|if
condition|(
name|structfile
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|structfile_footer
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"%s\n"
argument_list|,
name|structfile_footer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Write out the information accumulated in DEFS to    STRUCTFILE and EXTERNFILE. */
end_comment

begin_macro
name|write_builtins
argument_list|(
argument|defs
argument_list|,
argument|structfile
argument_list|,
argument|externfile
argument_list|)
end_macro

begin_decl_stmt
name|DEF_FILE
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|structfile
decl_stmt|,
modifier|*
name|externfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Write out the information. */
if|if
condition|(
name|defs
operator|->
name|builtins
condition|)
block|{
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defs
operator|->
name|builtins
operator|->
name|index
condition|;
name|i
operator|++
control|)
block|{
name|builtin
operator|=
operator|(
name|BUILTIN_DESC
operator|*
operator|)
name|defs
operator|->
name|builtins
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
comment|/* Write out any #ifdefs that may be there. */
if|if
condition|(
operator|!
name|only_documentation
condition|)
block|{
if|if
condition|(
name|builtin
operator|->
name|dependencies
condition|)
block|{
if|if
condition|(
name|builtin
operator|->
name|function
condition|)
name|write_ifdefs
argument_list|(
name|externfile
argument_list|,
name|builtin
operator|->
name|dependencies
operator|->
name|array
argument_list|)
expr_stmt|;
name|write_ifdefs
argument_list|(
name|structfile
argument_list|,
name|builtin
operator|->
name|dependencies
operator|->
name|array
argument_list|)
expr_stmt|;
block|}
comment|/* Write the extern definition. */
if|if
condition|(
name|externfile
condition|)
block|{
if|if
condition|(
name|builtin
operator|->
name|function
condition|)
name|fprintf
argument_list|(
name|externfile
argument_list|,
literal|"extern int %s ();\n"
argument_list|,
name|builtin
operator|->
name|function
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|externfile
argument_list|,
literal|"extern char *%s_doc[];\n"
argument_list|,
name|builtin
operator|->
name|docname
condition|?
name|builtin
operator|->
name|docname
else|:
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Write the structure definition. */
if|if
condition|(
name|structfile
condition|)
block|{
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"  { \"%s\", "
argument_list|,
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin
operator|->
name|function
condition|)
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"%s, "
argument_list|,
name|builtin
operator|->
name|function
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"(Function *)0x0, "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"1, %s_doc,\n"
argument_list|,
name|builtin
operator|->
name|docname
condition|?
name|builtin
operator|->
name|docname
else|:
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|structfile
argument_list|,
literal|"     \"%s\" },\n"
argument_list|,
name|builtin
operator|->
name|shortdoc
condition|?
name|builtin
operator|->
name|shortdoc
else|:
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Save away this builtin for later writing of the 		     long documentation strings. */
name|save_builtin
argument_list|(
name|builtin
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the matching #endif, if neccessary. */
if|if
condition|(
name|builtin
operator|->
name|dependencies
condition|)
block|{
if|if
condition|(
name|externfile
condition|)
name|write_endifs
argument_list|(
name|externfile
argument_list|,
name|builtin
operator|->
name|dependencies
operator|->
name|array
argument_list|)
expr_stmt|;
if|if
condition|(
name|structfile
condition|)
name|write_endifs
argument_list|(
name|structfile
argument_list|,
name|builtin
operator|->
name|dependencies
operator|->
name|array
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|documentation_file
condition|)
block|{
name|fprintf
argument_list|(
name|documentation_file
argument_list|,
literal|"@item %s\n"
argument_list|,
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
name|write_documentation
argument_list|(
name|documentation_file
argument_list|,
name|builtin
operator|->
name|longdoc
operator|->
name|array
argument_list|,
literal|0
argument_list|,
name|TEXINFO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Write out the long documentation strings in BUILTINS to STREAM. */
end_comment

begin_macro
name|write_longdocs
argument_list|(
argument|stream
argument_list|,
argument|builtins
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ARRAY
modifier|*
name|builtins
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BUILTIN_DESC
modifier|*
name|builtin
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|builtins
operator|->
name|index
condition|;
name|i
operator|++
control|)
block|{
name|builtin
operator|=
operator|(
name|BUILTIN_DESC
operator|*
operator|)
name|builtins
operator|->
name|array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|builtin
operator|->
name|dependencies
condition|)
name|write_ifdefs
argument_list|(
name|stream
argument_list|,
name|builtin
operator|->
name|dependencies
operator|->
name|array
argument_list|)
expr_stmt|;
comment|/* Write the long documentation strings. */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"char *%s_doc[] ="
argument_list|,
name|builtin
operator|->
name|docname
condition|?
name|builtin
operator|->
name|docname
else|:
name|builtin
operator|->
name|name
argument_list|)
expr_stmt|;
name|write_documentation
argument_list|(
name|stream
argument_list|,
name|builtin
operator|->
name|longdoc
operator|->
name|array
argument_list|,
literal|0
argument_list|,
name|STRING_ARRAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|builtin
operator|->
name|dependencies
condition|)
name|write_endifs
argument_list|(
name|stream
argument_list|,
name|builtin
operator|->
name|dependencies
operator|->
name|array
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Write an #ifdef string saying what needs to be defined (or not defined)    in order to allow compilation of the code that will follow.    STREAM is the stream to write the information to,    DEFINES is a null terminated array of define names.    If a define is preceded by an `!', then the sense of the test is    reversed. */
end_comment

begin_macro
name|write_ifdefs
argument_list|(
argument|stream
argument_list|,
argument|defines
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|defines
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#if "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|defines
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|def
init|=
name|defines
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|def
operator|==
literal|'!'
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"!defined (%s)"
argument_list|,
name|def
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"defined (%s)"
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|defines
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"&& "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write an #endif string saying what defines controlled the compilation    of the immediately preceding code.    STREAM is the stream to write the information to.    DEFINES is a null terminated array of define names. */
end_comment

begin_macro
name|write_endifs
argument_list|(
argument|stream
argument_list|,
argument|defines
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|defines
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#endif /* "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|defines
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|defines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|defines
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"&& "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write DOCUMENTAION to STREAM, perhaps surrounding it with double-quotes    and quoting special characters in the string. */
end_comment

begin_macro
name|write_documentation
argument_list|(
argument|stream
argument_list|,
argument|documentation
argument_list|,
argument|indentation
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|documentation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|indentation
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|string_array
init|=
operator|(
name|flags
operator|&
name|STRING_ARRAY
operator|)
decl_stmt|;
comment|/* Mutually exclusive. */
name|int
name|texinfo
init|=
operator|(
name|flags
operator|&
name|TEXINFO
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
if|if
condition|(
name|string_array
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
operator|=
name|documentation
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string_array
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  \""
argument_list|)
expr_stmt|;
if|if
condition|(
name|indentation
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|indentation
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_array
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|line
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|line
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%c"
argument_list|,
name|line
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|line
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\",\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|texinfo
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|line
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|line
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"@%c"
argument_list|,
name|line
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|line
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|string_array
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  (char *)NULL\n};\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

