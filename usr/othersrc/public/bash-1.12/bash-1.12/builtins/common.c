begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1987, 1989, 1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it under    the terms of the GNU General Public License as published by the Free    Software Foundation; either version 1, or (at your option) any later    version.     Bash is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    for more details.        You should have received a copy of the GNU General Public License along    with Bash; see the file COPYING.  If not, write to the Free Software    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VPRINTF */
end_comment

begin_include
include|#
directive|include
file|"../shell.h"
end_include

begin_include
include|#
directive|include
file|"../unwind_prot.h"
end_include

begin_include
include|#
directive|include
file|"../maxpath.h"
end_include

begin_include
include|#
directive|include
file|"../jobs.h"
end_include

begin_include
include|#
directive|include
file|"../builtins.h"
end_include

begin_include
include|#
directive|include
file|"../input.h"
end_include

begin_include
include|#
directive|include
file|"hashcom.h"
end_include

begin_decl_stmt
name|void
name|no_args
argument_list|()
decl_stmt|,
name|remember_args
argument_list|()
decl_stmt|,
name|parse_and_execute_cleanup
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|follow_symbolic_links
decl_stmt|,
name|interactive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read a numeric arg for this_command_name, the name of the shell builtin    that wants it.  LIST is the word list that the arg is to come from. */
end_comment

begin_function
name|int
name|get_numeric_arg
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|list
operator|->
name|word
operator|->
name|word
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|builtin_error
argument_list|(
literal|"bad non-numeric arg `%s'"
argument_list|,
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|throw_to_top_level
argument_list|()
expr_stmt|;
block|}
name|no_args
argument_list|(
name|list
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is a lot like report_error (), but it is for shell builtins    instead of shell control structures, and it won't ever exit the    shell. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
end_if

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|builtin_error
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|this_command_name
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
if|if
condition|(
name|this_command_name
operator|&&
operator|*
name|this_command_name
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|this_command_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Without VARARGS. */
end_comment

begin_macro
name|builtin_error
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|,
modifier|*
name|arg5
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|this_command_name
decl_stmt|;
if|if
condition|(
name|this_command_name
operator|&&
operator|*
name|this_command_name
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|this_command_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VPRINTF */
end_comment

begin_comment
comment|/* Remember LIST in $0 ... $9, and REST_OF_ARGS.  If DESTRUCTIVE is    non-zero, then discard whatever the existing arguments are, else    only discard the ones that are to be replaced. */
end_comment

begin_function
name|void
name|remember_args
parameter_list|(
name|list
parameter_list|,
name|destructive
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
name|int
name|destructive
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|WORD_LIST
modifier|*
name|copy_word_list
parameter_list|()
function_decl|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|destructive
operator|&&
name|dollar_vars
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|dollar_vars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dollar_vars
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
operator|!
name|destructive
operator|&&
name|dollar_vars
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|dollar_vars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dollar_vars
index|[
name|i
index|]
operator|=
name|savestring
argument_list|(
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* If arguments remain, assign them to REST_OF_ARGS. */
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|dispose_words
argument_list|(
name|rest_of_args
argument_list|)
expr_stmt|;
name|rest_of_args
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|rest_of_args
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|copy_word_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return if LIST is NULL else barf and jump to top_level. */
end_comment

begin_function
name|void
name|no_args
parameter_list|(
name|list
parameter_list|)
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|list
condition|)
block|{
name|builtin_error
argument_list|(
literal|"extra arguments"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the octal number parsed from STRING, or -1 to indicate    that the string contained a bad number. */
end_comment

begin_function
name|int
name|read_octal
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|digits
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|string
operator|&&
operator|*
name|string
operator|>=
literal|'0'
operator|&&
operator|*
name|string
operator|<
literal|'8'
condition|)
block|{
name|digits
operator|++
expr_stmt|;
name|result
operator|=
operator|(
name|result
operator|*
literal|8
operator|)
operator|+
operator|*
name|string
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|digits
operator|||
name|result
operator|>
literal|0777
operator|||
operator|*
name|string
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Temporary static. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dotted_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the full pathname that FILENAME hashes to.  If FILENAME    is hashed, but data->check_dot is non-zero, check ./FILENAME    and return that if it is executable. */
end_comment

begin_function
name|char
modifier|*
name|find_hashed_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|extern
name|HASH_TABLE
modifier|*
name|hashed_filenames
decl_stmt|;
specifier|extern
name|int
name|hashing_disabled
decl_stmt|;
specifier|register
name|BUCKET_CONTENTS
modifier|*
name|item
decl_stmt|;
if|if
condition|(
name|hashing_disabled
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|item
operator|=
name|find_hash_item
argument_list|(
name|filename
argument_list|,
name|hashed_filenames
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
comment|/* If this filename is hashed, but `.' comes before it in the path, 	 then see if `./filename' is an executable. */
if|if
condition|(
name|pathdata
argument_list|(
name|item
argument_list|)
operator|->
name|check_dot
condition|)
block|{
if|if
condition|(
name|dotted_filename
condition|)
name|free
argument_list|(
name|dotted_filename
argument_list|)
expr_stmt|;
name|dotted_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dotted_filename
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dotted_filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable_file
argument_list|(
name|dotted_filename
argument_list|)
condition|)
return|return
operator|(
name|dotted_filename
operator|)
return|;
comment|/* Watch out.  If this file was hashed to "./filename", and 	     "./filename" is not executable, then return NULL. */
comment|/* Since we already know "./filename" is not executable, what 	     we're really interested in is whether or not the `path' 	     portion of the hashed filename is equivalent to the current 	     directory, but only if it starts with a `.'.  (This catches 	     ./. and so on.)  same_file () is in execute_cmd.c; it tests 	     general Unix file equivalence -- same device and inode. */
block|{
name|char
modifier|*
name|path
init|=
name|pathdata
argument_list|(
name|item
argument_list|)
operator|->
name|path
decl_stmt|;
if|if
condition|(
operator|*
name|path
operator|==
literal|'.'
condition|)
block|{
name|int
name|same
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|tail
operator|=
name|rindex
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
condition|)
block|{
operator|*
name|tail
operator|=
literal|'\0'
expr_stmt|;
name|same
operator|=
name|same_file
argument_list|(
literal|"."
argument_list|,
name|path
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|tail
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|same
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|pathdata
argument_list|(
name|item
argument_list|)
operator|->
name|path
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		    Pushing and Popping a Context		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
name|WORD_LIST
modifier|*
modifier|*
name|dollar_arg_stack
init|=
operator|(
name|WORD_LIST
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dollar_arg_stack_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dollar_arg_stack_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|push_dollar_vars
argument_list|()
decl_stmt|,
name|pop_dollar_vars
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_context
parameter_list|()
block|{
specifier|extern
name|int
name|variable_context
decl_stmt|;
name|push_dollar_vars
argument_list|()
expr_stmt|;
name|variable_context
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_context
parameter_list|()
block|{
specifier|extern
name|int
name|variable_context
decl_stmt|;
name|pop_dollar_vars
argument_list|()
expr_stmt|;
name|kill_all_local_variables
argument_list|()
expr_stmt|;
name|variable_context
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the existing positional parameters on a stack. */
end_comment

begin_function
name|void
name|push_dollar_vars
parameter_list|()
block|{
specifier|extern
name|WORD_LIST
modifier|*
name|list_rest_of_args
parameter_list|()
function_decl|;
if|if
condition|(
name|dollar_arg_stack_index
operator|+
literal|2
operator|>
name|dollar_arg_stack_slots
condition|)
block|{
if|if
condition|(
operator|!
name|dollar_arg_stack
condition|)
block|{
name|dollar_arg_stack
operator|=
operator|(
name|WORD_LIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|dollar_arg_stack
argument_list|,
operator|(
name|dollar_arg_stack_slots
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|WORD_LIST
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dollar_arg_stack
index|[
name|dollar_arg_stack_index
index|]
operator|=
name|list_rest_of_args
argument_list|()
expr_stmt|;
name|dollar_arg_stack
index|[
operator|++
name|dollar_arg_stack_index
index|]
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the positional parameters from our stack. */
end_comment

begin_function
name|void
name|pop_dollar_vars
parameter_list|()
block|{
if|if
condition|(
operator|!
name|dollar_arg_stack
operator|||
operator|!
name|dollar_arg_stack_index
condition|)
return|return;
name|remember_args
argument_list|(
name|dollar_arg_stack
index|[
operator|--
name|dollar_arg_stack_index
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dispose_words
argument_list|(
name|dollar_arg_stack
index|[
name|dollar_arg_stack_index
index|]
argument_list|)
expr_stmt|;
name|dollar_arg_stack
index|[
name|dollar_arg_stack_index
index|]
operator|=
operator|(
name|WORD_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function called when one of the builtin commands detects a bad    option. */
end_comment

begin_macro
name|bad_option
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|builtin_error
argument_list|(
literal|"unknown option: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a consed string which is the current working directory.    FOR_WHOM is the name of the caller for error printing.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|the_current_working_directory
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|get_working_directory
parameter_list|(
name|for_whom
parameter_list|)
name|char
modifier|*
name|for_whom
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|follow_symbolic_links
condition|)
block|{
if|if
condition|(
name|the_current_working_directory
condition|)
name|free
argument_list|(
name|the_current_working_directory
argument_list|)
expr_stmt|;
name|the_current_working_directory
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|the_current_working_directory
condition|)
block|{
name|char
modifier|*
name|directory
decl_stmt|,
modifier|*
name|getwd
argument_list|()
decl_stmt|;
name|the_current_working_directory
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|directory
operator|=
name|getwd
argument_list|(
name|the_current_working_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|directory
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n\r"
argument_list|,
name|for_whom
argument_list|,
name|the_current_working_directory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_current_working_directory
argument_list|)
expr_stmt|;
name|the_current_working_directory
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
block|}
return|return
operator|(
name|savestring
argument_list|(
name|the_current_working_directory
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
end_if

begin_comment
comment|/* Return the job spec found in LIST. */
end_comment

begin_macro
name|get_job_spec
argument_list|(
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|word
decl_stmt|;
name|int
name|job
init|=
name|NO_JOB
decl_stmt|;
name|int
name|substring
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
operator|(
name|current_job
operator|)
return|;
name|word
operator|=
name|list
operator|->
name|word
operator|->
name|word
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|word
condition|)
return|return
operator|(
name|current_job
operator|)
return|;
if|if
condition|(
operator|*
name|word
operator|==
literal|'%'
condition|)
name|word
operator|++
expr_stmt|;
if|if
condition|(
name|digit
argument_list|(
operator|*
name|word
argument_list|)
operator|&&
operator|(
name|sscanf
argument_list|(
name|word
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|job
argument_list|)
operator|==
literal|1
operator|)
condition|)
return|return
operator|(
name|job
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
operator|*
name|word
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|'%'
case|:
case|case
literal|'+'
case|:
return|return
operator|(
name|current_job
operator|)
return|;
case|case
literal|'-'
case|:
return|return
operator|(
name|previous_job
operator|)
return|;
case|case
literal|'?'
case|:
comment|/* Substring search requested. */
name|substring
operator|++
expr_stmt|;
name|word
operator|++
expr_stmt|;
goto|goto
name|find_string
goto|;
default|default:
name|find_string
label|:
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|wl
init|=
name|strlen
argument_list|(
name|word
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|job_slots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|jobs
index|[
name|i
index|]
condition|)
block|{
specifier|register
name|PROCESS
modifier|*
name|p
init|=
name|jobs
index|[
name|i
index|]
operator|->
name|pipe
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strindex
parameter_list|()
function_decl|;
do|do
block|{
if|if
condition|(
operator|(
name|substring
operator|&&
name|strindex
argument_list|(
name|p
operator|->
name|command
argument_list|,
name|word
argument_list|)
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|p
operator|->
name|command
argument_list|,
name|word
argument_list|,
name|wl
argument_list|)
operator|==
literal|0
operator|)
condition|)
if|if
condition|(
name|job
operator|!=
name|NO_JOB
condition|)
block|{
name|builtin_error
argument_list|(
literal|"ambigious job spec: %s"
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|DUP_JOB
operator|)
return|;
block|}
else|else
name|job
operator|=
name|i
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|jobs
index|[
name|i
index|]
operator|->
name|pipe
condition|)
do|;
block|}
block|}
return|return
operator|(
name|job
operator|)
return|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JOB_CONTROL */
end_comment

begin_comment
comment|/* The command name of the currently running function. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|this_command_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parse_and_execute_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to force parse_and_execute () to clean up after itself. */
end_comment

begin_function
name|void
name|parse_and_execute_cleanup
parameter_list|()
block|{
name|run_unwind_frame
argument_list|(
literal|"parse_and_execute_top"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse and execute the commands in STRING.  Returns whatever    execute_command () returns.  This frees STRING. */
end_comment

begin_function
name|int
name|parse_and_execute
parameter_list|(
name|string
parameter_list|,
name|from_file
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|from_file
decl_stmt|;
block|{
specifier|extern
name|int
name|remember_on_history
decl_stmt|;
specifier|extern
name|int
name|history_expansion_inhibited
decl_stmt|;
specifier|extern
name|int
name|indirection_level
decl_stmt|;
specifier|extern
name|int
name|builtin_pipe_in
decl_stmt|,
name|builtin_pipe_out
decl_stmt|;
specifier|extern
name|COMMAND
modifier|*
name|global_command
decl_stmt|;
specifier|extern
name|char
modifier|*
name|indirection_level_string
parameter_list|()
function_decl|;
specifier|extern
name|int
name|pop_stream
argument_list|()
decl_stmt|,
name|free
argument_list|()
decl_stmt|;
name|int
name|last_result
init|=
name|EXECUTION_SUCCESS
decl_stmt|;
name|int
name|code
decl_stmt|,
name|jump_to_top_level
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|orig_string
init|=
name|string
decl_stmt|;
comment|/* Unwind protect this invocation of parse_and_execute (). */
name|begin_unwind_frame
argument_list|(
literal|"parse_and_execute_top"
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|parse_and_execute_level
argument_list|)
expr_stmt|;
name|unwind_protect_jmp_buf
argument_list|(
name|top_level
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|indirection_level
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|interactive
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|remember_on_history
argument_list|)
expr_stmt|;
name|unwind_protect_int
argument_list|(
name|history_expansion_inhibited
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|pop_stream
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_string
condition|)
name|add_unwind_protect
argument_list|(
name|free
argument_list|,
name|orig_string
argument_list|)
expr_stmt|;
name|end_unwind_frame
argument_list|()
expr_stmt|;
name|parse_and_execute_level
operator|++
expr_stmt|;
name|push_stream
argument_list|()
expr_stmt|;
name|interactive
operator|=
literal|0
expr_stmt|;
name|indirection_level
operator|++
expr_stmt|;
comment|/* We don't remember text read by the shell this way on      the history list, and we don't use !$ in shell scripts. */
name|remember_on_history
operator|=
literal|0
expr_stmt|;
name|history_expansion_inhibited
operator|=
literal|1
expr_stmt|;
name|with_input_from_string
argument_list|(
name|string
argument_list|,
name|from_file
argument_list|)
expr_stmt|;
block|{
name|COMMAND
modifier|*
name|command
decl_stmt|;
while|while
condition|(
operator|*
operator|(
name|bash_input
operator|.
name|location
operator|.
name|string
operator|)
condition|)
block|{
if|if
condition|(
name|interrupt_state
condition|)
block|{
name|last_result
operator|=
name|EXECUTION_FAILURE
expr_stmt|;
break|break;
block|}
comment|/* Provide a location for functions which `longjmp (top_level)' to 	   jump to.  This prevents errors in substitution from restarting 	   the reader loop directly, for example. */
name|code
operator|=
name|setjmp
argument_list|(
name|top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|FORCE_EOF
case|:
case|case
name|EXITPROG
case|:
name|run_unwind_frame
argument_list|(
literal|"pe_dispose"
argument_list|)
expr_stmt|;
comment|/* Remember to call longjmp (top_level) after the old 		   value for it is restored. */
name|jump_to_top_level
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|DISCARD
case|:
name|run_unwind_frame
argument_list|(
literal|"pe_dispose"
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|programming_error
argument_list|(
literal|"bad jump to top_level: %d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|parse_command
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|command
operator|=
name|global_command
operator|)
operator|!=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|extern
name|struct
name|fd_bitmap
modifier|*
name|new_fd_bitmap
parameter_list|()
function_decl|;
specifier|extern
name|void
name|dispose_fd_bitmap
parameter_list|()
function_decl|;
name|struct
name|fd_bitmap
modifier|*
name|bitmap
decl_stmt|;
name|bitmap
operator|=
name|new_fd_bitmap
argument_list|(
name|FD_BITMAP_SIZE
argument_list|)
expr_stmt|;
name|begin_unwind_frame
argument_list|(
literal|"pe_dispose"
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|dispose_fd_bitmap
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
name|global_command
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|builtin_pipe_in
operator|!=
name|NO_PIPE
condition|)
name|bitmap
operator|->
name|bitmap
index|[
name|builtin_pipe_in
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|builtin_pipe_out
operator|!=
name|NO_PIPE
condition|)
name|bitmap
operator|->
name|bitmap
index|[
name|builtin_pipe_out
index|]
operator|=
literal|1
expr_stmt|;
name|last_result
operator|=
name|execute_command_internal
argument_list|(
name|command
argument_list|,
literal|0
argument_list|,
name|NO_PIPE
argument_list|,
name|NO_PIPE
argument_list|,
name|bitmap
argument_list|)
expr_stmt|;
name|dispose_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|run_unwind_frame
argument_list|(
literal|"pe_dispose"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|last_result
operator|=
name|EXECUTION_FAILURE
expr_stmt|;
comment|/* Since we are shell compatible, syntax errors in a script 	       abort the execution of the script.  Right? */
break|break;
block|}
block|}
block|}
name|out
label|:
name|run_unwind_frame
argument_list|(
literal|"parse_and_execute_top"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt_state
operator|&&
name|parse_and_execute_level
operator|==
literal|0
condition|)
name|throw_to_top_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|jump_to_top_level
condition|)
name|longjmp
argument_list|(
name|top_level
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the builtin named NAME.    DISABLED_OKAY means find it even if the builtin is disabled. */
end_comment

begin_function
name|Function
modifier|*
name|builtin_address_internal
parameter_list|(
name|name
parameter_list|,
name|disabled_okay
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|disabled_okay
decl_stmt|;
block|{
name|int
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|mid
decl_stmt|,
name|j
decl_stmt|;
name|hi
operator|=
name|num_shell_builtins
operator|-
literal|1
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lo
operator|<=
name|hi
condition|)
block|{
name|mid
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
name|j
operator|=
name|strcmp
argument_list|(
name|shell_builtins
index|[
name|mid
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shell_builtins
index|[
name|mid
index|]
operator|.
name|function
operator|&&
operator|(
name|shell_builtins
index|[
name|mid
index|]
operator|.
name|enabled
operator|||
name|disabled_okay
operator|)
condition|)
return|return
operator|(
name|shell_builtins
index|[
name|mid
index|]
operator|.
name|function
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|Function
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|hi
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|Function
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Perform a binary search and return the address of the builtin function    whose name is NAME.  If the function couldn't be found, or the builtin    is disabled or has no function associated with it, return NULL. */
end_comment

begin_function
name|Function
modifier|*
name|find_shell_builtin
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|builtin_address_internal
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the address of builtin with NAME, irregardless of its state of    enableness. */
end_comment

begin_function
name|Function
modifier|*
name|builtin_address
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|builtin_address_internal
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|shell_builtin_compare
parameter_list|(
name|sbp1
parameter_list|,
name|sbp2
parameter_list|)
name|struct
name|builtin
modifier|*
name|sbp1
decl_stmt|,
decl|*
name|sbp2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|sbp1
operator|->
name|name
argument_list|,
name|sbp2
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Sort the table of shell builtins so that the binary search will work    in find_shell_builtin. */
end_comment

begin_macro
name|initialize_shell_builtins
argument_list|()
end_macro

begin_block
block|{
name|qsort
argument_list|(
name|shell_builtins
argument_list|,
name|num_shell_builtins
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|builtin
argument_list|)
argument_list|,
name|shell_builtin_compare
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

