begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* print_command -- A way to make readable commands from a command tree. */
end_comment

begin_comment
comment|/* Copyright (C) 1989 Free Software Foundation, Inc.  This file is part of GNU Bash, the Bourne Again SHell.  Bash is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  Bash is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with Bash; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|indentation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indentation_amount
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PRINTED_COMMAND_GROW_SIZE
value|1024
end_define

begin_decl_stmt
name|char
modifier|*
name|the_printed_command
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|the_printed_command_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|command_string_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means the stuff being printed is inside of a function def. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inside_function_def
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skip_this_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print COMMAND (a command tree) on standard output. */
end_comment

begin_macro
name|print_command
argument_list|(
argument|command
argument_list|)
end_macro

begin_decl_stmt
name|COMMAND
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|make_command_string
parameter_list|()
function_decl|;
name|command_string_index
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|make_command_string
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make a string which is the printed representation of the command    tree in COMMAND.  We return this string.  However, the string is    not consed, so you have to do that yourself if you want it to    remain around. */
end_comment

begin_function
name|char
modifier|*
name|make_command_string
parameter_list|(
name|command
parameter_list|)
name|COMMAND
modifier|*
name|command
decl_stmt|;
block|{
name|command_string_index
operator|=
literal|0
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
name|the_printed_command
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The internal function.  This is the real workhorse. */
end_comment

begin_macro
name|make_command_string_internal
argument_list|(
argument|command
argument_list|)
end_macro

begin_decl_stmt
name|COMMAND
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|command
condition|)
block|{
name|cprintf
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|skip_this_indent
condition|)
name|skip_this_indent
operator|--
expr_stmt|;
else|else
name|indent
argument_list|(
name|indentation
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|flags
operator|&
name|CMD_WANT_SUBSHELL
condition|)
name|cprintf
argument_list|(
literal|"( "
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|flags
operator|&
name|CMD_INVERT_RETURN
condition|)
name|cprintf
argument_list|(
literal|" ! "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
operator|->
name|type
condition|)
block|{
case|case
name|cm_for
case|:
name|print_for_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|For
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_case
case|:
name|print_case_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Case
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_while
case|:
name|print_while_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|While
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_until
case|:
name|print_until_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|While
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_if
case|:
name|print_if_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|If
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_simple
case|:
name|print_simple_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Simple
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_connection
case|:
name|skip_this_indent
operator|++
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|first
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|connector
condition|)
block|{
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
block|{
name|char
name|c
init|=
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|connector
decl_stmt|;
name|cprintf
argument_list|(
literal|" %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'&'
operator|||
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
block|{
name|cprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|skip_this_indent
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AND_AND
case|:
name|cprintf
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
name|skip_this_indent
operator|++
expr_stmt|;
break|break;
case|case
name|OR_OR
case|:
name|cprintf
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
name|skip_this_indent
operator|++
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|cprintf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside_function_def
condition|)
name|cprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|cprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
condition|)
name|skip_this_indent
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|cprintf
argument_list|(
literal|"OOPS!  Bad connector `%d'!"
argument_list|,
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|connector
argument_list|)
expr_stmt|;
break|break;
block|}
name|make_command_string_internal
argument_list|(
name|command
operator|->
name|value
operator|.
name|Connection
operator|->
name|second
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_function_def
case|:
name|print_function_def
argument_list|(
name|command
operator|->
name|value
operator|.
name|Function_def
argument_list|)
expr_stmt|;
break|break;
case|case
name|cm_group
case|:
name|print_group_command
argument_list|(
name|command
operator|->
name|value
operator|.
name|Group
argument_list|)
expr_stmt|;
break|break;
default|default:
name|programming_error
argument_list|(
literal|"OOPS!  Bad command type `%d'!"
argument_list|,
name|command
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|command
operator|->
name|flags
operator|&
name|CMD_WANT_SUBSHELL
condition|)
name|cprintf
argument_list|(
literal|" )"
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|->
name|redirects
condition|)
name|print_redirection_list
argument_list|(
name|command
operator|->
name|redirects
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|print_word_list
argument_list|(
argument|list
argument_list|,
argument|separator
argument_list|)
end_macro

begin_decl_stmt
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|separator
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|list
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|command_print_word_list
argument_list|(
argument|list
argument_list|,
argument|separator
argument_list|)
end_macro

begin_decl_stmt
name|WORD_LIST
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|separator
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|list
condition|)
block|{
name|cprintf
argument_list|(
literal|"%s"
argument_list|,
name|list
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|cprintf
argument_list|(
literal|"%s"
argument_list|,
name|separator
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|print_for_command
argument_list|(
argument|for_command
argument_list|)
end_macro

begin_decl_stmt
name|FOR_COM
modifier|*
name|for_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cprintf
argument_list|(
literal|"for %s in "
argument_list|,
name|for_command
operator|->
name|name
operator|->
name|word
argument_list|)
expr_stmt|;
name|command_print_word_list
argument_list|(
name|for_command
operator|->
name|map_list
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|newline
argument_list|(
literal|"do\n"
argument_list|)
expr_stmt|;
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|for_command
operator|->
name|action
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|indentation
operator|-=
name|indentation_amount
expr_stmt|;
name|newline
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_group_command
argument_list|(
argument|group_command
argument_list|)
end_macro

begin_decl_stmt
name|GROUP_COM
modifier|*
name|group_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cprintf
argument_list|(
literal|"{ "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inside_function_def
condition|)
name|skip_this_indent
operator|++
expr_stmt|;
else|else
name|cprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|group_command
operator|->
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside_function_def
condition|)
if|#
directive|if
literal|0
then|cprintf ("; \n}");
else|#
directive|else
name|cprintf
argument_list|(
literal|"\n}"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|cprintf
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_case_command
argument_list|(
argument|case_command
argument_list|)
end_macro

begin_decl_stmt
name|CASE_COM
modifier|*
name|case_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cprintf
argument_list|(
literal|"case %s in "
argument_list|,
name|case_command
operator|->
name|word
operator|->
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_command
operator|->
name|clauses
condition|)
name|print_case_clauses
argument_list|(
name|case_command
operator|->
name|clauses
argument_list|)
expr_stmt|;
name|newline
argument_list|(
literal|"esac"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_case_clauses
argument_list|(
argument|clauses
argument_list|)
end_macro

begin_decl_stmt
name|PATTERN_LIST
modifier|*
name|clauses
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
while|while
condition|(
name|clauses
condition|)
block|{
name|newline
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|command_print_word_list
argument_list|(
name|clauses
operator|->
name|patterns
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|clauses
operator|->
name|action
argument_list|)
expr_stmt|;
name|indentation
operator|-=
name|indentation_amount
expr_stmt|;
name|newline
argument_list|(
literal|";;"
argument_list|)
expr_stmt|;
name|clauses
operator|=
name|clauses
operator|->
name|next
expr_stmt|;
block|}
name|indentation
operator|-=
name|indentation_amount
expr_stmt|;
block|}
end_block

begin_macro
name|print_while_command
argument_list|(
argument|while_command
argument_list|)
end_macro

begin_decl_stmt
name|WHILE_COM
modifier|*
name|while_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|print_until_or_while
argument_list|(
name|while_command
argument_list|,
literal|"while"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_until_command
argument_list|(
argument|while_command
argument_list|)
end_macro

begin_decl_stmt
name|WHILE_COM
modifier|*
name|while_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|print_until_or_while
argument_list|(
name|while_command
argument_list|,
literal|"until"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_until_or_while
argument_list|(
argument|while_command
argument_list|,
argument|which
argument_list|)
end_macro

begin_decl_stmt
name|WHILE_COM
modifier|*
name|while_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cprintf
argument_list|(
literal|"%s "
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|skip_this_indent
operator|++
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|while_command
operator|->
name|test
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|newline
argument_list|(
literal|"do\n"
argument_list|)
expr_stmt|;
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|while_command
operator|->
name|action
argument_list|)
expr_stmt|;
name|indentation
operator|-=
name|indentation_amount
expr_stmt|;
name|cprintf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|newline
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_if_command
argument_list|(
argument|if_command
argument_list|)
end_macro

begin_decl_stmt
name|IF_COM
modifier|*
name|if_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cprintf
argument_list|(
literal|"if "
argument_list|)
expr_stmt|;
name|skip_this_indent
operator|++
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|if_command
operator|->
name|test
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|" ; then\n"
argument_list|)
expr_stmt|;
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|if_command
operator|->
name|true_case
argument_list|)
expr_stmt|;
name|indentation
operator|-=
name|indentation_amount
expr_stmt|;
if|if
condition|(
name|if_command
operator|->
name|false_case
condition|)
block|{
name|cprintf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|newline
argument_list|(
literal|"else\n"
argument_list|)
expr_stmt|;
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|if_command
operator|->
name|false_case
argument_list|)
expr_stmt|;
name|indentation
operator|-=
name|indentation_amount
expr_stmt|;
block|}
name|cprintf
argument_list|(
literal|" ;"
argument_list|)
expr_stmt|;
name|newline
argument_list|(
literal|"fi"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_simple_command
argument_list|(
argument|simple_command
argument_list|)
end_macro

begin_decl_stmt
name|SIMPLE_COM
modifier|*
name|simple_command
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|command_print_word_list
argument_list|(
name|simple_command
operator|->
name|words
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|simple_command
operator|->
name|redirects
condition|)
block|{
name|cprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_redirection_list
argument_list|(
name|simple_command
operator|->
name|redirects
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|print_redirection_list
argument_list|(
argument|redirects
argument_list|)
end_macro

begin_decl_stmt
name|REDIRECT
modifier|*
name|redirects
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|redirects
condition|)
block|{
name|print_redirection
argument_list|(
name|redirects
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|redirects
operator|=
name|redirects
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|print_redirection
argument_list|(
argument|redirect
argument_list|)
end_macro

begin_decl_stmt
name|REDIRECT
modifier|*
name|redirect
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|kill_leading
init|=
literal|0
decl_stmt|;
name|int
name|redirector
init|=
name|redirect
operator|->
name|redirector
decl_stmt|;
name|WORD_DESC
modifier|*
name|redirectee
init|=
name|redirect
operator|->
name|redirectee
operator|.
name|filename
decl_stmt|;
switch|switch
condition|(
name|redirect
operator|->
name|instruction
condition|)
block|{
case|case
name|r_output_direction
case|:
if|if
condition|(
name|redirector
operator|!=
literal|1
condition|)
name|cprintf
argument_list|(
literal|"%d"
argument_list|,
name|redirector
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|">%s"
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_input_direction
case|:
if|if
condition|(
name|redirector
operator|!=
literal|0
condition|)
name|cprintf
argument_list|(
literal|"%d"
argument_list|,
name|redirector
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|"<%s"
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_inputa_direction
case|:
comment|/* Redirection created by the sh. */
name|cprintf
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_appending_to
case|:
if|if
condition|(
name|redirector
operator|!=
literal|1
condition|)
name|cprintf
argument_list|(
literal|"%d"
argument_list|,
name|redirector
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|">>%s"
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_deblank_reading_until
case|:
name|kill_leading
operator|++
expr_stmt|;
comment|/* ... */
case|case
name|r_reading_until
case|:
if|if
condition|(
name|redirector
operator|!=
literal|0
condition|)
name|cprintf
argument_list|(
literal|"%d"
argument_list|,
name|redirector
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|"<<%s%s"
argument_list|,
name|kill_leading
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|redirect
operator|->
name|here_doc_eof
argument_list|)
expr_stmt|;
comment|/* This is only important if we are printing a function definition 	 for export.  If not, we could overrun the buffer that `cprintf' 	 writes into, quite unexpectedly -- when unpacking shar files, for 	 instance. */
if|if
condition|(
name|inside_function_def
condition|)
block|{
name|cprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|redirect
operator|->
name|redirectee
operator|.
name|filename
operator|->
name|word
argument_list|,
name|redirect
operator|->
name|here_doc_eof
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|r_duplicating_input
case|:
name|cprintf
argument_list|(
literal|"%d<&%d"
argument_list|,
name|redirector
argument_list|,
operator|(
name|int
operator|)
name|redirectee
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_duplicating_output
case|:
name|cprintf
argument_list|(
literal|"%d>&%d"
argument_list|,
name|redirector
argument_list|,
operator|(
name|int
operator|)
name|redirectee
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_duplicating_input_word
case|:
name|cprintf
argument_list|(
literal|"%d<&%s"
argument_list|,
name|redirector
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_duplicating_output_word
case|:
name|cprintf
argument_list|(
literal|"%d>&%s"
argument_list|,
name|redirector
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_close_this
case|:
name|cprintf
argument_list|(
literal|"%d>&-"
argument_list|,
name|redirector
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_err_and_out
case|:
name|cprintf
argument_list|(
literal|">&%s"
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_input_output
case|:
if|if
condition|(
name|redirector
operator|!=
literal|1
condition|)
name|cprintf
argument_list|(
literal|"%d"
argument_list|,
name|redirector
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|"<>%s"
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
case|case
name|r_output_force
case|:
if|if
condition|(
name|redirector
operator|!=
literal|1
condition|)
name|cprintf
argument_list|(
literal|"%d"
argument_list|,
name|redirector
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|">|%s"
argument_list|,
name|redirectee
operator|->
name|word
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|reset_locals
parameter_list|()
block|{
name|inside_function_def
operator|=
literal|0
expr_stmt|;
name|indentation
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|print_function_def
argument_list|(
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|FUNCTION_DEF
modifier|*
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cprintf
argument_list|(
literal|"function %s () \n"
argument_list|,
name|func
operator|->
name|name
operator|->
name|word
argument_list|)
expr_stmt|;
name|add_unwind_protect
argument_list|(
name|reset_locals
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inside_function_def
operator|++
expr_stmt|;
name|skip_this_indent
operator|++
expr_stmt|;
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|func
operator|->
name|command
argument_list|)
expr_stmt|;
name|remove_unwind_protect
argument_list|()
expr_stmt|;
name|indentation
operator|-=
name|indentation_amount
expr_stmt|;
name|inside_function_def
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the string representation of the named function.    NAME is the name of the function.    COMMAND is the function body.  It should be a GROUP_COM.    MULTI_LINE is non-zero to pretty-print, or zero for all on one line.   */
end_comment

begin_function
name|char
modifier|*
name|named_function_string
parameter_list|(
name|name
parameter_list|,
name|command
parameter_list|,
name|multi_line
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|COMMAND
modifier|*
name|command
decl_stmt|;
name|int
name|multi_line
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|old_indent
init|=
name|indentation
decl_stmt|,
name|old_amount
init|=
name|indentation_amount
decl_stmt|;
name|command_string_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
name|cprintf
argument_list|(
literal|"%s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|"() "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|multi_line
condition|)
block|{
name|indentation
operator|=
literal|1
expr_stmt|;
name|indentation_amount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|indentation
operator|+=
name|indentation_amount
expr_stmt|;
block|}
name|inside_function_def
operator|++
expr_stmt|;
name|skip_this_indent
operator|++
expr_stmt|;
name|make_command_string_internal
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|indentation
operator|=
name|old_indent
expr_stmt|;
name|indentation_amount
operator|=
name|old_amount
expr_stmt|;
name|inside_function_def
operator|--
expr_stmt|;
name|result
operator|=
name|the_printed_command
expr_stmt|;
if|if
condition|(
operator|!
name|multi_line
condition|)
block|{
if|#
directive|if
literal|0
block|register int i;       for (i = 0; result[i]; i++) 	if (result[i] == '\n') 	  { 	    strcpy (&result[i],&result[i + 1]); 	    --i; 	  }
else|#
directive|else
if|if
condition|(
name|result
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
comment|/* XXX -- experimental */
name|strcpy
argument_list|(
operator|&
name|result
index|[
literal|2
index|]
argument_list|,
operator|&
name|result
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_macro
name|newline
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|indentation
argument_list|)
expr_stmt|;
name|cprintf
argument_list|(
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|indent
argument_list|(
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|amount
operator|--
operator|>
literal|0
condition|)
name|cprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
end_if

begin_comment
comment|/* How to make the string. */
end_comment

begin_macro
name|cprintf
argument_list|(
argument|control
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|control
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp_buffer
index|[
literal|5000
index|]
decl_stmt|;
name|int
name|l
decl_stmt|;
name|sprintf
argument_list|(
name|temp_buffer
argument_list|,
name|control
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|temp_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_printed_command
condition|)
name|the_printed_command
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|the_printed_command_size
operator|=
name|PRINTED_COMMAND_GROW_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|the_printed_command_size
operator|<=
name|command_string_index
operator|+
name|l
condition|)
name|the_printed_command
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_printed_command
argument_list|,
name|the_printed_command_size
operator|+=
name|PRINTED_COMMAND_GROW_SIZE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_printed_command
operator|+
name|command_string_index
argument_list|,
name|temp_buffer
argument_list|)
expr_stmt|;
name|command_string_index
operator|+=
name|l
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We have support for varargs. */
end_comment

begin_comment
comment|/* How to make the string. */
end_comment

begin_macro
name|cprintf
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|temp_buffer
index|[
literal|5000
index|]
decl_stmt|;
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|control
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|control
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|temp_buffer
argument_list|,
name|control
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|temp_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_printed_command
condition|)
name|the_printed_command
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|the_printed_command_size
operator|=
name|PRINTED_COMMAND_GROW_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|the_printed_command_size
operator|<=
name|command_string_index
operator|+
name|l
condition|)
name|the_printed_command
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_printed_command
argument_list|,
name|the_printed_command_size
operator|+=
name|PRINTED_COMMAND_GROW_SIZE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_printed_command
operator|+
name|command_string_index
argument_list|,
name|temp_buffer
argument_list|)
expr_stmt|;
name|command_string_index
operator|+=
name|l
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VFPRINTF */
end_comment

end_unit

