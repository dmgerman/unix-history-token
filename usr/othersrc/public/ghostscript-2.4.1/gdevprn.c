begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevprn.c */
end_comment

begin_comment
comment|/* Generic printer support for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_include
include|#
directive|include
file|"gsprops.h"
end_include

begin_comment
comment|/* Define the scratch file name prefix for mktemp */
end_comment

begin_define
define|#
directive|define
name|SCRATCH_TEMPLATE
value|gp_scratch_file_name_prefix
end_define

begin_comment
comment|/* Internal routine for opening a scratch file */
end_comment

begin_function
name|private
name|int
name|open_scratch
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|FILE
modifier|*
modifier|*
name|pfile
parameter_list|)
block|{
operator|*
name|pfile
operator|=
name|gp_open_scratch_file
argument_list|(
name|SCRATCH_TEMPLATE
argument_list|,
name|fname
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pfile
operator|==
name|NULL
condition|)
block|{
name|eprintf1
argument_list|(
literal|"could not open the scratch file %s.\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Standard device procedures ------ */
end_comment

begin_comment
comment|/* Macros for casting the pdev argument */
end_comment

begin_define
define|#
directive|define
name|ppdev
value|((gx_device_printer *)pdev)
end_define

begin_define
define|#
directive|define
name|pmemdev
value|((gx_device_memory *)pdev)
end_define

begin_define
define|#
directive|define
name|pcldev
value|((gx_device_clist *)pdev)
end_define

begin_decl_stmt
name|gx_device_procs
name|prn_std_procs
init|=
name|prn_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic initialization for the printer device. */
end_comment

begin_comment
comment|/* Specific devices may wish to extend this. */
end_comment

begin_function
name|int
name|gdev_prn_open
parameter_list|(
name|gx_device
modifier|*
name|pdev
parameter_list|)
block|{
name|gx_device_memory
modifier|*
name|mdev
init|=
name|gdev_mem_device_for_bits
argument_list|(
name|pdev
operator|->
name|color_info
operator|.
name|depth
argument_list|)
decl_stmt|;
name|ulong
name|mem_space
decl_stmt|;
name|byte
modifier|*
name|base
decl_stmt|;
if|if
condition|(
name|mdev
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|ppdev
operator|->
name|skip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ppdev
operator|->
name|skip
argument_list|)
argument_list|)
expr_stmt|;
name|mem_space
operator|=
name|gdev_mem_bitmap_size
argument_list|(
name|pmemdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_space
operator|>=
name|ppdev
operator|->
name|max_bitmap
operator|||
name|mem_space
operator|!=
operator|(
name|uint
operator|)
name|mem_space
operator|||
comment|/* too big to allocate */
operator|(
name|base
operator|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
operator|(
name|uint
operator|)
name|mem_space
argument_list|,
literal|1
argument_list|,
literal|"printer buffer"
argument_list|)
operator|)
operator|==
literal|0
comment|/* can't allocate */
condition|)
block|{
comment|/* Buffer the image in a command list. */
name|uint
name|space
decl_stmt|;
for|for
control|(
name|space
operator|=
name|ppdev
operator|->
name|use_buffer_space
init|;
condition|;
control|)
block|{
name|base
operator|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|space
argument_list|,
literal|1
argument_list|,
literal|"command list buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|space
operator|>>=
literal|1
operator|)
operator|<
name|PRN_BUFFER_SPACE
condition|)
return|return
operator|-
literal|1
return|;
comment|/* no hope */
block|}
name|ppdev
operator|->
name|buffer_space
operator|=
name|space
expr_stmt|;
name|pcldev
operator|->
name|mdev
operator|=
operator|*
name|mdev
expr_stmt|;
name|ppdev
operator|->
name|buf
operator|=
name|base
expr_stmt|;
name|pcldev
operator|->
name|data
operator|=
name|base
expr_stmt|;
name|pcldev
operator|->
name|data_size
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|open_scratch
argument_list|(
name|ppdev
operator|->
name|ccfname
argument_list|,
operator|&
name|ppdev
operator|->
name|ccfile
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|open_scratch
argument_list|(
name|ppdev
operator|->
name|cbfname
argument_list|,
operator|&
name|ppdev
operator|->
name|cbfile
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|pcldev
operator|->
name|target
operator|=
name|pdev
expr_stmt|;
name|pcldev
operator|->
name|cfile
operator|=
name|ppdev
operator|->
name|ccfile
expr_stmt|;
name|pcldev
operator|->
name|bfile
operator|=
name|ppdev
operator|->
name|cbfile
expr_stmt|;
name|pcldev
operator|->
name|bfile_end_pos
operator|=
literal|0
expr_stmt|;
name|ppdev
operator|->
name|mod_procs
operator|=
operator|*
name|gs_clist_device
operator|.
name|procs
expr_stmt|;
block|}
else|else
block|{
comment|/* Render entirely in memory. */
name|ppdev
operator|->
name|buffer_space
operator|=
literal|0
expr_stmt|;
name|ppdev
operator|->
name|ccfile
operator|=
name|NULL
expr_stmt|;
name|ppdev
operator|->
name|cbfile
operator|=
name|NULL
expr_stmt|;
name|pmemdev
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|ppdev
operator|->
name|mod_procs
operator|=
operator|*
name|mdev
operator|->
name|procs
expr_stmt|;
block|}
comment|/* Synthesize the procedure vector. */
comment|/* Rendering operations come from the memory or clist device, */
comment|/* non-rendering come from the printer device. */
block|{
name|gx_device_procs
modifier|*
name|pprocs
init|=
name|pdev
operator|->
name|procs
decl_stmt|;
name|ppdev
operator|->
name|orig_procs
operator|=
name|pprocs
expr_stmt|;
name|pdev
operator|->
name|procs
operator|=
operator|&
name|ppdev
operator|->
name|mod_procs
expr_stmt|;
define|#
directive|define
name|copy_proc
parameter_list|(
name|p
parameter_list|)
value|ppdev->mod_procs.p = pprocs->p
name|copy_proc
argument_list|(
name|get_initial_matrix
argument_list|)
expr_stmt|;
name|copy_proc
argument_list|(
name|output_page
argument_list|)
expr_stmt|;
name|copy_proc
argument_list|(
name|close_device
argument_list|)
expr_stmt|;
name|copy_proc
argument_list|(
name|map_rgb_color
argument_list|)
expr_stmt|;
name|copy_proc
argument_list|(
name|map_color_rgb
argument_list|)
expr_stmt|;
name|copy_proc
argument_list|(
name|get_props
argument_list|)
expr_stmt|;
name|copy_proc
argument_list|(
name|put_props
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|copy_proc
block|}
name|ppdev
operator|->
name|page_count
operator|=
literal|0
expr_stmt|;
name|ppdev
operator|->
name|file
operator|=
literal|0
expr_stmt|;
return|return
call|(
modifier|*
name|pdev
operator|->
name|procs
operator|->
name|open_device
call|)
argument_list|(
name|pdev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Added properties for printers */
end_comment

begin_decl_stmt
name|private
name|gs_prop_item
name|props_prn
index|[]
init|=
block|{
name|prop_def
argument_list|(
literal|"BufferSpace"
argument_list|,
name|prt_int
argument_list|)
block|,
name|prop_def
argument_list|(
literal|"MaxBitmap"
argument_list|,
name|prt_int
argument_list|)
block|,
name|prop_def
argument_list|(
literal|"OutputFile"
argument_list|,
argument|prt_string
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get properties.  In addition to the standard properties, */
end_comment

begin_comment
comment|/* we supply the max bitmap size, buffer size, and output name. */
end_comment

begin_function
name|int
name|gdev_prn_get_props
parameter_list|(
name|gx_device
modifier|*
name|pdev
parameter_list|,
name|gs_prop_item
modifier|*
name|plist
parameter_list|)
block|{
name|int
name|start
init|=
name|gx_default_get_props
argument_list|(
name|pdev
argument_list|,
name|plist
argument_list|)
decl_stmt|;
if|if
condition|(
name|plist
operator|!=
literal|0
condition|)
block|{
specifier|register
name|gs_prop_item
modifier|*
name|pi
init|=
name|plist
operator|+
name|start
decl_stmt|;
name|memcpy
argument_list|(
name|pi
argument_list|,
name|props_prn
argument_list|,
sizeof|sizeof
argument_list|(
name|props_prn
argument_list|)
argument_list|)
expr_stmt|;
name|pi
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|i
operator|=
name|ppdev
operator|->
name|use_buffer_space
expr_stmt|;
name|pi
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|i
operator|=
name|ppdev
operator|->
name|max_bitmap
expr_stmt|;
name|pi
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|s
operator|=
name|ppdev
operator|->
name|fname
expr_stmt|;
name|pi
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|start
operator|+
sizeof|sizeof
argument_list|(
name|props_prn
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|gs_prop_item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Put properties. */
end_comment

begin_function
name|int
name|gdev_prn_put_props
parameter_list|(
name|gx_device
modifier|*
name|pdev
parameter_list|,
name|gs_prop_item
modifier|*
name|plist
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|gs_prop_item
modifier|*
name|known
index|[
literal|3
index|]
decl_stmt|;
name|props_extract
argument_list|(
name|plist
argument_list|,
name|count
argument_list|,
name|props_prn
argument_list|,
literal|3
argument_list|,
name|known
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gx_default_put_props
argument_list|(
name|pdev
argument_list|,
name|plist
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|known
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|gs_prop_item
modifier|*
name|pi
init|=
name|known
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|value
operator|.
name|i
operator|<
literal|10000
condition|)
name|pi
operator|->
name|status
operator|=
name|pv_rangecheck
expr_stmt|;
else|else
name|ppdev
operator|->
name|use_buffer_space
operator|=
name|known
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|i
expr_stmt|;
block|}
if|if
condition|(
name|known
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|ppdev
operator|->
name|max_bitmap
operator|=
name|known
index|[
literal|1
index|]
operator|->
name|value
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|known
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|gs_prop_item
modifier|*
name|pn
init|=
name|known
index|[
literal|2
index|]
decl_stmt|;
name|int
name|size
init|=
name|pn
operator|->
name|value
operator|.
name|a
operator|.
name|size
decl_stmt|;
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|ppdev
operator|->
name|fname
argument_list|)
condition|)
name|pn
operator|->
name|status
operator|=
name|pv_limitcheck
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|ppdev
operator|->
name|fname
argument_list|,
name|pn
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pn
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|s
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generic routine to send the page to the printer. */
end_comment

begin_comment
comment|/****** Note that num_copies is currently ignored: this is wrong. ******/
end_comment

begin_function
name|int
name|gdev_prn_output_page
parameter_list|(
name|gx_device
modifier|*
name|pdev
parameter_list|,
name|int
name|num_copies
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|ppdev
operator|->
name|page_count
operator|++
expr_stmt|;
name|code
operator|=
name|gdev_prn_open_printer
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* print the accumulated page description */
name|code
operator|=
call|(
modifier|*
name|ppdev
operator|->
name|print_page
call|)
argument_list|(
name|ppdev
argument_list|,
name|ppdev
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|code
operator|=
name|gdev_prn_close_printer
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|ppdev
operator|->
name|buffer_space
condition|)
comment|/* reinitialize clist for writing */
name|code
operator|=
call|(
modifier|*
name|gs_clist_device
operator|.
name|procs
operator|->
name|output_page
call|)
argument_list|(
name|pdev
argument_list|,
name|num_copies
argument_list|,
name|flush
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Generic closing for the printer device. */
end_comment

begin_comment
comment|/* Specific devices may wish to extend this. */
end_comment

begin_function
name|int
name|gdev_prn_close
parameter_list|(
name|gx_device
modifier|*
name|pdev
parameter_list|)
block|{
if|if
condition|(
name|ppdev
operator|->
name|ccfile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|ppdev
operator|->
name|ccfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ppdev
operator|->
name|cbfile
argument_list|)
expr_stmt|;
name|ppdev
operator|->
name|ccfile
operator|=
name|NULL
expr_stmt|;
name|unlink
argument_list|(
name|ppdev
operator|->
name|ccfname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ppdev
operator|->
name|cbfname
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ppdev
operator|->
name|buf
argument_list|,
operator|(
name|uint
operator|)
name|ppdev
operator|->
name|buffer_space
argument_list|,
literal|1
argument_list|,
literal|"command list buffer"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppdev
operator|->
name|file
operator|!=
name|NULL
condition|)
block|{
name|gp_close_printer
argument_list|(
name|ppdev
operator|->
name|file
argument_list|,
name|ppdev
operator|->
name|fname
argument_list|)
expr_stmt|;
name|ppdev
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
block|}
name|pdev
operator|->
name|procs
operator|=
name|ppdev
operator|->
name|orig_procs
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map colors.  This is different from the default, because */
end_comment

begin_comment
comment|/* printers write black, not white. */
end_comment

begin_function
name|gx_color_index
name|gdev_prn_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
comment|/* Map values>= 1/2 to 0,< 1/2 to 1. */
return|return
operator|(
operator|(
name|r
operator||
name|g
operator||
name|b
operator|)
operator|>
name|gx_max_color_value
operator|/
literal|2
condition|?
operator|(
name|gx_color_index
operator|)
literal|0
else|:
operator|(
name|gx_color_index
operator|)
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gdev_prn_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
comment|/* Map 0 to max_value, 1 to 0. */
name|prgb
index|[
literal|0
index|]
operator|=
name|prgb
index|[
literal|1
index|]
operator|=
name|prgb
index|[
literal|2
index|]
operator|=
operator|-
operator|(
operator|(
name|gx_color_value
operator|)
name|color
operator|^
literal|1
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Driver services ------ */
end_comment

begin_comment
comment|/* Open the current page for printing. */
end_comment

begin_function
name|int
name|gdev_prn_open_printer
parameter_list|(
name|gx_device
modifier|*
name|pdev
parameter_list|)
block|{
name|char
modifier|*
name|fname
init|=
name|ppdev
operator|->
name|fname
decl_stmt|;
name|char
name|pfname
index|[
sizeof|sizeof
argument_list|(
name|ppdev
operator|->
name|fname
argument_list|)
operator|+
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|pfname
argument_list|,
name|fname
argument_list|,
name|ppdev
operator|->
name|page_count
argument_list|)
expr_stmt|;
name|fname
operator|=
name|pfname
expr_stmt|;
block|}
if|if
condition|(
name|ppdev
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
name|ppdev
operator|->
name|file
operator|=
name|gp_open_printer
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppdev
operator|->
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the size of a scan line for copying. */
end_comment

begin_function
name|uint
name|gdev_prn_bytes_per_scan_line
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|gx_device_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy scan lines from the buffer to the printer. */
end_comment

begin_function
name|int
name|gdev_prn_get_bits
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|int
name|y
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|size
parameter_list|,
name|int
name|pad
parameter_list|)
block|{
name|int
name|swap
init|=
call|(
modifier|*
name|pdev
operator|->
name|procs
operator|->
name|get_bits
call|)
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|,
name|y
argument_list|,
name|str
argument_list|,
name|size
argument_list|,
name|pad
argument_list|)
decl_stmt|;
name|uint
name|line_size
init|=
name|gdev_prn_bytes_per_scan_line
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
comment|/* If monobit, trim off trailing garbage. */
if|if
condition|(
name|pad
condition|)
block|{
name|int
name|extra_bits
init|=
operator|-
operator|(
name|pdev
operator|->
name|width
operator|*
name|pdev
operator|->
name|color_info
operator|.
name|depth
operator|)
operator|&
literal|31
decl_stmt|;
if|if
condition|(
name|extra_bits
condition|)
block|{
name|ulong
name|last_mask
init|=
literal|0xffffffffL
operator|<<
name|extra_bits
decl_stmt|;
name|byte
modifier|*
name|line_end
init|=
name|str
operator|+
name|line_size
operator|-
literal|4
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|swap
condition|)
comment|/* swap the mask */
name|memswab
argument_list|(
operator|&
name|last_mask
argument_list|,
operator|&
name|last_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|last_mask
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|size
init|;
name|n
operator|>=
name|line_size
condition|;
name|n
operator|-=
name|line_size
operator|,
name|line_end
operator|+=
name|line_size
control|)
operator|*
operator|(
name|ulong
operator|*
operator|)
name|line_end
operator|&=
name|last_mask
expr_stmt|;
block|}
block|}
else|else
comment|/* know !swap */
block|{
name|byte
name|last_mask
init|=
literal|0xff
operator|<<
operator|(
operator|-
operator|(
name|pdev
operator|->
name|width
operator|*
name|pdev
operator|->
name|color_info
operator|.
name|depth
operator|)
operator|&
literal|7
operator|)
decl_stmt|;
if|if
condition|(
name|last_mask
operator|!=
literal|0xff
condition|)
block|{
name|byte
modifier|*
name|line_end
init|=
name|str
operator|+
name|line_size
operator|-
literal|1
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|size
init|;
name|n
operator|>=
name|line_size
condition|;
name|n
operator|-=
name|line_size
operator|,
name|line_end
operator|+=
name|line_size
control|)
operator|*
name|line_end
operator|&=
name|last_mask
expr_stmt|;
block|}
block|}
return|return
name|swap
return|;
block|}
end_function

begin_comment
comment|/* Copy scan lines to a buffer.  Return the number of scan lines, */
end_comment

begin_comment
comment|/* or<0 if error. */
end_comment

begin_function
name|int
name|gdev_prn_copy_scan_lines
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|int
name|y
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|size
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|code
operator|=
name|gdev_prn_get_bits
argument_list|(
name|pdev
argument_list|,
name|y
argument_list|,
name|str
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|size
operator|/
name|gdev_prn_bytes_per_scan_line
argument_list|(
name|pdev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close the current page. */
end_comment

begin_function
name|int
name|gdev_prn_close_printer
parameter_list|(
name|gx_device
modifier|*
name|pdev
parameter_list|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|ppdev
operator|->
name|fname
argument_list|,
literal|'%'
argument_list|)
condition|)
comment|/* file per page */
block|{
name|gp_close_printer
argument_list|(
name|ppdev
operator|->
name|file
argument_list|,
name|ppdev
operator|->
name|fname
argument_list|)
expr_stmt|;
name|ppdev
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

