begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zcontrol.c */
end_comment

begin_comment
comment|/* Control operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Export the index of the 'for' operator */
end_comment

begin_comment
comment|/* for the transfer function mapper in zcolor.c. */
end_comment

begin_decl_stmt
name|int
name|i_zfor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check for updating the currentfile cache. */
end_comment

begin_define
define|#
directive|define
name|esfile_check
parameter_list|(
name|ep
parameter_list|)
define|\
value|if ( r_has_type_attrs(ep, t_file, a_executable) ) esfile = 0
end_define

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|es_ptr
name|find_stopped
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exec */
end_comment

begin_function
name|int
name|zexec
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|check_estack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
name|ref_assign
argument_list|(
name|esp
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|esfile_check
argument_list|(
name|esp
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* if */
end_comment

begin_function
name|int
name|zif
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|index
condition|)
comment|/* true */
block|{
name|check_estack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
name|ref_assign
argument_list|(
name|esp
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|esfile_check
argument_list|(
name|esp
argument_list|)
expr_stmt|;
block|}
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* ifelse */
end_comment

begin_function
name|int
name|zifelse
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|2
index|]
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
name|check_estack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
if|if
condition|(
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|index
condition|)
block|{
name|ref_assign
argument_list|(
name|esp
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref_assign
argument_list|(
name|esp
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|esfile_check
argument_list|(
name|esp
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* for */
end_comment

begin_decl_stmt
name|private
name|int
name|for_pos_int_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_for_pos_int_continue
decl_stmt|,
name|for_neg_int_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_for_neg_int_continue
decl_stmt|,
name|for_real_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_for_real_continue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zfor
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|float
name|params
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|es_ptr
name|ep
decl_stmt|;
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_has_type
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|t_integer
argument_list|)
operator|&&
name|r_has_type
argument_list|(
name|op
operator|-
literal|2
argument_list|,
name|t_integer
argument_list|)
operator|&&
name|r_has_type
argument_list|(
name|op
operator|-
literal|3
argument_list|,
name|t_integer
argument_list|)
condition|)
name|code
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|=
name|num_params
argument_list|(
name|op
operator|-
literal|1
argument_list|,
literal|3
argument_list|,
name|params
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|check_estack
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* Push a mark, the control variable, the initial value, */
comment|/* the increment, the limit, and the procedure, */
comment|/* and invoke the continuation operator. */
name|mark_estack
argument_list|(
name|es_for
argument_list|)
expr_stmt|;
name|ep
operator|=
name|esp
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
comment|/* initial& increment are ints */
block|{
name|ep
index|[
operator|-
literal|4
index|]
operator|=
name|op
index|[
operator|-
literal|3
index|]
expr_stmt|;
name|ep
index|[
operator|-
literal|3
index|]
operator|=
name|op
index|[
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|7
condition|)
name|ep
index|[
operator|-
literal|2
index|]
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|make_int
argument_list|(
name|ep
operator|-
literal|2
argument_list|,
operator|(
name|long
operator|)
name|params
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
operator|>=
literal|0
condition|)
name|make_op_estack
argument_list|(
name|ep
argument_list|,
name|for_pos_int_continue
argument_list|,
name|i_for_pos_int_continue
argument_list|)
expr_stmt|;
else|else
name|make_op_estack
argument_list|(
name|ep
argument_list|,
name|for_neg_int_continue
argument_list|,
name|i_for_neg_int_continue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|make_real
argument_list|(
name|ep
operator|-
literal|4
argument_list|,
name|params
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|ep
operator|-
literal|3
argument_list|,
name|params
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|ep
operator|-
literal|2
argument_list|,
name|params
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|make_op_estack
argument_list|(
name|ep
argument_list|,
name|for_real_continue
argument_list|,
name|i_for_real_continue
argument_list|)
expr_stmt|;
block|}
name|ep
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|op
expr_stmt|;
name|pop
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* Continuation operators for for, separate for positive integer, */
end_comment

begin_comment
comment|/* negative integer, and real. */
end_comment

begin_comment
comment|/* Execution stack contains mark, control variable, increment, */
end_comment

begin_comment
comment|/* limit, and procedure (procedure is topmost.) */
end_comment

begin_comment
comment|/* The continuation operator is just above the top of the e-stack. */
end_comment

begin_comment
comment|/* Continuation operator for positive integers. */
end_comment

begin_function
name|private
name|int
name|for_pos_int_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
specifier|register
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
name|long
name|var
init|=
name|ep
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
decl_stmt|;
if|if
condition|(
name|var
operator|>
name|ep
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
condition|)
block|{
name|esp
operator|-=
literal|5
expr_stmt|;
comment|/* pop everything */
return|return
name|o_pop_estack
return|;
block|}
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|ep
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
operator|=
name|var
operator|+
name|ep
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
expr_stmt|;
name|ref_assign
argument_list|(
name|ep
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* saved proc */
name|esp
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator for negative integers. */
end_comment

begin_function
name|private
name|int
name|for_neg_int_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
specifier|register
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
name|long
name|var
init|=
name|ep
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
decl_stmt|;
if|if
condition|(
name|var
operator|<
name|ep
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
condition|)
block|{
name|esp
operator|-=
literal|5
expr_stmt|;
comment|/* pop everything */
return|return
name|o_pop_estack
return|;
block|}
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|ep
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
operator|=
name|var
operator|+
name|ep
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
expr_stmt|;
name|ref_assign
argument_list|(
name|ep
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* saved proc */
name|esp
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator for reals. */
end_comment

begin_function
name|private
name|int
name|for_real_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
name|float
name|var
init|=
name|ep
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|realval
decl_stmt|;
name|float
name|incr
init|=
name|ep
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|realval
decl_stmt|;
if|if
condition|(
name|incr
operator|>=
literal|0
condition|?
operator|(
name|var
operator|>
name|ep
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|realval
operator|)
else|:
operator|(
name|var
operator|<
name|ep
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|realval
operator|)
condition|)
block|{
name|esp
operator|-=
literal|5
expr_stmt|;
comment|/* pop everything */
return|return
name|o_pop_estack
return|;
block|}
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|op
argument_list|,
name|ep
operator|-
literal|3
argument_list|)
expr_stmt|;
name|ep
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|realval
operator|=
name|var
operator|+
name|incr
expr_stmt|;
name|esp
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
name|ref_assign
argument_list|(
name|ep
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* saved proc */
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* repeat */
end_comment

begin_decl_stmt
name|private
name|int
name|repeat_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_repeat_continue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zrepeat
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|<
literal|0
condition|)
return|return
name|e_rangecheck
return|;
name|check_estack
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Push a mark, the count, and the procedure, and invoke */
comment|/* the continuation operator. */
name|mark_estack
argument_list|(
name|es_for
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
operator|*
name|op
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|repeat_continue
argument_list|(
name|op
operator|-
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator for repeat */
end_comment

begin_function
name|private
name|int
name|repeat_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
comment|/* saved proc */
if|if
condition|(
operator|--
operator|(
name|ep
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|)
operator|>=
literal|0
condition|)
comment|/* continue */
block|{
name|push_op_estack
argument_list|(
name|repeat_continue
argument_list|,
name|i_repeat_continue
argument_list|)
expr_stmt|;
comment|/* push continuation */
operator|++
name|esp
expr_stmt|;
name|ref_assign
argument_list|(
name|esp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
else|else
comment|/* done */
block|{
name|esp
operator|-=
literal|3
expr_stmt|;
comment|/* pop mark, count, proc */
return|return
name|o_pop_estack
return|;
block|}
block|}
end_function

begin_comment
comment|/* loop */
end_comment

begin_decl_stmt
name|private
name|int
name|loop_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_loop_continue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zloop
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|check_estack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Push a mark and the procedure, and invoke */
comment|/* the continuation operator. */
name|mark_estack
argument_list|(
name|es_for
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
operator|*
name|op
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|loop_continue
argument_list|(
name|op
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator for loop */
end_comment

begin_function
name|private
name|int
name|loop_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
specifier|register
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
comment|/* saved proc */
name|make_op_estack
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
name|loop_continue
argument_list|,
name|i_loop_continue
argument_list|)
expr_stmt|;
comment|/* push continuation */
name|ref_assign
argument_list|(
name|ep
operator|+
literal|2
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|esp
operator|=
name|ep
operator|+
literal|2
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* exit */
end_comment

begin_function
name|int
name|zexit
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
name|esfile
operator|=
literal|0
expr_stmt|;
comment|/* be lazy, just clear the cache */
while|while
condition|(
name|ep
operator|>=
name|esbot
condition|)
block|{
if|if
condition|(
name|r_has_type
argument_list|(
name|ep
argument_list|,
name|t_null
argument_list|)
condition|)
comment|/* control mark */
switch|switch
condition|(
operator|(
name|ep
operator|--
operator|)
operator|->
name|value
operator|.
name|index
condition|)
block|{
case|case
name|es_for
case|:
name|esp
operator|=
name|ep
expr_stmt|;
return|return
name|o_pop_estack
return|;
case|case
name|es_stopped
case|:
return|return
name|e_invalidexit
return|;
comment|/* not a loop */
block|}
else|else
name|ep
operator|--
expr_stmt|;
block|}
comment|/* Return e_invalidexit if there is no mark at all. */
comment|/* This is different from PostScript, which aborts. */
comment|/* It shouldn't matter in practice. */
return|return
name|e_invalidexit
return|;
block|}
end_function

begin_comment
comment|/* stop */
end_comment

begin_function
name|int
name|zstop
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|ep
init|=
name|find_stopped
argument_list|()
decl_stmt|;
name|esfile
operator|=
literal|0
expr_stmt|;
comment|/* be lazy, just clear the cache */
if|if
condition|(
name|ep
condition|)
block|{
name|esp
operator|=
name|ep
operator|-
literal|1
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|o_pop_estack
return|;
block|}
comment|/* Return e_invalidexit if there is no mark at all. */
comment|/* This is different from PostScript, which aborts. */
comment|/* It shouldn't matter in practice. */
return|return
name|e_invalidexit
return|;
block|}
end_function

begin_comment
comment|/* stopped */
end_comment

begin_function
name|int
name|zstopped
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark the execution stack, and push a false in case */
comment|/* control returns normally. */
name|check_estack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|mark_estack
argument_list|(
name|es_stopped
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
name|make_false
argument_list|(
name|esp
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
operator|*
name|op
expr_stmt|;
comment|/* execute the operand */
name|esfile_check
argument_list|(
name|esp
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* .instopped */
end_comment

begin_function
name|int
name|zinstopped
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
name|find_stopped
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* countexecstack */
end_comment

begin_function
name|int
name|zcountexecstack
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|esp
operator|-
name|esbot
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* execstack */
end_comment

begin_decl_stmt
name|private
name|int
name|execstack_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_execstack_continue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zexecstack
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
comment|/* We can't do this directly, because the interpreter */
comment|/* might have cached some state.  To force the interpreter */
comment|/* to update the stored state, we push a continuation on */
comment|/* the exec stack; the continuation is executed immediately, */
comment|/* and does the actual transfer. */
name|int
name|depth
init|=
name|esp
operator|-
name|esbot
operator|+
literal|1
decl_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_array
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|r_size
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
name|check_estack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|execstack_continue
argument_list|,
name|i_execstack_continue
argument_list|)
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator to do the actual transfer */
end_comment

begin_function
name|private
name|int
name|execstack_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|depth
init|=
name|r_size
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* was set above */
name|refcpy_to_old
argument_list|(
name|op
operator|->
name|value
operator|.
name|refs
argument_list|,
name|esbot
argument_list|,
name|depth
argument_list|,
literal|"execstack"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* .quit */
end_comment

begin_function
name|int
name|zquit
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
operator|(
name|int
operator|)
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
comment|/* gs_exit doesn't return, but just in case a miracle happens.... */
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zcontrol_op_defs
index|[]
init|=
block|{
block|{
literal|"0countexecstack"
block|,
name|zcountexecstack
block|}
block|,
block|{
literal|"1exec"
block|,
name|zexec
block|}
block|,
block|{
literal|"0execstack"
block|,
name|zexecstack
block|}
block|,
block|{
literal|"0exit"
block|,
name|zexit
block|}
block|,
block|{
literal|"2if"
block|,
name|zif
block|}
block|,
block|{
literal|"3ifelse"
block|,
name|zifelse
block|}
block|,
block|{
literal|"0.instopped"
block|,
name|zinstopped
block|}
block|,
block|{
literal|"4for"
block|,
name|zfor
block|,
operator|&
name|i_zfor
block|}
block|,
block|{
literal|"1loop"
block|,
name|zloop
block|}
block|,
block|{
literal|"1.quit"
block|,
name|zquit
block|}
block|,
block|{
literal|"2repeat"
block|,
name|zrepeat
block|}
block|,
block|{
literal|"0stop"
block|,
name|zstop
block|}
block|,
block|{
literal|"1stopped"
block|,
name|zstopped
block|}
block|,
comment|/* Internal operators */
block|{
literal|"0%execstack_continue"
block|,
name|execstack_continue
block|,
operator|&
name|i_execstack_continue
block|}
block|,
block|{
literal|"0%for_pos_int_continue"
block|,
name|for_pos_int_continue
block|,
operator|&
name|i_for_pos_int_continue
block|}
block|,
block|{
literal|"0%for_neg_int_continue"
block|,
name|for_neg_int_continue
block|,
operator|&
name|i_for_neg_int_continue
block|}
block|,
block|{
literal|"0%for_real_continue"
block|,
name|for_real_continue
block|,
operator|&
name|i_for_real_continue
block|}
block|,
block|{
literal|"0%loop_continue"
block|,
name|loop_continue
block|,
operator|&
name|i_loop_continue
block|}
block|,
block|{
literal|"0%repeat_continue"
block|,
name|repeat_continue
block|,
operator|&
name|i_repeat_continue
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal routines */
end_comment

begin_comment
comment|/* Find a `stopped' mark on the e-stack. */
end_comment

begin_comment
comment|/* Return the e-stack pointer or 0. */
end_comment

begin_function
name|private
name|es_ptr
name|find_stopped
parameter_list|()
block|{
specifier|register
name|es_ptr
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|esp
init|;
name|ep
operator|>=
name|esbot
condition|;
operator|--
name|ep
control|)
if|if
condition|(
name|r_has_type
argument_list|(
name|ep
argument_list|,
name|t_null
argument_list|)
operator|&&
name|ep
operator|->
name|value
operator|.
name|index
operator|==
name|es_stopped
condition|)
return|return
name|ep
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

