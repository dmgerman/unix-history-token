begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* ztype.c */
end_comment

begin_comment
comment|/* Type, attribute, and conversion operators for GhostScript */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_comment
comment|/* Imported procedures */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|scan_number_only
argument_list|(
name|P2
argument_list|(
name|ref
operator|*
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|near
name|access_check
argument_list|(
name|P3
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|convert_to_string
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max and min integer values expressed as reals. */
end_comment

begin_comment
comment|/* Note that these are biased by 1 to correct for truncation. */
end_comment

begin_define
define|#
directive|define
name|lb_real_int
value|(-1.0 * 0x8000L * 0x10000L - 1)
end_define

begin_define
define|#
directive|define
name|ub_real_int
value|( 1.0 * 0x8000L * 0x10000L)
end_define

begin_comment
comment|/* Get the pointer to the access flags for a ref. */
end_comment

begin_define
define|#
directive|define
name|access_ref
parameter_list|(
name|opp
parameter_list|)
define|\
value|(r_has_type(opp, t_dictionary) ? dict_access_ref(opp) : opp)
end_define

begin_comment
comment|/* Initialize the table of type names. */
end_comment

begin_comment
comment|/* We export the type names just in case they might be useful. */
end_comment

begin_decl_stmt
name|ref
name|type_names
index|[
name|t_next_index
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|ztype_init
parameter_list|()
block|{
specifier|static
specifier|const
name|char
modifier|*
name|tnames
index|[]
init|=
block|{
name|type_name_strings
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t_next_index
condition|;
name|i
operator|++
control|)
block|{
name|name_enter
argument_list|(
name|tnames
index|[
name|i
index|]
argument_list|,
operator|&
name|type_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|r_set_attrs
argument_list|(
operator|&
name|type_names
index|[
name|i
index|]
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* type */
end_comment

begin_function
name|int
name|ztype
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|ref
modifier|*
name|ptref
decl_stmt|;
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ptref
operator|=
operator|&
name|type_names
index|[
name|r_btype
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
name|ref_assign
argument_list|(
name|op
argument_list|,
name|ptref
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* cvlit */
end_comment

begin_function
name|int
name|zcvlit
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|ref
modifier|*
name|aop
decl_stmt|;
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|aop
operator|=
name|access_ref
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|r_clear_attrs
argument_list|(
name|aop
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* cvx */
end_comment

begin_function
name|int
name|zcvx
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|ref
modifier|*
name|aop
decl_stmt|;
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|aop
operator|=
name|access_ref
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|r_set_attrs
argument_list|(
name|aop
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xcheck */
end_comment

begin_function
name|int
name|zxcheck
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
operator|(
name|r_has_attr
argument_list|(
name|access_ref
argument_list|(
name|op
argument_list|)
argument_list|,
name|a_executable
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* executeonly */
end_comment

begin_function
name|int
name|zexecuteonly
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_op
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_has_type
argument_list|(
name|op
argument_list|,
name|t_dictionary
argument_list|)
condition|)
return|return
name|e_typecheck
return|;
return|return
name|access_check
argument_list|(
name|op
argument_list|,
name|a_execute
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* noaccess */
end_comment

begin_function
name|int
name|znoaccess
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|access_check
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* readonly */
end_comment

begin_function
name|int
name|zreadonly
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|access_check
argument_list|(
name|op
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* rcheck */
end_comment

begin_function
name|int
name|zrcheck
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|access_check
argument_list|(
name|op
argument_list|,
name|a_read
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|make_bool
argument_list|(
name|op
argument_list|,
name|code
argument_list|)
operator|,
name|code
operator|=
literal|0
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* wcheck */
end_comment

begin_function
name|int
name|zwcheck
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|access_check
argument_list|(
name|op
argument_list|,
name|a_write
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|make_bool
argument_list|(
name|op
argument_list|,
name|code
argument_list|)
operator|,
name|code
operator|=
literal|0
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* cvi */
end_comment

begin_function
name|int
name|zcvi
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|fval
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
return|return
literal|0
return|;
case|case
name|t_real
case|:
name|fval
operator|=
name|op
operator|->
name|value
operator|.
name|realval
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_string
case|:
block|{
name|ref
name|nref
decl_stmt|;
name|int
name|code
decl_stmt|;
name|code
operator|=
name|scan_number_only
argument_list|(
name|op
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
return|return
name|code
return|;
comment|/* error condition */
if|if
condition|(
name|r_has_type
argument_list|(
operator|&
name|nref
argument_list|,
name|t_integer
argument_list|)
condition|)
block|{
operator|*
name|op
operator|=
name|nref
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise, result was a real */
name|fval
operator|=
name|nref
operator|.
name|value
operator|.
name|realval
expr_stmt|;
block|}
block|}
comment|/* Check if a real will fit into an integer value */
if|if
condition|(
name|fval
operator|<=
name|lb_real_int
operator|||
name|fval
operator|>=
name|ub_real_int
condition|)
return|return
name|e_rangecheck
return|;
name|make_int
argument_list|(
name|op
argument_list|,
operator|(
name|long
operator|)
name|fval
argument_list|)
expr_stmt|;
comment|/* truncates towards 0 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* cvn */
end_comment

begin_function
name|int
name|zcvn
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
return|return
name|name_from_string
argument_list|(
name|op
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* cvr */
end_comment

begin_function
name|int
name|zcvr
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
name|make_real
argument_list|(
name|op
argument_list|,
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
case|case
name|t_real
case|:
return|return
literal|0
return|;
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_string
case|:
block|{
name|ref
name|nref
decl_stmt|;
name|int
name|code
decl_stmt|;
name|code
operator|=
name|scan_number_only
argument_list|(
name|op
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
return|return
name|code
return|;
comment|/* error condition */
if|if
condition|(
name|r_has_type
argument_list|(
operator|&
name|nref
argument_list|,
name|t_real
argument_list|)
condition|)
block|{
operator|*
name|op
operator|=
name|nref
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Otherwise, result was an integer */
name|make_real
argument_list|(
name|op
argument_list|,
name|nref
operator|.
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* cvrs */
end_comment

begin_function
name|int
name|zcvrs
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|radix
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|<
literal|2
operator|||
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|>
literal|36
condition|)
return|return
name|e_rangecheck
return|;
name|radix
operator|=
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
expr_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|radix
operator|==
literal|10
condition|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
operator|-
literal|2
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
case|case
name|t_real
case|:
block|{
name|int
name|code
init|=
name|convert_to_string
argument_list|(
name|op
operator|-
literal|2
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
return|return
name|e_typecheck
return|;
block|}
block|}
else|else
block|{
name|ulong
name|ival
decl_stmt|;
name|byte
name|digits
index|[
literal|32
index|]
decl_stmt|;
name|byte
modifier|*
name|endp
init|=
operator|&
name|digits
index|[
literal|32
index|]
decl_stmt|;
name|byte
modifier|*
name|dp
init|=
name|endp
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
operator|-
literal|2
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
name|ival
operator|=
operator|(
name|ulong
operator|)
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
expr_stmt|;
break|break;
case|case
name|t_real
case|:
block|{
name|float
name|fval
init|=
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|realval
decl_stmt|;
if|if
condition|(
name|fval
operator|<=
name|lb_real_int
operator|||
name|fval
operator|>=
name|ub_real_int
condition|)
return|return
name|e_rangecheck
return|;
name|ival
operator|=
operator|(
name|ulong
operator|)
operator|(
name|long
operator|)
name|fval
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
do|do
block|{
name|int
name|dit
init|=
name|ival
operator|%
name|radix
decl_stmt|;
operator|*
operator|--
name|dp
operator|=
name|dit
operator|+
operator|(
name|dit
operator|<
literal|10
condition|?
literal|'0'
else|:
operator|(
literal|'A'
operator|-
literal|10
operator|)
operator|)
expr_stmt|;
name|ival
operator|/=
name|radix
expr_stmt|;
block|}
do|while
condition|(
name|ival
condition|)
do|;
if|if
condition|(
name|endp
operator|-
name|dp
operator|>
name|r_size
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
name|memcpy
argument_list|(
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|dp
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|endp
operator|-
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|endp
operator|-
name|dp
argument_list|)
expr_stmt|;
block|}
name|op
index|[
operator|-
literal|2
index|]
operator|=
operator|*
name|op
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* cvs */
end_comment

begin_function
name|int
name|zcvs
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|code
operator|=
name|convert_to_string
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|ztype_op_defs
index|[]
init|=
block|{
block|{
literal|"1cvi"
block|,
name|zcvi
block|}
block|,
block|{
literal|"1cvlit"
block|,
name|zcvlit
block|}
block|,
block|{
literal|"1cvn"
block|,
name|zcvn
block|}
block|,
block|{
literal|"1cvr"
block|,
name|zcvr
block|}
block|,
block|{
literal|"3cvrs"
block|,
name|zcvrs
block|}
block|,
block|{
literal|"2cvs"
block|,
name|zcvs
block|}
block|,
block|{
literal|"1cvx"
block|,
name|zcvx
block|}
block|,
block|{
literal|"1executeonly"
block|,
name|zexecuteonly
block|}
block|,
block|{
literal|"1noaccess"
block|,
name|znoaccess
block|}
block|,
block|{
literal|"1rcheck"
block|,
name|zrcheck
block|}
block|,
block|{
literal|"1readonly"
block|,
name|zreadonly
block|}
block|,
block|{
literal|"1type"
block|,
name|ztype
block|}
block|,
block|{
literal|"1wcheck"
block|,
name|zwcheck
block|}
block|,
block|{
literal|"1xcheck"
block|,
name|zxcheck
block|}
block|,
name|op_def_end
argument_list|(
argument|ztype_init
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Test or modify the access of an object. */
end_comment

begin_comment
comment|/* If modify = 1, restrict to the selected access and return 0; */
end_comment

begin_comment
comment|/* if modify = 0, do not change the access, and return 1 */
end_comment

begin_comment
comment|/* if the object had the access. */
end_comment

begin_comment
comment|/* Return an error code if the object is not of appropriate type, */
end_comment

begin_comment
comment|/* or if the object did not have the access already when modify=1. */
end_comment

begin_function
name|private
name|int
name|near
name|access_check
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|int
name|access
parameter_list|,
comment|/* mask for attrs */
name|int
name|modify
parameter_list|)
comment|/* if true, reduce access */
block|{
name|ref
modifier|*
name|aop
init|=
name|op
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_dictionary
case|:
name|aop
operator|=
name|dict_access_ref
argument_list|(
name|op
argument_list|)
expr_stmt|;
case|case
name|t_array
case|:
case|case
name|t_file
case|:
case|case
name|t_gstate
case|:
case|case
name|t_string
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
empty_stmt|;
block|}
if|if
condition|(
name|modify
condition|)
block|{
if|if
condition|(
operator|!
name|r_has_attrs
argument_list|(
name|aop
argument_list|,
name|access
argument_list|)
condition|)
return|return
name|e_invalidaccess
return|;
if|if
condition|(
name|aop
operator|!=
name|op
condition|)
comment|/* i.e., t_dictionary */
block|{
name|ref_save
argument_list|(
name|aop
argument_list|,
literal|"access_check(modify)"
argument_list|)
expr_stmt|;
block|}
name|r_clear_attrs
argument_list|(
name|aop
argument_list|,
name|a_all
argument_list|)
expr_stmt|;
name|r_set_attrs
argument_list|(
name|aop
argument_list|,
name|access
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
name|r_has_attrs
argument_list|(
name|aop
argument_list|,
name|access
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Do all the work of cvs.  The destination has been checked, but not */
end_comment

begin_comment
comment|/* the source.  This is a separate procedure so that */
end_comment

begin_comment
comment|/* cvrs can use it when the radix is 10. */
end_comment

begin_function
name|private
name|int
name|convert_to_string
parameter_list|(
name|os_ptr
name|op1
parameter_list|,
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|uint
name|len
decl_stmt|;
if|if
condition|(
name|r_has_type
argument_list|(
name|op1
argument_list|,
name|t_string
argument_list|)
condition|)
name|check_read
argument_list|(
operator|*
name|op1
argument_list|)
expr_stmt|;
name|code
operator|=
name|obj_cvs
argument_list|(
name|op1
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
operator|*
name|op1
operator|=
operator|*
name|op
expr_stmt|;
name|r_set_size
argument_list|(
name|op1
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

