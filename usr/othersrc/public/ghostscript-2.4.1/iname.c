begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* iname.c */
end_comment

begin_comment
comment|/* Name lookup for Ghostscript interpreter */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Definitions and structure for the name table. */
end_comment

begin_comment
comment|/* The first entry is left unused. */
end_comment

begin_comment
comment|/* 1-character names are the next nt_1char_size entries. */
end_comment

begin_define
define|#
directive|define
name|nt_log2_sub_size
value|7
end_define

begin_define
define|#
directive|define
name|nt_sub_size
value|(1<< nt_log2_sub_size)
end_define

begin_define
define|#
directive|define
name|nt_sub_index_mask
value|(nt_sub_size - 1)
end_define

begin_define
define|#
directive|define
name|nt_hash_size
value|256
end_define

begin_comment
comment|/* must be a power of 2 */
end_comment

begin_define
define|#
directive|define
name|nt_1char_size
value|256
end_define

begin_comment
comment|/* must cover a full byte */
end_comment

begin_typedef
typedef|typedef
name|name
name|name_sub_table
index|[
name|nt_sub_size
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|ushort
name|hash
index|[
name|nt_hash_size
index|]
decl_stmt|;
name|name
modifier|*
name|table
index|[
literal|1
operator|<<
operator|(
literal|16
operator|-
name|nt_log2_sub_size
operator|)
index|]
decl_stmt|;
comment|/* name_sub_table */
name|ref
name|count
decl_stmt|;
comment|/* t_integer */
define|#
directive|define
name|nt_count
parameter_list|(
name|nt
parameter_list|)
value|(uint)((nt)->count.value.intval)
define|#
directive|define
name|set_nt_count
parameter_list|(
name|nt
parameter_list|,
name|cnt
parameter_list|)
value|((nt)->count.value.intval = (cnt))
block|}
name|name_table
typedef|;
end_typedef

begin_define
define|#
directive|define
name|name_index_ptr
parameter_list|(
name|nt
parameter_list|,
name|index
parameter_list|)
define|\
value|((nt)->table[(index)>> nt_log2_sub_size] + ((index)& nt_sub_index_mask))
end_define

begin_comment
comment|/*  * Scramble the assignment order within a sub-table, so that  * dictionary lookup doesn't have to scramble the index.  * The algorithm must have three properties:  *	- It must map 0 to 0;  *	- It must only scramble the sub-table index;  *	- It must be a permutation on the sub-table index.  * We do something very simple for now.  */
end_comment

begin_define
define|#
directive|define
name|name_count_to_index
parameter_list|(
name|cnt
parameter_list|)
define|\
value|(((cnt)& (-nt_sub_size)) + (((cnt) * 59)& nt_sub_index_mask))
end_define

begin_comment
comment|/* We also store the reverse permutation, for age checking in restore. */
end_comment

begin_define
define|#
directive|define
name|name_index_to_count
parameter_list|(
name|idx
parameter_list|)
define|\
value|((idx) ^ name_sub_index_to_count[(idx)& nt_sub_index_mask])
end_define

begin_if
if|#
directive|if
name|nt_sub_size
operator|<=
literal|256
end_if

begin_decl_stmt
name|private
name|byte
name|name_sub_index_to_count
index|[
name|nt_sub_size
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|private
name|ushort
name|name_sub_index_to_count
index|[
name|nt_sub_size
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The one and only name table (for now). */
end_comment

begin_decl_stmt
name|private
name|name_table
modifier|*
name|the_nt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|name_alloc_sub
argument_list|(
name|P1
argument_list|(
name|name_table
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a t_name ref out of a name * */
end_comment

begin_define
define|#
directive|define
name|make_name
parameter_list|(
name|pref
parameter_list|,
name|pnm
parameter_list|)
value|make_tv(pref, t_name, pname, pnm)
end_define

begin_comment
comment|/* Initialize the name table */
end_comment

begin_function
name|void
name|name_init
parameter_list|()
block|{
specifier|register
name|uint
name|i
decl_stmt|;
comment|/* Initialize the index_to_count map. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt_sub_size
condition|;
name|i
operator|++
control|)
block|{
name|uint
name|idx
init|=
name|name_count_to_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|name_sub_index_to_count
index|[
name|idx
index|]
operator|=
name|idx
operator|^
name|i
expr_stmt|;
block|}
name|the_nt
operator|=
operator|(
name|name_table
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|name_table
argument_list|)
argument_list|,
literal|"name_init"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|the_nt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name_table
argument_list|)
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
operator|&
name|the_nt
operator|->
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nt_1char_size
condition|;
name|i
operator|+=
name|nt_sub_size
control|)
block|{
name|set_nt_count
argument_list|(
name|the_nt
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|name_alloc_sub
argument_list|(
name|the_nt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look up or enter a name in the table. */
end_comment

begin_comment
comment|/* Return 0 or an error code. */
end_comment

begin_comment
comment|/* The return may overlap the characters of the string! */
end_comment

begin_comment
comment|/* See name.h for the meaning of enterflag. */
end_comment

begin_function
name|int
name|name_ref
parameter_list|(
specifier|const
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|isize
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|,
name|int
name|enterflag
parameter_list|)
block|{
specifier|register
name|name
modifier|*
name|pname
decl_stmt|;
specifier|const
name|byte
modifier|*
name|cptr
decl_stmt|;
name|ushort
name|size
init|=
operator|(
name|ushort
operator|)
name|isize
decl_stmt|;
comment|/* see name.h */
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|uint
name|ccnt
init|=
operator|*
name|ptr
operator|+
literal|1
decl_stmt|;
name|uint
name|nidx
init|=
name|name_count_to_index
argument_list|(
name|ccnt
argument_list|)
decl_stmt|;
name|pname
operator|=
name|name_index_ptr
argument_list|(
name|the_nt
argument_list|,
name|nidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pname
operator|->
name|string_size
operator|!=
literal|0
condition|)
block|{
name|make_name
argument_list|(
name|pref
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|enterflag
operator|<
literal|0
condition|)
return|return
name|e_undefined
return|;
name|pname
operator|->
name|index
operator|=
name|nidx
expr_stmt|;
name|pname
operator|->
name|next_index
operator|=
literal|0
expr_stmt|;
name|if_debug4
argument_list|(
literal|'n'
argument_list|,
literal|"[n]new name 0x%lx#%u, length=%u, count=%u\n"
argument_list|,
operator|(
name|ulong
operator|)
name|pname
argument_list|,
name|nidx
argument_list|,
name|isize
argument_list|,
name|ccnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ushort
modifier|*
name|phash
init|=
name|the_nt
operator|->
name|hash
operator|+
operator|(
operator|(
name|ushort
operator|)
name|string_hash
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
operator|&
operator|(
name|nt_hash_size
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|uint
name|nidx
init|=
operator|*
name|phash
decl_stmt|;
name|uint
name|ncnt
decl_stmt|;
while|while
condition|(
name|nidx
operator|!=
literal|0
condition|)
block|{
name|pname
operator|=
name|name_index_ptr
argument_list|(
name|the_nt
argument_list|,
name|nidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pname
operator|->
name|string_size
operator|==
name|size
operator|&&
operator|!
name|memcmp
argument_list|(
name|ptr
argument_list|,
name|pname
operator|->
name|string_bytes
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|make_name
argument_list|(
name|pref
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nidx
operator|=
name|pname
operator|->
name|next_index
expr_stmt|;
block|}
comment|/* Not in table, allocate a new entry. */
if|if
condition|(
name|enterflag
operator|<
literal|0
condition|)
return|return
name|e_undefined
return|;
if|if
condition|(
operator|!
operator|(
name|nt_count
argument_list|(
name|the_nt
argument_list|)
operator|&
operator|(
name|nt_sub_size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|int
name|code
init|=
name|name_alloc_sub
argument_list|(
name|the_nt
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
name|ncnt
operator|=
name|nt_count
argument_list|(
name|the_nt
argument_list|)
expr_stmt|;
name|nidx
operator|=
name|name_count_to_index
argument_list|(
name|ncnt
argument_list|)
expr_stmt|;
name|pname
operator|=
name|name_index_ptr
argument_list|(
name|the_nt
argument_list|,
name|nidx
argument_list|)
expr_stmt|;
name|pname
operator|->
name|index
operator|=
name|nidx
expr_stmt|;
name|pname
operator|->
name|next_index
operator|=
operator|*
name|phash
expr_stmt|;
operator|*
name|phash
operator|=
name|nidx
expr_stmt|;
name|if_debug4
argument_list|(
literal|'n'
argument_list|,
literal|"[n]new name 0x%lx#%u, length=%u, count=%u\n"
argument_list|,
operator|(
name|ulong
operator|)
name|pname
argument_list|,
name|nidx
argument_list|,
name|isize
argument_list|,
name|ncnt
argument_list|)
expr_stmt|;
name|ref_save
argument_list|(
operator|&
name|the_nt
operator|->
name|count
argument_list|,
literal|"name_ref(count)"
argument_list|)
expr_stmt|;
name|set_nt_count
argument_list|(
name|the_nt
argument_list|,
name|ncnt
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Name was not in the table.  Make a new entry. */
if|if
condition|(
name|enterflag
condition|)
block|{
name|cptr
operator|=
operator|(
specifier|const
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
literal|"name_ref(string)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|memcpy
argument_list|(
operator|(
name|byte
operator|*
operator|)
name|cptr
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|cptr
operator|=
name|ptr
expr_stmt|;
name|pname
operator|->
name|string_size
operator|=
name|size
expr_stmt|;
name|pname
operator|->
name|string_bytes
operator|=
name|cptr
expr_stmt|;
name|pname
operator|->
name|pvalue
operator|=
name|pv_no_defn
expr_stmt|;
name|make_name
argument_list|(
name|pref
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the string for a name. */
end_comment

begin_function
name|void
name|name_string_ref
parameter_list|(
specifier|const
name|ref
modifier|*
name|pnref
comment|/* t_name */
parameter_list|,
name|ref
modifier|*
name|psref
comment|/* result, t_string */
parameter_list|)
block|{
name|name
modifier|*
name|pname
init|=
name|pnref
operator|->
name|value
operator|.
name|pname
decl_stmt|;
name|make_tasv
argument_list|(
name|psref
argument_list|,
name|t_string
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
name|pname
operator|->
name|string_size
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|pname
operator|->
name|string_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a t_string object to a name. */
end_comment

begin_comment
comment|/* Copy the executable attribute. */
end_comment

begin_function
name|int
name|name_from_string
parameter_list|(
specifier|const
name|ref
modifier|*
name|psref
parameter_list|,
name|ref
modifier|*
name|pnref
parameter_list|)
block|{
name|int
name|exec
init|=
name|r_has_attr
argument_list|(
name|psref
argument_list|,
name|a_executable
argument_list|)
decl_stmt|;
name|int
name|code
init|=
name|name_ref
argument_list|(
name|psref
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|psref
argument_list|)
argument_list|,
name|pnref
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|exec
condition|)
name|r_set_attrs
argument_list|(
name|pnref
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Enter a name during initialization. */
end_comment

begin_comment
comment|/* Fatal error if the entry fails. */
end_comment

begin_function
name|void
name|name_enter
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
if|if
condition|(
name|name_ref
argument_list|(
operator|(
specifier|const
name|byte
operator|*
operator|)
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|pref
argument_list|,
literal|0
argument_list|)
condition|)
name|lprintf1
argument_list|(
literal|"name_enter failed - %s"
argument_list|,
name|str
argument_list|)
operator|,
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the name with a given index. */
end_comment

begin_function
name|void
name|name_index_ref
parameter_list|(
name|uint
name|index
parameter_list|,
name|ref
modifier|*
name|pnref
parameter_list|)
block|{
name|make_name
argument_list|(
name|pnref
argument_list|,
name|name_index_ptr
argument_list|(
name|the_nt
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the current name count. */
end_comment

begin_function
name|uint
name|name_count
parameter_list|()
block|{
return|return
name|nt_count
argument_list|(
name|the_nt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether a name was created since a given count. */
end_comment

begin_function
name|int
name|name_is_since_count
parameter_list|(
name|ref
modifier|*
name|pnref
parameter_list|,
name|uint
name|cnt
parameter_list|)
block|{
return|return
name|name_index_to_count
argument_list|(
name|name_index
argument_list|(
name|pnref
argument_list|)
argument_list|)
operator|>=
name|cnt
return|;
block|}
end_function

begin_comment
comment|/* Clean up the name table before a restore. */
end_comment

begin_comment
comment|/* The count will be reset, and added subtables will be freed. */
end_comment

begin_comment
comment|/* All we have to do is remove initial entries from the hash chains, */
end_comment

begin_comment
comment|/* since we know they are linked in decreasing index order */
end_comment

begin_comment
comment|/* (by sub-table, but not within each sub-table.) */
end_comment

begin_comment
comment|/* (There will be some spurious non-zero entries in the subtable table, */
end_comment

begin_comment
comment|/* but this doesn't matter since they will never be accessed.) */
end_comment

begin_function
name|void
name|name_restore
parameter_list|(
name|uint
name|old_count
parameter_list|)
block|{
name|ushort
modifier|*
name|phash
init|=
operator|&
name|the_nt
operator|->
name|hash
index|[
literal|0
index|]
decl_stmt|;
name|uint
name|old_sub
init|=
name|old_count
operator|&
operator|-
name|nt_sub_size
decl_stmt|;
specifier|register
name|uint
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt_hash_size
condition|;
name|phash
operator|++
operator|,
name|i
operator|++
control|)
block|{
specifier|register
name|ushort
modifier|*
name|pnh
init|=
name|phash
decl_stmt|;
while|while
condition|(
operator|*
name|pnh
operator|>=
name|old_sub
condition|)
block|{
if|if
condition|(
name|name_index_to_count
argument_list|(
operator|*
name|pnh
argument_list|)
operator|<
name|old_count
condition|)
name|pnh
operator|=
operator|&
name|name_index_ptr
argument_list|(
name|the_nt
argument_list|,
operator|*
name|pnh
argument_list|)
operator|->
name|next_index
expr_stmt|;
else|else
operator|*
name|pnh
operator|=
name|name_index_ptr
argument_list|(
name|the_nt
argument_list|,
operator|*
name|pnh
argument_list|)
operator|->
name|next_index
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ------ Internal procedures ------ */
end_comment

begin_comment
comment|/* Allocate the next sub-table. */
end_comment

begin_function
name|private
name|int
name|name_alloc_sub
parameter_list|(
name|name_table
modifier|*
name|nt
parameter_list|)
block|{
name|name
modifier|*
name|sub
init|=
operator|(
name|name
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|name_sub_table
argument_list|)
argument_list|,
literal|"name_alloc_sub"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|memset
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|name_sub_table
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|table
index|[
name|nt_count
argument_list|(
name|nt
argument_list|)
operator|>>
name|nt_log2_sub_size
index|]
operator|=
name|sub
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

