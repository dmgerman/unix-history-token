begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zrelbit.c */
end_comment

begin_comment
comment|/* Relational, boolean, and bit operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|int
name|obj_le
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* eq */
end_comment

begin_function
name|int
name|zeq
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
specifier|register
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
define|#
directive|define
name|eq_check_read
parameter_list|(
name|opp
parameter_list|)
define|\
value|switch ( r_type(opp) )\    {	case t_string: case t_array: case t_mixedarray: case t_shortarray:\ 	  check_read(*opp); break;\ 	case t_dictionary: check_dict_read(*opp);\    }
name|eq_check_read
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|eq_check_read
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op1
argument_list|,
operator|(
name|obj_eq
argument_list|(
name|op1
argument_list|,
name|op
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ne */
end_comment

begin_function
name|int
name|zne
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
comment|/* We'll just be lazy and use eq. */
name|int
name|code
init|=
name|zeq
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|index
operator|^=
literal|1
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ge */
end_comment

begin_function
name|int
name|zge
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|obj_le
argument_list|(
name|op
argument_list|,
name|op
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_bool
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* gt */
end_comment

begin_function
name|int
name|zgt
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|obj_le
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_bool
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|code
operator|^
literal|1
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* le */
end_comment

begin_function
name|int
name|zle
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|obj_le
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_bool
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* lt */
end_comment

begin_function
name|int
name|zlt
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|obj_le
argument_list|(
name|op
argument_list|,
name|op
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_bool
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|code
operator|^
literal|1
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* max */
end_comment

begin_function
name|int
name|zmax
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|obj_le
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|code
condition|)
block|{
name|ref_assign
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* min */
end_comment

begin_function
name|int
name|zmin
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|obj_le
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|!
name|code
condition|)
block|{
name|ref_assign
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* and */
end_comment

begin_function
name|int
name|zand
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|r_type
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_boolean
case|:
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|index
operator|&=
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|&=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* not */
end_comment

begin_function
name|int
name|znot
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_boolean
case|:
name|op
operator|->
name|value
operator|.
name|index
operator|=
operator|!
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|op
operator|->
name|value
operator|.
name|intval
operator|=
operator|~
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* or */
end_comment

begin_function
name|int
name|zor
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|r_type
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_boolean
case|:
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|index
operator||=
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator||=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* xor */
end_comment

begin_function
name|int
name|zxor
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|r_type
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_boolean
case|:
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|index
operator|^=
name|op
operator|->
name|value
operator|.
name|index
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|^=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* bitshift */
end_comment

begin_function
name|int
name|zbitshift
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|shift
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|<
operator|-
literal|31
operator|||
name|op
operator|->
name|value
operator|.
name|intval
operator|>
literal|31
condition|)
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|shift
operator|=
name|op
operator|->
name|value
operator|.
name|intval
operator|)
operator|<
literal|0
condition|)
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|=
operator|(
call|(
name|ulong
call|)
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
argument_list|)
operator|)
operator|>>
operator|-
name|shift
expr_stmt|;
else|else
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|<<=
name|shift
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zrelbit_op_defs
index|[]
init|=
block|{
block|{
literal|"2and"
block|,
name|zand
block|}
block|,
block|{
literal|"2bitshift"
block|,
name|zbitshift
block|}
block|,
block|{
literal|"2eq"
block|,
name|zeq
block|}
block|,
block|{
literal|"2ge"
block|,
name|zge
block|}
block|,
block|{
literal|"2gt"
block|,
name|zgt
block|}
block|,
block|{
literal|"2le"
block|,
name|zle
block|}
block|,
block|{
literal|"2lt"
block|,
name|zlt
block|}
block|,
block|{
literal|"2max"
block|,
name|zmax
block|}
block|,
block|{
literal|"2min"
block|,
name|zmin
block|}
block|,
block|{
literal|"2ne"
block|,
name|zne
block|}
block|,
block|{
literal|"1not"
block|,
name|znot
block|}
block|,
block|{
literal|"2or"
block|,
name|zor
block|}
block|,
block|{
literal|"2xor"
block|,
name|zxor
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Compare two operands (both numeric, or both strings). */
end_comment

begin_comment
comment|/* Return 1 if op[-1]<= op[0], 0 if op[-1]> op[0], */
end_comment

begin_comment
comment|/* or a (negative) error code. */
end_comment

begin_define
define|#
directive|define
name|bcval
parameter_list|(
name|v1
parameter_list|,
name|rel
parameter_list|,
name|v2
parameter_list|)
value|(op1->value.v1 rel op->value.v2 ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|bcstr
parameter_list|(
name|rel
parameter_list|)
define|\
value|(bytes_compare(op1->value.bytes, r_size(op1),\ 		 op->value.bytes, r_size(op)) rel 0 ? 1 : 0)
end_define

begin_function
name|int
name|obj_le
parameter_list|(
specifier|register
name|os_ptr
name|op1
parameter_list|,
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
return|return
name|bcval
argument_list|(
name|intval
argument_list|,
operator|<=
argument_list|,
name|intval
argument_list|)
return|;
case|case
name|t_real
case|:
return|return
name|bcval
argument_list|(
name|intval
argument_list|,
operator|<=
argument_list|,
name|realval
argument_list|)
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
case|case
name|t_real
case|:
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_real
case|:
return|return
name|bcval
argument_list|(
name|realval
argument_list|,
operator|<=
argument_list|,
name|realval
argument_list|)
return|;
case|case
name|t_integer
case|:
return|return
name|bcval
argument_list|(
name|realval
argument_list|,
operator|<=
argument_list|,
name|intval
argument_list|)
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
case|case
name|t_string
case|:
name|check_read
argument_list|(
operator|*
name|op1
argument_list|)
expr_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
return|return
name|bcstr
argument_list|(
operator|<=
argument_list|)
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
block|}
end_function

end_unit

