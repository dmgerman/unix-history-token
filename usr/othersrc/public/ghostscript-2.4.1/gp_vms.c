begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gp_vms.c */
end_comment

begin_comment
comment|/* VAX/VMS specific routines for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gs.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_include
include|#
directive|include
file|<stat.h>
end_include

begin_define
define|#
directive|define
name|MAX_VMS_FILENAME_LEN
value|255
end_define

begin_comment
comment|/* VMS string descriptor structure */
end_comment

begin_define
define|#
directive|define
name|DSC$K_DTYPE_T
value|14
end_define

begin_define
define|#
directive|define
name|DSC$K_CLASS_S
value|1
end_define

begin_struct
struct|struct
name|dsc$descriptor_s
block|{
name|unsigned
name|short
name|dsc$w_length
decl_stmt|;
name|unsigned
name|char
name|dsc$b_dtype
decl_stmt|;
name|unsigned
name|char
name|dsc$b_class
decl_stmt|;
name|char
modifier|*
name|dsc$a_pointer
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dsc$descriptor_s
name|descrip
typedef|;
end_typedef

begin_comment
comment|/* VMS RMS constants */
end_comment

begin_define
define|#
directive|define
name|RMS$_NMF
value|99018
end_define

begin_define
define|#
directive|define
name|RMS$_NORMAL
value|65537
end_define

begin_struct
struct|struct
name|file_enum_s
block|{
name|uint
name|context
decl_stmt|,
name|length
decl_stmt|;
name|descrip
modifier|*
name|pattern
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|uint
name|LIB$FIND_FILE
argument_list|(
name|descrip
operator|*
argument_list|,
name|descrip
operator|*
argument_list|,
name|uint
operator|*
argument_list|,
name|descrip
operator|*
argument_list|,
name|descrip
operator|*
argument_list|,
name|uint
operator|*
argument_list|,
name|uint
operator|*
argument_list|)
decl_stmt|,
name|LIB$FIND_FILE_END
argument_list|(
name|uint
operator|*
argument_list|)
decl_stmt|,
name|SYS$FILESCAN
argument_list|(
name|descrip
operator|*
argument_list|,
name|uint
operator|*
argument_list|,
name|uint
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|uint
name|strlength
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|uint
name|maxlen
parameter_list|,
name|char
name|term
parameter_list|)
block|{
name|uint
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|maxlen
operator|&&
name|str
index|[
name|i
index|]
operator|!=
name|term
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Do platform-dependent initialization. */
end_comment

begin_function
name|void
name|gp_init
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Do platform-dependent cleanup. */
end_comment

begin_function
name|void
name|gp_exit
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* ------ Date and time ------ */
end_comment

begin_comment
comment|/* Read the current date (in days since Jan. 1, 1980) */
end_comment

begin_comment
comment|/* and time (in milliseconds since midnight). */
end_comment

begin_function
name|void
name|gp_get_clock
parameter_list|(
name|long
modifier|*
name|pdt
parameter_list|)
block|{
struct|struct
block|{
name|uint
name|_l0
decl_stmt|,
name|_l1
decl_stmt|;
block|}
name|binary_date
struct|;
name|long
name|lib$day
argument_list|()
decl_stmt|,
name|sys$bintim
argument_list|()
decl_stmt|;
name|long
name|days
decl_stmt|,
name|days0
decl_stmt|,
name|seconds
decl_stmt|;
name|char
modifier|*
name|jan_1_1980
init|=
literal|"1-JAN-1980"
decl_stmt|;
name|char
modifier|*
name|midnight
init|=
literal|"00:00:00.00"
decl_stmt|;
name|descrip
name|str_desc
decl_stmt|;
comment|/* Get days from system zero date (November 17, 1858) to present. */
operator|(
name|void
operator|)
name|lib$day
argument_list|(
operator|&
name|days0
argument_list|)
expr_stmt|;
comment|/* For those interested, Wednesday, November 17, 1858 is the base 	   of the Modified Julian Day system adopted by the Smithsonian 	   Astrophysical Observatory in 1957 for satellite tracking.  (The 	   year 1858 preceded the oldest star catalog in use at the 	   observatory.)  VMS uses quadword time stamps which are offsets 	   in 100 nanosecond units from November 17, 1858.  With a 63-bit 	   absolute time representation (sign bit must be clear), VMS will 	   have no trouble with time until 31-JUL-31086 02:48:05.47. */
comment|/* Convert January 1, 1980 into a binary absolute time */
name|str_desc
operator|.
name|dsc$w_length
operator|=
name|strlen
argument_list|(
name|jan_1_1980
argument_list|)
expr_stmt|;
name|str_desc
operator|.
name|dsc$a_pointer
operator|=
name|jan_1_1980
expr_stmt|;
operator|(
name|void
operator|)
name|sys$bintim
argument_list|(
operator|&
name|str_desc
argument_list|,
operator|&
name|binary_date
argument_list|)
expr_stmt|;
comment|/* Now get days from system zero date to January 1, 1980 */
operator|(
name|void
operator|)
name|lib$day
argument_list|(
operator|&
name|days
argument_list|,
operator|&
name|binary_date
argument_list|)
expr_stmt|;
comment|/* Now compute number of days since January 1, 1980 */
name|pdt
index|[
literal|0
index|]
operator|=
literal|1
operator|+
name|days0
operator|-
name|days
expr_stmt|;
comment|/* Convert midnight into a binary delta time */
name|str_desc
operator|.
name|dsc$w_length
operator|=
name|strlen
argument_list|(
name|midnight
argument_list|)
expr_stmt|;
name|str_desc
operator|.
name|dsc$a_pointer
operator|=
name|midnight
expr_stmt|;
operator|(
name|void
operator|)
name|sys$bintim
argument_list|(
operator|&
name|str_desc
argument_list|,
operator|&
name|binary_date
argument_list|)
expr_stmt|;
comment|/* Now get number 10 millisecond time units since midnight */
operator|(
name|void
operator|)
name|lib$day
argument_list|(
operator|&
name|days
argument_list|,
operator|&
name|binary_date
argument_list|,
operator|&
name|seconds
argument_list|)
expr_stmt|;
name|pdt
index|[
literal|1
index|]
operator|=
literal|10
operator|*
name|seconds
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Screen management ------ */
end_comment

begin_comment
comment|/* Write a string to the console. */
end_comment

begin_function
name|void
name|gp_console_puts
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint
name|size
parameter_list|)
block|{
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the console current on the screen. */
end_comment

begin_function
name|int
name|gp_make_console_current
parameter_list|(
name|struct
name|gx_device_s
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make the graphics current on the screen. */
end_comment

begin_function
name|int
name|gp_make_graphics_current
parameter_list|(
name|struct
name|gx_device_s
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Printer accessing ------ */
end_comment

begin_comment
comment|/* Open a connection to a printer.  A null file name means use the */
end_comment

begin_comment
comment|/* standard printer connected to the machine, if any. */
end_comment

begin_comment
comment|/* Return NULL if the connection could not be opened. */
end_comment

begin_function
name|FILE
modifier|*
name|gp_open_printer
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
return|return
operator|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|==
literal|0
condition|?
name|gp_open_scratch_file
argument_list|(
name|gp_scratch_file_name_prefix
argument_list|,
name|fname
argument_list|,
literal|"wb"
argument_list|)
else|:
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"wb"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Close the connection to the printer. */
end_comment

begin_function
name|void
name|gp_close_printer
parameter_list|(
name|FILE
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|fclose
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ File names ------ */
end_comment

begin_comment
comment|/* Define the character used for separating file names in a list. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|gp_file_name_list_separator
init|=
literal|','
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the default scratch file name prefix. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|gp_scratch_file_name_prefix
index|[]
init|=
literal|"_temp_"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define whether case is insignificant in file names. */
end_comment

begin_decl_stmt
specifier|const
name|int
name|gp_file_names_ignore_case
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create and open a scratch file with a given name prefix. */
end_comment

begin_comment
comment|/* Write the actual file name at fname. */
end_comment

begin_function
name|FILE
modifier|*
name|gp_open_scratch_file
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"XXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|fopen
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Answer whether a file name contains a directory/device specification, i.e.,  *  is absolute (not directory- or device-relative).  Since for VMS, the concept  *  of an "absolute" file reference has no meaning.  As Ghostscript is here  *  merely checking to see if it will make sense to paste a path to the front  *  of the file name, we use the VMS system service SYS$FILESCAN to check that  *  the file name has no node, device, root, or directory specification: if all  *  four of these items are missing from the file name then it is considered to  *  a relative file name to which a path may be prefixed. (Roots are associated  *  with rooted logical names.)  */
end_comment

begin_function
name|int
name|gp_file_name_is_absolute
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
name|descrip
name|str_desc
decl_stmt|;
struct|struct
block|{
name|unsigned
name|fscn$v_node
range|:
literal|1
decl_stmt|;
name|unsigned
name|fscn$v_device
range|:
literal|1
decl_stmt|;
name|unsigned
name|fscn$v_root
range|:
literal|1
decl_stmt|;
name|unsigned
name|fscn$v_directory
range|:
literal|1
decl_stmt|;
name|unsigned
name|fscn$v_name
range|:
literal|1
decl_stmt|;
name|unsigned
name|fscn$v_type
range|:
literal|1
decl_stmt|;
name|unsigned
name|fscn$v_version
range|:
literal|1
decl_stmt|;
name|unsigned
name|fscn$v_fill_23
range|:
literal|1
decl_stmt|;
block|}
name|flags
struct|;
name|str_desc
operator|.
name|dsc$w_length
operator|=
name|len
expr_stmt|;
name|str_desc
operator|.
name|dsc$a_pointer
operator|=
name|fname
expr_stmt|;
name|SYS$FILESCAN
argument_list|(
operator|&
name|str_desc
argument_list|,
operator|&
literal|0L
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|fscn$v_directory
operator|||
name|flags
operator|.
name|fscn$v_root
operator|||
name|flags
operator|.
name|fscn$v_device
operator|||
name|flags
operator|.
name|fscn$v_node
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Answer the string to be used for combining a directory/device prefix */
end_comment

begin_comment
comment|/* with a base file name.  The file name is known to not be absolute. */
end_comment

begin_function
name|char
modifier|*
name|gp_file_name_concat_string
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|uint
name|plen
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
comment|/*  Full VAX/VMS paths are of the form: 	 * 	 *    device:[root.][directory.subdirectory]filename.extension;version 	 *    logical:filename.extension;version 	 * 	 *  Roots are fairly rare and associated typically with rooted logical 	 *  names. 	 * 	 *  Examples: 	 * 	 *    DUA1:[GHOSTSCRIPT]GHOST.PS;1 	 *    THOR_DEC:[DOOF.A.B.C.D]FILE.DAT;-3 	 *    LOG:GHOST.PS  (LOG is a logical defined as DUA1:[GHOSTSCRIPT]) 	 *    LOG:DOOF.DAT  (LOG is defined as DUA1, current directory is 	 *                   is used as the directory spec.) 	 * 	 */
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
switch|switch
condition|(
name|prefix
index|[
name|plen
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|':'
case|:
case|case
literal|']'
case|:
return|return
literal|""
return|;
block|}
empty_stmt|;
return|return
literal|":"
return|;
block|}
end_function

begin_comment
comment|/* ------ File operations ------ */
end_comment

begin_comment
comment|/* If the file given by fname exists, fill in its status and return 1; */
end_comment

begin_comment
comment|/* otherwise return 0. */
end_comment

begin_function
name|int
name|gp_file_status
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|file_status
modifier|*
name|pstatus
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|pstatus
operator|->
name|size_pages
operator|=
operator|(
name|sbuf
operator|.
name|st_size
operator|+
literal|1023
operator|)
operator|>>
literal|10
expr_stmt|;
comment|/* no st_blocks */
name|pstatus
operator|->
name|size_bytes
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
name|pstatus
operator|->
name|time_referenced
operator|=
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
name|pstatus
operator|->
name|time_created
operator|=
name|sbuf
operator|.
name|st_ctime
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ------ Wild card file search procedures ------ */
end_comment

begin_function
name|private
name|void
name|gp_free_enumeration
parameter_list|(
name|file_enum
modifier|*
name|pfen
parameter_list|)
block|{
if|if
condition|(
name|pfen
condition|)
block|{
name|LIB$FIND_FILE_END
argument_list|(
operator|&
name|pfen
operator|->
name|context
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
name|pfen
operator|->
name|pattern
operator|->
name|dsc$a_pointer
argument_list|,
name|pfen
operator|->
name|length
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(pattern)"
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfen
operator|->
name|pattern
argument_list|,
sizeof|sizeof
argument_list|(
name|descrip
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(descriptor)"
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfen
argument_list|,
sizeof|sizeof
argument_list|(
name|file_enum
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(file_enum)"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Begin an enumeration.  pat is a C string that may contain *s or ?s. */
end_comment

begin_comment
comment|/* The implementor should copy the string to a safe place. */
end_comment

begin_comment
comment|/* If the operating system doesn't support correct, arbitrarily placed */
end_comment

begin_comment
comment|/* *s and ?s, the implementation should modify the string so that it */
end_comment

begin_comment
comment|/* will return a conservative superset of the request.  E.g., if the OS */
end_comment

begin_comment
comment|/* doesn't implement ? (single-character wild card), any consecutive */
end_comment

begin_comment
comment|/* string of ?s should be interpreted as *.  Note that \ can appear in */
end_comment

begin_comment
comment|/* the pattern also, as a quoting character. */
end_comment

begin_function
name|file_enum
modifier|*
name|gp_enumerate_files_init
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|uint
name|patlen
parameter_list|)
block|{
name|file_enum
modifier|*
name|pfen
decl_stmt|;
name|uint
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|newpat
decl_stmt|;
name|pfen
operator|=
operator|(
name|file_enum
operator|*
operator|)
name|gs_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|file_enum
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(file_enum)"
argument_list|)
expr_stmt|;
name|pfen
operator|->
name|pattern
operator|=
operator|(
name|descrip
operator|*
operator|)
name|gs_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|descrip
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(descriptor)"
argument_list|)
expr_stmt|;
name|newpat
operator|=
operator|(
name|char
operator|*
operator|)
name|gs_malloc
argument_list|(
name|patlen
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(pattern)"
argument_list|)
expr_stmt|;
comment|/*  Copy the pattern removing backslash quoting characters and 	 *  transforming unquoted question marks, '?', to percent signs, '%'. 	 *  (VAX/VMS uses the wildcard '%' to represent exactly one character 	 *  and '*' to represent zero or more characters.  Any combination and 	 *  number of interspersed wildcards is permitted.) 	 */
name|c
operator|=
name|newpat
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patlen
condition|;
name|pat
operator|++
operator|,
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|pat
condition|)
block|{
case|case
literal|'?'
case|:
operator|*
name|c
operator|++
operator|=
literal|'%'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|patlen
condition|)
operator|*
name|c
operator|++
operator|=
operator|*
operator|++
name|pat
expr_stmt|;
break|break;
default|default   :
operator|*
name|c
operator|++
operator|=
operator|*
name|pat
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|c
operator|-
name|newpat
expr_stmt|;
comment|/* Pattern may not exceed 255 characters */
if|if
condition|(
name|len
operator|>
literal|255
condition|)
block|{
name|gs_free
argument_list|(
name|newpat
argument_list|,
name|patlen
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(pattern)"
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfen
operator|->
name|pattern
argument_list|,
sizeof|sizeof
argument_list|(
name|descrip
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(descriptor)"
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfen
argument_list|,
sizeof|sizeof
argument_list|(
name|file_enum
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|"GP_ENUM(file_enum)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|file_enum
operator|*
operator|)
literal|0
return|;
block|}
name|pfen
operator|->
name|context
operator|=
literal|0
expr_stmt|;
name|pfen
operator|->
name|length
operator|=
name|patlen
expr_stmt|;
name|pfen
operator|->
name|pattern
operator|->
name|dsc$w_length
operator|=
name|len
expr_stmt|;
name|pfen
operator|->
name|pattern
operator|->
name|dsc$b_dtype
operator|=
name|DSC$K_DTYPE_T
expr_stmt|;
name|pfen
operator|->
name|pattern
operator|->
name|dsc$b_class
operator|=
name|DSC$K_CLASS_S
expr_stmt|;
name|pfen
operator|->
name|pattern
operator|->
name|dsc$a_pointer
operator|=
name|newpat
expr_stmt|;
return|return
name|pfen
return|;
block|}
end_function

begin_comment
comment|/* Return the next file name in the enumeration.  The client passes in */
end_comment

begin_comment
comment|/* a scratch string and a max length.  If the name of the next file fits, */
end_comment

begin_comment
comment|/* the procedure returns the length.  If it doesn't fit, the procedure */
end_comment

begin_comment
comment|/* returns max length +1.  If there are no more files, the procedure */
end_comment

begin_comment
comment|/* returns -1. */
end_comment

begin_function
name|uint
name|gp_enumerate_files_next
parameter_list|(
name|file_enum
modifier|*
name|pfen
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|uint
name|maxlen
parameter_list|)
block|{
name|char
modifier|*
name|c
decl_stmt|,
name|filnam
index|[
name|MAX_VMS_FILENAME_LEN
index|]
decl_stmt|;
name|descrip
name|result
init|=
block|{
name|MAX_VMS_FILENAME_LEN
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|filnam
block|}
decl_stmt|;
name|uint
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* Find the next file which matches the pattern */
name|i
operator|=
name|LIB$FIND_FILE
argument_list|(
name|pfen
operator|->
name|pattern
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|pfen
operator|->
name|context
argument_list|,
operator|(
name|descrip
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|descrip
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|uint
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|uint
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Check the return status */
if|if
condition|(
name|i
operator|==
name|RMS$_NMF
condition|)
block|{
name|gp_free_enumeration
argument_list|(
name|pfen
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint
operator|)
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
name|RMS$_NORMAL
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|len
operator|=
name|strlength
argument_list|(
name|filnam
argument_list|,
name|MAX_VMS_FILENAME_LEN
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
name|maxlen
condition|)
return|return
name|maxlen
operator|+
literal|1
return|;
comment|/* Copy the returned filename over to the input string ptr */
name|c
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|c
operator|++
operator|=
name|filnam
index|[
name|i
index|]
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Clean up a file enumeration.  This is only called to abandon */
end_comment

begin_comment
comment|/* an enumeration partway through: ...next should do it if there are */
end_comment

begin_comment
comment|/* no more files to enumerate.  This should deallocate the file_enum */
end_comment

begin_comment
comment|/* structure and any subsidiary structures, strings, buffers, etc. */
end_comment

begin_function
name|void
name|gp_enumerate_files_close
parameter_list|(
name|file_enum
modifier|*
name|pfen
parameter_list|)
block|{
name|gp_free_enumeration
argument_list|(
name|pfen
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

