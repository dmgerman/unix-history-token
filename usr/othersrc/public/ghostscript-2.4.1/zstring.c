begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zstring.c */
end_comment

begin_comment
comment|/* String operators for GhostScript */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_comment
comment|/* The generic operators (copy, get, put, getinterval, putinterval, */
end_comment

begin_comment
comment|/* length, and forall) are implemented in zgeneric.c. */
end_comment

begin_comment
comment|/* Imported operators */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|ztoken_file
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string */
end_comment

begin_function
name|int
name|zstring
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|byte
modifier|*
name|sbody
decl_stmt|;
name|uint
name|size
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|<
literal|0
operator|||
call|(
name|ulong
call|)
argument_list|(
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|>
name|max_uint
condition|)
return|return
name|e_rangecheck
return|;
name|size
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|sbody
operator|=
operator|(
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbody
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|make_tasv
argument_list|(
name|op
argument_list|,
name|t_string
argument_list|,
name|a_all
argument_list|,
name|size
argument_list|,
name|bytes
argument_list|,
name|sbody
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sbody
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* anchorsearch */
end_comment

begin_function
name|int
name|zanchorsearch
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|uint
name|size
init|=
name|r_size
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op1
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|r_size
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|op1
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|size
argument_list|)
condition|)
block|{
operator|*
name|op
operator|=
operator|*
name|op1
expr_stmt|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|op1
operator|->
name|value
operator|.
name|bytes
operator|+=
name|size
expr_stmt|;
name|r_inc_size
argument_list|(
name|op1
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* search */
end_comment

begin_function
name|int
name|zsearch
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|uint
name|size
init|=
name|r_size
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|uint
name|count
decl_stmt|;
name|byte
modifier|*
name|ptr
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op1
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|r_size
argument_list|(
name|op1
argument_list|)
condition|)
comment|/* can't match */
block|{
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count
operator|=
name|r_size
argument_list|(
name|op1
argument_list|)
operator|-
name|size
expr_stmt|;
name|ptr
operator|=
name|op1
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|ptr
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|op
operator|->
name|tas
operator|.
name|type_attrs
operator|=
name|op1
operator|->
name|tas
operator|.
name|type_attrs
expr_stmt|;
name|op
operator|->
name|value
operator|.
name|bytes
operator|=
name|ptr
expr_stmt|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|=
operator|*
name|op1
expr_stmt|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|ptr
operator|-
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|)
expr_stmt|;
name|op1
operator|->
name|value
operator|.
name|bytes
operator|=
name|ptr
operator|+
name|size
expr_stmt|;
name|r_set_size
argument_list|(
name|op1
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|--
condition|)
do|;
comment|/* No match */
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* stringmatch */
end_comment

begin_function
name|int
name|zstringmatch
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|int
name|result
decl_stmt|;
name|ref
name|stref
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|t_string
case|:
name|check_read
argument_list|(
operator|*
name|op1
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
operator|&
name|stref
argument_list|,
name|op1
argument_list|)
expr_stmt|;
goto|goto
name|cmp
goto|;
case|case
name|t_name
case|:
name|name_string_ref
argument_list|(
name|op1
argument_list|,
operator|&
name|stref
argument_list|)
expr_stmt|;
name|cmp
label|:
name|result
operator|=
name|string_match
argument_list|(
name|stref
operator|.
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
operator|&
name|stref
argument_list|)
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
operator|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|op
operator|->
name|value
operator|.
name|bytes
operator|==
literal|'*'
operator|)
expr_stmt|;
block|}
name|make_bool
argument_list|(
name|op1
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* token */
end_comment

begin_function
name|int
name|ztoken
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
name|st
decl_stmt|;
name|stream
modifier|*
name|s
init|=
operator|&
name|st
decl_stmt|;
name|int
name|code
decl_stmt|;
name|ref
name|token
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_file
case|:
return|return
name|ztoken_file
argument_list|(
name|op
argument_list|)
return|;
case|case
name|t_string
case|:
empty_stmt|;
block|}
name|check_read
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|sread_string
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
operator|=
name|scan_token
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|&
name|token
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* read a token */
block|{
name|uint
name|pos
init|=
name|stell
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|op
operator|->
name|value
operator|.
name|bytes
operator|+=
name|pos
expr_stmt|;
name|r_inc_size
argument_list|(
name|op
argument_list|,
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
name|push
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|op
index|[
operator|-
literal|1
index|]
operator|=
name|token
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* no tokens */
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
comment|/* error */
return|return
name|code
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zstring_op_defs
index|[]
init|=
block|{
block|{
literal|"2anchorsearch"
block|,
name|zanchorsearch
block|}
block|,
block|{
literal|"2search"
block|,
name|zsearch
block|}
block|,
block|{
literal|"1string"
block|,
name|zstring
block|}
block|,
block|{
literal|"2stringmatch"
block|,
name|zstringmatch
block|}
block|,
block|{
literal|"1token"
block|,
name|ztoken
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

