begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevpcl.c */
end_comment

begin_comment
comment|/* Utilities for PCL printers */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gdevpcl.h"
end_include

begin_comment
comment|/* ------ Color mapping ------ */
end_comment

begin_comment
comment|/* The PaintJet and DeskJet 500C use additive colors in separate planes. */
end_comment

begin_comment
comment|/* We only keep one bit of color, with 1 = R, 2 = G, 4 = B. */
end_comment

begin_comment
comment|/* Because the buffering routines assume 0 = white, */
end_comment

begin_comment
comment|/* we complement all the color components. */
end_comment

begin_define
define|#
directive|define
name|cv_shift
value|(sizeof(gx_color_value) * 8 - 1)
end_define

begin_comment
comment|/* Map an RGB color to a printer color. */
end_comment

begin_function
name|gx_color_index
name|gdev_pcl_3bit_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|b
operator|>>
name|cv_shift
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|g
operator|>>
name|cv_shift
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
name|r
operator|>>
name|cv_shift
operator|)
operator|)
operator|^
literal|7
return|;
block|}
end_function

begin_comment
comment|/* Map the printer color back to RGB. */
end_comment

begin_function
name|int
name|gdev_pcl_3bit_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|ushort
name|cc
init|=
operator|(
name|ushort
operator|)
name|color
operator|^
literal|7
decl_stmt|;
name|prgb
index|[
literal|0
index|]
operator|=
operator|-
operator|(
name|cc
operator|&
literal|1
operator|)
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
operator|-
operator|(
operator|(
name|cc
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|cc
operator|>>
literal|2
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Compression ------ */
end_comment

begin_comment
comment|/*  * Mode 2 Row compression routine for the HP DeskJet& LaserJet IIp.  * Compresses data from row up to end_row, storing the result  * starting at compressed.  Returns the number of bytes stored.  * Runs of K<=127 literal bytes are encoded as K-1 followed by  * the bytes; runs of 2<=K<=127 identical bytes are encoded as  * 257-K followed by the byte.  * In the worst case, the result is N+(N/127)+1 bytes long,  * where N is the original byte count (end_row - row).  * To speed up the search, we examine an entire word at a time.  * We will miss a few blocks of identical bytes; tant pis.  */
end_comment

begin_function
name|int
name|gdev_pcl_mode2compress
parameter_list|(
specifier|const
name|word
modifier|*
name|row
parameter_list|,
specifier|const
name|word
modifier|*
name|end_row
parameter_list|,
name|char
modifier|*
name|compressed
parameter_list|)
block|{
specifier|register
specifier|const
name|word
modifier|*
name|exam
init|=
name|row
decl_stmt|;
comment|/* word being examined in the row to compress */
specifier|register
name|char
modifier|*
name|cptr
init|=
name|compressed
decl_stmt|;
comment|/* output pointer into compressed bytes */
while|while
condition|(
name|exam
operator|<
name|end_row
condition|)
block|{
comment|/* Search ahead in the input looking for a run */
comment|/* of at least 4 identical bytes. */
specifier|const
name|char
modifier|*
name|compr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|exam
decl_stmt|;
specifier|const
name|char
modifier|*
name|end_dis
decl_stmt|;
specifier|const
name|word
modifier|*
name|next
decl_stmt|;
specifier|register
name|word
name|test
decl_stmt|;
while|while
condition|(
name|exam
operator|<
name|end_row
condition|)
block|{
name|test
operator|=
operator|*
name|exam
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|test
operator|<<
literal|8
operator|)
operator|^
name|test
operator|)
operator|<=
literal|0xff
condition|)
break|break;
name|exam
operator|++
expr_stmt|;
block|}
comment|/* Find out how long the run is */
name|end_dis
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|exam
expr_stmt|;
if|if
condition|(
name|exam
operator|==
name|end_row
condition|)
comment|/* no run */
block|{
comment|/* See if any of the last 3 "dissimilar" bytes are 0. */
if|if
condition|(
name|end_dis
operator|>
name|compr
operator|&&
name|end_dis
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|end_dis
index|[
operator|-
literal|2
index|]
operator|!=
literal|0
condition|)
name|end_dis
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|end_dis
index|[
operator|-
literal|3
index|]
operator|!=
literal|0
condition|)
name|end_dis
operator|-=
literal|2
expr_stmt|;
else|else
name|end_dis
operator|-=
literal|3
expr_stmt|;
block|}
name|next
operator|=
operator|--
name|end_row
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|exam
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|end_row
operator|&&
operator|*
name|next
operator|==
name|test
condition|)
name|next
operator|++
expr_stmt|;
comment|/* See if any of the last 3 "dissimilar" bytes */
comment|/* are the same as the repeated byte. */
if|if
condition|(
name|end_dis
operator|>
name|compr
operator|&&
name|end_dis
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|byte
operator|)
name|test
condition|)
block|{
if|if
condition|(
name|end_dis
index|[
operator|-
literal|2
index|]
operator|!=
operator|(
name|byte
operator|)
name|test
condition|)
name|end_dis
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|end_dis
index|[
operator|-
literal|3
index|]
operator|!=
operator|(
name|byte
operator|)
name|test
condition|)
name|end_dis
operator|-=
literal|2
expr_stmt|;
else|else
name|end_dis
operator|-=
literal|3
expr_stmt|;
block|}
block|}
comment|/* Now [compr..end_dis) should be encoded as dissimilar, */
comment|/* and [end_dis..next) should be encoded as similar. */
comment|/* Note that either of these ranges may be empty. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Encode up to 127 dissimilar bytes */
name|uint
name|count
init|=
name|end_dis
operator|-
name|compr
decl_stmt|;
comment|/* uint for faster switch */
switch|switch
condition|(
name|count
condition|)
block|{
comment|/* Use memcpy only if it's worthwhile. */
case|case
literal|6
case|:
name|cptr
index|[
literal|6
index|]
operator|=
name|compr
index|[
literal|5
index|]
expr_stmt|;
case|case
literal|5
case|:
name|cptr
index|[
literal|5
index|]
operator|=
name|compr
index|[
literal|4
index|]
expr_stmt|;
case|case
literal|4
case|:
name|cptr
index|[
literal|4
index|]
operator|=
name|compr
index|[
literal|3
index|]
expr_stmt|;
case|case
literal|3
case|:
name|cptr
index|[
literal|3
index|]
operator|=
name|compr
index|[
literal|2
index|]
expr_stmt|;
case|case
literal|2
case|:
name|cptr
index|[
literal|2
index|]
operator|=
name|compr
index|[
literal|1
index|]
expr_stmt|;
case|case
literal|1
case|:
name|cptr
index|[
literal|1
index|]
operator|=
name|compr
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|cptr
operator|=
name|count
operator|-
literal|1
expr_stmt|;
name|cptr
operator|+=
name|count
operator|+
literal|1
expr_stmt|;
case|case
literal|0
case|:
comment|/* all done */
break|break;
default|default:
if|if
condition|(
name|count
operator|>
literal|127
condition|)
name|count
operator|=
literal|127
expr_stmt|;
operator|*
name|cptr
operator|++
operator|=
name|count
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|cptr
argument_list|,
name|compr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|cptr
operator|+=
name|count
operator|,
name|compr
operator|+=
name|count
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|{
comment|/* Encode up to 127 similar bytes. */
comment|/* Note that count may be<0 at end of row. */
name|int
name|count
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|next
operator|-
name|end_dis
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|this
init|=
operator|(
name|count
operator|>
literal|127
condition|?
literal|127
else|:
name|count
operator|)
decl_stmt|;
operator|*
name|cptr
operator|++
operator|=
literal|257
operator|-
name|this
expr_stmt|;
operator|*
name|cptr
operator|++
operator|=
operator|(
name|byte
operator|)
name|test
expr_stmt|;
name|count
operator|-=
name|this
expr_stmt|;
block|}
name|exam
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|cptr
operator|-
name|compressed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mode 3 compression routine for the HP LaserJet III family.  * Compresses bytecount bytes starting at current, storing the result  * in compressed, comparing against and updating previous.  * Returns the number of bytes stored.  In the worst case,  * the number of bytes is bytecount+(bytecount/8)+1.  */
end_comment

begin_function
name|int
name|gdev_pcl_mode3compress
parameter_list|(
name|int
name|bytecount
parameter_list|,
specifier|const
name|char
modifier|*
name|current
parameter_list|,
name|char
modifier|*
name|previous
parameter_list|,
name|char
modifier|*
name|compressed
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cur
init|=
name|current
decl_stmt|;
specifier|register
name|char
modifier|*
name|prev
init|=
name|previous
decl_stmt|;
specifier|register
name|char
modifier|*
name|out
init|=
name|compressed
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|current
operator|+
name|bytecount
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|end
condition|)
block|{
comment|/* Detect a maximum run of unchanged bytes. */
specifier|const
name|char
modifier|*
name|run
init|=
name|cur
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|diff
decl_stmt|;
specifier|const
name|char
modifier|*
name|stop
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|cbyte
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|end
operator|&&
operator|*
name|cur
operator|==
operator|*
name|prev
condition|)
block|{
name|cur
operator|++
operator|,
name|prev
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|==
name|end
condition|)
break|break;
comment|/* rest of row is unchanged */
comment|/* Detect a run of up to 8 changed bytes. */
comment|/* We know that *cur != *prev. */
name|diff
operator|=
name|cur
expr_stmt|;
name|stop
operator|=
operator|(
name|end
operator|-
name|cur
operator|>
literal|8
condition|?
name|cur
operator|+
literal|8
else|:
name|end
operator|)
expr_stmt|;
do|do
block|{
operator|*
name|prev
operator|++
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|cur
operator|<
name|stop
operator|&&
operator|*
name|cur
operator|!=
operator|*
name|prev
condition|)
do|;
comment|/* Now [run..diff) are unchanged, and */
comment|/* [diff..cur) are changed. */
comment|/* Generate the command byte(s). */
name|offset
operator|=
name|diff
operator|-
name|run
expr_stmt|;
name|cbyte
operator|=
operator|(
name|cur
operator|-
name|diff
operator|-
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|31
condition|)
operator|*
name|out
operator|++
operator|=
name|cbyte
operator|+
name|offset
expr_stmt|;
else|else
block|{
operator|*
name|out
operator|++
operator|=
name|cbyte
operator|+
literal|31
expr_stmt|;
name|offset
operator|-=
literal|31
expr_stmt|;
while|while
condition|(
name|offset
operator|>=
literal|255
condition|)
operator|*
name|out
operator|++
operator|=
literal|255
operator|,
name|offset
operator|-=
literal|255
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|offset
expr_stmt|;
block|}
comment|/* Copy the changed data. */
while|while
condition|(
name|diff
operator|<
name|cur
condition|)
operator|*
name|out
operator|++
operator|=
operator|*
name|diff
operator|++
expr_stmt|;
block|}
return|return
name|out
operator|-
name|compressed
return|;
block|}
end_function

end_unit

