begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsmain.c */
end_comment

begin_comment
comment|/* Framework for Ghostscript drivers */
end_comment

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_comment
comment|/* for gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/*  * This routine provides the following standard services for parsing  * a command line:  *	- setting debug flags (-A, -e, -E switches; -Z switch if debugging);  *	- passing other arguments and switches back to the caller.  *  * Calling convention:  *	gs_main(argc, argv, switch_proc, arg_proc)  * Calls  *	switch_proc(&switch, rest_of_arg) for switches,  *	arg_proc(&arg, index) for non-switch args.  * If switch_proc returns a negative value, gs_main prints an  *   "unknown switch" error message and aborts.  * gs_main returns the number of non-switch args handed to arg_proc.  */
end_comment

begin_comment
comment|/* Imported data */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|gs_alloc_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gs_log_errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|gx_device
modifier|*
name|gx_device_list
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|gs_exit
argument_list|(
name|P1
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gs_main
argument_list|(
name|int
name|argc
argument_list|,
name|char
operator|*
name|argv
index|[]
argument_list|,
name|int
argument_list|(
operator|*
name|switch_proc
argument_list|)
argument_list|(
name|P2
argument_list|(
name|char
operator|*
operator|*
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|void
argument_list|(
operator|*
name|arg_proc
argument_list|)
argument_list|(
name|P2
argument_list|(
name|char
operator|*
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|)
block|{
name|int
name|argi
init|=
literal|1
decl_stmt|;
name|int
name|arg_count
init|=
literal|0
decl_stmt|;
name|gs_log_errors
operator|=
literal|0
expr_stmt|;
name|gs_out
operator|=
name|stdout
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|gs_debug_out
operator|=
name|stdout
expr_stmt|;
comment|/* Reset debugging flags */
name|memset
argument_list|(
name|gs_debug
argument_list|,
literal|0
argument_list|,
literal|128
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If debugging is enabled, trace the device calls. */
ifdef|#
directive|ifdef
name|DEBUG
block|{
specifier|extern
name|gx_device
modifier|*
name|gs_trace_device
argument_list|(
name|P1
argument_list|(
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|extern
name|gx_device_memory
name|mem_mono_device
decl_stmt|,
name|mem_mapped8_color_device
decl_stmt|,
name|mem_true24_color_device
decl_stmt|,
name|mem_true32_color_device
decl_stmt|;
specifier|static
name|gx_device_memory
modifier|*
name|mdevs
index|[
literal|5
index|]
init|=
block|{
operator|&
name|mem_mono_device
block|,
operator|&
name|mem_mapped8_color_device
block|,
operator|&
name|mem_true24_color_device
block|,
operator|&
name|mem_true32_color_device
block|,
literal|0
block|}
decl_stmt|;
specifier|extern
name|gx_device
name|gs_clist_device
decl_stmt|;
comment|/* gx_clist_device */
specifier|static
name|gx_device
modifier|*
name|cldevs
index|[
literal|2
index|]
init|=
block|{
operator|&
name|gs_clist_device
block|,
literal|0
block|}
decl_stmt|;
name|gx_device
modifier|*
modifier|*
name|pdevs
index|[
literal|4
index|]
decl_stmt|;
name|gx_device
modifier|*
modifier|*
modifier|*
name|ppdev
decl_stmt|;
name|gx_device
modifier|*
modifier|*
name|pdev
decl_stmt|;
name|pdevs
index|[
literal|0
index|]
operator|=
name|gx_device_list
expr_stmt|;
name|pdevs
index|[
literal|1
index|]
operator|=
operator|(
name|gx_device
operator|*
operator|*
operator|)
name|mdevs
expr_stmt|;
name|pdevs
index|[
literal|2
index|]
operator|=
name|cldevs
expr_stmt|;
name|pdevs
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/****** 		for ( ppdev = pdevs; *ppdev != 0; ppdev++ ) 		 for ( pdev = *ppdev; *pdev != 0; pdev++ ) 		   {	gx_device *tdev = gs_trace_device(*pdev); 			if ( tdev == 0 ) 			   {	lprintf("Can't allocate traced device!\n"); 				gs_exit(1); 			   } 			*pdev = tdev; 		   }  ******/
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|argi
operator|<
name|argc
condition|;
name|argi
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|argp
init|=
operator|&
name|argv
index|[
name|argi
index|]
decl_stmt|;
name|char
modifier|*
name|arg
init|=
operator|*
name|argp
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|arg
condition|)
block|{
default|default:
if|if
condition|(
call|(
modifier|*
name|switch_proc
call|)
argument_list|(
name|argp
argument_list|,
name|arg
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Unknown switch %s - ignoring\n"
argument_list|,
name|arg
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|gs_alloc_debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|gs_log_errors
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|gs_log_errors
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|arg
index|[
literal|1
index|]
condition|)
block|{
comment|/* No options, set all flags */
name|memset
argument_list|(
name|gs_debug
argument_list|,
literal|0xff
argument_list|,
literal|128
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
operator|++
name|arg
condition|)
name|gs_debug
index|[
operator|*
name|arg
operator|&
literal|127
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"Not a debugging configuration, -Z switch ignored\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
else|else
call|(
modifier|*
name|arg_proc
call|)
argument_list|(
name|argp
argument_list|,
name|arg_count
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|arg_count
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Free all resources and exit. */
end_comment

begin_decl_stmt
name|void
name|gs_malloc_release
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|file_close_all
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gs_closedevice
argument_list|(
name|P1
argument_list|(
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|gp_exit
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|gs_exit
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|gx_device
modifier|*
modifier|*
name|pdev
init|=
name|gx_device_list
decl_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* in case of error exit */
for|for
control|(
init|;
operator|*
name|pdev
operator|!=
literal|0
condition|;
name|pdev
operator|++
control|)
name|gs_closedevice
argument_list|(
operator|*
name|pdev
argument_list|)
expr_stmt|;
comment|/* Close all open files. */
name|file_close_all
argument_list|()
expr_stmt|;
comment|/* Release all memory acquired with malloc. */
name|gs_malloc_release
argument_list|()
expr_stmt|;
comment|/* Do platform-specific cleanup. */
name|gp_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Debugging routines ------ */
end_comment

begin_comment
comment|/* Log an error return */
end_comment

begin_function
name|int
name|gs_log_error
parameter_list|(
name|int
name|err
parameter_list|,
specifier|const
name|char
name|_ds
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|gs_log_errors
condition|)
block|{
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|dprintf1
argument_list|(
literal|"Returning error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
else|else
name|dprintf3
argument_list|(
literal|"%s(%d): returning error %d\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|line
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

end_unit

