begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevpcx.c */
end_comment

begin_comment
comment|/* PCX file format devices for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_comment
comment|/* REALLY? */
end_comment

begin_include
include|#
directive|include
file|"gdevpccm.h"
end_include

begin_comment
comment|/* Thanks to Phil Conrad for donating the original version */
end_comment

begin_comment
comment|/* of these drivers to Aladdin Enterprises. */
end_comment

begin_comment
comment|/* ------ The device descriptors ------ */
end_comment

begin_comment
comment|/*  * Standard U.S. page width and height.  A4 paper is 8.4" x 11.7".  */
end_comment

begin_define
define|#
directive|define
name|WIDTH_10THS
value|85
end_define

begin_define
define|#
directive|define
name|HEIGHT_10THS
value|110
end_define

begin_comment
comment|/*  * Default X and Y resolution.  */
end_comment

begin_define
define|#
directive|define
name|X_DPI
value|72
end_define

begin_define
define|#
directive|define
name|Y_DPI
value|72
end_define

begin_comment
comment|/* Monochrome. */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|pcxmono_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|gx_device_printer
name|gs_pcxmono_device
init|=
name|prn_device
argument_list|(
name|prn_std_procs
argument_list|,
literal|"pcxmono"
argument_list|,
name|WIDTH_10THS
argument_list|,
name|HEIGHT_10THS
argument_list|,
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|1
argument_list|,
name|pcxmono_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 4-bit planar (EGA/VGA-style) color. */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|pcx16_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|pcx16_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|pc_4bit_map_rgb_color
argument_list|,
name|pc_4bit_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_printer
name|gs_pcx16_device
init|=
name|prn_device
argument_list|(
name|pcx16_procs
argument_list|,
literal|"pcx16"
argument_list|,
name|WIDTH_10THS
argument_list|,
name|HEIGHT_10THS
argument_list|,
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|4
argument_list|,
name|pcx16_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chunky 8-bit (SuperVGA-style) color. */
end_comment

begin_comment
comment|/* (Uses a fixed palette of 3,3,2 bits.) */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|pcx256_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|pcx256_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|pc_8bit_map_rgb_color
argument_list|,
name|pc_8bit_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_printer
name|gs_pcx256_device
init|=
name|prn_device
argument_list|(
name|pcx256_procs
argument_list|,
literal|"pcx256"
argument_list|,
name|WIDTH_10THS
argument_list|,
name|HEIGHT_10THS
argument_list|,
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|8
argument_list|,
name|pcx256_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Private definitions ------ */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pcx_header_s
block|{
name|byte
name|manuf
decl_stmt|;
comment|/* always 0x0a */
name|byte
name|version
decl_stmt|;
comment|/* version info = 0,2,3,5 */
name|byte
name|encoding
decl_stmt|;
comment|/* 1=RLE */
name|byte
name|bpp
decl_stmt|;
comment|/* bits per pixel */
name|ushort
name|x1
decl_stmt|;
comment|/* picture dimensions */
name|ushort
name|y1
decl_stmt|;
name|ushort
name|x2
decl_stmt|;
name|ushort
name|y2
decl_stmt|;
name|ushort
name|hres
decl_stmt|;
comment|/* horz. resolution */
name|ushort
name|vres
decl_stmt|;
comment|/* vert. resolution */
name|byte
name|palette
index|[
literal|16
operator|*
literal|3
index|]
decl_stmt|;
comment|/* color palette */
name|byte
name|vmode
decl_stmt|;
comment|/* video mode for graphics board */
name|byte
name|nplanes
decl_stmt|;
comment|/* number of color planes */
name|ushort
name|bpl
decl_stmt|;
comment|/* number of bytes per line (uncompresses) */
name|ushort
name|palinfo
decl_stmt|;
comment|/* palette info 1=color, 2=grey */
name|ushort
name|shres
decl_stmt|;
comment|/* scanner horz. resolution */
name|ushort
name|svres
decl_stmt|;
comment|/* scanner vert. resolution */
name|byte
name|xtra
index|[
literal|58
index|]
decl_stmt|;
comment|/* fill out header to 128 bytes */
block|}
name|pcx_header
typedef|;
end_typedef

begin_comment
comment|/*  ** version info for PCX is as follows  ** ** 0 == 2.5 ** 2 == 2.8 w/palette info ** 3 == 2.8 without palette info ** 5 == 3.0 ** */
end_comment

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|private
name|void
name|pcx_write_rle
argument_list|(
name|P3
argument_list|(
name|byte
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|FILE
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|pcx_write_page
argument_list|(
name|P4
argument_list|(
argument|gx_device_printer *
argument_list|,
argument|FILE *
argument_list|,
argument|pcx_header _ss *
argument_list|,
argument|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write an "old" PCX page. */
end_comment

begin_decl_stmt
specifier|static
name|byte
name|ega_palette
index|[
literal|16
operator|*
literal|3
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xaa
block|,
literal|0x00
block|,
literal|0xaa
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xaa
block|,
literal|0x00
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0x00
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0xff
block|,
literal|0x55
block|,
literal|0xff
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0xff
block|,
literal|0x55
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x55
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|pcx16_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|pcx_header
name|header
decl_stmt|;
name|header
operator|.
name|version
operator|=
literal|2
expr_stmt|;
name|header
operator|.
name|bpp
operator|=
literal|1
expr_stmt|;
name|header
operator|.
name|nplanes
operator|=
literal|4
expr_stmt|;
comment|/* Fill the EGA palette appropriately. */
name|memcpy
argument_list|(
operator|(
name|byte
operator|*
operator|)
name|header
operator|.
name|palette
argument_list|,
name|ega_palette
argument_list|,
sizeof|sizeof
argument_list|(
name|ega_palette
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pcx_write_page
argument_list|(
name|pdev
argument_list|,
name|file
argument_list|,
operator|&
name|header
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a "new" PCX page. */
end_comment

begin_function
name|private
name|int
name|pcx256_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|pcx_header
name|header
decl_stmt|;
name|int
name|code
decl_stmt|;
name|header
operator|.
name|version
operator|=
literal|5
expr_stmt|;
name|header
operator|.
name|bpp
operator|=
literal|8
expr_stmt|;
name|header
operator|.
name|nplanes
operator|=
literal|1
expr_stmt|;
comment|/* Clear the EGA palette */
name|memset
argument_list|(
operator|(
name|byte
operator|*
operator|)
name|header
operator|.
name|palette
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|.
name|palette
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|pcx_write_page
argument_list|(
name|pdev
argument_list|,
name|file
argument_list|,
operator|&
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
comment|/* Write out the palette. */
name|fputc
argument_list|(
literal|0x0c
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|code
operator|=
name|pc_write_palette
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|,
literal|256
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Write a monochrome PCX page. */
end_comment

begin_function
name|private
name|int
name|pcxmono_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|pcx_header
name|header
decl_stmt|;
name|header
operator|.
name|version
operator|=
literal|2
expr_stmt|;
name|header
operator|.
name|bpp
operator|=
literal|1
expr_stmt|;
name|header
operator|.
name|nplanes
operator|=
literal|1
expr_stmt|;
comment|/* Clear the EGA palette */
name|memset
argument_list|(
operator|(
name|byte
operator|*
operator|)
name|header
operator|.
name|palette
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|.
name|palette
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pcx_write_page
argument_list|(
name|pdev
argument_list|,
name|file
argument_list|,
operator|&
name|header
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out a page in PCX format. */
end_comment

begin_comment
comment|/* This routine is used for all three formats (monochrome, planar */
end_comment

begin_comment
comment|/* "8-bit" actually 4-bit color, and chunky 8-bit color.) */
end_comment

begin_function
name|private
name|int
name|pcx_write_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|pcx_header
name|_ss
modifier|*
name|phdr
parameter_list|,
name|int
name|planar
parameter_list|)
block|{
name|int
name|raster
init|=
name|gdev_prn_bytes_per_scan_line
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
decl_stmt|;
name|int
name|depth
init|=
name|pdev
operator|->
name|color_info
operator|.
name|depth
decl_stmt|;
name|uint
name|rsize
init|=
operator|(
name|pdev
operator|->
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
name|byte
modifier|*
name|row
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|raster
operator|+
name|rsize
argument_list|,
literal|1
argument_list|,
literal|"pcx file buffer"
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|end
init|=
name|row
operator|+
name|raster
decl_stmt|;
name|byte
modifier|*
name|plane
init|=
name|end
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
comment|/* return code */
if|if
condition|(
name|row
operator|==
literal|0
condition|)
comment|/* can't allocate row buffer */
return|return
name|gs_error_VMerror
return|;
comment|/* setup the header struct */
name|phdr
operator|->
name|manuf
operator|=
literal|10
expr_stmt|;
comment|/* version and bpp were set by the caller */
name|phdr
operator|->
name|encoding
operator|=
literal|1
expr_stmt|;
comment|/* 1 for rle 8-bit encoding */
name|phdr
operator|->
name|x1
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|y1
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|x2
operator|=
name|pdev
operator|->
name|width
operator|-
literal|1
expr_stmt|;
name|phdr
operator|->
name|y2
operator|=
name|height
operator|-
literal|1
expr_stmt|;
name|phdr
operator|->
name|hres
operator|=
operator|(
name|int
operator|)
name|pdev
operator|->
name|x_pixels_per_inch
expr_stmt|;
name|phdr
operator|->
name|vres
operator|=
operator|(
name|int
operator|)
name|pdev
operator|->
name|y_pixels_per_inch
expr_stmt|;
name|phdr
operator|->
name|vmode
operator|=
literal|0
expr_stmt|;
comment|/* nplanes was set by the caller */
name|phdr
operator|->
name|bpl
operator|=
operator|(
name|planar
operator|&&
name|depth
operator|>
literal|1
condition|?
name|rsize
else|:
name|raster
operator|)
expr_stmt|;
name|phdr
operator|->
name|palinfo
operator|=
operator|(
name|gx_device_has_color
argument_list|(
name|pdev
argument_list|)
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
comment|/* Write the header. */
if|if
condition|(
name|fwrite
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|phdr
argument_list|,
literal|1
argument_list|,
literal|128
argument_list|,
name|file
argument_list|)
operator|<
literal|128
condition|)
block|{
name|code
operator|=
name|gs_error_ioerror
expr_stmt|;
goto|goto
name|pcx_done
goto|;
block|}
comment|/* Dump the contents of the image. */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|y
argument_list|,
name|row
argument_list|,
name|raster
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
literal|1
case|:
block|{
comment|/* PCX assumes 0=black, 1=white. */
specifier|register
name|byte
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|row
init|;
name|bp
operator|<
name|end
condition|;
name|bp
operator|++
control|)
operator|*
name|bp
operator|=
operator|~
operator|*
name|bp
expr_stmt|;
name|pcx_write_rle
argument_list|(
name|row
argument_list|,
name|end
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|8
case|:
block|{
specifier|register
name|int
name|shift
decl_stmt|;
if|if
condition|(
operator|!
name|gx_device_has_color
argument_list|(
name|pdev
argument_list|)
condition|)
block|{
comment|/* Can't map gray scale */
name|code
operator|=
name|gs_error_undefinedresult
expr_stmt|;
goto|goto
name|pcx_done
goto|;
block|}
if|if
condition|(
operator|!
name|planar
condition|)
block|{
comment|/* Just write the bits */
name|pcx_write_rle
argument_list|(
name|row
argument_list|,
name|end
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|shift
operator|=
literal|0
init|;
name|shift
operator|<
literal|4
condition|;
name|shift
operator|++
control|)
block|{
specifier|register
name|byte
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|bmask
init|=
literal|1
operator|<<
name|shift
decl_stmt|;
for|for
control|(
name|from
operator|=
name|row
operator|,
name|to
operator|=
name|plane
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
literal|8
control|)
block|{
operator|*
name|to
operator|++
operator|=
operator|(
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|0
index|]
operator|&
name|bmask
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|1
index|]
operator|&
name|bmask
operator|)
operator|<<
literal|6
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|2
index|]
operator|&
name|bmask
operator|)
operator|<<
literal|5
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|3
index|]
operator|&
name|bmask
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|4
index|]
operator|&
name|bmask
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|5
index|]
operator|&
name|bmask
operator|)
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|6
index|]
operator|&
name|bmask
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|from
index|[
literal|7
index|]
operator|&
name|bmask
operator|)
operator|)
operator|)
operator|>>
name|shift
expr_stmt|;
block|}
name|pcx_write_rle
argument_list|(
name|plane
argument_list|,
name|to
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|code
operator|=
name|gs_error_undefinedresult
expr_stmt|;
goto|goto
name|pcx_done
goto|;
block|}
block|}
name|pcx_done
label|:
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|row
argument_list|,
name|raster
operator|+
name|rsize
argument_list|,
literal|1
argument_list|,
literal|"pcx file buffer"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Write one line in PCX run-length-encoded format. */
end_comment

begin_function
name|private
name|void
name|pcx_write_rle
parameter_list|(
name|byte
modifier|*
name|from
parameter_list|,
name|byte
modifier|*
name|end
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
while|while
condition|(
name|from
operator|<
name|end
condition|)
block|{
name|byte
name|data
init|=
operator|*
name|from
operator|++
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|from
operator|<
name|end
operator|)
operator|&&
operator|(
operator|*
name|from
operator|==
name|data
operator|)
condition|)
name|count
operator|++
operator|,
name|from
operator|++
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|63
condition|)
block|{
name|putc
argument_list|(
literal|0xff
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|data
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|count
operator|-=
literal|63
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|1
operator|||
name|data
operator|>=
literal|0xc0
condition|)
block|{
name|putc
argument_list|(
name|count
operator||
literal|0xc0
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|data
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

