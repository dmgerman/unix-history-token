begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gp_msdos.c */
end_comment

begin_comment
comment|/* Common platform-specific routines for MS-DOS (any compiler) */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"dos_.h"
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_comment
comment|/* ------ Date and time ------ */
end_comment

begin_comment
comment|/* Read the current date (in days since Jan. 1, 1980) */
end_comment

begin_comment
comment|/* and time (in milliseconds since midnight). */
end_comment

begin_function
name|void
name|gp_get_clock
parameter_list|(
name|long
modifier|*
name|pdt
parameter_list|)
block|{
name|union
name|REGS
name|osdate
decl_stmt|,
name|ostime
decl_stmt|;
name|long
name|idate
decl_stmt|;
specifier|static
name|int
name|mstart
index|[
literal|12
index|]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|}
decl_stmt|;
name|osdate
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x2a
expr_stmt|;
comment|/* get date */
name|intdos
argument_list|(
operator|&
name|osdate
argument_list|,
operator|&
name|osdate
argument_list|)
expr_stmt|;
define|#
directive|define
name|da_year
value|rshort.cx
define|#
directive|define
name|da_mon
value|h.dh
define|#
directive|define
name|da_day
value|h.dl
name|ostime
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x2c
expr_stmt|;
comment|/* get time */
name|intdos
argument_list|(
operator|&
name|ostime
argument_list|,
operator|&
name|ostime
argument_list|)
expr_stmt|;
define|#
directive|define
name|ti_hour
value|h.ch
define|#
directive|define
name|ti_min
value|h.cl
define|#
directive|define
name|ti_sec
value|h.dh
define|#
directive|define
name|ti_hund
value|h.dl
name|idate
operator|=
operator|(
name|long
operator|)
name|osdate
operator|.
name|da_year
operator|*
literal|365
operator|+
operator|(
name|osdate
operator|.
name|da_year
operator|/
literal|4
operator|+
literal|1
operator|+
comment|/* account for leap years */
name|mstart
index|[
name|osdate
operator|.
name|da_mon
operator|-
literal|1
index|]
operator|+
comment|/* month is 1-origin */
name|osdate
operator|.
name|da_day
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* day of month is 1-origin */
if|if
condition|(
name|osdate
operator|.
name|da_mon
operator|<=
literal|2
operator|&&
name|osdate
operator|.
name|da_year
operator|%
literal|4
operator|==
literal|0
condition|)
comment|/* Jan. or Feb. of leap year */
name|idate
operator|--
expr_stmt|;
name|pdt
index|[
literal|0
index|]
operator|=
name|idate
expr_stmt|;
name|pdt
index|[
literal|1
index|]
operator|=
operator|(
name|ostime
operator|.
name|ti_hour
operator|*
literal|60
operator|+
name|ostime
operator|.
name|ti_min
operator|)
operator|*
literal|60000L
operator|+
operator|(
name|ostime
operator|.
name|ti_sec
operator|*
literal|100
operator|+
name|ostime
operator|.
name|ti_hund
operator|)
operator|*
literal|10L
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Printer accessing ------ */
end_comment

begin_comment
comment|/* Put the printer into binary mode.  This is not a standard gp procedure, */
end_comment

begin_comment
comment|/* but all MS-DOS configurations need it. */
end_comment

begin_function
name|void
name|gp_set_printer_binary
parameter_list|(
name|int
name|prnfno
parameter_list|)
block|{
name|union
name|REGS
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x44
expr_stmt|;
comment|/* ioctl */
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0
expr_stmt|;
comment|/* get device info */
name|regs
operator|.
name|rshort
operator|.
name|bx
operator|=
name|prnfno
expr_stmt|;
name|intdos
argument_list|(
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|dl
operator||=
literal|0x20
expr_stmt|;
comment|/* binary (no ^Z intervention) */
name|regs
operator|.
name|h
operator|.
name|dh
operator|=
literal|0
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x44
expr_stmt|;
comment|/* ioctl */
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|1
expr_stmt|;
comment|/* set device info */
name|intdos
argument_list|(
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ File names ------ */
end_comment

begin_comment
comment|/* Define the character used for separating file names in a list. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|gp_file_name_list_separator
init|=
literal|';'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the default scratch file name prefix. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|gp_scratch_file_name_prefix
index|[]
init|=
literal|"_temp_"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define whether case is insignificant in file names. */
end_comment

begin_decl_stmt
specifier|const
name|int
name|gp_file_names_ignore_case
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Answer whether a file name contains a directory/device specification, */
end_comment

begin_comment
comment|/* i.e. is absolute (not directory- or device-relative). */
end_comment

begin_function
name|int
name|gp_file_name_is_absolute
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
comment|/* A file name is absolute if it contains a drive specification */
comment|/* (second character is a :) or if it start with / or \. */
return|return
operator|(
name|len
operator|>=
literal|1
operator|&&
operator|(
operator|*
name|fname
operator|==
literal|'/'
operator|||
operator|*
name|fname
operator|==
literal|'\\'
operator|||
operator|(
name|len
operator|>=
literal|2
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Answer the string to be used for combining a directory/device prefix */
end_comment

begin_comment
comment|/* with a base file name.  The file name is known to not be absolute. */
end_comment

begin_function
name|char
modifier|*
name|gp_file_name_concat_string
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|uint
name|plen
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
switch|switch
condition|(
name|prefix
index|[
name|plen
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|':'
case|:
case|case
literal|'/'
case|:
case|case
literal|'\\'
case|:
return|return
literal|""
return|;
block|}
empty_stmt|;
return|return
literal|"\\"
return|;
block|}
end_function

begin_comment
comment|/* ------ File enumeration ------ */
end_comment

begin_struct
struct|struct
name|file_enum_s
block|{
name|ff_struct_t
name|ffblk
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|patlen
decl_stmt|;
comment|/* allocated length of pattern */
name|int
name|head_size
decl_stmt|;
comment|/* pattern length through last */
comment|/* : or \ */
name|int
name|first_time
decl_stmt|;
name|gs_memory_procs
name|mprocs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize an enumeration.  Note that * and ? in a directory */
end_comment

begin_comment
comment|/* don't work, and \* and \? don't work. */
end_comment

begin_function
name|file_enum
modifier|*
name|gp_enumerate_files_init
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|uint
name|patlen
parameter_list|,
name|proc_alloc_t
name|palloc
parameter_list|,
name|proc_free_t
name|pfree
parameter_list|)
block|{
name|file_enum
modifier|*
name|pfen
init|=
operator|(
name|file_enum
operator|*
operator|)
call|(
modifier|*
name|palloc
call|)
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|file_enum
argument_list|)
argument_list|,
literal|"gp_enumerate_files"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|hsize
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pfen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|pattern
operator|=
call|(
modifier|*
name|palloc
call|)
argument_list|(
name|patlen
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"gp_enumerate_files(pattern)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|pattern
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patlen
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pat
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* Skip to . or end of string so DOS can do it. */
operator|*
name|p
operator|++
operator|=
literal|'*'
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|patlen
operator|&&
name|pat
index|[
name|i
index|]
operator|!=
literal|'.'
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|pat
index|[
name|i
index|]
operator|!=
literal|'\\'
operator|&&
name|pat
index|[
name|i
index|]
operator|!=
literal|'/'
operator|&&
name|pat
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
break|break;
comment|/* falls through */
case|case
literal|':'
case|:
case|case
literal|'/'
case|:
name|hsize
operator|=
name|p
operator|+
literal|1
operator|-
name|pattern
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|pat
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|pfen
operator|->
name|pattern
operator|=
name|pattern
expr_stmt|;
name|pfen
operator|->
name|patlen
operator|=
name|patlen
expr_stmt|;
name|pfen
operator|->
name|head_size
operator|=
name|hsize
expr_stmt|;
name|pfen
operator|->
name|mprocs
operator|.
name|alloc
operator|=
name|palloc
expr_stmt|;
name|pfen
operator|->
name|mprocs
operator|.
name|free
operator|=
name|pfree
expr_stmt|;
name|pfen
operator|->
name|first_time
operator|=
literal|1
expr_stmt|;
return|return
name|pfen
return|;
block|}
end_function

begin_comment
comment|/* Enumerate the next file. */
end_comment

begin_function
name|uint
name|gp_enumerate_files_next
parameter_list|(
name|file_enum
modifier|*
name|pfen
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|uint
name|maxlen
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|pfen
operator|->
name|first_time
condition|)
block|{
name|code
operator|=
name|dos_findfirst
argument_list|(
name|pfen
operator|->
name|pattern
argument_list|,
operator|&
name|pfen
operator|->
name|ffblk
argument_list|)
expr_stmt|;
name|pfen
operator|->
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|code
operator|=
name|dos_findnext
argument_list|(
operator|&
name|pfen
operator|->
name|ffblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
block|{
comment|/* All done, clean up. */
name|gp_enumerate_files_close
argument_list|(
name|pfen
argument_list|)
expr_stmt|;
return|return
operator|~
operator|(
name|uint
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|maxlen
operator|<
literal|13
operator|+
name|pfen
operator|->
name|head_size
condition|)
return|return
name|maxlen
operator|+
literal|1
return|;
comment|/* cop out! */
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|pfen
operator|->
name|pattern
argument_list|,
name|pfen
operator|->
name|head_size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|pfen
operator|->
name|ffblk
operator|.
name|ff_name
index|[
literal|0
index|]
operator|,
name|q
operator|=
name|ptr
operator|+
name|pfen
operator|->
name|head_size
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
return|return
name|q
operator|-
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Clean up the file enumeration. */
end_comment

begin_function
name|void
name|gp_enumerate_files_close
parameter_list|(
name|file_enum
modifier|*
name|pfen
parameter_list|)
block|{
name|proc_free_t
name|pfree
init|=
name|pfen
operator|->
name|mprocs
operator|.
name|free
decl_stmt|;
call|(
modifier|*
name|pfree
call|)
argument_list|(
name|pfen
operator|->
name|pattern
argument_list|,
name|pfen
operator|->
name|patlen
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"gp_enumerate_files_close(pattern)"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pfree
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfen
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|file_enum
argument_list|)
argument_list|,
literal|"gp_enumerate_files_close"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

