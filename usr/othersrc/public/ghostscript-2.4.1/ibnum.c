begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* ibnum.c */
end_comment

begin_comment
comment|/* Level 2 encoded number reading utilities for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"bnum.h"
end_include

begin_include
include|#
directive|include
file|"btoken.h"
end_include

begin_comment
comment|/* ------ Encoded number reading ------ */
end_comment

begin_comment
comment|/* Set up to read from an encoded number array/string. */
end_comment

begin_function
name|int
name|sread_num_array
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|ref
modifier|*
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_string
case|:
block|{
comment|/* Check that this is a legitimate encoded number array */
name|byte
modifier|*
name|bp
init|=
name|op
operator|->
name|value
operator|.
name|bytes
decl_stmt|;
name|short
name|count
decl_stmt|;
name|int
name|nshift
decl_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|<
literal|4
operator|||
operator|(
name|bt_type
operator|)
name|bp
index|[
literal|0
index|]
operator|!=
name|bt_num_array
operator|||
operator|!
name|num_is_valid
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|e_typecheck
return|;
name|sread_string
argument_list|(
name|s
argument_list|,
name|bp
operator|+
literal|2
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|s
operator|->
name|num_format
operator|=
name|bp
index|[
literal|1
index|]
expr_stmt|;
name|sgetshort
argument_list|(
name|s
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|nshift
operator|=
operator|(
operator|(
name|bp
index|[
literal|1
index|]
operator|&
literal|0x70
operator|)
operator|==
literal|0x20
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
operator|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|-
literal|4
operator|)
operator|>>
name|nshift
condition|)
return|return
name|e_typecheck
return|;
block|}
break|break;
case|case
name|t_array
case|:
name|sread_string
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|op
operator|->
name|value
operator|.
name|refs
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|num_format
operator|=
name|num_array
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the number of elements in an encoded number stream. */
end_comment

begin_function
name|uint
name|scount_num_stream
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|long
name|avlong
decl_stmt|;
name|savailable
argument_list|(
name|s
argument_list|,
operator|&
name|avlong
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|num_format
operator|&
literal|0x170
condition|)
block|{
case|case
name|num_int16
case|:
return|return
call|(
name|uint
call|)
argument_list|(
name|avlong
operator|>>
literal|1
argument_list|)
return|;
case|case
name|num_array
case|:
return|return
call|(
name|uint
call|)
argument_list|(
name|avlong
operator|/
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
return|;
default|default:
comment|/* num_int32, num_float */
return|return
call|(
name|uint
call|)
argument_list|(
name|avlong
operator|>>
literal|2
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read an encoded number from a stream according to its num_format. */
end_comment

begin_comment
comment|/* Put the value in np->value.{intval,realval}.  Return t_int, t_real, */
end_comment

begin_comment
comment|/* t_null if end of stream, or e_syntaxerror or e_typecheck. */
end_comment

begin_decl_stmt
specifier|static
name|double
name|binary_scale
index|[
literal|32
index|]
init|=
block|{
define|#
directive|define
name|expn2
parameter_list|(
name|n
parameter_list|)
value|(0.5 / (1L<< (n-1)))
literal|1.0
block|,
name|expn2
argument_list|(
literal|1
argument_list|)
block|,
name|expn2
argument_list|(
literal|2
argument_list|)
block|,
name|expn2
argument_list|(
literal|3
argument_list|)
block|,
name|expn2
argument_list|(
literal|4
argument_list|)
block|,
name|expn2
argument_list|(
literal|5
argument_list|)
block|,
name|expn2
argument_list|(
literal|6
argument_list|)
block|,
name|expn2
argument_list|(
literal|7
argument_list|)
block|,
name|expn2
argument_list|(
literal|8
argument_list|)
block|,
name|expn2
argument_list|(
literal|9
argument_list|)
block|,
name|expn2
argument_list|(
literal|10
argument_list|)
block|,
name|expn2
argument_list|(
literal|11
argument_list|)
block|,
name|expn2
argument_list|(
literal|12
argument_list|)
block|,
name|expn2
argument_list|(
literal|13
argument_list|)
block|,
name|expn2
argument_list|(
literal|14
argument_list|)
block|,
name|expn2
argument_list|(
literal|15
argument_list|)
block|,
name|expn2
argument_list|(
literal|16
argument_list|)
block|,
name|expn2
argument_list|(
literal|17
argument_list|)
block|,
name|expn2
argument_list|(
literal|18
argument_list|)
block|,
name|expn2
argument_list|(
literal|19
argument_list|)
block|,
name|expn2
argument_list|(
literal|20
argument_list|)
block|,
name|expn2
argument_list|(
literal|21
argument_list|)
block|,
name|expn2
argument_list|(
literal|22
argument_list|)
block|,
name|expn2
argument_list|(
literal|23
argument_list|)
block|,
name|expn2
argument_list|(
literal|24
argument_list|)
block|,
name|expn2
argument_list|(
literal|25
argument_list|)
block|,
name|expn2
argument_list|(
literal|26
argument_list|)
block|,
name|expn2
argument_list|(
literal|27
argument_list|)
block|,
name|expn2
argument_list|(
literal|28
argument_list|)
block|,
name|expn2
argument_list|(
literal|29
argument_list|)
block|,
name|expn2
argument_list|(
literal|30
argument_list|)
block|,
name|expn2
argument_list|(
literal|31
argument_list|)
undef|#
directive|undef
name|expn2
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sget_encoded_number
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|ref
modifier|*
name|np
parameter_list|)
block|{
name|int
name|format
init|=
name|s
operator|->
name|num_format
decl_stmt|;
name|short
name|snum
decl_stmt|;
name|long
name|lnum
decl_stmt|;
name|int
name|code
decl_stmt|,
name|type
decl_stmt|;
switch|switch
condition|(
name|format
operator|&
literal|0x170
condition|)
block|{
case|case
name|num_int32
case|:
case|case
name|num_int32
operator|+
literal|16
case|:
if|if
condition|(
operator|(
name|format
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
name|type
operator|=
name|t_integer
operator|,
name|code
operator|=
name|sgetlong
argument_list|(
name|s
argument_list|,
operator|&
name|np
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|t_real
expr_stmt|;
name|code
operator|=
name|sgetlong
argument_list|(
name|s
argument_list|,
operator|&
name|lnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
name|np
operator|->
name|value
operator|.
name|realval
operator|=
operator|(
name|double
operator|)
name|lnum
operator|*
name|binary_scale
index|[
name|format
operator|&
literal|31
index|]
expr_stmt|;
block|}
break|break;
case|case
name|num_int16
case|:
name|code
operator|=
name|sgetshort
argument_list|(
name|s
argument_list|,
operator|&
name|snum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|format
operator|&
literal|15
operator|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|t_integer
expr_stmt|;
name|np
operator|->
name|value
operator|.
name|intval
operator|=
name|snum
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|t_real
expr_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
name|np
operator|->
name|value
operator|.
name|realval
operator|=
operator|(
name|double
operator|)
name|snum
operator|*
name|binary_scale
index|[
name|format
operator|&
literal|15
index|]
expr_stmt|;
block|}
break|break;
case|case
name|num_float
case|:
name|type
operator|=
name|t_real
expr_stmt|;
name|code
operator|=
name|sgetfloat
argument_list|(
name|s
argument_list|,
operator|&
name|np
operator|->
name|value
operator|.
name|realval
argument_list|)
expr_stmt|;
break|break;
case|case
name|num_array
case|:
block|{
name|uint
name|count
init|=
name|sgets
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
decl_stmt|;
name|code
operator|=
operator|(
name|count
operator|==
literal|0
condition|?
literal|1
else|:
name|count
operator|==
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
condition|?
literal|0
else|:
name|e_syntaxerror
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
switch|switch
condition|(
name|r_type
argument_list|(
name|np
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
return|return
name|t_integer
return|;
case|case
name|t_real
case|:
return|return
name|t_real
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
block|}
break|break;
default|default:
return|return
name|e_syntaxerror
return|;
comment|/* invalid num_format?? */
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
return|return
name|type
return|;
case|case
literal|1
case|:
return|return
name|t_null
return|;
comment|/* end of stream */
default|default:
return|return
name|code
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------ Get/put number ------ */
end_comment

begin_comment
comment|/* Get/put encoded numbers on a stream according to num_format. */
end_comment

begin_comment
comment|/* 1 means end of stream, 0 means not end,<0 means error. */
end_comment

begin_comment
comment|/* Get/put a short. */
end_comment

begin_function
name|int
name|sgetshort
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|short
modifier|*
name|p
parameter_list|)
block|{
name|int
name|a
init|=
name|sgetc
argument_list|(
name|s
argument_list|)
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|b
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
return|return
name|e_syntaxerror
return|;
operator|*
name|p
operator|=
call|(
name|short
call|)
argument_list|(
name|s_is_lsb
argument_list|(
name|s
argument_list|)
condition|?
operator|(
name|b
operator|<<
literal|8
operator|)
operator|+
name|a
else|:
operator|(
name|a
operator|<<
literal|8
operator|)
operator|+
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sputshort
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|short
name|num
parameter_list|)
block|{
name|byte
name|a
init|=
name|num
operator|&
literal|0xff
decl_stmt|;
name|byte
name|b
init|=
call|(
name|byte
call|)
argument_list|(
name|num
operator|>>
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|s_is_msb
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|byte
name|t
init|=
name|a
decl_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|t
expr_stmt|;
block|}
name|sputc
argument_list|(
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get/put a long. */
end_comment

begin_function
name|int
name|sgetlong
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|long
modifier|*
name|p
parameter_list|)
block|{
name|int
name|a
init|=
name|sgetc
argument_list|(
name|s
argument_list|)
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|a
operator|<
literal|0
condition|)
return|return
literal|1
return|;
name|b
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator||
name|c
operator||
name|d
operator|)
operator|<
literal|0
condition|)
return|return
name|e_syntaxerror
return|;
operator|*
name|p
operator|=
call|(
name|long
call|)
argument_list|(
name|s_is_lsb
argument_list|(
name|s
argument_list|)
condition|?
operator|(
operator|(
name|long
operator|)
name|d
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
operator|<<
literal|8
operator|)
operator|+
name|a
else|:
operator|(
operator|(
name|long
operator|)
name|a
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|long
operator|)
name|b
operator|<<
literal|16
operator|)
operator|+
operator|(
name|c
operator|<<
literal|8
operator|)
operator|+
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sputlong
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|long
name|num
parameter_list|)
block|{
name|byte
name|a
init|=
name|num
operator|&
literal|0xff
decl_stmt|;
name|byte
name|b
init|=
call|(
name|byte
call|)
argument_list|(
name|num
operator|>>
literal|8
argument_list|)
decl_stmt|;
name|byte
name|c
init|=
call|(
name|byte
call|)
argument_list|(
name|num
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|byte
name|d
init|=
call|(
name|byte
call|)
argument_list|(
name|num
operator|>>
literal|24
argument_list|)
decl_stmt|;
if|if
condition|(
name|s_is_msb
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|byte
name|t
init|=
name|a
decl_stmt|;
name|a
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|t
expr_stmt|;
block|}
name|sputc
argument_list|(
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get/put a float.  We don't handle non-IEEE native representations yet. */
end_comment

begin_function
name|int
name|sgetfloat
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|float
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|num_format
operator|==
name|num_float_native
condition|)
block|{
name|uint
name|len
init|=
name|sgets
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|?
literal|0
else|:
name|len
operator|==
literal|0
operator|&&
name|seofp
argument_list|(
name|s
argument_list|)
condition|?
literal|1
else|:
name|e_syntaxerror
operator|)
return|;
block|}
else|else
block|{
comment|/* Hack: we know floats and longs are the same size. */
return|return
name|sgetlong
argument_list|(
name|s
argument_list|,
operator|(
name|long
operator|*
operator|)
name|p
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sputfloat
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|floatp
name|num
parameter_list|)
block|{
name|float
name|f
init|=
name|num
decl_stmt|;
comment|/* coerce from double */
if|if
condition|(
name|s
operator|->
name|num_format
operator|==
name|num_float_native
condition|)
name|sputs
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|*
operator|)
operator|&
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Hack: we know floats and longs are the same size. */
name|sputlong
argument_list|(
name|s
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

