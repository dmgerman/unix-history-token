begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsdevice.c */
end_comment

begin_comment
comment|/* Device operators for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_comment
comment|/* for fabs */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_comment
comment|/* for memcpy */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gsprops.h"
end_include

begin_include
include|#
directive|include
file|"gsutil.h"
end_include

begin_include
include|#
directive|include
file|"gxarith.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for gzstate.h */
end_comment

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/* Import the device list from gdevs.c */
end_comment

begin_decl_stmt
specifier|extern
name|gx_device
modifier|*
name|gx_device_list
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device definitions */
end_comment

begin_comment
comment|/* Following defines the null device */
end_comment

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|null_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_tile_rectangle
parameter_list|(
name|null_tile_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_mono
parameter_list|(
name|null_copy_mono
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_draw_line
parameter_list|(
name|null_draw_line
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|null_procs
init|=
block|{
name|gx_default_open_device
block|,
name|gx_default_get_initial_matrix
block|,
name|gx_default_sync_output
block|,
name|gx_default_output_page
block|,
name|gx_default_close_device
block|,
name|gx_default_map_rgb_color
block|,
name|gx_default_map_color_rgb
block|,
name|null_fill_rectangle
block|,
name|null_tile_rectangle
block|,
name|null_copy_mono
block|,
name|gx_default_copy_color
block|,
name|null_draw_line
block|,
name|gx_default_get_bits
block|,
name|gx_default_get_props
block|,
name|gx_default_put_props
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_device
name|null_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|device
argument_list|)
block|,
operator|&
name|null_procs
block|,
literal|"null"
block|,
literal|0
block|,
literal|0
block|,
literal|72
block|,
literal|72
block|,
name|no_margins
block|,
name|dci_black_and_white
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The null device */
end_comment

begin_decl_stmt
name|gx_device
modifier|*
name|gx_device_null_p
init|=
operator|&
name|null_device
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flush buffered output to the device */
end_comment

begin_function
name|int
name|gs_flushpage
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_device
modifier|*
name|dev
init|=
name|pgs
operator|->
name|device
operator|->
name|info
decl_stmt|;
return|return
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|sync_output
call|)
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make the device output the accumulated page description */
end_comment

begin_function
name|int
name|gs_copypage
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|gs_output_page
argument_list|(
name|pgs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_output_page
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|num_copies
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
name|gx_device
modifier|*
name|dev
init|=
name|pgs
operator|->
name|device
operator|->
name|info
decl_stmt|;
return|return
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|output_page
call|)
argument_list|(
name|dev
argument_list|,
name|num_copies
argument_list|,
name|flush
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy scan lines from an image device */
end_comment

begin_function
name|int
name|gs_copyscanlines
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|start_y
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|size
parameter_list|,
name|int
modifier|*
name|plines_copied
parameter_list|,
name|uint
modifier|*
name|pbytes_copied
parameter_list|)
block|{
name|uint
name|line_size
init|=
name|gx_device_bytes_per_scan_line
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|code
init|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|get_bits
call|)
argument_list|(
name|dev
argument_list|,
name|start_y
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|uint
name|count
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_undefined
argument_list|)
expr_stmt|;
name|count
operator|=
name|size
operator|/
name|line_size
expr_stmt|;
if|if
condition|(
name|plines_copied
operator|!=
name|NULL
condition|)
operator|*
name|plines_copied
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|pbytes_copied
operator|!=
name|NULL
condition|)
operator|*
name|pbytes_copied
operator|=
name|count
operator|*
name|line_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the current device from the graphics state */
end_comment

begin_function
name|gx_device
modifier|*
name|gs_currentdevice
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|device
operator|->
name|info
return|;
block|}
end_function

begin_comment
comment|/* Get the name of a device */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gs_devicename
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|dev
operator|->
name|dname
return|;
block|}
end_function

begin_comment
comment|/* Get the initial matrix of a device. */
end_comment

begin_function
name|void
name|gs_deviceinitialmatrix
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|get_initial_matrix
call|)
argument_list|(
name|dev
argument_list|,
name|pmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the N'th device from the known device list */
end_comment

begin_function
name|gx_device
modifier|*
name|gs_getdevice
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|gx_device_list
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|index
condition|)
return|return
name|gx_device_list
index|[
name|i
index|]
return|;
block|}
return|return
literal|0
return|;
comment|/* index out of range */
block|}
end_function

begin_comment
comment|/* Cloning an existing device. */
end_comment

begin_function
name|int
name|gs_copydevice
parameter_list|(
name|gx_device
modifier|*
modifier|*
name|pnew_dev
parameter_list|,
name|gx_device
modifier|*
name|dev
parameter_list|,
name|proc_alloc_t
name|palloc
parameter_list|)
block|{
specifier|register
name|gx_device
modifier|*
name|new_dev
decl_stmt|;
name|new_dev
operator|=
operator|(
name|gx_device
operator|*
operator|)
call|(
modifier|*
name|palloc
call|)
argument_list|(
literal|1
argument_list|,
name|dev
operator|->
name|params_size
argument_list|,
literal|"gs_copydevice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dev
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_dev
argument_list|,
name|dev
argument_list|,
name|dev
operator|->
name|params_size
argument_list|)
expr_stmt|;
name|new_dev
operator|->
name|is_open
operator|=
literal|0
expr_stmt|;
operator|*
name|pnew_dev
operator|=
name|new_dev
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make a memory (image) device. */
end_comment

begin_comment
comment|/* If num_colors = -16, -24, or -32, this is a true-color device; */
end_comment

begin_comment
comment|/* otherwise, num_colors is the number of elements in the palette */
end_comment

begin_comment
comment|/* (2^N or 3*2^N). */
end_comment

begin_function
name|int
name|gs_makeimagedevice
parameter_list|(
name|gx_device
modifier|*
modifier|*
name|pnew_dev
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
name|uint
name|width
parameter_list|,
name|uint
name|height
parameter_list|,
name|byte
modifier|*
name|colors
parameter_list|,
name|int
name|num_colors
parameter_list|,
name|proc_alloc_t
name|palloc
parameter_list|)
block|{
name|gx_device_memory
modifier|*
name|old_dev
decl_stmt|;
specifier|register
name|gx_device_memory
modifier|*
name|new_dev
decl_stmt|;
name|byte
modifier|*
name|bits
decl_stmt|;
name|int
name|palette_size
init|=
name|num_colors
decl_stmt|;
name|int
name|bpp
init|=
literal|1
decl_stmt|;
name|int
name|pcount
decl_stmt|;
name|int
name|bits_per_pixel
decl_stmt|;
name|float
name|x_pixels_per_unit
decl_stmt|,
name|y_pixels_per_unit
decl_stmt|;
name|ulong
name|bitmap_size
decl_stmt|;
name|byte
name|palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|has_color
decl_stmt|;
if|if
condition|(
name|width
operator|<=
literal|0
operator|||
name|height
operator|<=
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num_colors
condition|)
block|{
case|case
literal|3
operator|*
literal|2
case|:
name|palette_size
operator|=
literal|2
expr_stmt|;
name|bpp
operator|=
literal|3
expr_stmt|;
case|case
literal|2
case|:
name|bits_per_pixel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
operator|*
literal|4
case|:
name|palette_size
operator|=
literal|4
expr_stmt|;
name|bpp
operator|=
literal|3
expr_stmt|;
case|case
literal|4
case|:
name|bits_per_pixel
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
operator|*
literal|16
case|:
name|palette_size
operator|=
literal|16
expr_stmt|;
name|bpp
operator|=
literal|3
expr_stmt|;
case|case
literal|16
case|:
name|bits_per_pixel
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
operator|*
literal|256
case|:
name|palette_size
operator|=
literal|256
expr_stmt|;
name|bpp
operator|=
literal|3
expr_stmt|;
case|case
literal|256
case|:
name|bits_per_pixel
operator|=
literal|8
expr_stmt|;
break|break;
case|case
operator|-
literal|16
case|:
name|bits_per_pixel
operator|=
literal|16
expr_stmt|;
name|palette_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|-
literal|24
case|:
name|bits_per_pixel
operator|=
literal|24
expr_stmt|;
name|palette_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|-
literal|32
case|:
name|bits_per_pixel
operator|=
literal|32
expr_stmt|;
name|palette_size
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
block|}
name|old_dev
operator|=
name|gdev_mem_device_for_bits
argument_list|(
name|bits_per_pixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_dev
operator|==
literal|0
condition|)
comment|/* no suitable device */
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
name|pcount
operator|=
name|palette_size
operator|*
literal|3
expr_stmt|;
comment|/* Check to make sure the palette contains white and black, */
comment|/* and, if it has any colors, the six primaries. */
if|if
condition|(
name|bits_per_pixel
operator|<=
literal|8
condition|)
block|{
name|byte
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|primary_mask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|has_color
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|colors
operator|,
name|q
operator|=
name|palette
init|;
name|i
operator|<
name|palette_size
condition|;
name|i
operator|++
operator|,
name|q
operator|+=
literal|3
control|)
block|{
name|int
name|mask
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|bpp
condition|)
block|{
case|case
literal|1
case|:
comment|/* gray */
name|q
index|[
literal|0
index|]
operator|=
name|q
index|[
literal|1
index|]
operator|=
name|q
index|[
literal|2
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* bpp == 3, colored */
name|q
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
operator|,
name|q
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|,
name|q
index|[
literal|2
index|]
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
define|#
directive|define
name|shift_mask
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|switch ( b ) { case 0xff: mask<<= n; case 0: break; default: mask = 0; }
name|shift_mask
argument_list|(
name|q
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|shift_mask
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|shift_mask
argument_list|(
name|q
index|[
literal|2
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|shift_mask
name|primary_mask
operator||=
name|mask
expr_stmt|;
if|if
condition|(
name|q
index|[
literal|0
index|]
operator|!=
name|q
index|[
literal|1
index|]
operator|||
name|q
index|[
literal|0
index|]
operator|!=
name|q
index|[
literal|2
index|]
condition|)
name|has_color
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|primary_mask
condition|)
block|{
case|case
literal|129
case|:
comment|/* just black and white */
if|if
condition|(
name|has_color
condition|)
comment|/* color but no primaries */
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
case|case
literal|255
case|:
comment|/* full color */
break|break;
default|default:
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|has_color
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The initial transformation matrix must map 1 user unit to 	 * 1/72".  Let W and H be the width and height in pixels, and 	 * assume the initial matrix is of the form [A 0 0 B X Y]. 	 * Then the size of the image in user units is (W/|A|,H/|B|), 	 * hence the size in inches is ((W/|A|)/72,(H/|B|)/72), so 	 * the number of pixels per inch is 	 * (W/((W/|A|)/72),H/((H/|B|)/72)), or (|A|*72,|B|*72). 	 * Similarly, if the initial matrix is [0 A B 0 X Y] for a 90 	 * or 270 degree rotation, the size of the image in user 	 * units is (W/|B|,H/|A|), so the pixels per inch are 	 * (|B|*72,|A|*72).  We forbid non-orthogonal transformation 	 * matrices. 	 */
if|if
condition|(
name|is_fzero2
argument_list|(
name|pmat
operator|->
name|xy
argument_list|,
name|pmat
operator|->
name|yx
argument_list|)
condition|)
name|x_pixels_per_unit
operator|=
name|pmat
operator|->
name|xx
operator|,
name|y_pixels_per_unit
operator|=
name|pmat
operator|->
name|yy
expr_stmt|;
elseif|else
if|if
condition|(
name|is_fzero2
argument_list|(
name|pmat
operator|->
name|xx
argument_list|,
name|pmat
operator|->
name|yy
argument_list|)
condition|)
name|x_pixels_per_unit
operator|=
name|pmat
operator|->
name|yx
operator|,
name|y_pixels_per_unit
operator|=
name|pmat
operator|->
name|xy
expr_stmt|;
else|else
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
comment|/* All checks done, allocate the device. */
name|new_dev
operator|=
operator|(
name|gx_device_memory
operator|*
operator|)
call|(
modifier|*
name|palloc
call|)
argument_list|(
literal|1
argument_list|,
name|old_dev
operator|->
name|params_size
argument_list|,
literal|"gs_makeimagedevice(device)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dev
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
operator|*
name|new_dev
operator|=
operator|*
name|old_dev
expr_stmt|;
name|new_dev
operator|->
name|initial_matrix
operator|=
operator|*
name|pmat
expr_stmt|;
name|new_dev
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|new_dev
operator|->
name|height
operator|=
name|height
expr_stmt|;
name|new_dev
operator|->
name|x_pixels_per_inch
operator|=
name|fabs
argument_list|(
name|x_pixels_per_unit
argument_list|)
operator|*
literal|72
expr_stmt|;
name|new_dev
operator|->
name|y_pixels_per_inch
operator|=
name|fabs
argument_list|(
name|y_pixels_per_unit
argument_list|)
operator|*
literal|72
expr_stmt|;
if|if
condition|(
operator|!
name|has_color
condition|)
name|new_dev
operator|->
name|color_info
operator|.
name|max_rgb
operator|=
literal|0
operator|,
name|new_dev
operator|->
name|color_info
operator|.
name|dither_rgb
operator|=
literal|0
expr_stmt|;
name|bitmap_size
operator|=
name|gdev_mem_bitmap_size
argument_list|(
name|new_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_size
operator|>
name|max_uint
condition|)
comment|/* can't allocate it! */
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
name|byte
operator|*
operator|)
call|(
modifier|*
name|palloc
call|)
argument_list|(
literal|1
argument_list|,
operator|(
name|uint
operator|)
name|bitmap_size
operator|+
name|pcount
argument_list|,
literal|"gs_makeimagedevice(bits)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|new_dev
operator|->
name|base
operator|=
name|bits
expr_stmt|;
name|new_dev
operator|->
name|invert
operator|=
operator|(
name|palette
index|[
literal|0
index|]
operator||
name|palette
index|[
literal|1
index|]
operator||
name|palette
index|[
literal|2
index|]
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* bogus */
name|new_dev
operator|->
name|palette_size
operator|=
name|palette_size
expr_stmt|;
name|new_dev
operator|->
name|palette
operator|=
name|bits
operator|+
name|bitmap_size
expr_stmt|;
name|memcpy
argument_list|(
name|new_dev
operator|->
name|palette
argument_list|,
name|palette
argument_list|,
name|pcount
argument_list|)
expr_stmt|;
name|new_dev
operator|->
name|is_open
operator|=
literal|0
expr_stmt|;
operator|*
name|pnew_dev
operator|=
operator|(
name|gx_device
operator|*
operator|)
name|new_dev
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the device in the graphics state */
end_comment

begin_function
name|int
name|gs_setdevice
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|register
name|device
modifier|*
name|pdev
init|=
name|pgs
operator|->
name|device
decl_stmt|;
name|int
name|was_open
init|=
name|dev
operator|->
name|is_open
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Initialize the device */
if|if
condition|(
operator|!
name|was_open
condition|)
block|{
name|code
operator|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|open_device
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|dev
operator|->
name|is_open
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compute device white and black codes */
name|pdev
operator|->
name|black
operator|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pdev
operator|->
name|white
operator|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|gx_max_color_value
argument_list|,
name|gx_max_color_value
argument_list|,
name|gx_max_color_value
argument_list|)
expr_stmt|;
name|pdev
operator|->
name|info
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_initmatrix
argument_list|(
name|pgs
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_initclip
argument_list|(
name|pgs
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|!
name|was_open
condition|)
if|if
condition|(
operator|(
name|code
operator|=
name|gs_erasepage
argument_list|(
name|pgs
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|gx_remap_color
argument_list|(
name|pgs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Select the null device.  This is just a convenience. */
end_comment

begin_function
name|void
name|gs_nulldevice
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gs_setdevice
argument_list|(
name|pgs
argument_list|,
name|gx_device_null_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a device.  The client is responsible for ensuring that */
end_comment

begin_comment
comment|/* this device is not current in any graphics state. */
end_comment

begin_function
name|int
name|gs_closedevice
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|is_open
condition|)
block|{
name|code
operator|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|close_device
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|dev
operator|->
name|is_open
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Install enough of a null device to suppress graphics output */
end_comment

begin_comment
comment|/* during the execution of stringwidth. */
end_comment

begin_function
name|void
name|gx_device_no_output
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|pgs
operator|->
name|device
operator|->
name|info
operator|=
operator|&
name|null_device
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the native color space of the current device. */
end_comment

begin_function
name|gs_color_space
name|gx_device_color_space
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
operator|(
name|gx_device_has_color
argument_list|(
name|pgs
operator|->
name|device
operator|->
name|info
argument_list|)
condition|?
name|gs_color_space_DeviceRGB
else|:
name|gs_color_space_DeviceGray
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Just set the device without reinitializing. */
end_comment

begin_comment
comment|/* (For internal use only.) */
end_comment

begin_function
name|void
name|gx_set_device_only
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|pgs
operator|->
name|device
operator|->
name|info
operator|=
name|dev
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the size of one scan line for a device, */
end_comment

begin_comment
comment|/* with or without padding to a word boundary. */
end_comment

begin_function
name|uint
name|gx_device_bytes_per_scan_line
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|pad
parameter_list|)
block|{
name|ulong
name|bits
init|=
operator|(
name|ulong
operator|)
name|dev
operator|->
name|width
operator|*
name|dev
operator|->
name|color_info
operator|.
name|depth
decl_stmt|;
return|return
operator|(
name|pad
condition|?
call|(
name|uint
call|)
argument_list|(
operator|(
name|bits
operator|+
literal|31
operator|)
operator|>>
literal|5
argument_list|)
operator|<<
literal|2
else|:
call|(
name|uint
call|)
argument_list|(
operator|(
name|bits
operator|+
literal|7
operator|)
operator|>>
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------ The null `device' ------ */
end_comment

begin_function
name|private
name|int
name|null_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|null_tile_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_bitmap
modifier|*
name|tile
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|,
name|int
name|px
parameter_list|,
name|int
name|py
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|null_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|null_draw_line
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Default device procedures ------ */
end_comment

begin_function
name|int
name|gx_default_open_device
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|gx_default_get_initial_matrix
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
name|pmat
operator|->
name|xx
operator|=
name|dev
operator|->
name|x_pixels_per_inch
operator|/
literal|72.0
expr_stmt|;
name|pmat
operator|->
name|xy
operator|=
literal|0
expr_stmt|;
name|pmat
operator|->
name|yx
operator|=
literal|0
expr_stmt|;
name|pmat
operator|->
name|yy
operator|=
name|dev
operator|->
name|y_pixels_per_inch
operator|/
operator|-
literal|72.0
expr_stmt|;
name|pmat
operator|->
name|tx
operator|=
literal|0
expr_stmt|;
name|pmat
operator|->
name|ty
operator|=
name|dev
operator|->
name|height
expr_stmt|;
comment|/****** WRONG for devices with ******/
comment|/****** arbitrary initial matrix ******/
block|}
end_function

begin_function
name|int
name|gx_default_sync_output
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|gx_default_output_page
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|num_copies
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
return|return
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|sync_output
call|)
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gx_default_close_device
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|gx_color_index
name|gx_default_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
comment|/* Map values>= 1/2 to 1,< 1/2 to 0. */
return|return
operator|(
operator|(
name|r
operator||
name|g
operator||
name|b
operator|)
operator|>
name|gx_max_color_value
operator|/
literal|2
condition|?
operator|(
name|gx_color_index
operator|)
literal|1
else|:
operator|(
name|gx_color_index
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gx_default_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
comment|/* Map 1 to max_value, 0 to 0. */
name|prgb
index|[
literal|0
index|]
operator|=
name|prgb
index|[
literal|1
index|]
operator|=
name|prgb
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|gx_color_value
operator|)
name|color
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|gx_default_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|data_x
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
return|return
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|copy_mono
call|)
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
name|data_x
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|0
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gx_default_get_bits
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|y
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|pad
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Standard device properties */
end_comment

begin_decl_stmt
name|private
name|gs_prop_item
name|props_std
index|[]
init|=
block|{
name|prop_def
argument_list|(
literal|"HWResolution"
argument_list|,
name|prt_float_array
argument_list|)
block|,
name|prop_def
argument_list|(
literal|"HWSize"
argument_list|,
name|prt_int_array
argument_list|)
block|,
comment|/* Following cannot be set yet */
name|prop_def
argument_list|(
literal|"InitialMatrix"
argument_list|,
name|prt_float_array
argument_list|)
block|,
comment|/* Following cannot be set */
name|prop_def
argument_list|(
literal|"Name"
argument_list|,
name|prt_string
argument_list|)
block|,
comment|/* Slots for arrays */
name|prop_float
block|,
name|prop_float
block|,
name|prop_int
block|,
name|prop_int
block|,
name|prop_float
block|,
name|prop_float
block|,
name|prop_float
block|,
name|prop_float
block|,
name|prop_float
block|,
name|prop_float
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get standard properties */
end_comment

begin_function
name|int
name|gx_default_get_props
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
specifier|register
name|gs_prop_item
modifier|*
name|plist
parameter_list|)
block|{
if|if
condition|(
name|plist
operator|!=
literal|0
condition|)
block|{
specifier|register
name|gs_prop_item
modifier|*
name|pi
decl_stmt|;
name|gs_matrix
name|mat
decl_stmt|;
name|memcpy
argument_list|(
name|plist
argument_list|,
name|props_std
argument_list|,
sizeof|sizeof
argument_list|(
name|props_std
argument_list|)
argument_list|)
expr_stmt|;
name|plist
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|plist
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|plist
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|size
operator|=
literal|6
expr_stmt|;
name|plist
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dev
operator|->
name|dname
expr_stmt|;
name|plist
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|pi
operator|=
operator|&
name|plist
index|[
literal|4
index|]
expr_stmt|;
comment|/* resolution array */
name|plist
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
operator|=
name|pi
expr_stmt|;
name|pi
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|dev
operator|->
name|x_pixels_per_inch
expr_stmt|;
name|pi
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|dev
operator|->
name|y_pixels_per_inch
expr_stmt|;
name|pi
operator|+=
literal|2
expr_stmt|;
comment|/* width/height array */
name|plist
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
operator|=
name|pi
expr_stmt|;
name|pi
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|i
operator|=
name|dev
operator|->
name|width
expr_stmt|;
name|pi
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|i
operator|=
name|dev
operator|->
name|height
expr_stmt|;
name|pi
operator|+=
literal|2
expr_stmt|;
comment|/* matrix */
name|plist
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
operator|=
name|pi
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|get_initial_matrix
call|)
argument_list|(
name|dev
argument_list|,
operator|&
name|mat
argument_list|)
expr_stmt|;
name|pi
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|mat
operator|.
name|xx
expr_stmt|;
name|pi
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|mat
operator|.
name|xy
expr_stmt|;
name|pi
index|[
literal|2
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|mat
operator|.
name|yx
expr_stmt|;
name|pi
index|[
literal|3
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|mat
operator|.
name|yy
expr_stmt|;
name|pi
index|[
literal|4
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|mat
operator|.
name|tx
expr_stmt|;
name|pi
index|[
literal|5
index|]
operator|.
name|value
operator|.
name|f
operator|=
name|mat
operator|.
name|ty
expr_stmt|;
name|pi
operator|+=
literal|6
expr_stmt|;
block|}
return|return
sizeof|sizeof
argument_list|(
name|props_std
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|gs_prop_item
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set standard properties */
end_comment

begin_function
name|int
name|gx_default_put_props
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gs_prop_item
modifier|*
name|plist
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|gs_prop_item
modifier|*
name|known
index|[
literal|2
index|]
decl_stmt|;
name|props_extract
argument_list|(
name|plist
argument_list|,
name|count
argument_list|,
name|props_std
argument_list|,
literal|2
argument_list|,
name|known
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|known
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|known
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|a
operator|.
name|size
operator|!=
literal|2
condition|)
name|known
index|[
literal|0
index|]
operator|->
name|status
operator|=
name|pv_typecheck
expr_stmt|;
else|else
block|{
name|gs_prop_item
modifier|*
name|ap
init|=
name|known
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
decl_stmt|;
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|f
operator|<=
literal|0
operator|||
name|ap
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|f
operator|<=
literal|0
condition|)
name|known
index|[
literal|0
index|]
operator|->
name|status
operator|=
name|pv_rangecheck
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|x_pixels_per_inch
operator|=
name|ap
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|f
expr_stmt|;
name|dev
operator|->
name|y_pixels_per_inch
operator|=
name|ap
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|f
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|known
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|known
index|[
literal|1
index|]
operator|->
name|value
operator|.
name|a
operator|.
name|size
operator|!=
literal|2
condition|)
name|known
index|[
literal|1
index|]
operator|->
name|status
operator|=
name|pv_typecheck
expr_stmt|;
else|else
block|{
name|gs_prop_item
modifier|*
name|ap
init|=
name|known
index|[
literal|1
index|]
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
decl_stmt|;
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|i
operator|<=
literal|0
operator|||
name|ap
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|i
operator|>
literal|0x7fff
operator|||
name|ap
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|i
operator|<=
literal|0
operator|||
name|ap
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|i
operator|>
literal|0x7fff
condition|)
name|known
index|[
literal|1
index|]
operator|->
name|status
operator|=
name|pv_rangecheck
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|width
operator|=
name|ap
index|[
literal|0
index|]
operator|.
name|value
operator|.
name|i
expr_stmt|;
name|dev
operator|->
name|height
operator|=
name|ap
index|[
literal|1
index|]
operator|.
name|value
operator|.
name|i
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

