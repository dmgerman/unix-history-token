begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxdither.c */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxlum.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_include
include|#
directive|include
file|"gzht.h"
end_include

begin_comment
comment|/*   *	Improved dithering for Ghostscript.  The underlying device imaging   *	model supports dithering between two colors to generate intermediate  *	shades.    *	  *	The strategy is to first see if the color is either pure white or  *	pure black.  In this case the problem is trivial.  *  *	Next, if the device has high quality colors (at least 256 values  *	per axis), we ask it to map the color directly.  *  *	Next, if the device is black and white, or the color happens  *	to be achromatic, we perform simple B/W dithering.  *	  *	Otherwise, things are a bit more complicated.  If the device   * 	supports N shades of each R, G and B independently, there are a total   *	of N*N*N colors.  These colors form a 3-D grid in a cubical color   *	space.  The following dithering technique works by locating the   *	color we want in this 3-D color grid and finding the eight colors   * 	that surround it.  In the case of dithering into 8 colors with 1   *	bit for each red, green and blue, these eight colors will always   *	be the same.  *  *	Now we consider all possible diagonal paths between the eight colors  *	and chose the path that runs closest to our desired color in 3-D  *	color space.  There are 28 such paths.  Then we find the position  *	on the path that is closest to our color.  *  *	The search is made faster by always reflecting our color into  *	the bottom octant of the cube and comparing it to 7 paths.  *	After the best path and the best position on that path are found,  *	the results are reflected back into the original color space.  *  *	NOTE: This code has been tested for B/W and Color imaging with  *	1, 2, 3 and 8 bits per component.  *  *	--- original code by Paul Haeberli @ Silicon Graphics - 1990  *	--- extensively revised by L. Peter Deutsch, Aladdin Enterprises  */
end_comment

begin_decl_stmt
name|void
name|gx_color_load
argument_list|(
name|P2
argument_list|(
name|gx_device_color
operator|*
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WEIGHT1
value|(unsigned long)(100)
end_define

begin_comment
comment|/* 1.0 			*/
end_comment

begin_define
define|#
directive|define
name|WEIGHT2
value|(unsigned long)(71)
end_define

begin_comment
comment|/* 1/sqrt(2.0) 		*/
end_comment

begin_define
define|#
directive|define
name|WEIGHT3
value|(unsigned long)(62)
end_define

begin_comment
comment|/* 1/sqrt(3.0)+tad 	*/
end_comment

begin_define
define|#
directive|define
name|DIAG_R
value|(0x1)
end_define

begin_define
define|#
directive|define
name|DIAG_G
value|(0x2)
end_define

begin_define
define|#
directive|define
name|DIAG_B
value|(0x4)
end_define

begin_define
define|#
directive|define
name|DIAG_RG
value|(0x3)
end_define

begin_define
define|#
directive|define
name|DIAG_GB
value|(0x6)
end_define

begin_define
define|#
directive|define
name|DIAG_BR
value|(0x5)
end_define

begin_define
define|#
directive|define
name|DIAG_RGB
value|(0x7)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|lum
index|[
literal|8
index|]
init|=
block|{
operator|(
literal|0
operator|*
name|lum_blue_weight
operator|+
literal|0
operator|*
name|lum_green_weight
operator|+
literal|0
operator|*
name|lum_red_weight
operator|)
block|,
operator|(
literal|0
operator|*
name|lum_blue_weight
operator|+
literal|0
operator|*
name|lum_green_weight
operator|+
literal|1
operator|*
name|lum_red_weight
operator|)
block|,
operator|(
literal|0
operator|*
name|lum_blue_weight
operator|+
literal|1
operator|*
name|lum_green_weight
operator|+
literal|0
operator|*
name|lum_red_weight
operator|)
block|,
operator|(
literal|0
operator|*
name|lum_blue_weight
operator|+
literal|1
operator|*
name|lum_green_weight
operator|+
literal|1
operator|*
name|lum_red_weight
operator|)
block|,
operator|(
literal|1
operator|*
name|lum_blue_weight
operator|+
literal|0
operator|*
name|lum_green_weight
operator|+
literal|0
operator|*
name|lum_red_weight
operator|)
block|,
operator|(
literal|1
operator|*
name|lum_blue_weight
operator|+
literal|0
operator|*
name|lum_green_weight
operator|+
literal|1
operator|*
name|lum_red_weight
operator|)
block|,
operator|(
literal|1
operator|*
name|lum_blue_weight
operator|+
literal|1
operator|*
name|lum_green_weight
operator|+
literal|0
operator|*
name|lum_red_weight
operator|)
block|,
operator|(
literal|1
operator|*
name|lum_blue_weight
operator|+
literal|1
operator|*
name|lum_green_weight
operator|+
literal|1
operator|*
name|lum_red_weight
operator|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a fractional color, the correctly rounded quotient of */
end_comment

begin_comment
comment|/* f * max_color_param / maxv. */
end_comment

begin_define
define|#
directive|define
name|_fc
parameter_list|(
name|f
parameter_list|,
name|maxv
parameter_list|)
define|\
value|(gx_color_value)(((f) * (max_color_param_long * 2) + maxv) / (maxv * 2))
end_define

begin_comment
comment|/* We have to split up the following because of a bug in the IBM AIX 3.2 */
end_comment

begin_comment
comment|/* C compiler. */
end_comment

begin_decl_stmt
name|private
name|gx_color_value
name|q0
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|q1
index|[]
init|=
block|{
literal|0
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|q2
index|[]
init|=
block|{
literal|0
block|,
name|_fc
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|q3
index|[]
init|=
block|{
literal|0
block|,
name|_fc
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
block|,
name|_fc
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|q4
index|[]
init|=
block|{
literal|0
block|,
name|_fc
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
block|,
name|_fc
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
block|,
name|_fc
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|q5
index|[]
init|=
block|{
literal|0
block|,
name|_fc
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
block|,
name|_fc
argument_list|(
literal|2
argument_list|,
literal|5
argument_list|)
block|,
name|_fc
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|)
block|,
name|_fc
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|q6
index|[]
init|=
block|{
literal|0
block|,
name|_fc
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|)
block|,
name|_fc
argument_list|(
literal|2
argument_list|,
literal|6
argument_list|)
block|,
name|_fc
argument_list|(
literal|3
argument_list|,
literal|6
argument_list|)
block|,
name|_fc
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
block|,
name|_fc
argument_list|(
literal|5
argument_list|,
literal|6
argument_list|)
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|q7
index|[]
init|=
block|{
literal|0
block|,
name|_fc
argument_list|(
literal|1
argument_list|,
literal|7
argument_list|)
block|,
name|_fc
argument_list|(
literal|2
argument_list|,
literal|7
argument_list|)
block|,
name|_fc
argument_list|(
literal|3
argument_list|,
literal|7
argument_list|)
block|,
name|_fc
argument_list|(
literal|4
argument_list|,
literal|7
argument_list|)
block|,
name|_fc
argument_list|(
literal|5
argument_list|,
literal|7
argument_list|)
block|,
name|_fc
argument_list|(
literal|6
argument_list|,
literal|7
argument_list|)
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_color_value
name|_ds
modifier|*
name|color_quo
index|[
literal|8
index|]
init|=
block|{
name|q0
block|,
name|q1
block|,
name|q2
block|,
name|q3
block|,
name|q4
block|,
name|q5
block|,
name|q6
block|,
name|q7
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|fractional_color
parameter_list|(
name|f
parameter_list|,
name|maxv
parameter_list|)
define|\
value|((maxv)<= 7 ? color_quo[maxv][f] : _fc(f, maxv))
end_define

begin_comment
comment|/* Note that this routine assumes that the incoming color */
end_comment

begin_comment
comment|/* has already been mapped through the transfer functions. */
end_comment

begin_function
name|void
name|gx_color_render
parameter_list|(
name|gs_color
modifier|*
name|pcolor
parameter_list|,
name|gx_device_color
modifier|*
name|pdevc
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|device
modifier|*
name|pdev
init|=
name|pgs
operator|->
name|device
decl_stmt|;
name|uint
name|max_value
decl_stmt|;
name|unsigned
name|long
name|hsize
decl_stmt|;
name|gx_device
modifier|*
name|dev
decl_stmt|;
name|gx_color_index
argument_list|(
operator|*
name|map_rgb_color
argument_list|)
argument_list|(
name|P4
argument_list|(
name|gx_device
operator|*
argument_list|,
name|gx_color_value
argument_list|,
name|gx_color_value
argument_list|,
name|gx_color_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a special check for black and white. */
if|if
condition|(
name|pcolor
operator|->
name|is_gray
condition|)
block|{
if|if
condition|(
name|pcolor
operator|->
name|luminance
operator|==
literal|0
condition|)
block|{
name|pdevc
operator|->
name|color2
operator|=
name|pdevc
operator|->
name|color1
operator|=
name|pdev
operator|->
name|black
expr_stmt|;
name|pdevc
operator|->
name|halftone_level
operator|=
literal|0
expr_stmt|;
comment|/* pure color */
return|return;
block|}
elseif|else
if|if
condition|(
name|pcolor
operator|->
name|luminance
operator|==
name|max_color_param
condition|)
block|{
name|pdevc
operator|->
name|color2
operator|=
name|pdevc
operator|->
name|color1
operator|=
name|pdev
operator|->
name|white
expr_stmt|;
name|pdevc
operator|->
name|halftone_level
operator|=
literal|0
expr_stmt|;
comment|/* pure color */
return|return;
block|}
block|}
comment|/* get a few handy values */
name|dev
operator|=
name|pdev
operator|->
name|info
expr_stmt|;
name|map_rgb_color
operator|=
name|dev
operator|->
name|procs
operator|->
name|map_rgb_color
expr_stmt|;
name|hsize
operator|=
operator|(
name|unsigned
operator|)
name|pgs
operator|->
name|halftone
operator|->
name|order_size
expr_stmt|;
comment|/* See if we should do it in black and white. */
if|if
condition|(
operator|!
name|gx_device_has_color
argument_list|(
name|dev
argument_list|)
operator|||
name|pcolor
operator|->
name|is_gray
condition|)
block|{
name|color_param
name|lum
init|=
name|color_luminance
argument_list|(
name|pcolor
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|color_info
operator|.
name|max_gray
operator|>=
literal|31
condition|)
block|{
comment|/* Give the device a chance first. */
name|gx_color_index
name|cx
init|=
call|(
modifier|*
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|lum
argument_list|,
name|lum
argument_list|,
name|lum
argument_list|)
decl_stmt|;
if|if
condition|(
name|cx
operator|!=
name|gx_no_color_index
condition|)
block|{
name|pdevc
operator|->
name|color2
operator|=
name|pdevc
operator|->
name|color1
operator|=
name|cx
expr_stmt|;
name|pdevc
operator|->
name|halftone_level
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* No luck, must dither. */
name|max_value
operator|=
name|dev
operator|->
name|color_info
operator|.
name|dither_gray
operator|-
literal|1
expr_stmt|;
block|{
name|unsigned
name|long
name|nshades
init|=
name|hsize
operator|*
name|max_value
operator|+
literal|1
decl_stmt|;
name|unsigned
name|long
name|lx
init|=
operator|(
name|nshades
operator|*
name|lum
operator|)
operator|/
operator|(
name|max_color_param_long
operator|+
literal|1
operator|)
decl_stmt|;
name|color_param
name|l
init|=
name|lx
operator|/
name|hsize
decl_stmt|;
name|pdevc
operator|->
name|halftone_level
operator|=
name|lx
operator|%
name|hsize
expr_stmt|;
name|lum
operator|=
name|fractional_color
argument_list|(
name|l
argument_list|,
name|max_value
argument_list|)
expr_stmt|;
name|pdevc
operator|->
name|color1
operator|=
call|(
modifier|*
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|lum
argument_list|,
name|lum
argument_list|,
name|lum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdevc
operator|->
name|halftone_level
operator|==
literal|0
condition|)
block|{
comment|/* Close enough to a pure color, */
comment|/* no dithering needed. */
name|pdevc
operator|->
name|color2
operator|=
name|pdevc
operator|->
name|color1
expr_stmt|;
block|}
else|else
block|{
name|lum
operator|=
name|fractional_color
argument_list|(
name|l
operator|+
literal|1
argument_list|,
name|max_value
argument_list|)
expr_stmt|;
name|pdevc
operator|->
name|color2
operator|=
call|(
modifier|*
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|lum
argument_list|,
name|lum
argument_list|,
name|lum
argument_list|)
expr_stmt|;
block|}
name|gx_color_load
argument_list|(
name|pdevc
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* If we are on a high quality RGB display, try not dithering first. */
if|if
condition|(
name|dev
operator|->
name|color_info
operator|.
name|max_rgb
operator|>=
literal|31
condition|)
block|{
name|gx_color_index
name|cx
init|=
call|(
modifier|*
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|pcolor
operator|->
name|red
argument_list|,
name|pcolor
operator|->
name|green
argument_list|,
name|pcolor
operator|->
name|blue
argument_list|)
decl_stmt|;
if|if
condition|(
name|cx
operator|!=
name|gx_no_color_index
condition|)
block|{
name|pdevc
operator|->
name|color2
operator|=
name|pdevc
operator|->
name|color1
operator|=
name|cx
expr_stmt|;
name|pdevc
operator|->
name|halftone_level
operator|=
literal|0
expr_stmt|;
comment|/* pure color */
return|return;
block|}
block|}
name|max_value
operator|=
name|dev
operator|->
name|color_info
operator|.
name|dither_rgb
operator|-
literal|1
expr_stmt|;
comment|/* must do real color dithering */
block|{
name|color_param
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|color_param
name|rem_r
init|=
name|pcolor
operator|->
name|red
decl_stmt|;
name|color_param
name|rem_g
init|=
name|pcolor
operator|->
name|green
decl_stmt|;
name|color_param
name|rem_b
init|=
name|pcolor
operator|->
name|blue
decl_stmt|;
name|int
name|adjust_r
decl_stmt|,
name|adjust_b
decl_stmt|,
name|adjust_g
decl_stmt|;
name|unsigned
name|short
name|amax
decl_stmt|;
name|unsigned
name|long
name|dmax
decl_stmt|;
name|int
name|axisc
decl_stmt|,
name|diagc
decl_stmt|;
name|unsigned
name|short
name|lum_invert
decl_stmt|;
name|unsigned
name|long
name|dot1
decl_stmt|,
name|dot2
decl_stmt|,
name|dot3
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* Compute the quotient and remainder of each color component */
comment|/* with the actual number of available colors.  Avoid */
comment|/* multiplies and divides for the common values. */
comment|/* Note that max_color_param is all 1s, so when only a short */
comment|/* result is needed, subtracting x*max_color_param is equivalent to */
comment|/* just adding x.  rem_{r,g,b} are short, so we can get away */
comment|/* with short arithmetic. */
switch|switch
condition|(
name|max_value
condition|)
block|{
case|case
literal|1
case|:
comment|/* 8 colors */
if|if
condition|(
name|rem_r
operator|==
name|max_color_param
condition|)
name|rem_r
operator|=
literal|0
operator|,
name|r
operator|=
literal|1
expr_stmt|;
else|else
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rem_g
operator|==
name|max_color_param
condition|)
name|rem_g
operator|=
literal|0
operator|,
name|g
operator|=
literal|1
expr_stmt|;
else|else
name|g
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rem_b
operator|==
name|max_color_param
condition|)
name|rem_b
operator|=
literal|0
operator|,
name|b
operator|=
literal|1
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* When max_color_param % max_value = 0, */
comment|/* we can do some short arithmetic. */
comment|/* Don't bother if ints are 32 bits. */
if|#
directive|if
name|arch_ints_are_short
case|case
literal|3
case|:
comment|/* 64 colors */
case|case
literal|15
case|:
comment|/* 4096 colors */
block|{
specifier|const
name|color_param
name|q
init|=
name|max_color_param
operator|/
name|max_value
decl_stmt|;
name|r
operator|=
name|rem_r
operator|/
name|q
expr_stmt|;
name|rem_r
operator|=
name|rem_r
operator|*
name|max_value
operator|+
name|r
expr_stmt|;
name|g
operator|=
name|rem_g
operator|/
name|q
expr_stmt|;
name|rem_g
operator|=
name|rem_g
operator|*
name|max_value
operator|+
name|g
expr_stmt|;
name|b
operator|=
name|rem_b
operator|/
name|q
expr_stmt|;
name|rem_b
operator|=
name|rem_b
operator|*
name|max_value
operator|+
name|b
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
block|{
name|unsigned
name|long
name|want_r
init|=
operator|(
name|ulong
operator|)
name|max_value
operator|*
name|rem_r
decl_stmt|;
name|unsigned
name|long
name|want_g
init|=
operator|(
name|ulong
operator|)
name|max_value
operator|*
name|rem_g
decl_stmt|;
name|unsigned
name|long
name|want_b
init|=
operator|(
name|ulong
operator|)
name|max_value
operator|*
name|rem_b
decl_stmt|;
name|r
operator|=
name|want_r
operator|/
name|max_color_param_long
expr_stmt|;
name|g
operator|=
name|want_g
operator|/
name|max_color_param_long
expr_stmt|;
name|b
operator|=
name|want_b
operator|/
name|max_color_param_long
expr_stmt|;
name|rem_r
operator|=
operator|(
name|color_param
operator|)
name|want_r
operator|+
name|r
expr_stmt|;
name|rem_g
operator|=
operator|(
name|color_param
operator|)
name|want_g
operator|+
name|g
expr_stmt|;
name|rem_b
operator|=
operator|(
name|color_param
operator|)
name|want_b
operator|+
name|b
expr_stmt|;
block|}
block|}
comment|/* Check for no dithering required */
if|if
condition|(
operator|!
operator|(
name|rem_r
operator||
name|rem_g
operator||
name|rem_b
operator|)
condition|)
block|{
name|pdevc
operator|->
name|color2
operator|=
name|pdevc
operator|->
name|color1
operator|=
call|(
modifier|*
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|fractional_color
argument_list|(
name|r
argument_list|,
name|max_value
argument_list|)
argument_list|,
name|fractional_color
argument_list|(
name|g
argument_list|,
name|max_value
argument_list|)
argument_list|,
name|fractional_color
argument_list|(
name|b
argument_list|,
name|max_value
argument_list|)
argument_list|)
expr_stmt|;
name|pdevc
operator|->
name|halftone_level
operator|=
literal|0
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'c'
index|]
condition|)
block|{
name|dprintf3
argument_list|(
literal|"[c]rgb=%x,%x,%x -->\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|pcolor
operator|->
name|red
argument_list|,
operator|(
name|unsigned
operator|)
name|pcolor
operator|->
name|green
argument_list|,
operator|(
name|unsigned
operator|)
name|pcolor
operator|->
name|blue
argument_list|)
expr_stmt|;
name|dprintf6
argument_list|(
literal|"   %x+%x,%x+%x,%x+%x -->\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|r
argument_list|,
operator|(
name|unsigned
operator|)
name|rem_r
argument_list|,
operator|(
name|unsigned
operator|)
name|g
argument_list|,
operator|(
name|unsigned
operator|)
name|rem_g
argument_list|,
operator|(
name|unsigned
operator|)
name|b
argument_list|,
operator|(
name|unsigned
operator|)
name|rem_b
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* flip the remainder color into the 0, 0, 0 octant */
name|lum_invert
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|half
value|((color_param)(max_color_param_long>>1))
if|if
condition|(
name|rem_r
operator|>
name|half
condition|)
name|rem_r
operator|=
name|max_color_param
operator|-
name|rem_r
operator|,
name|adjust_r
operator|=
operator|-
literal|1
operator|,
name|r
operator|++
operator|,
name|lum_invert
operator|+=
name|lum_red_weight
expr_stmt|;
else|else
name|adjust_r
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rem_g
operator|>
name|half
condition|)
name|rem_g
operator|=
name|max_color_param
operator|-
name|rem_g
operator|,
name|adjust_g
operator|=
operator|-
literal|1
operator|,
name|g
operator|++
operator|,
name|lum_invert
operator|+=
name|lum_green_weight
expr_stmt|;
else|else
name|adjust_g
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rem_b
operator|>
name|half
condition|)
name|rem_b
operator|=
name|max_color_param
operator|-
name|rem_b
operator|,
name|adjust_b
operator|=
operator|-
literal|1
operator|,
name|b
operator|++
operator|,
name|lum_invert
operator|+=
name|lum_blue_weight
expr_stmt|;
else|else
name|adjust_b
operator|=
literal|1
expr_stmt|;
name|pdevc
operator|->
name|color1
operator|=
call|(
modifier|*
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|fractional_color
argument_list|(
name|r
argument_list|,
name|max_value
argument_list|)
argument_list|,
name|fractional_color
argument_list|(
name|g
argument_list|,
name|max_value
argument_list|)
argument_list|,
name|fractional_color
argument_list|(
name|b
argument_list|,
name|max_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/*   * Dot the color with each axis to find the best one of 7;  * find the color at the end of the axis chosen.  */
if|if
condition|(
name|rem_g
operator|>
name|rem_r
condition|)
block|{
if|if
condition|(
name|rem_b
operator|>
name|rem_g
condition|)
name|amax
operator|=
name|rem_b
operator|,
name|axisc
operator|=
name|DIAG_B
expr_stmt|;
else|else
name|amax
operator|=
name|rem_g
operator|,
name|axisc
operator|=
name|DIAG_G
expr_stmt|;
if|if
condition|(
name|rem_b
operator|>
name|rem_r
condition|)
name|dmax
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rem_g
operator|+
name|rem_b
operator|,
name|diagc
operator|=
name|DIAG_GB
expr_stmt|;
else|else
name|dmax
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rem_r
operator|+
name|rem_g
operator|,
name|diagc
operator|=
name|DIAG_RG
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rem_b
operator|>
name|rem_r
condition|)
name|amax
operator|=
name|rem_b
operator|,
name|axisc
operator|=
name|DIAG_B
expr_stmt|;
else|else
name|amax
operator|=
name|rem_r
operator|,
name|axisc
operator|=
name|DIAG_R
expr_stmt|;
if|if
condition|(
name|rem_b
operator|>
name|rem_g
condition|)
name|dmax
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rem_b
operator|+
name|rem_r
operator|,
name|diagc
operator|=
name|DIAG_BR
expr_stmt|;
else|else
name|dmax
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rem_r
operator|+
name|rem_g
operator|,
name|diagc
operator|=
name|DIAG_RG
expr_stmt|;
block|}
name|dot1
operator|=
name|amax
operator|*
name|WEIGHT1
expr_stmt|;
name|dot2
operator|=
name|dmax
operator|*
name|WEIGHT2
expr_stmt|;
name|dot3
operator|=
operator|(
name|ulong
operator|)
name|rem_r
operator|+
name|rem_g
operator|+
name|rem_b
expr_stmt|;
comment|/* rgb axis */
if|if
condition|(
name|dot1
operator|>
name|dot2
condition|)
block|{
if|if
condition|(
name|dot3
operator|*
name|WEIGHT3
operator|>
name|dot1
condition|)
name|diagc
operator|=
name|DIAG_RGB
operator|,
name|level
operator|=
operator|(
name|hsize
operator|*
name|dot3
operator|)
operator|/
operator|(
literal|3
operator|*
name|max_color_param_long
operator|)
expr_stmt|;
else|else
name|diagc
operator|=
name|axisc
operator|,
name|level
operator|=
operator|(
name|hsize
operator|*
name|amax
operator|)
operator|/
name|max_color_param_long
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dot3
operator|*
name|WEIGHT3
operator|>
name|dot2
condition|)
name|diagc
operator|=
name|DIAG_RGB
operator|,
name|level
operator|=
operator|(
name|hsize
operator|*
name|dot3
operator|)
operator|/
operator|(
literal|3
operator|*
name|max_color_param_long
operator|)
expr_stmt|;
else|else
name|level
operator|=
operator|(
name|hsize
operator|*
name|dmax
operator|)
operator|/
operator|(
literal|2
operator|*
name|max_color_param_long
operator|)
expr_stmt|;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'c'
index|]
condition|)
block|{
name|dprintf6
argument_list|(
literal|"   %x+%x,%x+%x,%x+%x;"
argument_list|,
operator|(
name|unsigned
operator|)
name|r
argument_list|,
operator|(
name|unsigned
operator|)
name|rem_r
argument_list|,
operator|(
name|unsigned
operator|)
name|g
argument_list|,
operator|(
name|unsigned
operator|)
name|rem_g
argument_list|,
operator|(
name|unsigned
operator|)
name|b
argument_list|,
operator|(
name|unsigned
operator|)
name|rem_b
argument_list|)
expr_stmt|;
name|dprintf3
argument_list|(
literal|" adjust=%d,%d,%d;\n"
argument_list|,
name|adjust_r
argument_list|,
name|adjust_g
argument_list|,
name|adjust_b
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|pdevc
operator|->
name|halftone_level
operator|=
name|level
operator|)
operator|==
literal|0
condition|)
name|pdevc
operator|->
name|color2
operator|=
name|pdevc
operator|->
name|color1
expr_stmt|;
else|else
block|{
name|gx_color_index
name|color2
decl_stmt|;
comment|/* construct the second color, inverting back to original space if needed */
if|if
condition|(
name|diagc
operator|&
name|DIAG_R
condition|)
name|r
operator|+=
name|adjust_r
expr_stmt|;
if|if
condition|(
name|diagc
operator|&
name|DIAG_G
condition|)
name|g
operator|+=
name|adjust_g
expr_stmt|;
if|if
condition|(
name|diagc
operator|&
name|DIAG_B
condition|)
name|b
operator|+=
name|adjust_b
expr_stmt|;
comment|/* get the second device color, sorting by luminance */
name|color2
operator|=
call|(
modifier|*
name|map_rgb_color
call|)
argument_list|(
name|dev
argument_list|,
name|fractional_color
argument_list|(
name|r
argument_list|,
name|max_value
argument_list|)
argument_list|,
name|fractional_color
argument_list|(
name|g
argument_list|,
name|max_value
argument_list|)
argument_list|,
name|fractional_color
argument_list|(
name|b
argument_list|,
name|max_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/****** THIS IS A BAD IDEA ******/
if|#
directive|if
literal|0
block|if ( lum[diagc]< lum_invert ) 		   {	pdevc->color2 = pdevc->color1; 			pdevc->color1 = color2; 			pdevc->halftone_level = level = hsize - level; 		   } 		else
endif|#
directive|endif
name|pdevc
operator|->
name|color2
operator|=
name|color2
expr_stmt|;
name|gx_color_load
argument_list|(
name|pdevc
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'c'
index|]
condition|)
block|{
name|dprintf5
argument_list|(
literal|"[c]diagc=%d; color1=%lx, color2=%lx, level=%d/%d\n"
argument_list|,
name|diagc
argument_list|,
operator|(
name|ulong
operator|)
name|pdevc
operator|->
name|color1
argument_list|,
operator|(
name|ulong
operator|)
name|pdevc
operator|->
name|color2
argument_list|,
name|level
argument_list|,
operator|(
name|unsigned
operator|)
name|hsize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

end_unit

