begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zfilter.c */
end_comment

begin_comment
comment|/* Filter creation for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|int
name|filter_read
argument_list|(
name|P3
argument_list|(
argument|os_ptr
argument_list|,
argument|stream_procs _ds *
argument_list|,
argument|stream **
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filter_write
argument_list|(
name|P3
argument_list|(
argument|os_ptr
argument_list|,
argument|stream_procs _ds *
argument_list|,
argument|stream **
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* .filterASCIIHexEncode */
end_comment

begin_decl_stmt
specifier|extern
name|stream_procs
name|s_AXE_procs
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zAXE
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|filter_write
argument_list|(
name|op
argument_list|,
operator|&
name|s_AXE_procs
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* .filterASCIIHexDecode */
end_comment

begin_decl_stmt
specifier|extern
name|stream_procs
name|s_AXD_procs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|s_AXD_init
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zAXD
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
init|=
name|filter_read
argument_list|(
name|op
argument_list|,
operator|&
name|s_AXD_procs
argument_list|,
operator|&
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|s_AXD_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* .filtereexecDecode */
end_comment

begin_decl_stmt
specifier|extern
name|stream_procs
name|s_exD_procs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|s_exD_init
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|ushort
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zexD
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|ushort
name|state
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|state
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|!=
name|state
condition|)
return|return
name|e_rangecheck
return|;
comment|/* state value was truncated */
name|code
operator|=
name|filter_read
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|s_exD_procs
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|s_exD_init
argument_list|(
name|s
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* .filterPFBDecode */
end_comment

begin_decl_stmt
specifier|extern
name|stream_procs
name|s_PFBD_procs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|s_PFBD_init
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zPFBD
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
init|=
name|filter_read
argument_list|(
name|op
argument_list|,
operator|&
name|s_PFBD_procs
argument_list|,
operator|&
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|s_PFBD_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Utilities ------ */
end_comment

begin_comment
comment|/* Free the underlying string stream if needed. */
end_comment

begin_function
name|private
name|void
name|filter_free_null
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{ }
end_function

begin_function
name|private
name|void
name|filter_free_stream
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
operator|->
name|strm
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"filter_free_stream(stream)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up an input filter. */
end_comment

begin_function
name|int
name|filter_read
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|stream_procs
name|_ds
modifier|*
name|procs
parameter_list|,
name|stream
modifier|*
modifier|*
name|ps
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|stream
modifier|*
name|sstrm
decl_stmt|;
name|int
name|is_temp
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Check to make sure that the underlying data */
comment|/* can function as a source for reading. */
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_string
case|:
name|check_access
argument_list|(
operator|*
name|op
argument_list|,
name|a_read
argument_list|)
expr_stmt|;
name|sstrm
operator|=
operator|(
name|stream
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"filter_read(string stream)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstrm
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|sread_string
argument_list|(
name|sstrm
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|is_temp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|t_file
case|:
name|check_access
argument_list|(
operator|*
name|op
argument_list|,
name|a_read
argument_list|)
expr_stmt|;
name|sstrm
operator|=
name|op
operator|->
name|value
operator|.
name|pfile
expr_stmt|;
name|is_temp
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|code
operator|=
name|file_open
argument_list|(
operator|(
name|byte
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|"r"
argument_list|,
operator|(
name|ref
operator|*
operator|)
name|op
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|s_std_init
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|cbuf
argument_list|,
name|s
operator|->
name|bsize
argument_list|,
name|procs
argument_list|,
name|s_mode_read
argument_list|)
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not positionable */
name|s
operator|->
name|file
operator|=
literal|0
expr_stmt|;
comment|/* not a file stream */
name|s
operator|->
name|strm
operator|=
name|sstrm
expr_stmt|;
name|s
operator|->
name|strm_is_temp
operator|=
name|is_temp
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
operator|*
name|ps
operator|=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set up an output filter. */
end_comment

begin_function
name|int
name|filter_write
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|stream_procs
name|_ds
modifier|*
name|procs
parameter_list|,
name|stream
modifier|*
modifier|*
name|ps
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|stream
modifier|*
name|sstrm
decl_stmt|;
name|int
name|is_temp
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Check to make sure that the underlying data */
comment|/* can function as a sink for writing. */
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_string
case|:
name|check_access
argument_list|(
operator|*
name|op
argument_list|,
name|a_write
argument_list|)
expr_stmt|;
name|sstrm
operator|=
operator|(
name|stream
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"filter_write(string)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstrm
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|swrite_string
argument_list|(
name|sstrm
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|is_temp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|t_file
case|:
name|check_access
argument_list|(
operator|*
name|op
argument_list|,
name|a_write
argument_list|)
expr_stmt|;
name|sstrm
operator|=
name|op
operator|->
name|value
operator|.
name|pfile
expr_stmt|;
name|is_temp
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|code
operator|=
name|file_open
argument_list|(
operator|(
name|byte
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|"w"
argument_list|,
operator|(
name|ref
operator|*
operator|)
name|op
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|s_std_init
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|cbuf
argument_list|,
name|s
operator|->
name|bsize
argument_list|,
name|procs
argument_list|,
name|s_mode_write
argument_list|)
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|position
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not positionable */
name|s
operator|->
name|file
operator|=
literal|0
expr_stmt|;
comment|/* not a file stream */
name|s
operator|->
name|strm
operator|=
name|sstrm
expr_stmt|;
name|s
operator|->
name|strm_is_temp
operator|=
name|is_temp
expr_stmt|;
if|if
condition|(
name|ps
operator|!=
name|NULL
condition|)
operator|*
name|ps
operator|=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zfilter_op_defs
index|[]
init|=
block|{
block|{
literal|"1.filterASCIIHexEncode"
block|,
name|zAXE
block|}
block|,
block|{
literal|"1.filterASCIIHexDecode"
block|,
name|zAXD
block|}
block|,
block|{
literal|"2.filtereexecDecode"
block|,
name|zexD
block|}
block|,
block|{
literal|"1.filterPFBDecode"
block|,
name|zPFBD
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

