begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevsun.c */
end_comment

begin_comment
comment|/* SunView driver for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_comment
comment|/* for gx_bitmap; includes std.h */
end_comment

begin_include
include|#
directive|include
file|<suntool/sunview.h>
end_include

begin_include
include|#
directive|include
file|<suntool/canvas.h>
end_include

begin_include
include|#
directive|include
file|<sunwindow/cms_mono.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_comment
comment|/* needed for gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"malloc_.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_DPI
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_DPI
value|75
end_define

begin_comment
comment|/* Sun standard monitor */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Procedures */
end_comment

begin_expr_stmt
name|dev_proc_open_device
argument_list|(
name|sun_open
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_sync_output
argument_list|(
name|sun_sync
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_close_device
argument_list|(
name|sun_close
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_map_rgb_color
argument_list|(
name|sun_map_rgb_color
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_map_color_rgb
argument_list|(
name|sun_map_color_rgb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_fill_rectangle
argument_list|(
name|sun_fill_rectangle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_copy_mono
argument_list|(
name|sun_copy_mono
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_copy_color
argument_list|(
name|sun_copy_color
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dev_proc_draw_line
argument_list|(
name|sun_draw_line
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The device descriptor */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|sun_procs
init|=
block|{
name|sun_open
block|,
name|gx_default_get_initial_matrix
block|,
name|sun_sync
block|,
name|gx_default_output_page
block|,
name|sun_close
block|,
name|sun_map_rgb_color
block|,
name|sun_map_color_rgb
block|,
name|sun_fill_rectangle
block|,
name|gx_default_tile_rectangle
block|,
name|sun_copy_mono
block|,
name|sun_copy_color
block|,
name|sun_draw_line
block|,
name|gx_default_get_bits
block|,
name|gx_default_get_props
block|,
name|gx_default_put_props
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CMSNAME
value|"GHOSTVIEW"
end_define

begin_comment
comment|/* SunView colormap name */
end_comment

begin_comment
comment|/* Define the SunView device */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gx_device_sun
block|{
name|gx_device_common
expr_stmt|;
name|Frame
name|frame
decl_stmt|;
name|Canvas
name|canvas
decl_stmt|;
name|Pixwin
modifier|*
name|pw
decl_stmt|;
name|struct
name|mpr_data
name|mpr
decl_stmt|;
name|Pixrect
name|pr
decl_stmt|;
name|int
name|truecolor
decl_stmt|;
comment|/* use truecolor mapping */
name|gx_color_index
name|ncols
decl_stmt|;
comment|/* allocated colors */
name|byte
modifier|*
name|red
decl_stmt|,
modifier|*
name|green
decl_stmt|,
modifier|*
name|blue
decl_stmt|;
comment|/* colormap */
name|char
name|cmsname
index|[
sizeof|sizeof
argument_list|(
name|CMSNAME
argument_list|)
operator|+
literal|9
index|]
decl_stmt|;
comment|/* color map name */
if|#
directive|if
operator|!
name|arch_is_big_endian
comment|/* need to swap bits& bytes */
define|#
directive|define
name|BUF_WIDTH_BYTES
value|(((int)(8.5*DEFAULT_DPI)+15)/16*2)
name|byte
name|swap_buf
index|[
name|BUF_WIDTH_BYTES
index|]
decl_stmt|;
endif|#
directive|endif
block|}
name|gx_device_sun
typedef|;
end_typedef

begin_if
if|#
directive|if
operator|!
name|arch_is_big_endian
end_if

begin_comment
comment|/* Define a table for reversing bit order. */
end_comment

begin_decl_stmt
specifier|static
name|byte
name|reverse_bits
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|128
block|,
literal|64
block|,
literal|192
block|,
literal|32
block|,
literal|160
block|,
literal|96
block|,
literal|224
block|,
literal|16
block|,
literal|144
block|,
literal|80
block|,
literal|208
block|,
literal|48
block|,
literal|176
block|,
literal|112
block|,
literal|240
block|,
literal|8
block|,
literal|136
block|,
literal|72
block|,
literal|200
block|,
literal|40
block|,
literal|168
block|,
literal|104
block|,
literal|232
block|,
literal|24
block|,
literal|152
block|,
literal|88
block|,
literal|216
block|,
literal|56
block|,
literal|184
block|,
literal|120
block|,
literal|248
block|,
literal|4
block|,
literal|132
block|,
literal|68
block|,
literal|196
block|,
literal|36
block|,
literal|164
block|,
literal|100
block|,
literal|228
block|,
literal|20
block|,
literal|148
block|,
literal|84
block|,
literal|212
block|,
literal|52
block|,
literal|180
block|,
literal|116
block|,
literal|244
block|,
literal|12
block|,
literal|140
block|,
literal|76
block|,
literal|204
block|,
literal|44
block|,
literal|172
block|,
literal|108
block|,
literal|236
block|,
literal|28
block|,
literal|156
block|,
literal|92
block|,
literal|220
block|,
literal|60
block|,
literal|188
block|,
literal|124
block|,
literal|252
block|,
literal|2
block|,
literal|130
block|,
literal|66
block|,
literal|194
block|,
literal|34
block|,
literal|162
block|,
literal|98
block|,
literal|226
block|,
literal|18
block|,
literal|146
block|,
literal|82
block|,
literal|210
block|,
literal|50
block|,
literal|178
block|,
literal|114
block|,
literal|242
block|,
literal|10
block|,
literal|138
block|,
literal|74
block|,
literal|202
block|,
literal|42
block|,
literal|170
block|,
literal|106
block|,
literal|234
block|,
literal|26
block|,
literal|154
block|,
literal|90
block|,
literal|218
block|,
literal|58
block|,
literal|186
block|,
literal|122
block|,
literal|250
block|,
literal|6
block|,
literal|134
block|,
literal|70
block|,
literal|198
block|,
literal|38
block|,
literal|166
block|,
literal|102
block|,
literal|230
block|,
literal|22
block|,
literal|150
block|,
literal|86
block|,
literal|214
block|,
literal|54
block|,
literal|182
block|,
literal|118
block|,
literal|246
block|,
literal|14
block|,
literal|142
block|,
literal|78
block|,
literal|206
block|,
literal|46
block|,
literal|174
block|,
literal|110
block|,
literal|238
block|,
literal|30
block|,
literal|158
block|,
literal|94
block|,
literal|222
block|,
literal|62
block|,
literal|190
block|,
literal|126
block|,
literal|254
block|,
literal|1
block|,
literal|129
block|,
literal|65
block|,
literal|193
block|,
literal|33
block|,
literal|161
block|,
literal|97
block|,
literal|225
block|,
literal|17
block|,
literal|145
block|,
literal|81
block|,
literal|209
block|,
literal|49
block|,
literal|177
block|,
literal|113
block|,
literal|241
block|,
literal|9
block|,
literal|137
block|,
literal|73
block|,
literal|201
block|,
literal|41
block|,
literal|169
block|,
literal|105
block|,
literal|233
block|,
literal|25
block|,
literal|153
block|,
literal|89
block|,
literal|217
block|,
literal|57
block|,
literal|185
block|,
literal|121
block|,
literal|249
block|,
literal|5
block|,
literal|133
block|,
literal|69
block|,
literal|197
block|,
literal|37
block|,
literal|165
block|,
literal|101
block|,
literal|229
block|,
literal|21
block|,
literal|149
block|,
literal|85
block|,
literal|213
block|,
literal|53
block|,
literal|181
block|,
literal|117
block|,
literal|245
block|,
literal|13
block|,
literal|141
block|,
literal|77
block|,
literal|205
block|,
literal|45
block|,
literal|173
block|,
literal|109
block|,
literal|237
block|,
literal|29
block|,
literal|157
block|,
literal|93
block|,
literal|221
block|,
literal|61
block|,
literal|189
block|,
literal|125
block|,
literal|253
block|,
literal|3
block|,
literal|131
block|,
literal|67
block|,
literal|195
block|,
literal|35
block|,
literal|163
block|,
literal|99
block|,
literal|227
block|,
literal|19
block|,
literal|147
block|,
literal|83
block|,
literal|211
block|,
literal|51
block|,
literal|179
block|,
literal|115
block|,
literal|243
block|,
literal|11
block|,
literal|139
block|,
literal|75
block|,
literal|203
block|,
literal|43
block|,
literal|171
block|,
literal|107
block|,
literal|235
block|,
literal|27
block|,
literal|155
block|,
literal|91
block|,
literal|219
block|,
literal|59
block|,
literal|187
block|,
literal|123
block|,
literal|251
block|,
literal|7
block|,
literal|135
block|,
literal|71
block|,
literal|199
block|,
literal|39
block|,
literal|167
block|,
literal|103
block|,
literal|231
block|,
literal|23
block|,
literal|151
block|,
literal|87
block|,
literal|215
block|,
literal|55
block|,
literal|183
block|,
literal|119
block|,
literal|247
block|,
literal|15
block|,
literal|143
block|,
literal|79
block|,
literal|207
block|,
literal|47
block|,
literal|175
block|,
literal|111
block|,
literal|239
block|,
literal|31
block|,
literal|159
block|,
literal|95
block|,
literal|223
block|,
literal|63
block|,
literal|191
block|,
literal|127
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The instance is public. */
end_comment

begin_decl_stmt
name|gx_device_sun
name|gs_sunview_device
init|=
block|{
sizeof|sizeof
argument_list|(
name|gx_device_sun
argument_list|)
block|,
operator|&
name|sun_procs
block|,
literal|"sunview"
block|,
call|(
name|int
call|)
argument_list|(
literal|8.5
operator|*
name|DEFAULT_DPI
argument_list|)
block|,
call|(
name|int
call|)
argument_list|(
literal|11
operator|*
name|DEFAULT_DPI
argument_list|)
block|,
comment|/* x and y extent */
name|DEFAULT_DPI
block|,
name|DEFAULT_DPI
block|,
comment|/* x and y density */
name|no_margins
block|,
name|dci_color
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* fill in later from display depth */
literal|0
block|,
comment|/* connection not initialized */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for casting gx_device argument */
end_comment

begin_define
define|#
directive|define
name|xdev
value|((gx_device_sun *)dev)
end_define

begin_comment
comment|/* Macro to validate arguments */
end_comment

begin_define
define|#
directive|define
name|check_rect
parameter_list|()
define|\
value|if ( w<= 0 || h<= 0 ) return 0;\ 	if ( x< 0 || x> xdev->width - w || y< 0 || y> xdev->height - h )\ 		return -1
end_define

begin_comment
comment|/*  * The macros below define the colormap configuration used on 8-bit  * pseudo-color displays.  */
end_comment

begin_comment
comment|/*  * The following macros define the number of bits used to represent rgb colors.  * The total must not exceed the display depth.  * Note that the RGB dimensions could have an uneven number of bits assigned  * to them, but that will cause dithering to not work very well, since  * gs assumes the dither ramp is the same for all 3 color dimensions.  *  * Setting RED_BITS to n will pre-allocate a color-cube of 2^(3n) entries.  * The remaining entries are allocated on demand for colors requested by  * sun_map_rgb_color(), until the color map is full. At that point gs will  * fall back onto dithering using the pre-allocated colors.  * As a special case, if RED_BITS = GREEN_BITS = BLUE_BITS = 0, only  * black and white are pre-allocated.  */
end_comment

begin_define
define|#
directive|define
name|RED_BITS
value|2
end_define

begin_comment
comment|/* everything depends on this one */
end_comment

begin_define
define|#
directive|define
name|GREEN_BITS
value|RED_BITS
end_define

begin_define
define|#
directive|define
name|BLUE_BITS
value|RED_BITS
end_define

begin_define
define|#
directive|define
name|DEPTH
value|8
end_define

begin_comment
comment|/* don't change this */
end_comment

begin_define
define|#
directive|define
name|RGB_BITS
value|(RED_BITS + GREEN_BITS + BLUE_BITS)
end_define

begin_comment
comment|/*  * Smallest # bits per dimension  */
end_comment

begin_define
define|#
directive|define
name|MAX_BITS
value|RED_BITS
end_define

begin_if
if|#
directive|if
operator|(
name|GREEN_BITS
operator|>
name|MAX_BITS
operator|)
end_if

begin_undef
undef|#
directive|undef
name|MAX_BITS
end_undef

begin_define
define|#
directive|define
name|MAX_BITS
value|GREEN_BITS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|BLUE_BITS
operator|>
name|MAX_BITS
operator|)
end_if

begin_undef
undef|#
directive|undef
name|MAX_BITS
end_undef

begin_define
define|#
directive|define
name|MAX_BITS
value|BLUE_BITS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * masks to pull out rgb components  */
end_comment

begin_define
define|#
directive|define
name|BLUE_MASK
value|((1<< BLUE_BITS) - 1)
end_define

begin_define
define|#
directive|define
name|GREEN_MASK
value|((1<< (BLUE_BITS + GREEN_BITS)) - 1 - BLUE_MASK)
end_define

begin_define
define|#
directive|define
name|RED_MASK
value|((1<< (BLUE_BITS + GREEN_BITS + RED_BITS)) - 1 \ 			 - BLUE_MASK - GREEN_MASK)
end_define

begin_comment
comment|/*  * number of colors on rgb dimensions  */
end_comment

begin_define
define|#
directive|define
name|RED_COLS
value|(1<< RED_BITS)
end_define

begin_define
define|#
directive|define
name|GREEN_COLS
value|(1<< GREEN_BITS)
end_define

begin_define
define|#
directive|define
name|BLUE_COLS
value|(1<< BLUE_BITS)
end_define

begin_define
define|#
directive|define
name|RGB_COLS
value|(RED_COLS * GREEN_COLS * BLUE_COLS)
end_define

begin_define
define|#
directive|define
name|MAX_COLS
value|(1<< MAX_BITS)
end_define

begin_comment
comment|/*  * maximum number of colors in map  */
end_comment

begin_define
define|#
directive|define
name|ALL_COLS
value|(1<< DEPTH)
end_define

begin_comment
comment|/* 256 */
end_comment

begin_if
if|#
directive|if
operator|(
name|RGB_BITS
operator|<
literal|0
operator|)
operator|||
operator|(
name|RGB_BITS
operator|>
name|DEPTH
operator|)
end_if

begin_function_decl
name|Display_does_not_support_this_many_colors
endif|#
directive|endif
comment|/*  * The macros below define the color mapping used on 24-bit true-color  * displays.  * FAKE_TRUE_COLOR is used for debugging only.  It simulates a true-color  * type mapping on an 8-bit pseudo-color display. #define FAKE_TRUE_COLOR  */
ifdef|#
directive|ifdef
name|FAKE_TRUE_COLOR
define|#
directive|define
name|TRUE_RED_BITS
value|3
comment|/* everything depends on this one */
define|#
directive|define
name|TRUE_GREEN_BITS
value|2
define|#
directive|define
name|TRUE_BLUE_BITS
value|(DEPTH - TRUE_RED_BITS - TRUE_GREEN_BITS)
else|#
directive|else
define|#
directive|define
name|TRUE_RED_BITS
value|8
comment|/* everything depends on this one */
define|#
directive|define
name|TRUE_GREEN_BITS
value|TRUE_RED_BITS
define|#
directive|define
name|TRUE_BLUE_BITS
value|TRUE_RED_BITS
endif|#
directive|endif
endif|.
comment|/* FAKE_TRUE_COLOR */
define|#
directive|define
name|TRUE_DEPTH
value|(TRUE_RED_BITS + TRUE_GREEN_BITS + TRUE_BLUE_BITS)
comment|/*  * Masks to pull out rgb components.  Note that the bit order is BGR from  * high to low order bits.  */
define|#
directive|define
name|TRUE_RED_MASK
value|((1<< TRUE_RED_BITS) - 1)
define|#
directive|define
name|TRUE_GREEN_MASK
value|((1<< (TRUE_RED_BITS + TRUE_GREEN_BITS)) - 1 \ 			 - TRUE_RED_MASK)
define|#
directive|define
name|TRUE_BLUE_MASK
value|((1<< (TRUE_RED_BITS + TRUE_GREEN_BITS \ 			        + TRUE_BLUE_BITS)) - 1 \ 			 - TRUE_GREEN_MASK - TRUE_RED_MASK)
comment|/*  * number of colors on rgb dimensions  */
define|#
directive|define
name|TRUE_RED_COLS
value|(1<< TRUE_RED_BITS)
define|#
directive|define
name|TRUE_GREEN_COLS
value|(1<< TRUE_GREEN_BITS)
define|#
directive|define
name|TRUE_BLUE_COLS
value|(1<< TRUE_BLUE_BITS)
comment|/* Initialize the device. */
name|private
name|Notify_value
name|destroy_func
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|sun_open
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|gs_DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'X'
index|]
condition|)
block|{
specifier|extern
name|int
name|_Xdebug
decl_stmt|;
name|_Xdebug
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|xdev
operator|->
name|frame
operator|==
operator|(
name|Frame
operator|)
literal|0
condition|)
name|xdev
operator|->
name|frame
operator|=
name|window_create
argument_list|(
name|NULL
argument_list|,
name|FRAME
argument_list|,
name|FRAME_LABEL
argument_list|,
literal|"ghostscript"
argument_list|,
name|WIN_HEIGHT
argument_list|,
name|xdev
operator|->
name|width
operator|+
literal|20
argument_list|,
name|WIN_HEIGHT
argument_list|,
name|xdev
operator|->
name|height
operator|+
literal|40
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|frame
operator|==
operator|(
name|Frame
operator|)
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|xdev
operator|->
name|canvas
operator|=
name|window_create
argument_list|(
name|xdev
operator|->
name|frame
argument_list|,
name|CANVAS
argument_list|,
name|CANVAS_AUTO_EXPAND
argument_list|,
name|FALSE
argument_list|,
name|CANVAS_AUTO_SHRINK
argument_list|,
name|FALSE
argument_list|,
name|CANVAS_WIDTH
argument_list|,
name|xdev
operator|->
name|width
argument_list|,
name|CANVAS_HEIGHT
argument_list|,
name|xdev
operator|->
name|height
argument_list|,
ifndef|#
directive|ifndef
name|PRE_IBIS
comment|/* try to use 24-bit visual if OS supports it */
name|CANVAS_COLOR24
argument_list|,
name|TRUE
argument_list|,
endif|#
directive|endif
name|WIN_VERTICAL_SCROLLBAR
argument_list|,
name|scrollbar_create
argument_list|(
literal|0
argument_list|)
argument_list|,
name|WIN_HORIZONTAL_SCROLLBAR
argument_list|,
name|scrollbar_create
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|pw
operator|=
name|canvas_pixwin
argument_list|(
name|xdev
operator|->
name|canvas
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xdev
operator|->
name|pw
operator|->
name|pw_pixrect
operator|->
name|pr_depth
condition|)
block|{
specifier|static
name|gx_device_color_info
name|mono_ci
init|=
name|dci_black_and_white
decl_stmt|;
comment|/* 	      * If the pre-allocated color cube leaves room for spare entries, 	      * tell gs we can render colors exactly.  Otherwise admit our 	      * limitations. 	      */
specifier|static
name|gx_device_color_info
name|color_ci
init|=
if|#
directive|if
operator|(
name|RGB_COLS
operator|<
name|ALL_COLS
operator|)
name|dci_color
argument_list|(
name|DEPTH
argument_list|,
literal|31
argument_list|,
name|MAX_COLS
argument_list|)
decl_stmt|;
else|#
directive|else
name|dci_color
argument_list|(
name|DEPTH
argument_list|,
name|MAX_COLS
operator|-
literal|1
argument_list|,
name|MAX_COLS
argument_list|)
expr_stmt|;
endif|#
directive|endif
specifier|static
name|gx_device_color_info
name|truecolor_ci
init|=
name|dci_color
argument_list|(
name|TRUE_DEPTH
argument_list|,
literal|31
argument_list|,
literal|4
argument_list|)
decl_stmt|;
case|case
literal|1
case|:
comment|/* mono display */
name|xdev
operator|->
name|color_info
operator|=
name|mono_ci
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|FAKE_TRUE_COLOR
case|case
name|DEPTH
case|:
comment|/* pseudo-color display */
name|xdev
operator|->
name|color_info
operator|=
name|color_ci
expr_stmt|;
name|xdev
operator|->
name|truecolor
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FAKE_TRUE_COLOR */
case|case
name|TRUE_DEPTH
case|:
case|case
name|TRUE_DEPTH
operator|+
literal|8
case|:
comment|/* I'm not sure whether the XBGR frame buffer 				   returns depth 24 or 32. */
comment|/* pseudo-color display */
name|xdev
operator|->
name|color_info
operator|=
name|truecolor_ci
expr_stmt|;
name|xdev
operator|->
name|truecolor
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|eprintf1
argument_list|(
literal|"gs: Cannot handle display of depth %d.\n"
argument_list|,
name|xdev
operator|->
name|pw
operator|->
name|pw_pixrect
operator|->
name|pr_depth
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|xdev
argument_list|)
ifndef|#
directive|ifndef
name|FAKE_TRUE_COLOR
operator|&&
operator|!
name|xdev
operator|->
name|truecolor
endif|#
directive|endif
condition|)
block|{
name|gx_color_index
name|j
decl_stmt|;
comment|/* 		 * Create the pre-allocated colorcube. 		 */
name|xdev
operator|->
name|red
operator|=
operator|(
name|byte
operator|*
operator|)
name|malloc
argument_list|(
name|ALL_COLS
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|green
operator|=
operator|(
name|byte
operator|*
operator|)
name|malloc
argument_list|(
name|ALL_COLS
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|blue
operator|=
operator|(
name|byte
operator|*
operator|)
name|malloc
argument_list|(
name|ALL_COLS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdev
operator|->
name|red
operator|||
operator|!
name|xdev
operator|->
name|green
operator|||
operator|!
name|xdev
operator|->
name|blue
condition|)
block|{
name|eprintf
argument_list|(
literal|"gs: no memory for colomap\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|FAKE_TRUE_COLOR
comment|/* 		 * Fit the largest possible color cube into the colormap. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ALL_COLS
condition|;
name|j
operator|++
control|)
block|{
name|xdev
operator|->
name|blue
index|[
name|j
index|]
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
name|j
operator|&
name|TRUE_BLUE_MASK
operator|)
operator|>>
operator|(
name|TRUE_GREEN_BITS
operator|+
name|TRUE_RED_BITS
operator|)
argument_list|)
operator|/
operator|(
name|TRUE_BLUE_COLS
operator|-
literal|1
operator|)
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
name|xdev
operator|->
name|green
index|[
name|j
index|]
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
name|j
operator|&
name|TRUE_GREEN_MASK
operator|)
operator|>>
name|TRUE_RED_BITS
argument_list|)
operator|/
operator|(
name|TRUE_GREEN_COLS
operator|-
literal|1
operator|)
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
name|xdev
operator|->
name|red
index|[
name|j
index|]
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
name|j
operator|&
name|TRUE_RED_MASK
operator|)
argument_list|)
operator|/
operator|(
name|TRUE_RED_COLS
operator|-
literal|1
operator|)
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !FAKE_TRUE_COLOR */
comment|/* 		 * Black and white are allocated in the first two slots, 		 * so as to be compatible with the monochrome colormap. 		 * This prevents most text etc. to go technicolor as focus 		 * changes into the ghostscript window. 		 */
name|cms_monochromeload
argument_list|(
name|xdev
operator|->
name|red
argument_list|,
name|xdev
operator|->
name|green
argument_list|,
name|xdev
operator|->
name|blue
argument_list|)
expr_stmt|;
comment|/* 		 * The remaining slots up to RGB_COLS-1 are filled with 		 * evenly spaced points from the colorcube. 		 */
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|RGB_COLS
condition|;
name|j
operator|++
control|)
block|{
name|int
name|color
init|=
name|j
operator|-
literal|1
decl_stmt|;
comment|/* bit pattern corresponding to color */
name|xdev
operator|->
name|red
index|[
name|j
index|]
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
name|color
operator|&
name|RED_MASK
operator|)
operator|>>
operator|(
name|GREEN_BITS
operator|+
name|BLUE_BITS
operator|)
argument_list|)
operator|/
operator|(
name|RED_COLS
operator|-
literal|1
operator|)
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
name|xdev
operator|->
name|green
index|[
name|j
index|]
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
name|color
operator|&
name|GREEN_MASK
operator|)
operator|>>
name|BLUE_BITS
argument_list|)
operator|/
operator|(
name|GREEN_COLS
operator|-
literal|1
operator|)
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
name|xdev
operator|->
name|blue
index|[
name|j
index|]
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
name|color
operator|&
name|BLUE_MASK
operator|)
argument_list|)
operator|/
operator|(
name|BLUE_COLS
operator|-
literal|1
operator|)
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FAKE_TRUE_COLOR */
comment|/* 		 * Set the high-water mark to the end of the colorcube. 		 */
name|xdev
operator|->
name|ncols
operator|=
name|j
expr_stmt|;
comment|/* 		 * The unusued entries are filled so that the last entry is 		 * always different from the 0th entry.  This is a requirement 		 * for SunWindows. 		 */
for|for
control|(
init|;
name|j
operator|<
name|ALL_COLS
condition|;
name|j
operator|++
control|)
block|{
name|xdev
operator|->
name|red
index|[
name|j
index|]
operator|=
name|xdev
operator|->
name|green
index|[
name|j
index|]
operator|=
name|xdev
operator|->
name|blue
index|[
name|j
index|]
operator|=
operator|~
name|xdev
operator|->
name|red
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 		 * Install the colormap. 		 */
name|sprintf
argument_list|(
name|xdev
operator|->
name|cmsname
argument_list|,
literal|"%s-%d"
argument_list|,
name|CMSNAME
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|pw_setcmsname
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|xdev
operator|->
name|cmsname
argument_list|)
expr_stmt|;
name|pw_putcolormap
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
literal|0
argument_list|,
name|ALL_COLS
argument_list|,
name|xdev
operator|->
name|red
argument_list|,
name|xdev
operator|->
name|green
argument_list|,
name|xdev
operator|->
name|blue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xdev
operator|->
name|ncols
operator|=
literal|0
expr_stmt|;
name|xdev
operator|->
name|red
operator|=
operator|(
name|byte
operator|*
operator|)
literal|0
expr_stmt|;
name|xdev
operator|->
name|green
operator|=
operator|(
name|byte
operator|*
operator|)
literal|0
expr_stmt|;
name|xdev
operator|->
name|blue
operator|=
operator|(
name|byte
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|window_set
argument_list|(
name|xdev
operator|->
name|frame
argument_list|,
name|WIN_SHOW
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Interpose a destroy function to keep Ghostscript from */
comment|/* getting confused if the user closes the window. */
name|notify_interpose_destroy_func
argument_list|(
name|xdev
operator|->
name|frame
argument_list|,
name|destroy_func
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|notify_do_dispatch
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|notify_dispatch
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prevent the user from closing the window. */
end_comment

begin_function
name|private
name|Notify_value
name|destroy_func
parameter_list|(
name|Frame
name|frame
parameter_list|,
name|Destroy_status
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|==
name|DESTROY_CHECKING
condition|)
block|{
name|notify_veto_destroy
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTIFY_DONE
operator|)
return|;
block|}
return|return
operator|(
name|notify_next_destroy_func
argument_list|(
name|frame
argument_list|,
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Close the device. */
end_comment

begin_function
name|int
name|sun_close
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|window_destroy
argument_list|(
name|xdev
operator|->
name|frame
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|frame
operator|=
operator|(
name|Frame
operator|)
literal|0
expr_stmt|;
name|xdev
operator|->
name|canvas
operator|=
operator|(
name|Canvas
operator|)
literal|0
expr_stmt|;
name|xdev
operator|->
name|pw
operator|=
operator|(
name|Pixwin
operator|*
operator|)
literal|0
expr_stmt|;
name|xdev
operator|->
name|ncols
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|red
condition|)
name|free
argument_list|(
name|xdev
operator|->
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|green
condition|)
name|free
argument_list|(
name|xdev
operator|->
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|blue
condition|)
name|free
argument_list|(
name|xdev
operator|->
name|blue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Synchronize the display with the commands already given */
end_comment

begin_function
name|int
name|sun_sync
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
operator|(
name|void
operator|)
name|notify_dispatch
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map RGB to color number - 	Look for existing entry in colormap, or create a new one, or 	give up if no free colormap entries (requesting dithering).  */
end_comment

begin_function
name|gx_color_index
name|sun_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|short
name|red
parameter_list|,
name|unsigned
name|short
name|green
parameter_list|,
name|unsigned
name|short
name|blue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gx_device_has_color
argument_list|(
name|dev
argument_list|)
condition|)
comment|/* 		 * Invert default color index to match mono display 		 * pixel values (black = 1, white = 0). 		 */
return|return
operator|!
name|gx_default_map_rgb_color
argument_list|(
name|dev
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|xdev
operator|->
name|truecolor
condition|)
block|{
name|byte
name|red_val
decl_stmt|,
name|green_val
decl_stmt|,
name|blue_val
decl_stmt|;
name|gx_color_index
name|i
decl_stmt|;
specifier|static
name|int
name|warn
init|=
literal|1
decl_stmt|;
comment|/* 		 * Determine the RGB values at display resolution we 		 * ideally would want this color to be mapped into. 		 */
name|red_val
operator|=
operator|(
name|double
operator|)
name|red
operator|/
name|gx_max_color_value
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
name|green_val
operator|=
operator|(
name|double
operator|)
name|green
operator|/
name|gx_max_color_value
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
name|blue_val
operator|=
operator|(
name|double
operator|)
name|blue
operator|/
name|gx_max_color_value
operator|*
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 		 * Look for an exact match among the colors already allocated. 		 * This includes the pre-allocated default color cube. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xdev
operator|->
name|ncols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xdev
operator|->
name|red
index|[
name|i
index|]
operator|==
name|red_val
operator|&&
name|xdev
operator|->
name|green
index|[
name|i
index|]
operator|==
name|green_val
operator|&&
name|xdev
operator|->
name|blue
index|[
name|i
index|]
operator|==
name|blue_val
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
comment|/* 		 * If we run out of space in the color map, let gs know. 		 * It will call us again to request colors to do the 		 * dithering, and hopefully request only RGB values that 		 * match the colorcube entries. IF NOT, WE WILL LOOP 		 * FOREVER! 		 */
if|if
condition|(
name|xdev
operator|->
name|ncols
operator|==
name|ALL_COLS
condition|)
block|{
if|if
condition|(
name|warn
condition|)
block|{
name|eprintf
argument_list|(
literal|"gs: last spare color map entry allocated\n"
argument_list|)
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|gx_no_color_index
return|;
block|}
comment|/* 		 * Allocate new color in map. 		 */
name|xdev
operator|->
name|red
index|[
name|i
index|]
operator|=
name|red_val
expr_stmt|;
name|xdev
operator|->
name|green
index|[
name|i
index|]
operator|=
name|green_val
expr_stmt|;
name|xdev
operator|->
name|blue
index|[
name|i
index|]
operator|=
name|blue_val
expr_stmt|;
name|pw_setcmsname
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|xdev
operator|->
name|cmsname
argument_list|)
expr_stmt|;
name|pw_putcolormap
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|xdev
operator|->
name|ncols
argument_list|,
literal|1
argument_list|,
operator|&
name|xdev
operator|->
name|red
index|[
name|i
index|]
argument_list|,
operator|&
name|xdev
operator|->
name|green
index|[
name|i
index|]
argument_list|,
operator|&
name|xdev
operator|->
name|blue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xdev
operator|->
name|ncols
operator|++
expr_stmt|;
if|if
condition|(
name|xdev
operator|->
name|ncols
operator|==
name|ALL_COLS
condition|)
return|return
name|i
return|;
block|}
else|else
block|{
comment|/* true color mapping -- 			color index encodes all 3 RGB values */
return|return
operator|(
operator|(
name|blue
operator|>>
operator|(
name|gx_color_value_bits
operator|-
name|TRUE_BLUE_BITS
operator|)
operator|)
operator|<<
operator|(
name|TRUE_GREEN_BITS
operator|+
name|TRUE_RED_BITS
operator|)
operator|)
operator||
operator|(
operator|(
name|green
operator|>>
operator|(
name|gx_color_value_bits
operator|-
name|TRUE_GREEN_BITS
operator|)
operator|)
operator|<<
name|TRUE_RED_BITS
operator|)
operator||
operator|(
name|red
operator|>>
operator|(
name|gx_color_value_bits
operator|-
name|TRUE_RED_BITS
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Map color number back to RGB values  - see sun_map_rgb_color(), above */
end_comment

begin_function
name|int
name|sun_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|unsigned
name|short
name|rgb
index|[
literal|3
index|]
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gx_device_has_color
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|gx_default_map_color_rgb
argument_list|(
name|dev
argument_list|,
operator|!
name|color
argument_list|,
name|rgb
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|xdev
operator|->
name|truecolor
condition|)
block|{
comment|/* 		 * We just use the colormap to map back to rgb values. 		 */
if|if
condition|(
name|color
operator|>=
name|xdev
operator|->
name|ncols
condition|)
block|{
name|eprintf1
argument_list|(
literal|"gs: attempt to get RGB values for unallocated color index %d\n"
argument_list|,
name|color
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rgb
index|[
literal|0
index|]
operator|=
operator|(
name|double
operator|)
name|xdev
operator|->
name|red
index|[
name|color
index|]
operator|/
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
operator|*
name|gx_max_color_value
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
operator|(
name|double
operator|)
name|xdev
operator|->
name|green
index|[
name|color
index|]
operator|/
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
operator|*
name|gx_max_color_value
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
operator|(
name|double
operator|)
name|xdev
operator|->
name|blue
index|[
name|color
index|]
operator|/
operator|(
name|ALL_COLS
operator|-
literal|1
operator|)
operator|*
name|gx_max_color_value
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* true color mapping */
name|rgb
index|[
literal|0
index|]
operator|=
call|(
name|double
call|)
argument_list|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|color
operator|&
name|TRUE_RED_MASK
argument_list|)
argument_list|)
operator|/
operator|(
name|TRUE_RED_COLS
operator|-
literal|1
operator|)
operator|*
name|gx_max_color_value
expr_stmt|;
name|rgb
index|[
literal|1
index|]
operator|=
call|(
name|double
call|)
argument_list|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|color
operator|&
name|TRUE_GREEN_MASK
argument_list|)
operator|>>
name|TRUE_RED_BITS
argument_list|)
operator|/
operator|(
name|TRUE_GREEN_COLS
operator|-
literal|1
operator|)
operator|*
name|gx_max_color_value
expr_stmt|;
name|rgb
index|[
literal|2
index|]
operator|=
call|(
name|double
call|)
argument_list|(
call|(
name|unsigned
name|short
call|)
argument_list|(
name|color
operator|&
name|TRUE_BLUE_MASK
argument_list|)
operator|>>
operator|(
name|TRUE_GREEN_BITS
operator|+
name|TRUE_RED_BITS
operator|)
argument_list|)
operator|/
operator|(
name|TRUE_BLUE_COLS
operator|-
literal|1
operator|)
operator|*
name|gx_max_color_value
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fill a rectangle with a color. */
end_comment

begin_function
name|int
name|sun_fill_rectangle
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|check_rect
argument_list|()
expr_stmt|;
name|pw_write
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|PIX_SRC
operator||
name|PIX_COLOR
argument_list|(
call|(
name|int
call|)
argument_list|(
name|color
argument_list|)
argument_list|)
argument_list|,
operator|(
name|Pixrect
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|notify_dispatch
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a monochrome bitmap. */
end_comment

begin_function
name|int
name|sun_copy_mono
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nbytes
init|=
name|h
operator|*
name|raster
decl_stmt|;
specifier|extern
name|struct
name|pixrectops
name|mem_ops
decl_stmt|;
if|#
directive|if
operator|!
name|arch_is_big_endian
comment|/* need to swap bits& bytes */
define|#
directive|define
name|BUF_WIDTH_BYTES
value|(((int)(8.5*DEFAULT_DPI)+15)/16*2)
name|byte
name|swap_buf
index|[
name|BUF_WIDTH_BYTES
index|]
decl_stmt|;
endif|#
directive|endif
name|check_rect
argument_list|()
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_ops
operator|=
operator|&
name|mem_ops
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_width
operator|=
name|w
operator|+
name|sourcex
operator|+
literal|8
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_height
operator|=
name|h
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_depth
operator|=
literal|1
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|xdev
operator|->
name|mpr
operator|)
expr_stmt|;
name|xdev
operator|->
name|mpr
operator|.
name|md_linebytes
operator|=
name|raster
expr_stmt|;
name|xdev
operator|->
name|mpr
operator|.
name|md_image
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|ulong
operator|)
name|base
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
if|#
directive|if
operator|!
name|arch_is_big_endian
comment|/* Reverse the bit order in each byte. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
name|reverse_bits
index|[
name|base
index|[
name|i
index|]
index|]
expr_stmt|;
endif|#
directive|endif
name|pw_batch_on
argument_list|(
name|xdev
operator|->
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|!=
name|gx_no_color_index
condition|)
block|{
name|pw_stencil
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|PIX_SRC
operator||
name|PIX_COLOR
argument_list|(
name|one
argument_list|)
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|pr
operator|)
argument_list|,
operator|(
operator|(
name|int
operator|)
name|base
operator|&
literal|1
operator|)
condition|?
name|sourcex
operator|+
literal|8
else|:
name|sourcex
argument_list|,
literal|0
argument_list|,
operator|(
name|Pixrect
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zero
operator|!=
name|gx_no_color_index
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
operator|~
name|base
index|[
name|i
index|]
expr_stmt|;
name|pw_stencil
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|PIX_SRC
operator||
name|PIX_COLOR
argument_list|(
name|zero
argument_list|)
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|pr
operator|)
argument_list|,
operator|(
operator|(
name|int
operator|)
name|base
operator|&
literal|1
operator|)
condition|?
name|sourcex
operator|+
literal|8
else|:
name|sourcex
argument_list|,
literal|0
argument_list|,
operator|(
name|Pixrect
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
operator|~
name|base
index|[
name|i
index|]
expr_stmt|;
block|}
name|pw_batch_off
argument_list|(
name|xdev
operator|->
name|pw
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|arch_is_big_endian
comment|/* Reverse the bits back again. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
name|reverse_bits
index|[
name|base
index|[
name|i
index|]
index|]
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|notify_dispatch
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a color bitmap. */
end_comment

begin_function
name|int
name|sun_copy_color
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|struct
name|pixrectops
name|mem_ops
decl_stmt|;
if|if
condition|(
operator|!
name|gx_device_has_color
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|sun_copy_mono
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|sourcex
argument_list|,
name|raster
argument_list|,
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|0
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|1
argument_list|)
return|;
name|check_rect
argument_list|()
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_ops
operator|=
operator|&
name|mem_ops
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_width
operator|=
name|w
operator|+
name|sourcex
operator|+
literal|8
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_height
operator|=
name|h
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_depth
operator|=
literal|8
expr_stmt|;
name|xdev
operator|->
name|pr
operator|.
name|pr_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|xdev
operator|->
name|mpr
operator|)
expr_stmt|;
name|xdev
operator|->
name|mpr
operator|.
name|md_linebytes
operator|=
name|raster
expr_stmt|;
name|xdev
operator|->
name|mpr
operator|.
name|md_image
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|ulong
operator|)
name|base
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|pw_write
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|PIX_SRC
argument_list|,
operator|&
operator|(
name|xdev
operator|->
name|pr
operator|)
argument_list|,
operator|(
operator|(
operator|(
name|int
operator|)
name|base
operator|&
literal|1
operator|)
condition|?
name|sourcex
operator|+
literal|8
else|:
name|sourcex
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|notify_dispatch
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Draw a line */
end_comment

begin_function
name|int
name|sun_draw_line
parameter_list|(
specifier|register
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y1
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|pw_vector
argument_list|(
name|xdev
operator|->
name|pw
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|PIX_SRC
argument_list|,
name|color
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|notify_dispatch
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

