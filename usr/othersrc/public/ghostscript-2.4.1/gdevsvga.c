begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevsvga.c */
end_comment

begin_comment
comment|/* SuperVGA display drivers for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"dos_.h"
end_include

begin_typedef
typedef|typedef
name|union
name|REGS
name|registers
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gs.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USE_ASM
end_ifndef

begin_define
define|#
directive|define
name|USE_ASM
value|0
end_define

begin_comment
comment|/* don't use assembly language */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the short (integer) version of "transparent" color. */
end_comment

begin_comment
comment|/* ****** Depends on gx_no_color_index being all 1's. ******/
end_comment

begin_define
define|#
directive|define
name|no_color
value|((int)gx_no_color_index)
end_define

begin_comment
comment|/* Procedures */
end_comment

begin_comment
comment|/* See gxdevice.h for the definitions of the procedures. */
end_comment

begin_function_decl
name|private
name|dev_proc_close_device
parameter_list|(
name|svga_close
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_rgb_color
parameter_list|(
name|svga_map_rgb_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_color_rgb
parameter_list|(
name|svga_map_color_rgb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_fill_rectangle
parameter_list|(
name|svga_fill_rectangle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_mono
parameter_list|(
name|svga_copy_mono
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_copy_color
parameter_list|(
name|svga_copy_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_get_bits
parameter_list|(
name|svga_get_bits
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Type for frame buffer pointers. */
end_comment

begin_comment
comment|/*** Intimately tied to the 80x86 (x<2) addressing architecture. ***/
end_comment

begin_typedef
typedef|typedef
name|byte
name|far
modifier|*
name|fb_ptr
typedef|;
end_typedef

begin_comment
comment|/* The device descriptor */
end_comment

begin_typedef
typedef|typedef
name|struct
name|gx_device_svga_s
name|gx_device_svga
typedef|;
end_typedef

begin_struct
struct|struct
name|gx_device_svga_s
block|{
name|gx_device_common
expr_stmt|;
name|int
argument_list|(
operator|*
name|get_mode
argument_list|)
argument_list|(
name|P0
argument_list|()
argument_list|)
expr_stmt|;
name|void
argument_list|(
operator|*
name|set_mode
argument_list|)
argument_list|(
name|P1
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
operator|*
name|set_page
argument_list|)
argument_list|(
name|P3
argument_list|(
name|gx_device_svga
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|uint
name|raster
decl_stmt|;
comment|/* frame buffer bytes per line */
name|int
name|page
decl_stmt|;
comment|/* current page */
name|int
name|wnum_read
decl_stmt|,
name|wnum_write
decl_stmt|;
comment|/* window #s for read vs. write */
comment|/* Following are device-specific. */
union|union
block|{
struct|struct
block|{
name|void
argument_list|(
operator|*
name|bios_set_page
argument_list|)
argument_list|(
name|P2
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set-page function */
block|}
name|vesa
struct|;
struct|struct
block|{
name|int
name|select_reg
decl_stmt|;
comment|/* page-select register */
block|}
name|atiw
struct|;
struct|struct
block|{
name|int
name|et_model
decl_stmt|;
comment|/* 4 for ET4000, */
comment|/* 3 for ET3000 */
block|}
name|tseng
struct|;
block|}
name|info
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* The color map for dynamically assignable colors. */
end_comment

begin_define
define|#
directive|define
name|first_color_index
value|64
end_define

begin_decl_stmt
name|private
name|int
name|next_color_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ushort
name|dynamic_colors
index|[
literal|256
operator|-
name|first_color_index
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for casting gx_device argument */
end_comment

begin_define
define|#
directive|define
name|fb_dev
value|((gx_device_svga *)dev)
end_define

begin_comment
comment|/* Procedure records */
end_comment

begin_define
define|#
directive|define
name|svga_procs
parameter_list|(
name|open
parameter_list|)
value|{\ 	open, gx_default_get_initial_matrix,\ 	gx_default_sync_output, gx_default_output_page, svga_close,\ 	svga_map_rgb_color, svga_map_color_rgb,\ 	svga_fill_rectangle, gx_default_tile_rectangle,\ 	svga_copy_mono, svga_copy_color, gx_default_draw_line,\ 	svga_get_bits, gx_default_get_props, gx_default_put_props\ }
end_define

begin_comment
comment|/* The initial parameters map an appropriate fraction of */
end_comment

begin_comment
comment|/* the screen to an 8.5" x 11" coordinate space. */
end_comment

begin_comment
comment|/* This may or may not be what is desired! */
end_comment

begin_define
define|#
directive|define
name|svga_device
parameter_list|(
name|procs
parameter_list|,
name|name
parameter_list|,
name|get_mode
parameter_list|,
name|set_mode
parameter_list|,
name|set_page
parameter_list|)
value|{\ 	sizeof(gx_device_svga),\&procs,\ 	name,\ 	640, 480,
comment|/* screen size */
value|\ 	480 / 11.0, 480 / 11.0,
comment|/* resolution */
value|\ 	no_margins,\ 	dci_color(8, 31, 4),\ 	0,
comment|/* not opened yet */
value|\ 	get_mode, set_mode, set_page\    }
end_define

begin_comment
comment|/* Save the controller mode */
end_comment

begin_decl_stmt
name|private
name|int
name|svga_save_mode
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for validating rectangle parameters x and w. */
end_comment

begin_comment
comment|/* set_pixel_ptr implicitly validates y and h. */
end_comment

begin_define
define|#
directive|define
name|validate_rect
parameter_list|()
define|\
value|if ( w<= 0 ) return 0;\   if ( x< 0 || x + w> dev->width ) return -1
end_define

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_define
define|#
directive|define
name|regen
value|0xa000
end_define

begin_comment
comment|/* Construct a pointer for writing a pixel. */
end_comment

begin_comment
comment|/* Assume 64K pages, 64K granularity. */
end_comment

begin_define
define|#
directive|define
name|set_pixel_ptr
parameter_list|(
name|ptr
parameter_list|,
name|fbdev
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|wnum
parameter_list|)
define|\
value|{	ulong index = (ulong)(y) * fbdev->raster + (uint)(x);\ 	if ( (uint)(index>> 16) != fbdev->page )\ 	   {	if ( y< 0 || y>= fbdev->height ) return -1;\ 		(*fbdev->set_page)(fbdev, (fbdev->page = index>> 16), wnum);\ 	   }\ 	ptr = (fb_ptr)MK_PTR(regen, (ushort)index);\ }
end_define

begin_define
define|#
directive|define
name|set_pixel_write_ptr
parameter_list|(
name|ptr
parameter_list|,
name|fbdev
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|set_pixel_ptr(ptr, fbdev, x, y, fbdev->wnum_write)
end_define

begin_define
define|#
directive|define
name|set_pixel_read_ptr
parameter_list|(
name|ptr
parameter_list|,
name|fbdev
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|set_pixel_ptr(ptr, fbdev, x, y, fbdev->wnum_read)
end_define

begin_comment
comment|/* Table structure for looking up graphics modes. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
comment|/* "key" */
name|int
name|mode
decl_stmt|;
comment|/* "value" */
block|}
name|mode_info
typedef|;
end_typedef

begin_comment
comment|/* Find the graphics mode for a desired width and height. */
end_comment

begin_comment
comment|/* Return the graphics mode or -1. */
end_comment

begin_function
name|private
name|int
name|svga_find_mode
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|mode_info
name|_ds
modifier|*
name|mip
parameter_list|)
block|{
for|for
control|(
init|;
name|mip
operator|->
name|mode
operator|>=
literal|0
condition|;
name|mip
operator|++
control|)
block|{
if|if
condition|(
name|mip
operator|->
name|width
operator|==
name|fb_dev
operator|->
name|width
operator|&&
name|mip
operator|->
name|height
operator|==
name|fb_dev
operator|->
name|height
condition|)
return|return
name|mip
operator|->
name|mode
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the index for writing into the color DAC. */
end_comment

begin_define
define|#
directive|define
name|svga_dac_set_write_index
parameter_list|(
name|i
parameter_list|)
value|outportb(0x3c8, i)
end_define

begin_comment
comment|/* Write 6-bit R,G,B values into the color DAC. */
end_comment

begin_define
define|#
directive|define
name|svga_dac_write
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
define|\
value|(outportb(0x3c9, r), outportb(0x3c9, g), outportb(0x3c9, b))
end_define

begin_comment
comment|/* ------ Common procedures ------ */
end_comment

begin_comment
comment|/* Initialize the device structure and the DACs. */
end_comment

begin_function
name|private
name|int
name|svga_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|fb_dev
operator|->
name|raster
operator|=
name|fb_dev
operator|->
name|width
expr_stmt|;
name|fb_dev
operator|->
name|x_pixels_per_inch
operator|=
name|fb_dev
operator|->
name|y_pixels_per_inch
operator|=
name|fb_dev
operator|->
name|height
operator|/
literal|11.0
expr_stmt|;
comment|/* Set the display mode. */
if|if
condition|(
name|svga_save_mode
operator|<
literal|0
condition|)
name|svga_save_mode
operator|=
call|(
modifier|*
name|fb_dev
operator|->
name|get_mode
call|)
argument_list|()
expr_stmt|;
call|(
modifier|*
name|fb_dev
operator|->
name|set_mode
call|)
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Load the color DAC. */
name|svga_dac_set_write_index
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|64
condition|;
name|c
operator|++
control|)
block|{
specifier|static
name|byte
name|c2
index|[
literal|10
index|]
init|=
block|{
literal|0
block|,
literal|42
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
literal|63
block|}
decl_stmt|;
name|svga_dac_write
argument_list|(
name|c2
index|[
operator|(
name|c
operator|>>
literal|2
operator|)
operator|&
literal|9
index|]
argument_list|,
name|c2
index|[
operator|(
name|c
operator|>>
literal|1
operator|)
operator|&
literal|9
index|]
argument_list|,
name|c2
index|[
name|c
operator|&
literal|9
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize the dynamic color table. */
name|next_color_index
operator|=
name|first_color_index
expr_stmt|;
name|fb_dev
operator|->
name|page
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the device; reinitialize the display for text mode. */
end_comment

begin_function
name|private
name|int
name|svga_close
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|svga_save_mode
operator|>=
literal|0
condition|)
call|(
modifier|*
name|fb_dev
operator|->
name|set_mode
call|)
argument_list|(
name|svga_save_mode
argument_list|)
expr_stmt|;
name|svga_save_mode
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map a r-g-b color to a palette index. */
end_comment

begin_comment
comment|/* The first 64 entries of the color map are set */
end_comment

begin_comment
comment|/* for compatibility with the older display modes: */
end_comment

begin_comment
comment|/* these are indexed as 0.0.R0.G0.B0.R1.G1.B1. */
end_comment

begin_function
name|private
name|gx_color_index
name|svga_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|ushort
name|r
parameter_list|,
name|ushort
name|g
parameter_list|,
name|ushort
name|b
parameter_list|)
block|{
define|#
directive|define
name|cv_bits
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|(v>> (gx_color_value_bits - n))
name|ushort
name|r5
init|=
name|cv_bits
argument_list|(
name|r
argument_list|,
literal|5
argument_list|)
decl_stmt|,
name|g5
init|=
name|cv_bits
argument_list|(
name|g
argument_list|,
literal|5
argument_list|)
decl_stmt|,
name|b5
init|=
name|cv_bits
argument_list|(
name|b
argument_list|,
literal|5
argument_list|)
decl_stmt|;
specifier|static
name|byte
name|cube_bits
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|8
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|1
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|128
block|,
literal|9
block|}
decl_stmt|;
name|uint
name|cx
init|=
operator|(
operator|(
name|uint
operator|)
name|cube_bits
index|[
name|r5
index|]
operator|<<
literal|2
operator|)
operator|+
operator|(
operator|(
name|uint
operator|)
name|cube_bits
index|[
name|g5
index|]
operator|<<
literal|1
operator|)
operator|+
operator|(
name|uint
operator|)
name|cube_bits
index|[
name|b5
index|]
decl_stmt|;
name|ushort
name|rgb
decl_stmt|;
comment|/* Check for a color on the cube. */
if|if
condition|(
name|cx
operator|<
literal|64
condition|)
return|return
operator|(
name|gx_color_index
operator|)
name|cx
return|;
comment|/* Not on the cube, check the dynamic color table. */
name|rgb
operator|=
operator|(
name|r5
operator|<<
literal|10
operator|)
operator|+
operator|(
name|g5
operator|<<
literal|5
operator|)
operator|+
name|b5
expr_stmt|;
block|{
name|int
name|i
init|=
name|next_color_index
operator|-
name|first_color_index
decl_stmt|;
specifier|register
name|ushort
name|_ds
modifier|*
name|pdc
init|=
name|dynamic_colors
operator|+
name|i
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
operator|--
name|pdc
operator|==
name|rgb
condition|)
return|return
call|(
name|gx_color_index
call|)
argument_list|(
name|i
operator|+
name|first_color_index
argument_list|)
return|;
block|}
comment|/* Not on the cube, and not in the dynamic table. */
comment|/* Put in the dynamic table if space available. */
if|if
condition|(
name|next_color_index
operator|<
literal|255
condition|)
block|{
name|int
name|i
init|=
name|next_color_index
operator|++
decl_stmt|;
name|dynamic_colors
index|[
name|i
operator|-
name|first_color_index
index|]
operator|=
name|rgb
expr_stmt|;
name|svga_dac_set_write_index
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|svga_dac_write
argument_list|(
name|cv_bits
argument_list|(
name|r
argument_list|,
literal|6
argument_list|)
argument_list|,
name|cv_bits
argument_list|(
name|g
argument_list|,
literal|6
argument_list|)
argument_list|,
name|cv_bits
argument_list|(
name|b
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|gx_color_index
operator|)
name|i
return|;
block|}
comment|/* No space left, report failure. */
return|return
name|gx_no_color_index
return|;
block|}
end_function

begin_comment
comment|/* Map a color code to r-g-b. */
end_comment

begin_comment
comment|/* This routine must invert the transformation of the one above. */
end_comment

begin_comment
comment|/* Since this is practically never used, we just read the DAC. */
end_comment

begin_function
name|private
name|int
name|svga_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|ushort
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|uint
name|cval
decl_stmt|;
name|outportb
argument_list|(
literal|0x3c7
argument_list|,
operator|(
name|byte
operator|)
name|color
argument_list|)
expr_stmt|;
define|#
directive|define
name|dacin
parameter_list|()
value|(cval = inportb(0x3c9)>> 1,\   ((cval<< 11) + (cval<< 6) + (cval<< 1) + (cval>> 4))>>\    (16 - gx_color_value_bits))
name|prgb
index|[
literal|0
index|]
operator|=
name|dacin
argument_list|()
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
name|dacin
argument_list|()
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
name|dacin
argument_list|()
expr_stmt|;
undef|#
directive|undef
name|dacin
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a monochrome bitmap.  The colors are given explicitly. */
end_comment

begin_comment
comment|/* Color = gx_no_color_index means transparent (no effect on the image). */
end_comment

begin_function
name|private
name|int
name|svga_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|czero
parameter_list|,
name|gx_color_index
name|cone
parameter_list|)
block|{
specifier|register
name|int
name|xi
decl_stmt|;
name|uint
name|skip
init|=
name|fb_dev
operator|->
name|raster
operator|-
name|w
decl_stmt|;
name|int
name|yi
decl_stmt|;
name|fb_ptr
name|ptr
init|=
operator|(
name|fb_ptr
operator|)
literal|0
decl_stmt|;
name|byte
modifier|*
name|srow
init|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|3
operator|)
decl_stmt|;
name|uint
name|imask
init|=
literal|0x80
operator|>>
operator|(
name|sourcex
operator|&
literal|7
operator|)
decl_stmt|;
name|validate_rect
argument_list|()
expr_stmt|;
define|#
directive|define
name|izero
value|(int)czero
define|#
directive|define
name|ione
value|(int)cone
for|for
control|(
name|yi
operator|=
literal|0
init|;
name|yi
operator|<
name|h
condition|;
name|yi
operator|++
control|)
block|{
name|byte
modifier|*
name|sptr
init|=
name|srow
decl_stmt|;
name|uint
name|bits
init|=
operator|*
name|sptr
decl_stmt|;
specifier|register
name|uint
name|mask
init|=
name|imask
decl_stmt|;
if|if
condition|(
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|<=
name|skip
condition|)
name|set_pixel_write_ptr
argument_list|(
name|ptr
argument_list|,
name|fb_dev
argument_list|,
name|x
argument_list|,
name|y
operator|+
name|yi
argument_list|)
expr_stmt|;
for|for
control|(
name|xi
operator|=
literal|0
init|;
name|xi
operator|<
name|w
condition|;
name|xi
operator|++
control|)
block|{
if|if
condition|(
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|==
literal|0
condition|)
name|set_pixel_write_ptr
argument_list|(
name|ptr
argument_list|,
name|fb_dev
argument_list|,
name|x
operator|+
name|xi
argument_list|,
name|y
operator|+
name|yi
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|mask
condition|)
block|{
if|if
condition|(
name|ione
operator|!=
name|no_color
condition|)
operator|*
name|ptr
operator|=
operator|(
name|byte
operator|)
name|ione
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|izero
operator|!=
name|no_color
condition|)
operator|*
name|ptr
operator|=
operator|(
name|byte
operator|)
name|izero
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mask
operator|>>=
literal|1
operator|)
condition|)
name|mask
operator|=
literal|0x80
operator|,
name|bits
operator|=
operator|*
operator|++
name|sptr
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|ptr
operator|+=
name|skip
expr_stmt|;
name|srow
operator|+=
name|raster
expr_stmt|;
block|}
undef|#
directive|undef
name|izero
undef|#
directive|undef
name|ione
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a color pixelmap.  This is just like a bitmap, */
end_comment

begin_comment
comment|/* except that each pixel takes 8 bits instead of 1. */
end_comment

begin_function
name|private
name|int
name|svga_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|raster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|xi
decl_stmt|,
name|yi
decl_stmt|;
name|int
name|skip
init|=
name|raster
operator|-
name|w
decl_stmt|;
name|byte
modifier|*
name|sptr
init|=
name|base
operator|+
name|sourcex
decl_stmt|;
name|fb_ptr
name|ptr
decl_stmt|;
name|validate_rect
argument_list|()
expr_stmt|;
for|for
control|(
name|yi
operator|=
name|y
init|;
name|yi
operator|-
name|y
operator|<
name|h
condition|;
name|yi
operator|++
control|)
block|{
name|ptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|xi
operator|=
name|x
init|;
name|xi
operator|-
name|x
operator|<
name|w
condition|;
name|xi
operator|++
control|)
block|{
if|if
condition|(
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|==
literal|0
condition|)
name|set_pixel_write_ptr
argument_list|(
name|ptr
argument_list|,
name|fb_dev
argument_list|,
name|xi
argument_list|,
name|yi
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
name|sptr
operator|+=
name|skip
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill a rectangle. */
end_comment

begin_function
name|private
name|int
name|svga_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|uint
name|raster
init|=
name|fb_dev
operator|->
name|raster
decl_stmt|;
name|ushort
name|limit
init|=
operator|(
name|ushort
operator|)
operator|-
name|raster
decl_stmt|;
name|int
name|yi
decl_stmt|;
name|fb_ptr
name|ptr
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|+
name|w
operator|>
name|dev
operator|->
name|width
condition|)
return|return
operator|-
literal|1
return|;
comment|/* skip w */
name|set_pixel_write_ptr
argument_list|(
name|ptr
argument_list|,
name|fb_dev
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* Most fills are very small and don't cross a page boundary. */
name|yi
operator|=
name|h
expr_stmt|;
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
comment|/* no-op */
case|case
literal|1
case|:
while|while
condition|(
operator|--
name|yi
operator|>=
literal|0
operator|&&
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|<
name|limit
condition|)
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|color
operator|,
name|ptr
operator|+=
name|raster
expr_stmt|;
if|if
condition|(
operator|!
operator|++
name|yi
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|2
case|:
while|while
condition|(
operator|--
name|yi
operator|>=
literal|0
operator|&&
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|<
name|limit
condition|)
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
index|[
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|color
operator|,
name|ptr
operator|+=
name|raster
expr_stmt|;
if|if
condition|(
operator|!
operator|++
name|yi
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|3
case|:
while|while
condition|(
operator|--
name|yi
operator|>=
literal|0
operator|&&
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|<
name|limit
condition|)
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
index|[
literal|1
index|]
operator|=
name|ptr
index|[
literal|2
index|]
operator|=
operator|(
name|byte
operator|)
name|color
operator|,
name|ptr
operator|+=
name|raster
expr_stmt|;
if|if
condition|(
operator|!
operator|++
name|yi
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|4
case|:
while|while
condition|(
operator|--
name|yi
operator|>=
literal|0
operator|&&
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|<
name|limit
condition|)
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
index|[
literal|1
index|]
operator|=
name|ptr
index|[
literal|2
index|]
operator|=
name|ptr
index|[
literal|3
index|]
operator|=
operator|(
name|byte
operator|)
name|color
operator|,
name|ptr
operator|+=
name|raster
expr_stmt|;
if|if
condition|(
operator|!
operator|++
name|yi
condition|)
return|return
literal|0
return|;
break|break;
default|default:
if|if
condition|(
name|w
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|--
name|yi
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|<
name|limit
condition|)
block|{
name|memset
argument_list|(
name|ptr
argument_list|,
operator|(
name|byte
operator|)
name|color
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|raster
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
operator|<=
call|(
name|ushort
call|)
argument_list|(
operator|-
name|w
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|ptr
argument_list|,
operator|(
name|byte
operator|)
name|color
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|yi
operator|>
literal|0
condition|)
name|set_pixel_write_ptr
argument_list|(
name|ptr
argument_list|,
name|fb_dev
argument_list|,
name|x
argument_list|,
name|y
operator|+
name|h
operator|-
name|yi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint
name|left
init|=
operator|(
name|uint
operator|)
literal|0x10000
operator|-
name|PTR_OFF
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
operator|(
name|byte
operator|)
name|color
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|set_pixel_write_ptr
argument_list|(
name|ptr
argument_list|,
name|fb_dev
argument_list|,
name|x
operator|+
name|left
argument_list|,
name|y
operator|+
name|h
operator|-
literal|1
operator|-
name|yi
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
operator|(
name|byte
operator|)
name|color
argument_list|,
name|w
operator|-
name|left
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|raster
operator|-
name|left
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read scan lines back from the frame buffer. */
end_comment

begin_function
name|int
name|svga_get_bits
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|y
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|uint
name|size
parameter_list|,
name|int
name|pad_to_word
parameter_list|)
block|{
comment|/* We don't have to worry about padding, because we read back */
comment|/* a byte per pixel and the frame buffer width is always */
comment|/* a multiple of 8 pixels. */
name|uint
name|bytes_per_row
init|=
name|dev
operator|->
name|width
decl_stmt|;
name|uint
name|count
init|=
name|min
argument_list|(
name|dev
operator|->
name|height
operator|-
name|y
argument_list|,
name|size
operator|/
name|bytes_per_row
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|dest
init|=
name|data
decl_stmt|;
name|ushort
name|limit
init|=
operator|(
name|ushort
operator|)
operator|-
name|bytes_per_row
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|count
init|;
name|j
operator|--
condition|;
name|dest
operator|+=
name|bytes_per_row
operator|,
name|y
operator|++
control|)
block|{
name|fb_ptr
name|src
decl_stmt|;
name|set_pixel_read_ptr
argument_list|(
name|src
argument_list|,
name|fb_dev
argument_list|,
literal|0
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* The logic here is similar to fill_rectangle. */
if|if
condition|(
name|PTR_OFF
argument_list|(
name|src
argument_list|)
operator|<=
name|limit
condition|)
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes_per_row
argument_list|)
expr_stmt|;
else|else
block|{
name|uint
name|left
init|=
operator|(
name|uint
operator|)
literal|0x10000
operator|-
name|PTR_OFF
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|set_pixel_read_ptr
argument_list|(
name|src
argument_list|,
name|fb_dev
argument_list|,
name|left
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dest
operator|+
name|left
argument_list|,
name|src
argument_list|,
name|bytes_per_row
operator|-
name|left
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* ------ The VESA device ------ */
end_comment

begin_function_decl
name|private
name|dev_proc_open_device
parameter_list|(
name|vesa_open
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|vesa_procs
init|=
name|svga_procs
argument_list|(
name|vesa_open
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|vesa_get_mode
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|vesa_set_mode
argument_list|(
name|P1
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|vesa_set_page
argument_list|(
name|P3
argument_list|(
name|gx_device_svga
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_svga
name|gs_vesa_device
init|=
name|svga_device
argument_list|(
name|vesa_procs
argument_list|,
literal|"vesa"
argument_list|,
name|vesa_get_mode
argument_list|,
name|vesa_set_mode
argument_list|,
name|vesa_set_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the structure for information returned by the BIOS. */
end_comment

begin_define
define|#
directive|define
name|bits_include
parameter_list|(
name|a
parameter_list|,
name|m
parameter_list|)
value|!(~(a)& (m))
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|m_supported
init|=
literal|1
block|,
name|m_graphics
init|=
literal|0x10
block|}
name|mode_attribute
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|w_supported
init|=
literal|1
block|,
name|w_readable
init|=
literal|2
block|,
name|w_writable
init|=
literal|4
block|}
name|win_attribute
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|ushort
name|mode_attributes
decl_stmt|;
name|byte
name|win_a_attributes
decl_stmt|;
name|byte
name|win_b_attributes
decl_stmt|;
name|ushort
name|win_granularity
decl_stmt|;
name|ushort
name|win_size
decl_stmt|;
name|ushort
name|win_a_segment
decl_stmt|;
name|ushort
name|win_b_segment
decl_stmt|;
name|void
argument_list|(
operator|*
name|win_func_ptr
argument_list|)
argument_list|(
name|P2
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ushort
name|bytes_per_line
decl_stmt|;
comment|/* Optional information */
name|ushort
name|x_resolution
decl_stmt|;
name|ushort
name|y_resolution
decl_stmt|;
name|byte
name|x_char_size
decl_stmt|;
name|byte
name|y_char_size
decl_stmt|;
name|byte
name|number_of_planes
decl_stmt|;
name|byte
name|bits_per_pixel
decl_stmt|;
name|byte
name|number_of_banks
decl_stmt|;
name|byte
name|memory_model
decl_stmt|;
name|byte
name|bank_size
decl_stmt|;
block|}
name|vesa_info
typedef|;
end_typedef

begin_comment
comment|/* Read the device mode */
end_comment

begin_function
name|private
name|int
name|vesa_get_mode
parameter_list|()
block|{
name|registers
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x4f
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0x03
expr_stmt|;
name|int86
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
name|regs
operator|.
name|rshort
operator|.
name|bx
return|;
block|}
end_function

begin_comment
comment|/* Set the device mode */
end_comment

begin_function
name|private
name|void
name|vesa_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|registers
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x4f
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0x02
expr_stmt|;
name|regs
operator|.
name|rshort
operator|.
name|bx
operator|=
name|mode
expr_stmt|;
name|int86
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read information about a device mode */
end_comment

begin_function
name|private
name|int
name|vesa_get_info
parameter_list|(
name|int
name|mode
parameter_list|,
name|vesa_info
name|_ss
modifier|*
name|info
parameter_list|)
block|{
name|registers
name|regs
decl_stmt|;
name|struct
name|SREGS
name|sregs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x4f
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0x01
expr_stmt|;
name|regs
operator|.
name|rshort
operator|.
name|cx
operator|=
name|mode
expr_stmt|;
name|regs
operator|.
name|rshort
operator|.
name|di
operator|=
name|PTR_OFF
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|segread
argument_list|(
operator|&
name|sregs
argument_list|)
expr_stmt|;
name|sregs
operator|.
name|es
operator|=
name|sregs
operator|.
name|ss
expr_stmt|;
name|int86x
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|sregs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|regs
operator|.
name|h
operator|.
name|ah
operator|==
literal|0
operator|&&
name|regs
operator|.
name|h
operator|.
name|al
operator|==
literal|0x4f
condition|)
name|dprintf8
argument_list|(
literal|"vesa_get_info(%x): ma=%x wa=%x/%x wg=%x ws=%x wseg=%x/%x\n"
argument_list|,
name|mode
argument_list|,
name|info
operator|->
name|mode_attributes
argument_list|,
name|info
operator|->
name|win_a_attributes
argument_list|,
name|info
operator|->
name|win_b_attributes
argument_list|,
name|info
operator|->
name|win_granularity
argument_list|,
name|info
operator|->
name|win_size
argument_list|,
name|info
operator|->
name|win_a_segment
argument_list|,
name|info
operator|->
name|win_b_segment
argument_list|)
expr_stmt|;
else|else
name|dprintf3
argument_list|(
literal|"vesa_get_info(%x) failed: ah=%x al=%x\n"
argument_list|,
name|mode
argument_list|,
name|regs
operator|.
name|h
operator|.
name|ah
argument_list|,
name|regs
operator|.
name|h
operator|.
name|al
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|regs
operator|.
name|h
operator|.
name|ah
operator|==
literal|0
operator|&&
name|regs
operator|.
name|h
operator|.
name|al
operator|==
literal|0x4f
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the graphics mode. */
end_comment

begin_function
name|private
name|int
name|vesa_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* Select the proper video mode */
block|{
name|vesa_info
name|info
decl_stmt|;
specifier|static
name|mode_info
name|mode_table
index|[
literal|6
index|]
init|=
block|{
block|{
literal|640
block|,
literal|400
block|,
literal|0x100
block|}
block|,
block|{
literal|640
block|,
literal|480
block|,
literal|0x101
block|}
block|,
block|{
literal|800
block|,
literal|600
block|,
literal|0x103
block|}
block|,
block|{
literal|1024
block|,
literal|768
block|,
literal|0x105
block|}
block|,
block|{
literal|1280
block|,
literal|1024
block|,
literal|0x107
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
name|mode_info
name|_ds
modifier|*
name|mip
decl_stmt|;
for|for
control|(
name|mip
operator|=
name|mode_table
init|;
name|mip
operator|->
name|mode
operator|>=
literal|0
condition|;
name|mip
operator|++
control|)
block|{
if|if
condition|(
name|mip
operator|->
name|width
operator|==
name|fb_dev
operator|->
name|width
operator|&&
name|mip
operator|->
name|height
operator|==
name|fb_dev
operator|->
name|height
operator|&&
name|vesa_get_info
argument_list|(
name|mip
operator|->
name|mode
argument_list|,
operator|&
name|info
argument_list|)
operator|>=
literal|0
operator|&&
name|bits_include
argument_list|(
name|info
operator|.
name|mode_attributes
argument_list|,
name|m_supported
operator||
name|m_graphics
argument_list|)
operator|&&
name|info
operator|.
name|win_granularity
operator|==
literal|64
operator|&&
name|info
operator|.
name|win_size
operator|==
literal|64
operator|&&
name|bits_include
argument_list|(
name|info
operator|.
name|win_a_attributes
argument_list|,
name|w_supported
argument_list|)
operator|&&
name|info
operator|.
name|win_a_segment
operator|==
name|regen
condition|)
block|{
comment|/* Make sure we can both read& write. */
comment|/* Initialize for the default case. */
name|fb_dev
operator|->
name|wnum_read
operator|=
literal|0
expr_stmt|;
name|fb_dev
operator|->
name|wnum_write
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits_include
argument_list|(
name|info
operator|.
name|win_a_attributes
argument_list|,
name|w_readable
operator||
name|w_writable
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|info
operator|.
name|win_b_segment
operator|==
name|regen
operator|&&
name|bits_include
argument_list|(
name|info
operator|.
name|win_b_attributes
argument_list|,
name|w_supported
argument_list|)
operator|&&
name|bits_include
argument_list|(
name|info
operator|.
name|win_a_attributes
operator||
name|info
operator|.
name|win_b_attributes
argument_list|,
name|w_readable
operator||
name|w_writable
argument_list|)
condition|)
block|{
comment|/* Two superimposed windows. */
if|if
condition|(
operator|!
name|bits_include
argument_list|(
name|info
operator|.
name|win_a_attributes
argument_list|,
name|w_writable
argument_list|)
condition|)
name|fb_dev
operator|->
name|wnum_write
operator|=
literal|1
expr_stmt|;
else|else
name|fb_dev
operator|->
name|wnum_read
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|mip
operator|->
name|mode
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* mode not available */
name|fb_dev
operator|->
name|info
operator|.
name|vesa
operator|.
name|bios_set_page
operator|=
name|info
operator|.
name|win_func_ptr
expr_stmt|;
return|return
name|svga_open
argument_list|(
name|dev
argument_list|,
name|mip
operator|->
name|mode
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set the current display page. */
end_comment

begin_function
name|private
name|void
name|vesa_set_page
parameter_list|(
name|gx_device_svga
modifier|*
name|dev
parameter_list|,
name|int
name|pn
parameter_list|,
name|int
name|wnum
parameter_list|)
block|{
if|#
directive|if
name|USE_ASM
specifier|extern
name|void
name|vesa_call_set_page
argument_list|(
name|P3
argument_list|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P2
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|info
operator|.
name|vesa
operator|.
name|bios_set_page
operator|!=
name|NULL
condition|)
name|vesa_call_set_page
argument_list|(
name|dev
operator|->
name|info
operator|.
name|vesa
operator|.
name|bios_set_page
argument_list|,
name|pn
argument_list|,
name|wnum
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|registers
name|regs
decl_stmt|;
name|regs
operator|.
name|rshort
operator|.
name|dx
operator|=
name|pn
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x4f
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|5
expr_stmt|;
name|regs
operator|.
name|rshort
operator|.
name|bx
operator|=
name|wnum
expr_stmt|;
name|int86
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------ The ATI Wonder device ------ */
end_comment

begin_function_decl
name|private
name|dev_proc_open_device
parameter_list|(
name|atiw_open
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|atiw_procs
init|=
name|svga_procs
argument_list|(
name|atiw_open
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|atiw_get_mode
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|atiw_set_mode
argument_list|(
name|P1
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|atiw_set_page
argument_list|(
name|P3
argument_list|(
name|gx_device_svga
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_svga
name|gs_atiw_device
init|=
name|svga_device
argument_list|(
name|atiw_procs
argument_list|,
literal|"atiw"
argument_list|,
name|atiw_get_mode
argument_list|,
name|atiw_set_mode
argument_list|,
name|atiw_set_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the device mode */
end_comment

begin_function
name|private
name|int
name|atiw_get_mode
parameter_list|()
block|{
name|registers
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0xf
expr_stmt|;
name|int86
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
name|regs
operator|.
name|h
operator|.
name|al
return|;
block|}
end_function

begin_comment
comment|/* Set the device mode */
end_comment

begin_function
name|private
name|void
name|atiw_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|registers
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
name|mode
expr_stmt|;
name|int86
argument_list|(
literal|0x10
argument_list|,
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the graphics mode. */
end_comment

begin_function
name|private
name|int
name|atiw_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
comment|/* Select the proper video mode */
block|{
specifier|static
name|mode_info
name|mode_table
index|[
literal|4
index|]
init|=
block|{
block|{
literal|640
block|,
literal|400
block|,
literal|0x61
block|}
block|,
block|{
literal|640
block|,
literal|480
block|,
literal|0x62
block|}
block|,
block|{
literal|800
block|,
literal|600
block|,
literal|0x63
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
name|int
name|mode
init|=
name|svga_find_mode
argument_list|(
name|dev
argument_list|,
name|mode_table
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* mode not available */
name|fb_dev
operator|->
name|info
operator|.
name|atiw
operator|.
name|select_reg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|MK_PTR
argument_list|(
literal|0xc000
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
return|return
name|svga_open
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set the current display page. */
end_comment

begin_function
name|private
name|void
name|atiw_set_page
parameter_list|(
name|gx_device_svga
modifier|*
name|dev
parameter_list|,
name|int
name|pn
parameter_list|,
name|int
name|wnum
parameter_list|)
block|{
name|int
name|select_reg
init|=
name|dev
operator|->
name|info
operator|.
name|atiw
operator|.
name|select_reg
decl_stmt|;
name|byte
name|reg
decl_stmt|;
name|disable
argument_list|()
expr_stmt|;
name|outportb
argument_list|(
name|select_reg
argument_list|,
literal|0xb2
argument_list|)
expr_stmt|;
name|reg
operator|=
name|inportb
argument_list|(
name|select_reg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outportb
argument_list|(
name|select_reg
argument_list|,
literal|0xb2
argument_list|)
expr_stmt|;
name|outportb
argument_list|(
name|select_reg
operator|+
literal|1
argument_list|,
operator|(
name|reg
operator|&
literal|0xe1
operator|)
operator|+
operator|(
name|pn
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ The Tseng Labs ET3000/4000 device ------ */
end_comment

begin_function_decl
name|private
name|dev_proc_open_device
parameter_list|(
name|tseng_open
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|tseng_procs
init|=
name|svga_procs
argument_list|(
name|tseng_open
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We can use the tseng_get/set_mode procedures. */
end_comment

begin_decl_stmt
name|private
name|void
name|tseng_set_page
argument_list|(
name|P3
argument_list|(
name|gx_device_svga
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_svga
name|gs_tseng_device
init|=
name|svga_device
argument_list|(
name|tseng_procs
argument_list|,
literal|"tseng"
argument_list|,
name|atiw_get_mode
argument_list|,
name|atiw_set_mode
argument_list|,
name|tseng_set_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the graphics mode. */
end_comment

begin_function
name|private
name|int
name|tseng_open
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|fb_dev
operator|->
name|wnum_read
operator|=
literal|1
expr_stmt|;
name|fb_dev
operator|->
name|wnum_write
operator|=
literal|0
expr_stmt|;
comment|/* Select the proper video mode */
block|{
specifier|static
name|mode_info
name|mode_table
index|[
literal|5
index|]
init|=
block|{
block|{
literal|640
block|,
literal|350
block|,
literal|0x2d
block|}
block|,
block|{
literal|640
block|,
literal|480
block|,
literal|0x2e
block|}
block|,
block|{
literal|800
block|,
literal|600
block|,
literal|0x30
block|}
block|,
block|{
literal|1024
block|,
literal|768
block|,
literal|0x38
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
name|int
name|mode
init|=
name|svga_find_mode
argument_list|(
name|dev
argument_list|,
name|mode_table
argument_list|)
decl_stmt|;
name|fb_ptr
name|p0
init|=
operator|(
name|fb_ptr
operator|)
name|MK_PTR
argument_list|(
name|regen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* mode not available */
comment|/* Figure out whether we have an ET3000 or an ET4000 */
comment|/* by playing with the segment register. */
name|outportb
argument_list|(
literal|0x3cd
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
literal|4
expr_stmt|;
comment|/* byte 0, page 4 */
name|outportb
argument_list|(
literal|0x3cd
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
literal|3
expr_stmt|;
comment|/* byte 0, page 0 */
name|fb_dev
operator|->
name|info
operator|.
name|tseng
operator|.
name|et_model
operator|=
operator|*
name|p0
expr_stmt|;
comment|/* read page 0 if ET3000, */
comment|/* page 4 if ET4000 */
return|return
name|svga_open
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set the current display page. */
end_comment

begin_function
name|private
name|void
name|tseng_set_page
parameter_list|(
name|gx_device_svga
modifier|*
name|dev
parameter_list|,
name|int
name|pn
parameter_list|,
name|int
name|wnum
parameter_list|)
block|{
comment|/* The ET3000 has read page = 5:3, write page = 2:0; */
comment|/* the ET4000 has read page = 7:4, write page = 3:0. */
name|int
name|shift
init|=
name|dev
operator|->
name|info
operator|.
name|tseng
operator|.
name|et_model
decl_stmt|;
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|wnum
condition|)
name|pn
operator|<<=
name|shift
operator|,
name|mask
operator|<<=
name|shift
expr_stmt|;
name|outportb
argument_list|(
literal|0x3cd
argument_list|,
operator|(
name|inportb
argument_list|(
literal|0x3cd
argument_list|)
operator|&
operator|~
name|mask
operator|)
operator|+
name|pn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

