begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zfile.c */
end_comment

begin_comment
comment|/* Non-I/O file operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_comment
comment|/* for filenameforall, file_close */
end_comment

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_comment
comment|/* for restore */
end_comment

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_comment
comment|/* must come after stream.h */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|int
name|lib_file_open
argument_list|(
name|P6
argument_list|(
specifier|const
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
name|uint
operator|*
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|file_open
argument_list|(
name|P5
argument_list|(
specifier|const
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|ref
operator|*
argument_list|,
name|stream
operator|*
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|file_close
argument_list|(
name|P2
argument_list|(
name|ref
operator|*
argument_list|,
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|open_std_file
argument_list|(
name|P3
argument_list|(
name|os_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In zfileio.c */
end_comment

begin_decl_stmt
name|es_ptr
name|zget_current_file
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported from gs.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|gs_lib_paths
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search path list, */
end_comment

begin_comment
comment|/* terminated by a null pointer */
end_comment

begin_comment
comment|/* The chain of all open files.  We need this only */
end_comment

begin_comment
comment|/* so that we can do the right thing for restore (and GC someday). */
end_comment

begin_decl_stmt
name|private
name|ref
name|all_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* t_file */
end_comment

begin_define
define|#
directive|define
name|file_list
value|all_files.value.pfile
end_define

begin_comment
comment|/* File buffer sizes.  For real files, this is arbitrary, */
end_comment

begin_comment
comment|/* since the C library does its own buffering in addition. */
end_comment

begin_comment
comment|/* stdout and stderr use smaller buffers, */
end_comment

begin_comment
comment|/* on the assumption that they are usually not real files. */
end_comment

begin_comment
comment|/* The buffer size for type 1 encrypted files is NOT arbitrary: */
end_comment

begin_comment
comment|/* it must be at most 512. */
end_comment

begin_define
define|#
directive|define
name|buffer_size
value|512
end_define

begin_comment
comment|/* Standard file objects: */
end_comment

begin_comment
comment|/* 0 is stdin, 1 is stdout, 2 is stderr, 3 is lineedit, 4 is statementedit */
end_comment

begin_define
define|#
directive|define
name|num_std_files
value|5
end_define

begin_decl_stmt
name|stream
name|invalid_file_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|byte
define|#
directive|define
name|stdin_buf_size
value|1
name|stdin_buf
index|[
name|stdin_buf_size
index|]
decl_stmt|,
define|#
directive|define
name|stdout_buf_size
value|128
name|stdout_buf
index|[
name|stdout_buf_size
index|]
decl_stmt|,
define|#
directive|define
name|stderr_buf_size
value|128
name|stderr_buf
index|[
name|stderr_buf_size
index|]
decl_stmt|,
define|#
directive|define
name|lineedit_buf_size
value|160
name|lineedit_buf
index|[
name|lineedit_buf_size
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statementedit is equivalent to lineedit for now */
end_comment

begin_decl_stmt
name|stream
name|std_files
index|[
name|num_std_files
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
specifier|const
name|char
modifier|*
name|std_file_names
index|[
name|num_std_files
index|]
init|=
block|{
literal|"%stdin"
block|,
literal|"%stdout"
block|,
literal|"%stderr"
block|,
literal|"%lineedit"
block|,
literal|"%statementedit"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|std_file_attrs
index|[
name|num_std_files
index|]
init|=
block|{
name|a_read
operator|+
name|a_execute
block|,
name|a_write
operator|+
name|a_execute
block|,
name|a_write
operator|+
name|a_execute
block|,
name|a_read
operator|+
name|a_execute
block|,
name|a_read
operator|+
name|a_execute
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the file table */
end_comment

begin_function
name|private
name|void
name|zfile_init
parameter_list|()
block|{
comment|/* Create files for stdin, stdout, and stderr. */
comment|/****** stdin IS NOT IMPLEMENTED PROPERLY ******/
comment|/* Note that we use gs_out instead of stdout. */
name|sread_file
argument_list|(
operator|&
name|std_files
index|[
literal|0
index|]
argument_list|,
name|stdin
argument_list|,
name|stdin_buf
argument_list|,
name|stdin_buf_size
argument_list|)
expr_stmt|;
name|std_files
index|[
literal|0
index|]
operator|.
name|can_close
operator|=
literal|0
expr_stmt|;
name|swrite_file
argument_list|(
operator|&
name|std_files
index|[
literal|1
index|]
argument_list|,
name|gs_out
argument_list|,
name|stdout_buf
argument_list|,
name|stdout_buf_size
argument_list|)
expr_stmt|;
name|std_files
index|[
literal|1
index|]
operator|.
name|can_close
operator|=
literal|0
expr_stmt|;
name|swrite_file
argument_list|(
operator|&
name|std_files
index|[
literal|2
index|]
argument_list|,
name|stderr
argument_list|,
name|stderr_buf
argument_list|,
name|stderr_buf_size
argument_list|)
expr_stmt|;
name|std_files
index|[
literal|2
index|]
operator|.
name|can_close
operator|=
literal|0
expr_stmt|;
name|make_tav
argument_list|(
operator|&
name|all_files
argument_list|,
name|t_file
argument_list|,
literal|0
argument_list|,
name|pfile
argument_list|,
operator|(
name|stream
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|s_disable
argument_list|(
operator|&
name|invalid_file_entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* file */
end_comment

begin_function
name|int
name|zfile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|char
name|file_access
index|[
literal|3
index|]
decl_stmt|;
name|ref
name|fname
decl_stmt|;
name|int
name|code
decl_stmt|;
name|stream
modifier|*
name|s
decl_stmt|;
name|fname
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|check_type
argument_list|(
name|fname
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|/****** 	case 2: 		if ( op->value.bytes[1] != '+' ) 			return e_invalidfileaccess; 		file_access[1] = '+'; 		file_access[2] = 0; 		break;  ******/
case|case
literal|1
case|:
name|file_access
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|e_invalidfileaccess
return|;
block|}
switch|switch
condition|(
operator|*
name|op
operator|->
name|value
operator|.
name|bytes
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'w'
case|:
comment|/****** case 'a': ******/
break|break;
default|default:
return|return
name|e_invalidfileaccess
return|;
block|}
name|file_access
index|[
literal|0
index|]
operator|=
operator|*
name|op
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
name|code
operator|=
name|open_std_file
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|file_access
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* successful open */
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
default|default:
comment|/* unsuccessful open */
return|return
name|code
return|;
case|case
name|e_undefinedfilename
case|:
comment|/* not a %file */
empty_stmt|;
block|}
name|code
operator|=
name|file_open
argument_list|(
name|fname
operator|.
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
operator|&
name|fname
argument_list|)
argument_list|,
name|file_access
argument_list|,
name|op
operator|-
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* closefile */
end_comment

begin_function
name|int
name|zclosefile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_file
argument_list|(
name|s
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|can_close
operator|==
literal|0
condition|)
return|return
name|e_invalidaccess
return|;
comment|/* can't close std file */
if|if
condition|(
operator|(
name|code
operator|=
name|file_close
argument_list|(
name|op
argument_list|,
name|s
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Level 2 extensions ------ */
end_comment

begin_comment
comment|/* deletefile */
end_comment

begin_function
name|int
name|zdeletefile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|str
operator|=
name|ref_to_string
argument_list|(
name|op
argument_list|,
literal|"deletefile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|stat
operator|=
name|unlink
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
name|str
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"deletefile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
literal|0
condition|)
return|return
name|e_ioerror
return|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* filenameforall */
end_comment

begin_decl_stmt
name|private
name|int
name|file_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_file_continue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zfilenameforall
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|file_enum
modifier|*
name|pfen
decl_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_proc
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|check_read_type
argument_list|(
name|op
index|[
operator|-
literal|2
index|]
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
comment|/* Push a mark, the pattern, the scratch string, the enumerator, */
comment|/* and the procedure, and invoke the continuation. */
name|check_estack
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|pfen
operator|=
name|gp_enumerate_files_init
argument_list|(
operator|(
name|char
operator|*
operator|)
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
operator|-
literal|2
argument_list|)
argument_list|,
name|alloc
argument_list|,
name|alloc_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfen
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|mark_estack
argument_list|(
name|es_for
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
name|op
index|[
operator|-
literal|2
index|]
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
operator|*
name|op
expr_stmt|;
operator|++
name|esp
expr_stmt|;
name|make_tasv
argument_list|(
name|esp
argument_list|,
name|t_string
argument_list|,
name|a_read
operator|+
name|a_execute
operator|+
name|a_executable
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|pfen
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|pop
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|3
expr_stmt|;
return|return
name|file_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator for enumerating files */
end_comment

begin_function
name|private
name|int
name|file_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|pscratch
init|=
name|esp
operator|-
literal|2
decl_stmt|;
name|file_enum
modifier|*
name|pfen
init|=
operator|(
name|file_enum
operator|*
operator|)
name|esp
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|bytes
decl_stmt|;
name|uint
name|len
init|=
name|r_size
argument_list|(
name|pscratch
argument_list|)
decl_stmt|;
name|uint
name|code
init|=
name|gp_enumerate_files_next
argument_list|(
name|pfen
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pscratch
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
operator|~
operator|(
name|uint
operator|)
literal|0
condition|)
comment|/* all done */
block|{
name|gp_enumerate_files_close
argument_list|(
name|pfen
argument_list|)
expr_stmt|;
name|esp
operator|-=
literal|4
expr_stmt|;
comment|/* pop mark, scatch, pfen, proc */
return|return
name|o_pop_estack
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|>
name|len
condition|)
comment|/* overran string */
block|{
name|gp_enumerate_files_close
argument_list|(
name|pfen
argument_list|)
expr_stmt|;
return|return
name|e_rangecheck
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|string_match
argument_list|(
name|pscratch
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|code
argument_list|,
name|pscratch
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
operator|&
name|pscratch
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|,
name|gp_file_names_ignore_case
argument_list|)
condition|)
block|{
comment|/* Enumerator was too liberal, ignore this one. */
name|push_op_estack
argument_list|(
name|file_continue
argument_list|,
name|i_file_continue
argument_list|)
expr_stmt|;
comment|/* come again */
return|return
name|o_push_estack
return|;
block|}
else|else
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ref_assign
argument_list|(
name|op
argument_list|,
name|pscratch
argument_list|)
expr_stmt|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|file_continue
argument_list|,
name|i_file_continue
argument_list|)
expr_stmt|;
comment|/* come again */
operator|*
operator|++
name|esp
operator|=
name|pscratch
index|[
literal|2
index|]
expr_stmt|;
comment|/* proc */
return|return
name|o_push_estack
return|;
block|}
block|}
end_function

begin_comment
comment|/* renamefile */
end_comment

begin_function
name|int
name|zrenamefile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|char
modifier|*
name|str1
init|=
literal|0
decl_stmt|,
modifier|*
name|str2
init|=
literal|0
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|check_read_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|str1
operator|=
name|ref_to_string
argument_list|(
name|op
operator|-
literal|1
argument_list|,
literal|"renamefile(from)"
argument_list|)
expr_stmt|;
name|str2
operator|=
name|ref_to_string
argument_list|(
name|op
argument_list|,
literal|"renamefile(to)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str1
operator|!=
literal|0
operator|&&
name|str2
operator|!=
literal|0
operator|&&
name|rename
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str1
operator|!=
literal|0
condition|)
name|alloc_free
argument_list|(
name|str1
argument_list|,
name|r_size
argument_list|(
name|op
operator|-
literal|1
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"renamefile(from)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
operator|!=
literal|0
condition|)
name|alloc_free
argument_list|(
name|str2
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"renamefile(to)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Ghostscript extensions ------ */
end_comment

begin_comment
comment|/* findlibfile */
end_comment

begin_function
name|int
name|zfindlibfile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
define|#
directive|define
name|maxclen
value|200
name|byte
name|cname
index|[
name|maxclen
index|]
decl_stmt|;
name|uint
name|clen
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|code
operator|=
name|open_std_file
argument_list|(
name|op
argument_list|,
literal|"r"
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* successful open */
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
default|default:
comment|/* unsuccessful open */
return|return
name|code
return|;
case|case
name|e_undefinedfilename
case|:
comment|/* not a %file */
empty_stmt|;
block|}
name|code
operator|=
name|lib_file_open
argument_list|(
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|,
name|cname
argument_list|,
name|maxclen
argument_list|,
operator|&
name|clen
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|byte
modifier|*
name|cstr
init|=
operator|(
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|clen
argument_list|,
literal|1
argument_list|,
literal|"findlibfile"
argument_list|)
decl_stmt|;
if|if
condition|(
name|cstr
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|memcpy
argument_list|(
name|cstr
argument_list|,
name|cname
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|op
index|[
operator|-
literal|1
index|]
operator|=
name|op
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|make_tasv
argument_list|(
name|op
operator|-
literal|2
argument_list|,
name|t_string
argument_list|,
name|a_all
argument_list|,
name|clen
argument_list|,
name|bytes
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zfile_op_defs
index|[]
init|=
block|{
block|{
literal|"1closefile"
block|,
name|zclosefile
block|}
block|,
block|{
literal|"1deletefile"
block|,
name|zdeletefile
block|}
block|,
block|{
literal|"2file"
block|,
name|zfile
block|}
block|,
block|{
literal|"3filenameforall"
block|,
name|zfilenameforall
block|}
block|,
block|{
literal|"1findlibfile"
block|,
name|zfindlibfile
block|}
block|,
block|{
literal|"2renamefile"
block|,
name|zrenamefile
block|}
block|,
comment|/* Internal operators */
block|{
literal|"0%file_continue"
block|,
name|file_continue
block|,
operator|&
name|i_file_continue
block|}
block|,
name|op_def_end
argument_list|(
argument|zfile_init
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Non-operator routines ------ */
end_comment

begin_comment
comment|/* Open a file, using the search paths if necessary. */
end_comment

begin_comment
comment|/* The startup code calls this to open the initialization file gs_init.ps. */
end_comment

begin_function
name|int
name|lib_file_open
parameter_list|(
specifier|const
name|byte
modifier|*
name|fname
parameter_list|,
name|uint
name|len
parameter_list|,
name|byte
modifier|*
name|cname
parameter_list|,
name|uint
name|max_clen
parameter_list|,
name|uint
modifier|*
name|pclen
parameter_list|,
name|ref
modifier|*
name|pfile
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|char
modifier|*
modifier|*
name|ppath
decl_stmt|;
name|stream
modifier|*
name|s
decl_stmt|;
name|code
operator|=
name|file_open
argument_list|(
name|fname
argument_list|,
name|len
argument_list|,
literal|"r"
argument_list|,
name|pfile
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|cname
argument_list|,
name|fname
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|pclen
operator|=
name|len
expr_stmt|;
return|return
name|code
return|;
block|}
if|if
condition|(
name|gp_file_name_is_absolute
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|fname
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|e_undefinedfilename
return|;
comment|/* Go through the list of search paths */
for|for
control|(
name|ppath
operator|=
name|gs_lib_paths
init|;
operator|*
name|ppath
operator|!=
literal|0
condition|;
name|ppath
operator|++
control|)
block|{
name|char
modifier|*
name|path
init|=
operator|*
name|ppath
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Find the end of the next path */
name|char
modifier|*
name|npath
init|=
name|path
decl_stmt|;
name|uint
name|plen
decl_stmt|;
name|char
modifier|*
name|cstr
decl_stmt|;
name|uint
name|clen
decl_stmt|;
while|while
condition|(
operator|*
name|npath
operator|!=
literal|0
operator|&&
operator|*
name|npath
operator|!=
name|gp_file_name_list_separator
condition|)
name|npath
operator|++
expr_stmt|;
name|plen
operator|=
name|npath
operator|-
name|path
expr_stmt|;
name|cstr
operator|=
name|gp_file_name_concat_string
argument_list|(
name|path
argument_list|,
name|plen
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|fname
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Concatenate the prefix, combiner, and file name. */
name|clen
operator|=
name|plen
operator|+
name|strlen
argument_list|(
name|cstr
argument_list|)
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|clen
operator|<=
name|max_clen
condition|)
comment|/* otherwise punt */
block|{
name|memcpy
argument_list|(
name|cname
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|path
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cname
operator|+
name|plen
argument_list|,
name|cstr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cname
operator|+
name|clen
operator|-
name|len
argument_list|,
name|fname
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|pclen
operator|=
name|clen
expr_stmt|;
name|code
operator|=
name|file_open
argument_list|(
name|cname
argument_list|,
name|clen
argument_list|,
literal|"r"
argument_list|,
name|pfile
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
return|return
name|code
return|;
block|}
comment|/****** NYI ******/
if|if
condition|(
operator|!
operator|*
name|npath
condition|)
break|break;
name|path
operator|=
name|npath
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Open a file and create a file object. */
end_comment

begin_comment
comment|/* Return 0 if successful, error code if not. */
end_comment

begin_comment
comment|/* If fname==0, set up the file entry, stream, and buffer, */
end_comment

begin_comment
comment|/* but don't open an OS file or initialize the stream. */
end_comment

begin_comment
comment|/* The filter routines also use this. */
end_comment

begin_function
name|int
name|file_open
parameter_list|(
specifier|const
name|byte
modifier|*
name|fname
parameter_list|,
name|uint
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|file_access
parameter_list|,
name|ref
modifier|*
name|pfile
parameter_list|,
name|stream
modifier|*
modifier|*
name|ps
parameter_list|)
block|{
name|byte
modifier|*
name|buffer
decl_stmt|;
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|buffer_size
condition|)
return|return
name|e_limitcheck
return|;
comment|/* we copy the file name into the buffer */
comment|/* Allocate the stream first, since it persists */
comment|/* even after the file has been closed. */
name|s
operator|=
operator|(
name|stream
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"file_open(stream)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
comment|/* Allocate the buffer. */
name|buffer
operator|=
operator|(
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|buffer_size
argument_list|,
literal|1
argument_list|,
literal|"file_open(buffer)"
argument_list|)
expr_stmt|;
comment|/* Set the close procedure in case we have to free the file */
comment|/* before actually initializing the stream. */
name|s
operator|->
name|procs
operator|.
name|close
operator|=
name|s_std_close
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"file_open(stream)"
argument_list|)
expr_stmt|;
return|return
name|e_VMerror
return|;
block|}
if|if
condition|(
name|fname
operator|!=
literal|0
condition|)
block|{
comment|/* Copy the name (so we can terminate it with a zero byte.) */
name|char
modifier|*
name|file_name
init|=
operator|(
name|char
operator|*
operator|)
name|buffer
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|memcpy
argument_list|(
name|file_name
argument_list|,
name|fname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|file_name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* terminate string */
comment|/* Open the file. */
name|file
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
name|file_access
argument_list|)
expr_stmt|;
name|code
operator|=
name|e_undefinedfilename
expr_stmt|;
if|if
condition|(
name|file
operator|==
literal|0
condition|)
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|buffer_size
argument_list|,
literal|1
argument_list|,
literal|"file_open(buffer)"
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"file_open(stream)"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
comment|/* Set up the stream. */
if|if
condition|(
operator|*
name|file_access
operator|==
literal|'r'
condition|)
comment|/* reading */
name|sread_file
argument_list|(
name|s
argument_list|,
name|file
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
else|else
name|swrite_file
argument_list|(
name|s
argument_list|,
name|file
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* save the buffer and size */
block|{
name|s
operator|->
name|cbuf
operator|=
name|buffer
expr_stmt|;
name|s
operator|->
name|bsize
operator|=
name|s
operator|->
name|cbsize
operator|=
name|buffer_size
expr_stmt|;
block|}
name|s
operator|->
name|can_close
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|strm_is_temp
operator|=
literal|0
expr_stmt|;
comment|/* not a temp stream */
if|if
condition|(
name|file_list
operator|!=
literal|0
condition|)
name|file_list
operator|->
name|prev
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|file_list
expr_stmt|;
name|s
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|file_list
operator|=
name|s
expr_stmt|;
name|make_file
argument_list|(
name|pfile
argument_list|,
operator|(
operator|*
name|file_access
operator|==
literal|'r'
condition|?
name|a_read
operator|+
name|a_execute
else|:
name|a_write
operator|+
name|a_execute
operator|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|ps
operator|=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free a stream and its buffer. */
end_comment

begin_comment
comment|/* Free the stream and buffer in the reverse of the order */
end_comment

begin_comment
comment|/* in which they were created, and hope for LIFO storage behavior. */
end_comment

begin_function
name|void
name|file_free_stream
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
operator|->
name|cbuf
argument_list|,
name|s
operator|->
name|cbsize
argument_list|,
literal|1
argument_list|,
literal|"file_free_stream(buffer)"
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"file_free_stream(stream)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a file.  The interpreter calls this when */
end_comment

begin_comment
comment|/* it reaches the end of an executable file. */
end_comment

begin_function
name|int
name|file_close
parameter_list|(
name|ref
modifier|*
name|fp
comment|/* t_file */
parameter_list|,
name|stream
modifier|*
name|s
parameter_list|)
block|{
switch|switch
condition|(
name|s
operator|->
name|can_close
condition|)
block|{
case|case
literal|0
case|:
comment|/* can't close std files, ignore */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* ignore on statement/lineedit */
name|sclose
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s_disable
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ordinary or filter file */
block|{
name|char
modifier|*
name|stemp
init|=
operator|(
name|s
operator|->
name|strm_is_temp
condition|?
operator|(
name|char
operator|*
operator|)
name|s
operator|->
name|strm
else|:
literal|0
operator|)
decl_stmt|;
comment|/* Save the links before freeing the stream. */
name|stream
modifier|*
name|sprev
init|=
name|s
operator|->
name|prev
decl_stmt|,
modifier|*
name|snext
init|=
name|s
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|sclose
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|e_ioerror
return|;
name|s_disable
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|file_free_stream
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|stemp
operator|!=
literal|0
condition|)
name|alloc_free
argument_list|(
name|stemp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|stream
argument_list|)
argument_list|,
literal|"file_close(sub-stream)"
argument_list|)
expr_stmt|;
comment|/* Unlink the file from the list of all files. */
if|if
condition|(
name|sprev
operator|!=
literal|0
condition|)
name|sprev
operator|->
name|next
operator|=
name|snext
expr_stmt|;
else|else
name|file_list
operator|=
name|snext
expr_stmt|;
if|if
condition|(
name|snext
operator|!=
literal|0
condition|)
name|snext
operator|->
name|prev
operator|=
name|sprev
expr_stmt|;
block|}
block|}
comment|/* If we just closed the file from which the interpreter */
comment|/* is reading, zap it on the exec stack. */
block|{
name|es_ptr
name|cfp
init|=
name|zget_current_file
argument_list|()
decl_stmt|;
if|if
condition|(
name|cfp
operator|!=
literal|0
operator|&&
name|fptr
argument_list|(
name|cfp
argument_list|)
operator|==
name|fptr
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* A null would confuse the estack parser.... */
name|make_tasv
argument_list|(
name|cfp
argument_list|,
name|t_array
argument_list|,
name|a_executable
operator|+
name|a_execute
argument_list|,
literal|0
argument_list|,
name|refs
argument_list|,
operator|(
name|ref
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|esfile
operator|=
literal|0
expr_stmt|;
comment|/* clear currentfile cache */
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* If a file name refers to one of the standard %files, */
end_comment

begin_comment
comment|/* 'open' the file and return 0 or an error code, otherwise */
end_comment

begin_comment
comment|/* return e_undefinedfilename. */
end_comment

begin_function
name|private
name|int
name|open_std_file
parameter_list|(
name|os_ptr
name|pfname
parameter_list|,
specifier|const
name|char
modifier|*
name|file_access
parameter_list|,
name|os_ptr
name|pfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_std_files
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|bytes_compare
argument_list|(
name|pfname
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|pfname
argument_list|)
argument_list|,
operator|(
specifier|const
name|byte
operator|*
operator|)
name|std_file_names
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|std_file_names
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This is a standard file */
name|int
name|attrs
init|=
operator|(
operator|*
name|file_access
operator|==
literal|'r'
condition|?
name|a_read
operator|+
name|a_execute
else|:
name|a_write
operator|+
name|a_execute
operator|)
decl_stmt|;
name|stream
modifier|*
name|s
init|=
operator|&
name|std_files
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|attrs
operator|!=
name|std_file_attrs
index|[
name|i
index|]
condition|)
return|return
name|e_invalidaccess
return|;
name|make_file
argument_list|(
name|pfile
argument_list|,
name|attrs
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* If this is %lineedit or %statementedit, */
comment|/* read a line now. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|4
case|:
block|{
name|uint
name|count
decl_stmt|;
name|int
name|code
init|=
name|zreadline_stdin
argument_list|(
name|lineedit_buf
argument_list|,
name|lineedit_buf_size
argument_list|,
operator|&
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|sread_string
argument_list|(
name|s
argument_list|,
name|lineedit_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|->
name|can_close
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
return|return
name|e_undefinedfilename
return|;
block|}
end_function

begin_comment
comment|/* Close inaccessible files just before a restore, */
end_comment

begin_comment
comment|/* or all files just before exiting. */
end_comment

begin_function
name|void
name|file_restore
parameter_list|(
name|alloc_save
modifier|*
name|save
parameter_list|)
block|{
while|while
condition|(
name|file_list
operator|!=
literal|0
operator|&&
operator|(
name|save
operator|==
literal|0
operator|||
name|alloc_is_since_save
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_list
argument_list|,
name|save
argument_list|)
operator|)
condition|)
block|{
name|stream
modifier|*
name|s
init|=
name|file_list
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|can_close
operator|>
literal|0
condition|)
comment|/* ignore std& buffered files */
block|{
name|sclose
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|file_list
operator|=
name|s
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|next
operator|!=
literal|0
condition|)
name|s
operator|->
name|next
operator|->
name|prev
operator|=
name|s
operator|->
name|prev
expr_stmt|;
name|s_disable
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|file_close_all
parameter_list|()
block|{
name|file_restore
argument_list|(
operator|(
name|alloc_save
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

