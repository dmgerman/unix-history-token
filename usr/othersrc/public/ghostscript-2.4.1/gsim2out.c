begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsim2out.c */
end_comment

begin_comment
comment|/* Image to outline conversion for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gsstate.h"
end_include

begin_include
include|#
directive|include
file|"gscoord.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxtype1.h"
end_include

begin_comment
comment|/*  * Convert a bitmap image to an outline (path) representation.  * The outline representation is in Adobe Type 1 CharString format.  * See ghost.doc for more details.  */
end_comment

begin_comment
comment|/* Define the state of the conversion process. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The following are set at the beginning of the conversion. */
name|gs_matrix
name|ifm
decl_stmt|;
comment|/* inverse of (CTM */
comment|/* scaled by width/height * 4). */
name|byte
modifier|*
name|limit
decl_stmt|;
comment|/* stop output here */
name|int
name|ox
decl_stmt|,
name|oy
decl_stmt|;
comment|/* X/Y pixel offset of char origin */
comment|/* The following are updated dynamically. */
name|byte
modifier|*
name|next
decl_stmt|;
comment|/* next byte goes here */
name|int
name|px
decl_stmt|,
name|py
decl_stmt|;
comment|/* X/Y position at start of run */
name|int
name|cpx
decl_stmt|,
name|cpy
decl_stmt|;
comment|/* px/py in character coordinates */
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
comment|/* X/Y increment of current run */
name|int
name|count
decl_stmt|;
comment|/* # of steps in current run */
block|}
name|status
typedef|;
end_typedef

begin_comment
comment|/* Define the scaling for the path tracer. */
end_comment

begin_define
define|#
directive|define
name|outline_scale
value|4
end_define

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|private
name|int
name|round_coord
argument_list|(
name|P1
argument_list|(
name|floatp
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|put_int
argument_list|(
name|P2
argument_list|(
name|status
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|fill_cells
argument_list|(
name|P4
argument_list|(
name|byte
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|trace_cells
argument_list|(
name|P4
argument_list|(
name|byte
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|status
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * gs_type1imagepath encodes an image into a byte string supplied  * by the caller.  If the string is not big enough, the procedure  * returns gs_error_limitcheck.  Otherwise, the procedure returns  * the actual number of bytes of data stored.  */
end_comment

begin_function
name|int
name|gs_type1imagepath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|floatp
name|wx
parameter_list|,
name|floatp
name|wy
parameter_list|,
name|floatp
name|origin_x
parameter_list|,
name|floatp
name|origin_y
parameter_list|,
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|maxlen
parameter_list|)
block|{
name|uint
name|csize
decl_stmt|;
name|byte
modifier|*
name|cells
decl_stmt|;
name|status
name|stat
decl_stmt|;
name|status
modifier|*
name|out
init|=
operator|&
name|stat
decl_stmt|;
name|int
name|lsbx
decl_stmt|;
name|int
name|iwx
decl_stmt|,
name|iwy
decl_stmt|,
name|ilsbx
decl_stmt|,
name|ilsby
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Construct the coordinate transformation. */
block|{
name|float
name|hsc
init|=
name|height
operator|*
name|outline_scale
decl_stmt|;
name|gs_matrix
name|mat
decl_stmt|;
name|gs_currentmatrix
argument_list|(
name|pgs
argument_list|,
operator|&
name|stat
operator|.
name|ifm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'0'
index|]
condition|)
name|dprintf6
argument_list|(
literal|"[0]ctm=[%g %g %g %g %g %g]\n"
argument_list|,
name|stat
operator|.
name|ifm
operator|.
name|xx
argument_list|,
name|stat
operator|.
name|ifm
operator|.
name|xy
argument_list|,
name|stat
operator|.
name|ifm
operator|.
name|yx
argument_list|,
name|stat
operator|.
name|ifm
operator|.
name|yy
argument_list|,
name|stat
operator|.
name|ifm
operator|.
name|tx
argument_list|,
name|stat
operator|.
name|ifm
operator|.
name|ty
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|code
operator|=
name|gs_make_scaling
argument_list|(
name|hsc
argument_list|,
name|hsc
argument_list|,
operator|&
name|mat
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_matrix_multiply
argument_list|(
operator|&
name|mat
argument_list|,
operator|&
name|stat
operator|.
name|ifm
argument_list|,
operator|&
name|stat
operator|.
name|ifm
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_matrix_invert
argument_list|(
operator|&
name|stat
operator|.
name|ifm
argument_list|,
operator|&
name|stat
operator|.
name|ifm
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
comment|/* Allocate and fill in the cell matrix. */
name|csize
operator|=
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
operator|(
name|height
operator|+
literal|2
operator|)
expr_stmt|;
name|cells
operator|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|csize
argument_list|,
literal|1
argument_list|,
literal|"gsim2out cells"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cells
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|fill_cells
argument_list|(
name|cells
argument_list|,
name|data
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* Initialize the rest of the state. */
name|stat
operator|.
name|next
operator|=
name|str
expr_stmt|;
name|stat
operator|.
name|limit
operator|=
name|str
operator|+
name|maxlen
expr_stmt|;
comment|/* Determine the left side bearing by looking for */
comment|/* the leftmost column with any 1-bits. */
for|for
control|(
name|lsbx
operator|=
literal|0
init|;
name|lsbx
operator|<
name|width
condition|;
name|lsbx
operator|++
control|)
block|{
name|int
name|y
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|1
init|;
name|y
operator|<=
name|height
condition|;
name|y
operator|++
control|)
if|if
condition|(
name|cells
index|[
name|y
operator|*
operator|(
name|width
operator|+
literal|2
operator|)
operator|+
name|lsbx
operator|+
literal|1
index|]
condition|)
goto|goto
name|xit
goto|;
block|}
name|xit
label|:
comment|/* Encode the origin, width, and side bearing. */
block|{
name|gs_point
name|opt
decl_stmt|,
name|wpt
decl_stmt|,
name|lsbpt
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_distance_transform
argument_list|(
name|origin_x
operator|*
name|outline_scale
argument_list|,
name|origin_y
operator|*
name|outline_scale
argument_list|,
operator|&
name|stat
operator|.
name|ifm
argument_list|,
operator|&
name|opt
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_distance_transform
argument_list|(
name|wx
operator|*
name|outline_scale
argument_list|,
name|wy
operator|*
name|outline_scale
argument_list|,
operator|&
name|stat
operator|.
name|ifm
argument_list|,
operator|&
name|wpt
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_distance_transform
argument_list|(
operator|(
name|lsbx
operator|-
name|origin_x
operator|)
operator|*
name|outline_scale
argument_list|,
operator|(
name|floatp
operator|)
literal|0
argument_list|,
operator|&
name|stat
operator|.
name|ifm
argument_list|,
operator|&
name|lsbpt
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|stat
operator|.
name|ox
operator|=
name|round_coord
argument_list|(
name|opt
operator|.
name|x
argument_list|)
expr_stmt|;
name|stat
operator|.
name|oy
operator|=
name|round_coord
argument_list|(
name|opt
operator|.
name|y
argument_list|)
expr_stmt|;
name|iwx
operator|=
name|round_coord
argument_list|(
name|wpt
operator|.
name|x
argument_list|)
expr_stmt|;
name|iwy
operator|=
name|round_coord
argument_list|(
name|wpt
operator|.
name|y
argument_list|)
expr_stmt|;
name|ilsbx
operator|=
name|round_coord
argument_list|(
name|lsbpt
operator|.
name|x
argument_list|)
expr_stmt|;
name|ilsby
operator|=
name|round_coord
argument_list|(
name|lsbpt
operator|.
name|y
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'0'
index|]
condition|)
block|{
name|int
name|cy
decl_stmt|,
name|cx
decl_stmt|;
name|byte
modifier|*
name|cp
init|=
name|data
decl_stmt|;
name|dprintf6
argument_list|(
literal|"[0]w=%d h=%d oxy=(%g,%g) wxy=(%g,%g)\n"
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|origin_x
argument_list|,
name|origin_y
argument_list|,
name|wx
argument_list|,
name|wy
argument_list|)
expr_stmt|;
name|dprintf6
argument_list|(
literal|"   io=(%d,%d) iw=(%d,%d) ilsb=(%d,%d)\n"
argument_list|,
name|stat
operator|.
name|ox
argument_list|,
name|stat
operator|.
name|oy
argument_list|,
name|iwx
argument_list|,
name|iwy
argument_list|,
name|ilsbx
argument_list|,
name|ilsby
argument_list|)
expr_stmt|;
for|for
control|(
name|cy
operator|=
literal|0
init|;
name|cy
operator|<
name|height
condition|;
name|cy
operator|++
control|)
block|{
name|dprintf1
argument_list|(
literal|"[0]%3d "
argument_list|,
name|cy
argument_list|)
expr_stmt|;
for|for
control|(
name|cx
operator|=
literal|0
init|;
name|cx
operator|<
name|width
condition|;
name|cx
operator|+=
literal|8
control|)
name|dprintf1
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|int
operator|)
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|code
operator|=
name|put_int
argument_list|(
name|out
argument_list|,
name|ilsbx
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|iwy
operator|!=
literal|0
operator|||
name|ilsby
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|put_int
argument_list|(
name|out
argument_list|,
name|ilsby
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|put_int
argument_list|(
name|out
argument_list|,
name|iwx
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|put_int
argument_list|(
name|out
argument_list|,
name|iwy
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|stat
operator|.
name|next
operator|+
literal|2
operator|>
name|stat
operator|.
name|limit
condition|)
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
operator|*
name|stat
operator|.
name|next
operator|++
operator|=
operator|(
name|byte
operator|)
name|c_escape
expr_stmt|;
operator|*
name|stat
operator|.
name|next
operator|++
operator|=
operator|(
name|byte
operator|)
name|ce_sbw
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|put_int
argument_list|(
name|out
argument_list|,
name|iwx
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|stat
operator|.
name|next
operator|+
literal|1
operator|>
name|stat
operator|.
name|limit
condition|)
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
operator|*
name|stat
operator|.
name|next
operator|++
operator|=
operator|(
name|byte
operator|)
name|c_hsbw
expr_stmt|;
block|}
block|}
comment|/* Since all further movements are relative, we can account */
comment|/* for the origin by simply setting px/py to the lsb, */
comment|/* and cpx/cpy to the lsb plus the origin. */
name|stat
operator|.
name|px
operator|=
operator|(
name|lsbx
operator|*
name|outline_scale
operator|)
expr_stmt|;
name|stat
operator|.
name|py
operator|=
call|(
name|int
call|)
argument_list|(
name|origin_y
operator|*
name|outline_scale
argument_list|)
expr_stmt|;
name|stat
operator|.
name|cpx
operator|=
name|ilsbx
operator|+
name|stat
operator|.
name|ox
expr_stmt|;
name|stat
operator|.
name|cpy
operator|=
name|ilsby
operator|+
name|stat
operator|.
name|oy
expr_stmt|;
comment|/* Trace the outline of the cells. */
name|code
operator|=
name|trace_cells
argument_list|(
name|cells
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cells
argument_list|,
name|csize
argument_list|,
literal|1
argument_list|,
literal|"gsim2out cells"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|stat
operator|.
name|next
operator|>=
name|stat
operator|.
name|limit
condition|)
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
operator|*
name|stat
operator|.
name|next
operator|++
operator|=
operator|(
name|byte
operator|)
name|c_endchar
expr_stmt|;
return|return
name|stat
operator|.
name|next
operator|-
name|str
return|;
block|}
end_function

begin_comment
comment|/* Fill the cell matrix with the image being traced. */
end_comment

begin_comment
comment|/* The cell matrix has a row and column of zero padding on each side, */
end_comment

begin_comment
comment|/* so we don't have to check for boundary conditions all the time. */
end_comment

begin_comment
comment|/* Note that the image data are in PostScript / Ghostscript standard */
end_comment

begin_comment
comment|/* order (left to right, top row first), but the cells are stored */
end_comment

begin_comment
comment|/* bottom row first. */
end_comment

begin_function
name|private
name|void
name|fill_cells
parameter_list|(
name|byte
modifier|*
name|cells
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|)
block|{
name|int
name|y
decl_stmt|;
name|byte
modifier|*
name|dptr
init|=
name|data
operator|-
literal|1
decl_stmt|;
name|byte
modifier|*
name|cptr
init|=
name|cells
operator|+
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
name|height
operator|+
literal|1
decl_stmt|;
name|memset
argument_list|(
name|cells
argument_list|,
literal|0
argument_list|,
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
operator|(
name|height
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
specifier|register
name|int
name|mask
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|b
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|width
condition|;
name|x
operator|++
operator|,
name|mask
operator|>>=
literal|1
operator|,
name|cptr
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|mask
operator|=
literal|0x80
operator|,
name|b
operator|=
operator|*
operator|++
name|dptr
expr_stmt|;
if|if
condition|(
name|b
operator|&
name|mask
condition|)
operator|*
name|cptr
operator|=
literal|1
expr_stmt|;
block|}
name|cptr
operator|-=
name|width
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
comment|/* back up 1 row */
block|}
block|}
end_function

begin_comment
comment|/* Trace the cells to form an outline.  The trace goes in clockwise */
end_comment

begin_comment
comment|/* order, always starting by going west along a bottom edge. */
end_comment

begin_comment
comment|/* All the subsidiary routines return 0 on success, */
end_comment

begin_comment
comment|/* -1 if the output buffer overflowed. */
end_comment

begin_decl_stmt
name|private
name|int
name|trace_from
argument_list|(
name|P3
argument_list|(
name|status
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|add_dxdy
argument_list|(
name|P4
argument_list|(
name|status
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|add_deltas
parameter_list|(
name|s
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|n
parameter_list|)
define|\
value|if ( (code = add_dxdy(s, dx, dy, n))< 0 ) return code
end_define

begin_decl_stmt
name|private
name|int
name|put_dxdy
argument_list|(
name|P4
argument_list|(
name|status
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|put_deltas
parameter_list|(
name|s
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|moving
parameter_list|)
define|\
value|if ( (code = put_dxdy(s, dx, dy, moving))< 0 ) return code
end_define

begin_function
name|private
name|int
name|trace_cells
parameter_list|(
name|byte
modifier|*
name|cells
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
specifier|register
name|status
modifier|*
name|out
parameter_list|)
block|{
name|byte
modifier|*
name|cptr
decl_stmt|;
name|int
name|code
decl_stmt|;
for|for
control|(
name|cptr
operator|=
name|cells
operator|+
operator|(
name|width
operator|+
literal|2
operator|)
operator|*
operator|(
name|height
operator|+
literal|1
operator|)
operator|-
literal|2
init|;
name|cptr
operator|>=
name|cells
condition|;
name|cptr
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|cptr
operator|==
literal|1
operator|&&
name|cptr
index|[
operator|-
operator|(
name|width
operator|+
literal|2
operator|)
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Found a starting point */
name|int
name|x
init|=
operator|(
name|cptr
operator|-
name|cells
operator|)
operator|%
operator|(
name|width
operator|+
literal|2
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|y
init|=
operator|(
name|cptr
operator|-
name|cells
operator|)
operator|/
operator|(
name|width
operator|+
literal|2
operator|)
operator|-
literal|1
decl_stmt|;
name|put_deltas
argument_list|(
name|out
argument_list|,
name|x
operator|*
name|outline_scale
operator|+
literal|1
operator|-
name|out
operator|->
name|px
argument_list|,
name|y
operator|*
name|outline_scale
operator|-
name|out
operator|->
name|py
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|trace_from
argument_list|(
name|out
argument_list|,
name|cptr
argument_list|,
name|width
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|out
operator|->
name|next
operator|>=
name|out
operator|->
name|limit
condition|)
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
operator|*
name|out
operator|->
name|next
operator|++
operator|=
operator|(
name|byte
operator|)
name|c_closepath
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Trace a path */
end_comment

begin_function
name|private
name|int
name|trace_from
parameter_list|(
specifier|register
name|status
modifier|*
name|out
parameter_list|,
name|byte
modifier|*
name|cptr
parameter_list|,
name|int
name|width
parameter_list|)
block|{
typedef|typedef
enum|enum
block|{
comment|/* must be in this order */
name|north
init|=
literal|0
block|,
name|east
init|=
literal|1
block|,
name|south
init|=
literal|2
block|,
name|west
init|=
literal|3
block|}
name|direction
typedef|;
name|direction
name|dir
decl_stmt|;
name|int
name|w2
init|=
name|width
operator|+
literal|2
decl_stmt|;
comment|/* actual width of cell rows */
name|int
name|part
decl_stmt|;
comment|/* how far along edge we are */
name|int
name|code
decl_stmt|;
comment|/* Movement tables */
typedef|typedef
struct|struct
block|{
name|short
name|tx
decl_stmt|,
name|ty
decl_stmt|;
comment|/* relative index of first cell */
comment|/* to test (counter-clockwise move) */
name|short
name|dx
decl_stmt|,
name|dy
decl_stmt|;
comment|/* continue in same direction */
block|}
name|dir_descr
typedef|;
specifier|static
name|dir_descr
name|nesw
index|[
literal|4
operator|+
literal|1
index|]
init|=
block|{
comment|/* Going north (along a western edge) */
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* Going east (along a northern edge) */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* Going south (along an eastern edge) */
block|{
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,
comment|/* Going west (along a southern edge) */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* An extra copy of north */
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
for|for
control|(
name|dir
operator|=
name|west
operator|,
name|part
operator|=
literal|1
init|;
condition|;
control|)
block|{
specifier|register
name|dir_descr
modifier|*
name|pd
init|=
operator|&
name|nesw
index|[
operator|(
name|int
operator|)
name|dir
index|]
decl_stmt|;
name|int
name|dx
init|=
name|pd
operator|->
name|dx
decl_stmt|,
name|dy
init|=
name|pd
operator|->
name|dy
decl_stmt|;
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|west
condition|)
block|{
comment|/* This is the only case that has to check */
comment|/* for the end of a subpath. */
if|if
condition|(
operator|*
name|cptr
operator|==
literal|2
condition|)
return|return
literal|0
return|;
operator|*
name|cptr
operator|=
literal|2
expr_stmt|;
block|}
name|delta
operator|=
name|pd
operator|->
name|ty
operator|*
name|w2
operator|+
name|pd
operator|->
name|tx
expr_stmt|;
if|if
condition|(
name|cptr
index|[
name|delta
index|]
condition|)
comment|/* go counter-clockwise */
block|{
name|cptr
operator|+=
name|delta
expr_stmt|;
name|add_deltas
argument_list|(
name|out
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
literal|1
operator|-
name|part
argument_list|)
expr_stmt|;
name|add_deltas
argument_list|(
name|out
argument_list|,
name|pd
operator|->
name|tx
argument_list|,
name|pd
operator|->
name|ty
argument_list|,
name|outline_scale
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dir
operator|=
call|(
name|direction
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|dir
operator|-
literal|1
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|part
operator|=
name|outline_scale
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|delta
operator|=
name|dy
operator|*
name|w2
operator|+
name|dx
expr_stmt|;
if|if
condition|(
operator|!
name|cptr
index|[
name|delta
index|]
condition|)
comment|/* go clockwise */
block|{
name|add_deltas
argument_list|(
name|out
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|outline_scale
operator|-
literal|1
operator|-
name|part
argument_list|)
expr_stmt|;
name|add_deltas
argument_list|(
name|out
argument_list|,
name|dx
operator|+
name|pd
index|[
literal|1
index|]
operator|.
name|dx
argument_list|,
name|dy
operator|+
name|pd
index|[
literal|1
index|]
operator|.
name|dy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dir
operator|=
call|(
name|direction
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|dir
operator|+
literal|1
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|part
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|cptr
operator|+=
name|delta
expr_stmt|;
comment|/* go in same direction */
name|add_deltas
argument_list|(
name|out
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|outline_scale
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a (dx, dy) pair to the path being formed. */
end_comment

begin_comment
comment|/* Accumulate successive segments in the same direction. */
end_comment

begin_function
name|private
name|int
name|add_dxdy
parameter_list|(
specifier|register
name|status
modifier|*
name|out
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dx
operator|==
name|out
operator|->
name|dx
operator|&&
name|dy
operator|==
name|out
operator|->
name|dy
condition|)
name|out
operator|->
name|count
operator|+=
name|count
expr_stmt|;
else|else
block|{
if|if
condition|(
name|out
operator|->
name|count
operator|!=
literal|0
condition|)
name|put_deltas
argument_list|(
name|out
argument_list|,
name|out
operator|->
name|dx
operator|*
name|out
operator|->
name|count
argument_list|,
name|out
operator|->
name|dy
operator|*
name|out
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|->
name|dx
operator|=
name|dx
operator|,
name|out
operator|->
name|dy
operator|=
name|dy
expr_stmt|;
name|out
operator|->
name|count
operator|=
name|count
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Encode a (dx, dy) pair onto the path. */
end_comment

begin_comment
comment|/* If there isn't enough space, return -1. */
end_comment

begin_function
name|private
name|int
name|put_dxdy
parameter_list|(
specifier|register
name|status
modifier|*
name|out
parameter_list|,
name|int
name|dx
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|moving
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
comment|/* We do the arithmetic in the 1/4-pixel coordinate system, */
comment|/* and then transform the result, to avoid accumulating */
comment|/* rounding errors. */
name|int
name|npx
init|=
name|out
operator|->
name|px
operator|+
name|dx
decl_stmt|,
name|npy
init|=
name|out
operator|->
name|py
operator|+
name|dy
decl_stmt|;
name|gs_point
name|npt
decl_stmt|;
name|int
name|ncpx
decl_stmt|,
name|ncpy
decl_stmt|;
name|int
name|cdx
decl_stmt|,
name|cdy
decl_stmt|;
name|gs_distance_transform
argument_list|(
operator|(
name|floatp
operator|)
name|npx
argument_list|,
operator|(
name|floatp
operator|)
name|npy
argument_list|,
operator|&
name|out
operator|->
name|ifm
argument_list|,
operator|&
name|npt
argument_list|)
expr_stmt|;
name|ncpx
operator|=
name|round_coord
argument_list|(
name|npt
operator|.
name|x
argument_list|)
expr_stmt|;
name|ncpy
operator|=
name|round_coord
argument_list|(
name|npt
operator|.
name|y
argument_list|)
expr_stmt|;
name|cdx
operator|=
name|ncpx
operator|-
name|out
operator|->
name|cpx
expr_stmt|;
name|cdy
operator|=
name|ncpy
operator|-
name|out
operator|->
name|cpy
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'0'
index|]
condition|)
name|dprintf8
argument_list|(
literal|"[0]  pxy=(%d,%d)+(%d,%d)  cpxy=(%d,%d)+(%d,%d)\n"
argument_list|,
name|out
operator|->
name|px
argument_list|,
name|out
operator|->
name|py
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
name|out
operator|->
name|cpx
argument_list|,
name|out
operator|->
name|cpy
argument_list|,
name|cdx
argument_list|,
name|cdy
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cdx
operator|!=
literal|0
operator|||
name|cdy
operator|==
literal|0
condition|)
comment|/* encode dx if needed */
if|if
condition|(
operator|(
name|code
operator|=
name|put_int
argument_list|(
name|out
argument_list|,
name|cdx
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|cdy
operator|!=
literal|0
condition|)
comment|/* encode dy if needed */
if|if
condition|(
operator|(
name|code
operator|=
name|put_int
argument_list|(
name|out
argument_list|,
name|cdy
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|out
operator|->
name|next
operator|==
name|out
operator|->
name|limit
condition|)
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
operator|*
name|out
operator|->
name|next
operator|++
operator|=
call|(
name|byte
call|)
argument_list|(
name|cdy
operator|==
literal|0
condition|?
comment|/* use hmove/lineto */
operator|(
name|moving
condition|?
name|c_hmoveto
else|:
name|c_hlineto
operator|)
else|:
name|cdx
operator|==
literal|0
condition|?
comment|/* use vmove/lineto */
operator|(
name|moving
condition|?
name|c_vmoveto
else|:
name|c_vlineto
operator|)
else|:
operator|(
name|moving
condition|?
name|c_rmoveto
else|:
name|c_rlineto
operator|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|px
operator|=
name|npx
operator|,
name|out
operator|->
name|py
operator|=
name|npy
expr_stmt|;
name|out
operator|->
name|cpx
operator|=
name|ncpx
operator|,
name|out
operator|->
name|cpy
operator|=
name|ncpy
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Round a floating point coordinate.  If it is out of range, */
end_comment

begin_comment
comment|/* return a limiting value. */
end_comment

begin_function
name|private
name|int
name|round_coord
parameter_list|(
name|floatp
name|v
parameter_list|)
block|{
name|long
name|c
init|=
call|(
name|long
call|)
argument_list|(
name|v
operator|+
literal|0.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|c
operator|>
literal|0x7fff
condition|?
literal|0x7fff
else|:
name|c
operator|<
operator|-
literal|0x7fff
condition|?
operator|-
literal|0x7fff
else|:
operator|(
name|int
operator|)
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Encode a single number in Type 1 representation. */
end_comment

begin_function
name|private
name|int
name|put_int
parameter_list|(
name|status
modifier|*
name|out
parameter_list|,
specifier|register
name|int
name|v
parameter_list|)
block|{
define|#
directive|define
name|min_enc_num1
value|((c_num1 - c_num2 + 1) / 2)
define|#
directive|define
name|max_enc_num1
value|((c_num2 - c_num1 - 1) / 2)
define|#
directive|define
name|min_enc_num2
value|(max_enc_num1 + 1)
define|#
directive|define
name|max_enc_num2
value|(min_enc_num2 + (c_num3 - c_num2) * 256 - 1)
define|#
directive|define
name|min_enc_num3
value|(-max_enc_num2)
define|#
directive|define
name|max_enc_num3
value|(-min_enc_num2)
specifier|register
name|byte
modifier|*
name|ptr
init|=
name|out
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|ptr
operator|+
literal|5
operator|>
name|out
operator|->
name|limit
condition|)
comment|/* conservative test is faster */
name|return_error
argument_list|(
name|gs_error_limitcheck
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>=
name|min_enc_num1
operator|&&
name|v
operator|<=
name|max_enc_num1
condition|)
operator|*
name|ptr
operator|++
operator|=
name|v
operator|-
name|min_enc_num1
operator|+
name|c_num1
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|>=
name|min_enc_num2
operator|&&
name|v
operator|<=
name|max_enc_num2
condition|)
block|{
name|v
operator|-=
name|min_enc_num2
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|+
name|c_num2
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|>=
name|min_enc_num3
operator|&&
name|v
operator|<=
name|max_enc_num3
condition|)
block|{
name|v
operator|=
operator|-
operator|(
name|v
operator|-
name|max_enc_num3
operator|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|+
name|c_num3
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr
operator|++
operator|=
name|c_num4
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
operator|(
name|long
operator|)
name|v
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
operator|(
name|long
operator|)
name|v
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
block|}
name|out
operator|->
name|next
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

