begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zgeneric.c */
end_comment

begin_comment
comment|/* Array/string/dictionary generic operators for PostScript */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_comment
comment|/* for forall */
end_comment

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* This file implements copy, get, put, getinterval, putinterval, */
end_comment

begin_comment
comment|/* length, and forall, which apply generically to */
end_comment

begin_comment
comment|/* arrays, strings, and dictionaries.  (Copy also has a special */
end_comment

begin_comment
comment|/* meaning for copying the top N elements of the stack.) */
end_comment

begin_comment
comment|/* Imported operators */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|zcopy_device
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zcopy_dict
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|int
name|array_get
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|long
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|copy_interval
argument_list|(
name|P4
argument_list|(
name|os_ptr
argument_list|,
name|uint
argument_list|,
name|os_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* copy */
end_comment

begin_comment
comment|/* Note that this implements copy for arrays and strings, */
end_comment

begin_comment
comment|/* but not for dictionaries (see zcopy_dict in zdict.c) */
end_comment

begin_comment
comment|/* or devices (see zcopy_device in zdevice.c). */
end_comment

begin_function
name|int
name|zcopy
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|int
name|code
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_integer
case|:
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|op
operator|->
name|value
operator|.
name|intval
operator|>
name|op
operator|-
name|osbot
condition|)
return|return
name|e_rangecheck
return|;
name|count
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|op1
operator|+
name|count
operator|>
name|ostop
condition|)
return|return
name|e_stackoverflow
return|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|op
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|op
operator|-
name|count
operator|)
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|t_array
case|:
case|case
name|t_string
case|:
name|code
operator|=
name|copy_interval
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|op1
argument_list|,
literal|"copy"
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_device
case|:
return|return
name|zcopy_device
argument_list|(
name|op
argument_list|)
return|;
case|case
name|t_dictionary
case|:
return|return
name|zcopy_dict
argument_list|(
name|op
argument_list|)
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
if|if
condition|(
name|code
condition|)
return|return
name|code
return|;
comment|/* error */
name|r_set_size
argument_list|(
name|op
argument_list|,
name|r_size
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|op1
operator|=
operator|*
name|op
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* length */
end_comment

begin_function
name|int
name|zlength
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
case|case
name|t_string
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
name|check_read
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|t_dictionary
case|:
name|check_dict_read
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|dict_length
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|t_name
case|:
block|{
name|ref
name|str
decl_stmt|;
name|name_string_ref
argument_list|(
name|op
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|r_size
argument_list|(
operator|&
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
block|}
end_function

begin_comment
comment|/* get */
end_comment

begin_function
name|int
name|zget
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|ref
modifier|*
name|pvalue
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|t_dictionary
case|:
name|check_dict_read
argument_list|(
operator|*
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict_find
argument_list|(
name|op1
argument_list|,
name|op
argument_list|,
operator|&
name|pvalue
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|e_undefined
return|;
name|op
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|pvalue
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
operator|*
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|ulong
call|)
argument_list|(
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|>=
name|r_size
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Zget t_string %u>= %u\n"
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
argument_list|,
name|r_size
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|e_rangecheck
return|;
block|}
block|{
name|int
name|element
init|=
name|op1
operator|->
name|value
operator|.
name|bytes
index|[
operator|(
name|uint
operator|)
name|op
operator|->
name|value
operator|.
name|intval
index|]
decl_stmt|;
name|make_int
argument_list|(
name|op1
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
block|{
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_read
argument_list|(
operator|*
name|op1
argument_list|)
expr_stmt|;
name|code
operator|=
name|array_get
argument_list|(
name|op1
argument_list|,
name|op
operator|->
name|value
operator|.
name|intval
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* put */
end_comment

begin_function
name|int
name|zput
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|os_ptr
name|op2
init|=
name|op1
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op2
argument_list|)
condition|)
block|{
case|case
name|t_dictionary
case|:
name|check_dict_write
argument_list|(
operator|*
name|op2
argument_list|)
expr_stmt|;
block|{
name|int
name|code
init|=
name|dict_put
argument_list|(
name|op2
argument_list|,
name|op1
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
condition|)
return|return
name|code
return|;
comment|/* error */
block|}
break|break;
case|case
name|t_array
case|:
name|check_type
argument_list|(
operator|*
name|op1
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
operator|*
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|ulong
call|)
argument_list|(
name|op1
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|>=
name|r_size
argument_list|(
name|op2
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
name|ref_assign_old
argument_list|(
name|op2
operator|->
name|value
operator|.
name|refs
operator|+
operator|(
name|uint
operator|)
name|op1
operator|->
name|value
operator|.
name|intval
argument_list|,
name|op
argument_list|,
literal|"put"
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_mixedarray
case|:
comment|/* packed arrays are read-only */
case|case
name|t_shortarray
case|:
return|return
name|e_invalidaccess
return|;
case|case
name|t_string
case|:
name|check_type
argument_list|(
operator|*
name|op1
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
operator|*
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|ulong
call|)
argument_list|(
name|op1
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|>=
name|r_size
argument_list|(
name|op2
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|op
operator|->
name|value
operator|.
name|intval
operator|>
literal|0xff
condition|)
return|return
name|e_rangecheck
return|;
name|op2
operator|->
name|value
operator|.
name|bytes
index|[
operator|(
name|uint
operator|)
name|op1
operator|->
name|value
operator|.
name|intval
index|]
operator|=
operator|(
name|byte
operator|)
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
default|default:
return|return
name|e_typecheck
return|;
block|}
name|pop
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* getinterval */
end_comment

begin_function
name|int
name|zgetinterval
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|os_ptr
name|op2
init|=
name|op1
operator|-
literal|1
decl_stmt|;
name|uint
name|index
decl_stmt|;
name|uint
name|count
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op1
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op2
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_array
case|:
case|case
name|t_string
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
empty_stmt|;
block|}
name|check_read
argument_list|(
operator|*
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|op1
operator|->
name|value
operator|.
name|intval
operator|>
name|r_size
argument_list|(
name|op2
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
name|index
operator|=
name|op1
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|op
operator|->
name|value
operator|.
name|intval
operator|>
name|r_size
argument_list|(
name|op2
argument_list|)
operator|-
name|index
condition|)
return|return
name|e_rangecheck
return|;
name|count
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op2
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
name|op2
operator|->
name|value
operator|.
name|refs
operator|+=
name|index
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|op2
operator|->
name|value
operator|.
name|bytes
operator|+=
name|index
expr_stmt|;
break|break;
case|case
name|t_mixedarray
case|:
block|{
name|ushort
modifier|*
name|packed
init|=
name|op2
operator|->
name|value
operator|.
name|packed
decl_stmt|;
for|for
control|(
init|;
name|index
operator|--
condition|;
control|)
name|packed
operator|=
name|packed_next
argument_list|(
name|packed
argument_list|)
expr_stmt|;
name|op2
operator|->
name|value
operator|.
name|packed
operator|=
name|packed
expr_stmt|;
block|}
break|break;
case|case
name|t_shortarray
case|:
name|op2
operator|->
name|value
operator|.
name|packed
operator|+=
name|index
expr_stmt|;
break|break;
block|}
name|r_set_size
argument_list|(
name|op2
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* putinterval */
end_comment

begin_function
name|int
name|zputinterval
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|os_ptr
name|opindex
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|os_ptr
name|opto
init|=
name|opindex
operator|-
literal|1
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|opindex
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|opto
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
return|return
name|e_invalidaccess
return|;
case|case
name|t_array
case|:
case|case
name|t_string
case|:
empty_stmt|;
block|}
name|check_write
argument_list|(
operator|*
name|opto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|opindex
operator|->
name|value
operator|.
name|intval
operator|>
name|r_size
argument_list|(
name|opto
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
name|code
operator|=
name|copy_interval
argument_list|(
name|opto
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|opindex
operator|->
name|value
operator|.
name|intval
argument_list|)
argument_list|,
name|op
argument_list|,
literal|"putinterval"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* forall */
end_comment

begin_decl_stmt
name|private
name|int
name|array_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_array_continue
decl_stmt|,
name|dict_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_dict_continue
decl_stmt|,
name|string_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_string_continue
decl_stmt|,
name|packedarray_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|,
name|i_packedarray_continue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zforall
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
argument_list|(
operator|*
name|cproc
argument_list|)
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|os_ptr
name|obj
init|=
name|op
operator|-
literal|1
decl_stmt|;
name|uint
name|index
init|=
literal|0
decl_stmt|;
comment|/* only used for dictionaries */
switch|switch
condition|(
name|r_type
argument_list|(
name|obj
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_array
case|:
name|check_read
argument_list|(
operator|*
name|obj
argument_list|)
expr_stmt|;
name|cproc
operator|=
name|array_continue
expr_stmt|;
break|break;
case|case
name|t_dictionary
case|:
name|check_dict_read
argument_list|(
operator|*
name|obj
argument_list|)
expr_stmt|;
name|cproc
operator|=
name|dict_continue
expr_stmt|;
name|index
operator|=
name|dict_first
argument_list|(
name|obj
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|check_read
argument_list|(
operator|*
name|obj
argument_list|)
expr_stmt|;
name|cproc
operator|=
name|string_continue
expr_stmt|;
break|break;
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
name|check_read
argument_list|(
operator|*
name|obj
argument_list|)
expr_stmt|;
name|cproc
operator|=
name|packedarray_continue
expr_stmt|;
break|break;
block|}
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
comment|/* Push a mark, the composite object, the iteration index, */
comment|/* and the procedure, and invoke the continuation operator. */
name|check_estack
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|mark_estack
argument_list|(
name|es_for
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
operator|*
name|obj
expr_stmt|;
operator|++
name|esp
expr_stmt|;
name|make_int
argument_list|(
name|esp
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
operator|*
name|op
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|2
expr_stmt|;
return|return
call|(
modifier|*
name|cproc
call|)
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Continuation operator for arrays */
end_comment

begin_function
name|private
name|int
name|array_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|obj
init|=
name|esp
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|obj
argument_list|)
condition|)
comment|/* continue */
block|{
name|r_inc_size
argument_list|(
name|obj
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|=
operator|*
name|obj
operator|->
name|value
operator|.
name|refs
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|refs
operator|++
expr_stmt|;
name|push_op_estack
argument_list|(
name|array_continue
argument_list|,
name|i_array_continue
argument_list|)
expr_stmt|;
comment|/* push continuation */
operator|*
operator|++
name|esp
operator|=
name|obj
index|[
literal|2
index|]
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
else|else
comment|/* done */
block|{
name|esp
operator|-=
literal|4
expr_stmt|;
comment|/* pop mark, object, index, proc */
return|return
name|o_pop_estack
return|;
block|}
block|}
end_function

begin_comment
comment|/* Continuation operator for dictionaries */
end_comment

begin_function
name|private
name|int
name|dict_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|obj
init|=
name|esp
operator|-
literal|2
decl_stmt|;
name|int
name|index
init|=
operator|(
name|int
operator|)
name|esp
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
decl_stmt|;
name|push
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* make room for key and value */
if|if
condition|(
operator|(
name|index
operator|=
name|dict_next
argument_list|(
name|obj
argument_list|,
name|index
argument_list|,
name|op
operator|-
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
comment|/* continue */
block|{
name|esp
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|=
name|index
expr_stmt|;
name|push_op_estack
argument_list|(
name|dict_continue
argument_list|,
name|i_dict_continue
argument_list|)
expr_stmt|;
comment|/* push continuation */
operator|*
operator|++
name|esp
operator|=
name|obj
index|[
literal|2
index|]
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
else|else
comment|/* done */
block|{
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* undo push */
name|esp
operator|-=
literal|4
expr_stmt|;
comment|/* pop mark, object, index, proc */
return|return
name|o_pop_estack
return|;
block|}
block|}
end_function

begin_comment
comment|/* Continuation operator for strings */
end_comment

begin_function
name|private
name|int
name|string_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|obj
init|=
name|esp
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|obj
argument_list|)
condition|)
comment|/* continue */
block|{
name|r_inc_size
argument_list|(
name|obj
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
operator|*
name|obj
operator|->
name|value
operator|.
name|bytes
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|bytes
operator|++
expr_stmt|;
name|push_op_estack
argument_list|(
name|string_continue
argument_list|,
name|i_string_continue
argument_list|)
expr_stmt|;
comment|/* push continuation */
operator|*
operator|++
name|esp
operator|=
name|obj
index|[
literal|2
index|]
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
else|else
comment|/* done */
block|{
name|esp
operator|-=
literal|4
expr_stmt|;
comment|/* pop mark, object, index, proc */
return|return
name|o_pop_estack
return|;
block|}
block|}
end_function

begin_comment
comment|/* Continuation operator for packed arrays */
end_comment

begin_function
name|private
name|int
name|packedarray_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|obj
init|=
name|esp
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|obj
argument_list|)
condition|)
comment|/* continue */
block|{
name|ushort
modifier|*
name|packed
init|=
name|obj
operator|->
name|value
operator|.
name|packed
decl_stmt|;
name|r_inc_size
argument_list|(
name|obj
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|packed_get
argument_list|(
name|packed
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|packed
operator|=
name|packed_next
argument_list|(
name|packed
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|packedarray_continue
argument_list|,
name|i_packedarray_continue
argument_list|)
expr_stmt|;
comment|/* push continuation */
operator|*
operator|++
name|esp
operator|=
name|obj
index|[
literal|2
index|]
expr_stmt|;
return|return
name|o_push_estack
return|;
block|}
else|else
comment|/* done */
block|{
name|esp
operator|-=
literal|4
expr_stmt|;
comment|/* pop mark, object, index, proc */
return|return
name|o_pop_estack
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zgeneric_op_defs
index|[]
init|=
block|{
block|{
literal|"1copy"
block|,
name|zcopy
block|}
block|,
block|{
literal|"2forall"
block|,
name|zforall
block|}
block|,
block|{
literal|"2get"
block|,
name|zget
block|}
block|,
block|{
literal|"3getinterval"
block|,
name|zgetinterval
block|}
block|,
block|{
literal|"1length"
block|,
name|zlength
block|}
block|,
block|{
literal|"3put"
block|,
name|zput
block|}
block|,
block|{
literal|"3putinterval"
block|,
name|zputinterval
block|}
block|,
comment|/* Internal operators */
block|{
literal|"0%array_continue"
block|,
name|array_continue
block|,
operator|&
name|i_array_continue
block|}
block|,
block|{
literal|"0%dict_continue"
block|,
name|dict_continue
block|,
operator|&
name|i_dict_continue
block|}
block|,
block|{
literal|"0%packedarray_continue"
block|,
name|packedarray_continue
block|,
operator|&
name|i_packedarray_continue
block|}
block|,
block|{
literal|"0%string_continue"
block|,
name|string_continue
block|,
operator|&
name|i_string_continue
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Shared routines ------ */
end_comment

begin_comment
comment|/* Get an element from an array of some kind. */
end_comment

begin_comment
comment|/* This is also used to index into Encoding vectors, */
end_comment

begin_comment
comment|/* the error name vector, etc. */
end_comment

begin_function
name|int
name|array_get
parameter_list|(
name|ref
modifier|*
name|aref
parameter_list|,
name|long
name|index_long
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|uint
name|index
init|=
operator|(
name|uint
operator|)
name|index_long
decl_stmt|;
if|if
condition|(
operator|(
name|ulong
operator|)
name|index_long
operator|>=
name|r_size
argument_list|(
name|aref
argument_list|)
condition|)
return|return
name|e_rangecheck
return|;
switch|switch
condition|(
name|r_type
argument_list|(
name|aref
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
block|{
name|ref
modifier|*
name|pvalue
init|=
name|aref
operator|->
name|value
operator|.
name|refs
operator|+
name|index
decl_stmt|;
name|ref_assign
argument_list|(
name|pref
argument_list|,
name|pvalue
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|t_mixedarray
case|:
block|{
name|ushort
modifier|*
name|packed
init|=
name|aref
operator|->
name|value
operator|.
name|packed
decl_stmt|;
for|for
control|(
init|;
name|index
operator|--
condition|;
control|)
name|packed
operator|=
name|packed_next
argument_list|(
name|packed
argument_list|)
expr_stmt|;
name|packed_get
argument_list|(
name|packed
argument_list|,
name|pref
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|t_shortarray
case|:
block|{
name|ushort
modifier|*
name|packed
init|=
name|aref
operator|->
name|value
operator|.
name|packed
operator|+
name|index
decl_stmt|;
name|packed_get
argument_list|(
name|packed
argument_list|,
name|pref
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
block|}
end_function

begin_comment
comment|/* Copy an interval from one operand to another. */
end_comment

begin_comment
comment|/* This is used by both putinterval and string/array copy. */
end_comment

begin_comment
comment|/* One operand is known to be an array or string, */
end_comment

begin_comment
comment|/* and the starting index is known to be less than or equal to */
end_comment

begin_comment
comment|/* its length; nothing else has been checked. */
end_comment

begin_function
name|private
name|int
name|copy_interval
parameter_list|(
name|os_ptr
name|prto
parameter_list|,
name|uint
name|index
parameter_list|,
name|os_ptr
name|prfrom
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|)
block|{
name|int
name|fromtype
init|=
name|r_type
argument_list|(
name|prfrom
argument_list|)
decl_stmt|;
name|uint
name|fromsize
init|=
name|r_size
argument_list|(
name|prfrom
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fromtype
operator|==
name|r_type
argument_list|(
name|prto
argument_list|)
operator|||
operator|(
name|fromtype
operator|==
name|t_shortarray
operator|||
name|fromtype
operator|==
name|t_mixedarray
operator|)
operator|&&
name|r_type
argument_list|(
name|prto
argument_list|)
operator|==
name|t_array
operator|)
condition|)
return|return
name|e_typecheck
return|;
name|check_read
argument_list|(
operator|*
name|prfrom
argument_list|)
expr_stmt|;
name|check_write
argument_list|(
operator|*
name|prto
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsize
operator|>
name|r_size
argument_list|(
name|prto
argument_list|)
operator|-
name|index
condition|)
return|return
name|e_rangecheck
return|;
switch|switch
condition|(
name|fromtype
condition|)
block|{
case|case
name|t_array
case|:
name|refcpy_to_old
argument_list|(
name|prto
operator|->
name|value
operator|.
name|refs
operator|+
name|index
argument_list|,
name|prfrom
operator|->
name|value
operator|.
name|refs
argument_list|,
name|fromsize
argument_list|,
name|cname
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|memcpy
argument_list|(
name|prto
operator|->
name|value
operator|.
name|bytes
operator|+
name|index
argument_list|,
name|prfrom
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|fromsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
block|{
name|int
name|i
decl_stmt|;
name|ushort
modifier|*
name|packed
init|=
name|prfrom
operator|->
name|value
operator|.
name|packed
decl_stmt|;
name|ref
modifier|*
name|pdest
init|=
name|prto
operator|->
name|value
operator|.
name|refs
operator|+
name|index
decl_stmt|;
name|ref
name|elt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fromsize
condition|;
name|i
operator|++
operator|,
name|pdest
operator|++
control|)
block|{
name|packed_get
argument_list|(
name|packed
argument_list|,
operator|&
name|elt
argument_list|)
expr_stmt|;
name|ref_assign_old
argument_list|(
name|pdest
argument_list|,
operator|&
name|elt
argument_list|,
name|cname
argument_list|)
expr_stmt|;
name|packed
operator|=
name|packed_next
argument_list|(
name|packed
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

