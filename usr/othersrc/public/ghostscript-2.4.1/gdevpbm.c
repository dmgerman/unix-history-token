begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevpbm.c */
end_comment

begin_comment
comment|/* Portable Bit/Gray/PixMap devices for Ghostscript. */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gxlum.h"
end_include

begin_comment
comment|/* Thanks are due to Jos Vos (jos@bull.nl) for an earlier P*M driver, */
end_comment

begin_comment
comment|/* on which this one is based. */
end_comment

begin_comment
comment|/* Structure for P*M devices, which extend the generic printer device. */
end_comment

begin_define
define|#
directive|define
name|MAX_COMMENT
value|70
end_define

begin_comment
comment|/* max user-supplied comment */
end_comment

begin_struct
struct|struct
name|gx_device_pbm_s
block|{
name|gx_device_common
expr_stmt|;
name|gx_prn_device_common
expr_stmt|;
comment|/* Additional state for P*M devices */
specifier|const
name|char
modifier|*
name|magic
decl_stmt|;
comment|/* "Pn" */
name|char
name|comment
index|[
name|MAX_COMMENT
operator|+
literal|1
index|]
decl_stmt|;
comment|/* comment for head of file */
name|byte
name|is_raw
decl_stmt|;
comment|/* 1 if raw format, 0 if plain */
name|byte
name|is_pbm
decl_stmt|;
comment|/* 1 if bitmap, 0 if gray or pixmap */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|gx_device_pbm_s
name|gx_device_pbm
typedef|;
end_typedef

begin_comment
comment|/* ------ The device descriptors ------ */
end_comment

begin_comment
comment|/*  * Standard U.S. page width and height.  A4 paper is 8.4" x 11.7".  */
end_comment

begin_define
define|#
directive|define
name|WIDTH_10THS
value|85
end_define

begin_define
define|#
directive|define
name|HEIGHT_10THS
value|110
end_define

begin_comment
comment|/*  * Default X and Y resolution.  */
end_comment

begin_define
define|#
directive|define
name|X_DPI
value|72
end_define

begin_define
define|#
directive|define
name|Y_DPI
value|72
end_define

begin_comment
comment|/* Macro for generating P*M device descriptors. */
end_comment

begin_define
define|#
directive|define
name|pbm_prn_device
parameter_list|(
name|procs
parameter_list|,
name|dev_name
parameter_list|,
name|magic
parameter_list|,
name|is_raw
parameter_list|,
name|num_comp
parameter_list|,
name|depth
parameter_list|,
name|max_gray
parameter_list|,
name|max_rgb
parameter_list|,
name|print_page
parameter_list|)
define|\
value|{	prn_device_body(gx_device_pbm, procs, dev_name,\ 	  WIDTH_10THS, HEIGHT_10THS, X_DPI, Y_DPI,\ 	  0, 0, 0, 0,\ 	  num_comp, depth, max_gray, max_rgb, max_gray + 1, max_rgb + 1,\ 	  print_page),\ 	magic,\ 	 { 0 },\ 	is_raw,\ 	(depth == 1)\ }
end_define

begin_comment
comment|/* For all PBM variants we do some extra things at opening time. */
end_comment

begin_comment
comment|/* private dev_proc_open_device(gdev_pbm_open); */
end_comment

begin_define
define|#
directive|define
name|gdev_pbm_open
value|gdev_prn_open
end_define

begin_comment
comment|/* no we don't! */
end_comment

begin_comment
comment|/* For PGM and PPM we need our own color mapping procedures. */
end_comment

begin_function_decl
name|private
name|dev_proc_map_rgb_color
parameter_list|(
name|pgm_map_rgb_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_rgb_color
parameter_list|(
name|ppm_map_rgb_color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_color_rgb
parameter_list|(
name|pgm_map_color_rgb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_map_color_rgb
parameter_list|(
name|ppm_map_color_rgb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* And of course we need our own print-page routines. */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|pbm_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|pbm_raw_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|pgm_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|ppm_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The device procedures */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|pbm_procs
init|=
name|prn_procs
argument_list|(
name|gdev_pbm_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_device_procs
name|pgm_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_pbm_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|pgm_map_rgb_color
argument_list|,
name|pgm_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_device_procs
name|ppm_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_pbm_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|ppm_map_rgb_color
argument_list|,
name|ppm_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The device descriptors themselves */
end_comment

begin_decl_stmt
name|gx_device_pbm
name|gs_pbm_device
init|=
name|pbm_prn_device
argument_list|(
name|pbm_procs
argument_list|,
literal|"pbm"
argument_list|,
literal|"P1"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pbm_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_pbm
name|gs_pbmraw_device
init|=
name|pbm_prn_device
argument_list|(
name|pbm_procs
argument_list|,
literal|"pbmraw"
argument_list|,
literal|"P4"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|pbm_raw_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_pbm
name|gs_pgm_device
init|=
name|pbm_prn_device
argument_list|(
name|pgm_procs
argument_list|,
literal|"pgm"
argument_list|,
literal|"P2"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|pgm_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_pbm
name|gs_pgmraw_device
init|=
name|pbm_prn_device
argument_list|(
name|pgm_procs
argument_list|,
literal|"pgmraw"
argument_list|,
literal|"P5"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|,
name|pgm_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_pbm
name|gs_ppm_device
init|=
name|pbm_prn_device
argument_list|(
name|ppm_procs
argument_list|,
literal|"ppm"
argument_list|,
literal|"P3"
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|24
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
name|ppm_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_pbm
name|gs_ppmraw_device
init|=
name|pbm_prn_device
argument_list|(
name|ppm_procs
argument_list|,
literal|"ppmraw"
argument_list|,
literal|"P6"
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|24
argument_list|,
literal|255
argument_list|,
literal|255
argument_list|,
name|ppm_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Color mapping routines ------ */
end_comment

begin_comment
comment|/* Map an RGB color to a PGM gray value. */
end_comment

begin_function
name|private
name|gx_color_index
name|pgm_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|ushort
name|r
parameter_list|,
name|ushort
name|g
parameter_list|,
name|ushort
name|b
parameter_list|)
block|{
comment|/* We round the value rather than truncating it. */
return|return
operator|(
operator|(
name|r
operator|*
operator|(
name|ulong
operator|)
name|lum_red_weight
operator|)
operator|+
operator|(
name|g
operator|*
operator|(
name|ulong
operator|)
name|lum_green_weight
operator|)
operator|+
operator|(
name|b
operator|*
operator|(
name|ulong
operator|)
name|lum_blue_weight
operator|)
operator|+
operator|(
name|lum_all_weights
operator|/
literal|2
operator|)
operator|)
operator|/
name|lum_all_weights
operator|*
name|dev
operator|->
name|color_info
operator|.
name|max_gray
operator|/
name|gx_max_color_value
return|;
block|}
end_function

begin_comment
comment|/* Map a PGM gray value back to an RGB color. */
end_comment

begin_function
name|private
name|int
name|pgm_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|ushort
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|gx_color_value
name|gray
init|=
name|color
operator|*
name|gx_max_color_value
operator|/
name|dev
operator|->
name|color_info
operator|.
name|max_gray
decl_stmt|;
name|prgb
index|[
literal|0
index|]
operator|=
name|gray
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
name|gray
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
name|gray
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map an RGB color to a PPM color tuple. */
end_comment

begin_function
name|private
name|gx_color_index
name|ppm_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|ushort
name|r
parameter_list|,
name|ushort
name|g
parameter_list|,
name|ushort
name|b
parameter_list|)
block|{
name|ushort
name|bitspercolor
init|=
name|dev
operator|->
name|color_info
operator|.
name|depth
operator|/
literal|3
decl_stmt|;
name|ulong
name|max_value
init|=
operator|(
literal|1
operator|<<
name|bitspercolor
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
operator|(
name|r
operator|*
name|max_value
operator|/
name|gx_max_color_value
operator|)
operator|<<
operator|(
name|bitspercolor
operator|*
literal|2
operator|)
operator|)
operator|+
operator|(
operator|(
name|g
operator|*
name|max_value
operator|/
name|gx_max_color_value
operator|)
operator|<<
name|bitspercolor
operator|)
operator|+
operator|(
name|b
operator|*
name|max_value
operator|/
name|gx_max_color_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Map a PPM color tuple back to an RGB color. */
end_comment

begin_function
name|private
name|int
name|ppm_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|ushort
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
name|ushort
name|bitspercolor
init|=
name|dev
operator|->
name|color_info
operator|.
name|depth
operator|/
literal|3
decl_stmt|;
name|ushort
name|colormask
init|=
operator|(
literal|1
operator|<<
name|bitspercolor
operator|)
operator|-
literal|1
decl_stmt|;
name|prgb
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|color
operator|>>
operator|(
name|bitspercolor
operator|*
literal|2
operator|)
operator|)
operator|&
name|colormask
operator|)
operator|*
operator|(
name|ulong
operator|)
name|gx_max_color_value
operator|/
name|colormask
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|color
operator|>>
name|bitspercolor
operator|)
operator|&
name|colormask
operator|)
operator|*
operator|(
name|ulong
operator|)
name|gx_max_color_value
operator|/
name|colormask
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
operator|(
name|color
operator|&
name|colormask
operator|)
operator|*
operator|(
name|ulong
operator|)
name|gx_max_color_value
operator|/
name|colormask
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Define a "cursor" that keeps track of where we are in the page. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pbm_cursor_s
block|{
name|gx_device_pbm
modifier|*
name|dev
decl_stmt|;
name|int
name|bpp
decl_stmt|;
comment|/* bits per pixel */
name|uint
name|line_size
decl_stmt|;
comment|/* bytes per scan line */
name|byte
modifier|*
name|data
decl_stmt|;
comment|/* output row buffer */
name|int
name|lnum
decl_stmt|;
comment|/* row within page */
block|}
name|pbm_cursor
typedef|;
end_typedef

begin_comment
comment|/* Begin a P*M output page. */
end_comment

begin_comment
comment|/* Write the header information and initialize the cursor. */
end_comment

begin_function
name|private
name|int
name|pbm_begin_page
parameter_list|(
name|gx_device_pbm
modifier|*
name|bdev
parameter_list|,
name|FILE
modifier|*
name|pstream
parameter_list|,
name|pbm_cursor
name|_ss
modifier|*
name|pcur
parameter_list|)
block|{
name|uint
name|line_size
init|=
name|gdev_prn_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device_printer
operator|*
operator|)
name|bdev
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|data
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|line_size
argument_list|,
literal|1
argument_list|,
literal|"pbm_begin_page"
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|fprintf
argument_list|(
name|pstream
argument_list|,
literal|"%s\n"
argument_list|,
name|bdev
operator|->
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdev
operator|->
name|comment
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|pstream
argument_list|,
literal|"# %s\n"
argument_list|,
name|bdev
operator|->
name|comment
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|pstream
argument_list|,
literal|"# Image generated by Ghostscript (device=%s)\n"
argument_list|,
name|bdev
operator|->
name|dname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pstream
argument_list|,
literal|"%d %d\n"
argument_list|,
name|bdev
operator|->
name|width
argument_list|,
name|bdev
operator|->
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bdev
operator|->
name|is_pbm
condition|)
name|fprintf
argument_list|(
name|pstream
argument_list|,
literal|"%d\n"
argument_list|,
name|bdev
operator|->
name|color_info
operator|.
name|max_gray
argument_list|)
expr_stmt|;
comment|/* Initialize the cursor. */
name|pcur
operator|->
name|dev
operator|=
name|bdev
expr_stmt|;
name|pcur
operator|->
name|bpp
operator|=
name|bdev
operator|->
name|color_info
operator|.
name|depth
expr_stmt|;
name|pcur
operator|->
name|line_size
operator|=
name|line_size
expr_stmt|;
name|pcur
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|pcur
operator|->
name|lnum
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Advance to the next row.  Return 0 if more, 1 if done. */
end_comment

begin_function
name|private
name|int
name|pbm_next_row
parameter_list|(
name|pbm_cursor
name|_ss
modifier|*
name|pcur
parameter_list|)
block|{
if|if
condition|(
name|pcur
operator|->
name|lnum
operator|>=
name|pcur
operator|->
name|dev
operator|->
name|height
condition|)
block|{
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pcur
operator|->
name|data
argument_list|,
name|pcur
operator|->
name|line_size
argument_list|,
literal|1
argument_list|,
literal|"pbm_next_row(done)"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|gdev_prn_copy_scan_lines
argument_list|(
operator|(
name|gx_device_printer
operator|*
operator|)
name|pcur
operator|->
name|dev
argument_list|,
name|pcur
operator|->
name|lnum
operator|++
argument_list|,
name|pcur
operator|->
name|data
argument_list|,
name|pcur
operator|->
name|line_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Individual page printing routines ------ */
end_comment

begin_define
define|#
directive|define
name|bdev
value|((gx_device_pbm *)pdev)
end_define

begin_comment
comment|/* Print a raw monobit page. */
end_comment

begin_function
name|private
name|int
name|pbm_raw_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|pstream
parameter_list|)
block|{
comment|/* All the print_page routines have the same structure; */
comment|/* only the indicated section is different. */
name|pbm_cursor
name|cur
decl_stmt|;
name|int
name|code
init|=
name|pbm_begin_page
argument_list|(
name|bdev
argument_list|,
name|pstream
argument_list|,
operator|&
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
while|while
condition|(
operator|!
operator|(
name|code
operator|=
name|pbm_next_row
argument_list|(
operator|&
name|cur
argument_list|)
operator|)
condition|)
block|{
comment|/* ---- This section changes. ---- */
name|fwrite
argument_list|(
name|cur
operator|.
name|data
argument_list|,
literal|1
argument_list|,
name|cur
operator|.
name|line_size
argument_list|,
name|pstream
argument_list|)
expr_stmt|;
comment|/* ---- End of changing section. ---- */
block|}
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print an ASCII monobit page. */
end_comment

begin_function
name|private
name|int
name|pbm_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|pstream
parameter_list|)
block|{
name|pbm_cursor
name|cur
decl_stmt|;
name|int
name|code
init|=
name|pbm_begin_page
argument_list|(
name|bdev
argument_list|,
name|pstream
argument_list|,
operator|&
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
while|while
condition|(
operator|!
operator|(
name|code
operator|=
name|pbm_next_row
argument_list|(
operator|&
name|cur
argument_list|)
operator|)
condition|)
block|{
name|byte
modifier|*
name|bp
decl_stmt|;
name|uint
name|x
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|cur
operator|.
name|data
operator|,
name|x
operator|=
literal|0
operator|,
name|mask
operator|=
literal|0x80
init|;
name|x
operator|<
name|bdev
operator|->
name|width
condition|;
operator|(
name|mask
operator|>>=
literal|1
operator|)
operator|!=
literal|0
operator|||
operator|(
name|bp
operator|++
operator|,
name|mask
operator|=
literal|0x80
operator|)
control|)
block|{
name|putc
argument_list|(
operator|(
operator|*
name|bp
operator|&
name|mask
condition|?
literal|'1'
else|:
literal|'0'
operator|)
argument_list|,
name|pstream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|x
operator|==
name|bdev
operator|->
name|width
operator|||
operator|!
operator|(
name|x
operator|&
literal|63
operator|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pstream
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print a gray-mapped page. */
end_comment

begin_function
name|private
name|int
name|pgm_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|pstream
parameter_list|)
block|{
name|pbm_cursor
name|cur
decl_stmt|;
name|int
name|code
init|=
name|pbm_begin_page
argument_list|(
name|bdev
argument_list|,
name|pstream
argument_list|,
operator|&
name|cur
argument_list|)
decl_stmt|;
name|uint
name|mask
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Note that bpp<= 8 for raw format, bpp<= 16 for plain. */
name|mask
operator|=
operator|(
literal|1
operator|<<
name|cur
operator|.
name|bpp
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|code
operator|=
name|pbm_next_row
argument_list|(
operator|&
name|cur
argument_list|)
operator|)
condition|)
block|{
name|byte
modifier|*
name|bp
decl_stmt|;
name|uint
name|x
decl_stmt|;
name|int
name|shift
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|cur
operator|.
name|data
operator|,
name|x
operator|=
literal|0
operator|,
name|shift
operator|=
literal|8
operator|-
name|cur
operator|.
name|bpp
init|;
name|x
operator|<
name|bdev
operator|->
name|width
condition|;
control|)
block|{
name|uint
name|pixel
decl_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
comment|/* bpp = 16 */
block|{
name|pixel
operator|=
operator|(
operator|(
name|uint
operator|)
operator|*
name|bp
operator|<<
literal|8
operator|)
operator|+
name|bp
index|[
literal|1
index|]
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|pixel
operator|=
operator|(
operator|*
name|bp
operator|>>
name|shift
operator|)
operator|&
name|mask
expr_stmt|;
if|if
condition|(
operator|(
name|shift
operator|-=
name|cur
operator|.
name|bpp
operator|)
operator|<
literal|0
condition|)
name|bp
operator|++
operator|,
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
operator|++
name|x
expr_stmt|;
if|if
condition|(
name|bdev
operator|->
name|is_raw
condition|)
name|putc
argument_list|(
name|pixel
argument_list|,
name|pstream
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|pstream
argument_list|,
literal|"%d%c"
argument_list|,
name|pixel
argument_list|,
operator|(
name|x
operator|==
name|bdev
operator|->
name|width
operator|||
operator|!
operator|(
name|x
operator|&
literal|15
operator|)
condition|?
literal|'\n'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print a color-mapped page. */
end_comment

begin_function
name|private
name|int
name|ppm_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|pstream
parameter_list|)
block|{
name|pbm_cursor
name|cur
decl_stmt|;
name|int
name|code
init|=
name|pbm_begin_page
argument_list|(
name|bdev
argument_list|,
name|pstream
argument_list|,
operator|&
name|cur
argument_list|)
decl_stmt|;
name|uint
name|bpe
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Note that bpp<= 24 for raw format, bpp<= 32 for plain. */
name|bpe
operator|=
name|cur
operator|.
name|bpp
operator|/
literal|3
expr_stmt|;
comment|/* bits per r/g/b element */
name|mask
operator|=
operator|(
literal|1
operator|<<
name|bpe
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|code
operator|=
name|pbm_next_row
argument_list|(
operator|&
name|cur
argument_list|)
operator|)
condition|)
block|{
name|byte
modifier|*
name|bp
decl_stmt|;
name|uint
name|x
decl_stmt|;
name|int
name|shift
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|cur
operator|.
name|data
operator|,
name|x
operator|=
literal|0
operator|,
name|shift
operator|=
literal|8
operator|-
name|cur
operator|.
name|bpp
init|;
name|x
operator|<
name|bdev
operator|->
name|width
condition|;
control|)
block|{
name|ulong
name|pixel
init|=
literal|0
decl_stmt|;
name|uint
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
switch|switch
condition|(
name|cur
operator|.
name|bpp
operator|>>
literal|3
condition|)
block|{
case|case
literal|3
case|:
name|pixel
operator|=
operator|(
name|ulong
operator|)
operator|*
name|bp
operator|<<
literal|16
expr_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* falls through */
case|case
literal|2
case|:
name|pixel
operator|+=
operator|(
name|uint
operator|)
operator|*
name|bp
operator|<<
literal|8
expr_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* falls through */
case|case
literal|1
case|:
name|pixel
operator|+=
operator|*
name|bp
expr_stmt|;
name|bp
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* bpp == 4, bpe == 1 */
name|pixel
operator|=
operator|*
name|bp
operator|>>
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|shift
operator|-=
name|cur
operator|.
name|bpp
operator|)
operator|<
literal|0
condition|)
name|bp
operator|++
operator|,
name|shift
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
operator|++
name|x
expr_stmt|;
name|b
operator|=
name|pixel
operator|&
name|mask
expr_stmt|;
name|pixel
operator|>>=
name|bpe
expr_stmt|;
name|g
operator|=
name|pixel
operator|&
name|mask
expr_stmt|;
name|pixel
operator|>>=
name|bpe
expr_stmt|;
name|r
operator|=
name|pixel
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|bdev
operator|->
name|is_raw
condition|)
block|{
name|putc
argument_list|(
name|r
argument_list|,
name|pstream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|g
argument_list|,
name|pstream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|b
argument_list|,
name|pstream
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|pstream
argument_list|,
literal|"%d %d %d%c"
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
operator|(
name|x
operator|==
name|bdev
operator|->
name|width
operator|||
operator|!
operator|(
name|x
operator|&
literal|7
operator|)
condition|?
literal|'\n'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
literal|0
operator|)
return|;
block|}
end_function

end_unit

