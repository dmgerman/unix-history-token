begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gscolor.c */
end_comment

begin_comment
comment|/* Color and halftone operators for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for gzstate.h */
end_comment

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* for gx_color_index */
end_comment

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_include
include|#
directive|include
file|"gzht.h"
end_include

begin_comment
comment|/* Halftone enumeration structure */
end_comment

begin_struct
struct|struct
name|gs_screen_enum_s
block|{
name|halftone_params
name|ht
decl_stmt|;
comment|/* constructed here */
name|gs_matrix
name|mat
decl_stmt|;
comment|/* for mapping device x,y to rotated cell */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|gs_state
modifier|*
name|pgs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Exported values */
end_comment

begin_decl_stmt
specifier|const
name|uint
name|gs_screen_enum_sizeof
init|=
sizeof|sizeof
argument_list|(
name|gs_screen_enum
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|uint
name|gs_color_sizeof
init|=
sizeof|sizeof
argument_list|(
name|gs_color
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|private
name|void
name|tri_param
argument_list|(
name|P4
argument_list|(
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|color_param
index|[
literal|3
index|]
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|tri_return
argument_list|(
name|P4
argument_list|(
name|color_param
argument_list|,
name|color_param
argument_list|,
name|color_param
argument_list|,
name|float
index|[
literal|3
index|]
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|set_phase
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|load_transfer_map
argument_list|(
name|P2
argument_list|(
name|gs_state
operator|*
argument_list|,
name|gx_transfer_map
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|unshare_transfer
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Imported from gxcolor.c */
end_comment

begin_decl_stmt
name|void
name|gx_color_from_hsb
argument_list|(
name|P4
argument_list|(
name|gs_color
operator|*
argument_list|,
name|color_param
argument_list|,
name|color_param
argument_list|,
name|color_param
argument_list|)
argument_list|)
decl_stmt|,
name|gx_color_from_rgb
argument_list|(
name|P1
argument_list|(
name|gs_color
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|gx_color_to_hsb
argument_list|(
name|P2
argument_list|(
name|gs_color
operator|*
argument_list|,
name|color_param
index|[
literal|3
index|]
argument_list|)
argument_list|)
decl_stmt|,
name|gx_sort_ht_order
argument_list|(
name|P2
argument_list|(
name|ht_bit
operator|*
argument_list|,
name|uint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* setgray */
end_comment

begin_function
name|int
name|gs_setgray
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|gray
parameter_list|)
block|{
if|if
condition|(
name|pgs
operator|->
name|in_cachedevice
condition|)
name|return_error
argument_list|(
name|gs_error_undefined
argument_list|)
expr_stmt|;
name|gx_set_gray_only
argument_list|(
name|pgs
operator|->
name|color
argument_list|,
name|gx_color_unit_param
argument_list|(
name|gray
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gx_remap_color
argument_list|(
name|pgs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* currentgray */
end_comment

begin_function
name|float
name|gs_currentgray
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
call|(
name|float
call|)
argument_list|(
name|color_luminance
argument_list|(
name|pgs
operator|->
name|color
argument_list|)
operator|/
name|max_color_param_float
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* sethsbcolor */
end_comment

begin_function
name|int
name|gs_sethsbcolor
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|h
parameter_list|,
name|floatp
name|s
parameter_list|,
name|floatp
name|b
parameter_list|)
block|{
name|color_param
name|params
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|pgs
operator|->
name|in_cachedevice
condition|)
name|return_error
argument_list|(
name|gs_error_undefined
argument_list|)
expr_stmt|;
name|tri_param
argument_list|(
name|h
argument_list|,
name|s
argument_list|,
name|b
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|gx_color_from_hsb
argument_list|(
name|pgs
operator|->
name|color
argument_list|,
name|params
index|[
literal|0
index|]
argument_list|,
name|params
index|[
literal|1
index|]
argument_list|,
name|params
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|gx_remap_color
argument_list|(
name|pgs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* currenthsbcolor */
end_comment

begin_function
name|int
name|gs_currenthsbcolor
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|float
name|pr3
index|[
literal|3
index|]
parameter_list|)
block|{
name|color_param
name|hsb
index|[
literal|3
index|]
decl_stmt|;
name|gx_color_to_hsb
argument_list|(
name|pgs
operator|->
name|color
argument_list|,
name|hsb
argument_list|)
expr_stmt|;
name|tri_return
argument_list|(
name|hsb
index|[
literal|0
index|]
argument_list|,
name|hsb
index|[
literal|1
index|]
argument_list|,
name|hsb
index|[
literal|2
index|]
argument_list|,
name|pr3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setrgbcolor */
end_comment

begin_function
name|int
name|gs_setrgbcolor
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|r
parameter_list|,
name|floatp
name|g
parameter_list|,
name|floatp
name|b
parameter_list|)
block|{
if|if
condition|(
name|pgs
operator|->
name|in_cachedevice
condition|)
name|return_error
argument_list|(
name|gs_error_undefined
argument_list|)
expr_stmt|;
name|gx_set_rgb_only
argument_list|(
name|pgs
operator|->
name|color
argument_list|,
name|gx_color_unit_param
argument_list|(
name|r
argument_list|)
argument_list|,
name|gx_color_unit_param
argument_list|(
name|g
argument_list|)
argument_list|,
name|gx_color_unit_param
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gx_remap_color
argument_list|(
name|pgs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* currentrgbcolor */
end_comment

begin_function
name|int
name|gs_currentrgbcolor
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|float
name|pr3
index|[
literal|3
index|]
parameter_list|)
block|{
name|gs_color
modifier|*
name|pcolor
init|=
name|pgs
operator|->
name|color
decl_stmt|;
name|tri_return
argument_list|(
name|pcolor
operator|->
name|red
argument_list|,
name|pcolor
operator|->
name|green
argument_list|,
name|pcolor
operator|->
name|blue
argument_list|,
name|pr3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentcolorspace */
end_comment

begin_function
name|int
name|gs_currentcolorspace
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_color_space
modifier|*
name|pcs
parameter_list|)
block|{
operator|*
name|pcs
operator|=
operator|(
name|gs_color_space
operator|)
name|pgs
operator|->
name|color
operator|->
name|space
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setscreen */
end_comment

begin_decl_stmt
name|int
name|gs_setscreen
argument_list|(
name|gs_state
operator|*
name|pgs
argument_list|,
name|floatp
name|freq
argument_list|,
name|floatp
name|angle
argument_list|,
name|float
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|(
name|P2
argument_list|(
name|floatp
argument_list|,
name|floatp
argument_list|)
argument_list|)
argument_list|)
block|{
name|gs_screen_enum
name|senum
decl_stmt|;
name|gs_point
name|pt
decl_stmt|;
name|int
name|code
init|=
name|gs_screen_init
argument_list|(
operator|&
name|senum
argument_list|,
name|pgs
argument_list|,
name|freq
argument_list|,
name|angle
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
while|while
condition|(
operator|(
name|code
operator|=
name|gs_screen_currentpoint
argument_list|(
operator|&
name|senum
argument_list|,
operator|&
name|pt
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|code
operator|=
name|gs_screen_next
argument_list|(
operator|&
name|senum
argument_list|,
call|(
modifier|*
name|proc
call|)
argument_list|(
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pgs
operator|->
name|ht_proc
operator|=
name|proc
expr_stmt|;
name|set_phase
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* currentscreen */
end_comment

begin_decl_stmt
name|int
name|gs_currentscreen
argument_list|(
name|gs_state
operator|*
name|pgs
argument_list|,
name|float
operator|*
name|pfreq
argument_list|,
name|float
operator|*
name|pangle
argument_list|,
name|float
argument_list|(
operator|*
operator|*
name|pproc
argument_list|)
argument_list|(
name|P2
argument_list|(
name|floatp
argument_list|,
name|floatp
argument_list|)
argument_list|)
argument_list|)
block|{
name|halftone_params
modifier|*
name|pht
init|=
name|pgs
operator|->
name|halftone
decl_stmt|;
operator|*
name|pfreq
operator|=
name|pht
operator|->
name|frequency
expr_stmt|;
operator|*
name|pangle
operator|=
name|pht
operator|->
name|angle
expr_stmt|;
operator|*
name|pproc
operator|=
name|pgs
operator|->
name|ht_proc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* settransfer */
end_comment

begin_comment
comment|/* Remap=0 is used by the interpreter. */
end_comment

begin_function
name|int
name|gs_settransfer_remap
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_transfer_proc
name|tproc
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|int
name|code
init|=
name|unshare_transfer
argument_list|(
name|pgs
argument_list|)
decl_stmt|;
name|gx_transfer
modifier|*
name|ptran
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|ptran
operator|=
name|pgs
operator|->
name|transfer
expr_stmt|;
name|ptran
operator|->
name|gray
operator|.
name|proc
operator|=
name|tproc
expr_stmt|;
if|if
condition|(
name|remap
condition|)
name|load_transfer_map
argument_list|(
name|pgs
argument_list|,
operator|&
name|ptran
operator|->
name|gray
argument_list|)
expr_stmt|;
name|ptran
operator|->
name|red
operator|=
name|ptran
operator|->
name|gray
expr_stmt|;
name|ptran
operator|->
name|green
operator|=
name|ptran
operator|->
name|gray
expr_stmt|;
name|ptran
operator|->
name|blue
operator|=
name|ptran
operator|->
name|gray
expr_stmt|;
return|return
operator|(
name|remap
condition|?
name|gx_remap_color
argument_list|(
name|pgs
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gs_settransfer
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_transfer_proc
name|tproc
parameter_list|)
block|{
return|return
name|gs_settransfer_remap
argument_list|(
name|pgs
argument_list|,
name|tproc
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* currenttransfer */
end_comment

begin_function
name|gs_transfer_proc
name|gs_currenttransfer
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|transfer
operator|->
name|gray
operator|.
name|proc
return|;
block|}
end_function

begin_comment
comment|/* setcolortransfer */
end_comment

begin_comment
comment|/* Remap=0 is used by the interpreter. */
end_comment

begin_function
name|int
name|gs_setcolortransfer_remap
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_transfer_proc
name|red_proc
parameter_list|,
name|gs_transfer_proc
name|green_proc
parameter_list|,
name|gs_transfer_proc
name|blue_proc
parameter_list|,
name|gs_transfer_proc
name|gray_proc
parameter_list|,
name|int
name|remap
parameter_list|)
block|{
name|int
name|code
init|=
name|unshare_transfer
argument_list|(
name|pgs
argument_list|)
decl_stmt|;
name|gx_transfer
modifier|*
name|ptran
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|ptran
operator|=
name|pgs
operator|->
name|transfer
expr_stmt|;
name|ptran
operator|->
name|red
operator|.
name|proc
operator|=
name|red_proc
expr_stmt|;
name|ptran
operator|->
name|green
operator|.
name|proc
operator|=
name|green_proc
expr_stmt|;
name|ptran
operator|->
name|blue
operator|.
name|proc
operator|=
name|blue_proc
expr_stmt|;
name|ptran
operator|->
name|gray
operator|.
name|proc
operator|=
name|gray_proc
expr_stmt|;
if|if
condition|(
name|remap
condition|)
block|{
name|load_transfer_map
argument_list|(
name|pgs
argument_list|,
operator|&
name|ptran
operator|->
name|red
argument_list|)
expr_stmt|;
name|load_transfer_map
argument_list|(
name|pgs
argument_list|,
operator|&
name|ptran
operator|->
name|green
argument_list|)
expr_stmt|;
name|load_transfer_map
argument_list|(
name|pgs
argument_list|,
operator|&
name|ptran
operator|->
name|blue
argument_list|)
expr_stmt|;
name|load_transfer_map
argument_list|(
name|pgs
argument_list|,
operator|&
name|ptran
operator|->
name|gray
argument_list|)
expr_stmt|;
return|return
name|gx_remap_color
argument_list|(
name|pgs
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|gs_setcolortransfer
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_transfer_proc
name|red_proc
parameter_list|,
name|gs_transfer_proc
name|green_proc
parameter_list|,
name|gs_transfer_proc
name|blue_proc
parameter_list|,
name|gs_transfer_proc
name|gray_proc
parameter_list|)
block|{
return|return
name|gs_setcolortransfer_remap
argument_list|(
name|pgs
argument_list|,
name|red_proc
argument_list|,
name|green_proc
argument_list|,
name|blue_proc
argument_list|,
name|gray_proc
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* currentcolortransfer */
end_comment

begin_function
name|void
name|gs_currentcolortransfer
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_transfer_proc
name|procs
index|[
literal|4
index|]
parameter_list|)
block|{
name|gx_transfer
modifier|*
name|ptran
init|=
name|pgs
operator|->
name|transfer
decl_stmt|;
name|procs
index|[
literal|0
index|]
operator|=
name|ptran
operator|->
name|red
operator|.
name|proc
expr_stmt|;
name|procs
index|[
literal|1
index|]
operator|=
name|ptran
operator|->
name|green
operator|.
name|proc
expr_stmt|;
name|procs
index|[
literal|2
index|]
operator|=
name|ptran
operator|->
name|blue
operator|.
name|proc
expr_stmt|;
name|procs
index|[
literal|3
index|]
operator|=
name|ptran
operator|->
name|gray
operator|.
name|proc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sethalftonephase */
end_comment

begin_function
name|int
name|gs_sethalftonephase
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|pgs
operator|->
name|ht_phase
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|pgs
operator|->
name|ht_phase
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|set_phase
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currenthalftonephase */
end_comment

begin_function
name|int
name|gs_currenthalftonephase
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_int_point
modifier|*
name|pphase
parameter_list|)
block|{
operator|*
name|pphase
operator|=
name|pgs
operator|->
name|ht_phase
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Halftone sampling ------ */
end_comment

begin_comment
comment|/* Set up for halftone sampling */
end_comment

begin_function
name|int
name|gs_screen_init
parameter_list|(
name|gs_screen_enum
modifier|*
name|penum
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|freq
parameter_list|,
name|floatp
name|angle
parameter_list|)
block|{
name|int
name|cwidth
decl_stmt|,
name|cheight
decl_stmt|;
name|int
name|code
decl_stmt|;
name|ht_bit
modifier|*
name|order
decl_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0.0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
comment|/* Convert the frequency to cell width and height */
block|{
name|float
name|cell_size
init|=
literal|72.0
operator|/
name|freq
decl_stmt|;
name|gs_point
name|pcwh
decl_stmt|;
name|gs_matrix
name|imat
decl_stmt|;
name|gs_deviceinitialmatrix
argument_list|(
name|gs_currentdevice
argument_list|(
name|pgs
argument_list|)
argument_list|,
operator|&
name|imat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_distance_transform
argument_list|(
name|cell_size
argument_list|,
name|cell_size
argument_list|,
operator|&
name|imat
argument_list|,
operator|&
name|pcwh
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* It isn't clear to me whether we should round the */
comment|/* width and height, truncate them, or do something */
comment|/* more complicated.  All the problems arise from devices */
comment|/* whose X and Y resolutions aren't the same: */
comment|/* the halftone model isn't really designed for this. */
comment|/* For the moment, truncate and hope for the best. */
define|#
directive|define
name|abs_round
parameter_list|(
name|z
parameter_list|)
value|(z< 0 ? -(int)(z) : (int)(z))
comment|/*#define abs_round(z) (z< 0 ? -(int)(z - 0.5) : (int)(z + 0.5))*/
name|cwidth
operator|=
name|abs_round
argument_list|(
name|pcwh
operator|.
name|x
argument_list|)
expr_stmt|;
name|cheight
operator|=
name|abs_round
argument_list|(
name|pcwh
operator|.
name|y
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|abs_round
block|}
comment|/* Force a halfway reasonable cell size. */
if|if
condition|(
name|cwidth
operator|<=
literal|4
condition|)
name|cwidth
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|cheight
operator|<=
literal|4
condition|)
name|cheight
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|cwidth
operator|>
name|max_ushort
operator|/
name|cheight
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
name|order
operator|=
operator|(
name|ht_bit
operator|*
operator|)
name|gs_malloc
argument_list|(
name|cwidth
operator|*
name|cheight
argument_list|,
sizeof|sizeof
argument_list|(
name|ht_bit
argument_list|)
argument_list|,
literal|"halftone samples"
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|penum
operator|->
name|ht
operator|.
name|frequency
operator|=
name|freq
expr_stmt|;
name|penum
operator|->
name|ht
operator|.
name|angle
operator|=
name|angle
expr_stmt|;
name|penum
operator|->
name|ht
operator|.
name|order
operator|=
name|order
expr_stmt|;
name|penum
operator|->
name|ht
operator|.
name|width
operator|=
name|cwidth
expr_stmt|;
name|penum
operator|->
name|ht
operator|.
name|height
operator|=
name|cheight
expr_stmt|;
name|penum
operator|->
name|ht
operator|.
name|order_size
operator|=
name|cwidth
operator|*
name|cheight
expr_stmt|;
name|penum
operator|->
name|x
operator|=
name|penum
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|penum
operator|->
name|pgs
operator|=
name|pgs
expr_stmt|;
comment|/* The transformation matrix must include normalization to the */
comment|/* interval (-1..1), and rotation by the negative of the angle. */
block|{
name|float
name|xscale
init|=
literal|2.0
operator|/
name|cwidth
decl_stmt|;
name|float
name|yscale
init|=
literal|2.0
operator|/
name|cheight
decl_stmt|;
name|gs_matrix
name|mat
decl_stmt|;
name|gs_make_identity
argument_list|(
operator|&
name|mat
argument_list|)
expr_stmt|;
name|mat
operator|.
name|xx
operator|=
name|xscale
expr_stmt|;
name|mat
operator|.
name|yy
operator|=
name|yscale
expr_stmt|;
name|mat
operator|.
name|tx
operator|=
name|xscale
operator|*
literal|0.5
operator|-
literal|1.0
expr_stmt|;
name|mat
operator|.
name|ty
operator|=
name|yscale
operator|*
literal|0.5
operator|-
literal|1.0
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_matrix_rotate
argument_list|(
operator|&
name|mat
argument_list|,
operator|-
name|angle
argument_list|,
operator|&
name|penum
operator|->
name|mat
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'h'
index|]
condition|)
name|dprintf8
argument_list|(
literal|"[h]Screen: w=%d h=%d [%f %f %f %f %f %f]\n"
argument_list|,
name|cwidth
argument_list|,
name|cheight
argument_list|,
name|penum
operator|->
name|mat
operator|.
name|xx
argument_list|,
name|penum
operator|->
name|mat
operator|.
name|xy
argument_list|,
name|penum
operator|->
name|mat
operator|.
name|yx
argument_list|,
name|penum
operator|->
name|mat
operator|.
name|yy
argument_list|,
name|penum
operator|->
name|mat
operator|.
name|tx
argument_list|,
name|penum
operator|->
name|mat
operator|.
name|ty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Report current point for sampling */
end_comment

begin_decl_stmt
name|private
name|int
name|gx_screen_finish
argument_list|(
name|P1
argument_list|(
name|gs_screen_enum
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|gs_screen_currentpoint
parameter_list|(
name|gs_screen_enum
modifier|*
name|penum
parameter_list|,
name|gs_point
modifier|*
name|ppt
parameter_list|)
block|{
name|gs_point
name|pt
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|penum
operator|->
name|y
operator|>=
name|penum
operator|->
name|ht
operator|.
name|height
condition|)
comment|/* all done */
return|return
name|gx_screen_finish
argument_list|(
name|penum
argument_list|)
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_point_transform
argument_list|(
operator|(
name|floatp
operator|)
name|penum
operator|->
name|x
argument_list|,
operator|(
name|floatp
operator|)
name|penum
operator|->
name|y
argument_list|,
operator|&
name|penum
operator|->
name|mat
argument_list|,
operator|&
name|pt
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
while|while
condition|(
name|pt
operator|.
name|x
operator|<
operator|-
literal|1.0
condition|)
name|pt
operator|.
name|x
operator|+=
literal|2.0
expr_stmt|;
while|while
condition|(
name|pt
operator|.
name|x
operator|>=
literal|1.0
condition|)
name|pt
operator|.
name|x
operator|-=
literal|2.0
expr_stmt|;
while|while
condition|(
name|pt
operator|.
name|y
operator|<
operator|-
literal|1.0
condition|)
name|pt
operator|.
name|y
operator|+=
literal|2.0
expr_stmt|;
while|while
condition|(
name|pt
operator|.
name|y
operator|>=
literal|1.0
condition|)
name|pt
operator|.
name|y
operator|-=
literal|2.0
expr_stmt|;
operator|*
name|ppt
operator|=
name|pt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record next halftone sample */
end_comment

begin_function
name|int
name|gs_screen_next
parameter_list|(
name|gs_screen_enum
modifier|*
name|penum
parameter_list|,
name|floatp
name|value
parameter_list|)
block|{
name|ushort
name|sample
decl_stmt|;
if|if
condition|(
name|value
operator|<
operator|-
literal|1.0
operator|||
name|value
operator|>
literal|1.0
condition|)
name|return_error
argument_list|(
name|gs_error_rangecheck
argument_list|)
expr_stmt|;
comment|/* The following statement was split into two */
comment|/* to work around a bug in the Siemens C compiler. */
name|sample
operator|=
call|(
name|ushort
call|)
argument_list|(
name|value
operator|*
call|(
name|float
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
name|max_ushort
operator|>>
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sample
operator|+=
operator|(
name|max_ushort
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* convert from signed to biased */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'h'
index|]
condition|)
block|{
name|gs_point
name|pt
decl_stmt|;
name|gs_screen_currentpoint
argument_list|(
name|penum
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
name|dprintf6
argument_list|(
literal|"[h]sample x=%d y=%d (%f,%f): %f -> %u\n"
argument_list|,
name|penum
operator|->
name|x
argument_list|,
name|penum
operator|->
name|y
argument_list|,
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|,
name|value
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|penum
operator|->
name|ht
operator|.
name|order
index|[
name|penum
operator|->
name|y
operator|*
name|penum
operator|->
name|ht
operator|.
name|width
operator|+
name|penum
operator|->
name|x
index|]
operator|.
name|mask
operator|=
name|sample
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|penum
operator|->
name|x
operator|)
operator|>=
name|penum
operator|->
name|ht
operator|.
name|width
condition|)
name|penum
operator|->
name|x
operator|=
literal|0
operator|,
operator|++
operator|(
name|penum
operator|->
name|y
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* All points have been sampled. */
end_comment

begin_comment
comment|/* Finish constructing the halftone. */
end_comment

begin_function
name|private
name|int
name|gx_screen_finish
parameter_list|(
name|gs_screen_enum
modifier|*
name|penum
parameter_list|)
block|{
name|ht_bit
modifier|*
name|order
init|=
name|penum
operator|->
name|ht
operator|.
name|order
decl_stmt|;
name|uint
name|size
init|=
name|penum
operator|->
name|ht
operator|.
name|order_size
decl_stmt|;
name|uint
name|i
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Label each element with its ordinal position. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|order
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|i
expr_stmt|;
comment|/* Sort the samples in increasing order by value. */
name|gx_sort_ht_order
argument_list|(
name|order
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Set up the actual halftone description. */
name|code
operator|=
name|gx_ht_construct_order
argument_list|(
name|order
argument_list|,
name|penum
operator|->
name|ht
operator|.
name|width
argument_list|,
name|penum
operator|->
name|ht
operator|.
name|height
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
operator|*
name|penum
operator|->
name|pgs
operator|->
name|halftone
operator|=
name|penum
operator|->
name|ht
expr_stmt|;
return|return
literal|1
return|;
comment|/* all done */
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Get 3 real parameters in the range [0..1], */
end_comment

begin_comment
comment|/* and convert them to color_params. */
end_comment

begin_function
name|private
name|void
name|tri_param
parameter_list|(
name|floatp
name|p1
parameter_list|,
name|floatp
name|p2
parameter_list|,
name|floatp
name|p3
parameter_list|,
name|color_param
name|pq3
index|[
literal|3
index|]
parameter_list|)
block|{
name|pq3
index|[
literal|0
index|]
operator|=
name|gx_color_unit_param
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pq3
index|[
literal|1
index|]
operator|=
name|gx_color_unit_param
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|pq3
index|[
literal|2
index|]
operator|=
name|gx_color_unit_param
argument_list|(
name|p3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert 3 color_params to reals */
end_comment

begin_function
name|private
name|void
name|tri_return
parameter_list|(
name|color_param
name|p1
parameter_list|,
name|color_param
name|p2
parameter_list|,
name|color_param
name|p3
parameter_list|,
name|float
name|pr3
index|[
literal|3
index|]
parameter_list|)
block|{
name|pr3
index|[
literal|0
index|]
operator|=
name|p1
operator|/
name|max_color_param_float
expr_stmt|;
name|pr3
index|[
literal|1
index|]
operator|=
name|p2
operator|/
name|max_color_param_float
expr_stmt|;
name|pr3
index|[
literal|2
index|]
operator|=
name|p3
operator|/
name|max_color_param_float
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the negated halftone phase mod the tile size. */
end_comment

begin_comment
comment|/* This is the displacement of the tile relative to the device coordinates. */
end_comment

begin_function
name|private
name|void
name|set_phase
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|halftone_params
modifier|*
name|pht
init|=
name|pgs
operator|->
name|halftone
decl_stmt|;
if|if
condition|(
name|pht
operator|->
name|width
operator|==
literal|0
condition|)
name|pgs
operator|->
name|phase_mod
operator|.
name|x
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|pgs
operator|->
name|phase_mod
operator|.
name|x
operator|=
operator|-
name|pgs
operator|->
name|ht_phase
operator|.
name|x
operator|%
name|pht
operator|->
name|width
operator|)
operator|<
literal|0
condition|)
name|pgs
operator|->
name|phase_mod
operator|.
name|x
operator|+=
name|pht
operator|->
name|width
expr_stmt|;
block|}
if|if
condition|(
name|pht
operator|->
name|height
operator|==
literal|0
condition|)
name|pgs
operator|->
name|phase_mod
operator|.
name|y
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|pgs
operator|->
name|phase_mod
operator|.
name|y
operator|=
operator|-
name|pgs
operator|->
name|ht_phase
operator|.
name|y
operator|%
name|pht
operator|->
name|height
operator|)
operator|<
literal|0
condition|)
name|pgs
operator|->
name|phase_mod
operator|.
name|y
operator|+=
name|pht
operator|->
name|height
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Load one cached transfer map. */
end_comment

begin_function
name|private
name|void
name|load_transfer_map
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gx_transfer_map
modifier|*
name|pmap
parameter_list|)
block|{
name|gs_transfer_proc
name|proc
init|=
name|pmap
operator|->
name|proc
decl_stmt|;
name|color_param
modifier|*
name|values
init|=
name|pmap
operator|->
name|values
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|transfer_map_size
condition|;
name|i
operator|++
control|)
name|values
index|[
name|i
index|]
operator|=
name|gx_color_unit_param
argument_list|(
call|(
modifier|*
name|proc
call|)
argument_list|(
name|pgs
argument_list|,
operator|(
name|float
operator|)
name|i
operator|/
name|transfer_map_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure that the transfer map is not shared. */
end_comment

begin_function
name|private
name|int
name|unshare_transfer
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
if|if
condition|(
name|pgs
operator|->
name|transfer
operator|->
name|ref_count
operator|>
literal|1
condition|)
block|{
name|gx_transfer
modifier|*
name|ptran
init|=
operator|(
name|gx_transfer
operator|*
operator|)
call|(
modifier|*
name|pgs
operator|->
name|memory_procs
operator|.
name|alloc
call|)
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gx_transfer
argument_list|)
argument_list|,
literal|"unshare_transfer"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptran
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|ptran
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
name|pgs
operator|->
name|transfer
operator|->
name|ref_count
operator|--
expr_stmt|;
name|pgs
operator|->
name|transfer
operator|=
name|ptran
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

