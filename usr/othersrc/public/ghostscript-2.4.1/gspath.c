begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gspath.c */
end_comment

begin_comment
comment|/* Path construction routines for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gxpath.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_comment
comment|/* Conversion parameters */
end_comment

begin_define
define|#
directive|define
name|degrees_to_radians
value|(M_PI / 180.0)
end_define

begin_comment
comment|/* ------ Miscellaneous ------ */
end_comment

begin_function
name|int
name|gs_newpath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_path_release
argument_list|(
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
name|gx_path_init
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|pgs
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|gs_closepath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|gx_path_close_subpath
argument_list|(
name|pgs
operator|->
name|path
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_upmergepath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|gx_path_add_path
argument_list|(
name|pgs
operator|->
name|saved
operator|->
name|path
argument_list|,
name|pgs
operator|->
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Points and lines ------ */
end_comment

begin_function
name|int
name|gs_currentpoint
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_point
modifier|*
name|ppt
parameter_list|)
block|{
name|gs_fixed_point
name|pt
decl_stmt|;
name|int
name|code
init|=
name|gx_path_current_point
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|pt
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|gs_itransform
argument_list|(
name|pgs
argument_list|,
name|fixed2float
argument_list|(
name|pt
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pt
operator|.
name|y
argument_list|)
argument_list|,
name|ppt
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_moveto
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|x
parameter_list|,
name|floatp
name|y
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|gs_fixed_point
name|pt
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|pt
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_path_add_point
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_function
name|int
name|gs_rmoveto
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|x
parameter_list|,
name|floatp
name|y
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|gs_fixed_point
name|dpt
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_distance_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|dpt
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_path_add_relative_point
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|dpt
operator|.
name|x
argument_list|,
name|dpt
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_function
name|int
name|gs_lineto
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|x
parameter_list|,
name|floatp
name|y
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|gs_fixed_point
name|pt
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|pt
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_function
name|int
name|gs_rlineto
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|x
parameter_list|,
name|floatp
name|y
parameter_list|)
block|{
name|gs_fixed_point
name|cpt
decl_stmt|,
name|dpt
decl_stmt|;
name|int
name|code
init|=
name|gx_path_current_point
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|cpt
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_distance_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|dpt
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|cpt
operator|.
name|x
operator|+
name|dpt
operator|.
name|x
argument_list|,
name|cpt
operator|.
name|y
operator|+
name|dpt
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Arcs ------ */
end_comment

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|private
name|int
name|arc_either
argument_list|(
name|P7
argument_list|(
name|gs_state
operator|*
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|arc_add
argument_list|(
name|P9
argument_list|(
name|gs_state
operator|*
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|floatp
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|gs_arc
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|xc
parameter_list|,
name|floatp
name|yc
parameter_list|,
name|floatp
name|r
parameter_list|,
name|floatp
name|ang1
parameter_list|,
name|floatp
name|ang2
parameter_list|)
block|{
return|return
name|arc_either
argument_list|(
name|pgs
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|r
argument_list|,
name|ang1
argument_list|,
name|ang2
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_arcn
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|xc
parameter_list|,
name|floatp
name|yc
parameter_list|,
name|floatp
name|r
parameter_list|,
name|floatp
name|ang1
parameter_list|,
name|floatp
name|ang2
parameter_list|)
block|{
return|return
name|arc_either
argument_list|(
name|pgs
argument_list|,
name|xc
argument_list|,
name|yc
argument_list|,
name|r
argument_list|,
name|ang1
argument_list|,
name|ang2
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|arc_either
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|axc
parameter_list|,
name|floatp
name|ayc
parameter_list|,
name|floatp
name|arad
parameter_list|,
name|floatp
name|aang1
parameter_list|,
name|floatp
name|aang2
parameter_list|,
name|int
name|clockwise
parameter_list|)
block|{
name|float
name|ar
init|=
name|arad
decl_stmt|;
name|fixed
name|ang1
init|=
name|float2fixed
argument_list|(
name|aang1
argument_list|)
decl_stmt|,
name|ang2
init|=
name|float2fixed
argument_list|(
name|aang2
argument_list|)
decl_stmt|,
name|adiff
decl_stmt|;
name|float
name|ang1r
decl_stmt|;
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|sin0
decl_stmt|,
name|cos0
decl_stmt|;
name|float
name|x3r
decl_stmt|,
name|y3r
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|ar
operator|<
literal|0
condition|)
block|{
name|ang1
operator|+=
name|int2fixed
argument_list|(
literal|180
argument_list|)
expr_stmt|;
name|ang2
operator|+=
name|int2fixed
argument_list|(
literal|180
argument_list|)
expr_stmt|;
name|ar
operator|=
operator|-
name|ar
expr_stmt|;
block|}
define|#
directive|define
name|fixed90
value|int2fixed(90)
define|#
directive|define
name|fixed360
value|int2fixed(360)
comment|/* Don't reduce the arc by multiples of 360 degrees: */
comment|/* this could lead to incorrect winding numbers. */
if|if
condition|(
name|ang1
operator|!=
name|ang2
condition|)
block|{
if|if
condition|(
name|clockwise
condition|)
block|{
while|while
condition|(
name|ang2
operator|>=
name|ang1
condition|)
name|ang1
operator|+=
name|fixed360
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ang2
operator|<=
name|ang1
condition|)
name|ang2
operator|+=
name|fixed360
expr_stmt|;
block|}
block|}
name|ang1r
operator|=
name|fixed2float
argument_list|(
name|ang1
operator|%
name|fixed360
argument_list|)
operator|*
name|degrees_to_radians
expr_stmt|;
name|sin0
operator|=
name|ar
operator|*
name|sin
argument_list|(
name|ang1r
argument_list|)
operator|,
name|cos0
operator|=
name|ar
operator|*
name|cos
argument_list|(
name|ang1r
argument_list|)
expr_stmt|;
name|x0
operator|=
name|axc
operator|+
name|cos0
operator|,
name|y0
operator|=
name|ayc
operator|+
name|sin0
expr_stmt|;
if|if
condition|(
name|clockwise
condition|)
block|{
comment|/* Quadrant reduction */
while|while
condition|(
operator|(
name|adiff
operator|=
name|ang2
operator|-
name|ang1
operator|)
operator|<
operator|-
name|fixed90
condition|)
block|{
name|float
name|w
init|=
name|sin0
decl_stmt|;
name|sin0
operator|=
operator|-
name|cos0
expr_stmt|;
name|cos0
operator|=
name|w
expr_stmt|;
name|x3r
operator|=
name|axc
operator|+
name|cos0
operator|,
name|y3r
operator|=
name|ayc
operator|+
name|sin0
expr_stmt|;
name|code
operator|=
name|arc_add
argument_list|(
name|pgs
argument_list|,
name|ar
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x3r
argument_list|,
name|y3r
argument_list|,
operator|(
name|x0
operator|+
name|cos0
operator|)
argument_list|,
operator|(
name|y0
operator|+
name|sin0
operator|)
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|x0
operator|=
name|x3r
operator|,
name|y0
operator|=
name|y3r
expr_stmt|;
name|ang1
operator|-=
name|fixed90
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Quadrant reduction */
while|while
condition|(
operator|(
name|adiff
operator|=
name|ang2
operator|-
name|ang1
operator|)
operator|>
name|fixed90
condition|)
block|{
name|float
name|w
init|=
name|cos0
decl_stmt|;
name|cos0
operator|=
operator|-
name|sin0
expr_stmt|;
name|sin0
operator|=
name|w
expr_stmt|;
name|x3r
operator|=
name|axc
operator|+
name|cos0
operator|,
name|y3r
operator|=
name|ayc
operator|+
name|sin0
expr_stmt|;
name|code
operator|=
name|arc_add
argument_list|(
name|pgs
argument_list|,
name|ar
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x3r
argument_list|,
name|y3r
argument_list|,
operator|(
name|x0
operator|+
name|cos0
operator|)
argument_list|,
operator|(
name|y0
operator|+
name|sin0
operator|)
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|x0
operator|=
name|x3r
operator|,
name|y0
operator|=
name|y3r
expr_stmt|;
name|ang1
operator|+=
name|fixed90
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Compute the intersection of the tangents. */
block|{
name|double
name|trad
init|=
name|tan
argument_list|(
name|fixed2float
argument_list|(
name|adiff
argument_list|)
operator|*
operator|(
name|degrees_to_radians
operator|/
literal|2
operator|)
argument_list|)
decl_stmt|;
name|float
name|ang2r
init|=
name|fixed2float
argument_list|(
name|ang2
argument_list|)
operator|*
name|degrees_to_radians
decl_stmt|;
name|code
operator|=
name|arc_add
argument_list|(
name|pgs
argument_list|,
name|ar
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
operator|(
name|axc
operator|+
name|ar
operator|*
name|cos
argument_list|(
name|ang2r
argument_list|)
operator|)
argument_list|,
operator|(
name|ayc
operator|+
name|ar
operator|*
name|sin
argument_list|(
name|ang2r
argument_list|)
operator|)
argument_list|,
operator|(
name|x0
operator|-
name|trad
operator|*
name|sin0
operator|)
argument_list|,
operator|(
name|y0
operator|+
name|trad
operator|*
name|cos0
operator|)
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_function
name|int
name|gs_arcto
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|ax1
parameter_list|,
name|floatp
name|ay1
parameter_list|,
name|floatp
name|ax2
parameter_list|,
name|floatp
name|ay2
parameter_list|,
name|floatp
name|arad
parameter_list|,
name|float
modifier|*
name|retxy
parameter_list|)
comment|/* float retxy[4] */
block|{
name|float
name|xt0
decl_stmt|,
name|yt0
decl_stmt|,
name|xt2
decl_stmt|,
name|yt2
decl_stmt|;
name|gs_point
name|up0
decl_stmt|;
define|#
directive|define
name|ax0
value|up0.x
define|#
directive|define
name|ay0
value|up0.y
name|int
name|code
decl_stmt|;
if|if
condition|(
name|arad
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
comment|/* Transform the current point back into user coordinates */
if|if
condition|(
operator|(
name|code
operator|=
name|gs_currentpoint
argument_list|(
name|pgs
argument_list|,
operator|&
name|up0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|{
comment|/* Now we have to compute the tangent points. */
comment|/* Basically, the idea is to compute the tangent */
comment|/* of the bisector by using tan(x+y) and tan(z/2) */
comment|/* formulas, without ever using any trig. */
name|float
name|dx0
init|=
name|ax0
operator|-
name|ax1
decl_stmt|,
name|dy0
init|=
name|ay0
operator|-
name|ay1
decl_stmt|;
name|float
name|dx2
init|=
name|ax2
operator|-
name|ax1
decl_stmt|,
name|dy2
init|=
name|ay2
operator|-
name|ay1
decl_stmt|;
comment|/* Compute the squared lengths from p1 to p0 and p2. */
name|double
name|sql0
init|=
name|dx0
operator|*
name|dx0
operator|+
name|dy0
operator|*
name|dy0
decl_stmt|;
name|double
name|sql2
init|=
name|dx2
operator|*
name|dx2
operator|+
name|dy2
operator|*
name|dy2
decl_stmt|;
comment|/* Compute the distance from p1 to the tangent points. */
comment|/* This is the only hairy part. */
name|double
name|num
init|=
name|dy0
operator|*
name|dx2
operator|-
name|dy2
operator|*
name|dx0
decl_stmt|;
name|double
name|denom
init|=
name|sqrt
argument_list|(
name|sql0
operator|*
name|sql2
argument_list|)
operator|-
operator|(
name|dx0
operator|*
name|dx2
operator|+
name|dy0
operator|*
name|dy2
operator|)
decl_stmt|;
comment|/* Check for collinear points. */
if|if
condition|(
name|fabs
argument_list|(
name|num
argument_list|)
operator|<
literal|1.0e-6
operator|||
name|fabs
argument_list|(
name|denom
argument_list|)
operator|<
literal|1.0e-6
condition|)
block|{
name|gs_fixed_point
name|pt
decl_stmt|;
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|ax1
argument_list|,
name|ay1
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|)
expr_stmt|;
name|xt0
operator|=
name|xt2
operator|=
name|ax1
expr_stmt|;
name|yt0
operator|=
name|yt2
operator|=
name|ay1
expr_stmt|;
block|}
else|else
comment|/* not collinear */
block|{
name|double
name|dist
init|=
name|fabs
argument_list|(
name|arad
operator|*
name|num
operator|/
name|denom
argument_list|)
decl_stmt|;
name|double
name|l0
init|=
name|dist
operator|/
name|sqrt
argument_list|(
name|sql0
argument_list|)
decl_stmt|,
name|l2
init|=
name|dist
operator|/
name|sqrt
argument_list|(
name|sql2
argument_list|)
decl_stmt|;
name|xt0
operator|=
name|ax1
operator|+
name|dx0
operator|*
name|l0
expr_stmt|;
name|yt0
operator|=
name|ay1
operator|+
name|dy0
operator|*
name|l0
expr_stmt|;
name|xt2
operator|=
name|ax1
operator|+
name|dx2
operator|*
name|l2
expr_stmt|;
name|yt2
operator|=
name|ay1
operator|+
name|dy2
operator|*
name|l2
expr_stmt|;
name|code
operator|=
name|arc_add
argument_list|(
name|pgs
argument_list|,
name|arad
argument_list|,
name|xt0
argument_list|,
name|yt0
argument_list|,
name|xt2
argument_list|,
name|yt2
argument_list|,
name|ax1
argument_list|,
name|ay1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retxy
operator|!=
literal|0
condition|)
block|{
name|retxy
index|[
literal|0
index|]
operator|=
name|xt0
expr_stmt|;
name|retxy
index|[
literal|1
index|]
operator|=
name|yt0
expr_stmt|;
name|retxy
index|[
literal|2
index|]
operator|=
name|xt2
expr_stmt|;
name|retxy
index|[
literal|3
index|]
operator|=
name|yt2
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Internal routine for adding an arc to the path. */
end_comment

begin_function
name|private
name|int
name|arc_add
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|r
parameter_list|,
name|floatp
name|x0
parameter_list|,
name|floatp
name|y0
parameter_list|,
name|floatp
name|x3
parameter_list|,
name|floatp
name|y3
parameter_list|,
name|floatp
name|xt
parameter_list|,
name|floatp
name|yt
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|gx_path
modifier|*
name|path
init|=
name|pgs
operator|->
name|path
decl_stmt|;
name|floatp
name|dx
init|=
name|xt
operator|-
name|x0
decl_stmt|,
name|dy
init|=
name|yt
operator|-
name|y0
decl_stmt|;
name|floatp
name|fraction
decl_stmt|;
name|gs_fixed_point
name|p0
decl_stmt|,
name|p3
decl_stmt|,
name|pt
decl_stmt|,
name|cpt
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* Compute the fraction coefficient for the curve. */
comment|/* See gx_path_add_arc for details. */
if|if
condition|(
name|fabs
argument_list|(
name|r
argument_list|)
operator|<
literal|1.0e-4
condition|)
comment|/* almost zero radius */
block|{
name|fraction
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|double
name|ratio2
init|=
operator|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
operator|)
operator|/
operator|(
name|r
operator|*
name|r
operator|)
decl_stmt|;
name|fraction
operator|=
operator|(
literal|4.0
operator|/
literal|3.0
operator|)
operator|/
operator|(
literal|1
operator|+
name|sqrt
argument_list|(
literal|1
operator|+
name|ratio2
argument_list|)
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'r'
index|]
condition|)
name|dprintf7
argument_list|(
literal|"[r]Arc f=%f p0=(%f,%f) pt=(%f,%f) p3=(%f,%f) first=%d\n"
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|xt
argument_list|,
name|yt
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
name|first
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
operator|&
name|p0
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
operator|&
name|p3
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|xt
argument_list|,
name|yt
argument_list|,
operator|&
name|pt
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|first
operator|&&
operator|(
name|code
operator|=
operator|(
name|gx_path_current_point
argument_list|(
name|path
argument_list|,
operator|&
name|cpt
argument_list|)
operator|>=
literal|0
condition|?
name|gx_path_add_line
argument_list|(
name|path
argument_list|,
name|p0
operator|.
name|x
argument_list|,
name|p0
operator|.
name|y
argument_list|)
else|:
name|gx_path_add_point
argument_list|(
name|path
argument_list|,
name|p0
operator|.
name|x
argument_list|,
name|p0
operator|.
name|y
argument_list|)
operator|)
operator|)
operator|<
literal|0
operator|)
condition|)
return|return
name|code
return|;
return|return
name|gx_path_add_arc
argument_list|(
name|path
argument_list|,
name|p0
operator|.
name|x
argument_list|,
name|p0
operator|.
name|y
argument_list|,
name|p3
operator|.
name|x
argument_list|,
name|p3
operator|.
name|y
argument_list|,
name|pt
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
argument_list|,
name|fraction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Curves ------ */
end_comment

begin_function
name|int
name|gs_curveto
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|x1
parameter_list|,
name|floatp
name|y1
parameter_list|,
name|floatp
name|x2
parameter_list|,
name|floatp
name|y2
parameter_list|,
name|floatp
name|x3
parameter_list|,
name|floatp
name|y3
parameter_list|)
block|{
name|gs_fixed_point
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
operator|&
name|p1
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
operator|&
name|p2
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_point_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
operator|&
name|p3
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|gx_path_add_curve
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|p1
operator|.
name|x
argument_list|,
name|p1
operator|.
name|y
argument_list|,
name|p2
operator|.
name|x
argument_list|,
name|p2
operator|.
name|y
argument_list|,
name|p3
operator|.
name|x
argument_list|,
name|p3
operator|.
name|y
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|gs_rcurveto
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|dx1
parameter_list|,
name|floatp
name|dy1
parameter_list|,
name|floatp
name|dx2
parameter_list|,
name|floatp
name|dy2
parameter_list|,
name|floatp
name|dx3
parameter_list|,
name|floatp
name|dy3
parameter_list|)
block|{
name|gs_fixed_point
name|pt
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|;
name|int
name|code
init|=
name|gx_path_current_point
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|pt
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_distance_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|dx1
argument_list|,
name|dy1
argument_list|,
operator|&
name|p1
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_distance_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|dx2
argument_list|,
name|dy2
argument_list|,
operator|&
name|p2
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_distance_transform2fixed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|,
name|dx3
argument_list|,
name|dy3
argument_list|,
operator|&
name|p3
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|gx_path_add_curve
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pt
operator|.
name|x
operator|+
name|p1
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
operator|+
name|p1
operator|.
name|y
argument_list|,
name|pt
operator|.
name|x
operator|+
name|p2
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
operator|+
name|p2
operator|.
name|y
argument_list|,
name|pt
operator|.
name|x
operator|+
name|p3
operator|.
name|x
argument_list|,
name|pt
operator|.
name|y
operator|+
name|p3
operator|.
name|y
argument_list|)
return|;
block|}
end_function

end_unit

