begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1990 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsfile.c */
end_comment

begin_comment
comment|/* Bitmap file writing routines for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_comment
comment|/* for gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/* Dump the contents of a memory device in PPM format. */
end_comment

begin_function
name|int
name|gs_writeppmfile
parameter_list|(
name|gx_device_memory
modifier|*
name|md
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|raster
init|=
name|gx_device_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|md
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|md
operator|->
name|height
decl_stmt|;
name|int
name|depth
init|=
name|md
operator|->
name|color_info
operator|.
name|depth
decl_stmt|;
name|uint
name|rsize
init|=
name|raster
operator|*
literal|3
decl_stmt|;
comment|/* * 3 just for mapped color */
name|byte
modifier|*
name|row
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|rsize
argument_list|,
literal|1
argument_list|,
literal|"ppm file buffer"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
comment|/* return code */
if|if
condition|(
name|row
operator|==
literal|0
condition|)
comment|/* can't allocate row buffer */
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
comment|/* A PPM file consists of: magic number, comment, */
comment|/* width, height, maxvalue, (r,g,b).... */
comment|/* Dispatch on the type of the device -- 1-bit mono, */
comment|/* 8-bit (gray scale or color), 24- or 32-bit true color. */
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
literal|1
case|:
name|header
operator|=
literal|"P4\n# Ghostscript 1 bit mono image dump\n%d %d\n"
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|header
operator|=
operator|(
name|gx_device_has_color
argument_list|(
name|md
argument_list|)
condition|?
literal|"P6\n# Ghostscript 8 bit mapped color image dump\n%d %d\n255\n"
else|:
literal|"P5\n# Ghostscript 8 bit gray scale image dump\n%d %d\n255\n"
operator|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|header
operator|=
literal|"P6\n# Ghostscript 24 bit color image dump\n%d %d\n255\n"
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|header
operator|=
literal|"P6\n# Ghostscript 32 bit color image dump\n%d %d\n255\n"
expr_stmt|;
break|break;
default|default:
comment|/* shouldn't happen! */
name|code
operator|=
name|gs_error_undefinedresult
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Write the header. */
name|fprintf
argument_list|(
name|file
argument_list|,
name|header
argument_list|,
name|md
operator|->
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
comment|/* Dump the contents of the image. */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|int
name|count
decl_stmt|;
specifier|register
name|byte
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|,
modifier|*
name|end
decl_stmt|;
call|(
modifier|*
name|md
operator|->
name|procs
operator|->
name|get_bits
call|)
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|md
argument_list|,
name|y
argument_list|,
name|row
argument_list|,
name|raster
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|depth
condition|)
block|{
case|case
literal|8
case|:
block|{
comment|/* Mapped color, consult the map. */
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|md
argument_list|)
condition|)
block|{
comment|/* Map color */
name|byte
modifier|*
name|palette
init|=
name|md
operator|->
name|palette
decl_stmt|;
name|from
operator|=
name|row
operator|+
name|raster
operator|+
name|raster
expr_stmt|;
name|memcpy
argument_list|(
name|from
argument_list|,
name|row
argument_list|,
name|raster
argument_list|)
expr_stmt|;
name|to
operator|=
name|row
expr_stmt|;
name|end
operator|=
name|from
operator|+
name|raster
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|end
condition|)
block|{
specifier|register
name|byte
modifier|*
name|cp
init|=
name|palette
operator|+
operator|(
name|int
operator|)
operator|*
name|from
operator|++
operator|*
literal|3
decl_stmt|;
name|to
index|[
literal|0
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
comment|/* red */
name|to
index|[
literal|1
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
comment|/* green */
name|to
index|[
literal|2
index|]
operator|=
name|cp
index|[
literal|2
index|]
expr_stmt|;
comment|/* blue */
name|to
operator|+=
literal|3
expr_stmt|;
block|}
name|count
operator|=
name|raster
operator|*
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* Map gray scale */
specifier|register
name|byte
modifier|*
name|palette
init|=
name|md
operator|->
name|palette
decl_stmt|;
name|from
operator|=
name|to
operator|=
name|row
operator|,
name|end
operator|=
name|row
operator|+
name|raster
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|end
condition|)
operator|*
name|to
operator|++
operator|=
name|palette
index|[
operator|(
name|int
operator|)
operator|*
name|from
operator|++
operator|*
literal|3
index|]
expr_stmt|;
name|count
operator|=
name|raster
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|32
case|:
block|{
comment|/* This case is different, because we must skip */
comment|/* every fourth byte. */
name|from
operator|=
name|to
operator|=
name|row
operator|,
name|end
operator|=
name|row
operator|+
name|raster
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|end
condition|)
block|{
comment|/* from[0] is unused */
name|to
index|[
literal|0
index|]
operator|=
name|from
index|[
literal|1
index|]
expr_stmt|;
comment|/* red */
name|to
index|[
literal|1
index|]
operator|=
name|from
index|[
literal|2
index|]
expr_stmt|;
comment|/* green */
name|to
index|[
literal|2
index|]
operator|=
name|from
index|[
literal|3
index|]
expr_stmt|;
comment|/* blue */
name|from
operator|+=
literal|4
expr_stmt|;
name|to
operator|+=
literal|3
expr_stmt|;
block|}
name|count
operator|=
name|to
operator|-
name|row
expr_stmt|;
block|}
break|break;
default|default:
name|count
operator|=
name|raster
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|row
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|file
argument_list|)
operator|<
name|count
condition|)
block|{
name|code
operator|=
name|gs_error_ioerror
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|row
argument_list|,
name|rsize
argument_list|,
literal|1
argument_list|,
literal|"ppm file buffer"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

end_unit

