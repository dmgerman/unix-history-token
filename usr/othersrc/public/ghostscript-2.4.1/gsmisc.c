begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsmisc.c */
end_comment

begin_comment
comment|/* Miscellaneous utilities for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"malloc_.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_comment
comment|/* Ghostscript writes to gs_out instead of stdout, */
end_comment

begin_comment
comment|/* and writes debugging output to gs_debug_out. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|gs_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We define gs_debug and gs_debug_out even if DEBUG isn't defined, */
end_comment

begin_comment
comment|/* so that we can compile individual modules with DEBUG set. */
end_comment

begin_decl_stmt
name|char
name|gs_debug
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|gs_debug_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We define gs_log_errors here for the same reason. */
end_comment

begin_decl_stmt
name|int
name|gs_log_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We can turn on allocator debugging even if DEBUG isn't defined. */
end_comment

begin_decl_stmt
name|int
name|gs_alloc_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|byte
name|gs_alloc_fill_alloc
init|=
literal|0xa1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|byte
name|gs_alloc_fill_free
init|=
literal|0xf1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate a block of unique IDs. */
end_comment

begin_decl_stmt
specifier|static
name|ulong
name|gs_next_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|ulong
name|gs_next_ids
parameter_list|(
name|uint
name|count
parameter_list|)
block|{
name|ulong
name|id
decl_stmt|;
if|if
condition|(
name|gs_next_id
operator|==
literal|0
condition|)
name|gs_next_id
operator|++
expr_stmt|;
name|id
operator|=
name|gs_next_id
expr_stmt|;
name|gs_next_id
operator|+=
name|count
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/* Versions of malloc and free compatible with Ghostscript's */
end_comment

begin_comment
comment|/* model of memory management.  We keep track of all allocated */
end_comment

begin_comment
comment|/* blocks so we can free them at cleanup time. */
end_comment

begin_comment
comment|/* We must make sure that malloc_blocks leave the block aligned. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|malloc_block_s
name|malloc_block
typedef|;
end_typedef

begin_define
define|#
directive|define
name|malloc_block_data
define|\
value|malloc_block *next;\ 	uint size;\ 	const char *cname
end_define

begin_struct
struct|struct
name|malloc_block_data_s
block|{
name|malloc_block_data
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|malloc_block_s
block|{
name|malloc_block_data
expr_stmt|;
name|byte
name|_pad
index|[
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|malloc_block_data_s
argument_list|)
operator|&
literal|7
index|]
decl_stmt|;
comment|/* pad to double */
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|malloc_block
modifier|*
name|malloc_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|gs_malloc
parameter_list|(
name|uint
name|num_elts
parameter_list|,
name|uint
name|elt_size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|num_elts
operator|>
operator|(
name|max_uint
operator|-
sizeof|sizeof
argument_list|(
name|malloc_block
argument_list|)
operator|)
operator|/
name|elt_size
condition|)
block|{
comment|/* Can't represent the size in a uint! */
name|msg
operator|=
literal|"too large for size_t"
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uint
name|size
init|=
name|num_elts
operator|*
name|elt_size
decl_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|malloc_block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"failed"
expr_stmt|;
else|else
block|{
name|malloc_block
modifier|*
name|bp
init|=
operator|(
name|malloc_block
operator|*
operator|)
name|ptr
decl_stmt|;
name|bp
operator|->
name|next
operator|=
name|malloc_list
expr_stmt|;
name|bp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|cname
operator|=
name|client_name
expr_stmt|;
name|malloc_list
operator|=
name|bp
expr_stmt|;
name|msg
operator|=
literal|"OK"
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|bp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|gs_alloc_debug
condition|)
block|{
comment|/* Clear the block in an attempt to track down */
comment|/* uninitialized data errors. */
name|memset
argument_list|(
name|ptr
argument_list|,
name|gs_alloc_fill_alloc
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|gs_alloc_debug
operator|||
operator|!
operator|*
name|msg
condition|)
name|dprintf5
argument_list|(
literal|"gs_malloc(%s)(%u, %u) = 0x%lx: %s\n"
argument_list|,
name|client_name
argument_list|,
name|num_elts
argument_list|,
name|elt_size
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
name|gs_free
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|uint
name|num_elts
parameter_list|,
name|uint
name|elt_size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
name|malloc_block
modifier|*
name|bp
init|=
name|malloc_list
decl_stmt|;
if|if
condition|(
name|gs_alloc_debug
condition|)
name|dprintf4
argument_list|(
literal|"gs_free(%s)(0x%lx, %u, %u)\n"
argument_list|,
name|client_name
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|,
name|num_elts
argument_list|,
name|elt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|char
operator|*
operator|)
operator|(
name|bp
operator|+
literal|1
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|bp
operator|->
name|size
operator|!=
name|num_elts
operator|*
name|elt_size
condition|)
name|lprintf5
argument_list|(
literal|"%s: free 0x%lx(%u,%u) size ~= %u\n"
argument_list|,
name|client_name
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|,
name|num_elts
argument_list|,
name|elt_size
argument_list|,
name|bp
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|malloc_list
operator|=
name|bp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|gs_alloc_debug
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|bp
operator|+
literal|1
operator|)
argument_list|,
name|gs_alloc_fill_free
argument_list|,
name|bp
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_block
modifier|*
name|np
decl_stmt|;
for|for
control|(
init|;
operator|(
name|np
operator|=
name|bp
operator|->
name|next
operator|)
operator|!=
literal|0
condition|;
name|bp
operator|=
name|np
control|)
block|{
if|if
condition|(
name|ptr
operator|==
operator|(
name|char
operator|*
operator|)
operator|(
name|np
operator|+
literal|1
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|np
operator|->
name|size
operator|!=
name|num_elts
operator|*
name|elt_size
condition|)
name|lprintf5
argument_list|(
literal|"%s: free 0x%lx(%u,%u) size ~= %u\n"
argument_list|,
name|client_name
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|,
name|num_elts
argument_list|,
name|elt_size
argument_list|,
name|np
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|next
operator|=
name|np
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|gs_alloc_debug
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|np
operator|+
literal|1
operator|)
argument_list|,
name|gs_alloc_fill_free
argument_list|,
name|np
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|lprintf4
argument_list|(
literal|"%s: free 0x%lx(%u,%u) not found\n"
argument_list|,
name|client_name
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|,
name|num_elts
argument_list|,
name|elt_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|malloc_block
operator|*
operator|)
name|ptr
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gs_malloc_release
parameter_list|()
block|{
name|malloc_block
modifier|*
name|bp
init|=
name|malloc_list
decl_stmt|;
name|malloc_block
modifier|*
name|np
decl_stmt|;
for|for
control|(
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|np
control|)
block|{
name|np
operator|=
name|bp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|gs_alloc_debug
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|bp
operator|+
literal|1
operator|)
argument_list|,
name|gs_alloc_fill_free
argument_list|,
name|bp
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|malloc_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap even and odd bytes. */
end_comment

begin_comment
comment|/* This routine may be supplanted by assembly code. */
end_comment

begin_if
if|#
directive|if
operator|!
name|USE_ASM
end_if

begin_undef
undef|#
directive|undef
name|memswab
end_undef

begin_comment
comment|/* see memory_.h */
end_comment

begin_function
name|void
name|memswab
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|count
parameter_list|)
block|{
specifier|register
specifier|const
name|uint
modifier|*
name|sptr
init|=
operator|(
specifier|const
name|uint
operator|*
operator|)
name|src
decl_stmt|;
specifier|register
name|uint
modifier|*
name|dptr
init|=
operator|(
name|uint
operator|*
operator|)
name|dest
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|uint
name|w
decl_stmt|;
for|for
control|(
name|x
operator|=
name|count
operator|>>
literal|3
init|;
operator|--
name|x
operator|>=
literal|0
condition|;
control|)
block|{
name|w
operator|=
operator|*
name|sptr
expr_stmt|;
if|#
directive|if
name|arch_ints_are_short
operator|*
name|dptr
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|+
operator|(
name|w
operator|<<
literal|8
operator|)
expr_stmt|;
name|w
operator|=
name|sptr
index|[
literal|1
index|]
expr_stmt|;
name|dptr
index|[
literal|1
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|+
operator|(
name|w
operator|<<
literal|8
operator|)
expr_stmt|;
name|w
operator|=
name|sptr
index|[
literal|2
index|]
expr_stmt|;
name|dptr
index|[
literal|2
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|+
operator|(
name|w
operator|<<
literal|8
operator|)
expr_stmt|;
name|w
operator|=
name|sptr
index|[
literal|3
index|]
expr_stmt|;
name|dptr
index|[
literal|3
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|+
operator|(
name|w
operator|<<
literal|8
operator|)
expr_stmt|;
name|sptr
operator|+=
literal|4
operator|,
name|dptr
operator|+=
literal|4
expr_stmt|;
else|#
directive|else
operator|*
name|dptr
operator|=
operator|(
operator|(
name|w
operator|<<
literal|8
operator|)
operator|&
literal|0xff00ff00
operator|)
operator|+
operator|(
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff00ff
operator|)
expr_stmt|;
name|w
operator|=
name|sptr
index|[
literal|1
index|]
expr_stmt|;
name|dptr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|w
operator|<<
literal|8
operator|)
operator|&
literal|0xff00ff00
operator|)
operator|+
operator|(
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff00ff
operator|)
expr_stmt|;
name|sptr
operator|+=
literal|2
operator|,
name|dptr
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|count
operator|&
literal|6
condition|)
block|{
case|case
literal|6
case|:
name|w
operator|=
operator|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|sptr
operator|)
index|[
literal|2
index|]
expr_stmt|;
operator|(
operator|(
name|ushort
operator|*
operator|)
name|dptr
operator|)
index|[
literal|2
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|+
operator|(
name|w
operator|<<
literal|8
operator|)
expr_stmt|;
case|case
literal|4
case|:
name|w
operator|=
operator|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|sptr
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|ushort
operator|*
operator|)
name|dptr
operator|)
index|[
literal|1
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|+
operator|(
name|w
operator|<<
literal|8
operator|)
expr_stmt|;
case|case
literal|2
case|:
name|w
operator|=
operator|(
operator|(
specifier|const
name|ushort
operator|*
operator|)
name|sptr
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|ushort
operator|*
operator|)
name|dptr
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|+
operator|(
name|w
operator|<<
literal|8
operator|)
expr_stmt|;
case|case
literal|0
case|:
empty_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_ASM */
end_comment

begin_comment
comment|/* Transpose an 8 x 8 block of bits.  line_size is the raster of */
end_comment

begin_comment
comment|/* the input data.  dist is the distance between output bytes. */
end_comment

begin_comment
comment|/* This routine may be supplanted by assembly code. */
end_comment

begin_if
if|#
directive|if
operator|!
name|USE_ASM
end_if

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* This is the better of the two algorithms. */
end_comment

begin_function
name|void
name|memflip8x8
parameter_list|(
specifier|const
name|byte
modifier|*
name|inp
parameter_list|,
name|int
name|line_size
parameter_list|,
name|byte
modifier|*
name|outp
parameter_list|,
name|int
name|dist
parameter_list|)
block|{
specifier|register
name|uint
name|ae
decl_stmt|,
name|bf
decl_stmt|,
name|cg
decl_stmt|,
name|dh
decl_stmt|;
block|{
specifier|const
name|byte
modifier|*
name|ptr4
init|=
name|inp
operator|+
operator|(
name|line_size
operator|<<
literal|2
operator|)
decl_stmt|;
name|ae
operator|=
operator|(
operator|(
name|uint
operator|)
operator|*
name|inp
operator|<<
literal|8
operator|)
operator|+
operator|*
name|ptr4
expr_stmt|;
name|inp
operator|+=
name|line_size
operator|,
name|ptr4
operator|+=
name|line_size
expr_stmt|;
name|bf
operator|=
operator|(
operator|(
name|uint
operator|)
operator|*
name|inp
operator|<<
literal|8
operator|)
operator|+
operator|*
name|ptr4
expr_stmt|;
name|inp
operator|+=
name|line_size
operator|,
name|ptr4
operator|+=
name|line_size
expr_stmt|;
name|cg
operator|=
operator|(
operator|(
name|uint
operator|)
operator|*
name|inp
operator|<<
literal|8
operator|)
operator|+
operator|*
name|ptr4
expr_stmt|;
name|inp
operator|+=
name|line_size
operator|,
name|ptr4
operator|+=
name|line_size
expr_stmt|;
name|dh
operator|=
operator|(
operator|(
name|uint
operator|)
operator|*
name|inp
operator|<<
literal|8
operator|)
operator|+
operator|*
name|ptr4
expr_stmt|;
block|}
comment|/* Check for all 8 bytes being the same. */
comment|/* This is especially worth doing for the case where all are zero. */
if|if
condition|(
name|ae
operator|==
name|bf
operator|&&
name|ae
operator|==
name|cg
operator|&&
name|ae
operator|==
name|dh
operator|&&
operator|(
name|ae
operator|>>
literal|8
operator|)
operator|==
operator|(
name|ae
operator|&
literal|0xff
operator|)
condition|)
block|{
if|if
condition|(
name|ae
operator|==
literal|0
condition|)
goto|goto
name|store
goto|;
operator|*
name|outp
operator|=
operator|-
operator|(
operator|(
name|ae
operator|>>
literal|7
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|-
operator|(
operator|(
name|ae
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|-
operator|(
operator|(
name|ae
operator|>>
literal|5
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|-
operator|(
operator|(
name|ae
operator|>>
literal|4
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|-
operator|(
operator|(
name|ae
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|-
operator|(
operator|(
name|ae
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|-
operator|(
operator|(
name|ae
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|-
operator|(
name|ae
operator|&
literal|1
operator|)
expr_stmt|;
return|return;
block|}
block|{
specifier|register
name|uint
name|temp
decl_stmt|;
comment|/* Transpose a block of bits between registers. */
define|#
directive|define
name|transpose
parameter_list|(
name|r
parameter_list|,
name|s
parameter_list|,
name|mask
parameter_list|,
name|shift
parameter_list|)
define|\
value|r ^= (temp = ((s>> shift) ^ r)& mask);\   s ^= temp<< shift
comment|/* Transpose blocks of 4 x 4 */
define|#
directive|define
name|transpose4
parameter_list|(
name|r
parameter_list|)
value|transpose(r,r,0x00f0,4)
name|transpose4
argument_list|(
name|ae
argument_list|)
expr_stmt|;
name|transpose4
argument_list|(
name|bf
argument_list|)
expr_stmt|;
name|transpose4
argument_list|(
name|cg
argument_list|)
expr_stmt|;
name|transpose4
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* Transpose blocks of 2 x 2 */
name|transpose
argument_list|(
name|ae
argument_list|,
name|cg
argument_list|,
literal|0x3333
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|transpose
argument_list|(
name|bf
argument_list|,
name|dh
argument_list|,
literal|0x3333
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Transpose blocks of 1 x 1 */
name|transpose
argument_list|(
name|ae
argument_list|,
name|bf
argument_list|,
literal|0x5555
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|transpose
argument_list|(
name|cg
argument_list|,
name|dh
argument_list|,
literal|0x5555
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|store
label|:
operator|*
name|outp
operator|=
name|ae
operator|>>
literal|8
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
name|bf
operator|>>
literal|8
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
name|cg
operator|>>
literal|8
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
name|dh
operator|>>
literal|8
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|(
name|byte
operator|)
name|ae
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|(
name|byte
operator|)
name|bf
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|(
name|byte
operator|)
name|cg
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
operator|(
name|byte
operator|)
name|dh
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* This looked like a good idea, but it's no faster. */
end_comment

begin_comment
comment|/* Transpose an 8 x 8 block of bits.  line_size is the raster of */
end_comment

begin_comment
comment|/* the input data.  dist is the distance between output bytes. */
end_comment

begin_function
name|void
name|memflip8x8
parameter_list|(
specifier|const
name|byte
modifier|*
name|inp
parameter_list|,
name|int
name|line_size
parameter_list|,
name|byte
modifier|*
name|outp
parameter_list|,
name|int
name|dist
parameter_list|)
block|{
comment|/* Define a table that spreads the bits of its index as follows: */
comment|/* 0->0-3, 1->8-11, 2->16-19, 3->24-27, */
comment|/* 4->4-7, 5->12-15, 6->20-23, 7->28-31. */
define|#
directive|define
name|b4
parameter_list|(
name|v
parameter_list|)
value|v,v+0xf,v+0xf00,v+0xf0f
define|#
directive|define
name|b8
parameter_list|(
name|v
parameter_list|)
value|b4(v),b4(v+0xf0000)
define|#
directive|define
name|b16
parameter_list|(
name|v
parameter_list|)
value|b8(v),b8(v+0xf000000)
specifier|static
specifier|const
name|ulong
name|spread
index|[
literal|256
index|]
init|=
block|{
name|b16
argument_list|(
literal|0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf000
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0f0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf00000
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf000f0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0f000
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0f0f0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0000000
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf00000f0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf000f000
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf000f0f0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0f00000
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0f000f0
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0f0f000
argument_list|)
block|,
name|b16
argument_list|(
literal|0xf0f0f0f0
argument_list|)
block|}
decl_stmt|;
specifier|register
name|ulong
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|temp
decl_stmt|;
name|hi
operator|=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x88888888
expr_stmt|;
name|inp
operator|+=
name|line_size
expr_stmt|;
name|hi
operator||=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x44444444
expr_stmt|;
name|inp
operator|+=
name|line_size
expr_stmt|;
name|hi
operator||=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x22222222
expr_stmt|;
name|inp
operator|+=
name|line_size
expr_stmt|;
name|hi
operator||=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x11111111
expr_stmt|;
name|inp
operator|+=
name|line_size
expr_stmt|;
name|lo
operator|=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x88888888
expr_stmt|;
name|inp
operator|+=
name|line_size
expr_stmt|;
name|lo
operator||=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x44444444
expr_stmt|;
name|inp
operator|+=
name|line_size
expr_stmt|;
name|lo
operator||=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x22222222
expr_stmt|;
name|inp
operator|+=
name|line_size
expr_stmt|;
name|lo
operator||=
name|spread
index|[
operator|*
name|inp
index|]
operator|&
literal|0x11111111
expr_stmt|;
name|temp
operator|=
operator|(
name|hi
operator|&
literal|0xf0f0f0f0
operator|)
operator||
operator|(
operator|(
name|lo
operator|>>
literal|4
operator|)
operator|&
literal|0x0f0f0f0f
operator|)
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|uint
call|)
argument_list|(
name|temp
operator|>>
literal|16
argument_list|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
name|temp
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|uint
operator|)
name|temp
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
name|temp
operator|=
operator|(
operator|(
name|hi
operator|<<
literal|4
operator|)
operator|&
literal|0xf0f0f0f0
operator|)
operator||
operator|(
name|lo
operator|&
literal|0x0f0f0f0f
operator|)
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
call|(
name|uint
call|)
argument_list|(
name|temp
operator|>>
literal|16
argument_list|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
name|temp
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|uint
operator|)
name|temp
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outp
operator|+=
name|dist
expr_stmt|;
operator|*
name|outp
operator|=
call|(
name|byte
call|)
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* memflip8x8 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_ASM */
end_comment

end_unit

