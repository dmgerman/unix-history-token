begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* ansi2knr.c */
end_comment

begin_comment
comment|/* Convert ANSI function declarations to K&R syntax */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"malloc_.h"
end_include

begin_comment
comment|/* Usage: 	ansi2knr input_file output_file  * If no output_file is supplied, output goes to stdout.  * There are no error messages.  *  * ansi2knr recognizes functions by seeing a non-keyword identifier  * at the left margin, followed by a left parenthesis,  * with a right parenthesis as the last character on the line.  * It will recognize a multi-line header if the last character  * on each line but the last is a left parenthesis or comma.  * These algorithms ignore whitespace and comments, except that  * the function name must be the first thing on the line.  * The following constructs will confuse it: 	- Any other construct that starts at the left margin and 	    follows the above syntax (such as a macro or function call). 	- Macros that tinker with the syntax of the function header.  */
end_comment

begin_comment
comment|/* Scanning macros */
end_comment

begin_define
define|#
directive|define
name|isidchar
parameter_list|(
name|ch
parameter_list|)
value|(isalnum(ch) || (ch) == '_')
end_define

begin_define
define|#
directive|define
name|isidfirstchar
parameter_list|(
name|ch
parameter_list|)
value|(isalpha(ch) || (ch) == '_')
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
define|#
directive|define
name|bufsize
value|500
comment|/* arbitrary size */
name|char
name|buf
index|[
name|bufsize
index|]
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
switch|switch
condition|(
name|argc
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"Usage: ansi2knr input_file [output_file]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|out
operator|=
name|stdout
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|out
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|in
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#line 1 \"%s\"\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|line
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|buf
operator|+
name|bufsize
operator|-
name|line
argument_list|)
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|test1
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* a function */
name|convert1
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
comment|/* maybe the start of a function */
name|line
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
default|default:
comment|/* not a function */
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|!=
name|buf
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Skip over space and comments, in either direction. */
end_comment

begin_function
name|char
modifier|*
name|skipspace
parameter_list|(
name|p
parameter_list|,
name|dir
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|dir
decl_stmt|;
comment|/* 1 for forward, -1 for backward */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|+=
name|dir
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|p
index|[
name|dir
index|]
operator|==
literal|'*'
operator|)
condition|)
break|break;
name|p
operator|+=
name|dir
expr_stmt|;
name|p
operator|+=
name|dir
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|&&
name|p
index|[
name|dir
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
name|p
return|;
comment|/* multi-line comment?? */
name|p
operator|+=
name|dir
expr_stmt|;
block|}
name|p
operator|+=
name|dir
expr_stmt|;
name|p
operator|+=
name|dir
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Write blanks over part of a string.  */
end_comment

begin_function
name|void
name|writeblanks
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|start
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test whether the string in buf is a function definition.  * The string may contain and/or end with a newline.  * Return as follows:  *	0 - definitely not a function definition;  *	1 - definitely a function definition;  *	-1 - may be the beginning of a function definition,  *		append another line and look again.  */
end_comment

begin_macro
name|test1
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|bend
decl_stmt|;
name|char
modifier|*
name|endfn
decl_stmt|;
name|int
name|contin
decl_stmt|;
if|if
condition|(
operator|!
name|isidfirstchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* no name at left margin */
name|bend
operator|=
name|skipspace
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|bend
condition|)
block|{
case|case
literal|')'
case|:
name|contin
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|','
case|:
name|contin
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
comment|/* not a function */
block|}
while|while
condition|(
name|isidchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|endfn
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'('
condition|)
return|return
literal|0
return|;
comment|/* not a function */
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
return|return
literal|0
return|;
comment|/* no parameters */
comment|/* Check that the apparent function name isn't a keyword. */
comment|/* We only need to check for keywords that could be followed */
comment|/* by a left parenthesis (which, unfortunately, is most of them). */
block|{
specifier|static
name|char
modifier|*
name|words
index|[]
init|=
block|{
literal|"asm"
block|,
literal|"auto"
block|,
literal|"case"
block|,
literal|"char"
block|,
literal|"const"
block|,
literal|"double"
block|,
literal|"extern"
block|,
literal|"float"
block|,
literal|"for"
block|,
literal|"if"
block|,
literal|"int"
block|,
literal|"long"
block|,
literal|"register"
block|,
literal|"return"
block|,
literal|"short"
block|,
literal|"signed"
block|,
literal|"sizeof"
block|,
literal|"static"
block|,
literal|"switch"
block|,
literal|"typedef"
block|,
literal|"unsigned"
block|,
literal|"void"
block|,
literal|"volatile"
block|,
literal|"while"
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|key
init|=
name|words
decl_stmt|;
name|char
modifier|*
name|kp
decl_stmt|;
name|int
name|len
init|=
name|endfn
operator|-
name|buf
decl_stmt|;
while|while
condition|(
operator|(
name|kp
operator|=
operator|*
name|key
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|kp
argument_list|)
operator|==
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|kp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* name is a keyword */
name|key
operator|++
expr_stmt|;
block|}
block|}
return|return
name|contin
return|;
block|}
end_block

begin_macro
name|convert1
argument_list|(
argument|buf
argument_list|,
argument|out
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|endfn
init|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'('
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|breaks
decl_stmt|;
name|unsigned
name|num_breaks
init|=
literal|2
decl_stmt|;
comment|/* for testing */
name|char
modifier|*
modifier|*
name|btop
decl_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|top
label|:
name|p
operator|=
name|endfn
expr_stmt|;
name|breaks
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|num_breaks
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|breaks
operator|==
literal|0
condition|)
block|{
comment|/* Couldn't allocate break table, give up */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to allocate break table!\n"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|btop
operator|=
name|breaks
operator|+
name|num_breaks
operator|*
literal|2
operator|-
literal|2
expr_stmt|;
name|bp
operator|=
name|breaks
expr_stmt|;
comment|/* Parse the argument list */
do|do
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bp
operator|>=
name|btop
condition|)
block|{
comment|/* Filled up break table. */
comment|/* Allocate a bigger one and start over. */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|breaks
argument_list|)
expr_stmt|;
name|num_breaks
operator|<<=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
operator|*
name|bp
operator|++
operator|=
name|p
expr_stmt|;
comment|/* Find the end of the argument */
for|for
control|(
init|;
name|end
operator|==
name|NULL
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|','
case|:
if|if
condition|(
operator|!
name|level
condition|)
name|end
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
name|level
operator|<
literal|0
condition|)
name|end
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
name|p
operator|--
expr_stmt|;
comment|/* back up over terminator */
comment|/* Find the name being declared. */
comment|/* This is complicated because of procedure and */
comment|/* array modifiers. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|skipspace
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|']'
case|:
comment|/* skip array dimension(s) */
case|case
literal|')'
case|:
comment|/* skip procedure args OR name */
block|{
name|int
name|level
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|level
condition|)
switch|switch
condition|(
operator|*
operator|--
name|p
condition|)
block|{
case|case
literal|']'
case|:
case|case
literal|')'
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|'['
case|:
case|case
literal|'('
case|:
name|level
operator|--
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
operator|&&
operator|*
name|skipspace
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
literal|'*'
condition|)
block|{
comment|/* We found the name being declared */
while|while
condition|(
operator|!
name|isidfirstchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
goto|goto
name|found
goto|;
block|}
break|break;
default|default:
goto|goto
name|found
goto|;
block|}
block|}
name|found
label|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|breaks
operator|+
literal|1
condition|)
comment|/* sole argument */
name|writeblanks
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|writeblanks
argument_list|(
name|bp
index|[
operator|-
literal|1
index|]
operator|-
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bp
operator|--
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|isidchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|end
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|','
condition|)
do|;
operator|*
name|bp
operator|=
name|p
expr_stmt|;
comment|/* Make a special check for 'void' arglist */
if|if
condition|(
name|bp
operator|==
name|breaks
operator|+
literal|2
condition|)
block|{
name|p
operator|=
name|skipspace
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"void"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|p
operator|=
name|skipspace
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|breaks
index|[
literal|2
index|]
operator|-
literal|1
condition|)
block|{
name|bp
operator|=
name|breaks
expr_stmt|;
comment|/* yup, pretend arglist is empty */
name|writeblanks
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Put out the function name */
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endfn
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|out
argument_list|)
operator|,
name|p
operator|++
expr_stmt|;
comment|/* Put out the declaration */
for|for
control|(
name|ap
operator|=
name|breaks
operator|+
literal|1
init|;
name|ap
operator|<
name|bp
condition|;
name|ap
operator|+=
literal|2
control|)
block|{
name|p
operator|=
operator|*
name|ap
expr_stmt|;
while|while
condition|(
name|isidchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|out
argument_list|)
operator|,
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|ap
operator|<
name|bp
operator|-
literal|1
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|")  "
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Put out the argument declarations */
for|for
control|(
name|ap
operator|=
name|breaks
operator|+
literal|2
init|;
name|ap
operator|<=
name|bp
condition|;
name|ap
operator|+=
literal|2
control|)
operator|(
operator|*
name|ap
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|';'
expr_stmt|;
name|fputs
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|breaks
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

end_unit

