begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevepsc.c */
end_comment

begin_comment
comment|/* Epson color dot-matrix printer driver for Ghostscript by dave@exlog.com */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_comment
comment|/******  * For 9-pin printers, you may select  *   X_DPI = 60, 120, or 240  *   Y_DPI = 60 or 72  * For 24-pin printers, you may select  *   X_DPI = 60, 120, 180, 240, or 360  *   Y_DPI = 60, 72, 180, or 216  * Note that a given printer implements *either* Y_DPI = 60 | 180 *or*  * Y_DPI = 72 | 216; no attempt is made to check this here.  * Note that X_DPI = 180 or 360 requires Y_DPI> 100;  * this isn't checked either.  Finally, note that X_DPI=240 and  * X_DPI=360 are double-density modes requiring two passes to print.  *  * The values of X_DPI and Y_DPI may be set at compile time:  * see gdevs.mak.  *   * At some time in the future, we could simulate 24-bit output on  * 9-pin printers by using fractional vertical positioning;  * we could even implement an X_DPI=360 mode by using the  * ESC++ command that spaces vertically in units of 1/360"  * (not supported on many printers.)  ******/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|X_DPI
end_ifndef

begin_define
define|#
directive|define
name|X_DPI
value|180
end_define

begin_comment
comment|/* pixels per inch */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Y_DPI
end_ifndef

begin_define
define|#
directive|define
name|Y_DPI
value|180
end_define

begin_comment
comment|/* pixels per inch */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **	Colors for EPSON LQ-2550. ** **	We map VIOLET to BLUE since this is the best we can do. */
end_comment

begin_define
define|#
directive|define
name|BLACK
value|0
end_define

begin_define
define|#
directive|define
name|MAGENTA
value|1
end_define

begin_define
define|#
directive|define
name|CYAN
value|2
end_define

begin_define
define|#
directive|define
name|VIOLET
value|3
end_define

begin_define
define|#
directive|define
name|YELLOW
value|4
end_define

begin_define
define|#
directive|define
name|RED
value|5
end_define

begin_define
define|#
directive|define
name|GREEN
value|6
end_define

begin_define
define|#
directive|define
name|WHITE
value|7
end_define

begin_comment
comment|/* **	The offset in this array correspond to **	the ESC-r n value */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rgb_color
index|[
literal|2
index|]
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
name|BLACK
block|,
name|VIOLET
block|,
name|GREEN
block|,
name|CYAN
block|,
name|RED
block|,
name|MAGENTA
block|,
name|YELLOW
block|,
name|WHITE
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map an RGB color to a printer color. */
end_comment

begin_define
define|#
directive|define
name|cv_shift
value|(sizeof(gx_color_value) * 8 - 1)
end_define

begin_function
name|private
name|gx_color_index
name|epson_map_rgb_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_value
name|r
parameter_list|,
name|gx_color_value
name|g
parameter_list|,
name|gx_color_value
name|b
parameter_list|)
block|{
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* use ^7 so WHITE is 0 for internal calculations */
return|return
operator|(
name|gx_color_index
operator|)
name|rgb_color
index|[
name|r
operator|>>
name|cv_shift
index|]
index|[
name|g
operator|>>
name|cv_shift
index|]
index|[
name|b
operator|>>
name|cv_shift
index|]
operator|^
literal|7
return|;
block|}
else|else
block|{
return|return
name|gx_default_map_rgb_color
argument_list|(
name|dev
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Map the printer color back to RGB. */
end_comment

begin_function
name|private
name|int
name|epson_map_color_rgb
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|gx_color_index
name|color
parameter_list|,
name|gx_color_value
name|prgb
index|[
literal|3
index|]
parameter_list|)
block|{
define|#
directive|define
name|c1
value|gx_max_color_value
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|dev
argument_list|)
condition|)
switch|switch
condition|(
operator|(
name|ushort
operator|)
name|color
operator|^
literal|7
condition|)
block|{
case|case
name|BLACK
case|:
name|prgb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VIOLET
case|:
name|prgb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
break|break;
case|case
name|GREEN
case|:
name|prgb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CYAN
case|:
name|prgb
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
break|break;
case|case
name|RED
case|:
name|prgb
index|[
literal|0
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MAGENTA
case|:
name|prgb
index|[
literal|0
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
break|break;
case|case
name|YELLOW
case|:
name|prgb
index|[
literal|0
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WHITE
case|:
name|prgb
index|[
literal|0
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|1
index|]
operator|=
name|c1
expr_stmt|;
name|prgb
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
break|break;
block|}
else|else
return|return
name|gx_default_map_color_rgb
argument_list|(
name|dev
argument_list|,
name|color
argument_list|,
name|prgb
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The device descriptor */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|eps_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|epson_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|epson_map_rgb_color
argument_list|,
name|epson_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_printer
name|gs_epsonc_device
init|=
name|prn_device
argument_list|(
name|epson_procs
argument_list|,
literal|"epsonc"
argument_list|,
literal|85
argument_list|,
comment|/* width_10ths, 8.5" */
literal|110
argument_list|,
comment|/* height_10ths, 11" */
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0.25
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|3
argument_list|,
name|eps_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|void
name|eps_output_run
argument_list|(
name|P6
argument_list|(
name|byte
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|char
argument_list|,
name|FILE
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send the page to the printer. */
end_comment

begin_define
define|#
directive|define
name|DD
value|0x80
end_define

begin_comment
comment|/* double density flag */
end_comment

begin_function
name|private
name|int
name|eps_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|prn_stream
parameter_list|)
block|{
specifier|static
name|char
name|graphics_modes_9
index|[
literal|5
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|0
comment|/*60*/
block|,
literal|1
comment|/*120*/
block|,
operator|-
literal|1
block|,
name|DD
operator|+
literal|3
comment|/*240*/
block|}
decl_stmt|;
specifier|static
name|char
name|graphics_modes_24
index|[
literal|7
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|32
comment|/*60*/
block|,
literal|33
comment|/*120*/
block|,
literal|39
comment|/*180*/
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|DD
operator|+
literal|40
comment|/*360*/
block|}
decl_stmt|;
name|int
name|y_24pin
init|=
name|pdev
operator|->
name|y_pixels_per_inch
operator|>
literal|72
decl_stmt|;
name|int
name|y_mult
init|=
operator|(
name|y_24pin
condition|?
literal|3
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|line_size
init|=
operator|(
name|pdev
operator|->
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
decl_stmt|;
comment|/* always mono */
name|int
name|in_size
init|=
name|line_size
operator|*
operator|(
literal|8
operator|*
name|y_mult
operator|)
decl_stmt|;
name|byte
modifier|*
name|in
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(in)"
argument_list|)
decl_stmt|;
name|int
name|out_size
init|=
operator|(
operator|(
name|pdev
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
operator|)
operator|*
name|y_mult
decl_stmt|;
name|byte
modifier|*
name|out
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|out_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(out)"
argument_list|)
decl_stmt|;
name|int
name|x_dpi
init|=
name|pdev
operator|->
name|x_pixels_per_inch
decl_stmt|;
name|char
name|start_graphics
init|=
operator|(
name|y_24pin
condition|?
name|graphics_modes_24
else|:
name|graphics_modes_9
operator|)
index|[
name|x_dpi
operator|/
literal|60
index|]
decl_stmt|;
name|int
name|first_pass
init|=
operator|(
name|start_graphics
operator|&
name|DD
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|last_pass
init|=
name|first_pass
operator|*
literal|2
decl_stmt|;
name|int
name|dots_per_space
init|=
name|x_dpi
operator|/
literal|10
decl_stmt|;
comment|/* pica space = 1/10" */
name|int
name|bytes_per_space
init|=
name|dots_per_space
operator|*
name|y_mult
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|,
name|lnum
init|=
literal|0
decl_stmt|,
name|pass
decl_stmt|;
comment|/* declare color buffer and related vars */
name|byte
modifier|*
name|color_in
decl_stmt|;
name|int
name|color_line_size
decl_stmt|,
name|color_in_size
decl_stmt|;
name|int
name|spare_bits
init|=
operator|(
name|pdev
operator|->
name|width
operator|%
literal|8
operator|)
decl_stmt|;
comment|/* left over bits to go to margin */
name|int
name|whole_bits
init|=
name|pdev
operator|->
name|width
operator|-
name|spare_bits
decl_stmt|;
comment|/* Check allocations */
if|if
condition|(
name|in
operator|==
literal|0
operator|||
name|out
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in
condition|)
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
name|in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(in)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
name|out_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(out)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize the printer and reset the margins. */
name|fwrite
argument_list|(
literal|"\033@\033P\033l\000\033Q\377\033U\001\r"
argument_list|,
literal|1
argument_list|,
literal|14
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/*	Create color buffer */
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|pdev
argument_list|)
condition|)
block|{
name|color_line_size
operator|=
name|gdev_mem_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|)
expr_stmt|;
name|color_in_size
operator|=
name|color_line_size
operator|*
operator|(
literal|8
operator|*
name|y_mult
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|color_in
operator|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|color_in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(color)"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
name|in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(in)"
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
name|out_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(out)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|color_in
operator|=
name|in
expr_stmt|;
name|color_in_size
operator|=
name|in_size
expr_stmt|;
name|color_line_size
operator|=
name|line_size
expr_stmt|;
block|}
comment|/* Print lines of graphics */
while|while
condition|(
name|lnum
operator|<
name|pdev
operator|->
name|height
condition|)
block|{
name|int
name|lcnt
decl_stmt|;
name|byte
modifier|*
name|nextcolor
init|=
name|NULL
decl_stmt|;
comment|/* position where next color appears */
name|byte
modifier|*
name|nextmono
init|=
name|NULL
decl_stmt|;
comment|/* position to map next color */
comment|/* Copy 1 scan line and test for all zero. */
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|lnum
argument_list|,
name|color_in
argument_list|,
name|color_line_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_in
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|color_in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|color_in
operator|+
literal|1
argument_list|,
name|color_line_size
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lnum
operator|++
expr_stmt|;
name|skip
operator|+=
literal|3
operator|/
name|y_mult
expr_stmt|;
continue|continue;
block|}
comment|/* Vertical tab to the appropriate position. */
while|while
condition|(
name|skip
operator|>
literal|255
condition|)
block|{
name|fputs
argument_list|(
literal|"\033J\377"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|skip
operator|-=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033J%c"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
comment|/* Copy the rest of the scan lines. */
name|lcnt
operator|=
literal|1
operator|+
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|lnum
operator|+
literal|1
argument_list|,
name|color_in
operator|+
name|color_line_size
argument_list|,
name|color_in_size
operator|-
name|color_line_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
literal|8
operator|*
name|y_mult
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|color_in
operator|+
name|lcnt
operator|*
name|color_line_size
operator|)
argument_list|,
literal|0
argument_list|,
name|color_in_size
operator|-
name|lcnt
operator|*
name|color_line_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|pdev
argument_list|)
condition|)
comment|/* clear the work buffer */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|in
operator|+
name|lcnt
operator|*
name|line_size
operator|)
argument_list|,
literal|0
argument_list|,
name|in_size
operator|-
name|lcnt
operator|*
name|line_size
argument_list|)
expr_stmt|;
block|}
comment|/* **	We need to create a normal epson scan line from our color scan line **	We do this by setting a bit in the "in" buffer if the pixel byte is set **	to any color.  We then search for any more pixels of that color, setting **	"in" accordingly.  If any other color is found, we save it for the next **	pass.  There may be up to 7 passes. **	In the future, we should make the passes so as to maximize the **	life of the color ribbon (i.e. go lightest to darkest). */
do|do
block|{
name|byte
modifier|*
name|inp
init|=
name|in
decl_stmt|;
name|byte
modifier|*
name|in_end
init|=
name|in
operator|+
name|line_size
decl_stmt|;
name|byte
modifier|*
name|out_end
init|=
name|out
decl_stmt|;
name|byte
modifier|*
name|out_blk
decl_stmt|;
specifier|register
name|byte
modifier|*
name|outp
decl_stmt|;
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|pdev
argument_list|)
condition|)
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|byte
modifier|*
name|outbuf
decl_stmt|,
modifier|*
name|realbuf
decl_stmt|;
name|byte
name|current_color
decl_stmt|;
name|int
name|end_next_bits
init|=
name|whole_bits
decl_stmt|;
name|int
name|lastbits
decl_stmt|;
comment|/*	Move to the point in the scanline that has a new color */
if|if
condition|(
name|nextcolor
condition|)
block|{
name|realbuf
operator|=
name|nextcolor
expr_stmt|;
name|outbuf
operator|=
name|nextmono
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
literal|0
argument_list|,
operator|(
name|nextmono
operator|-
name|in
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|nextcolor
operator|-
name|color_in
expr_stmt|;
name|nextcolor
operator|=
name|NULL
expr_stmt|;
name|end_next_bits
operator|=
operator|(
name|i
operator|/
name|color_line_size
operator|)
operator|*
name|color_line_size
operator|+
name|whole_bits
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|realbuf
operator|=
name|color_in
expr_stmt|;
name|outbuf
operator|=
name|in
expr_stmt|;
name|nextcolor
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*	move thru the color buffer, turning on the appropriate **	bit in the "mono" buffer", setting pointers to the next **	color and changing the color output of the epson */
for|for
control|(
name|current_color
operator|=
literal|0
init|;
name|i
operator|<=
name|color_in_size
condition|;
name|outbuf
operator|++
control|)
block|{
comment|/*	Remember, line_size is rounded up to next whole byte **	whereas color_line_size is the proper length **	We only want to set the proper bits in the last line_size byte. */
if|if
condition|(
name|spare_bits
operator|&&
name|i
operator|==
name|end_next_bits
condition|)
block|{
name|end_next_bits
operator|=
name|whole_bits
operator|+
name|i
operator|+
name|spare_bits
expr_stmt|;
name|lastbits
operator|=
literal|8
operator|-
name|spare_bits
expr_stmt|;
block|}
else|else
name|lastbits
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|*
name|outbuf
operator|=
literal|0
operator|,
name|j
operator|=
literal|8
init|;
operator|--
name|j
operator|>=
name|lastbits
operator|&&
name|i
operator|<=
name|color_in_size
condition|;
name|realbuf
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|realbuf
condition|)
block|{
if|if
condition|(
name|current_color
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|realbuf
operator|==
name|current_color
condition|)
block|{
operator|*
name|outbuf
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
operator|*
name|realbuf
operator|=
literal|0
expr_stmt|;
comment|/* throw this byte away */
block|}
comment|/* save this location for next pass */
elseif|else
if|if
condition|(
name|nextcolor
operator|==
name|NULL
condition|)
block|{
name|nextcolor
operator|=
name|realbuf
operator|-
operator|(
literal|7
operator|-
name|j
operator|)
expr_stmt|;
name|nextmono
operator|=
name|outbuf
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|outbuf
operator||=
literal|1
operator|<<
name|j
expr_stmt|;
name|current_color
operator|=
operator|*
name|realbuf
expr_stmt|;
comment|/* set color */
operator|*
name|realbuf
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
operator|*
name|outbuf
operator|=
literal|0
expr_stmt|;
comment|/* zero the end, for safe keeping */
comment|/*	Change color on the EPSON, current_color must be set **	but lets check anyway */
if|if
condition|(
name|current_color
condition|)
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033r%d"
argument_list|,
name|current_color
operator|^
literal|7
argument_list|)
expr_stmt|;
block|}
comment|/* We have to 'transpose' blocks of 8 pixels x 8 lines, */
comment|/* because that's how the printer wants the data. */
comment|/* If we are in a 24-pin mode, we have to transpose */
comment|/* groups of 3 lines at a time. */
if|if
condition|(
name|y_24pin
condition|)
block|{
for|for
control|(
init|;
name|inp
operator|<
name|in_end
condition|;
name|inp
operator|++
operator|,
name|out_end
operator|+=
literal|24
control|)
block|{
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
argument_list|,
name|line_size
argument_list|,
name|out_end
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
operator|+
name|line_size
operator|*
literal|8
argument_list|,
name|line_size
argument_list|,
name|out_end
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
operator|+
name|line_size
operator|*
literal|16
argument_list|,
name|line_size
argument_list|,
name|out_end
operator|+
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Remove trailing 0s. */
while|while
condition|(
name|out_end
operator|>
name|out
operator|&&
name|out_end
index|[
operator|-
literal|1
index|]
operator|==
literal|0
operator|&&
name|out_end
index|[
operator|-
literal|2
index|]
operator|==
literal|0
operator|&&
name|out_end
index|[
operator|-
literal|3
index|]
operator|==
literal|0
condition|)
name|out_end
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|inp
operator|<
name|in_end
condition|;
name|inp
operator|++
operator|,
name|out_end
operator|+=
literal|8
control|)
block|{
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
argument_list|,
name|line_size
argument_list|,
name|out_end
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Remove trailing 0s. */
while|while
condition|(
name|out_end
operator|>
name|out
operator|&&
name|out_end
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|out_end
operator|--
expr_stmt|;
block|}
for|for
control|(
name|pass
operator|=
name|first_pass
init|;
name|pass
operator|<=
name|last_pass
condition|;
name|pass
operator|++
control|)
block|{
for|for
control|(
name|out_blk
operator|=
name|outp
operator|=
name|out
init|;
name|outp
operator|<
name|out_end
condition|;
control|)
block|{
comment|/* Skip a run of leading 0s. */
comment|/* At least 10 are needed to make tabbing worth it. */
comment|/* We do everything by 3's to avoid having to make */
comment|/* different cases for 9- and 24-pin. */
if|if
condition|(
operator|*
name|outp
operator|==
literal|0
operator|&&
name|outp
operator|+
literal|12
operator|<=
name|out_end
operator|&&
name|outp
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|outp
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
operator|(
name|outp
index|[
literal|3
index|]
operator||
name|outp
index|[
literal|4
index|]
operator||
name|outp
index|[
literal|5
index|]
operator|)
operator|==
literal|0
operator|&&
operator|(
name|outp
index|[
literal|6
index|]
operator||
name|outp
index|[
literal|7
index|]
operator||
name|outp
index|[
literal|8
index|]
operator|)
operator|==
literal|0
operator|&&
operator|(
name|outp
index|[
literal|9
index|]
operator||
name|outp
index|[
literal|10
index|]
operator||
name|outp
index|[
literal|11
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|byte
modifier|*
name|zp
init|=
name|outp
decl_stmt|;
name|int
name|tpos
decl_stmt|;
name|byte
modifier|*
name|newp
decl_stmt|;
name|outp
operator|+=
literal|12
expr_stmt|;
while|while
condition|(
name|outp
operator|+
literal|3
operator|<=
name|out_end
operator|&&
operator|*
name|outp
operator|==
literal|0
operator|&&
name|outp
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|outp
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|outp
operator|+=
literal|3
expr_stmt|;
name|tpos
operator|=
operator|(
name|outp
operator|-
name|out
operator|)
operator|/
name|bytes_per_space
expr_stmt|;
name|newp
operator|=
name|out
operator|+
name|tpos
operator|*
name|bytes_per_space
expr_stmt|;
if|if
condition|(
name|newp
operator|>
name|zp
operator|+
literal|10
condition|)
block|{
comment|/* Output preceding bit data. */
if|if
condition|(
name|zp
operator|>
name|out_blk
condition|)
comment|/* only false at */
comment|/* beginning of line */
name|eps_output_run
argument_list|(
name|out_blk
argument_list|,
call|(
name|int
call|)
argument_list|(
name|zp
operator|-
name|out_blk
argument_list|)
argument_list|,
name|y_mult
argument_list|,
name|start_graphics
argument_list|,
name|prn_stream
argument_list|,
name|pass
argument_list|)
expr_stmt|;
comment|/* Tab over to the appropriate position. */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033D%c%c\t"
argument_list|,
name|tpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_blk
operator|=
name|outp
operator|=
name|newp
expr_stmt|;
block|}
block|}
else|else
name|outp
operator|+=
name|y_mult
expr_stmt|;
block|}
if|if
condition|(
name|outp
operator|>
name|out_blk
condition|)
name|eps_output_run
argument_list|(
name|out_blk
argument_list|,
call|(
name|int
call|)
argument_list|(
name|outp
operator|-
name|out_blk
argument_list|)
argument_list|,
name|y_mult
argument_list|,
name|start_graphics
argument_list|,
name|prn_stream
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\r'
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nextcolor
condition|)
do|;
name|skip
operator|=
literal|24
expr_stmt|;
name|lnum
operator|+=
literal|8
operator|*
name|y_mult
expr_stmt|;
block|}
comment|/* Eject the page and reinitialize the printer */
name|fputs
argument_list|(
literal|"\f\033@"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
name|out_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(out)"
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
name|in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(in)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gx_device_has_color
argument_list|(
name|pdev
argument_list|)
condition|)
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|color_in
argument_list|,
name|color_in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(rin)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output a single graphics command. */
end_comment

begin_comment
comment|/* pass=0 for all columns, 1 for even columns, 2 for odd columns. */
end_comment

begin_function
name|private
name|void
name|eps_output_run
parameter_list|(
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|y_mult
parameter_list|,
name|char
name|start_graphics
parameter_list|,
name|FILE
modifier|*
name|prn_stream
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|int
name|xcount
init|=
name|count
operator|/
name|y_mult
decl_stmt|;
name|fputc
argument_list|(
literal|033
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|start_graphics
operator|&
operator|~
literal|3
operator|)
condition|)
block|{
name|fputc
argument_list|(
literal|"KLYZ"
index|[
name|start_graphics
index|]
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|start_graphics
operator|&
operator|~
name|DD
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
name|xcount
operator|&
literal|0xff
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|xcount
operator|>>
literal|8
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pass
condition|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only write every other column of y_mult bytes. */
name|int
name|which
init|=
name|pass
decl_stmt|;
name|byte
modifier|*
name|dp
init|=
name|data
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|which
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|y_mult
condition|;
name|j
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|putc
argument_list|(
operator|(
operator|(
name|which
operator|&
literal|1
operator|)
condition|?
operator|*
name|dp
else|:
literal|0
operator|)
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

