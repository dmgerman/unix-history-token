begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gp_dosfb.c */
end_comment

begin_comment
comment|/* MS-DOS frame buffer swapping routines for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* On MS-DOS machines, we maintain a console image in memory, */
end_comment

begin_comment
comment|/* and swap screens on request. */
end_comment

begin_define
define|#
directive|define
name|cw_width
value|80
end_define

begin_define
define|#
directive|define
name|cw_height
value|25
end_define

begin_typedef
typedef|typedef
struct|struct
name|text_line_s
block|{
name|int
name|end
decl_stmt|;
name|char
name|text
index|[
name|cw_width
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|text_line
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|text_line
name|_ds
modifier|*
name|line
decl_stmt|;
name|text_line
name|lines
index|[
name|cw_height
index|]
decl_stmt|;
block|}
name|ds_text_screen
typedef|;
end_typedef

begin_decl_stmt
name|private
name|ds_text_screen
name|console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|console_is_current
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer one scan line of graphics. */
end_comment

begin_define
define|#
directive|define
name|row_buf_size
value|1280
end_define

begin_decl_stmt
name|private
name|char
name|graphics_file_name
index|[]
init|=
literal|"_temp_.gfb"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|save_graphics
argument_list|(
name|P1
argument_list|(
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|restore_graphics
argument_list|(
name|P1
argument_list|(
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the console buffer. */
end_comment

begin_function
name|void
name|gp_init_console
parameter_list|()
block|{
name|memset
argument_list|(
operator|&
name|console
operator|.
name|lines
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|console
operator|.
name|lines
argument_list|)
argument_list|)
expr_stmt|;
name|console
operator|.
name|line
operator|=
operator|&
name|console
operator|.
name|lines
index|[
literal|0
index|]
expr_stmt|;
name|console_is_current
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a string to the console. */
end_comment

begin_function
name|void
name|gp_console_puts
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint
name|size
parameter_list|)
block|{
specifier|register
name|ds_text_screen
name|_ds
modifier|*
name|cop
init|=
operator|&
name|console
decl_stmt|;
specifier|register
name|text_line
name|_ds
modifier|*
name|lip
init|=
name|cop
operator|->
name|line
decl_stmt|;
for|for
control|(
init|;
name|size
condition|;
name|str
operator|++
operator|,
name|size
operator|--
control|)
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|lip
operator|==
operator|&
name|cop
operator|->
name|lines
index|[
name|cw_height
operator|-
literal|1
index|]
condition|)
block|{
comment|/* Scroll up */
name|memcpy
argument_list|(
operator|&
name|cop
operator|->
name|lines
index|[
literal|0
index|]
argument_list|,
operator|&
name|cop
operator|->
name|lines
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|text_line
argument_list|)
operator|*
operator|(
name|cw_height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cop
operator|->
name|line
operator|=
operator|++
name|lip
expr_stmt|;
name|lip
operator|->
name|end
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|gp_console_puts
argument_list|(
literal|"        "
argument_list|,
literal|8
operator|-
operator|(
name|lip
operator|->
name|end
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|lip
operator|=
name|cop
operator|->
name|line
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|lip
operator|->
name|end
operator|==
name|cw_width
condition|)
block|{
name|gp_console_puts
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lip
operator|=
name|cop
operator|->
name|line
expr_stmt|;
block|}
name|lip
operator|->
name|text
index|[
name|lip
operator|->
name|end
operator|++
index|]
operator|=
operator|*
name|str
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make the console current on the screen. */
end_comment

begin_function
name|int
name|gp_make_console_current
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|console_is_current
condition|)
name|code
operator|=
name|save_graphics
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Transfer the console buffer to the screen. */
comment|/* Unfortunately, there is no standard way to clear the screen. */
comment|/* Output the ANSI sequence and hope for the best. */
name|cputs
argument_list|(
literal|"\r\033[2J\r    \r"
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|text_line
name|_ds
modifier|*
name|lip
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lip
operator|=
operator|&
name|console
operator|.
name|lines
index|[
literal|0
index|]
init|;
name|i
operator|<
name|cw_height
condition|;
name|i
operator|++
operator|,
name|lip
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|cputs
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|lip
operator|->
name|text
index|[
name|lip
operator|->
name|end
index|]
operator|=
literal|0
expr_stmt|;
name|cputs
argument_list|(
name|lip
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
name|console_is_current
operator|=
literal|1
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Make the graphics current on the screen. */
end_comment

begin_function
name|int
name|gp_make_graphics_current
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|console_is_current
condition|)
block|{
name|int
name|code
init|=
name|restore_graphics
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|console_is_current
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* We compress the pixmap just a little, by noting */
end_comment

begin_comment
comment|/* replicated bytes at the beginning and end of a line. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|ushort
name|pre
decl_stmt|,
name|post
decl_stmt|;
block|}
name|row_head
typedef|;
end_typedef

begin_comment
comment|/* Save the graphics screen on a file. */
end_comment

begin_function
name|private
name|int
name|save_graphics
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|uint
name|row_size
init|=
name|gx_device_bytes_per_scan_line
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
name|row_buf
index|[
name|row_buf_size
index|]
decl_stmt|;
name|int
name|count
init|=
name|row_buf_size
operator|/
name|row_size
decl_stmt|;
name|FILE
modifier|*
name|gfile
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|gfile
operator|=
name|fopen
argument_list|(
name|graphics_file_name
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfile
operator|==
literal|0
condition|)
return|return
name|gs_error_ioerror
return|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dev
operator|->
name|height
condition|;
name|y
operator|+=
name|count
control|)
block|{
name|char
name|_ss
modifier|*
name|row
init|=
name|row_buf
decl_stmt|;
name|int
name|n
init|=
name|count
decl_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|get_bits
call|)
argument_list|(
name|dev
argument_list|,
name|y
argument_list|,
name|row
argument_list|,
name|row_buf_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|row_head
name|head
decl_stmt|;
name|char
name|_ss
modifier|*
name|beg
init|=
name|row
decl_stmt|,
modifier|*
name|end
init|=
name|row
operator|+
name|row_size
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|end
operator|>
name|beg
operator|&&
operator|*
name|end
operator|==
name|end
index|[
operator|-
literal|1
index|]
condition|)
name|end
operator|--
expr_stmt|;
if|if
condition|(
name|beg
operator|<
name|end
condition|)
while|while
condition|(
operator|*
name|beg
operator|==
name|beg
index|[
literal|1
index|]
condition|)
name|beg
operator|++
expr_stmt|;
name|head
operator|.
name|pre
operator|=
name|beg
operator|-
name|row
expr_stmt|;
name|head
operator|.
name|post
operator|=
name|end
operator|+
literal|1
operator|-
name|row
expr_stmt|;
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|head
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|,
name|gfile
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|beg
argument_list|,
name|head
operator|.
name|post
operator|-
name|head
operator|.
name|pre
argument_list|,
literal|1
argument_list|,
name|gfile
argument_list|)
expr_stmt|;
name|row
operator|+=
name|row_size
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|gfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Restore the graphics screen from a file. */
end_comment

begin_function
name|private
name|int
name|restore_graphics
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|)
block|{
name|FILE
modifier|*
name|gfile
decl_stmt|;
name|uint
name|row_size
init|=
name|gx_device_bytes_per_scan_line
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
name|row_buf
index|[
name|row_buf_size
index|]
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
name|row_size
operator|>
name|row_buf_size
condition|)
return|return
operator|-
literal|1
return|;
name|gfile
operator|=
name|fopen
argument_list|(
name|graphics_file_name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfile
operator|==
literal|0
condition|)
return|return
name|gs_error_ioerror
return|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|dev
operator|->
name|height
condition|;
name|y
operator|++
control|)
block|{
name|row_head
name|head
decl_stmt|;
name|char
name|_ss
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|head
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|,
name|gfile
argument_list|)
expr_stmt|;
name|beg
operator|=
name|row_buf
operator|+
name|head
operator|.
name|pre
expr_stmt|;
name|end
operator|=
name|row_buf
operator|+
name|head
operator|.
name|post
expr_stmt|;
name|fread
argument_list|(
name|beg
argument_list|,
literal|1
argument_list|,
name|end
operator|-
name|beg
argument_list|,
name|gfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|.
name|pre
condition|)
name|memset
argument_list|(
name|row_buf
argument_list|,
operator|*
name|beg
argument_list|,
name|head
operator|.
name|pre
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|.
name|post
operator|<
name|row_size
condition|)
name|memset
argument_list|(
name|end
argument_list|,
name|end
index|[
operator|-
literal|1
index|]
argument_list|,
name|row_size
operator|-
name|head
operator|.
name|post
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|copy_color
call|)
argument_list|(
name|dev
argument_list|,
name|row_buf
argument_list|,
literal|0
argument_list|,
name|row_size
argument_list|,
name|gx_no_bitmap_id
argument_list|,
literal|0
argument_list|,
name|y
argument_list|,
name|dev
operator|->
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|gfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

