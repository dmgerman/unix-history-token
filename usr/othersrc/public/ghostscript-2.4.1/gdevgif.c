begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevgif.c */
end_comment

begin_comment
comment|/* GIF output device for Ghostscript. */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_comment
comment|/* REALLY? */
end_comment

begin_include
include|#
directive|include
file|"gdevpccm.h"
end_include

begin_comment
comment|/* Thanks to Phil Conrad for donating the original version */
end_comment

begin_comment
comment|/* of these drivers to Aladdin Enterprises. */
end_comment

begin_comment
comment|/* ------ The device descriptors ------ */
end_comment

begin_comment
comment|/*  * Standard U.S. page width and height.  A4 paper is 8.4" x 11.7".  */
end_comment

begin_define
define|#
directive|define
name|WIDTH_10THS
value|85
end_define

begin_define
define|#
directive|define
name|HEIGHT_10THS
value|110
end_define

begin_comment
comment|/*  * Default X and Y resolution.  */
end_comment

begin_define
define|#
directive|define
name|X_DPI
value|72
end_define

begin_define
define|#
directive|define
name|Y_DPI
value|72
end_define

begin_comment
comment|/* The same print_page routine currently serves for */
end_comment

begin_comment
comment|/* both monochrome and color. */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|gif_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Monochrome. */
end_comment

begin_decl_stmt
name|gx_device_printer
name|gs_gifmono_device
init|=
name|prn_device
argument_list|(
name|prn_std_procs
argument_list|,
literal|"gifmono"
argument_list|,
name|WIDTH_10THS
argument_list|,
name|HEIGHT_10THS
argument_list|,
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|1
argument_list|,
name|gif_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chunky 8-bit (SuperVGA-style) color. */
end_comment

begin_comment
comment|/* (Uses a fixed palette of 3,3,2 bits.) */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|gif8_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|pc_8bit_map_rgb_color
argument_list|,
name|pc_8bit_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_printer
name|gs_gif8_device
init|=
name|prn_device
argument_list|(
name|gif8_procs
argument_list|,
literal|"gif8"
argument_list|,
name|WIDTH_10THS
argument_list|,
name|HEIGHT_10THS
argument_list|,
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|8
argument_list|,
name|gif_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Private definitions ------ */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gif_header_s
block|{
name|byte
name|signature
index|[
literal|3
index|]
decl_stmt|;
comment|/* magic number == 'GIF' */
name|byte
name|version
index|[
literal|3
index|]
decl_stmt|;
comment|/* version # '87a' or '89a' */
name|ushort
name|width
decl_stmt|;
comment|/* screen width */
name|ushort
name|height
decl_stmt|;
comment|/* screen height */
comment|/*	struct	{		/* bit structure of flags */
comment|/*	unsigned globalcolor:1;	/* global color table flag - MSB*/
define|#
directive|define
name|globalcolor_shift
value|7
comment|/*	unsigned colorres:3;	/* bits/color */
define|#
directive|define
name|colorres_shift
value|4
comment|/*	unsigned sort:1;		/* color table sorted */
define|#
directive|define
name|sort_shift
value|3
comment|/*	unsigned colorsize:3;	/* 2^colorsize bytes in color table -LSB */
define|#
directive|define
name|colorsize_shift
value|0
comment|/*	} flags;		*/
name|byte
name|flags
decl_stmt|;
name|byte
name|background
decl_stmt|;
comment|/* background color index */
name|byte
name|aspect
decl_stmt|;
comment|/* pixel aspect ratio */
comment|/* ratio = (aspect + 15) / 64 */
block|}
name|gif_header
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|image_descriptor_s
block|{
comment|/*	byte	separator;	/* image separator == 0x2c */
name|ushort
name|left_pos
decl_stmt|;
comment|/* image left pos (pixels) */
name|ushort
name|top_pos
decl_stmt|;
comment|/* image top  pos (pixels) */
name|ushort
name|width
decl_stmt|;
comment|/* image width    (pixels) */
name|ushort
name|height
decl_stmt|;
comment|/* image height   (pixels) */
comment|/*	struct	{		*/
comment|/*	unsigned localcolor:1;	/* local color table flag */
comment|/*	unsigned interlace:1;	/* image interlaced  0=no */
comment|/*	unsigned sort:1;	/* color table sorted 0=no*/
comment|/*	unsigned resv:2;	*/
comment|/*	unsigned localsize:3;	/* 2^localsize+1 = color table size */
comment|/*	} flags;		*/
name|byte
name|flags
decl_stmt|;
block|}
name|image_descriptor
typedef|;
end_typedef

begin_comment
comment|/* State for reading bits from image. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pixel_reader_s
block|{
name|byte
modifier|*
name|next
decl_stmt|;
name|int
name|bits_left
decl_stmt|;
name|uint
name|bit_buffer
decl_stmt|;
comment|/* low-order bits_left bits are valid */
block|}
name|pixel_reader
typedef|;
end_typedef

begin_comment
comment|/********************************************************/
end_comment

begin_comment
comment|/* LZW routines are based on:				*/
end_comment

begin_comment
comment|/* Dr. Dobbs Journal --- Oct. 1989. 			*/
end_comment

begin_comment
comment|/* Article on LZW Data Compression by Mark R. Nelson 	*/
end_comment

begin_comment
comment|/********************************************************/
end_comment

begin_define
define|#
directive|define
name|MAX_BITS
value|12
end_define

begin_comment
comment|/* this is max for GIF. */
end_comment

begin_define
define|#
directive|define
name|TABLE_SIZE
value|5021
end_define

begin_comment
comment|/* this is max for 12-bit codes */
end_comment

begin_comment
comment|/* State of LZW encoder */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|code_entry_s
block|{
name|int
name|code_value
decl_stmt|;
name|ushort
name|prefix_code
decl_stmt|;
name|byte
name|append_character
decl_stmt|;
block|}
name|code_entry
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lzw_encoder_s
block|{
name|int
name|bits
decl_stmt|;
name|ushort
name|Max_Code
decl_stmt|;
name|ushort
name|Clear_code
decl_stmt|;
name|ushort
name|next_code
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|code_entry
modifier|*
name|table
decl_stmt|;
name|ushort
name|string_code
decl_stmt|;
comment|/* State of output buffer */
name|byte
name|output_bit_buffer
decl_stmt|;
name|int
name|output_bit_count
decl_stmt|;
comment|/* # of valid low-order bits */
comment|/* (between 0 and 7) in buffer */
name|uint
name|byte_count
decl_stmt|;
name|byte
name|gif_buffer
index|[
literal|260
index|]
decl_stmt|;
block|}
name|lzw_encoder
typedef|;
end_typedef

begin_comment
comment|/* Initialize LZW encoder */
end_comment

begin_decl_stmt
name|private
name|void
name|lzw_set_bits
argument_list|(
name|P2
argument_list|(
argument|register lzw_encoder _ss *
argument_list|,
argument|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|lzw_reset
argument_list|(
name|P1
argument_list|(
argument|register lzw_encoder _ss *
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|lzw_init
parameter_list|(
specifier|register
name|lzw_encoder
name|_ss
modifier|*
name|pe
parameter_list|,
name|int
name|bits
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|lzw_set_bits
argument_list|(
name|pe
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|pe
operator|->
name|Clear_code
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
expr_stmt|;
name|pe
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|pe
operator|->
name|byte_count
operator|=
literal|1
expr_stmt|;
name|pe
operator|->
name|output_bit_count
operator|=
literal|0
expr_stmt|;
name|pe
operator|->
name|output_bit_buffer
operator|=
literal|0
expr_stmt|;
name|pe
operator|->
name|table
operator|=
operator|(
name|code_entry
operator|*
operator|)
name|gs_malloc
argument_list|(
name|TABLE_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|code_entry
argument_list|)
argument_list|,
literal|"GIF code table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|table
operator|==
literal|0
condition|)
return|return
name|gs_error_VMerror
return|;
comment|/* can't allocate buffers */
name|lzw_reset
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|pe
operator|->
name|string_code
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Establish the width of the code in bits */
end_comment

begin_function
name|private
name|void
name|lzw_set_bits
parameter_list|(
specifier|register
name|lzw_encoder
name|_ss
modifier|*
name|pe
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|pe
operator|->
name|bits
operator|=
name|bits
expr_stmt|;
name|pe
operator|->
name|Max_Code
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the encoding table */
end_comment

begin_function
name|private
name|void
name|lzw_reset
parameter_list|(
specifier|register
name|lzw_encoder
name|_ss
modifier|*
name|pe
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|TABLE_SIZE
condition|;
name|index
operator|++
control|)
name|pe
operator|->
name|table
index|[
name|index
index|]
operator|.
name|code_value
operator|=
operator|-
literal|1
expr_stmt|;
name|pe
operator|->
name|next_code
operator|=
name|pe
operator|->
name|Clear_code
operator|+
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put out (data) of length (bits) to GIF buffer */
end_comment

begin_function
name|private
name|void
name|lzw_putc
parameter_list|(
specifier|register
name|lzw_encoder
name|_ss
modifier|*
name|pe
parameter_list|,
name|uint
name|data
parameter_list|)
block|{
name|int
name|bits
init|=
name|pe
operator|->
name|bits
operator|+
literal|1
decl_stmt|;
comment|/* output width */
name|ulong
name|buffer
init|=
name|pe
operator|->
name|output_bit_buffer
operator||
operator|(
operator|(
name|ulong
operator|)
name|data
operator|<<
name|pe
operator|->
name|output_bit_count
operator|)
decl_stmt|;
name|pe
operator|->
name|output_bit_count
operator|+=
name|bits
expr_stmt|;
while|while
condition|(
name|pe
operator|->
name|output_bit_count
operator|>=
literal|8
condition|)
block|{
comment|/* putc(output_bit_buffer>> 24, file); */
name|pe
operator|->
name|gif_buffer
index|[
name|pe
operator|->
name|byte_count
index|]
operator|=
operator|(
name|byte
operator|)
name|buffer
expr_stmt|;
comment|/* low byte */
name|buffer
operator|>>=
literal|8
expr_stmt|;
name|pe
operator|->
name|output_bit_count
operator|-=
literal|8
expr_stmt|;
name|pe
operator|->
name|byte_count
operator|++
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|byte_count
operator|==
literal|256
condition|)
block|{
name|pe
operator|->
name|byte_count
operator|=
literal|1
expr_stmt|;
name|pe
operator|->
name|gif_buffer
index|[
literal|0
index|]
operator|=
literal|255
expr_stmt|;
comment|/* byte count for block */
name|fwrite
argument_list|(
name|pe
operator|->
name|gif_buffer
argument_list|,
literal|1
argument_list|,
literal|256
argument_list|,
name|pe
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|pe
operator|->
name|output_bit_buffer
operator|=
operator|(
name|byte
operator|)
name|buffer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish encoding, and flush the buffers. */
end_comment

begin_function
name|private
name|void
name|lzw_finish
parameter_list|(
specifier|register
name|lzw_encoder
name|_ss
modifier|*
name|pe
parameter_list|)
block|{
name|lzw_putc
argument_list|(
name|pe
argument_list|,
name|pe
operator|->
name|string_code
argument_list|)
expr_stmt|;
comment|/* output last code */
name|lzw_putc
argument_list|(
name|pe
argument_list|,
name|pe
operator|->
name|Clear_code
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* output eof code */
name|lzw_putc
argument_list|(
name|pe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* force out last code */
if|if
condition|(
name|pe
operator|->
name|byte_count
operator|!=
literal|1
condition|)
block|{
name|pe
operator|->
name|gif_buffer
index|[
literal|0
index|]
operator|=
name|pe
operator|->
name|byte_count
expr_stmt|;
name|fwrite
argument_list|(
name|pe
operator|->
name|gif_buffer
argument_list|,
literal|1
argument_list|,
name|pe
operator|->
name|byte_count
operator|+
literal|1
argument_list|,
name|pe
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Terminate LZW encoder. */
end_comment

begin_function
name|private
name|void
name|lzw_exit
parameter_list|(
specifier|register
name|lzw_encoder
name|_ss
modifier|*
name|pe
parameter_list|)
block|{
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pe
operator|->
name|table
argument_list|,
name|TABLE_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|code_entry
argument_list|)
argument_list|,
literal|"GIF code table"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the next (depth) bits from the pixel buffer. */
end_comment

begin_function
name|private
name|uint
name|lzw_getc
parameter_list|(
name|pixel_reader
name|_ss
modifier|*
name|pr
parameter_list|,
name|uint
name|depth
parameter_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|bits_left
operator|<
name|depth
condition|)
block|{
name|pr
operator|->
name|bit_buffer
operator|<<=
literal|8
expr_stmt|;
name|pr
operator|->
name|bit_buffer
operator||=
operator|*
operator|(
name|pr
operator|->
name|next
operator|++
operator|)
expr_stmt|;
name|pr
operator|->
name|bits_left
operator|+=
literal|8
expr_stmt|;
block|}
name|pr
operator|->
name|bits_left
operator|-=
name|depth
expr_stmt|;
return|return
operator|(
name|pr
operator|->
name|bit_buffer
operator|>>
name|pr
operator|->
name|bits_left
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|depth
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output 1 row of data in GIF (LZW) format. */
end_comment

begin_function
name|private
name|void
name|lzw
parameter_list|(
name|byte
modifier|*
name|from
parameter_list|,
name|byte
modifier|*
name|end
parameter_list|,
specifier|register
name|lzw_encoder
name|_ss
modifier|*
name|pe
parameter_list|,
name|byte
name|depth
parameter_list|)
block|{
name|pixel_reader
name|reader
decl_stmt|;
comment|/* Set up the reader. */
name|reader
operator|.
name|next
operator|=
name|from
expr_stmt|;
name|reader
operator|.
name|bits_left
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|next_code
operator|==
operator|(
name|pe
operator|->
name|Clear_code
operator|+
literal|2
operator|)
condition|)
comment|/* first time through */
block|{
name|pe
operator|->
name|string_code
operator|=
name|lzw_getc
argument_list|(
operator|&
name|reader
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|reader
operator|.
name|next
operator|<
name|end
operator|||
name|reader
operator|.
name|bits_left
operator|>=
name|depth
condition|)
block|{
name|uint
name|data
init|=
name|lzw_getc
argument_list|(
operator|&
name|reader
argument_list|,
name|depth
argument_list|)
decl_stmt|;
comment|/* actually only a byte */
comment|/* Hash to find a match for the prefix+char */
comment|/* string in the string table */
name|ushort
name|hash_prefix
init|=
name|pe
operator|->
name|string_code
decl_stmt|;
name|int
name|index
init|=
operator|(
name|data
operator|<<
literal|4
operator|)
operator|^
name|hash_prefix
decl_stmt|;
name|int
name|hash_offset
decl_stmt|;
specifier|register
name|code_entry
modifier|*
name|pce
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
name|hash_offset
operator|=
literal|1
expr_stmt|;
else|else
name|hash_offset
operator|=
name|TABLE_SIZE
operator|-
name|index
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pce
operator|=
operator|&
name|pe
operator|->
name|table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|pce
operator|->
name|code_value
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|pce
operator|->
name|prefix_code
operator|==
name|hash_prefix
operator|&&
name|pce
operator|->
name|append_character
operator|==
name|data
condition|)
break|break;
name|index
operator|-=
name|hash_offset
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|index
operator|+=
name|TABLE_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|pce
operator|->
name|code_value
operator|!=
operator|-
literal|1
condition|)
name|pe
operator|->
name|string_code
operator|=
name|pce
operator|->
name|code_value
expr_stmt|;
else|else
block|{
comment|/* Make a new entry */
name|pce
operator|->
name|code_value
operator|=
name|pe
operator|->
name|next_code
operator|++
expr_stmt|;
name|pce
operator|->
name|prefix_code
operator|=
name|pe
operator|->
name|string_code
expr_stmt|;
name|pce
operator|->
name|append_character
operator|=
name|data
expr_stmt|;
name|lzw_putc
argument_list|(
name|pe
argument_list|,
name|pe
operator|->
name|string_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|next_code
operator|>
operator|(
name|pe
operator|->
name|Max_Code
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Increment the width of the code */
if|if
condition|(
name|pe
operator|->
name|bits
operator|+
literal|1
operator|>=
name|MAX_BITS
condition|)
block|{
comment|/* output clear code first*/
name|lzw_putc
argument_list|(
name|pe
argument_list|,
name|pe
operator|->
name|Clear_code
argument_list|)
expr_stmt|;
name|pe
operator|->
name|bits
operator|=
operator|(
name|depth
operator|==
literal|1
condition|?
literal|2
else|:
name|depth
operator|)
expr_stmt|;
name|lzw_reset
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
else|else
name|pe
operator|->
name|bits
operator|++
expr_stmt|;
name|lzw_set_bits
argument_list|(
name|pe
argument_list|,
name|pe
operator|->
name|bits
argument_list|)
expr_stmt|;
block|}
name|pe
operator|->
name|string_code
operator|=
name|data
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write a page to a file in GIF format. */
end_comment

begin_function
name|int
name|gif_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|raster
init|=
name|gdev_prn_bytes_per_scan_line
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|pdev
operator|->
name|height
decl_stmt|;
name|int
name|depth
init|=
name|pdev
operator|->
name|color_info
operator|.
name|depth
decl_stmt|;
name|byte
modifier|*
name|row
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|raster
operator|*
literal|2
argument_list|,
literal|1
argument_list|,
literal|"gif file buffer"
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|end
init|=
name|row
operator|+
name|raster
decl_stmt|;
name|gif_header
name|header
decl_stmt|;
name|image_descriptor
name|header_desc
decl_stmt|;
name|lzw_encoder
name|encoder
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
comment|/* return code */
if|if
condition|(
name|row
operator|==
literal|0
condition|)
comment|/* can't allocate row buffer */
return|return
name|gs_error_VMerror
return|;
name|code
operator|=
name|lzw_init
argument_list|(
operator|&
name|encoder
argument_list|,
operator|(
name|depth
operator|==
literal|1
condition|?
literal|2
else|:
name|depth
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Set up the header. */
name|memcpy
argument_list|(
name|header
operator|.
name|signature
argument_list|,
literal|"GIF"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|header
operator|.
name|version
argument_list|,
literal|"87a"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|header
operator|.
name|width
operator|=
name|raster
operator|*
operator|(
literal|8
operator|/
name|depth
operator|)
expr_stmt|;
comment|/*pdev->width;*/
comment|/* for most decoders the */
comment|/* width must be on byte */
comment|/* boundry		 */
name|header
operator|.
name|height
operator|=
name|height
expr_stmt|;
comment|/*	header.flags.globalcolor = TRUE;	*/
comment|/*	header.flags.colorres = depth-1;	*/
comment|/*	header.flags.sort = FALSE;		*/
comment|/*	header.flags.colorsize = depth-1;	*/
name|header
operator|.
name|flags
operator|=
operator|(
literal|1
operator|<<
name|globalcolor_shift
operator|)
operator|+
operator|(
operator|(
name|depth
operator|-
literal|1
operator|)
operator|<<
name|colorres_shift
operator|)
operator|+
operator|(
literal|0
operator|<<
name|sort_shift
operator|)
operator|+
operator|(
operator|(
name|depth
operator|-
literal|1
operator|)
operator|<<
name|colorsize_shift
operator|)
expr_stmt|;
name|header
operator|.
name|background
operator|=
literal|0
expr_stmt|;
name|header
operator|.
name|aspect
operator|=
literal|0
expr_stmt|;
comment|/* Write the header. */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|header
argument_list|,
literal|1
argument_list|,
literal|13
argument_list|,
name|file
argument_list|)
operator|<
literal|13
condition|)
block|{
name|code
operator|=
name|gs_error_ioerror
expr_stmt|;
goto|goto
name|gif_done
goto|;
block|}
comment|/* Write the header global color palette. */
if|if
condition|(
name|pc_write_palette
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|,
literal|1
operator|<<
name|depth
argument_list|,
name|file
argument_list|)
operator|<
literal|0
condition|)
block|{
name|code
operator|=
name|gs_error_ioerror
expr_stmt|;
goto|goto
name|gif_done
goto|;
block|}
name|header_desc
operator|.
name|left_pos
operator|=
literal|0
expr_stmt|;
name|header_desc
operator|.
name|top_pos
operator|=
literal|0
expr_stmt|;
name|header_desc
operator|.
name|width
operator|=
name|raster
operator|*
operator|(
literal|8
operator|/
name|depth
operator|)
expr_stmt|;
comment|/*pdev->width;*/
name|header_desc
operator|.
name|height
operator|=
name|height
expr_stmt|;
comment|/*	header_desc.flags.localcolor = FALSE;	*/
comment|/*	header_desc.flags.interlace = FALSE;	*/
comment|/*	header_desc.flags.sort = FALSE;		*/
comment|/*	header_desc.flags.localsize = 0;	*/
name|header_desc
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Write the header image descriptor. */
name|fputc
argument_list|(
literal|0x2c
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* start with separator */
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|header_desc
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|file
argument_list|)
operator|<
literal|9
condition|)
block|{
name|code
operator|=
name|gs_error_ioerror
expr_stmt|;
goto|goto
name|gif_done
goto|;
block|}
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The Graphics Interchange Format(c) is \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"the Copyright Property of CompuServe Incorporated.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GIF(sm) is a Service Mark property of CompuServe Incorporated\n"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|encoder
operator|.
name|bits
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* start with code size */
name|lzw_putc
argument_list|(
operator|&
name|encoder
argument_list|,
name|encoder
operator|.
name|Clear_code
argument_list|)
expr_stmt|;
comment|/* output clear code first*/
comment|/* Dump the contents of the image. */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|height
condition|;
name|y
operator|++
control|)
block|{
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|y
argument_list|,
name|row
argument_list|,
name|raster
argument_list|)
expr_stmt|;
name|lzw
argument_list|(
name|row
argument_list|,
name|end
argument_list|,
operator|&
name|encoder
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|lzw_finish
argument_list|(
operator|&
name|encoder
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x3b
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* EOF indicator */
name|gif_done
label|:
name|lzw_exit
argument_list|(
operator|&
name|encoder
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|row
argument_list|,
name|raster
operator|*
literal|2
argument_list|,
literal|1
argument_list|,
literal|"gif file buffer"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

end_unit

