begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsmatrix.c */
end_comment

begin_comment
comment|/* Matrix operators for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxarith.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* The identity matrix */
end_comment

begin_comment
comment|/* This should be private (static), but the interpreter */
end_comment

begin_comment
comment|/* has to be able to fill in the "unused" words. */
end_comment

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|gs_matrix
name|gs_identity_matrix
init|=
block|{
name|identity_matrix_body
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Matrix creation ------ */
end_comment

begin_comment
comment|/* Create an identity matrix */
end_comment

begin_function
name|void
name|gs_make_identity
parameter_list|(
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
operator|*
name|pmat
operator|=
name|gs_identity_matrix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a translation matrix */
end_comment

begin_function
name|int
name|gs_make_translation
parameter_list|(
name|floatp
name|dx
parameter_list|,
name|floatp
name|dy
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
operator|*
name|pmat
operator|=
name|gs_identity_matrix
expr_stmt|;
name|pmat
operator|->
name|tx
operator|=
name|dx
expr_stmt|;
name|pmat
operator|->
name|ty
operator|=
name|dy
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a scaling matrix */
end_comment

begin_function
name|int
name|gs_make_scaling
parameter_list|(
name|floatp
name|sx
parameter_list|,
name|floatp
name|sy
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
operator|*
name|pmat
operator|=
name|gs_identity_matrix
expr_stmt|;
name|pmat
operator|->
name|xx
operator|=
name|sx
expr_stmt|;
name|pmat
operator|->
name|yy
operator|=
name|sy
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a rotation matrix. */
end_comment

begin_comment
comment|/* The angle is in degrees. */
end_comment

begin_function
name|int
name|gs_make_rotation
parameter_list|(
name|floatp
name|ang
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmat
parameter_list|)
block|{
name|float
name|theta
init|=
name|ang
operator|*
operator|(
name|M_PI
operator|/
literal|180.0
operator|)
decl_stmt|;
operator|*
name|pmat
operator|=
name|gs_identity_matrix
expr_stmt|;
name|pmat
operator|->
name|xx
operator|=
name|pmat
operator|->
name|yy
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|pmat
operator|->
name|yx
operator|=
operator|-
operator|(
name|pmat
operator|->
name|xy
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Matrix arithmetic ------ */
end_comment

begin_comment
comment|/* Multiply two matrices.  We should check for floating exceptions, */
end_comment

begin_comment
comment|/* but for the moment it's just too awkward. */
end_comment

begin_comment
comment|/* Since this is used heavily, we check for shortcuts. */
end_comment

begin_function
name|int
name|gs_matrix_multiply
parameter_list|(
specifier|const
name|gs_matrix
modifier|*
name|pm1
parameter_list|,
specifier|const
name|gs_matrix
modifier|*
name|pm2
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmr
parameter_list|)
block|{
name|float
name|xx1
init|=
name|pm1
operator|->
name|xx
decl_stmt|,
name|yy1
init|=
name|pm1
operator|->
name|yy
decl_stmt|;
name|float
name|tx1
init|=
name|pm1
operator|->
name|tx
decl_stmt|,
name|ty1
init|=
name|pm1
operator|->
name|ty
decl_stmt|;
name|float
name|xx2
init|=
name|pm2
operator|->
name|xx
decl_stmt|,
name|yy2
init|=
name|pm2
operator|->
name|yy
decl_stmt|;
name|float
name|xy2
init|=
name|pm2
operator|->
name|xy
decl_stmt|,
name|yx2
init|=
name|pm2
operator|->
name|yx
decl_stmt|;
if|if
condition|(
operator|!
name|is_skewed
argument_list|(
name|pm1
argument_list|)
condition|)
block|{
name|pmr
operator|->
name|tx
operator|=
name|tx1
operator|*
name|xx2
operator|+
name|pm2
operator|->
name|tx
expr_stmt|;
name|pmr
operator|->
name|ty
operator|=
name|ty1
operator|*
name|yy2
operator|+
name|pm2
operator|->
name|ty
expr_stmt|;
if|if
condition|(
name|is_fzero
argument_list|(
name|xy2
argument_list|)
condition|)
name|pmr
operator|->
name|xy
operator|=
literal|0
expr_stmt|;
else|else
name|pmr
operator|->
name|xy
operator|=
name|xx1
operator|*
name|xy2
operator|,
name|pmr
operator|->
name|ty
operator|+=
name|tx1
operator|*
name|xy2
expr_stmt|;
name|pmr
operator|->
name|xx
operator|=
name|xx1
operator|*
name|xx2
expr_stmt|;
if|if
condition|(
name|is_fzero
argument_list|(
name|yx2
argument_list|)
condition|)
name|pmr
operator|->
name|yx
operator|=
literal|0
expr_stmt|;
else|else
name|pmr
operator|->
name|yx
operator|=
name|yy1
operator|*
name|yx2
operator|,
name|pmr
operator|->
name|tx
operator|+=
name|ty1
operator|*
name|yx2
expr_stmt|;
name|pmr
operator|->
name|yy
operator|=
name|yy1
operator|*
name|yy2
expr_stmt|;
block|}
else|else
block|{
name|pmr
operator|->
name|xx
operator|=
name|xx1
operator|*
name|xx2
operator|+
name|pm1
operator|->
name|xy
operator|*
name|yx2
expr_stmt|;
name|pmr
operator|->
name|xy
operator|=
name|xx1
operator|*
name|xy2
operator|+
name|pm1
operator|->
name|xy
operator|*
name|yy2
expr_stmt|;
name|pmr
operator|->
name|yy
operator|=
name|pm1
operator|->
name|yx
operator|*
name|xy2
operator|+
name|yy1
operator|*
name|yy2
expr_stmt|;
name|pmr
operator|->
name|yx
operator|=
name|pm1
operator|->
name|yx
operator|*
name|xx2
operator|+
name|yy1
operator|*
name|yx2
expr_stmt|;
name|pmr
operator|->
name|tx
operator|=
name|tx1
operator|*
name|xx2
operator|+
name|ty1
operator|*
name|yx2
operator|+
name|pm2
operator|->
name|tx
expr_stmt|;
name|pmr
operator|->
name|ty
operator|=
name|tx1
operator|*
name|xy2
operator|+
name|ty1
operator|*
name|yy2
operator|+
name|pm2
operator|->
name|ty
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invert a matrix.  Return gs_error_undefinedresult if not invertible. */
end_comment

begin_function
name|int
name|gs_matrix_invert
parameter_list|(
specifier|register
specifier|const
name|gs_matrix
modifier|*
name|pm
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmr
parameter_list|)
block|{
comment|/* We have to be careful about fetch/store order, */
comment|/* because pm might be the same as pmr. */
if|if
condition|(
operator|!
name|is_skewed
argument_list|(
name|pm
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_fzero
argument_list|(
name|pm
operator|->
name|xx
argument_list|)
operator|||
name|is_fzero
argument_list|(
name|pm
operator|->
name|yy
argument_list|)
condition|)
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
name|pmr
operator|->
name|tx
operator|=
operator|-
operator|(
name|pmr
operator|->
name|xx
operator|=
literal|1.0
operator|/
name|pm
operator|->
name|xx
operator|)
operator|*
name|pm
operator|->
name|tx
expr_stmt|;
name|pmr
operator|->
name|xy
operator|=
literal|0.0
expr_stmt|;
name|pmr
operator|->
name|yx
operator|=
literal|0.0
expr_stmt|;
name|pmr
operator|->
name|ty
operator|=
operator|-
operator|(
name|pmr
operator|->
name|yy
operator|=
literal|1.0
operator|/
name|pm
operator|->
name|yy
operator|)
operator|*
name|pm
operator|->
name|ty
expr_stmt|;
block|}
else|else
block|{
name|double
name|det
init|=
name|pm
operator|->
name|xx
operator|*
name|pm
operator|->
name|yy
operator|-
name|pm
operator|->
name|xy
operator|*
name|pm
operator|->
name|yx
decl_stmt|;
name|float
name|mxx
init|=
name|pm
operator|->
name|xx
decl_stmt|,
name|mtx
init|=
name|pm
operator|->
name|tx
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
name|pmr
operator|->
name|xx
operator|=
name|pm
operator|->
name|yy
operator|/
name|det
expr_stmt|;
name|pmr
operator|->
name|xy
operator|=
operator|-
name|pm
operator|->
name|xy
operator|/
name|det
expr_stmt|;
name|pmr
operator|->
name|yx
operator|=
operator|-
name|pm
operator|->
name|yx
operator|/
name|det
expr_stmt|;
name|pmr
operator|->
name|yy
operator|=
name|mxx
operator|/
name|det
expr_stmt|;
comment|/* xx is already changed */
name|pmr
operator|->
name|tx
operator|=
operator|-
operator|(
name|mtx
operator|*
name|pmr
operator|->
name|xx
operator|+
name|pm
operator|->
name|ty
operator|*
name|pmr
operator|->
name|yx
operator|)
expr_stmt|;
name|pmr
operator|->
name|ty
operator|=
operator|-
operator|(
name|mtx
operator|*
name|pmr
operator|->
name|xy
operator|+
name|pm
operator|->
name|ty
operator|*
name|pmr
operator|->
name|yy
operator|)
expr_stmt|;
comment|/* tx is already changed */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Rotate a matrix, possibly in place.  The angle is in degrees. */
end_comment

begin_function
name|int
name|gs_matrix_rotate
parameter_list|(
specifier|register
specifier|const
name|gs_matrix
modifier|*
name|pm
parameter_list|,
name|floatp
name|ang
parameter_list|,
specifier|register
name|gs_matrix
modifier|*
name|pmr
parameter_list|)
block|{
name|float
name|mxx
decl_stmt|,
name|mxy
decl_stmt|;
name|int
name|quads
decl_stmt|;
name|float
name|tsin
decl_stmt|,
name|tcos
decl_stmt|;
comment|/* We do some special checking for multiples of 90, */
comment|/* so we don't get any rounding errors. */
if|if
condition|(
name|ang
operator|>=
operator|-
literal|360
operator|&&
name|ang
operator|<=
literal|360
operator|&&
name|ang
operator|==
operator|(
name|quads
operator|=
operator|(
name|int
operator|)
name|ang
operator|/
literal|90
operator|)
operator|*
literal|90
condition|)
block|{
name|int
name|isin
init|=
literal|0
decl_stmt|,
name|icos
init|=
literal|1
decl_stmt|,
name|t
decl_stmt|;
name|quads
operator|&=
literal|3
expr_stmt|;
while|while
condition|(
name|quads
operator|--
condition|)
name|t
operator|=
name|isin
operator|,
name|isin
operator|=
name|icos
operator|,
name|icos
operator|=
operator|-
name|t
expr_stmt|;
name|tsin
operator|=
name|isin
operator|,
name|tcos
operator|=
name|icos
expr_stmt|;
block|}
else|else
block|{
name|float
name|theta
init|=
name|ang
operator|*
operator|(
name|M_PI
operator|/
literal|180.0
operator|)
decl_stmt|;
name|tsin
operator|=
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|tcos
operator|=
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
block|}
name|mxx
operator|=
name|pm
operator|->
name|xx
operator|,
name|mxy
operator|=
name|pm
operator|->
name|xy
expr_stmt|;
name|pmr
operator|->
name|xx
operator|=
name|tcos
operator|*
name|mxx
operator|+
name|tsin
operator|*
name|pm
operator|->
name|yx
expr_stmt|;
name|pmr
operator|->
name|xy
operator|=
name|tcos
operator|*
name|mxy
operator|+
name|tsin
operator|*
name|pm
operator|->
name|yy
expr_stmt|;
name|pmr
operator|->
name|yx
operator|=
name|tcos
operator|*
name|pm
operator|->
name|yx
operator|-
name|tsin
operator|*
name|mxx
expr_stmt|;
name|pmr
operator|->
name|yy
operator|=
name|tcos
operator|*
name|pm
operator|->
name|yy
operator|-
name|tsin
operator|*
name|mxy
expr_stmt|;
name|pmr
operator|->
name|tx
operator|=
name|pm
operator|->
name|tx
expr_stmt|;
name|pmr
operator|->
name|ty
operator|=
name|pm
operator|->
name|ty
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Coordinate transformations (floating point) ------ */
end_comment

begin_comment
comment|/* Note that all the transformation routines take separate */
end_comment

begin_comment
comment|/* x and y arguments, but return their result in a point. */
end_comment

begin_comment
comment|/* Transform a point. */
end_comment

begin_function
name|int
name|gs_point_transform
parameter_list|(
name|floatp
name|x
parameter_list|,
name|floatp
name|y
parameter_list|,
specifier|register
specifier|const
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
specifier|register
name|gs_point
modifier|*
name|ppt
parameter_list|)
block|{
name|ppt
operator|->
name|x
operator|=
name|x
operator|*
name|pmat
operator|->
name|xx
operator|+
name|pmat
operator|->
name|tx
expr_stmt|;
name|ppt
operator|->
name|y
operator|=
name|y
operator|*
name|pmat
operator|->
name|yy
operator|+
name|pmat
operator|->
name|ty
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|yx
argument_list|)
condition|)
name|ppt
operator|->
name|x
operator|+=
name|y
operator|*
name|pmat
operator|->
name|yx
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|xy
argument_list|)
condition|)
name|ppt
operator|->
name|y
operator|+=
name|x
operator|*
name|pmat
operator|->
name|xy
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Inverse-transform a point. */
end_comment

begin_comment
comment|/* Return gs_error_undefinedresult if the matrix is not invertible. */
end_comment

begin_function
name|int
name|gs_point_transform_inverse
parameter_list|(
name|floatp
name|x
parameter_list|,
name|floatp
name|y
parameter_list|,
specifier|register
specifier|const
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
specifier|register
name|gs_point
modifier|*
name|ppt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_skewed
argument_list|(
name|pmat
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_fzero
argument_list|(
name|pmat
operator|->
name|xx
argument_list|)
operator|||
name|is_fzero
argument_list|(
name|pmat
operator|->
name|yy
argument_list|)
condition|)
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|x
operator|=
operator|(
name|x
operator|-
name|pmat
operator|->
name|tx
operator|)
operator|/
name|pmat
operator|->
name|xx
expr_stmt|;
name|ppt
operator|->
name|y
operator|=
operator|(
name|y
operator|-
name|pmat
operator|->
name|ty
operator|)
operator|/
name|pmat
operator|->
name|yy
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* There are faster ways to do this, */
comment|/* but we won't implement one unless we have to. */
name|gs_matrix
name|imat
decl_stmt|;
name|int
name|code
init|=
name|gs_matrix_invert
argument_list|(
name|pmat
argument_list|,
operator|&
name|imat
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
name|gs_point_transform
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|imat
argument_list|,
name|ppt
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Transform a distance. */
end_comment

begin_function
name|int
name|gs_distance_transform
parameter_list|(
name|floatp
name|dx
parameter_list|,
name|floatp
name|dy
parameter_list|,
specifier|register
specifier|const
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
specifier|register
name|gs_point
modifier|*
name|pdpt
parameter_list|)
block|{
name|pdpt
operator|->
name|x
operator|=
name|dx
operator|*
name|pmat
operator|->
name|xx
expr_stmt|;
name|pdpt
operator|->
name|y
operator|=
name|dy
operator|*
name|pmat
operator|->
name|yy
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|yx
argument_list|)
condition|)
name|pdpt
operator|->
name|x
operator|+=
name|dy
operator|*
name|pmat
operator|->
name|yx
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|xy
argument_list|)
condition|)
name|pdpt
operator|->
name|y
operator|+=
name|dx
operator|*
name|pmat
operator|->
name|xy
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Inverse-transform a distance. */
end_comment

begin_comment
comment|/* Return gs_error_undefinedresult if the matrix is not invertible. */
end_comment

begin_function
name|int
name|gs_distance_transform_inverse
parameter_list|(
name|floatp
name|dx
parameter_list|,
name|floatp
name|dy
parameter_list|,
specifier|register
specifier|const
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
specifier|register
name|gs_point
modifier|*
name|pdpt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_skewed
argument_list|(
name|pmat
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_fzero
argument_list|(
name|pmat
operator|->
name|xx
argument_list|)
operator|||
name|is_fzero
argument_list|(
name|pmat
operator|->
name|yy
argument_list|)
condition|)
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
name|pdpt
operator|->
name|x
operator|=
name|dx
operator|/
name|pmat
operator|->
name|xx
expr_stmt|;
name|pdpt
operator|->
name|y
operator|=
name|dy
operator|/
name|pmat
operator|->
name|yy
expr_stmt|;
block|}
else|else
block|{
name|double
name|det
init|=
name|pmat
operator|->
name|xx
operator|*
name|pmat
operator|->
name|yy
operator|-
name|pmat
operator|->
name|xy
operator|*
name|pmat
operator|->
name|yx
decl_stmt|;
if|if
condition|(
name|det
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_undefinedresult
argument_list|)
expr_stmt|;
name|pdpt
operator|->
name|x
operator|=
operator|(
name|dx
operator|*
name|pmat
operator|->
name|yy
operator|-
name|dy
operator|*
name|pmat
operator|->
name|yx
operator|)
operator|/
name|det
expr_stmt|;
name|pdpt
operator|->
name|y
operator|=
operator|(
name|dy
operator|*
name|pmat
operator|->
name|xx
operator|-
name|dx
operator|*
name|pmat
operator|->
name|xy
operator|)
operator|/
name|det
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Inverse-transform a bounding box. */
end_comment

begin_comment
comment|/* Return gs_error_undefinedresult if the matrix is not invertible. */
end_comment

begin_function
name|int
name|gs_bbox_transform_inverse
parameter_list|(
name|gs_rect
modifier|*
name|pbox_in
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
name|gs_rect
modifier|*
name|pbox_out
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|gs_point
name|p
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|double
name|xmin
decl_stmt|,
name|ymin
decl_stmt|,
name|xmax
decl_stmt|,
name|ymax
decl_stmt|;
comment|/* gs_point uses double */
comment|/* We must recompute the max and min after transforming, */
comment|/* since a rotation may be involved. */
if|if
condition|(
operator|(
name|code
operator|=
name|gs_point_transform_inverse
argument_list|(
name|pbox_in
operator|->
name|p
operator|.
name|x
argument_list|,
name|pbox_in
operator|->
name|p
operator|.
name|y
argument_list|,
name|pmat
argument_list|,
operator|&
name|p
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_distance_transform_inverse
argument_list|(
name|pbox_in
operator|->
name|q
operator|.
name|x
operator|-
name|pbox_in
operator|->
name|p
operator|.
name|x
argument_list|,
literal|0.0
argument_list|,
name|pmat
argument_list|,
operator|&
name|w
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_distance_transform_inverse
argument_list|(
literal|0.0
argument_list|,
name|pbox_in
operator|->
name|q
operator|.
name|y
operator|-
name|pbox_in
operator|->
name|p
operator|.
name|y
argument_list|,
name|pmat
argument_list|,
operator|&
name|h
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|xmin
operator|=
name|xmax
operator|=
name|p
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|x
operator|<
literal|0
condition|)
name|xmin
operator|+=
name|w
operator|.
name|x
expr_stmt|;
else|else
name|xmax
operator|+=
name|w
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|x
operator|<
literal|0
condition|)
name|xmin
operator|+=
name|h
operator|.
name|x
expr_stmt|;
else|else
name|xmax
operator|+=
name|h
operator|.
name|x
expr_stmt|;
name|ymin
operator|=
name|ymax
operator|=
name|p
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|y
operator|<
literal|0
condition|)
name|ymin
operator|+=
name|w
operator|.
name|y
expr_stmt|;
else|else
name|ymax
operator|+=
name|w
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|y
operator|<
literal|0
condition|)
name|ymin
operator|+=
name|h
operator|.
name|y
expr_stmt|;
else|else
name|ymax
operator|+=
name|h
operator|.
name|y
expr_stmt|;
name|pbox_out
operator|->
name|p
operator|.
name|x
operator|=
name|xmin
operator|,
name|pbox_out
operator|->
name|p
operator|.
name|y
operator|=
name|ymin
expr_stmt|;
name|pbox_out
operator|->
name|q
operator|.
name|x
operator|=
name|xmax
operator|,
name|pbox_out
operator|->
name|q
operator|.
name|y
operator|=
name|ymax
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Coordinate transformations (to fixed point) ------ */
end_comment

begin_comment
comment|/* Transform a point with a fixed-point result. */
end_comment

begin_function
name|int
name|gs_point_transform2fixed
parameter_list|(
specifier|register
name|gs_matrix_fixed
modifier|*
name|pmat
parameter_list|,
name|floatp
name|x
parameter_list|,
name|floatp
name|y
parameter_list|,
name|gs_fixed_point
modifier|*
name|ppt
parameter_list|)
block|{
name|ppt
operator|->
name|x
operator|=
name|float2fixed
argument_list|(
name|x
operator|*
name|pmat
operator|->
name|xx
argument_list|)
operator|+
name|pmat
operator|->
name|tx_fixed
expr_stmt|;
name|ppt
operator|->
name|y
operator|=
name|float2fixed
argument_list|(
name|y
operator|*
name|pmat
operator|->
name|yy
argument_list|)
operator|+
name|pmat
operator|->
name|ty_fixed
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|yx
argument_list|)
condition|)
name|ppt
operator|->
name|x
operator|+=
name|float2fixed
argument_list|(
name|y
operator|*
name|pmat
operator|->
name|yx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|xy
argument_list|)
condition|)
name|ppt
operator|->
name|y
operator|+=
name|float2fixed
argument_list|(
name|x
operator|*
name|pmat
operator|->
name|xy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Transform a distance with a fixed-point result. */
end_comment

begin_function
name|int
name|gs_distance_transform2fixed
parameter_list|(
specifier|register
name|gs_matrix_fixed
modifier|*
name|pmat
parameter_list|,
name|floatp
name|dx
parameter_list|,
name|floatp
name|dy
parameter_list|,
name|gs_fixed_point
modifier|*
name|ppt
parameter_list|)
block|{
name|ppt
operator|->
name|x
operator|=
name|float2fixed
argument_list|(
name|dx
operator|*
name|pmat
operator|->
name|xx
argument_list|)
expr_stmt|;
name|ppt
operator|->
name|y
operator|=
name|float2fixed
argument_list|(
name|dy
operator|*
name|pmat
operator|->
name|yy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|yx
argument_list|)
condition|)
name|ppt
operator|->
name|x
operator|+=
name|float2fixed
argument_list|(
name|dy
operator|*
name|pmat
operator|->
name|yx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_fzero
argument_list|(
name|pmat
operator|->
name|xy
argument_list|)
condition|)
name|ppt
operator|->
name|y
operator|+=
name|float2fixed
argument_list|(
name|dx
operator|*
name|pmat
operator|->
name|xy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

