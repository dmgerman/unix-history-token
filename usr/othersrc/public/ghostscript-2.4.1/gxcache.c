begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxcache.c */
end_comment

begin_comment
comment|/* Character cache routines for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gspaint.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_comment
comment|/* requires gsstate.h */
end_comment

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_include
include|#
directive|include
file|"gxcpath.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_include
include|#
directive|include
file|"gxchar.h"
end_include

begin_include
include|#
directive|include
file|"gxcache.h"
end_include

begin_include
include|#
directive|include
file|"gxfont.h"
end_include

begin_include
include|#
directive|include
file|"gxfdir.h"
end_include

begin_decl_stmt
specifier|extern
name|ulong
name|gs_next_ids
argument_list|(
name|P1
argument_list|(
name|uint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the size of the cache structures. */
end_comment

begin_comment
comment|/* We round the size of a cached_char so that */
end_comment

begin_comment
comment|/* an immediately following bitmap will be properly aligned. */
end_comment

begin_decl_stmt
specifier|const
name|uint
name|cached_char_sizeof
init|=
sizeof|sizeof
argument_list|(
name|cached_char
argument_list|)
operator|+
operator|(
operator|-
sizeof|sizeof
argument_list|(
name|cached_char
argument_list|)
operator|&
literal|3
operator|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cc_bits
parameter_list|(
name|cc
parameter_list|)
value|((byte *)(cc) + cached_char_sizeof)
end_define

begin_decl_stmt
specifier|const
name|uint
name|cached_fm_pair_sizeof
init|=
sizeof|sizeof
argument_list|(
name|cached_fm_pair
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the hash chain for a (code, fm_pair) key. */
end_comment

begin_define
define|#
directive|define
name|chars_head
parameter_list|(
name|dir
parameter_list|,
name|code
parameter_list|,
name|pair
parameter_list|)
define|\
value|&(dir)->chars[((uint)(code) + ((uint)(pair)<< 4))& (dir)->chars_mask]
end_define

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|void
name|shorten_cached_char
argument_list|(
name|P3
argument_list|(
name|gs_font_dir
operator|*
argument_list|,
name|cached_char
operator|*
argument_list|,
name|uint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|purge_fm_pair
argument_list|(
name|P2
argument_list|(
name|gs_font_dir
operator|*
argument_list|,
name|cached_fm_pair
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the character cache. */
end_comment

begin_function
name|void
name|gx_char_cache_init
parameter_list|(
specifier|register
name|gs_font_dir
modifier|*
name|dir
parameter_list|)
block|{
name|cached_char_head
modifier|*
name|cdata
init|=
operator|(
name|cached_char_head
operator|*
operator|)
name|dir
operator|->
name|cdata
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cached_fm_pair
modifier|*
name|pair
decl_stmt|;
name|dir
operator|->
name|bsize
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|msize
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|csize
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|mnext
operator|=
literal|0
expr_stmt|;
name|dir
operator|->
name|cnext
operator|=
literal|0
expr_stmt|;
name|cdata
operator|->
name|pair
operator|=
literal|0
expr_stmt|;
name|cdata
operator|->
name|size
operator|=
name|dir
operator|->
name|cdata_size
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dir
operator|->
name|chars
argument_list|,
literal|0
argument_list|,
operator|(
name|dir
operator|->
name|chars_mask
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cached_char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dir
operator|->
name|mmax
operator|,
name|pair
operator|=
name|dir
operator|->
name|mdata
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pair
operator|++
control|)
name|fm_pair_set_free
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate storage for caching a rendered character, */
end_comment

begin_comment
comment|/* and set up the memory device. */
end_comment

begin_comment
comment|/* Return the cached_char if OK, 0 if too big. */
end_comment

begin_function
name|cached_char
modifier|*
name|gx_alloc_char_bits
parameter_list|(
name|gs_font_dir
modifier|*
name|dir
parameter_list|,
name|gx_device_memory
modifier|*
name|dev
parameter_list|,
name|ushort
name|iwidth
parameter_list|,
name|ushort
name|iheight
parameter_list|)
block|{
name|ulong
name|isize
decl_stmt|,
name|cdsize
decl_stmt|;
name|cached_char_head
modifier|*
name|cch
decl_stmt|;
define|#
directive|define
name|hcc
value|((cached_char *)cch)
name|cached_char
modifier|*
name|cc
decl_stmt|;
name|uint
name|fsize
init|=
literal|0
decl_stmt|;
name|byte
modifier|*
name|bits
decl_stmt|;
name|dev
operator|->
name|width
operator|=
name|iwidth
expr_stmt|;
name|dev
operator|->
name|height
operator|=
name|iheight
expr_stmt|;
name|isize
operator|=
name|gdev_mem_bitmap_size
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* sets raster */
if|if
condition|(
name|dev
operator|->
name|raster
operator|!=
literal|0
operator|&&
name|iheight
operator|>
name|dir
operator|->
name|upper
operator|/
name|dev
operator|->
name|raster
condition|)
return|return
literal|0
return|;
comment|/* too big */
name|cdsize
operator|=
name|isize
operator|+
name|cached_char_sizeof
expr_stmt|;
if|if
condition|(
name|cdsize
operator|>=
name|dir
operator|->
name|cmax
condition|)
return|return
literal|0
return|;
comment|/* too big */
comment|/* Look for and/or free enough space. */
name|cch
operator|=
operator|(
name|cached_char_head
operator|*
operator|)
operator|(
name|dir
operator|->
name|cdata
operator|+
name|dir
operator|->
name|cnext
operator|)
expr_stmt|;
name|cc
operator|=
name|hcc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|byte
operator|*
operator|)
name|cc
operator|+
name|fsize
operator|==
name|dir
operator|->
name|cdata
operator|+
name|dir
operator|->
name|cdata_size
condition|)
name|cch
operator|=
operator|(
name|cached_char_head
operator|*
operator|)
name|dir
operator|->
name|cdata
operator|,
name|cc
operator|=
name|hcc
operator|,
name|fsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|cc_head_is_free
argument_list|(
name|cch
argument_list|)
condition|)
block|{
comment|/* Free the character */
name|cached_char
modifier|*
modifier|*
name|pcc
init|=
name|chars_head
argument_list|(
name|dir
argument_list|,
name|hcc
operator|->
name|code
argument_list|,
name|cch
operator|->
name|pair
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|pcc
operator|!=
name|hcc
condition|)
name|pcc
operator|=
operator|&
operator|(
operator|*
name|pcc
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|pcc
operator|=
name|hcc
operator|->
name|next
expr_stmt|;
comment|/* remove from chain */
name|gx_free_cached_char
argument_list|(
name|dir
argument_list|,
name|hcc
argument_list|)
expr_stmt|;
block|}
name|fsize
operator|+=
name|cch
operator|->
name|size
expr_stmt|;
name|if_debug2
argument_list|(
literal|'K'
argument_list|,
literal|"[K]merging free 0x%lx(%u)\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cch
argument_list|,
name|cch
operator|->
name|size
argument_list|)
expr_stmt|;
name|cc
operator|->
name|head
operator|.
name|size
operator|=
name|fsize
expr_stmt|;
if|if
condition|(
name|fsize
operator|==
name|cdsize
operator|||
name|fsize
operator|>=
name|cdsize
operator|+
sizeof|sizeof
argument_list|(
name|cached_char_head
argument_list|)
condition|)
break|break;
comment|/* enough room here */
name|cch
operator|=
operator|(
name|cached_char_head
operator|*
operator|)
operator|(
operator|(
name|byte
operator|*
operator|)
name|cc
operator|+
name|fsize
operator|)
expr_stmt|;
block|}
undef|#
directive|undef
name|hcc
if|if
condition|(
name|fsize
operator|>
name|cdsize
condition|)
block|{
name|shorten_cached_char
argument_list|(
name|dir
argument_list|,
name|cc
argument_list|,
name|fsize
operator|-
name|cdsize
argument_list|)
expr_stmt|;
name|if_debug2
argument_list|(
literal|'K'
argument_list|,
literal|"[K]shortening 0x%lx by %u (initial)\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cc
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|fsize
operator|-
name|cdsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|if_debug4
argument_list|(
literal|'k'
argument_list|,
literal|"[k]adding 0x%lx:%u(%u,%u)\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cc
argument_list|,
operator|(
name|uint
operator|)
name|cdsize
argument_list|,
name|iwidth
argument_list|,
name|iheight
argument_list|)
expr_stmt|;
name|bits
operator|=
name|cc_bits
argument_list|(
name|cc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bits
argument_list|,
literal|0
argument_list|,
operator|(
name|uint
operator|)
name|isize
argument_list|)
expr_stmt|;
name|cc
operator|->
name|width
operator|=
name|iwidth
expr_stmt|;
name|cc
operator|->
name|height
operator|=
name|iheight
expr_stmt|;
name|cc
operator|->
name|raster
operator|=
name|dev
operator|->
name|raster
expr_stmt|;
name|cc
operator|->
name|head
operator|.
name|pair
operator|=
literal|0
expr_stmt|;
comment|/* not linked in yet */
name|dev
operator|->
name|base
operator|=
name|bits
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|open_device
call|)
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
comment|/* initialize */
name|dir
operator|->
name|csize
operator|++
expr_stmt|;
name|dir
operator|->
name|bsize
operator|+=
name|cdsize
expr_stmt|;
name|dir
operator|->
name|cnext
operator|=
operator|(
name|byte
operator|*
operator|)
name|cc
operator|+
name|cdsize
operator|-
name|dir
operator|->
name|cdata
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function

begin_comment
comment|/* Remove a character from the cache. */
end_comment

begin_function
name|void
name|gx_free_cached_char
parameter_list|(
name|gs_font_dir
modifier|*
name|dir
parameter_list|,
name|cached_char
modifier|*
name|cc
parameter_list|)
block|{
name|dir
operator|->
name|cnext
operator|=
operator|(
name|byte
operator|*
operator|)
name|cc
operator|-
name|dir
operator|->
name|cdata
expr_stmt|;
name|dir
operator|->
name|csize
operator|--
expr_stmt|;
name|dir
operator|->
name|bsize
operator|-=
name|cc
operator|->
name|head
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|head
operator|.
name|pair
operator|!=
literal|0
condition|)
block|{
comment|/* might be allocated but not added to table yet */
name|cc
operator|->
name|head
operator|.
name|pair
operator|->
name|num_chars
operator|--
expr_stmt|;
block|}
name|if_debug2
argument_list|(
literal|'k'
argument_list|,
literal|"[k]freeing 0x%lx, pair=0x%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cc
argument_list|,
operator|(
name|ulong
operator|)
name|cc
operator|->
name|head
operator|.
name|pair
argument_list|)
expr_stmt|;
name|cc_set_free
argument_list|(
name|cc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up, and if necessary add, a font/matrix pair in the cache */
end_comment

begin_function
name|cached_fm_pair
modifier|*
name|gx_lookup_fm_pair
parameter_list|(
specifier|register
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|float
name|mxx
init|=
name|pgs
operator|->
name|char_tm
operator|.
name|xx
decl_stmt|,
name|mxy
init|=
name|pgs
operator|->
name|char_tm
operator|.
name|xy
decl_stmt|,
name|myx
init|=
name|pgs
operator|->
name|char_tm
operator|.
name|yx
decl_stmt|,
name|myy
init|=
name|pgs
operator|->
name|char_tm
operator|.
name|yy
decl_stmt|;
name|gs_font
modifier|*
name|font
init|=
name|pgs
operator|->
name|font
decl_stmt|;
specifier|register
name|gs_font_dir
modifier|*
name|dir
init|=
name|font
operator|->
name|dir
decl_stmt|;
specifier|register
name|cached_fm_pair
modifier|*
name|pair
init|=
name|dir
operator|->
name|mdata
operator|+
name|dir
operator|->
name|mnext
decl_stmt|;
name|int
name|count
init|=
name|dir
operator|->
name|mmax
decl_stmt|;
name|long
name|uid
init|=
operator|-
literal|1
decl_stmt|;
name|cached_fm_pair
modifier|*
name|mend
decl_stmt|;
if|if
condition|(
name|font
operator|->
name|FontType
operator|!=
name|ft_composite
condition|)
block|{
name|uid
operator|=
name|font
operator|->
name|data
operator|.
name|base
operator|.
name|UniqueID
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
operator|-
literal|1
condition|)
name|font
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|pair
operator|==
name|dir
operator|->
name|mdata
condition|)
name|pair
operator|+=
name|dir
operator|->
name|mmax
expr_stmt|;
name|pair
operator|--
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|font
operator|==
name|font
operator|&&
name|pair
operator|->
name|UniqueID
operator|==
name|uid
operator|&&
name|pair
operator|->
name|mxx
operator|==
name|mxx
operator|&&
name|pair
operator|->
name|mxy
operator|==
name|mxy
operator|&&
name|pair
operator|->
name|myx
operator|==
name|myx
operator|&&
name|pair
operator|->
name|myy
operator|==
name|myy
condition|)
return|return
name|pair
return|;
block|}
comment|/* Add the pair to the cache */
name|mend
operator|=
name|dir
operator|->
name|mdata
operator|+
name|dir
operator|->
name|mmax
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|msize
operator|==
name|dir
operator|->
name|mmax
condition|)
comment|/* cache is full */
block|{
comment|/* Prefer an entry with num_chars == 0, if any. */
for|for
control|(
name|count
operator|=
name|dir
operator|->
name|mmax
init|;
operator|--
name|count
operator|>=
literal|0
operator|&&
name|pair
operator|->
name|num_chars
operator|!=
literal|0
condition|;
control|)
if|if
condition|(
operator|++
name|pair
operator|==
name|mend
condition|)
name|pair
operator|=
name|dir
operator|->
name|mdata
expr_stmt|;
name|purge_fm_pair
argument_list|(
name|dir
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Look for an empty entry.  (We know there is one.) */
while|while
condition|(
operator|!
name|fm_pair_is_free
argument_list|(
name|pair
argument_list|)
condition|)
if|if
condition|(
operator|++
name|pair
operator|==
name|mend
condition|)
name|pair
operator|=
name|dir
operator|->
name|mdata
expr_stmt|;
block|}
name|dir
operator|->
name|msize
operator|++
expr_stmt|;
name|dir
operator|->
name|mnext
operator|=
name|pair
operator|+
literal|1
operator|-
name|dir
operator|->
name|mdata
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|mnext
operator|==
name|dir
operator|->
name|mmax
condition|)
name|dir
operator|->
name|mnext
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|font
operator|=
name|font
expr_stmt|;
name|pair
operator|->
name|UniqueID
operator|=
name|uid
expr_stmt|;
name|pair
operator|->
name|mxx
operator|=
name|mxx
operator|,
name|pair
operator|->
name|mxy
operator|=
name|mxy
expr_stmt|;
name|pair
operator|->
name|myx
operator|=
name|myx
operator|,
name|pair
operator|->
name|myy
operator|=
name|myy
expr_stmt|;
name|pair
operator|->
name|num_chars
operator|=
literal|0
expr_stmt|;
return|return
name|pair
return|;
block|}
end_function

begin_comment
comment|/* Add a character to the cache */
end_comment

begin_function
name|void
name|gx_add_cached_char
parameter_list|(
name|gs_font_dir
modifier|*
name|dir
parameter_list|,
name|gx_device_memory
modifier|*
name|dev
parameter_list|,
name|cached_char
modifier|*
name|cc
parameter_list|,
name|cached_fm_pair
modifier|*
name|pair
parameter_list|)
block|{
name|cc
operator|->
name|id
operator|=
name|gs_next_ids
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure the bits are in the right order */
comment|/* to use as a source. */
name|gdev_mem_ensure_byte_order
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Add the new character at the tail of its chain. */
block|{
specifier|register
name|cached_char
modifier|*
modifier|*
name|head
init|=
name|chars_head
argument_list|(
name|dir
argument_list|,
name|cc
operator|->
name|code
argument_list|,
name|pair
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|head
operator|!=
literal|0
condition|)
name|head
operator|=
operator|&
operator|(
operator|*
name|head
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|head
operator|=
name|cc
expr_stmt|;
name|cc
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|cc
operator|->
name|head
operator|.
name|pair
operator|=
name|pair
expr_stmt|;
name|pair
operator|->
name|num_chars
operator|++
expr_stmt|;
block|}
comment|/* Discard the memory device overhead that follows the bits. */
block|{
name|uint
name|diff
init|=
name|gdev_mem_bitmap_size
argument_list|(
name|dev
argument_list|)
operator|-
name|cc
operator|->
name|raster
operator|*
name|cc
operator|->
name|height
decl_stmt|;
if|if
condition|(
name|diff
operator|>=
sizeof|sizeof
argument_list|(
name|cached_char_head
argument_list|)
condition|)
block|{
name|shorten_cached_char
argument_list|(
name|dir
argument_list|,
name|cc
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|dir
operator|->
name|bsize
operator|-=
name|diff
expr_stmt|;
name|if_debug2
argument_list|(
literal|'K'
argument_list|,
literal|"[K]shortening 0x%lx by %u (mdev overhead)\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cc
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look up a character in the cache. */
end_comment

begin_comment
comment|/* Return the cached_char or 0. */
end_comment

begin_function
name|cached_char
modifier|*
name|gx_lookup_cached_char
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|cached_fm_pair
modifier|*
name|pair
parameter_list|,
name|char_code
name|ccode
parameter_list|)
block|{
name|gs_font_dir
modifier|*
name|dir
init|=
name|pgs
operator|->
name|font
operator|->
name|dir
decl_stmt|;
specifier|register
name|cached_char
modifier|*
name|cc
init|=
operator|*
name|chars_head
argument_list|(
name|dir
argument_list|,
name|ccode
argument_list|,
name|pair
argument_list|)
decl_stmt|;
while|while
condition|(
name|cc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cc
operator|->
name|code
operator|==
name|ccode
operator|&&
name|cc
operator|->
name|head
operator|.
name|pair
operator|==
name|pair
condition|)
return|return
name|cc
return|;
name|cc
operator|=
name|cc
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a cached character to the screen. */
end_comment

begin_comment
comment|/* Assume the caller has already done gx_color_load, */
end_comment

begin_comment
comment|/* and the color is not a halftone. */
end_comment

begin_comment
comment|/* Return 0 if OK, 1 if we couldn't do the operation but no error */
end_comment

begin_comment
comment|/* occurred, or a negative error code. */
end_comment

begin_function
name|int
name|gx_image_cached_char
parameter_list|(
specifier|register
name|gs_show_enum
modifier|*
name|penum
parameter_list|,
specifier|register
name|cached_char
modifier|*
name|cc
parameter_list|)
block|{
specifier|register
name|gs_state
modifier|*
name|pgs
init|=
name|penum
operator|->
name|pgs
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|code
decl_stmt|;
name|gs_fixed_point
name|pt
decl_stmt|;
name|gx_device
modifier|*
name|dev
init|=
name|pgs
operator|->
name|device
operator|->
name|info
decl_stmt|;
name|gx_device_clip
name|cdev
decl_stmt|;
name|code
operator|=
name|gx_path_current_point_inline
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Abort if the device color isn't pure. */
if|if
condition|(
operator|!
name|penum
operator|->
name|color_loaded
condition|)
block|{
if|if
condition|(
operator|!
name|color_is_pure
argument_list|(
name|pgs
operator|->
name|dev_color
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* can't use cache */
name|penum
operator|->
name|color_loaded
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the character doesn't lie entirely within the */
comment|/* quick-check clipping rectangle, we have to */
comment|/* set up an intermediate clipping device. */
name|pt
operator|.
name|x
operator|-=
name|cc
operator|->
name|offset
operator|.
name|x
expr_stmt|;
name|x
operator|=
name|fixed2int_var_rounded
argument_list|(
name|pt
operator|.
name|x
argument_list|)
operator|+
name|penum
operator|->
name|ftx
expr_stmt|;
name|pt
operator|.
name|y
operator|-=
name|cc
operator|->
name|offset
operator|.
name|y
expr_stmt|;
name|y
operator|=
name|fixed2int_var_rounded
argument_list|(
name|pt
operator|.
name|y
argument_list|)
operator|+
name|penum
operator|->
name|fty
expr_stmt|;
name|w
operator|=
name|cc
operator|->
name|width
expr_stmt|;
name|h
operator|=
name|cc
operator|->
name|height
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'K'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[K]copying 0x%lx, offset=(%g,%g)\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cc
argument_list|,
name|fixed2float
argument_list|(
operator|-
name|cc
operator|->
name|offset
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
operator|-
name|cc
operator|->
name|offset
operator|.
name|y
argument_list|)
argument_list|)
operator|,
name|dprintf6
argument_list|(
literal|"   at (%g,%g)+(%d,%d)->(%d,%d)\n"
argument_list|,
name|fixed2float
argument_list|(
name|pt
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pt
operator|.
name|y
argument_list|)
argument_list|,
name|penum
operator|->
name|ftx
argument_list|,
name|penum
operator|->
name|fty
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|<
name|penum
operator|->
name|cxmin
operator|||
name|x
operator|+
name|w
operator|>
name|penum
operator|->
name|cxmax
operator|||
name|y
operator|<
name|penum
operator|->
name|cymin
operator|||
name|y
operator|+
name|h
operator|>
name|penum
operator|->
name|cymax
condition|)
block|{
name|cdev
operator|=
name|gs_clip_device
expr_stmt|;
name|cdev
operator|.
name|target
operator|=
name|dev
expr_stmt|;
name|cdev
operator|.
name|list
operator|=
name|pgs
operator|->
name|clip_path
operator|->
name|list
expr_stmt|;
name|dev
operator|=
operator|(
name|gx_device
operator|*
operator|)
operator|&
name|cdev
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|open_device
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_debug0
argument_list|(
literal|'K'
argument_list|,
literal|"[K](clipping)\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the bits. */
name|code
operator|=
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|copy_mono
call|)
argument_list|(
name|dev
argument_list|,
name|cc_bits
argument_list|(
name|cc
argument_list|)
argument_list|,
literal|0
argument_list|,
name|cc
operator|->
name|raster
argument_list|,
name|cc
operator|->
name|id
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|w
argument_list|,
name|h
argument_list|,
name|gx_no_color_index
argument_list|,
name|pgs
operator|->
name|dev_color
operator|->
name|color1
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Purge from the caches all references to a given font. */
end_comment

begin_function
name|void
name|gs_purge_font_from_char_caches
parameter_list|(
name|gs_font_dir
modifier|*
name|dir
parameter_list|,
name|gs_font
modifier|*
name|font
parameter_list|)
block|{
name|cached_fm_pair
modifier|*
name|pair
init|=
name|dir
operator|->
name|mdata
decl_stmt|;
name|int
name|count
init|=
name|dir
operator|->
name|mmax
decl_stmt|;
name|if_debug1
argument_list|(
literal|'k'
argument_list|,
literal|"[k]purging font 0x%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|font
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|pair
operator|->
name|font
operator|==
name|font
condition|)
name|purge_fm_pair
argument_list|(
name|dir
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|pair
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Shorten a cached character. */
end_comment

begin_comment
comment|/* diff>= sizeof(cached_char_head). */
end_comment

begin_function
name|private
name|void
name|shorten_cached_char
parameter_list|(
name|gs_font_dir
modifier|*
name|dir
parameter_list|,
name|cached_char
modifier|*
name|cc
parameter_list|,
name|uint
name|diff
parameter_list|)
block|{
name|cached_char_head
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|byte
operator|*
operator|)
name|cc
operator|+
name|cc
operator|->
name|head
operator|.
name|size
operator|==
name|dir
operator|->
name|cdata
operator|+
name|dir
operator|->
name|cnext
condition|)
name|dir
operator|->
name|cnext
operator|-=
name|diff
expr_stmt|;
name|cc
operator|->
name|head
operator|.
name|size
operator|-=
name|diff
expr_stmt|;
name|next
operator|=
operator|(
name|cached_char_head
operator|*
operator|)
operator|(
operator|(
name|byte
operator|*
operator|)
name|cc
operator|+
name|cc
operator|->
name|head
operator|.
name|size
operator|)
expr_stmt|;
name|if_debug2
argument_list|(
literal|'K'
argument_list|,
literal|"[K]shortening creates free block 0x%lx(%u)\n"
argument_list|,
operator|(
name|ulong
operator|)
name|next
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|cc_head_set_free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|->
name|size
operator|=
name|diff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Purge from the caches all references to a given font/matrix pair. */
end_comment

begin_function
name|private
name|void
name|purge_fm_pair
parameter_list|(
name|gs_font_dir
modifier|*
name|dir
parameter_list|,
name|cached_fm_pair
modifier|*
name|pair
parameter_list|)
block|{
name|int
name|chi
decl_stmt|;
name|if_debug1
argument_list|(
literal|'k'
argument_list|,
literal|"[k]purging pair 0x%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|pair
argument_list|)
expr_stmt|;
for|for
control|(
name|chi
operator|=
name|dir
operator|->
name|chars_mask
init|;
name|pair
operator|->
name|num_chars
operator|!=
literal|0
condition|;
control|)
block|{
name|cached_char
modifier|*
modifier|*
name|pcc
init|=
name|dir
operator|->
name|chars
operator|+
name|chi
operator|--
decl_stmt|;
while|while
condition|(
operator|*
name|pcc
operator|!=
literal|0
condition|)
block|{
name|cached_char
modifier|*
name|cc
init|=
operator|*
name|pcc
decl_stmt|;
if|if
condition|(
name|cc
operator|->
name|head
operator|.
name|pair
operator|==
name|pair
condition|)
block|{
name|gx_free_cached_char
argument_list|(
name|dir
argument_list|,
name|cc
argument_list|)
expr_stmt|;
operator|*
name|pcc
operator|=
name|cc
operator|->
name|next
expr_stmt|;
block|}
else|else
name|pcc
operator|=
operator|&
name|cc
operator|->
name|next
expr_stmt|;
block|}
block|}
name|fm_pair_set_free
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|dir
operator|->
name|msize
operator|--
expr_stmt|;
block|}
end_function

end_unit

