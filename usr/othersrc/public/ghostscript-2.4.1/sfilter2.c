begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* sfilter2.c */
end_comment

begin_comment
comment|/* Additional stream functions for filters */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"scanchar.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_comment
comment|/* Generic functions in sfilter.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|s_filter_flush
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|s_filter_close
argument_list|(
name|P1
argument_list|(
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ ASCII85Encode ------ */
end_comment

begin_comment
comment|/* Flush the buffer */
end_comment

begin_function
name|private
name|int
name|s_A85E_write_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
specifier|register
name|byte
modifier|*
name|p
init|=
name|s
operator|->
name|cbuf
decl_stmt|;
specifier|register
name|int
name|count
init|=
name|s
operator|->
name|cptr
operator|+
literal|1
operator|-
name|p
decl_stmt|;
while|while
condition|(
name|count
operator|>=
literal|4
condition|)
block|{
name|ulong
name|word
init|=
operator|(
call|(
name|ulong
call|)
argument_list|(
operator|(
operator|(
name|uint
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|p
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|p
index|[
literal|3
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
name|sputc
argument_list|(
name|strm
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
else|else
block|{
name|ulong
name|q
init|=
name|word
operator|/
operator|(
literal|85L
operator|*
literal|85
operator|*
literal|85
operator|*
literal|85
operator|)
decl_stmt|;
name|ushort
name|w1
decl_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|q
operator|+
literal|'!'
argument_list|)
expr_stmt|;
name|word
operator|-=
name|q
operator|*
operator|(
literal|85L
operator|*
literal|85
operator|*
literal|85
operator|*
literal|85
operator|)
expr_stmt|;
name|q
operator|=
name|word
operator|/
operator|(
literal|85L
operator|*
literal|85
operator|*
literal|85
operator|)
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|q
operator|+
literal|'!'
argument_list|)
expr_stmt|;
name|word
operator|-=
name|q
operator|*
operator|(
literal|85L
operator|*
literal|85
operator|*
literal|85
operator|)
expr_stmt|;
name|q
operator|=
name|word
operator|/
operator|(
literal|85
operator|*
literal|85
operator|)
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|q
operator|+
literal|'!'
argument_list|)
expr_stmt|;
name|w1
operator|=
call|(
name|ushort
call|)
argument_list|(
name|word
operator|-
name|q
operator|*
operator|(
literal|85L
operator|*
literal|85
operator|)
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|w1
operator|/
literal|85
operator|+
literal|'!'
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|w1
operator|%
literal|85
operator|+
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|count
operator|&
literal|60
operator|)
condition|)
name|sputc
argument_list|(
name|strm
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|count
operator|-=
literal|4
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|s
operator|->
name|cbuf
argument_list|,
name|p
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|+
name|count
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the stream, flushing a partial word. */
end_comment

begin_function
name|private
name|int
name|s_A85E_close
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
name|int
name|count
decl_stmt|;
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|write_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|count
operator|=
name|s
operator|->
name|cptr
operator|-
name|s
operator|->
name|cbuf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* Handle leftover bytes.  1<= count<= 3. */
comment|/* All the bytes are at the beginning of the buffer. */
name|byte
name|ebuf
index|[
literal|5
index|]
decl_stmt|;
name|stream
name|sst
decl_stmt|;
name|s
operator|->
name|cptr
index|[
literal|1
index|]
operator|=
name|s
operator|->
name|cptr
index|[
literal|2
index|]
operator|=
name|s
operator|->
name|cptr
index|[
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|+
literal|3
expr_stmt|;
name|swrite_string
argument_list|(
operator|&
name|sst
argument_list|,
name|ebuf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|s
operator|->
name|strm
operator|=
operator|&
name|sst
expr_stmt|;
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|write_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* force out final codes */
name|sputs
argument_list|(
name|strm
argument_list|,
name|ebuf
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|sputs
argument_list|(
name|strm
argument_list|,
operator|(
name|byte
operator|*
operator|)
literal|"~>"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|s_std_close
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_A85E_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_filter_flush
block|,
name|s_A85E_close
block|,
name|NULL
block|,
name|s_A85E_write_buf
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ ASCII85Decode ------ */
end_comment

begin_comment
comment|/* Refill the buffer */
end_comment

begin_function
name|private
name|int
name|s_A85D_read_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
specifier|register
name|byte
modifier|*
name|p
init|=
name|s
operator|->
name|cbuf
decl_stmt|;
name|byte
modifier|*
name|limit
init|=
name|p
operator|+
name|s
operator|->
name|bsize
operator|-
literal|4
decl_stmt|;
name|int
name|ccount
init|=
literal|0
decl_stmt|;
name|ulong
name|word
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|int
name|ch
init|=
name|sgetc
argument_list|(
name|strm
argument_list|)
decl_stmt|;
name|uint
name|ccode
init|=
name|ch
operator|-
literal|'!'
decl_stmt|;
if|if
condition|(
name|ccode
operator|<
literal|85
condition|)
comment|/* catches ch< '!' as well */
block|{
name|word
operator|=
name|word
operator|*
literal|85
operator|+
name|ccode
expr_stmt|;
if|if
condition|(
operator|++
name|ccount
operator|==
literal|5
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|word
operator|>>
literal|24
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|word
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|uint
operator|)
name|word
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|byte
operator|)
name|word
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
name|ccount
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'z'
operator|&&
name|ccount
operator|==
literal|0
condition|)
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|2
index|]
operator|=
name|p
index|[
literal|3
index|]
operator|=
literal|0
operator|,
name|p
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|scan_char_decoder
index|[
name|ch
index|]
operator|==
name|ctype_space
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'~'
operator|&&
name|sgetc
argument_list|(
name|strm
argument_list|)
operator|==
literal|'>'
condition|)
block|{
comment|/* Handle odd bytes */
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
switch|switch
condition|(
name|ccount
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
comment|/* syntax error */
name|s
operator|->
name|end_status
operator|=
name|ERRC
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1 odd byte */
name|word
operator|=
name|word
operator|*
operator|(
literal|85L
operator|+
literal|85
operator|*
literal|85
operator|)
operator|+
literal|0xffffffL
expr_stmt|;
goto|goto
name|o1
goto|;
case|case
literal|3
case|:
comment|/* 2 odd bytes */
name|word
operator|=
name|word
operator|*
operator|(
literal|85L
operator|*
literal|85
operator|)
operator|+
literal|0xffffL
expr_stmt|;
goto|goto
name|o2
goto|;
case|case
literal|4
case|:
comment|/* 3 odd bytes */
name|word
operator|=
name|word
operator|*
literal|85
operator|+
literal|0xffL
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|word
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|o2
label|:
name|p
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|word
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|o1
label|:
name|p
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|word
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ccount
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
else|else
comment|/* syntax error */
block|{
name|s
operator|->
name|end_status
operator|=
name|ERRC
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|p
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|end_status
condition|)
name|s
operator|->
name|end_status
operator|=
name|strm
operator|->
name|end_status
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_A85D_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_std_null
block|,
name|s_filter_close
block|,
name|s_A85D_read_buf
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ NullEncode ------ */
end_comment

begin_comment
comment|/* Flush the buffer */
end_comment

begin_function
name|private
name|int
name|s_NullE_write_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|sputs
argument_list|(
name|s
operator|->
name|strm
argument_list|,
name|s
operator|->
name|cbuf
argument_list|,
name|s
operator|->
name|cptr
operator|-
name|s
operator|->
name|cbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close the stream */
end_comment

begin_function
name|private
name|int
name|s_NullE_close
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|sflush
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s_filter_close
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_NullE_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_filter_flush
block|,
name|s_NullE_close
block|,
name|NULL
block|,
name|s_NullE_write_buf
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ RunLengthEncode ------ */
end_comment

begin_comment
comment|/* Initialize */
end_comment

begin_function
name|void
name|s_RLE_init
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|uint
name|rec_size
parameter_list|)
block|{
name|s
operator|->
name|record_size
operator|=
operator|(
name|rec_size
operator|==
literal|0
condition|?
name|max_uint
else|:
name|rec_size
operator|)
expr_stmt|;
name|s
operator|->
name|record_left
operator|=
name|s
operator|->
name|record_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Empty the buffer */
end_comment

begin_function
name|private
name|int
name|s_RLE_write_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
specifier|register
name|byte
modifier|*
name|p
init|=
name|s
operator|->
name|cbuf
decl_stmt|;
while|while
condition|(
name|p
operator|<=
name|s
operator|->
name|cptr
condition|)
block|{
name|byte
modifier|*
name|beg
init|=
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|uint
name|count
init|=
name|s
operator|->
name|cptr
operator|-
name|p
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|s
operator|->
name|record_left
condition|)
name|count
operator|=
name|s
operator|->
name|record_left
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|127
condition|)
name|count
operator|=
literal|127
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
block|{
comment|/* Recognize leading repeated byte */
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|+
literal|1
operator|<
name|q
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|p
index|[
literal|0
index|]
condition|)
do|;
name|p
operator|++
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
literal|257
operator|-
operator|(
name|p
operator|-
name|beg
operator|)
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
operator|*
name|beg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|p
operator|+
literal|2
operator|<
name|q
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|!=
name|p
index|[
literal|0
index|]
operator|||
name|p
index|[
literal|2
index|]
operator|!=
name|p
index|[
literal|0
index|]
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|2
operator|>=
name|q
condition|)
name|p
operator|=
name|q
expr_stmt|;
name|sputc
argument_list|(
name|strm
argument_list|,
name|p
operator|-
name|beg
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sputs
argument_list|(
name|strm
argument_list|,
name|beg
argument_list|,
name|p
operator|-
name|beg
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|record_left
operator|-=
name|p
operator|-
name|beg
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|record_left
operator|==
literal|0
condition|)
name|s
operator|->
name|record_left
operator|=
name|s
operator|->
name|record_size
expr_stmt|;
block|}
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Close */
end_comment

begin_function
name|private
name|int
name|s_RLE_close
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
call|(
modifier|*
name|s
operator|->
name|procs
operator|.
name|write_buf
call|)
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
operator|->
name|strm
argument_list|,
literal|128
argument_list|)
expr_stmt|;
return|return
name|s_std_close
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_RLE_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_filter_flush
block|,
name|s_RLE_close
block|,
name|NULL
block|,
name|s_RLE_write_buf
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ RunLengthDecode ------ */
end_comment

begin_comment
comment|/* Initialize */
end_comment

begin_function
name|void
name|s_RLD_init
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|odd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Refill the buffer */
end_comment

begin_function
name|private
name|int
name|s_RLD_read_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
specifier|register
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
specifier|register
name|byte
modifier|*
name|p
init|=
name|s
operator|->
name|cbuf
decl_stmt|;
name|byte
modifier|*
name|limit
init|=
name|p
operator|+
name|s
operator|->
name|bsize
decl_stmt|;
name|int
name|b
init|=
name|s
operator|->
name|odd
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
name|b
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint
name|count
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
break|break;
comment|/* EOF/ERR */
if|if
condition|(
name|b
operator|<
literal|128
condition|)
block|{
if|if
condition|(
name|p
operator|+
name|b
operator|>=
name|limit
condition|)
break|break;
comment|/* data won't fit */
name|count
operator|=
name|sgets
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
name|b
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|end_status
condition|)
break|break;
comment|/* EOF/ERR */
block|}
elseif|else
if|if
condition|(
name|b
operator|==
literal|128
condition|)
comment|/* end of data */
block|{
name|s
operator|->
name|end_status
operator|=
name|EOFC
expr_stmt|;
name|b
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|p
operator|+
operator|(
literal|257
operator|-
name|b
operator|)
operator|>
name|limit
condition|)
break|break;
comment|/* won't fit */
else|else
block|{
name|count
operator|=
literal|257
operator|-
name|b
expr_stmt|;
name|b
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
break|break;
comment|/* EOF/ERR */
name|memset
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
block|}
name|b
operator|=
name|sgetc
argument_list|(
name|strm
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|p
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|odd
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|end_status
condition|)
name|s
operator|->
name|end_status
operator|=
name|strm
operator|->
name|end_status
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_RLD_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_std_null
block|,
name|s_std_close
block|,
name|s_RLD_read_buf
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ SubFileDecode ------ */
end_comment

begin_comment
comment|/* Currently equivalent to "NullDecode" */
end_comment

begin_comment
comment|/* Refill the buffer */
end_comment

begin_function
name|private
name|int
name|s_SFD_read_buf
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
name|uint
name|count
init|=
name|sgets
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|cbuf
argument_list|,
name|s
operator|->
name|bsize
argument_list|)
decl_stmt|;
name|s
operator|->
name|cptr
operator|=
name|s
operator|->
name|cbuf
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|endptr
operator|=
name|s
operator|->
name|cptr
operator|+
name|count
expr_stmt|;
name|s
operator|->
name|end_status
operator|=
name|strm
operator|->
name|end_status
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Stream procedures */
end_comment

begin_decl_stmt
name|stream_procs
name|s_SFD_procs
init|=
block|{
name|s_std_noavailable
block|,
name|NULL
block|,
name|s_std_null
block|,
name|s_filter_close
block|,
name|s_SFD_read_buf
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

