begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gs.c */
end_comment

begin_comment
comment|/* Driver program for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_include
include|#
directive|include
file|"ostack.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|GS_LIB
end_ifndef

begin_define
define|#
directive|define
name|GS_LIB
value|"GS_LIB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PROGRAM_NAME
end_ifndef

begin_define
define|#
directive|define
name|PROGRAM_NAME
value|"Ghostscript"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Library routines not declared in a standard header */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
argument_list|(
name|P1
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exported data */
end_comment

begin_decl_stmt
name|uint
name|memory_chunk_size
init|=
literal|20000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name search paths */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|gs_lib_paths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|gs_lib_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|gs_lib_env_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configuration information imported from gconfig.c. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|gs_lib_default_path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|gs_init_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ref
name|gs_init_file_array
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device procedures imported from gsdevice.c. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|gx_device_s
name|gx_device
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|gx_device
modifier|*
name|gs_getdevice
argument_list|(
name|P1
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|gs_devicename
argument_list|(
name|P1
argument_list|(
name|gx_device
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Help string */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|gs_help1
init|=
literal|"\ Usage: gs [switches] [file1.ps file2.ps ...]\n\   or : gs [switches] [file1.ps ...] -- filen.ps arg1 arg2 ...\n\ The latter passes arg1 ... to the program in filen.ps.\n\ Available devices:\n   "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We have to break help2 up into two parts, because the Watcom compiler */
end_comment

begin_comment
comment|/* has a limit of 510 characters for a single token. */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|gs_help2a
init|=
literal|"\n\ Switches: (you can use # in place of =)\n\     -d<name>[=<token>]   define name as token, or null if no token given\n\     -g<width>x<height>   set width and height (`geometry') for device\n\     -I<prefix>           add prefix to search path\n\     -q                   `quiet' mode, suppress most messages\n\     -r<res>              set resolution for initial device\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|gs_help2b
init|=
literal|"\     -r<xres>x<yres>      set device X and Y resolution separately\n\     -s<name>=<string>    define name as string\n\     -sDEVICE=<devname>   select initial device\n\     -sOUTPUTFILE=<file>  select output file, embed %d for page #,\n\                            |command to pipe\n\ `-' alone as a file name means read from stdin non-interactively.\n\ For more information, please read the use.doc file.\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|esc_strlen
argument_list|(
name|P1
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|esc_strcat
argument_list|(
name|P2
argument_list|(
name|char
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|runarg
argument_list|(
name|P4
argument_list|(
name|char
operator|*
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|run_string
argument_list|(
name|P1
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|init1
argument_list|()
decl_stmt|,
name|init2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|private
name|void
name|set_lib_paths
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|void
name|run_file
argument_list|(
name|P2
argument_list|(
argument|const char *file_name
argument_list|,
argument|int user_errors
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|debug_dump_stack
argument_list|(
name|P1
argument_list|(
argument|int code
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parameters set by swproc */
end_comment

begin_decl_stmt
name|private
name|int
name|user_errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|batch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static versions of argc and argv (for -- only) */
end_comment

begin_decl_stmt
name|private
name|int
name|static_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
modifier|*
name|static_argv
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|num_files
decl_stmt|;
name|int
name|swproc
argument_list|(
name|P2
argument_list|(
name|char
operator|*
operator|*
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|void
name|argproc
argument_list|(
name|P2
argument_list|(
name|char
operator|*
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|static_argc
operator|=
name|argc
expr_stmt|;
name|static_argv
operator|=
name|argv
expr_stmt|;
comment|/* Do platform-dependent initialization. */
comment|/* We have to do this as the very first thing, */
comment|/* because it detects attempts to run 80N86 executables (N>0) */
comment|/* on incompatible processors. */
name|gp_init
argument_list|()
expr_stmt|;
comment|/* Initialize the file search paths */
name|gs_lib_env_path
operator|=
literal|0
expr_stmt|;
block|{
name|char
modifier|*
name|lib
init|=
name|getenv
argument_list|(
name|GS_LIB
argument_list|)
decl_stmt|;
if|if
condition|(
name|lib
operator|!=
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|lib
argument_list|)
decl_stmt|;
name|gs_lib_env_path
operator|=
name|gs_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"GS_LIB"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|gs_lib_env_path
argument_list|,
name|lib
argument_list|)
expr_stmt|;
block|}
block|}
name|gs_lib_paths
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|gs_malloc
argument_list|(
name|argc
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|"-I array"
argument_list|)
expr_stmt|;
name|gs_lib_count
operator|=
literal|0
expr_stmt|;
name|set_lib_paths
argument_list|()
expr_stmt|;
comment|/* Execute files named in the command line, */
comment|/* processing options along the way. */
comment|/* Wait until the first file name (or the end */
comment|/* of the line) to finish initialization. */
name|batch
operator|=
literal|0
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
name|user_errors
operator|=
literal|1
expr_stmt|;
name|num_files
operator|=
name|gs_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|swproc
argument_list|,
name|argproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_files
operator|==
literal|0
condition|)
block|{
name|init2
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|batch
condition|)
name|run_string
argument_list|(
literal|"start"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process switches */
end_comment

begin_function
name|int
name|swproc
parameter_list|(
name|char
modifier|*
modifier|*
name|swp
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|sw
init|=
operator|(
operator|*
name|swp
operator|)
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|sw
condition|)
block|{
default|default:
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* read stdin as a file */
name|batch
operator|=
literal|1
expr_stmt|;
comment|/* Set NOPAUSE so showpage won't try to read from stdin. */
block|{
name|char
modifier|*
name|d
init|=
literal|"-dNOPAUSE"
decl_stmt|;
name|swproc
argument_list|(
operator|&
name|d
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|init2
argument_list|()
expr_stmt|;
comment|/* Finish initialization */
name|run_string
argument_list|(
literal|"(%stdin) (r) file cvx execute"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* run with command line args */
case|case
literal|'+'
case|:
comment|/* ditto */
block|{
name|int
name|nstrs
init|=
name|static_argv
operator|+
name|static_argc
operator|-
operator|(
name|swp
operator|+
literal|2
operator|)
decl_stmt|;
if|if
condition|(
name|nstrs
operator|<
literal|0
condition|)
comment|/* no file to run! */
block|{
name|printf
argument_list|(
literal|"Usage: gs ... -- file.ps arg1 ... argn\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|runarg
argument_list|(
name|swp
operator|+
literal|1
argument_list|,
literal|"{userdict /ARGUMENTS ["
argument_list|,
literal|"] put ("
argument_list|,
name|nstrs
argument_list|)
expr_stmt|;
block|}
name|gs_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'h'
case|:
comment|/* print help */
case|case
literal|'?'
case|:
name|fputs
argument_list|(
name|gs_help1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|gx_device
modifier|*
name|pdev
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|pdev
operator|=
name|gs_getdevice
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|gs_devicename
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|gs_help2a
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|gs_help2b
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'I'
case|:
comment|/* specify search path */
name|gs_lib_paths
index|[
name|gs_lib_count
index|]
operator|=
name|arg
expr_stmt|;
name|gs_lib_count
operator|++
expr_stmt|;
name|set_lib_paths
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quiet startup */
block|{
name|ref
name|vnull
decl_stmt|;
name|quiet
operator|=
literal|1
expr_stmt|;
name|init1
argument_list|()
expr_stmt|;
name|make_null
argument_list|(
operator|&
name|vnull
argument_list|)
expr_stmt|;
name|initial_enter_name
argument_list|(
literal|"QUIET"
argument_list|,
operator|&
name|vnull
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
comment|/* define name */
case|case
literal|'d'
case|:
case|case
literal|'S'
case|:
comment|/* define name as string */
case|case
literal|'s'
case|:
block|{
name|char
modifier|*
name|eqp
init|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
name|int
name|isd
init|=
operator|(
name|sw
operator|==
literal|'D'
operator|||
name|sw
operator|==
literal|'d'
operator|)
decl_stmt|;
name|ref
name|value
decl_stmt|;
if|if
condition|(
name|eqp
operator|==
name|NULL
condition|)
name|eqp
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
comment|/* Initialize the object memory, scanner, and */
comment|/* name table now if needed. */
name|init1
argument_list|()
expr_stmt|;
if|if
condition|(
name|eqp
operator|==
name|arg
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: -dname, -dname=token, -sname=string\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eqp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|isd
condition|)
name|make_null
argument_list|(
operator|&
name|value
argument_list|)
expr_stmt|;
else|else
name|make_tasv
argument_list|(
operator|&
name|value
argument_list|,
name|t_string
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|code
decl_stmt|;
operator|*
name|eqp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* delimit name */
if|if
condition|(
name|isd
condition|)
block|{
name|stream
name|astream
decl_stmt|;
name|sread_string
argument_list|(
operator|&
name|astream
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|eqp
argument_list|,
name|strlen
argument_list|(
name|eqp
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|scan_token
argument_list|(
operator|&
name|astream
argument_list|,
literal|0
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
block|{
name|printf
argument_list|(
literal|"-dname= must be followed by a valid token\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|eqp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|gs_malloc
argument_list|(
operator|(
name|uint
operator|)
name|len
argument_list|,
literal|1
argument_list|,
literal|"-s"
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"Out of memory!\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|str
argument_list|,
name|eqp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
operator|&
name|value
argument_list|,
name|t_string
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
name|len
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enter the name in systemdict */
name|initial_enter_name
argument_list|(
name|arg
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'g'
case|:
comment|/* define device geometry */
block|{
name|long
name|width
decl_stmt|,
name|height
decl_stmt|;
name|ref
name|value
decl_stmt|;
name|init1
argument_list|()
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%ldx%ld"
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"-g must be followed by<width>x<height>\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|make_int
argument_list|(
operator|&
name|value
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|initial_enter_name
argument_list|(
literal|"DEVICEWIDTH"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
operator|&
name|value
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|initial_enter_name
argument_list|(
literal|"DEVICEHEIGHT"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'M'
case|:
comment|/* set memory allocation increment */
block|{
name|unsigned
name|msize
init|=
literal|0
decl_stmt|;
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|msize
operator|<=
literal|0
operator|||
name|msize
operator|>=
literal|64
condition|)
block|{
name|printf
argument_list|(
literal|"-M must be between 1 and 64\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memory_chunk_size
operator|=
name|msize
operator|<<
literal|10
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* define device resolution */
block|{
name|long
name|xres
decl_stmt|,
name|yres
decl_stmt|;
name|ref
name|value
decl_stmt|;
name|init1
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%ldx%ld"
argument_list|,
operator|&
name|xres
argument_list|,
operator|&
name|yres
argument_list|)
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"-r must be followed by<res> or<xres>x<yres>\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* -r<res> */
name|yres
operator|=
name|xres
expr_stmt|;
case|case
literal|2
case|:
comment|/* -r<xres>x<yres> */
name|make_int
argument_list|(
operator|&
name|value
argument_list|,
name|xres
argument_list|)
expr_stmt|;
name|initial_enter_name
argument_list|(
literal|"DEVICEXRESOLUTION"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
operator|&
name|value
argument_list|,
name|yres
argument_list|)
expr_stmt|;
name|initial_enter_name
argument_list|(
literal|"DEVICEYRESOLUTION"
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Define versions of strlen and strcat that insert \ escapes */
end_comment

begin_comment
comment|/* before \, (, and ). */
end_comment

begin_define
define|#
directive|define
name|needs_esc
parameter_list|(
name|ch
parameter_list|)
value|((ch) == '(' || (ch) == ')' || (ch) == '\\')
end_define

begin_function
name|private
name|int
name|esc_strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|n
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|str
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|needs_esc
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|private
name|void
name|esc_strcat
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|d
init|=
name|dest
operator|+
name|strlen
argument_list|(
name|dest
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|src
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|needs_esc
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process file names */
end_comment

begin_function
name|void
name|argproc
parameter_list|(
name|char
modifier|*
modifier|*
name|argp
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|runarg
argument_list|(
name|argp
argument_list|,
literal|"{"
argument_list|,
literal|"("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|runarg
parameter_list|(
name|char
modifier|*
modifier|*
name|argp
parameter_list|,
name|char
modifier|*
name|pre
parameter_list|,
name|char
modifier|*
name|post
parameter_list|,
name|int
name|nstrs
parameter_list|)
block|{
name|char
modifier|*
name|arg
init|=
operator|*
name|argp
decl_stmt|;
specifier|static
name|char
modifier|*
name|pex
init|=
literal|")run}execute"
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|pre
argument_list|)
operator|+
name|esc_strlen
argument_list|(
name|arg
argument_list|)
operator|+
name|strlen
argument_list|(
name|post
argument_list|)
operator|+
name|strlen
argument_list|(
name|pex
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nstrs
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|esc_strlen
argument_list|(
name|argp
index|[
name|i
index|]
argument_list|)
operator|+
literal|2
expr_stmt|;
name|init2
argument_list|()
expr_stmt|;
comment|/* Finish initialization */
name|line
operator|=
name|gs_malloc
argument_list|(
name|len
argument_list|,
literal|1
argument_list|,
literal|"argproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|lprintf
argument_list|(
literal|"Out of memory!\n"
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|pre
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nstrs
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|line
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|esc_strcat
argument_list|(
name|line
argument_list|,
name|argp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|line
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|line
argument_list|,
name|post
argument_list|)
expr_stmt|;
name|esc_strcat
argument_list|(
name|line
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|line
argument_list|,
name|pex
argument_list|)
expr_stmt|;
name|run_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|run_string
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|ref
name|stref
decl_stmt|;
name|make_tasv
argument_list|(
operator|&
name|stref
argument_list|,
name|t_string
argument_list|,
name|a_executable
operator|+
name|a_read
operator|+
name|a_execute
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|code
operator|=
name|gs_interpret
argument_list|(
operator|&
name|stref
argument_list|,
name|user_errors
argument_list|)
expr_stmt|;
name|zflush
argument_list|(
operator|(
name|ref
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* flush stdout */
name|zflushpage
argument_list|(
operator|(
name|ref
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* force display update */
if|if
condition|(
name|code
condition|)
name|debug_dump_stack
argument_list|(
name|code
argument_list|)
operator|,
name|gs_exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|int
name|init1_done
init|=
literal|0
decl_stmt|,
name|init2_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|init1
parameter_list|()
block|{
if|if
condition|(
operator|!
name|init1_done
condition|)
block|{
name|alloc_init
argument_list|(
name|gs_malloc
argument_list|,
name|gs_free
argument_list|,
name|memory_chunk_size
argument_list|)
expr_stmt|;
name|name_init
argument_list|()
expr_stmt|;
name|obj_init
argument_list|()
expr_stmt|;
comment|/* requires name_init */
name|scan_init
argument_list|()
expr_stmt|;
comment|/* ditto */
name|init1_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|init2
parameter_list|()
block|{
name|init1
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|init2_done
condition|)
block|{
name|gs_init
argument_list|()
expr_stmt|;
name|zop_init
argument_list|()
expr_stmt|;
name|interp_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* requires obj_init */
name|op_init
argument_list|()
expr_stmt|;
comment|/* requires obj_init, scan_init */
comment|/* Set up the array of additional initialization files. */
block|{
name|ref
modifier|*
name|ifp
init|=
name|gs_init_file_array
decl_stmt|;
name|ref
name|ifa
decl_stmt|;
for|for
control|(
init|;
name|ifp
operator|->
name|value
operator|.
name|bytes
operator|!=
literal|0
condition|;
name|ifp
operator|++
control|)
name|r_set_size
argument_list|(
name|ifp
argument_list|,
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ifp
operator|->
name|value
operator|.
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|make_tasv
argument_list|(
operator|&
name|ifa
argument_list|,
name|t_array
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
name|ifp
operator|-
name|gs_init_file_array
argument_list|,
name|refs
argument_list|,
name|gs_init_file_array
argument_list|)
expr_stmt|;
name|initial_enter_name
argument_list|(
literal|"INITFILES"
argument_list|,
operator|&
name|ifa
argument_list|)
expr_stmt|;
block|}
comment|/* Execute the standard initialization file. */
name|run_file
argument_list|(
name|gs_init_file
argument_list|,
name|user_errors
argument_list|)
expr_stmt|;
name|init2_done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Complete the list of library search paths. */
end_comment

begin_function
name|private
name|void
name|set_lib_paths
parameter_list|()
block|{
specifier|const
name|char
modifier|*
modifier|*
name|ppath
init|=
operator|&
name|gs_lib_paths
index|[
name|gs_lib_count
index|]
decl_stmt|;
if|if
condition|(
name|gs_lib_env_path
operator|!=
literal|0
condition|)
operator|*
name|ppath
operator|++
operator|=
name|gs_lib_env_path
expr_stmt|;
if|if
condition|(
name|gs_lib_default_path
operator|!=
literal|0
condition|)
operator|*
name|ppath
operator|++
operator|=
name|gs_lib_default_path
expr_stmt|;
operator|*
name|ppath
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open and execute a file */
end_comment

begin_function
name|private
name|int
name|run_open
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|ref
modifier|*
name|pfile
parameter_list|)
block|{
define|#
directive|define
name|maxfn
value|200
name|byte
name|fn
index|[
name|maxfn
index|]
decl_stmt|;
name|uint
name|len
decl_stmt|;
return|return
name|lib_file_open
argument_list|(
name|file_name
argument_list|,
name|strlen
argument_list|(
name|file_name
argument_list|)
argument_list|,
name|fn
argument_list|,
name|maxfn
argument_list|,
operator|&
name|len
argument_list|,
name|pfile
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|run_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|int
name|user_errors
parameter_list|)
block|{
name|ref
name|initial_file
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|run_open
argument_list|(
name|file_name
argument_list|,
operator|&
name|initial_file
argument_list|)
operator|<
literal|0
condition|)
block|{
name|eprintf1
argument_list|(
literal|"Can't find initialization file %s\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|r_set_attrs
argument_list|(
operator|&
name|initial_file
argument_list|,
name|a_execute
operator|+
name|a_executable
argument_list|)
expr_stmt|;
name|code
operator|=
name|gs_interpret
argument_list|(
operator|&
name|initial_file
argument_list|,
name|user_errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
name|debug_dump_stack
argument_list|(
name|code
argument_list|)
operator|,
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging code */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|debug_print_ref
argument_list|(
name|P1
argument_list|(
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|debug_dump_refs
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|uint
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ref
name|error_object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump the stacks after interpretation */
end_comment

begin_function
name|private
name|void
name|debug_dump_stack
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|zflush
argument_list|(
name|osp
argument_list|)
expr_stmt|;
comment|/* force out buffered output */
name|dprintf1
argument_list|(
literal|"\nUnexpected interpreter error %d!\nError object: "
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|debug_print_ref
argument_list|(
operator|&
name|error_object
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|debug_dump_refs
argument_list|(
name|osbot
argument_list|,
name|osp
operator|+
literal|1
operator|-
name|osbot
argument_list|,
literal|"Operand stack"
argument_list|)
expr_stmt|;
name|debug_dump_refs
argument_list|(
name|esbot
argument_list|,
name|esp
operator|+
literal|1
operator|-
name|esbot
argument_list|,
literal|"Execution stack"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

