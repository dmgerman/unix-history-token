begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zfileio.c */
end_comment

begin_comment
comment|/* File I/O operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_comment
comment|/* for gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|int
name|zreadline_from
argument_list|(
name|P4
argument_list|(
name|byte
operator|*
argument_list|,
name|uint
argument_list|,
name|uint
operator|*
argument_list|,
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|es_ptr
name|zget_current_file
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|write_string
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|stream
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Operators ------ */
end_comment

begin_comment
comment|/* read */
end_comment

begin_function
name|int
name|zread
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|check_read_file
argument_list|(
name|s
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ch
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOFC
condition|)
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|make_int
argument_list|(
name|op
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* write */
end_comment

begin_function
name|int
name|zwrite
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|ulong
name|ch
decl_stmt|;
name|check_write_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|ch
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|ch
operator|>
literal|0xff
condition|)
return|return
name|e_rangecheck
return|;
name|sputc
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|)
name|ch
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* readhexstring */
end_comment

begin_function
name|int
name|zreadhexstring
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
decl_stmt|;
name|uint
name|nread
decl_stmt|;
name|int
name|odd
init|=
operator|-
literal|1
decl_stmt|;
name|check_read_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|code
operator|=
name|sreadhex
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|,
operator|&
name|nread
argument_list|,
operator|&
name|odd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EOFC
case|:
comment|/* Reached end-of-file before filling the string. */
comment|/* Return an appropriate substring. */
name|r_set_size
argument_list|(
name|op
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|code
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Filled the string. */
break|break;
default|default:
comment|/* Error */
return|return
name|e_ioerror
return|;
block|}
name|ref_assign
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
operator|-
name|code
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* writehexstring */
end_comment

begin_function
name|int
name|zwritehexstring
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
specifier|register
name|stream
modifier|*
name|s
decl_stmt|;
specifier|register
name|byte
name|ch
decl_stmt|;
specifier|register
name|byte
modifier|*
name|p
decl_stmt|;
specifier|register
specifier|const
name|char
name|_ds
modifier|*
name|hex_digits
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|register
name|uint
name|len
decl_stmt|;
name|check_write_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|p
operator|=
name|op
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
name|len
operator|=
name|r_size
argument_list|(
name|op
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|ch
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|hex_digits
index|[
name|ch
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
name|s
argument_list|,
name|hex_digits
index|[
name|ch
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* readstring */
end_comment

begin_function
name|int
name|zreadstring
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|uint
name|len
decl_stmt|,
name|rlen
decl_stmt|;
name|check_read_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|len
operator|=
name|r_size
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|sgets
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|op
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|op
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
operator|(
name|rlen
operator|==
name|len
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* writestring */
end_comment

begin_function
name|int
name|zwritestring
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_write_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|write_string
argument_list|(
name|op
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* readline */
end_comment

begin_function
name|int
name|zreadline
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|uint
name|count
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_read_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_write_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|code
operator|=
name|zreadline_from
argument_list|(
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|,
operator|&
name|count
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|r_set_size
argument_list|(
name|op
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|op
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|op
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read a line from stdin.  This is called from gs.c. */
end_comment

begin_function
name|int
name|zreadline_stdin
parameter_list|(
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|size
parameter_list|,
name|uint
modifier|*
name|pcount
parameter_list|)
block|{
return|return
name|zreadline_from
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|pcount
argument_list|,
operator|&
name|std_files
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Internal readline routine. */
end_comment

begin_comment
comment|/* Returns 1 if OK, 0 if end of file, or an error code. */
end_comment

begin_function
name|int
name|zreadline_from
parameter_list|(
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|size
parameter_list|,
name|uint
modifier|*
name|pcount
parameter_list|,
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|uint
name|count
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
init|;
condition|;
name|count
operator|++
control|)
block|{
switch|switch
condition|(
name|ch
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
literal|'\r'
case|:
name|ch
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|>=
literal|0
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* falls through */
case|case
literal|'\n'
case|:
operator|*
name|pcount
operator|=
name|count
expr_stmt|;
return|return
literal|1
return|;
case|case
name|EOFC
case|:
operator|*
name|pcount
operator|=
name|count
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|count
operator|>=
name|size
condition|)
comment|/* filled the string */
block|{
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|e_rangecheck
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
name|ch
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* token - this is called from zstring.c */
end_comment

begin_function
name|int
name|ztoken_file
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|ref
name|token
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_read_file
argument_list|(
name|s
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
operator|=
name|scan_token
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* read a token */
operator|*
name|op
operator|=
name|token
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* no tokens */
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
comment|/* error */
return|return
name|code
return|;
block|}
block|}
end_function

begin_comment
comment|/* bytesavailable */
end_comment

begin_function
name|int
name|zbytesavailable
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|long
name|avail
decl_stmt|;
name|check_read_file
argument_list|(
name|s
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|savailable
argument_list|(
name|s
argument_list|,
operator|&
name|avail
argument_list|)
operator|<
literal|0
condition|)
return|return
name|e_ioerror
return|;
name|make_int
argument_list|(
name|op
argument_list|,
name|avail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* flush */
end_comment

begin_function
name|int
name|zflush
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|sflush
argument_list|(
operator|&
name|std_files
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* flushfile */
end_comment

begin_function
name|int
name|zflushfile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|check_file
argument_list|(
name|s
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|sflush
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s_is_writing
argument_list|(
name|s
argument_list|)
condition|)
name|fseek
argument_list|(
name|s
operator|->
name|file
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* set to end */
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* resetfile */
end_comment

begin_function
name|int
name|zresetfile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|NYI
argument_list|(
literal|"resetfile"
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* status */
end_comment

begin_function
name|int
name|zstatus
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|t_file
case|:
name|make_bool
argument_list|(
name|op
argument_list|,
operator|(
name|fptr
argument_list|(
name|op
argument_list|)
operator|->
name|bsize
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|t_string
case|:
block|{
name|char
modifier|*
name|fname
init|=
name|ref_to_string
argument_list|(
name|op
argument_list|,
literal|"status"
argument_list|)
decl_stmt|;
name|file_status
name|fstat
decl_stmt|;
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
if|if
condition|(
name|gp_file_status
argument_list|(
name|fname
argument_list|,
operator|&
name|fstat
argument_list|)
condition|)
block|{
name|push
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
operator|-
literal|4
argument_list|,
name|fstat
operator|.
name|size_pages
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
operator|-
literal|3
argument_list|,
name|fstat
operator|.
name|size_bytes
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
operator|-
literal|2
argument_list|,
name|fstat
operator|.
name|time_referenced
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|fstat
operator|.
name|time_created
argument_list|)
expr_stmt|;
name|make_bool
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|make_bool
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
name|fname
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"status"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
default|default:
return|return
name|e_typecheck
return|;
block|}
block|}
end_function

begin_comment
comment|/* currentfile */
end_comment

begin_function
name|int
name|zcurrentfile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|es_ptr
name|fp
decl_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Check the cache first */
if|if
condition|(
name|esfile
operator|!=
literal|0
condition|)
name|ref_assign
argument_list|(
name|op
argument_list|,
name|esfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|zget_current_file
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Return an invalid file object. */
comment|/* This doesn't make a lot of sense to me, */
comment|/* but it's what the PostScript manual specifies. */
name|make_file
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
operator|&
name|invalid_file_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref_assign
argument_list|(
name|op
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Load the cache */
name|esfile
operator|=
name|fp
expr_stmt|;
block|}
comment|/* Make the returned value literal. */
name|r_clear_attrs
argument_list|(
name|op
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* print */
end_comment

begin_function
name|int
name|zprint
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|write_string
argument_list|(
name|op
argument_list|,
operator|&
name|std_files
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* echo */
end_comment

begin_function
name|int
name|zecho
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
comment|/****** NOT IMPLEMENTED YET ******/
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Level 2 extensions ------ */
end_comment

begin_comment
comment|/* fileposition */
end_comment

begin_function
name|int
name|zfileposition
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|check_file
argument_list|(
name|s
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sseekable
argument_list|(
name|s
argument_list|)
condition|)
return|return
name|e_ioerror
return|;
name|make_int
argument_list|(
name|op
argument_list|,
name|stell
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setfileposition */
end_comment

begin_function
name|int
name|zsetfileposition
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|check_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sseek
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|<
literal|0
condition|)
return|return
name|e_ioerror
return|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Ghostscript extensions ------ */
end_comment

begin_comment
comment|/* unread */
end_comment

begin_function
name|int
name|zunread
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|ulong
name|ch
decl_stmt|;
name|check_read_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|ch
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
if|if
condition|(
name|ch
operator|>
literal|0xff
condition|)
return|return
name|e_rangecheck
return|;
if|if
condition|(
name|sungetc
argument_list|(
name|s
argument_list|,
operator|(
name|byte
operator|)
name|ch
argument_list|)
operator|<
literal|0
condition|)
return|return
name|e_ioerror
return|;
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* writeppmfile */
end_comment

begin_function
name|int
name|zwriteppmfile
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|stream
modifier|*
name|s
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_write_file
argument_list|(
name|s
argument_list|,
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gs_device_is_memory
argument_list|(
name|op
operator|->
name|value
operator|.
name|pdevice
argument_list|)
condition|)
return|return
name|e_typecheck
return|;
name|sflush
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|code
operator|=
name|gs_writeppmfile
argument_list|(
operator|(
name|gx_device_memory
operator|*
operator|)
operator|(
name|op
operator|->
name|value
operator|.
name|pdevice
operator|)
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zfileio_op_defs
index|[]
init|=
block|{
block|{
literal|"1bytesavailable"
block|,
name|zbytesavailable
block|}
block|,
block|{
literal|"0currentfile"
block|,
name|zcurrentfile
block|}
block|,
block|{
literal|"1echo"
block|,
name|zecho
block|}
block|,
block|{
literal|"1fileposition"
block|,
name|zfileposition
block|}
block|,
block|{
literal|"0flush"
block|,
name|zflush
block|}
block|,
block|{
literal|"1flushfile"
block|,
name|zflushfile
block|}
block|,
block|{
literal|"1print"
block|,
name|zprint
block|}
block|,
block|{
literal|"1read"
block|,
name|zread
block|}
block|,
block|{
literal|"2readhexstring"
block|,
name|zreadhexstring
block|}
block|,
block|{
literal|"2readline"
block|,
name|zreadline
block|}
block|,
block|{
literal|"2readstring"
block|,
name|zreadstring
block|}
block|,
block|{
literal|"1resetfile"
block|,
name|zresetfile
block|}
block|,
block|{
literal|"2setfileposition"
block|,
name|zsetfileposition
block|}
block|,
block|{
literal|"2unread"
block|,
name|zunread
block|}
block|,
block|{
literal|"1status"
block|,
name|zstatus
block|}
block|,
block|{
literal|"2write"
block|,
name|zwrite
block|}
block|,
block|{
literal|"2writehexstring"
block|,
name|zwritehexstring
block|}
block|,
block|{
literal|"2writeppmfile"
block|,
name|zwriteppmfile
block|}
block|,
block|{
literal|"2writestring"
block|,
name|zwritestring
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Non-operator routines ------ */
end_comment

begin_comment
comment|/* Check a file for reading. */
end_comment

begin_comment
comment|/* The interpreter calls this to check an executable file. */
end_comment

begin_function
name|int
name|file_check_read
parameter_list|(
name|ref
modifier|*
name|op
parameter_list|,
name|stream
modifier|*
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
operator|!
name|s_is_reading
argument_list|(
operator|*
name|ps
operator|=
name|fptr
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|e_invalidaccess
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the current file from which the interpreter is reading. */
end_comment

begin_function
name|es_ptr
name|zget_current_file
parameter_list|()
block|{
specifier|register
name|es_ptr
name|ep
init|=
name|esp
decl_stmt|;
while|while
condition|(
name|ep
operator|>=
name|esbot
condition|)
block|{
if|if
condition|(
name|r_has_type_attrs
argument_list|(
name|ep
argument_list|,
name|t_file
argument_list|,
name|a_executable
argument_list|)
condition|)
return|return
name|ep
return|;
name|ep
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|es_ptr
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Write a string on a file.  The file has been checked for validity, */
end_comment

begin_comment
comment|/* but not the string. */
end_comment

begin_function
name|private
name|int
name|write_string
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|uint
name|len
decl_stmt|;
name|check_read_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_string
argument_list|)
expr_stmt|;
name|len
operator|=
name|r_size
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|sputs
argument_list|(
name|s
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
return|return
name|e_ioerror
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

