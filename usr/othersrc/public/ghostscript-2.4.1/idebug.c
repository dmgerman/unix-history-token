begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* idebug.c */
end_comment

begin_comment
comment|/* Debugging support for Ghostscript interpreter */
end_comment

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"ostack.h"
end_include

begin_comment
comment|/* for opdef.h */
end_comment

begin_include
include|#
directive|include
file|"opdef.h"
end_include

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* for make_oper for opdef.h */
end_comment

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|void
name|debug_print_string
argument_list|(
name|P2
argument_list|(
specifier|const
name|byte
operator|*
argument_list|,
name|ushort
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|debug_print_name
parameter_list|(
name|pnref
parameter_list|)
define|\
value|debug_print_string((pnref)->value.pname->string_bytes,\ 		     (pnref)->value.pname->string_size)
end_define

begin_comment
comment|/* Table of type name strings */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|type_strings
index|[]
init|=
block|{
name|type_print_strings
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a ref */
end_comment

begin_decl_stmt
name|void
name|debug_print_ref
argument_list|(
name|P1
argument_list|(
specifier|const
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|debug_print_full_ref
parameter_list|(
specifier|const
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|unsigned
name|size
init|=
name|r_size
argument_list|(
name|pref
argument_list|)
decl_stmt|;
name|ref
name|nref
decl_stmt|;
name|dprintf1
argument_list|(
literal|"(%x)"
argument_list|,
name|r_type_attrs
argument_list|(
name|pref
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|pref
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
name|dprintf2
argument_list|(
literal|"array(%u)0x%lx"
argument_list|,
name|size
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|refs
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_boolean
case|:
name|dprintf1
argument_list|(
literal|"boolean %x"
argument_list|,
name|pref
operator|->
name|value
operator|.
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_color
case|:
name|dprintf1
argument_list|(
literal|"color 0x%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|pcolor
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_condition
case|:
name|dprintf1
argument_list|(
literal|"condition 0x%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|pcond
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_device
case|:
name|dprintf1
argument_list|(
literal|"device 0x%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|pdevice
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_dictionary
case|:
name|dprintf3
argument_list|(
literal|"dict(%u/%u)0x%lx"
argument_list|,
name|dict_length
argument_list|(
name|pref
argument_list|)
argument_list|,
name|dict_maxlength
argument_list|(
name|pref
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|pdict
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_file
case|:
name|dprintf1
argument_list|(
literal|"file 0x%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|pfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_gstate
case|:
name|dprintf1
argument_list|(
literal|"gstate 0x%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|pgstate
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|dprintf1
argument_list|(
literal|"int %ld"
argument_list|,
name|pref
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_lock
case|:
name|dprintf1
argument_list|(
literal|"lock 0x%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|plock
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_mark
case|:
name|dprintf
argument_list|(
literal|"mark"
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_mixedarray
case|:
name|dprintf2
argument_list|(
literal|"mixed packedarray(%u)0x%lx"
argument_list|,
name|size
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|packed
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_name
case|:
name|dprintf2
argument_list|(
literal|"name(0x%lx#%x)"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|pname
argument_list|,
name|pref
operator|->
name|value
operator|.
name|pname
operator|->
name|index
argument_list|)
expr_stmt|;
name|debug_print_name
argument_list|(
name|pref
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_null
case|:
name|dprintf
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_oparray
case|:
name|dprintf1
argument_list|(
literal|"op_array(0x%x)"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|name_index_ref
argument_list|(
name|op_array_nx_table
index|[
name|size
operator|-
name|op_def_count
index|]
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|debug_print_name
argument_list|(
operator|&
name|nref
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_operator
case|:
name|dprintf1
argument_list|(
literal|"op(0x%x"
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|dprintf1
argument_list|(
literal|":%s"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|op_def_table
index|[
name|size
index|]
operator|->
name|oname
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dprintf1
argument_list|(
literal|")0x%lx"
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|opproc
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_real
case|:
name|dprintf1
argument_list|(
literal|"real %f"
argument_list|,
name|pref
operator|->
name|value
operator|.
name|realval
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_shortarray
case|:
name|dprintf2
argument_list|(
literal|"short packedarray(%u)0x%lx"
argument_list|,
name|size
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|packed
argument_list|)
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|dprintf2
argument_list|(
literal|"string(%u)0x%lx"
argument_list|,
name|size
argument_list|,
operator|(
name|ulong
operator|)
name|pref
operator|->
name|value
operator|.
name|bytes
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dprintf1
argument_list|(
literal|"type 0x%x"
argument_list|,
name|r_type
argument_list|(
name|pref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|debug_print_packed_ref
parameter_list|(
specifier|const
name|ref_packed
modifier|*
name|pref
parameter_list|)
block|{
name|ushort
name|elt
init|=
operator|*
name|pref
decl_stmt|;
name|ref
name|nref
decl_stmt|;
switch|switch
condition|(
name|elt
operator|>>
name|packed_type_shift
condition|)
block|{
case|case
name|pt_executable_operator
case|:
name|dprintf
argument_list|(
literal|"<op_name>"
argument_list|)
expr_stmt|;
name|elt
operator|&=
name|packed_int_mask
expr_stmt|;
name|op_index_ref
argument_list|(
name|elt
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|debug_print_ref
argument_list|(
operator|&
name|nref
argument_list|)
expr_stmt|;
break|break;
case|case
name|pt_integer
case|:
name|dprintf1
argument_list|(
literal|"<int> %d"
argument_list|,
operator|(
name|elt
operator|&
name|packed_int_mask
operator|)
operator|+
name|packed_min_intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|pt_literal_name
case|:
case|case
name|pt_literal_name
operator|+
literal|1
case|:
name|dprintf
argument_list|(
literal|"<lit_name>"
argument_list|)
expr_stmt|;
name|elt
operator|&=
name|packed_max_name_index
expr_stmt|;
goto|goto
name|ptn
goto|;
case|case
name|pt_executable_name
case|:
case|case
name|pt_executable_name
operator|+
literal|1
case|:
name|dprintf
argument_list|(
literal|"<exec_name>"
argument_list|)
expr_stmt|;
name|elt
operator|&=
name|packed_max_name_index
expr_stmt|;
name|ptn
label|:
name|name_index_ref
argument_list|(
name|elt
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
name|dprintf2
argument_list|(
literal|"(0x%lx#%x)"
argument_list|,
operator|(
name|ulong
operator|)
name|nref
operator|.
name|value
operator|.
name|pname
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|debug_print_name
argument_list|(
operator|&
name|nref
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|debug_print_ref
parameter_list|(
specifier|const
name|ref
modifier|*
name|pref
parameter_list|)
block|{
if|if
condition|(
name|r_is_packed
argument_list|(
name|pref
argument_list|)
condition|)
name|debug_print_packed_ref
argument_list|(
operator|(
specifier|const
name|ref_packed
operator|*
operator|)
name|pref
argument_list|)
expr_stmt|;
else|else
name|debug_print_full_ref
argument_list|(
name|pref
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a string */
end_comment

begin_function
name|void
name|debug_print_string
parameter_list|(
specifier|const
name|byte
modifier|*
name|chrs
parameter_list|,
name|ushort
name|len
parameter_list|)
block|{
name|ushort
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|dputc
argument_list|(
name|chrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump one ref */
end_comment

begin_function
name|void
name|debug_dump_one_ref
parameter_list|(
specifier|const
name|ref
modifier|*
name|p
parameter_list|)
block|{
name|uint
name|attrs
init|=
name|r_type_attrs
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uint
name|btype
init|=
name|r_btype
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|as
init|=
name|attr_print_string
decl_stmt|;
specifier|const
name|char
modifier|*
name|ap
init|=
name|as
decl_stmt|;
define|#
directive|define
name|buf_size
value|30
name|char
name|buf
index|[
name|buf_size
operator|+
literal|1
index|]
decl_stmt|;
name|uint
name|plen
decl_stmt|;
if|if
condition|(
name|btype
operator|>=
name|t_next_index
condition|)
name|dprintf1
argument_list|(
literal|"0x%02x?? "
argument_list|,
name|btype
argument_list|)
expr_stmt|;
else|else
name|dprintf1
argument_list|(
literal|"%s "
argument_list|,
name|type_strings
index|[
name|btype
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|attrs
operator|>>=
literal|1
control|)
if|if
condition|(
operator|*
name|ap
operator|!=
literal|'.'
condition|)
name|dputc
argument_list|(
operator|(
operator|(
name|attrs
operator|&
literal|1
operator|)
condition|?
operator|*
name|ap
else|:
literal|'-'
operator|)
argument_list|)
expr_stmt|;
name|dprintf2
argument_list|(
literal|" 0x%04x 0x%08lx"
argument_list|,
name|r_size
argument_list|(
name|p
argument_list|)
argument_list|,
operator|*
operator|(
specifier|const
name|ulong
operator|*
operator|)
operator|&
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_cvs
argument_list|(
name|p
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|buf
argument_list|,
name|buf_size
argument_list|,
operator|&
name|plen
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|buf
index|[
name|plen
index|]
operator|=
literal|0
operator|)
operator|,
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"--nostringval--"
argument_list|)
operator|)
condition|)
name|dprintf1
argument_list|(
literal|" = %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump a region of memory containing refs */
end_comment

begin_function
name|void
name|debug_dump_refs
parameter_list|(
specifier|const
name|ref
modifier|*
name|from
parameter_list|,
name|uint
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|ref
modifier|*
name|p
init|=
name|from
decl_stmt|;
name|uint
name|count
init|=
name|size
decl_stmt|;
if|if
condition|(
name|size
operator|&&
name|msg
condition|)
name|dprintf2
argument_list|(
literal|"%s at 0x%lx:\n"
argument_list|,
name|msg
argument_list|,
operator|(
name|ulong
operator|)
name|from
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|dprintf2
argument_list|(
literal|"..%04x: 0x%02x "
argument_list|,
operator|(
name|uint
operator|)
name|p
operator|&
literal|0xffff
argument_list|,
name|r_type
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|debug_dump_one_ref
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump a region of memory */
end_comment

begin_function
name|void
name|debug_dump_bytes
parameter_list|(
specifier|const
name|byte
modifier|*
name|from
parameter_list|,
specifier|const
name|byte
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|byte
modifier|*
name|p
init|=
name|from
decl_stmt|;
if|if
condition|(
name|from
operator|<
name|to
operator|&&
name|msg
condition|)
name|dprintf1
argument_list|(
literal|"%s:\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|to
condition|)
block|{
specifier|const
name|byte
modifier|*
name|q
init|=
name|min
argument_list|(
name|p
operator|+
literal|16
argument_list|,
name|to
argument_list|)
decl_stmt|;
name|dprintf1
argument_list|(
literal|"%lx:"
argument_list|,
operator|(
name|ulong
operator|)
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|q
condition|)
name|dprintf1
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump an array. */
end_comment

begin_function
name|void
name|debug_dump_array
parameter_list|(
specifier|const
name|ref
modifier|*
name|array
parameter_list|)
block|{
specifier|const
name|ref_packed
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|int
name|type
init|=
name|r_type
argument_list|(
name|array
argument_list|)
decl_stmt|;
name|uint
name|len
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|dprintf2
argument_list|(
literal|"%s at 0x%lx isn't an array.\n"
argument_list|,
operator|(
name|type
operator|<
name|countof
argument_list|(
name|type_strings
argument_list|)
condition|?
name|type_strings
index|[
name|type
index|]
else|:
literal|"????"
operator|)
argument_list|,
operator|(
name|ulong
operator|)
name|array
argument_list|)
expr_stmt|;
return|return;
case|case
name|t_oparray
case|:
comment|/* This isn't really an array, but we'd like to see */
comment|/* its contents anyway. */
name|debug_dump_array
argument_list|(
name|op_array_table
operator|.
name|value
operator|.
name|refs
operator|+
name|op_index
argument_list|(
name|array
argument_list|)
operator|-
name|op_def_count
argument_list|)
expr_stmt|;
return|return;
case|case
name|t_array
case|:
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
empty_stmt|;
block|}
comment|/* This "packed" loop works for all array-types. */
for|for
control|(
name|len
operator|=
name|r_size
argument_list|(
name|array
argument_list|)
operator|,
name|pp
operator|=
name|array
operator|->
name|value
operator|.
name|packed
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|pp
operator|=
name|packed_next
argument_list|(
name|pp
argument_list|)
control|)
block|{
name|ref
name|temp
decl_stmt|;
name|packed_get
argument_list|(
name|pp
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|dprintf3
argument_list|(
literal|"..%04x%c 0x%02x "
argument_list|,
operator|(
name|uint
operator|)
name|pp
operator|&
literal|0xffff
argument_list|,
operator|(
operator|(
name|r_is_packed
argument_list|(
name|pp
argument_list|)
operator|)
condition|?
literal|'*'
else|:
literal|':'
operator|)
argument_list|,
name|r_type
argument_list|(
operator|&
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|debug_dump_one_ref
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

