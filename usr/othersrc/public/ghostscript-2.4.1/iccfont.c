begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* iccfont.c */
end_comment

begin_comment
comment|/* Initialization support for compiled fonts */
end_comment

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"ccfont.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_comment
comment|/* for alloc_refs */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|array_get
argument_list|(
name|P3
argument_list|(
specifier|const
name|ref
operator|*
argument_list|,
name|long
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ref
name|name_StandardEncoding
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check for reaching the end of the keys. */
end_comment

begin_define
define|#
directive|define
name|more_keys
parameter_list|(
name|kp
parameter_list|)
value|((kp)->num_enc_keys | (kp)->num_str_keys)
end_define

begin_comment
comment|/* Put the next entry into a dictionary. */
end_comment

begin_comment
comment|/* We know that more_keys(kp) is true. */
end_comment

begin_function
name|private
name|int
name|cfont_put_next
parameter_list|(
name|ref
modifier|*
name|pdict
parameter_list|,
name|cfont_dict_keys
name|_ss
modifier|*
name|kp
parameter_list|,
specifier|const
name|ref
modifier|*
name|pvalue
parameter_list|,
name|ref
modifier|*
name|_ss
modifier|*
name|pencodings
parameter_list|)
block|{
name|ref
name|kname
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|*
name|pencodings
operator|==
literal|0
condition|)
block|{
comment|/* Create the dictionary and look up the encodings. */
name|code
operator|=
name|dict_create
argument_list|(
name|kp
operator|->
name|num_enc_keys
operator|+
name|kp
operator|->
name|num_str_keys
operator|+
name|kp
operator|->
name|extra_slots
argument_list|,
name|pdict
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_tasv
argument_list|(
operator|&
name|kname
argument_list|,
name|t_string
argument_list|,
literal|0
argument_list|,
literal|17
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
literal|"ISOLatin1Encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict_find
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|name_StandardEncoding
argument_list|,
operator|&
name|pencodings
index|[
literal|0
index|]
argument_list|)
operator|<=
literal|0
operator|||
name|dict_find
argument_list|(
operator|&
name|systemdict
argument_list|,
operator|&
name|kname
argument_list|,
operator|&
name|pencodings
index|[
literal|1
index|]
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|e_undefined
return|;
block|}
if|if
condition|(
name|kp
operator|->
name|num_enc_keys
condition|)
block|{
name|charindex
name|_ds
modifier|*
name|skp
init|=
name|kp
operator|->
name|enc_keys
operator|++
decl_stmt|;
name|code
operator|=
name|array_get
argument_list|(
name|pencodings
index|[
name|skp
operator|->
name|encx
index|]
argument_list|,
call|(
name|long
call|)
argument_list|(
name|skp
operator|->
name|charx
argument_list|)
argument_list|,
operator|&
name|kname
argument_list|)
expr_stmt|;
name|kp
operator|->
name|num_enc_keys
operator|--
expr_stmt|;
block|}
else|else
comment|/* must have kp->num_str_keys != 0 */
block|{
specifier|const
name|char
modifier|*
name|skp
init|=
operator|*
operator|(
name|kp
operator|->
name|str_keys
operator|++
operator|)
decl_stmt|;
name|code
operator|=
name|name_ref
argument_list|(
operator|(
specifier|const
name|byte
operator|*
operator|)
name|skp
argument_list|,
name|strlen
argument_list|(
name|skp
argument_list|)
argument_list|,
operator|&
name|kname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kp
operator|->
name|num_str_keys
operator|--
expr_stmt|;
block|}
return|return
name|dict_put
argument_list|(
name|pdict
argument_list|,
operator|&
name|kname
argument_list|,
name|pvalue
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a dictionary with general ref values. */
end_comment

begin_function
name|int
name|cfont_ref_dict_create
parameter_list|(
name|ref
modifier|*
name|pdict
parameter_list|,
specifier|const
name|cfont_dict_keys
name|_ds
modifier|*
name|kp
parameter_list|,
specifier|const
name|ref
name|_ds
modifier|*
name|_ds
modifier|*
name|values
parameter_list|)
block|{
name|cfont_dict_keys
name|keys
decl_stmt|;
specifier|const
name|ref
name|_ds
modifier|*
name|_ds
modifier|*
name|vp
init|=
name|values
decl_stmt|;
name|ref
modifier|*
name|pencodings
index|[
literal|2
index|]
decl_stmt|;
name|keys
operator|=
operator|*
name|kp
expr_stmt|;
name|pencodings
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|more_keys
argument_list|(
operator|&
name|keys
argument_list|)
condition|)
block|{
specifier|const
name|ref
modifier|*
name|pvalue
init|=
operator|*
name|vp
operator|++
decl_stmt|;
name|ref
name|nref
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|r_has_type
argument_list|(
name|pvalue
argument_list|,
name|t_name
argument_list|)
condition|)
block|{
comment|/* The "name" is really a string. */
comment|/* Convert it to a real name now. */
name|code
operator|=
name|name_ref
argument_list|(
name|pvalue
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|pvalue
argument_list|)
argument_list|,
operator|&
name|nref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pvalue
operator|=
operator|&
name|nref
expr_stmt|;
block|}
name|code
operator|=
name|cfont_put_next
argument_list|(
name|pdict
argument_list|,
operator|&
name|keys
argument_list|,
name|pvalue
argument_list|,
name|pencodings
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a dictionary with string values. */
end_comment

begin_function
name|int
name|cfont_string_dict_create
parameter_list|(
name|ref
modifier|*
name|pdict
parameter_list|,
specifier|const
name|cfont_dict_keys
name|_ds
modifier|*
name|kp
parameter_list|,
specifier|const
name|charray
name|_ds
modifier|*
name|values
parameter_list|)
block|{
name|cfont_dict_keys
name|keys
decl_stmt|;
specifier|const
name|charray
name|_ds
modifier|*
name|vp
init|=
name|values
decl_stmt|;
name|uint
name|attrs
init|=
name|kp
operator|->
name|value_attrs
decl_stmt|;
name|ref
modifier|*
name|pencodings
index|[
literal|2
index|]
decl_stmt|;
name|ref
name|vstring
decl_stmt|;
name|keys
operator|=
operator|*
name|kp
expr_stmt|;
name|pencodings
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|more_keys
argument_list|(
operator|&
name|keys
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
name|make_tasv
argument_list|(
operator|&
name|vstring
argument_list|,
name|t_string
argument_list|,
name|attrs
argument_list|,
name|vp
operator|->
name|len
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|vp
operator|->
name|str
argument_list|)
expr_stmt|;
name|vp
operator|++
expr_stmt|;
name|code
operator|=
name|cfont_put_next
argument_list|(
name|pdict
argument_list|,
operator|&
name|keys
argument_list|,
operator|&
name|vstring
argument_list|,
name|pencodings
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a dictionary with number values. */
end_comment

begin_function
name|int
name|cfont_num_dict_create
parameter_list|(
name|ref
modifier|*
name|pdict
parameter_list|,
specifier|const
name|cfont_dict_keys
name|_ds
modifier|*
name|kp
parameter_list|,
specifier|const
name|float
name|_ds
modifier|*
name|values
parameter_list|)
block|{
name|cfont_dict_keys
name|keys
decl_stmt|;
specifier|const
name|float
name|_ds
modifier|*
name|vp
init|=
name|values
decl_stmt|;
name|ref
modifier|*
name|pencodings
index|[
literal|2
index|]
decl_stmt|;
name|ref
name|vnum
decl_stmt|;
name|keys
operator|=
operator|*
name|kp
expr_stmt|;
name|pencodings
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|more_keys
argument_list|(
operator|&
name|keys
argument_list|)
condition|)
block|{
name|float
name|val
init|=
operator|*
name|vp
operator|++
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
name|int
operator|)
name|val
condition|)
name|make_int
argument_list|(
operator|&
name|vnum
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|make_real
argument_list|(
operator|&
name|vnum
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|code
operator|=
name|cfont_put_next
argument_list|(
name|pdict
argument_list|,
operator|&
name|keys
argument_list|,
operator|&
name|vnum
argument_list|,
name|pencodings
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create an array with name values. */
end_comment

begin_function
name|int
name|cfont_name_array_create
parameter_list|(
name|ref
modifier|*
name|parray
parameter_list|,
specifier|const
name|char
name|_ds
modifier|*
name|_ds
modifier|*
name|str_list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|ref
modifier|*
name|aptr
init|=
name|alloc_refs
argument_list|(
name|size
argument_list|,
literal|"cfont_name_array_create"
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
name|_ds
modifier|*
name|_ds
modifier|*
name|pstr
init|=
name|str_list
decl_stmt|;
if|if
condition|(
name|aptr
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|make_tasv
argument_list|(
name|parray
argument_list|,
name|t_array
argument_list|,
name|a_read
operator|+
name|a_execute
argument_list|,
name|size
argument_list|,
name|refs
argument_list|,
name|aptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|aptr
operator|++
operator|,
name|pstr
operator|++
control|)
block|{
name|ref
name|nref
decl_stmt|;
name|int
name|code
init|=
name|name_ref
argument_list|(
operator|(
name|byte
operator|*
operator|)
operator|*
name|pstr
argument_list|,
name|strlen
argument_list|(
operator|*
name|pstr
argument_list|)
argument_list|,
operator|&
name|nref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|ref_assign_new
argument_list|(
name|aptr
argument_list|,
operator|&
name|nref
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

