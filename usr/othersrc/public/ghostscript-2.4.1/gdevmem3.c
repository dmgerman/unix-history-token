begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevmem3.c */
end_comment

begin_comment
comment|/* 2- and 4-bit-per-pixel "memory" (stored bitmap) devices */
end_comment

begin_comment
comment|/* for Ghostscript library. */
end_comment

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gs.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_comment
comment|/* semi-public definitions */
end_comment

begin_include
include|#
directive|include
file|"gdevmem.h"
end_include

begin_comment
comment|/* private definitions */
end_comment

begin_comment
comment|/* The current implementations are quite inefficient. */
end_comment

begin_comment
comment|/* We intend to improve them someday.... */
end_comment

begin_comment
comment|/* ------ Generic procedures ------ */
end_comment

begin_comment
comment|/* We do everything byte-by-byte. */
end_comment

begin_define
define|#
directive|define
name|chunk
value|byte
end_define

begin_comment
comment|/* Import the monobit device from gdevmem1 */
end_comment

begin_comment
comment|/* so we can use its procedures. */
end_comment

begin_decl_stmt
specifier|extern
name|gx_device_memory
name|mem_mono_device
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Import the color mapping procedures from gdevmem2. */
end_comment

begin_extern
extern|extern dev_proc_map_rgb_color(mem_mapped_map_rgb_color
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern dev_proc_map_color_rgb(mem_mapped_map_color_rgb
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Implement fill_rectangle by tiling. */
end_comment

begin_function
name|private
name|int
name|fill_2or4_by_tiling
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|scaled_x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|scaled_w
parameter_list|,
name|int
name|h
parameter_list|,
name|ulong
modifier|*
name|ppattern
parameter_list|)
block|{
name|gx_bitmap
name|tile
decl_stmt|;
name|tile
operator|.
name|data
operator|=
operator|(
name|byte
operator|*
operator|)
name|ppattern
expr_stmt|;
name|tile
operator|.
name|raster
operator|=
sizeof|sizeof
argument_list|(
name|ulong
argument_list|)
expr_stmt|;
name|tile
operator|.
name|size
operator|.
name|x
operator|=
sizeof|sizeof
argument_list|(
name|ulong
argument_list|)
operator|*
literal|8
operator|,
name|tile
operator|.
name|size
operator|.
name|y
operator|=
literal|1
expr_stmt|;
name|tile
operator|.
name|id
operator|=
name|gx_no_bitmap_id
expr_stmt|;
name|tile
operator|.
name|rep_width
operator|=
literal|1
operator|,
name|tile
operator|.
name|rep_height
operator|=
literal|1
expr_stmt|;
return|return
call|(
modifier|*
name|mem_mono_device
operator|.
name|procs
operator|->
name|tile_rectangle
call|)
argument_list|(
name|dev
argument_list|,
operator|&
name|tile
argument_list|,
name|scaled_x
argument_list|,
name|y
argument_list|,
name|scaled_w
argument_list|,
name|h
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|0
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Mapped 2-bit color ------ */
end_comment

begin_comment
comment|/* Procedures */
end_comment

begin_expr_stmt
name|declare_mem_procs
argument_list|(
name|mem_mapped2_copy_mono
argument_list|,
name|mem_mapped2_copy_color
argument_list|,
name|mem_mapped2_fill_rectangle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The device descriptor. */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|mem_mapped2_procs
init|=
name|mem_procs
argument_list|(
name|mem_mapped_map_rgb_color
argument_list|,
name|mem_mapped_map_color_rgb
argument_list|,
name|mem_mapped2_copy_mono
argument_list|,
name|mem_mapped2_copy_color
argument_list|,
name|mem_mapped2_fill_rectangle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The instance is public. */
end_comment

begin_decl_stmt
name|gx_device_memory
name|mem_mapped2_color_device
init|=
name|mem_device
argument_list|(
literal|"image(2)"
argument_list|,
literal|2
argument_list|,
name|mem_mapped2_procs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert x coordinate to byte offset in scan line. */
end_comment

begin_undef
undef|#
directive|undef
name|x_to_byte
end_undef

begin_define
define|#
directive|define
name|x_to_byte
parameter_list|(
name|x
parameter_list|)
value|((x)>> 2)
end_define

begin_comment
comment|/* Fill a rectangle with a color. */
end_comment

begin_function
name|private
name|int
name|mem_mapped2_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
comment|/* Patch the width in the device temporarily. */
name|dev
operator|->
name|width
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|color
operator|==
literal|0
operator|||
name|color
operator|==
literal|3
condition|)
block|{
comment|/* Use monobit fill_rectangle. */
name|code
operator|=
call|(
modifier|*
name|mem_mono_device
operator|.
name|procs
operator|->
name|fill_rectangle
call|)
argument_list|(
name|dev
argument_list|,
name|x
operator|<<
literal|1
argument_list|,
name|y
argument_list|,
name|w
operator|<<
literal|1
argument_list|,
name|h
argument_list|,
name|color
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use monobit tile_rectangle. */
specifier|static
name|ulong
name|tile_patterns
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0x55555555
block|,
literal|0xaaaaaaaa
block|,
literal|0xffffffff
block|}
decl_stmt|;
name|code
operator|=
name|fill_2or4_by_tiling
argument_list|(
name|dev
argument_list|,
name|x
operator|<<
literal|1
argument_list|,
name|y
argument_list|,
name|w
operator|<<
literal|1
argument_list|,
name|h
argument_list|,
operator|&
name|tile_patterns
index|[
name|color
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the correct width. */
name|dev
operator|->
name|width
operator|>>=
literal|1
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Copy a bitmap. */
end_comment

begin_function
name|private
name|int
name|mem_mapped2_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|sraster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|)
block|{
name|byte
modifier|*
name|line
decl_stmt|;
name|int
name|first_bit
decl_stmt|;
name|byte
name|first_mask
decl_stmt|,
name|b0
decl_stmt|,
name|b1
decl_stmt|;
specifier|static
name|byte
name|btab
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xff
block|}
decl_stmt|;
specifier|static
name|byte
name|bmask
index|[
literal|4
index|]
init|=
block|{
literal|0xc0
block|,
literal|0x30
block|,
literal|0xc
block|,
literal|3
block|}
decl_stmt|;
name|declare_scan_ptr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
name|setup_rect
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|line
operator|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|3
operator|)
expr_stmt|;
name|first_bit
operator|=
literal|0x80
operator|>>
operator|(
name|sourcex
operator|&
literal|7
operator|)
expr_stmt|;
name|first_mask
operator|=
name|bmask
index|[
name|x
operator|&
literal|3
index|]
expr_stmt|;
name|b0
operator|=
name|btab
index|[
name|zero
operator|&
literal|3
index|]
expr_stmt|;
name|b1
operator|=
name|btab
index|[
name|one
operator|&
literal|3
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
specifier|register
name|byte
modifier|*
name|pptr
init|=
operator|(
name|byte
operator|*
operator|)
name|dest
decl_stmt|;
name|byte
modifier|*
name|sptr
init|=
name|line
decl_stmt|;
specifier|register
name|int
name|sbyte
init|=
operator|*
name|sptr
operator|++
decl_stmt|;
specifier|register
name|int
name|bit
init|=
name|first_bit
decl_stmt|;
specifier|register
name|byte
name|mask
init|=
name|first_mask
decl_stmt|;
name|int
name|count
init|=
name|w
decl_stmt|;
do|do
block|{
if|if
condition|(
name|sbyte
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|one
operator|!=
name|gx_no_color_index
condition|)
operator|*
name|pptr
operator|=
operator|(
operator|*
name|pptr
operator|&
operator|~
name|mask
operator|)
operator|+
operator|(
name|b1
operator|&
name|mask
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zero
operator|!=
name|gx_no_color_index
condition|)
operator|*
name|pptr
operator|=
operator|(
operator|*
name|pptr
operator|&
operator|~
name|mask
operator|)
operator|+
operator|(
name|b0
operator|&
name|mask
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bit
operator|>>=
literal|1
operator|)
operator|==
literal|0
condition|)
name|bit
operator|=
literal|0x80
operator|,
name|sbyte
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|6
operator|)
operator|+
operator|(
name|mask
operator|>>
literal|2
operator|)
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
name|line
operator|+=
name|sraster
expr_stmt|;
name|inc_chunk_ptr
argument_list|(
name|dest
argument_list|,
name|draster
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a color bitmap. */
end_comment

begin_function
name|private
name|int
name|mem_mapped2_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|sraster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
comment|/* Use monobit copy_mono. */
comment|/* Patch the width in the device temporarily. */
name|dev
operator|->
name|width
operator|<<=
literal|1
expr_stmt|;
name|code
operator|=
call|(
modifier|*
name|mem_mono_device
operator|.
name|procs
operator|->
name|copy_mono
call|)
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|sourcex
operator|<<
literal|1
argument_list|,
name|sraster
argument_list|,
name|id
argument_list|,
name|x
operator|<<
literal|1
argument_list|,
name|y
argument_list|,
name|w
operator|<<
literal|1
argument_list|,
name|h
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|0
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Restore the correct width. */
name|dev
operator|->
name|width
operator|>>=
literal|1
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Mapped 4-bit color ------ */
end_comment

begin_comment
comment|/* Procedures */
end_comment

begin_expr_stmt
name|declare_mem_procs
argument_list|(
name|mem_mapped4_copy_mono
argument_list|,
name|mem_mapped4_copy_color
argument_list|,
name|mem_mapped4_fill_rectangle
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The device descriptor. */
end_comment

begin_decl_stmt
name|private
name|gx_device_procs
name|mem_mapped4_procs
init|=
name|mem_procs
argument_list|(
name|mem_mapped_map_rgb_color
argument_list|,
name|mem_mapped_map_color_rgb
argument_list|,
name|mem_mapped4_copy_mono
argument_list|,
name|mem_mapped4_copy_color
argument_list|,
name|mem_mapped4_fill_rectangle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The instance is public. */
end_comment

begin_decl_stmt
name|gx_device_memory
name|mem_mapped4_color_device
init|=
name|mem_device
argument_list|(
literal|"image(4)"
argument_list|,
literal|4
argument_list|,
name|mem_mapped4_procs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert x coordinate to byte offset in scan line. */
end_comment

begin_undef
undef|#
directive|undef
name|x_to_byte
end_undef

begin_define
define|#
directive|define
name|x_to_byte
parameter_list|(
name|x
parameter_list|)
value|((x)>> 1)
end_define

begin_comment
comment|/* Fill a rectangle with a color. */
end_comment

begin_function
name|private
name|int
name|mem_mapped4_fill_rectangle
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|color
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
comment|/* Patch the width in the device temporarily. */
name|dev
operator|->
name|width
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|color
operator|==
literal|0
operator|||
name|color
operator|==
literal|15
condition|)
block|{
comment|/* Use monobit fill_rectangle. */
name|code
operator|=
call|(
modifier|*
name|mem_mono_device
operator|.
name|procs
operator|->
name|fill_rectangle
call|)
argument_list|(
name|dev
argument_list|,
name|x
operator|<<
literal|2
argument_list|,
name|y
argument_list|,
name|w
operator|<<
literal|2
argument_list|,
name|h
argument_list|,
name|color
operator|&
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use monobit tile_rectangle. */
specifier|static
name|ulong
name|tile_patterns
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0x11111111
block|,
literal|0x22222222
block|,
literal|0x33333333
block|,
literal|0x44444444
block|,
literal|0x55555555
block|,
literal|0x66666666
block|,
literal|0x77777777
block|,
literal|0x88888888
block|,
literal|0x99999999
block|,
literal|0xaaaaaaaa
block|,
literal|0xbbbbbbbb
block|,
literal|0xcccccccc
block|,
literal|0xdddddddd
block|,
literal|0xeeeeeeee
block|,
literal|0xffffffff
block|}
decl_stmt|;
name|code
operator|=
name|fill_2or4_by_tiling
argument_list|(
name|dev
argument_list|,
name|x
operator|<<
literal|2
argument_list|,
name|y
argument_list|,
name|w
operator|<<
literal|2
argument_list|,
name|h
argument_list|,
operator|&
name|tile_patterns
index|[
name|color
index|]
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|width
operator|>>=
literal|2
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Copy a bitmap. */
end_comment

begin_function
name|private
name|int
name|mem_mapped4_copy_mono
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|sraster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|gx_color_index
name|zero
parameter_list|,
name|gx_color_index
name|one
parameter_list|)
block|{
name|byte
modifier|*
name|line
decl_stmt|;
name|int
name|first_bit
decl_stmt|;
name|byte
name|first_mask
decl_stmt|,
name|b0
decl_stmt|,
name|b1
decl_stmt|;
name|declare_scan_ptr
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
name|setup_rect
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|line
operator|=
name|base
operator|+
operator|(
name|sourcex
operator|>>
literal|3
operator|)
expr_stmt|;
name|first_bit
operator|=
literal|0x80
operator|>>
operator|(
name|sourcex
operator|&
literal|7
operator|)
expr_stmt|;
name|first_mask
operator|=
operator|(
name|x
operator|&
literal|1
condition|?
literal|0xf
else|:
literal|0xf0
operator|)
expr_stmt|;
name|b0
operator|=
operator|(
operator|(
name|byte
operator|)
name|zero
operator|<<
literal|4
operator|)
operator|+
operator|(
name|byte
operator|)
name|zero
expr_stmt|;
name|b1
operator|=
operator|(
operator|(
name|byte
operator|)
name|one
operator|<<
literal|4
operator|)
operator|+
operator|(
name|byte
operator|)
name|one
expr_stmt|;
while|while
condition|(
name|h
operator|--
operator|>
literal|0
condition|)
block|{
specifier|register
name|byte
modifier|*
name|pptr
init|=
operator|(
name|byte
operator|*
operator|)
name|dest
decl_stmt|;
name|byte
modifier|*
name|sptr
init|=
name|line
decl_stmt|;
specifier|register
name|int
name|sbyte
init|=
operator|*
name|sptr
operator|++
decl_stmt|;
specifier|register
name|int
name|bit
init|=
name|first_bit
decl_stmt|;
specifier|register
name|byte
name|mask
init|=
name|first_mask
decl_stmt|;
name|int
name|count
init|=
name|w
decl_stmt|;
do|do
block|{
if|if
condition|(
name|sbyte
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|one
operator|!=
name|gx_no_color_index
condition|)
operator|*
name|pptr
operator|=
operator|(
operator|*
name|pptr
operator|&
operator|~
name|mask
operator|)
operator|+
operator|(
name|b1
operator|&
name|mask
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zero
operator|!=
name|gx_no_color_index
condition|)
operator|*
name|pptr
operator|=
operator|(
operator|*
name|pptr
operator|&
operator|~
name|mask
operator|)
operator|+
operator|(
name|b0
operator|&
name|mask
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bit
operator|>>=
literal|1
operator|)
operator|==
literal|0
condition|)
name|bit
operator|=
literal|0x80
operator|,
name|sbyte
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
name|pptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
do|;
name|line
operator|+=
name|sraster
expr_stmt|;
name|inc_chunk_ptr
argument_list|(
name|dest
argument_list|,
name|draster
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy a color bitmap. */
end_comment

begin_function
name|private
name|int
name|mem_mapped4_copy_color
parameter_list|(
name|gx_device
modifier|*
name|dev
parameter_list|,
name|byte
modifier|*
name|base
parameter_list|,
name|int
name|sourcex
parameter_list|,
name|int
name|sraster
parameter_list|,
name|gx_bitmap_id
name|id
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_rect
argument_list|()
expr_stmt|;
comment|/* Use monobit copy_mono. */
comment|/* Patch the width in the device temporarily. */
name|dev
operator|->
name|width
operator|<<=
literal|2
expr_stmt|;
name|code
operator|=
call|(
modifier|*
name|mem_mono_device
operator|.
name|procs
operator|->
name|copy_mono
call|)
argument_list|(
name|dev
argument_list|,
name|base
argument_list|,
name|sourcex
operator|<<
literal|2
argument_list|,
name|sraster
argument_list|,
name|id
argument_list|,
name|x
operator|<<
literal|2
argument_list|,
name|y
argument_list|,
name|w
operator|<<
literal|2
argument_list|,
name|h
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|0
argument_list|,
operator|(
name|gx_color_index
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Restore the correct width. */
name|dev
operator|->
name|width
operator|>>=
literal|2
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

end_unit

