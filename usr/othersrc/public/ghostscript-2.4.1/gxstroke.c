begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxstroke.c */
end_comment

begin_comment
comment|/* Path stroking procedures for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxarith.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_comment
comment|/* requires gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gzline.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_comment
comment|/* stroke_add uses the following global for its path: */
end_comment

begin_decl_stmt
name|private
name|gx_path
name|stroke_path_body
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|gx_path
modifier|*
name|stroke_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure for a partial line (passed to the drawing routine).  * Two of these are required to do joins right.  * Each endpoint includes the two ends of the cap as well,  * and the deltas for square and round cap computation.  *  * The deltas (co, cdelta, ce) are in clockwise order in device space  * around the endpoint p: they are one-half the line width (suitably  * transformed) at 90 degrees counter-clockwise, straight ahead,  * and 90 degrees clockwise from the oriented line o->e,  * where "90 degrees" is measured in *user* coordinates.  * Note that the values at o are the negatives of the values at e.  *  * Initially, only o.p, e.p, o.cdelta, width, and thin are set.  * compute_caps fills in the rest when needed.  */
end_comment

begin_typedef
typedef|typedef
name|gs_fixed_point
name|_ss
modifier|*
name|p_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|endpoint_s
block|{
name|gs_fixed_point
name|p
decl_stmt|;
comment|/* the end of the line */
name|gs_fixed_point
name|co
decl_stmt|,
name|ce
decl_stmt|;
comment|/* ends of the cap, p +/- width */
name|gs_fixed_point
name|cdelta
decl_stmt|;
comment|/* +/- cap length */
block|}
name|endpoint
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|endpoint
name|_ss
modifier|*
name|ep_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|partial_line_s
block|{
name|endpoint
name|o
decl_stmt|;
comment|/* starting coordinate */
name|endpoint
name|e
decl_stmt|;
comment|/* ending coordinate */
name|gs_fixed_point
name|width
decl_stmt|;
comment|/* one-half line width, see above */
name|int
name|thin
decl_stmt|;
comment|/* true if minimum-width line */
block|}
name|partial_line
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|partial_line
name|_ss
modifier|*
name|pl_ptr
typedef|;
end_typedef

begin_comment
comment|/* Procedures that stroke a partial_line (the first argument). */
end_comment

begin_comment
comment|/* If both partial_lines are non-null, the procedure creates */
end_comment

begin_comment
comment|/* an appropriate join; otherwise, the procedure creates an */
end_comment

begin_comment
comment|/* end cap.  If the first int is 0, the procedure also starts with */
end_comment

begin_comment
comment|/* an appropriate cap. */
end_comment

begin_decl_stmt
name|private
name|int
name|stroke_add
argument_list|(
name|P4
argument_list|(
name|int
argument_list|,
name|pl_ptr
argument_list|,
name|pl_ptr
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|stroke_fill
argument_list|(
name|P4
argument_list|(
name|int
argument_list|,
name|pl_ptr
argument_list|,
name|pl_ptr
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other forward declarations */
end_comment

begin_decl_stmt
name|private
name|int
name|stroke
argument_list|(
name|P3
argument_list|(
name|gx_path
operator|*
argument_list|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P4
argument_list|(
name|int
argument_list|,
name|pl_ptr
argument_list|,
name|pl_ptr
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|expand_dashes
argument_list|(
name|P3
argument_list|(
name|subpath
operator|*
argument_list|,
name|gx_path
operator|*
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|compute_caps
argument_list|(
name|P1
argument_list|(
name|pl_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|add_capped
argument_list|(
name|P4
argument_list|(
name|gx_path
operator|*
argument_list|,
name|gs_line_cap
argument_list|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P3
argument_list|(
name|gx_path
operator|*
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
argument_list|,
name|ep_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stroke a path for drawing or saving */
end_comment

begin_function
name|int
name|gx_stroke_fill
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|stroke_path
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|stroke
argument_list|(
name|ppath
argument_list|,
name|stroke_fill
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stroke_path
condition|)
comment|/* set if filling needed */
block|{
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_fill_path
argument_list|(
name|stroke_path
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|,
name|gx_rule_winding_number
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
expr_stmt|;
name|gx_path_release
argument_list|(
name|stroke_path
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_function
name|int
name|gx_stroke_add
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gx_path
modifier|*
name|topath
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|stroke_path
operator|=
name|topath
expr_stmt|;
return|return
name|stroke
argument_list|(
name|ppath
argument_list|,
name|stroke_add
argument_list|,
name|pgs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stroke a path.  Call line_proc (stroke_add or stroke_fill) */
end_comment

begin_comment
comment|/* for each line segment. */
end_comment

begin_decl_stmt
name|private
name|int
name|stroke
argument_list|(
name|gx_path
operator|*
name|ppath
argument_list|,
name|int
argument_list|(
operator|*
name|line_proc
argument_list|)
argument_list|(
name|P4
argument_list|(
name|int
argument_list|,
name|pl_ptr
argument_list|,
name|pl_ptr
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
argument_list|,
name|gs_state
operator|*
name|pgs
argument_list|)
block|{
name|subpath
modifier|*
name|psub
decl_stmt|;
name|subpath
modifier|*
name|save_psub
init|=
literal|0
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
name|line_params
modifier|*
name|lp
init|=
name|pgs
operator|->
name|line_params
decl_stmt|;
name|int
name|dash_count
init|=
name|lp
operator|->
name|dash
operator|.
name|pattern_size
decl_stmt|;
name|gx_path
name|fpath
decl_stmt|,
name|dpath
decl_stmt|;
name|float
name|xx
init|=
name|pgs
operator|->
name|ctm
operator|.
name|xx
decl_stmt|,
name|xy
init|=
name|pgs
operator|->
name|ctm
operator|.
name|xy
decl_stmt|;
name|float
name|yx
init|=
name|pgs
operator|->
name|ctm
operator|.
name|yx
decl_stmt|,
name|yy
init|=
name|pgs
operator|->
name|ctm
operator|.
name|yy
decl_stmt|;
name|int
name|skewed
init|=
operator|!
name|is_fzero2
argument_list|(
name|xy
argument_list|,
name|yx
argument_list|)
decl_stmt|;
name|int
name|uniform
init|=
operator|(
name|skewed
condition|?
literal|0
else|:
name|xx
operator|==
name|yy
condition|?
literal|1
else|:
name|xx
operator|==
operator|-
name|yy
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
comment|/* 	 * We are dealing with a reflected coordinate system 	 * if (1,0) is counter-clockwise from (0,1). 	 * See the note in stroke_add for the algorithm. 	 */
name|int
name|reflected
init|=
operator|(
name|uniform
condition|?
name|uniform
operator|>
literal|0
else|:
name|skewed
condition|?
name|xy
operator|*
name|yx
operator|<
name|xx
operator|*
name|yy
else|:
operator|(
name|xx
operator|<
literal|0
operator|)
operator|==
operator|(
name|yy
operator|<
literal|0
operator|)
operator|)
decl_stmt|;
name|float
name|line_width
init|=
name|lp
operator|->
name|width
decl_stmt|;
comment|/* this is *half* the line width! */
name|int
name|always_thin
decl_stmt|;
name|float
name|line_width_and_scale
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
block|{
name|int
name|count
init|=
name|lp
operator|->
name|dash
operator|.
name|pattern_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dprintf3
argument_list|(
literal|"[o]half_width=%f, cap=%d, join=%d,\n"
argument_list|,
name|lp
operator|->
name|width
argument_list|,
operator|(
name|int
operator|)
name|lp
operator|->
name|cap
argument_list|,
operator|(
name|int
operator|)
name|lp
operator|->
name|join
argument_list|)
expr_stmt|;
name|dprintf2
argument_list|(
literal|"   miter_limit=%f, miter_check=%f,\n"
argument_list|,
name|lp
operator|->
name|miter_limit
argument_list|,
name|lp
operator|->
name|miter_check
argument_list|)
expr_stmt|;
name|dprintf1
argument_list|(
literal|"   dash pattern=%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|dprintf1
argument_list|(
literal|",%f"
argument_list|,
name|lp
operator|->
name|dash
operator|.
name|pattern
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dprintf4
argument_list|(
literal|",\n   offset=%f, init(ink_on=%d, index=%d, dist_left=%f)\n"
argument_list|,
name|lp
operator|->
name|dash
operator|.
name|offset
argument_list|,
name|lp
operator|->
name|dash
operator|.
name|init_ink_on
argument_list|,
name|lp
operator|->
name|dash
operator|.
name|init_index
argument_list|,
name|lp
operator|->
name|dash
operator|.
name|init_dist_left
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|line_width
operator|<
literal|0
condition|)
name|line_width
operator|=
operator|-
name|line_width
expr_stmt|;
if|if
condition|(
name|is_fzero
argument_list|(
name|line_width
argument_list|)
condition|)
name|always_thin
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|skewed
condition|)
block|{
name|float
name|xxa
init|=
name|xx
decl_stmt|,
name|yya
init|=
name|yy
decl_stmt|;
if|if
condition|(
name|xxa
operator|<
literal|0
condition|)
name|xxa
operator|=
operator|-
name|xxa
expr_stmt|;
if|if
condition|(
name|yya
operator|<
literal|0
condition|)
name|yya
operator|=
operator|-
name|yya
expr_stmt|;
name|always_thin
operator|=
operator|(
name|max
argument_list|(
name|xxa
argument_list|,
name|yya
argument_list|)
operator|*
name|line_width
operator|<
literal|0.5
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The check is more complicated, but it's worth it. */
name|float
name|xsq
init|=
name|xx
operator|*
name|xx
operator|+
name|xy
operator|*
name|xy
decl_stmt|;
name|float
name|ysq
init|=
name|yx
operator|*
name|yx
operator|+
name|yy
operator|*
name|yy
decl_stmt|;
name|float
name|cross
init|=
name|xx
operator|*
name|yx
operator|+
name|xy
operator|*
name|yy
decl_stmt|;
if|if
condition|(
name|cross
operator|<
literal|0
condition|)
name|cross
operator|=
literal|0
expr_stmt|;
name|always_thin
operator|=
operator|(
operator|(
name|max
argument_list|(
name|xsq
argument_list|,
name|ysq
argument_list|)
operator|+
name|cross
operator|)
operator|*
name|line_width
operator|*
name|line_width
operator|<
literal|0.5
operator|)
expr_stmt|;
block|}
name|line_width_and_scale
operator|=
name|line_width
operator|*
operator|(
name|float
operator|)
name|int2fixed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
name|dprintf5
argument_list|(
literal|"[o]ctm=(%g,%g,%g,%g) thin=%d\n"
argument_list|,
name|xx
argument_list|,
name|xy
argument_list|,
name|yx
argument_list|,
name|yy
argument_list|,
name|always_thin
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Start by flattening the path.  We should do this on-the-fly.... */
if|if
condition|(
operator|!
name|ppath
operator|->
name|curve_count
condition|)
comment|/* don't need to flatten */
block|{
name|psub
operator|=
name|ppath
operator|->
name|first_subpath
expr_stmt|;
if|if
condition|(
operator|!
name|psub
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|gx_path_flatten
argument_list|(
name|ppath
argument_list|,
operator|&
name|fpath
argument_list|,
name|pgs
operator|->
name|flatness
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|psub
operator|=
name|fpath
operator|.
name|first_subpath
expr_stmt|;
block|}
if|if
condition|(
name|dash_count
condition|)
name|gx_path_init
argument_list|(
operator|&
name|dpath
argument_list|,
operator|&
name|ppath
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line_segment
modifier|*
name|pline
decl_stmt|;
name|fixed
name|x
decl_stmt|,
name|y
decl_stmt|;
name|partial_line
name|pl
decl_stmt|,
name|pl_prev
decl_stmt|,
name|pl_first
decl_stmt|;
name|int
name|first
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|psub
condition|)
block|{
comment|/* Might just be the end of a dash expansion. */
if|if
condition|(
name|save_psub
condition|)
block|{
name|gx_path_release
argument_list|(
operator|&
name|dpath
argument_list|)
expr_stmt|;
name|psub
operator|=
operator|(
name|subpath
operator|*
operator|)
name|save_psub
operator|->
name|last
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|psub
condition|)
break|break;
name|gx_path_init
argument_list|(
operator|&
name|dpath
argument_list|,
operator|&
name|ppath
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
name|save_psub
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* all done */
break|break;
block|}
if|if
condition|(
name|dash_count
operator|&&
operator|!
name|save_psub
condition|)
block|{
name|code
operator|=
name|expand_dashes
argument_list|(
name|psub
argument_list|,
operator|&
name|dpath
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
goto|goto
name|exit
goto|;
name|save_psub
operator|=
operator|(
name|subpath
operator|*
operator|)
name|psub
expr_stmt|;
name|psub
operator|=
name|dpath
operator|.
name|first_subpath
expr_stmt|;
continue|continue;
comment|/* psub might be null */
block|}
name|pline
operator|=
operator|(
name|line_segment
operator|*
operator|)
operator|(
name|psub
operator|->
name|next
operator|)
expr_stmt|;
name|x
operator|=
name|psub
operator|->
name|pt
operator|.
name|x
expr_stmt|;
name|y
operator|=
name|psub
operator|->
name|pt
operator|.
name|y
expr_stmt|;
while|while
condition|(
name|pline
operator|!=
literal|0
operator|&&
name|pline
operator|->
name|type
operator|!=
name|s_start
condition|)
block|{
name|fixed
name|sx
init|=
name|pline
operator|->
name|pt
operator|.
name|x
decl_stmt|;
name|fixed
name|sy
init|=
name|pline
operator|->
name|pt
operator|.
name|y
decl_stmt|;
comment|/* Compute the width parameters in device space. */
comment|/* We work with unscaled values, for speed. */
name|pl
operator|.
name|o
operator|.
name|p
operator|.
name|x
operator|=
name|x
operator|,
name|pl
operator|.
name|o
operator|.
name|p
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|pl
operator|.
name|e
operator|.
name|p
operator|.
name|x
operator|=
name|sx
operator|,
name|pl
operator|.
name|e
operator|.
name|p
operator|.
name|y
operator|=
name|sy
expr_stmt|;
if|if
condition|(
operator|!
name|always_thin
condition|)
block|{
name|fixed
name|udx
init|=
name|sx
operator|-
name|x
decl_stmt|,
name|udy
init|=
name|sy
operator|-
name|y
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|udx
operator||
name|udy
operator|)
condition|)
comment|/* degenerate */
block|{
comment|/* Only consider a degenerate segment */
comment|/* if the entire subpath is degenerate and */
comment|/* we are using round caps or joins. */
if|if
condition|(
name|index
operator|!=
literal|0
operator|||
operator|(
name|pline
operator|->
name|next
operator|!=
literal|0
operator|&&
name|pline
operator|->
name|next
operator|->
name|type
operator|!=
name|s_start
operator|)
operator|||
operator|(
name|lp
operator|->
name|cap
operator|!=
name|gs_cap_round
operator|&&
name|lp
operator|->
name|join
operator|!=
name|gs_join_round
operator|)
condition|)
goto|goto
name|nd
goto|;
comment|/* Pick an arbitrary orientation. */
name|udx
operator|=
name|int2fixed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uniform
operator|!=
literal|0
condition|)
block|{
comment|/* We can save a lot of work in this case. */
name|float
name|dpx
init|=
name|udx
decl_stmt|,
name|dpy
init|=
name|udy
decl_stmt|;
name|float
name|wl
init|=
name|line_width_and_scale
operator|*
name|xx
operator|/
name|hypot
argument_list|(
name|dpx
argument_list|,
name|dpy
argument_list|)
decl_stmt|;
if|if
condition|(
name|wl
operator|<
literal|0
condition|)
name|wl
operator|=
operator|-
name|wl
expr_stmt|;
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|x
operator|=
call|(
name|fixed
call|)
argument_list|(
name|dpx
operator|*
name|wl
argument_list|)
expr_stmt|;
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|y
operator|=
call|(
name|fixed
call|)
argument_list|(
name|dpy
operator|*
name|wl
argument_list|)
expr_stmt|;
name|pl
operator|.
name|width
operator|.
name|x
operator|=
operator|-
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|y
expr_stmt|;
name|pl
operator|.
name|width
operator|.
name|y
operator|=
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|x
expr_stmt|;
name|pl
operator|.
name|thin
operator|=
literal|0
expr_stmt|;
comment|/* if not always_thin, */
comment|/* then never thin. */
block|}
else|else
block|{
name|gs_point
name|dpt
decl_stmt|;
comment|/* unscaled */
name|float
name|wl
decl_stmt|;
if|if
condition|(
name|skewed
condition|)
name|gs_idtransform
argument_list|(
name|pgs
argument_list|,
operator|(
name|float
operator|)
name|udx
argument_list|,
operator|(
name|float
operator|)
name|udy
argument_list|,
operator|&
name|dpt
argument_list|)
expr_stmt|;
else|else
comment|/* shortcut */
name|dpt
operator|.
name|x
operator|=
name|udx
operator|/
name|xx
operator|,
name|dpt
operator|.
name|y
operator|=
name|udy
operator|/
name|yy
expr_stmt|;
name|wl
operator|=
name|line_width_and_scale
operator|/
name|hypot
argument_list|(
name|dpt
operator|.
name|x
argument_list|,
name|dpt
operator|.
name|y
argument_list|)
expr_stmt|;
comment|/* Construct the width vector in */
comment|/* user space, still unscaled. */
name|dpt
operator|.
name|x
operator|*=
name|wl
expr_stmt|;
name|dpt
operator|.
name|y
operator|*=
name|wl
expr_stmt|;
comment|/* 				 * We now compute both perpendicular 				 * and (optionally) parallel half-widths, 				 * as deltas in device space.  We use 				 * a fixed-point, unscaled version of 				 * gs_dtransform.  The second computation 				 * folds in a 90-degree rotation (in user 				 * space, before transforming) in the 				 * direction that corresponds to clockwise 				 * in device space. 				 */
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|x
operator|=
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|x
operator|*
name|xx
argument_list|)
expr_stmt|;
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|y
operator|=
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|y
operator|*
name|yy
argument_list|)
expr_stmt|;
if|if
condition|(
name|skewed
condition|)
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|x
operator|+=
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|y
operator|*
name|yx
argument_list|)
operator|,
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|y
operator|+=
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|x
operator|*
name|xy
argument_list|)
expr_stmt|;
if|if
condition|(
name|reflected
condition|)
name|dpt
operator|.
name|x
operator|=
operator|-
name|dpt
operator|.
name|x
operator|,
name|dpt
operator|.
name|y
operator|=
operator|-
name|dpt
operator|.
name|y
expr_stmt|;
name|pl
operator|.
name|width
operator|.
name|x
operator|=
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|y
operator|*
name|xx
argument_list|)
operator|,
name|pl
operator|.
name|width
operator|.
name|y
operator|=
operator|-
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|x
operator|*
name|yy
argument_list|)
expr_stmt|;
if|if
condition|(
name|skewed
condition|)
name|pl
operator|.
name|width
operator|.
name|x
operator|-=
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|x
operator|*
name|yx
argument_list|)
operator|,
name|pl
operator|.
name|width
operator|.
name|y
operator|+=
call|(
name|fixed
call|)
argument_list|(
name|dpt
operator|.
name|y
operator|*
name|xy
argument_list|)
expr_stmt|;
name|pl
operator|.
name|thin
operator|=
name|any_abs
argument_list|(
name|pl
operator|.
name|width
operator|.
name|x
argument_list|)
operator|+
name|any_abs
argument_list|(
name|pl
operator|.
name|width
operator|.
name|y
argument_list|)
operator|<
name|float2fixed
argument_list|(
literal|0.75
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pl
operator|.
name|thin
condition|)
name|compute_caps
argument_list|(
operator|&
name|pl
argument_list|)
expr_stmt|;
block|}
else|else
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|x
operator|=
name|pl
operator|.
name|e
operator|.
name|cdelta
operator|.
name|y
operator|=
literal|0
operator|,
name|pl
operator|.
name|width
operator|.
name|x
operator|=
name|pl
operator|.
name|width
operator|.
name|y
operator|=
literal|0
operator|,
name|pl
operator|.
name|thin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|++
operator|==
literal|0
condition|)
name|pl_first
operator|=
name|pl
expr_stmt|;
if|if
condition|(
name|index
operator|++
condition|)
call|(
modifier|*
name|line_proc
call|)
argument_list|(
name|index
operator|-
literal|2
argument_list|,
operator|&
name|pl_prev
argument_list|,
operator|&
name|pl
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|pl_prev
operator|=
name|pl
expr_stmt|;
name|x
operator|=
name|sx
operator|,
name|y
operator|=
name|sy
expr_stmt|;
name|nd
label|:
name|pline
operator|=
operator|(
name|line_segment
operator|*
operator|)
operator|(
name|pline
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|index
condition|)
block|{
comment|/* If closed, join back to start, else cap */
call|(
modifier|*
name|line_proc
call|)
argument_list|(
name|index
operator|-
literal|1
argument_list|,
operator|&
name|pl_prev
argument_list|,
operator|(
name|psub
operator|->
name|closed
condition|?
operator|&
name|pl_first
else|:
operator|(
name|pl_ptr
operator|)
literal|0
operator|)
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|}
name|psub
operator|=
operator|(
name|subpath
operator|*
operator|)
name|pline
expr_stmt|;
if|if
condition|(
name|stroke_path
operator|==
operator|&
name|stroke_path_body
condition|)
block|{
comment|/* Fill and release the accumulated path */
name|gx_fill_path
argument_list|(
name|stroke_path
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|,
name|gx_rule_winding_number
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
expr_stmt|;
name|gx_path_release
argument_list|(
name|stroke_path
argument_list|)
expr_stmt|;
name|stroke_path
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|exit
label|:
if|if
condition|(
name|dash_count
condition|)
name|gx_path_release
argument_list|(
operator|&
name|dpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppath
operator|->
name|curve_count
condition|)
name|gx_path_release
argument_list|(
operator|&
name|fpath
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Expand a dashed subpath into explicit segments. */
end_comment

begin_comment
comment|/* The subpath contains no curves. */
end_comment

begin_function
name|private
name|int
name|expand_dashes
parameter_list|(
name|subpath
modifier|*
name|psub
parameter_list|,
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|int
name|skewed
init|=
name|is_skewed
argument_list|(
operator|&
name|pgs
operator|->
name|ctm
argument_list|)
decl_stmt|;
name|dash_params
modifier|*
name|dash
init|=
operator|&
name|pgs
operator|->
name|line_params
operator|->
name|dash
decl_stmt|;
name|float
modifier|*
name|pattern
init|=
name|dash
operator|->
name|pattern
decl_stmt|;
name|int
name|count
decl_stmt|,
name|ink_on
decl_stmt|,
name|index
decl_stmt|;
name|float
name|dist_left
decl_stmt|;
name|fixed
name|x0
init|=
name|psub
operator|->
name|pt
operator|.
name|x
decl_stmt|,
name|y0
init|=
name|psub
operator|->
name|pt
operator|.
name|y
decl_stmt|;
name|fixed
name|x
decl_stmt|,
name|y
decl_stmt|;
name|segment
modifier|*
name|pseg
decl_stmt|;
name|int
name|wrap
init|=
operator|(
name|dash
operator|->
name|init_ink_on
operator|&&
name|psub
operator|->
name|closed
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|drawing
init|=
name|wrap
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* To do the right thing at the beginning of a closed path, */
comment|/* we have to skip any initial line, and then redo it at */
comment|/* the end of the path.  Drawing = -1 while skipping, */
comment|/* 0 while drawing normally, and 1 on the second round. */
name|top
label|:
name|count
operator|=
name|dash
operator|->
name|pattern_size
expr_stmt|;
name|ink_on
operator|=
name|dash
operator|->
name|init_ink_on
expr_stmt|;
name|index
operator|=
name|dash
operator|->
name|init_index
expr_stmt|;
name|dist_left
operator|=
name|dash
operator|->
name|init_dist_left
expr_stmt|;
name|x
operator|=
name|x0
operator|,
name|y
operator|=
name|y0
expr_stmt|;
name|pseg
operator|=
operator|(
name|segment
operator|*
operator|)
name|psub
expr_stmt|;
while|while
condition|(
operator|(
name|pseg
operator|=
name|pseg
operator|->
name|next
operator|)
operator|!=
literal|0
operator|&&
name|pseg
operator|->
name|type
operator|!=
name|s_start
condition|)
block|{
name|fixed
name|sx
init|=
name|pseg
operator|->
name|pt
operator|.
name|x
decl_stmt|,
name|sy
init|=
name|pseg
operator|->
name|pt
operator|.
name|y
decl_stmt|;
name|fixed
name|udx
init|=
name|sx
operator|-
name|x
decl_stmt|,
name|udy
init|=
name|sy
operator|-
name|y
decl_stmt|;
name|float
name|length
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|float
name|dist
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|udx
operator||
name|udy
operator|)
condition|)
comment|/* degenerate */
name|dx
operator|=
literal|0
operator|,
name|dy
operator|=
literal|0
operator|,
name|length
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|gs_point
name|d
decl_stmt|;
name|dx
operator|=
name|udx
operator|,
name|dy
operator|=
name|udy
expr_stmt|;
comment|/* scaled as fixed */
if|if
condition|(
name|skewed
condition|)
name|gs_idtransform
argument_list|(
name|pgs
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
else|else
comment|/* shortcut */
name|d
operator|.
name|x
operator|=
name|dx
operator|/
name|pgs
operator|->
name|ctm
operator|.
name|xx
operator|,
name|d
operator|.
name|y
operator|=
name|dy
operator|/
name|pgs
operator|->
name|ctm
operator|.
name|yy
expr_stmt|;
name|length
operator|=
name|sqrt
argument_list|(
name|d
operator|.
name|x
operator|*
name|d
operator|.
name|x
operator|+
name|d
operator|.
name|y
operator|*
name|d
operator|.
name|y
argument_list|)
operator|*
operator|(
literal|1
operator|/
operator|(
name|float
operator|)
name|int2fixed
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
block|}
name|dist
operator|=
name|length
expr_stmt|;
while|while
condition|(
name|dist
operator|>
name|dist_left
condition|)
block|{
comment|/* We are using up the dash element */
name|float
name|fraction
init|=
name|dist_left
operator|/
name|length
decl_stmt|;
name|fixed
name|nx
init|=
name|x
operator|+
call|(
name|fixed
call|)
argument_list|(
name|dx
operator|*
name|fraction
argument_list|)
decl_stmt|;
name|fixed
name|ny
init|=
name|y
operator|+
call|(
name|fixed
call|)
argument_list|(
name|dy
operator|*
name|fraction
argument_list|)
decl_stmt|;
if|if
condition|(
name|ink_on
condition|)
block|{
if|if
condition|(
name|drawing
operator|>=
literal|0
condition|)
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|drawing
operator|>
literal|0
condition|)
return|return
literal|0
return|;
comment|/* done */
name|code
operator|=
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
name|drawing
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|dist
operator|-=
name|dist_left
expr_stmt|;
name|ink_on
operator|=
operator|!
name|ink_on
expr_stmt|;
if|if
condition|(
operator|++
name|index
operator|==
name|count
condition|)
name|index
operator|=
literal|0
expr_stmt|;
name|dist_left
operator|=
name|pattern
index|[
name|index
index|]
expr_stmt|;
name|x
operator|=
name|nx
operator|,
name|y
operator|=
name|ny
expr_stmt|;
block|}
name|dist_left
operator|-=
name|dist
expr_stmt|;
comment|/* Handle the last dash of a segment. */
if|if
condition|(
name|ink_on
condition|)
block|{
if|if
condition|(
name|drawing
operator|>=
literal|0
condition|)
name|code
operator|=
operator|(
name|pseg
operator|->
name|type
operator|==
name|s_line_close
operator|&&
name|drawing
operator|>
literal|0
condition|?
name|gx_path_close_subpath
argument_list|(
name|ppath
argument_list|)
else|:
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|drawing
operator|>
literal|0
condition|)
return|return
literal|0
return|;
comment|/* done */
name|code
operator|=
name|gx_path_add_point
argument_list|(
name|ppath
argument_list|,
name|sx
argument_list|,
name|sy
argument_list|)
expr_stmt|;
name|drawing
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|x
operator|=
name|sx
operator|,
name|y
operator|=
name|sy
expr_stmt|;
block|}
comment|/* Check for wraparound. */
if|if
condition|(
name|wrap
operator|&&
name|drawing
operator|<=
literal|0
condition|)
block|{
comment|/* We skipped some initial lines. */
comment|/* Go back and do them now. */
name|drawing
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the intersection of two lines.  This is a messy algorithm */
end_comment

begin_comment
comment|/* that somehow ought to be useful in more places than just here.... */
end_comment

begin_function
name|private
name|void
name|line_intersect
parameter_list|(
name|p_ptr
name|pp1
parameter_list|,
comment|/* point on 1st line */
name|p_ptr
name|pd1
parameter_list|,
comment|/* slope of 1st line (dx,dy) */
name|p_ptr
name|pp2
parameter_list|,
comment|/* point on 2nd line */
name|p_ptr
name|pd2
parameter_list|,
comment|/* slope of 2nd line */
name|p_ptr
name|pi
parameter_list|)
comment|/* return intersection here */
block|{
comment|/* We don't have to do any scaling, the factors all work out right. */
name|float
name|u1
init|=
name|pd1
operator|->
name|x
decl_stmt|,
name|v1
init|=
name|pd1
operator|->
name|y
decl_stmt|;
name|float
name|u2
init|=
name|pd2
operator|->
name|x
decl_stmt|,
name|v2
init|=
name|pd2
operator|->
name|y
decl_stmt|;
name|double
name|denom
init|=
name|u1
operator|*
name|v2
operator|-
name|u2
operator|*
name|v1
decl_stmt|;
name|double
name|num1
init|=
name|v1
operator|*
name|pp1
operator|->
name|x
operator|-
name|u1
operator|*
name|pp1
operator|->
name|y
decl_stmt|;
name|double
name|num2
init|=
name|v2
operator|*
name|pp2
operator|->
name|x
operator|-
name|u2
operator|*
name|pp2
operator|->
name|y
decl_stmt|;
name|double
name|xnum
init|=
name|u1
operator|*
name|num2
operator|-
name|u2
operator|*
name|num1
decl_stmt|;
name|double
name|ynum
init|=
name|v1
operator|*
name|num2
operator|-
name|v2
operator|*
name|num1
decl_stmt|;
name|double
name|max_result
init|=
name|any_abs
argument_list|(
name|denom
argument_list|)
operator|*
operator|(
name|double
operator|)
name|max_fixed
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
block|{
name|dprintf4
argument_list|(
literal|"[o]Intersect %f,%f(%f/%f)"
argument_list|,
name|fixed2float
argument_list|(
name|pp1
operator|->
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pp1
operator|->
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pd1
operator|->
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pd1
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf4
argument_list|(
literal|"& %f,%f(%f/%f),\n"
argument_list|,
name|fixed2float
argument_list|(
name|pp2
operator|->
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pp2
operator|->
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pd2
operator|->
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pd2
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf4
argument_list|(
literal|"\txnum=%f ynum=%f denom=%f max_result=%f ->\n"
argument_list|,
name|xnum
argument_list|,
name|ynum
argument_list|,
name|denom
argument_list|,
name|max_result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check for degenerate result. */
if|if
condition|(
name|denom
operator|==
literal|0
operator|||
name|any_abs
argument_list|(
name|xnum
argument_list|)
operator|>
name|max_result
operator|||
name|any_abs
argument_list|(
name|ynum
argument_list|)
operator|>
name|max_result
condition|)
block|{
comment|/* The lines are nearly parallel, */
comment|/* or one of them has zero length.  Punt. */
operator|*
name|pi
operator|=
operator|*
name|pp1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
name|dprintf
argument_list|(
literal|"\tdegenerate!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|pi
operator|->
name|x
operator|=
call|(
name|fixed
call|)
argument_list|(
name|xnum
operator|/
name|denom
argument_list|)
expr_stmt|;
name|pi
operator|->
name|y
operator|=
call|(
name|fixed
call|)
argument_list|(
name|ynum
operator|/
name|denom
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"\t%f,%f\n"
argument_list|,
name|fixed2float
argument_list|(
name|pi
operator|->
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|pi
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_define
define|#
directive|define
name|lix
value|plp->o.p.x
end_define

begin_define
define|#
directive|define
name|liy
value|plp->o.p.y
end_define

begin_define
define|#
directive|define
name|litox
value|plp->e.p.x
end_define

begin_define
define|#
directive|define
name|litoy
value|plp->e.p.y
end_define

begin_comment
comment|/* Draw a line on the device. */
end_comment

begin_function
name|private
name|int
name|stroke_fill
parameter_list|(
name|int
name|first
parameter_list|,
specifier|register
name|pl_ptr
name|plp
parameter_list|,
name|pl_ptr
name|nplp
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
if|if
condition|(
name|plp
operator|->
name|thin
condition|)
block|{
comment|/* Minimum-width line, don't have to be careful. */
comment|/* We do have to check for the entire line being */
comment|/* within the clipping rectangle, allowing for some */
comment|/* slop at the ends. */
name|fixed
name|dx
init|=
name|litox
operator|-
name|lix
decl_stmt|,
name|dy
init|=
name|litoy
operator|-
name|liy
decl_stmt|;
define|#
directive|define
name|trsign
parameter_list|(
name|v
parameter_list|,
name|c
parameter_list|)
value|(v>= 0 ? c : -c)
define|#
directive|define
name|slop
value|int2fixed(2)
name|fixed
name|xslop
init|=
name|trsign
argument_list|(
name|dx
argument_list|,
name|slop
argument_list|)
decl_stmt|;
name|fixed
name|yslop
init|=
name|trsign
argument_list|(
name|dy
argument_list|,
name|slop
argument_list|)
decl_stmt|;
if|if
condition|(
name|gx_cpath_includes_rectangle
argument_list|(
name|pgs
operator|->
name|clip_path
argument_list|,
name|lix
operator|-
name|xslop
argument_list|,
name|liy
operator|-
name|yslop
argument_list|,
name|litox
operator|+
name|xslop
argument_list|,
name|litoy
operator|+
name|yslop
argument_list|)
condition|)
return|return
name|gz_draw_line_fixed
argument_list|(
name|lix
argument_list|,
name|liy
argument_list|,
name|litox
argument_list|,
name|litoy
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|)
return|;
undef|#
directive|undef
name|slop
comment|/* We didn't set up the endpoint parameters before, */
comment|/* because the line was thin.  Do it now. */
comment|/* We only approximate the width and height. */
if|if
condition|(
name|any_abs
argument_list|(
name|dx
argument_list|)
operator|>
name|any_abs
argument_list|(
name|dy
argument_list|)
condition|)
block|{
name|plp
operator|->
name|width
operator|.
name|x
operator|=
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|y
operator|=
literal|0
expr_stmt|;
name|plp
operator|->
name|width
operator|.
name|y
operator|=
operator|-
operator|(
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|x
operator|=
name|trsign
argument_list|(
name|dx
argument_list|,
name|float2fixed
argument_list|(
operator|-
literal|0.5
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|plp
operator|->
name|width
operator|.
name|y
operator|=
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|plp
operator|->
name|width
operator|.
name|x
operator|=
operator|-
operator|(
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|y
operator|=
name|trsign
argument_list|(
name|dy
argument_list|,
name|float2fixed
argument_list|(
operator|-
literal|0.5
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
undef|#
directive|undef
name|trsign
name|compute_caps
argument_list|(
name|plp
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* General case. */
comment|/* Construct a path and hand it to the fill algorithm. */
if|if
condition|(
name|stroke_path
operator|==
literal|0
condition|)
block|{
comment|/* We are rendering, and haven't run into the */
comment|/* general case yet.  Initialize the path. */
name|stroke_path
operator|=
operator|&
name|stroke_path_body
expr_stmt|;
comment|/* set global for stroke_add */
name|gx_path_init
argument_list|(
name|stroke_path
argument_list|,
operator|&
name|pgs
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
block|}
name|stroke_add
argument_list|(
name|first
argument_list|,
name|plp
argument_list|,
name|nplp
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|{
comment|/****** PATCH ******/
if|if
condition|(
name|stroke_path
operator|==
operator|&
name|stroke_path_body
condition|)
block|{
name|gx_fill_path
argument_list|(
name|stroke_path
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|,
name|gx_rule_winding_number
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
expr_stmt|;
name|gx_path_release
argument_list|(
name|stroke_path
argument_list|)
expr_stmt|;
name|stroke_path
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|lix
end_undef

begin_undef
undef|#
directive|undef
name|liy
end_undef

begin_undef
undef|#
directive|undef
name|litox
end_undef

begin_undef
undef|#
directive|undef
name|litoy
end_undef

begin_comment
comment|/* Add a segment to the path.  This handles all the complex cases. */
end_comment

begin_decl_stmt
name|private
name|int
name|add_capped
argument_list|(
name|P4
argument_list|(
name|gx_path
operator|*
argument_list|,
name|gs_line_cap
argument_list|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|P3
argument_list|(
name|gx_path
operator|*
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
argument_list|,
name|ep_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|stroke_add
parameter_list|(
name|int
name|first
parameter_list|,
specifier|register
name|pl_ptr
name|plp
parameter_list|,
name|pl_ptr
name|nplp
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_path
modifier|*
name|ppath
init|=
name|stroke_path
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|ppath
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/****** strokepath is NYI ******/
if|if
condition|(
name|plp
operator|->
name|thin
condition|)
block|{
comment|/* We didn't set up the endpoint parameters before, */
comment|/* because the line was thin.  Do it now. */
name|compute_caps
argument_list|(
name|plp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|=
name|add_capped
argument_list|(
name|ppath
argument_list|,
operator|(
name|first
operator|==
literal|0
condition|?
name|pgs
operator|->
name|line_params
operator|->
name|cap
else|:
name|gs_cap_butt
operator|)
argument_list|,
name|gx_path_add_point
argument_list|,
operator|&
name|plp
operator|->
name|o
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|nplp
operator|==
literal|0
condition|)
block|{
name|code
operator|=
name|add_capped
argument_list|(
name|ppath
argument_list|,
name|pgs
operator|->
name|line_params
operator|->
name|cap
argument_list|,
name|gx_path_add_line
argument_list|,
operator|&
name|plp
operator|->
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pgs
operator|->
name|line_params
operator|->
name|join
operator|==
name|gs_join_round
condition|)
block|{
name|code
operator|=
name|add_capped
argument_list|(
name|ppath
argument_list|,
name|gs_cap_round
argument_list|,
name|gx_path_add_line
argument_list|,
operator|&
name|plp
operator|->
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nplp
operator|->
name|thin
condition|)
comment|/* no join */
block|{
name|code
operator|=
name|add_capped
argument_list|(
name|ppath
argument_list|,
name|gs_cap_butt
argument_list|,
name|gx_path_add_line
argument_list|,
operator|&
name|plp
operator|->
name|e
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* join_bevel or join_miter */
block|{
name|gs_fixed_point
name|jp1
decl_stmt|,
name|jp2
decl_stmt|;
comment|/* 		 * Set np to whichever of nplp->o.co or .ce 		 * is outside the current line. 		 * We use the interesting observation that 		 * point (x2,y2) is counter-clockwise from (x1,y1) 		 * relative to the origin iff x1*y2< x2*y1. 		 * In this case x1,y1 are plp->width, 		 * x2,y2 are nplp->width, and the origin is 		 * their common point (plp->e.p, nplp->o.p). 		 */
name|float
name|wx1
init|=
name|plp
operator|->
name|width
operator|.
name|x
decl_stmt|,
name|wy1
init|=
name|plp
operator|->
name|width
operator|.
name|y
decl_stmt|;
name|float
name|wx2
init|=
name|nplp
operator|->
name|width
operator|.
name|x
decl_stmt|,
name|wy2
init|=
name|nplp
operator|->
name|width
operator|.
name|y
decl_stmt|;
name|int
name|ccw
init|=
name|wx1
operator|*
name|wy2
operator|<
name|wx2
operator|*
name|wy1
decl_stmt|;
name|p_ptr
name|outp
decl_stmt|,
name|np
decl_stmt|,
name|np1
decl_stmt|,
name|np2
decl_stmt|;
comment|/* Initialize for a bevel join. */
name|jp1
operator|.
name|x
operator|=
name|plp
operator|->
name|e
operator|.
name|co
operator|.
name|x
operator|,
name|jp1
operator|.
name|y
operator|=
name|plp
operator|->
name|e
operator|.
name|co
operator|.
name|y
expr_stmt|;
name|jp2
operator|.
name|x
operator|=
name|plp
operator|->
name|e
operator|.
name|ce
operator|.
name|x
operator|,
name|jp2
operator|.
name|y
operator|=
name|plp
operator|->
name|e
operator|.
name|ce
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|ccw
condition|)
name|outp
operator|=
operator|&
name|jp2
operator|,
name|np2
operator|=
name|np
operator|=
operator|&
name|nplp
operator|->
name|o
operator|.
name|co
operator|,
name|np1
operator|=
operator|&
name|plp
operator|->
name|e
operator|.
name|p
expr_stmt|;
else|else
name|outp
operator|=
operator|&
name|jp1
operator|,
name|np1
operator|=
name|np
operator|=
operator|&
name|nplp
operator|->
name|o
operator|.
name|ce
operator|,
name|np2
operator|=
operator|&
name|plp
operator|->
name|e
operator|.
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
name|dprintf1
argument_list|(
literal|"[o]use %s\n"
argument_list|,
operator|(
name|ccw
condition|?
literal|"co (ccw)"
else|:
literal|"ce (cw)"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't bother with the miter check if the two */
comment|/* points to be joined are very close together, */
comment|/* namely, in the same square half-pixel. */
if|if
condition|(
name|pgs
operator|->
name|line_params
operator|->
name|join
operator|==
name|gs_join_miter
operator|&&
operator|!
operator|(
name|fixed2long
argument_list|(
name|outp
operator|->
name|x
operator|<<
literal|1
argument_list|)
operator|==
name|fixed2long
argument_list|(
name|np
operator|->
name|x
operator|<<
literal|1
argument_list|)
operator|&&
name|fixed2long
argument_list|(
name|outp
operator|->
name|y
operator|<<
literal|1
argument_list|)
operator|==
name|fixed2long
argument_list|(
name|np
operator|->
name|y
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
comment|/* 		     * Check whether a miter join is appropriate. 		     * Let a, b be the angles of the two lines. 		     * We check tan(a-b) against the miter_check 		     * by using the following formula: 		     * If tan(a)=u1/v1 and tan(b)=u2/v2, then 		     * tan(a-b) = (u1*v2 - u2*v1) / (u1*u2 + v1*v2). 		     * We can do all the computations unscaled, 		     * because we're only concerned with ratios. 		     */
name|float
name|u1
init|=
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|x
decl_stmt|,
name|v1
init|=
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|y
decl_stmt|;
name|float
name|u2
init|=
name|nplp
operator|->
name|o
operator|.
name|cdelta
operator|.
name|x
decl_stmt|,
name|v2
init|=
name|nplp
operator|->
name|o
operator|.
name|cdelta
operator|.
name|y
decl_stmt|;
name|float
name|num
init|=
name|u1
operator|*
name|v2
operator|-
name|u2
operator|*
name|v1
decl_stmt|;
name|float
name|denom
init|=
name|u1
operator|*
name|u2
operator|+
name|v1
operator|*
name|v2
decl_stmt|;
name|float
name|check
init|=
name|pgs
operator|->
name|line_params
operator|->
name|miter_check
decl_stmt|;
comment|/* 		     * We will want either tan(a-b) or tan(b-a) 		     * depending on the orientations of the lines. 		     * Fortunately we know the relative orientations already. 		     */
if|if
condition|(
operator|!
name|ccw
condition|)
comment|/* have plp - nplp, want vice versa */
name|num
operator|=
operator|-
name|num
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
block|{
name|dprintf4
argument_list|(
literal|"[o]Miter check: u1/v1=%f/%f, u2/v2=%f/%f,\n"
argument_list|,
name|u1
argument_list|,
name|v1
argument_list|,
name|u2
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|dprintf3
argument_list|(
literal|"        num=%f, denom=%f, check=%f\n"
argument_list|,
name|num
argument_list|,
name|denom
argument_list|,
name|check
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Use a miter if num / denom>= check. */
comment|/* If check> 0, num< 0 always passes; */
comment|/* if check< 0, num>= 0 always fails. */
if|if
condition|(
name|denom
operator|<
literal|0
condition|)
name|num
operator|=
operator|-
name|num
operator|,
name|denom
operator|=
operator|-
name|denom
expr_stmt|;
if|if
condition|(
name|check
operator|>
literal|0
condition|?
operator|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>=
name|denom
operator|*
name|check
operator|)
else|:
operator|(
name|num
operator|<
literal|0
operator|&&
name|num
operator|>=
name|denom
operator|*
name|check
operator|)
condition|)
block|{
comment|/* OK to use a miter join. */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
name|dputs
argument_list|(
literal|"        ... passes.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute the intersection of */
comment|/* the extended edge lines. */
name|line_intersect
argument_list|(
name|outp
argument_list|,
operator|&
name|plp
operator|->
name|e
operator|.
name|cdelta
argument_list|,
name|np
argument_list|,
operator|&
name|nplp
operator|->
name|o
operator|.
name|cdelta
argument_list|,
name|outp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|jp1
operator|.
name|x
argument_list|,
name|jp1
operator|.
name|y
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|np1
operator|->
name|x
argument_list|,
name|np1
operator|->
name|y
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|np2
operator|->
name|x
argument_list|,
name|np2
operator|->
name|y
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|jp2
operator|.
name|x
argument_list|,
name|jp2
operator|.
name|y
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_close_subpath
argument_list|(
name|ppath
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Routines for cap computations */
end_comment

begin_comment
comment|/* Compute the endpoints of the two caps of a segment. */
end_comment

begin_function
name|private
name|void
name|compute_caps
parameter_list|(
specifier|register
name|pl_ptr
name|plp
parameter_list|)
block|{
name|fixed
name|wx2
init|=
name|plp
operator|->
name|width
operator|.
name|x
decl_stmt|;
name|fixed
name|wy2
init|=
name|plp
operator|->
name|width
operator|.
name|y
decl_stmt|;
name|plp
operator|->
name|o
operator|.
name|co
operator|.
name|x
operator|=
name|plp
operator|->
name|o
operator|.
name|p
operator|.
name|x
operator|+
name|wx2
operator|,
name|plp
operator|->
name|o
operator|.
name|co
operator|.
name|y
operator|=
name|plp
operator|->
name|o
operator|.
name|p
operator|.
name|y
operator|+
name|wy2
expr_stmt|;
name|plp
operator|->
name|o
operator|.
name|cdelta
operator|.
name|x
operator|=
operator|-
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|x
operator|,
name|plp
operator|->
name|o
operator|.
name|cdelta
operator|.
name|y
operator|=
operator|-
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|y
expr_stmt|;
name|plp
operator|->
name|o
operator|.
name|ce
operator|.
name|x
operator|=
name|plp
operator|->
name|o
operator|.
name|p
operator|.
name|x
operator|-
name|wx2
operator|,
name|plp
operator|->
name|o
operator|.
name|ce
operator|.
name|y
operator|=
name|plp
operator|->
name|o
operator|.
name|p
operator|.
name|y
operator|-
name|wy2
expr_stmt|;
name|plp
operator|->
name|e
operator|.
name|co
operator|.
name|x
operator|=
name|plp
operator|->
name|e
operator|.
name|p
operator|.
name|x
operator|-
name|wx2
operator|,
name|plp
operator|->
name|e
operator|.
name|co
operator|.
name|y
operator|=
name|plp
operator|->
name|e
operator|.
name|p
operator|.
name|y
operator|-
name|wy2
expr_stmt|;
name|plp
operator|->
name|e
operator|.
name|ce
operator|.
name|x
operator|=
name|plp
operator|->
name|e
operator|.
name|p
operator|.
name|x
operator|+
name|wx2
operator|,
name|plp
operator|->
name|e
operator|.
name|ce
operator|.
name|y
operator|=
name|plp
operator|->
name|e
operator|.
name|p
operator|.
name|y
operator|+
name|wy2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[o]Stroke o=(%f,%f) e=(%f,%f)\n"
argument_list|,
name|fixed2float
argument_list|(
name|plp
operator|->
name|o
operator|.
name|p
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|plp
operator|->
name|o
operator|.
name|p
operator|.
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|plp
operator|->
name|e
operator|.
name|p
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|plp
operator|->
name|e
operator|.
name|p
operator|.
name|y
argument_list|)
argument_list|)
operator|,
name|dprintf4
argument_list|(
literal|"\twxy=(%f,%f) lxy=(%f,%f)\n"
argument_list|,
name|fixed2float
argument_list|(
name|wx2
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|wy2
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|plp
operator|->
name|e
operator|.
name|cdelta
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Add a properly capped line endpoint to the path. */
end_comment

begin_comment
comment|/* The first point may require either moveto or lineto. */
end_comment

begin_decl_stmt
name|private
name|int
name|add_capped
argument_list|(
name|gx_path
operator|*
name|ppath
argument_list|,
name|gs_line_cap
name|type
argument_list|,
name|int
argument_list|(
operator|*
name|add_proc
argument_list|)
argument_list|(
name|P3
argument_list|(
name|gx_path
operator|*
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
argument_list|,
comment|/* gx_path_add_point/line */
specifier|register
name|ep_ptr
name|endp
argument_list|)
block|{
name|int
name|code
decl_stmt|;
define|#
directive|define
name|px
value|endp->p.x
define|#
directive|define
name|py
value|endp->p.y
define|#
directive|define
name|xo
value|endp->co.x
define|#
directive|define
name|yo
value|endp->co.y
define|#
directive|define
name|xe
value|endp->ce.x
define|#
directive|define
name|ye
value|endp->ce.y
define|#
directive|define
name|cdx
value|endp->cdelta.x
define|#
directive|define
name|cdy
value|endp->cdelta.y
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'o'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[o]cap: p=(%g,%g), co=(%g,%g),\n"
argument_list|,
name|fixed2float
argument_list|(
name|px
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|py
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|xo
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|yo
argument_list|)
argument_list|)
operator|,
name|dprintf4
argument_list|(
literal|"[o]\tce=(%g,%g), cd=(%g,%g)\n"
argument_list|,
name|fixed2float
argument_list|(
name|xe
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|ye
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|cdx
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|cdy
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|gs_cap_round
case|:
block|{
name|fixed
name|xm
init|=
name|px
operator|+
name|cdx
decl_stmt|;
name|fixed
name|ym
init|=
name|py
operator|+
name|cdy
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
call|(
modifier|*
name|add_proc
call|)
argument_list|(
name|ppath
argument_list|,
name|xo
argument_list|,
name|yo
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_arc
argument_list|(
name|ppath
argument_list|,
name|xo
argument_list|,
name|yo
argument_list|,
name|xm
argument_list|,
name|ym
argument_list|,
name|xo
operator|+
name|cdx
argument_list|,
name|yo
operator|+
name|cdy
argument_list|,
name|quarter_arc_fraction
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_arc
argument_list|(
name|ppath
argument_list|,
name|xm
argument_list|,
name|ym
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|,
name|xe
operator|+
name|cdx
argument_list|,
name|ye
operator|+
name|cdy
argument_list|,
name|quarter_arc_fraction
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
break|break;
case|case
name|gs_cap_square
case|:
if|if
condition|(
operator|(
name|code
operator|=
call|(
modifier|*
name|add_proc
call|)
argument_list|(
name|ppath
argument_list|,
name|xo
operator|+
name|cdx
argument_list|,
name|yo
operator|+
name|cdy
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|xe
operator|+
name|cdx
argument_list|,
name|ye
operator|+
name|cdy
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
break|break;
case|case
name|gs_cap_butt
case|:
if|if
condition|(
operator|(
name|code
operator|=
call|(
modifier|*
name|add_proc
call|)
argument_list|(
name|ppath
argument_list|,
name|xo
argument_list|,
name|yo
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gx_path_add_line
argument_list|(
name|ppath
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
return|return
name|code
return|;
block|}
end_decl_stmt

end_unit

