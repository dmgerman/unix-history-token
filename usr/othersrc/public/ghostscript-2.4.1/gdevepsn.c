begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevepsn.c */
end_comment

begin_comment
comment|/* Epson dot-matrix printer driver for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_comment
comment|/************************************************  * For 9-pin printers, you may select  *   X_DPI = 60, 120, or 240  *   Y_DPI = 60 or 72  * For 24-pin printers, you may select  *   X_DPI = 60, 120, 180, 240, or 360  *   Y_DPI = 60, 72, 180, or 216  * Note that a given printer implements *either* Y_DPI = 60 | 180 *or*  * Y_DPI = 72 | 216; no attempt is made to check this here.  * Note that X_DPI = 180 or 360 requires Y_DPI> 100;  * this isn't checked either.  Finally, note that X_DPI=240 and  * X_DPI=360 are double-density modes requiring two passes to print.  *  * The values of X_DPI and Y_DPI may be set at compile time:  * see gdevs.mak.  *   * At some time in the future, we could simulate 24-bit output on  * 9-pin printers by using fractional vertical positioning;  * we could even implement an X_DPI=360 mode by using the  * ESC++ command that spaces vertically in units of 1/360"  * (not supported on many printers.)  ************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|X_DPI
end_ifndef

begin_define
define|#
directive|define
name|X_DPI
value|240
end_define

begin_comment
comment|/* pixels per inch */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Y_DPI
end_ifndef

begin_define
define|#
directive|define
name|Y_DPI
value|60
end_define

begin_comment
comment|/* pixels per inch */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The device descriptors */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|eps_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|gx_device_printer
name|gs_epson_device
init|=
name|prn_device
argument_list|(
name|prn_std_procs
argument_list|,
literal|"epson"
argument_list|,
literal|85
argument_list|,
comment|/* width_10ths, 8.5" */
literal|110
argument_list|,
comment|/* height_10ths, 11" */
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0.5
argument_list|,
literal|0
argument_list|,
comment|/* margins */
literal|1
argument_list|,
name|eps_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|void
name|eps_output_run
argument_list|(
name|P6
argument_list|(
name|byte
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|char
argument_list|,
name|FILE
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send the page to the printer. */
end_comment

begin_define
define|#
directive|define
name|DD
value|0x80
end_define

begin_comment
comment|/* double density flag */
end_comment

begin_function
name|private
name|int
name|eps_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|prn_stream
parameter_list|)
block|{
specifier|static
name|char
name|graphics_modes_9
index|[
literal|5
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|0
comment|/*60*/
block|,
literal|1
comment|/*120*/
block|,
operator|-
literal|1
block|,
name|DD
operator|+
literal|3
comment|/*240*/
block|}
decl_stmt|;
specifier|static
name|char
name|graphics_modes_24
index|[
literal|7
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|32
comment|/*60*/
block|,
literal|33
comment|/*120*/
block|,
literal|39
comment|/*180*/
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|DD
operator|+
literal|40
comment|/*360*/
block|}
decl_stmt|;
name|int
name|y_24pin
init|=
name|pdev
operator|->
name|y_pixels_per_inch
operator|>
literal|72
decl_stmt|;
name|int
name|y_mult
init|=
operator|(
name|y_24pin
condition|?
literal|3
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|line_size
init|=
name|gdev_mem_bytes_per_scan_line
argument_list|(
operator|(
name|gx_device
operator|*
operator|)
name|pdev
argument_list|)
decl_stmt|;
name|int
name|in_size
init|=
name|line_size
operator|*
operator|(
literal|8
operator|*
name|y_mult
operator|)
decl_stmt|;
name|byte
modifier|*
name|in
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(in)"
argument_list|)
decl_stmt|;
name|int
name|out_size
init|=
operator|(
operator|(
name|pdev
operator|->
name|width
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
operator|)
operator|*
name|y_mult
decl_stmt|;
name|byte
modifier|*
name|out
init|=
operator|(
name|byte
operator|*
operator|)
name|gs_malloc
argument_list|(
name|out_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(out)"
argument_list|)
decl_stmt|;
name|int
name|x_dpi
init|=
name|pdev
operator|->
name|x_pixels_per_inch
decl_stmt|;
name|char
name|start_graphics
init|=
operator|(
name|y_24pin
condition|?
name|graphics_modes_24
else|:
name|graphics_modes_9
operator|)
index|[
name|x_dpi
operator|/
literal|60
index|]
decl_stmt|;
name|int
name|first_pass
init|=
operator|(
name|start_graphics
operator|&
name|DD
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|last_pass
init|=
name|first_pass
operator|*
literal|2
decl_stmt|;
name|int
name|dots_per_space
init|=
name|x_dpi
operator|/
literal|10
decl_stmt|;
comment|/* pica space = 1/10" */
name|int
name|bytes_per_space
init|=
name|dots_per_space
operator|*
name|y_mult
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|,
name|lnum
init|=
literal|0
decl_stmt|,
name|pass
decl_stmt|;
comment|/* Check allocations */
if|if
condition|(
name|in
operator|==
literal|0
operator|||
name|out
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in
condition|)
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
name|in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(in)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
name|out_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(out)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize the printer and reset the margins. */
name|fwrite
argument_list|(
literal|"\033@\033P\033l\000\r\033Q"
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pdev
operator|->
name|width
operator|/
name|pdev
operator|->
name|x_pixels_per_inch
operator|*
literal|10
argument_list|)
operator|+
literal|2
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* Print lines of graphics */
while|while
condition|(
name|lnum
operator|<
name|pdev
operator|->
name|height
condition|)
block|{
name|byte
modifier|*
name|inp
init|=
name|in
decl_stmt|;
name|byte
modifier|*
name|in_end
init|=
name|in
operator|+
name|line_size
decl_stmt|;
name|byte
modifier|*
name|out_end
init|=
name|out
decl_stmt|;
name|byte
modifier|*
name|out_blk
decl_stmt|;
specifier|register
name|byte
modifier|*
name|outp
decl_stmt|;
name|int
name|lcnt
decl_stmt|;
comment|/* Copy 1 scan line and test for all zero. */
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|lnum
argument_list|,
name|in
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|in
operator|+
literal|1
argument_list|,
name|line_size
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lnum
operator|++
expr_stmt|;
name|skip
operator|+=
literal|3
operator|/
name|y_mult
expr_stmt|;
continue|continue;
block|}
comment|/* Vertical tab to the appropriate position. */
while|while
condition|(
name|skip
operator|>
literal|255
condition|)
block|{
name|fputs
argument_list|(
literal|"\033J\377"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|skip
operator|-=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033J%c"
argument_list|,
name|skip
argument_list|)
expr_stmt|;
comment|/* Copy the rest of the scan lines. */
name|lcnt
operator|=
literal|1
operator|+
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|lnum
operator|+
literal|1
argument_list|,
name|in
operator|+
name|line_size
argument_list|,
name|in_size
operator|-
name|line_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
literal|8
operator|*
name|y_mult
condition|)
name|memset
argument_list|(
name|in
operator|+
name|lcnt
operator|*
name|line_size
argument_list|,
literal|0
argument_list|,
name|in_size
operator|-
name|lcnt
operator|*
name|line_size
argument_list|)
expr_stmt|;
comment|/* We have to 'transpose' blocks of 8 pixels x 8 lines, */
comment|/* because that's how the printer wants the data. */
comment|/* If we are in a 24-pin mode, we have to transpose */
comment|/* groups of 3 lines at a time. */
if|if
condition|(
name|y_24pin
condition|)
block|{
for|for
control|(
init|;
name|inp
operator|<
name|in_end
condition|;
name|inp
operator|++
operator|,
name|out_end
operator|+=
literal|24
control|)
block|{
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
argument_list|,
name|line_size
argument_list|,
name|out_end
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
operator|+
name|line_size
operator|*
literal|8
argument_list|,
name|line_size
argument_list|,
name|out_end
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
operator|+
name|line_size
operator|*
literal|16
argument_list|,
name|line_size
argument_list|,
name|out_end
operator|+
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Remove trailing 0s. */
while|while
condition|(
name|out_end
operator|>
name|out
operator|&&
name|out_end
index|[
operator|-
literal|1
index|]
operator|==
literal|0
operator|&&
name|out_end
index|[
operator|-
literal|2
index|]
operator|==
literal|0
operator|&&
name|out_end
index|[
operator|-
literal|3
index|]
operator|==
literal|0
condition|)
name|out_end
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|inp
operator|<
name|in_end
condition|;
name|inp
operator|++
operator|,
name|out_end
operator|+=
literal|8
control|)
block|{
name|gdev_prn_transpose_8x8
argument_list|(
name|inp
argument_list|,
name|line_size
argument_list|,
name|out_end
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Remove trailing 0s. */
while|while
condition|(
name|out_end
operator|>
name|out
operator|&&
name|out_end
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|out_end
operator|--
expr_stmt|;
block|}
for|for
control|(
name|pass
operator|=
name|first_pass
init|;
name|pass
operator|<=
name|last_pass
condition|;
name|pass
operator|++
control|)
block|{
for|for
control|(
name|out_blk
operator|=
name|outp
operator|=
name|out
init|;
name|outp
operator|<
name|out_end
condition|;
control|)
block|{
comment|/* Skip a run of leading 0s. */
comment|/* At least 10 are needed to make tabbing worth it. */
comment|/* We do everything by 3's to avoid having to make */
comment|/* different cases for 9- and 24-pin. */
if|if
condition|(
operator|*
name|outp
operator|==
literal|0
operator|&&
name|outp
operator|+
literal|12
operator|<=
name|out_end
operator|&&
name|outp
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|outp
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
operator|(
name|outp
index|[
literal|3
index|]
operator||
name|outp
index|[
literal|4
index|]
operator||
name|outp
index|[
literal|5
index|]
operator|)
operator|==
literal|0
operator|&&
operator|(
name|outp
index|[
literal|6
index|]
operator||
name|outp
index|[
literal|7
index|]
operator||
name|outp
index|[
literal|8
index|]
operator|)
operator|==
literal|0
operator|&&
operator|(
name|outp
index|[
literal|9
index|]
operator||
name|outp
index|[
literal|10
index|]
operator||
name|outp
index|[
literal|11
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|byte
modifier|*
name|zp
init|=
name|outp
decl_stmt|;
name|int
name|tpos
decl_stmt|;
name|byte
modifier|*
name|newp
decl_stmt|;
name|outp
operator|+=
literal|12
expr_stmt|;
while|while
condition|(
name|outp
operator|+
literal|3
operator|<=
name|out_end
operator|&&
operator|*
name|outp
operator|==
literal|0
operator|&&
name|outp
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|outp
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|outp
operator|+=
literal|3
expr_stmt|;
name|tpos
operator|=
operator|(
name|outp
operator|-
name|out
operator|)
operator|/
name|bytes_per_space
expr_stmt|;
name|newp
operator|=
name|out
operator|+
name|tpos
operator|*
name|bytes_per_space
expr_stmt|;
if|if
condition|(
name|newp
operator|>
name|zp
operator|+
literal|10
condition|)
block|{
comment|/* Output preceding bit data. */
if|if
condition|(
name|zp
operator|>
name|out_blk
condition|)
comment|/* only false at */
comment|/* beginning of line */
name|eps_output_run
argument_list|(
name|out_blk
argument_list|,
call|(
name|int
call|)
argument_list|(
name|zp
operator|-
name|out_blk
argument_list|)
argument_list|,
name|y_mult
argument_list|,
name|start_graphics
argument_list|,
name|prn_stream
argument_list|,
name|pass
argument_list|)
expr_stmt|;
comment|/* Tab over to the appropriate position. */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033D%c%c\t"
argument_list|,
name|tpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out_blk
operator|=
name|outp
operator|=
name|newp
expr_stmt|;
block|}
block|}
else|else
name|outp
operator|+=
name|y_mult
expr_stmt|;
block|}
if|if
condition|(
name|outp
operator|>
name|out_blk
condition|)
name|eps_output_run
argument_list|(
name|out_blk
argument_list|,
call|(
name|int
call|)
argument_list|(
name|outp
operator|-
name|out_blk
argument_list|)
argument_list|,
name|y_mult
argument_list|,
name|start_graphics
argument_list|,
name|prn_stream
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\r'
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
literal|24
expr_stmt|;
name|lnum
operator|+=
literal|8
operator|*
name|y_mult
expr_stmt|;
block|}
comment|/* Eject the page and reinitialize the printer */
name|fputs
argument_list|(
literal|"\f\033@"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|prn_stream
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|out
argument_list|,
name|out_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(out)"
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|in
argument_list|,
name|in_size
argument_list|,
literal|1
argument_list|,
literal|"eps_print_page(in)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output a single graphics command. */
end_comment

begin_comment
comment|/* pass=0 for all columns, 1 for even columns, 2 for odd columns. */
end_comment

begin_function
name|private
name|void
name|eps_output_run
parameter_list|(
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|y_mult
parameter_list|,
name|char
name|start_graphics
parameter_list|,
name|FILE
modifier|*
name|prn_stream
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|int
name|xcount
init|=
name|count
operator|/
name|y_mult
decl_stmt|;
name|fputc
argument_list|(
literal|033
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|start_graphics
operator|&
operator|~
literal|3
operator|)
condition|)
block|{
name|fputc
argument_list|(
literal|"KLYZ"
index|[
name|start_graphics
index|]
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|start_graphics
operator|&
operator|~
name|DD
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
name|xcount
operator|&
literal|0xff
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|xcount
operator|>>
literal|8
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pass
condition|)
name|fwrite
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only write every other column of y_mult bytes. */
name|int
name|which
init|=
name|pass
decl_stmt|;
name|byte
modifier|*
name|dp
init|=
name|data
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|which
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|y_mult
condition|;
name|j
operator|++
operator|,
name|dp
operator|++
control|)
block|{
name|putc
argument_list|(
operator|(
operator|(
name|which
operator|&
literal|1
operator|)
condition|?
operator|*
name|dp
else|:
literal|0
operator|)
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

