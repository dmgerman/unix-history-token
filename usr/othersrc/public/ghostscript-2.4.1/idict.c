begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* idict.c */
end_comment

begin_comment
comment|/* Dictionaries for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_comment
comment|/* for value cache in names */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_comment
comment|/* for obj_eq */
end_comment

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_comment
comment|/* interface definition */
end_comment

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_comment
comment|/*  * A dictionary is a structure of three elements (refs):  *  *	count - a t_integer whose value says how many entries are  *	occupied (N), and whose size says how many elements the client  *	thinks the dictionary can hold (C).  C may be less than M (see below).  *  *	keys - a t_shortarray or t_array of M+1 elements, containing  *	the keys.  *  *	values - a t_array of M+1 elements, containing the values.  *  * C< M is possible because on 32-bit systems, we round up M so that  * M is a power of 2; this allows us to use masking rather than division  * for computing the initial hash probe.  However, C is always the  * maxlength specified by the client, so clients get a consistent story.  */
end_comment

begin_define
define|#
directive|define
name|dict_round_size
value|(!arch_ints_are_short)
end_define

begin_if
if|#
directive|if
name|dict_round_size
end_if

begin_define
define|#
directive|define
name|hash_mod
parameter_list|(
name|hash
parameter_list|,
name|size
parameter_list|)
value|((hash)& ((size) - 1))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|hash_mod
parameter_list|(
name|hash
parameter_list|,
name|size
parameter_list|)
value|((hash) % (size))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * In the packed form, unused or deleted entries contain packed_key_empty  * or packed_key_deleted respectively; in the unpacked form, unused  * or deleted entries contain a literal or executable null respectively.  * The first entry is always marked as a deleted entry, to avoid a  * special wrap-around check.  *  * Note that if the keys slot in the dictionary is new,  * all the key slots are new (more recent than the last save).  * We use this fact to avoid saving stores into packed keys  * for newly created dictionaries.  */
end_comment

begin_define
define|#
directive|define
name|dict_is_packed
parameter_list|(
name|dct
parameter_list|)
value|r_has_type(&(dct)->keys, t_shortarray)
end_define

begin_define
define|#
directive|define
name|packed_key_empty
value|(pt_tag(pt_integer) + 0)
end_define

begin_define
define|#
directive|define
name|packed_key_deleted
value|(pt_tag(pt_integer) + 1)
end_define

begin_define
define|#
directive|define
name|packed_key_impossible
value|pt_tag(pt_full_ref)
end_define

begin_comment
comment|/* never matches */
end_comment

begin_define
define|#
directive|define
name|packed_name_key
parameter_list|(
name|nidx
parameter_list|)
define|\
value|((nidx)<= packed_max_name_index ? pt_tag(pt_literal_name) + (nidx) :\    packed_key_impossible)
end_define

begin_comment
comment|/*  * Using a special mark for deleted entries causes lookup time to degrade  * as entries are inserted and deleted.  This is not a problem, because  * entries are almost never deleted.  */
end_comment

begin_define
define|#
directive|define
name|d_maxlength
parameter_list|(
name|dct
parameter_list|)
value|r_size(&(dct)->count)
end_define

begin_define
define|#
directive|define
name|d_set_maxlength
parameter_list|(
name|dct
parameter_list|,
name|siz
parameter_list|)
value|r_set_size(&(dct)->count,siz)
end_define

begin_define
define|#
directive|define
name|nslots
parameter_list|(
name|dct
parameter_list|)
value|r_size(&(dct)->values)
end_define

begin_define
define|#
directive|define
name|npairs
parameter_list|(
name|dct
parameter_list|)
value|(nslots(dct) - 1)
end_define

begin_define
define|#
directive|define
name|d_length
parameter_list|(
name|dct
parameter_list|)
value|((uint)((dct)->count.value.intval))
end_define

begin_comment
comment|/* Define the size of the largest valid dictionary. */
end_comment

begin_comment
comment|/* This is limited by the size field of the keys and values refs, */
end_comment

begin_comment
comment|/* and by the enumeration interface, which requires the size to */
end_comment

begin_comment
comment|/* fit in an int. */
end_comment

begin_decl_stmt
specifier|const
name|uint
name|dict_max_size
init|=
name|max_ushort
operator|/
literal|2
operator|-
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define whether dictionaries expand automatically when full. */
end_comment

begin_decl_stmt
name|int
name|dict_auto_expand
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the hashing function for names. */
end_comment

begin_comment
comment|/* We don't have to scramble the index, because */
end_comment

begin_comment
comment|/* indices are assigned in a scattered order (see name_ref in iname.c). */
end_comment

begin_define
define|#
directive|define
name|dict_name_index_hash
parameter_list|(
name|nidx
parameter_list|)
value|(nidx)
end_define

begin_comment
comment|/* Define whether dictionaries are packed by default. */
end_comment

begin_define
define|#
directive|define
name|default_pack
value|1
end_define

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|dict_create_contents
argument_list|(
name|P3
argument_list|(
argument|uint size
argument_list|,
argument|dict *pdict
argument_list|,
argument|int pack
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a dictionary. */
end_comment

begin_function
name|int
name|dict_create
parameter_list|(
name|uint
name|size
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|dict
modifier|*
name|pdict
init|=
operator|(
name|dict
operator|*
operator|)
name|alloc_refs
argument_list|(
sizeof|sizeof
argument_list|(
name|dict
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|,
literal|"dict_create"
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|pdict
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|code
operator|=
name|dict_create_contents
argument_list|(
name|size
argument_list|,
name|pdict
argument_list|,
name|default_pack
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_tav_new
argument_list|(
name|pref
argument_list|,
name|t_dictionary
argument_list|,
name|a_all
argument_list|,
name|pdict
argument_list|,
name|pdict
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|dict_create_unpacked_keys
parameter_list|(
name|uint
name|asize
parameter_list|,
name|dict
modifier|*
name|pdict
parameter_list|)
block|{
name|ref
modifier|*
name|kp
init|=
name|alloc_refs
argument_list|(
name|asize
argument_list|,
literal|"dict_create(keys)"
argument_list|)
decl_stmt|;
name|ref
modifier|*
name|zp
decl_stmt|;
specifier|register
name|uint
name|i
decl_stmt|;
if|if
condition|(
name|kp
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|make_tasv_new
argument_list|(
operator|&
name|pdict
operator|->
name|keys
argument_list|,
name|t_array
argument_list|,
name|a_all
argument_list|,
name|asize
argument_list|,
name|refs
argument_list|,
name|kp
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|kp
operator|,
name|i
operator|=
name|asize
init|;
name|i
condition|;
name|zp
operator|++
operator|,
name|i
operator|--
control|)
name|make_null_new
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|r_set_attrs
argument_list|(
name|kp
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
comment|/* wraparound entry */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|dict_create_contents
parameter_list|(
name|uint
name|size
parameter_list|,
name|dict
modifier|*
name|pdict
parameter_list|,
name|int
name|pack
parameter_list|)
block|{
name|uint
name|csize
init|=
operator|(
name|size
operator|==
literal|0
condition|?
literal|1
else|:
name|size
operator|)
decl_stmt|;
comment|/* client-specified size */
name|uint
name|asize
init|=
name|csize
decl_stmt|;
name|ref
modifier|*
name|vp
decl_stmt|;
specifier|register
name|uint
name|i
decl_stmt|;
name|ref
modifier|*
name|zp
decl_stmt|;
if|#
directive|if
name|dict_round_size
comment|/* Round up the actual allocated size to the next higher */
comment|/* power of 2, so we can use& instead of %. */
while|while
condition|(
name|asize
operator|&
operator|(
name|asize
operator|-
literal|1
operator|)
condition|)
name|asize
operator|=
operator|(
name|asize
operator||
operator|(
name|asize
operator|>>
literal|1
operator|)
operator|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
name|asize
operator|++
expr_stmt|;
comment|/* allow room for wraparound entry */
name|vp
operator|=
name|alloc_refs
argument_list|(
name|asize
argument_list|,
literal|"dict_create(values)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|make_tasv_new
argument_list|(
operator|&
name|pdict
operator|->
name|values
argument_list|,
name|t_array
argument_list|,
name|a_all
argument_list|,
name|asize
argument_list|,
name|refs
argument_list|,
name|vp
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|vp
operator|,
name|i
operator|=
name|asize
init|;
name|i
condition|;
name|zp
operator|++
operator|,
name|i
operator|--
control|)
name|make_null_new
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
condition|)
block|{
name|uint
name|ksize
init|=
operator|(
name|asize
operator|+
name|packed_per_ref
operator|-
literal|1
operator|)
operator|/
name|packed_per_ref
decl_stmt|;
name|ref_packed
modifier|*
name|pkp
init|=
operator|(
name|ref_packed
operator|*
operator|)
name|alloc_refs
argument_list|(
name|ksize
argument_list|,
literal|"dict_create(packed keys)"
argument_list|)
decl_stmt|;
name|ref_packed
modifier|*
name|pzp
decl_stmt|;
name|make_tasv_new
argument_list|(
operator|&
name|pdict
operator|->
name|keys
argument_list|,
name|t_shortarray
argument_list|,
name|a_all
argument_list|,
name|asize
argument_list|,
name|packed
argument_list|,
name|pkp
argument_list|)
expr_stmt|;
for|for
control|(
name|pzp
operator|=
name|pkp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asize
operator|||
name|i
operator|%
name|packed_per_ref
condition|;
name|pzp
operator|++
operator|,
name|i
operator|++
control|)
operator|*
name|pzp
operator|=
name|packed_key_empty
expr_stmt|;
operator|*
name|pkp
operator|=
name|packed_key_deleted
expr_stmt|;
comment|/* wraparound entry */
block|}
else|else
comment|/* not packed */
block|{
name|int
name|code
init|=
name|dict_create_unpacked_keys
argument_list|(
name|asize
argument_list|,
name|pdict
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
name|make_tv_new
argument_list|(
operator|&
name|pdict
operator|->
name|count
argument_list|,
name|t_integer
argument_list|,
name|intval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d_set_maxlength
argument_list|(
name|pdict
argument_list|,
name|csize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Define a macro for searching a packed dictionary.  Free variables:  *	ref_packed kpack - holds the packed key.  *	uint hash - holds the hash of the name.  *	dict *pdict - points to the dictionary.  *	uint size - holds npairs(pdict).  *	int wrap - counts wraparounds, initialized to 0.  * Note that the macro is *not* enclosed in {}, so that we can access  * the values of kbot and kp after leaving the loop.  */
end_comment

begin_define
define|#
directive|define
name|packed_search
parameter_list|(
name|del
parameter_list|,
name|pre
parameter_list|,
name|post
parameter_list|)
define|\
value|int wrap = 0;\    ref_packed *kbot = pdict->keys.value.packed;\    register ref_packed *kp;\    for ( kp = kbot + hash_mod(hash, size) + 2; ; )\     { if ( *--kp == kpack )\        { pre (pdict->values.value.refs + (kp - kbot));\ 	 post;\        }\       else if ( !packed_ref_is_name(kp) )\        {
comment|/* Empty, deleted, or wraparound. Figure out which. */
value|\ 	 if ( *kp == packed_key_empty ) break;\ 	 if ( kp == kbot )
comment|/* wrap */
value|\ 	  { if ( wrap++ ) break;
comment|/* 2 wraps */
value|\ 	    kp += size + 1;\ 	  }\ 	 else { del; }\        }\     }
end_define

begin_comment
comment|/*  * Look up in a stack of dictionaries.  Store a pointer to the value slot  * where found, or to the (value) slot for inserting.  * Return 1 if found, 0 if not and there is room for a new entry in  * the top dictionary on the stack, or e_dictfull if the top dictionary  * is full and the key is missing.  * Note that pdbot<= pdtop, and the search starts at pdtop.  */
end_comment

begin_function
name|int
name|dict_lookup
parameter_list|(
specifier|const
name|ref
modifier|*
name|pdbot
parameter_list|,
specifier|const
name|ref
modifier|*
name|pdtop
parameter_list|,
specifier|const
name|ref
modifier|*
name|pkey
parameter_list|,
name|ref
modifier|*
modifier|*
name|ppvalue
comment|/* result is stored here */
parameter_list|)
block|{
specifier|const
name|ref
modifier|*
name|pdref
init|=
name|pdtop
decl_stmt|;
name|name
modifier|*
name|kpname
decl_stmt|;
name|uint
name|nidx
decl_stmt|;
name|ref_packed
name|kpack
decl_stmt|;
name|uint
name|hash
decl_stmt|;
name|int
name|ktype
decl_stmt|;
name|int
name|full
init|=
literal|1
decl_stmt|;
comment|/* gets set to 0 or e_dictfull */
comment|/* Compute hash.  The only types we bother with are strings, */
comment|/* names, and (unlikely, but worth checking for) integers. */
switch|switch
condition|(
name|r_type
argument_list|(
name|pkey
argument_list|)
condition|)
block|{
case|case
name|t_name
case|:
name|kpname
operator|=
name|pkey
operator|->
name|value
operator|.
name|pname
expr_stmt|;
name|nh
label|:
name|nidx
operator|=
name|kpname
operator|->
name|index
expr_stmt|;
name|hash
operator|=
name|dict_name_index_hash
argument_list|(
name|nidx
argument_list|)
expr_stmt|;
name|kpack
operator|=
name|packed_name_key
argument_list|(
name|nidx
argument_list|)
expr_stmt|;
name|ktype
operator|=
name|t_name
expr_stmt|;
break|break;
case|case
name|t_string
case|:
comment|/* convert to a name first */
block|{
name|ref
name|nref
decl_stmt|;
name|int
name|code
init|=
name|name_ref
argument_list|(
name|pkey
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|pkey
argument_list|)
argument_list|,
operator|&
name|nref
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|kpname
operator|=
name|nref
operator|.
name|value
operator|.
name|pname
expr_stmt|;
block|}
goto|goto
name|nh
goto|;
case|case
name|t_integer
case|:
name|hash
operator|=
operator|(
name|uint
operator|)
name|pkey
operator|->
name|value
operator|.
name|intval
operator|*
literal|30503
expr_stmt|;
name|kpack
operator|=
name|packed_key_impossible
expr_stmt|;
name|ktype
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|hash
operator|=
name|r_btype
argument_list|(
name|pkey
argument_list|)
operator|*
literal|99
expr_stmt|;
comment|/* yech */
name|kpack
operator|=
name|packed_key_impossible
expr_stmt|;
name|ktype
operator|=
operator|-
literal|1
expr_stmt|;
block|}
do|do
block|{
name|dict
modifier|*
name|pdict
init|=
name|pdref
operator|->
name|value
operator|.
name|pdict
decl_stmt|;
name|uint
name|size
init|=
name|npairs
argument_list|(
name|pdict
argument_list|)
decl_stmt|;
name|int
name|wrap
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|etype
decl_stmt|;
comment|/* Search the dictionary */
if|if
condition|(
name|dict_is_packed
argument_list|(
name|pdict
argument_list|)
condition|)
block|{
name|ref_packed
modifier|*
name|pslot
init|=
literal|0
decl_stmt|;
name|packed_search
argument_list|(
argument|if ( pslot ==
literal|0
argument|) pslot = kp
argument_list|,
argument|*ppvalue =
argument_list|,
argument|return
literal|1
argument_list|)
empty_stmt|;
if|if
condition|(
name|full
operator|>
literal|0
condition|)
comment|/* first dictionary */
block|{
if|if
condition|(
name|pslot
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|wrap
operator|==
literal|2
condition|)
name|full
operator|=
name|e_dictfull
expr_stmt|;
else|else
operator|*
name|ppvalue
operator|=
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
name|kp
operator|-
name|kbot
operator|)
operator|,
name|full
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|ppvalue
operator|=
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
name|pslot
operator|-
name|kbot
operator|)
operator|,
name|full
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ref
modifier|*
name|kbot
init|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
decl_stmt|;
specifier|register
name|ref
modifier|*
name|kp
decl_stmt|;
name|ref
modifier|*
name|pslot
init|=
literal|0
decl_stmt|;
for|for
control|(
name|kp
operator|=
name|kbot
operator|+
name|hash_mod
argument_list|(
name|hash
argument_list|,
name|size
argument_list|)
operator|+
literal|2
init|;
condition|;
control|)
block|{
operator|--
name|kp
expr_stmt|;
if|if
condition|(
operator|(
name|etype
operator|=
name|r_type
argument_list|(
name|kp
argument_list|)
operator|)
operator|==
name|ktype
condition|)
block|{
comment|/* Fast comparison if both keys are names */
if|if
condition|(
name|kp
operator|->
name|value
operator|.
name|pname
operator|==
name|kpname
condition|)
block|{
operator|*
name|ppvalue
operator|=
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
name|kp
operator|-
name|kbot
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|etype
operator|==
name|t_null
condition|)
block|{
comment|/* Empty, deleted, or wraparound. */
comment|/* Figure out which. */
if|if
condition|(
name|kp
operator|==
name|kbot
condition|)
comment|/* wrap */
block|{
if|if
condition|(
name|wrap
operator|++
condition|)
comment|/* wrapped twice */
block|{
if|if
condition|(
name|full
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pslot
operator|!=
literal|0
condition|)
break|break;
name|full
operator|=
name|e_dictfull
expr_stmt|;
block|}
goto|goto
name|next_dict
goto|;
block|}
name|kp
operator|+=
name|size
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_has_attr
argument_list|(
name|kp
argument_list|,
name|a_executable
argument_list|)
condition|)
block|{
comment|/* Deleted entry, save the slot. */
if|if
condition|(
name|pslot
operator|==
literal|0
condition|)
name|pslot
operator|=
name|kp
expr_stmt|;
block|}
else|else
comment|/* key not found */
break|break;
block|}
else|else
block|{
if|if
condition|(
name|obj_eq
argument_list|(
name|kp
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
operator|*
name|ppvalue
operator|=
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
name|kp
operator|-
name|kbot
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|full
operator|>
literal|0
condition|)
block|{
operator|*
name|ppvalue
operator|=
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
operator|(
name|pslot
operator|!=
literal|0
condition|?
name|pslot
else|:
name|kp
operator|)
operator|-
name|kbot
operator|)
expr_stmt|;
name|full
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|next_dict
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|--
name|pdref
operator|>=
name|pdbot
condition|)
do|;
return|return
name|full
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a name on the dictionary stack.  * Return the pointer to the value if found, 0 if not.  * This is just an optimization of dict_lookup with a different interface.  */
end_comment

begin_function
name|ref
modifier|*
name|dict_find_name
parameter_list|(
name|ref
modifier|*
name|pname
parameter_list|)
block|{
name|ds_ptr
name|pdref
init|=
name|dsp
decl_stmt|;
name|name
modifier|*
name|kpname
init|=
name|pname
operator|->
name|value
operator|.
name|pname
decl_stmt|;
name|uint
name|nidx
init|=
name|kpname
operator|->
name|index
decl_stmt|;
name|uint
name|hash
init|=
name|dict_name_index_hash
argument_list|(
name|nidx
argument_list|)
decl_stmt|;
name|ref_packed
name|kpack
init|=
name|packed_name_key
argument_list|(
name|nidx
argument_list|)
decl_stmt|;
name|int
name|wrap
init|=
literal|0
decl_stmt|;
do|do
block|{
name|dict
modifier|*
name|pdict
init|=
name|pdref
operator|->
name|value
operator|.
name|pdict
decl_stmt|;
name|uint
name|size
init|=
name|npairs
argument_list|(
name|pdict
argument_list|)
decl_stmt|;
if|if
condition|(
name|dict_is_packed
argument_list|(
name|pdict
argument_list|)
condition|)
block|{
name|packed_search
argument_list|(
literal|0
argument_list|,
argument|return
argument_list|,
literal|0
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|ref
modifier|*
name|kbot
init|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
decl_stmt|;
specifier|register
name|ref
modifier|*
name|kp
decl_stmt|;
comment|/* Search the dictionary */
for|for
control|(
name|kp
operator|=
name|kbot
operator|+
name|hash_mod
argument_list|(
name|hash
argument_list|,
name|size
argument_list|)
operator|+
literal|2
init|;
condition|;
control|)
block|{
operator|--
name|kp
expr_stmt|;
if|if
condition|(
name|r_has_type
argument_list|(
name|kp
argument_list|,
name|t_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|kp
operator|->
name|value
operator|.
name|pname
operator|==
name|kpname
condition|)
return|return
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
name|kp
operator|-
name|kbot
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|r_has_type
argument_list|(
name|kp
argument_list|,
name|t_null
argument_list|)
condition|)
block|{
comment|/* Empty, deleted, or wraparound. */
comment|/* Figure out which. */
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|kp
argument_list|,
name|a_executable
argument_list|)
condition|)
break|break;
if|if
condition|(
name|kp
operator|==
name|kbot
condition|)
comment|/* wrap */
block|{
if|if
condition|(
name|wrap
operator|++
condition|)
break|break;
comment|/* 2 wraps */
name|kp
operator|+=
name|size
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
do|while
condition|(
operator|--
name|pdref
operator|>=
name|dstack
condition|)
do|;
return|return
operator|(
name|ref
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a key-value pair in a dictionary.  * The caller is responsible for ensuring key is not a null.  * Return 0, e_dictfull, or e_VMerror if the key was a string  * and a VMerror occurred when converting it to a name.  */
end_comment

begin_function
name|int
name|dict_put
parameter_list|(
name|ref
modifier|*
name|pdref
comment|/* t_dictionary */
parameter_list|,
specifier|const
name|ref
modifier|*
name|pkey
parameter_list|,
specifier|const
name|ref
modifier|*
name|pvalue
parameter_list|)
block|{
name|ref
modifier|*
name|pvslot
decl_stmt|;
name|top
label|:
if|if
condition|(
name|dict_find
argument_list|(
name|pdref
argument_list|,
name|pkey
argument_list|,
operator|&
name|pvslot
argument_list|)
operator|<=
literal|0
condition|)
comment|/* not found */
block|{
comment|/* Check for overflow */
name|dict
modifier|*
name|pdict
init|=
name|pdref
operator|->
name|value
operator|.
name|pdict
decl_stmt|;
name|ref
name|kname
decl_stmt|;
name|uint
name|index
init|=
name|pvslot
operator|-
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
decl_stmt|;
if|if
condition|(
name|d_length
argument_list|(
name|pdict
argument_list|)
operator|==
name|npairs
argument_list|(
name|pdict
argument_list|)
condition|)
block|{
name|int
name|code
decl_stmt|;
name|ulong
name|new_size
decl_stmt|;
if|if
condition|(
operator|!
name|dict_auto_expand
condition|)
return|return
name|e_dictfull
return|;
name|new_size
operator|=
operator|(
name|ulong
operator|)
name|npairs
argument_list|(
name|pdict
argument_list|)
operator|*
literal|3
operator|/
literal|2
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|new_size
operator|>
name|dict_max_size
condition|)
block|{
if|if
condition|(
name|npairs
argument_list|(
name|pdict
argument_list|)
operator|>=
name|dict_max_size
condition|)
return|return
name|e_dictfull
return|;
name|new_size
operator|=
name|dict_max_size
expr_stmt|;
block|}
name|code
operator|=
name|dict_resize
argument_list|(
name|pdref
argument_list|,
operator|(
name|uint
operator|)
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
goto|goto
name|top
goto|;
comment|/* keep things simple */
block|}
comment|/* If the key is a string, convert it to a name. */
if|if
condition|(
name|r_has_type
argument_list|(
name|pkey
argument_list|,
name|t_string
argument_list|)
condition|)
block|{
name|int
name|code
init|=
name|name_from_string
argument_list|(
name|pkey
argument_list|,
operator|&
name|kname
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pkey
operator|=
operator|&
name|kname
expr_stmt|;
block|}
if|if
condition|(
name|dict_is_packed
argument_list|(
name|pdict
argument_list|)
condition|)
block|{
name|ref_packed
modifier|*
name|kp
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pkey
argument_list|,
name|t_name
argument_list|)
operator|||
name|name_index
argument_list|(
name|pkey
argument_list|)
operator|>
name|packed_max_name_index
condition|)
block|{
comment|/* Change to unpacked representation. */
comment|/* We can't just use dict_resize, */
comment|/* because the values slots mustn't move. */
name|uint
name|count
init|=
name|nslots
argument_list|(
name|pdict
argument_list|)
decl_stmt|;
name|ref_packed
modifier|*
name|old_keys
init|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|packed
decl_stmt|;
name|int
name|code
decl_stmt|;
name|ref
modifier|*
name|nkp
decl_stmt|;
if|if
condition|(
name|alloc_save_new_mask
condition|)
name|alloc_save_change
argument_list|(
operator|&
name|pdict
operator|->
name|keys
argument_list|,
literal|"dict_unpack(keys)"
argument_list|)
expr_stmt|;
name|code
operator|=
name|dict_create_unpacked_keys
argument_list|(
name|count
argument_list|,
name|pdict
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
for|for
control|(
name|kp
operator|=
name|old_keys
operator|,
name|nkp
operator|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
init|;
name|count
operator|--
condition|;
name|kp
operator|++
operator|,
name|nkp
operator|++
control|)
if|if
condition|(
name|packed_ref_is_name
argument_list|(
name|kp
argument_list|)
condition|)
name|packed_get
argument_list|(
name|kp
argument_list|,
name|nkp
argument_list|)
expr_stmt|;
name|alloc_free_refs
argument_list|(
operator|(
name|ref
operator|*
operator|)
name|old_keys
argument_list|,
operator|(
name|count
operator|+
name|packed_per_ref
operator|-
literal|1
operator|)
operator|/
name|packed_per_ref
argument_list|,
literal|"dict_unpack(old keys)"
argument_list|)
expr_stmt|;
return|return
name|dict_put
argument_list|(
name|pdref
argument_list|,
name|pkey
argument_list|,
name|pvalue
argument_list|)
return|;
block|}
name|kp
operator|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|packed
operator|+
name|index
expr_stmt|;
if|if
condition|(
name|alloc_save_new_mask
operator|&&
operator|!
name|r_has_attr
argument_list|(
operator|&
name|pdict
operator|->
name|keys
argument_list|,
name|l_new
argument_list|)
condition|)
block|{
comment|/* See initial comment for why it is safe */
comment|/* not to save the change if the keys */
comment|/* array itself is new. */
name|alloc_save_change
argument_list|(
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
name|index
operator|/
name|packed_per_ref
operator|)
argument_list|,
literal|"dict_put(key)"
argument_list|)
expr_stmt|;
block|}
operator|*
name|kp
operator|=
name|pt_tag
argument_list|(
name|pt_literal_name
argument_list|)
operator|+
name|name_index
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ref
modifier|*
name|kp
init|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
operator|+
name|index
decl_stmt|;
name|if_debug2
argument_list|(
literal|'d'
argument_list|,
literal|"[d]%lx fill key %lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|pdict
argument_list|,
operator|(
name|ulong
operator|)
name|kp
argument_list|)
expr_stmt|;
name|ref_assign_old
argument_list|(
name|kp
argument_list|,
name|pkey
argument_list|,
literal|"dict_put(key)"
argument_list|)
expr_stmt|;
comment|/* set key of pair */
block|}
name|ref_save
argument_list|(
operator|&
name|pdict
operator|->
name|count
argument_list|,
literal|"dict_put(count)"
argument_list|)
expr_stmt|;
name|pdict
operator|->
name|count
operator|.
name|value
operator|.
name|intval
operator|++
expr_stmt|;
comment|/* If the key is a name, update its 1-element cache. */
if|if
condition|(
name|r_has_type
argument_list|(
name|pkey
argument_list|,
name|t_name
argument_list|)
condition|)
block|{
name|name
modifier|*
name|pname
init|=
name|pkey
operator|->
name|value
operator|.
name|pname
decl_stmt|;
if|if
condition|(
name|pname
operator|->
name|pvalue
operator|==
name|pv_no_defn
operator|&&
operator|(
name|pdict
operator|==
name|systemdict
operator|.
name|value
operator|.
name|pdict
operator|||
name|pdict
operator|==
name|userdict
operator|.
name|value
operator|.
name|pdict
operator|)
operator|&&
comment|/* Only set the cache if we aren't inside */
comment|/* a save.  This way, we never have to */
comment|/* undo setting the cache. */
name|alloc_save_level
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* Set the cache */
name|pname
operator|->
name|pvalue
operator|=
name|pvslot
expr_stmt|;
block|}
else|else
comment|/* The cache is worthless */
name|pname
operator|->
name|pvalue
operator|=
name|pv_other
expr_stmt|;
block|}
block|}
name|if_debug6
argument_list|(
literal|'d'
argument_list|,
literal|"[d]in %lx put %lx: %lx %lx -> %lx %lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|pdref
operator|->
name|value
operator|.
name|pdict
argument_list|,
operator|(
name|ulong
operator|)
name|pvslot
argument_list|,
operator|(
operator|(
name|ulong
operator|*
operator|)
name|pvslot
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|ulong
operator|*
operator|)
name|pvslot
operator|)
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|ulong
operator|*
operator|)
name|pvalue
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|ulong
operator|*
operator|)
name|pvalue
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ref_assign_old
argument_list|(
name|pvslot
argument_list|,
name|pvalue
argument_list|,
literal|"dict_put(value)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove an element from a dictionary. */
end_comment

begin_function
name|int
name|dict_undef
parameter_list|(
name|ref
modifier|*
name|pdref
parameter_list|,
specifier|const
name|ref
modifier|*
name|pkey
parameter_list|)
block|{
name|ref
modifier|*
name|pvslot
decl_stmt|;
name|dict
modifier|*
name|pdict
decl_stmt|;
name|uint
name|index
decl_stmt|;
if|if
condition|(
name|dict_find
argument_list|(
name|pdref
argument_list|,
name|pkey
argument_list|,
operator|&
name|pvslot
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|e_undefined
return|;
comment|/* Remove the entry from the dictionary. */
name|pdict
operator|=
name|pdref
operator|->
name|value
operator|.
name|pdict
expr_stmt|;
name|index
operator|=
name|pvslot
operator|-
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
expr_stmt|;
if|if
condition|(
name|dict_is_packed
argument_list|(
name|pdict
argument_list|)
condition|)
block|{
name|ref_packed
modifier|*
name|pkp
init|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|packed
operator|+
name|index
decl_stmt|;
comment|/* Since packed arrays don't have room for a saved bit, */
comment|/* always save the entire ref containing this key. */
comment|/* This wastes a little space, but undef is rare. */
comment|/* See the initial comment for why it is safe not to save */
comment|/* the change if the keys array itself is new. */
if|if
condition|(
name|alloc_save_new_mask
operator|&&
operator|!
name|r_has_attr
argument_list|(
operator|&
name|pdict
operator|->
name|keys
argument_list|,
name|l_new
argument_list|)
condition|)
name|alloc_save_change
argument_list|(
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
operator|+
operator|(
name|index
operator|/
name|packed_per_ref
operator|)
argument_list|,
literal|"dict_undef(key)"
argument_list|)
expr_stmt|;
comment|/* Accumulating deleted entries slows down lookup. */
comment|/* Detect the easy case where we can use an empty entry */
comment|/* rather than a deleted one, namely, when the next entry */
comment|/* in the probe order is empty. */
if|if
condition|(
name|pkp
index|[
operator|-
literal|1
index|]
operator|==
name|packed_key_empty
condition|)
operator|*
name|pkp
operator|=
name|packed_key_empty
expr_stmt|;
else|else
operator|*
name|pkp
operator|=
name|packed_key_deleted
expr_stmt|;
block|}
else|else
comment|/* not packed */
block|{
name|ref
modifier|*
name|kp
init|=
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
operator|+
name|index
decl_stmt|;
name|make_null_old
argument_list|(
name|kp
argument_list|,
literal|"dict_undef(key)"
argument_list|)
expr_stmt|;
comment|/* Accumulating deleted entries slows down lookup. */
comment|/* Detect the easy case where we can use an empty entry */
comment|/* rather than a deleted one, namely, when the next entry */
comment|/* in the probe order is empty. */
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|kp
operator|-
literal|1
argument_list|,
name|t_null
argument_list|)
operator|||
comment|/* full entry */
name|r_has_attr
argument_list|(
name|kp
operator|-
literal|1
argument_list|,
name|a_executable
argument_list|)
comment|/* deleted or wraparound */
condition|)
name|r_set_attrs
argument_list|(
name|kp
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
comment|/* mark as deleted */
block|}
name|ref_save
argument_list|(
operator|&
name|pdict
operator|->
name|count
argument_list|,
literal|"dict_undef(count)"
argument_list|)
expr_stmt|;
name|pdict
operator|->
name|count
operator|.
name|value
operator|.
name|intval
operator|--
expr_stmt|;
comment|/* If the key is a name, update its 1-element cache. */
if|if
condition|(
name|r_has_type
argument_list|(
name|pkey
argument_list|,
name|t_name
argument_list|)
condition|)
block|{
name|name
modifier|*
name|pname
init|=
name|pkey
operator|->
name|value
operator|.
name|pname
decl_stmt|;
if|if
condition|(
name|pv_valid
argument_list|(
name|pname
operator|->
name|pvalue
argument_list|)
operator|&&
operator|(
name|pdict
operator|==
name|systemdict
operator|.
name|value
operator|.
name|pdict
operator|||
name|pdict
operator|==
name|userdict
operator|.
name|value
operator|.
name|pdict
operator|)
condition|)
block|{
comment|/* Clear the cache */
name|pname
operator|->
name|pvalue
operator|=
name|pv_no_defn
expr_stmt|;
block|}
block|}
name|make_null_old
argument_list|(
name|pvslot
argument_list|,
literal|"dict_undef(value)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the number of elements in a dictionary. */
end_comment

begin_function
name|uint
name|dict_length
parameter_list|(
specifier|const
name|ref
modifier|*
name|pdref
comment|/* t_dictionary */
parameter_list|)
block|{
return|return
name|d_length
argument_list|(
name|pdref
operator|->
name|value
operator|.
name|pdict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the capacity of a dictionary. */
end_comment

begin_function
name|uint
name|dict_maxlength
parameter_list|(
specifier|const
name|ref
modifier|*
name|pdref
comment|/* t_dictionary */
parameter_list|)
block|{
return|return
name|d_maxlength
argument_list|(
name|pdref
operator|->
name|value
operator|.
name|pdict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy one dictionary into another. */
end_comment

begin_function
name|int
name|dict_copy
parameter_list|(
specifier|const
name|ref
modifier|*
name|pdrfrom
comment|/* t_dictionary */
parameter_list|,
name|ref
modifier|*
name|pdrto
comment|/* t_dictionary */
parameter_list|)
block|{
name|int
name|index
init|=
name|dict_first
argument_list|(
name|pdrfrom
argument_list|)
decl_stmt|;
name|ref
name|elt
index|[
literal|2
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
while|while
condition|(
operator|(
name|index
operator|=
name|dict_next
argument_list|(
name|pdrfrom
argument_list|,
name|index
argument_list|,
name|elt
argument_list|)
operator|)
operator|>=
literal|0
condition|)
if|if
condition|(
operator|(
name|code
operator|=
name|dict_put
argument_list|(
name|pdrto
argument_list|,
operator|&
name|elt
index|[
literal|0
index|]
argument_list|,
operator|&
name|elt
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Resize a dictionary. */
end_comment

begin_function
name|int
name|dict_resize
parameter_list|(
name|ref
modifier|*
name|pdrfrom
parameter_list|,
name|uint
name|new_size
parameter_list|)
block|{
name|dict
modifier|*
name|pdict
init|=
name|pdrfrom
operator|->
name|value
operator|.
name|pdict
decl_stmt|;
name|uint
name|count
init|=
name|nslots
argument_list|(
name|pdict
argument_list|)
decl_stmt|;
name|dict
name|dnew
decl_stmt|;
name|ref
name|drto
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|new_size
operator|<
name|d_length
argument_list|(
name|pdict
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|dict_auto_expand
condition|)
return|return
name|e_dictfull
return|;
name|new_size
operator|=
name|d_length
argument_list|(
name|pdict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|=
name|dict_create_contents
argument_list|(
name|new_size
argument_list|,
operator|&
name|dnew
argument_list|,
name|dict_is_packed
argument_list|(
name|pdict
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_tav_new
argument_list|(
operator|&
name|drto
argument_list|,
name|t_dictionary
argument_list|,
name|a_all
argument_list|,
name|pdict
argument_list|,
operator|&
name|dnew
argument_list|)
expr_stmt|;
name|dict_copy
argument_list|(
name|pdrfrom
argument_list|,
operator|&
name|drto
argument_list|)
expr_stmt|;
comment|/* can't fail */
comment|/* Free the old dictionary */
name|alloc_free_refs
argument_list|(
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
argument_list|,
name|count
argument_list|,
literal|"dict_resize(old values)"
argument_list|)
expr_stmt|;
name|alloc_free_refs
argument_list|(
name|pdict
operator|->
name|keys
operator|.
name|value
operator|.
name|refs
argument_list|,
operator|(
name|dict_is_packed
argument_list|(
name|pdict
argument_list|)
condition|?
operator|(
name|count
operator|+
name|packed_per_ref
operator|-
literal|1
operator|)
operator|/
name|packed_per_ref
else|:
name|count
operator|)
argument_list|,
literal|"dict_resize(old keys)"
argument_list|)
expr_stmt|;
name|ref_assign_old
argument_list|(
operator|&
name|pdict
operator|->
name|keys
argument_list|,
operator|&
name|dnew
operator|.
name|keys
argument_list|,
literal|"dict_resize(keys)"
argument_list|)
expr_stmt|;
name|ref_assign_old
argument_list|(
operator|&
name|pdict
operator|->
name|values
argument_list|,
operator|&
name|dnew
operator|.
name|values
argument_list|,
literal|"dict_resize(values)"
argument_list|)
expr_stmt|;
name|ref_save
argument_list|(
operator|&
name|pdict
operator|->
name|count
argument_list|,
literal|"dict_resize(size)"
argument_list|)
expr_stmt|;
name|d_set_maxlength
argument_list|(
name|pdict
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prepare to enumerate a dictionary. */
end_comment

begin_function
name|int
name|dict_first
parameter_list|(
specifier|const
name|ref
modifier|*
name|pdref
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|nslots
argument_list|(
name|pdref
operator|->
name|value
operator|.
name|pdict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Enumerate the next element of a dictionary. */
end_comment

begin_function
name|int
name|dict_next
parameter_list|(
specifier|const
name|ref
modifier|*
name|pdref
parameter_list|,
name|int
name|index
parameter_list|,
name|ref
modifier|*
name|eltp
comment|/* ref eltp[2] */
parameter_list|)
block|{
name|dict
modifier|*
name|pdict
init|=
name|pdref
operator|->
name|value
operator|.
name|pdict
decl_stmt|;
name|ref
modifier|*
name|vp
init|=
name|pdict
operator|->
name|values
operator|.
name|value
operator|.
name|refs
operator|+
name|index
decl_stmt|;
while|while
condition|(
name|vp
operator|--
operator|,
operator|--
name|index
operator|>=
literal|0
condition|)
block|{
name|array_get
argument_list|(
operator|&
name|pdict
operator|->
name|keys
argument_list|,
operator|(
name|long
operator|)
name|index
argument_list|,
name|eltp
argument_list|)
expr_stmt|;
comment|/* Make sure this is a valid entry. */
if|if
condition|(
name|r_has_type
argument_list|(
name|eltp
argument_list|,
name|t_name
argument_list|)
operator|||
operator|(
operator|!
name|dict_is_packed
argument_list|(
name|pdict
argument_list|)
operator|&&
operator|!
name|r_has_type
argument_list|(
name|eltp
argument_list|,
name|t_null
argument_list|)
operator|)
condition|)
block|{
name|eltp
index|[
literal|1
index|]
operator|=
operator|*
name|vp
expr_stmt|;
return|return
name|index
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|/* no more elements */
block|}
end_function

end_unit

