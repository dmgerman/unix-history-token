begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gspaint.c */
end_comment

begin_comment
comment|/* Painting procedures for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for gs_state */
end_comment

begin_include
include|#
directive|include
file|"gspaint.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_include
include|#
directive|include
file|"gxcpath.h"
end_include

begin_include
include|#
directive|include
file|"gxdevmem.h"
end_include

begin_include
include|#
directive|include
file|"gximage.h"
end_include

begin_comment
comment|/* Erase the page */
end_comment

begin_function
name|int
name|gs_erasepage
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|device
modifier|*
name|pdev
init|=
name|pgs
operator|->
name|device
decl_stmt|;
name|gx_device
modifier|*
name|dev
init|=
name|pdev
operator|->
name|info
decl_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|fill_rectangle
call|)
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dev
operator|->
name|width
argument_list|,
name|dev
operator|->
name|height
argument_list|,
name|pdev
operator|->
name|white
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fill using the winding number rule */
end_comment

begin_function
name|int
name|gs_fill
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|gs_fill_adjust
argument_list|(
name|pgs
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is a hack, see gx_fill_path and gs_type1_interpret. */
end_comment

begin_function
name|int
name|gs_fill_adjust
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|fixed
name|adjust
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
comment|/* If we're inside a charpath, just merge the current path */
comment|/* into the parent's path. */
if|if
condition|(
name|pgs
operator|->
name|in_charpath
condition|)
name|code
operator|=
name|gx_path_add_path
argument_list|(
name|pgs
operator|->
name|saved
operator|->
name|path
argument_list|,
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|gx_color_load
argument_list|(
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|code
operator|=
name|gx_fill_path
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|,
name|gx_rule_winding_number
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
name|gs_newpath
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Fill using the even/odd rule */
end_comment

begin_function
name|int
name|gs_eofill
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
comment|/* If we're inside a charpath, just merge the current path */
comment|/* into the parent's path. */
if|if
condition|(
name|pgs
operator|->
name|in_charpath
condition|)
name|code
operator|=
name|gx_path_add_path
argument_list|(
name|pgs
operator|->
name|saved
operator|->
name|path
argument_list|,
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|gx_color_load
argument_list|(
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|code
operator|=
name|gx_fill_path
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|,
name|gx_rule_even_odd
argument_list|,
operator|(
name|fixed
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
name|gs_newpath
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Stroke the current path */
end_comment

begin_function
name|int
name|gs_stroke
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
comment|/* If we're inside a charpath, just merge the current path */
comment|/* into the parent's path. */
if|if
condition|(
name|pgs
operator|->
name|in_charpath
condition|)
name|code
operator|=
name|gx_path_add_path
argument_list|(
name|pgs
operator|->
name|saved
operator|->
name|path
argument_list|,
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|gx_color_load
argument_list|(
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|code
operator|=
name|gx_stroke_fill
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|code
condition|)
name|gs_newpath
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Compute the stroked outline of the current path */
end_comment

begin_function
name|int
name|gs_strokepath
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_path
name|spath
decl_stmt|;
name|int
name|code
decl_stmt|;
name|gx_path_init
argument_list|(
operator|&
name|spath
argument_list|,
operator|&
name|pgs
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
name|code
operator|=
name|gx_stroke_add
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|spath
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|gx_path_release
argument_list|(
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|pgs
operator|->
name|path
operator|=
name|spath
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Render a sampled image */
end_comment

begin_function
name|int
name|gs_colorimage
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bps
parameter_list|,
name|int
name|spp
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|)
block|{
name|gs_image_enum
modifier|*
name|penum
init|=
operator|(
name|gs_image_enum
operator|*
operator|)
name|gs_malloc
argument_list|(
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"gs_[color]image"
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
name|penum
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_image_init
argument_list|(
name|penum
argument_list|,
name|pgs
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bps
argument_list|,
name|spp
argument_list|,
name|pmat
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
argument_list|,
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"gs_[color]image"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
if|if
condition|(
name|spp
operator|>
literal|0
condition|)
block|{
name|uint
name|size
init|=
operator|(
operator|(
operator|(
name|uint
operator|)
name|width
operator|*
name|bps
operator|*
name|spp
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|*
operator|(
name|uint
operator|)
name|height
decl_stmt|;
name|code
operator|=
name|gs_image_next
argument_list|(
name|penum
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Deliver the colors separately */
name|uint
name|plane_size
init|=
operator|(
operator|(
operator|(
name|uint
operator|)
name|width
operator|*
name|bps
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|*
operator|(
name|uint
operator|)
name|height
decl_stmt|;
name|byte
modifier|*
name|plane_data
init|=
name|data
decl_stmt|;
name|int
name|count
init|=
name|spp
decl_stmt|;
do|do
block|{
name|code
operator|=
name|gs_image_next
argument_list|(
name|penum
argument_list|,
name|plane_data
argument_list|,
name|plane_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|plane_data
operator|+=
name|plane_size
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|count
condition|)
do|;
block|}
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
argument_list|,
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"gs_[color]image"
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gs_image
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|bps
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|)
block|{
return|return
name|gs_colorimage
argument_list|(
name|pgs
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bps
argument_list|,
literal|1
argument_list|,
name|pmat
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Render a mask */
end_comment

begin_function
name|int
name|gs_imagemask
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|invert
parameter_list|,
name|gs_matrix
modifier|*
name|pmat
parameter_list|,
name|byte
modifier|*
name|data
parameter_list|,
name|int
name|adjust
parameter_list|)
block|{
name|gs_image_enum
modifier|*
name|penum
init|=
operator|(
name|gs_image_enum
operator|*
operator|)
name|gs_malloc
argument_list|(
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"gs_imagemask"
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
name|uint
name|size
init|=
operator|(
operator|(
operator|(
name|uint
operator|)
name|width
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|*
operator|(
name|uint
operator|)
name|height
decl_stmt|;
if|if
condition|(
name|penum
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_imagemask_init
argument_list|(
name|penum
argument_list|,
name|pgs
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|invert
argument_list|,
name|pmat
argument_list|,
name|adjust
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
argument_list|,
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"gs_imagemask"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
name|code
operator|=
name|gs_image_next
argument_list|(
name|penum
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
argument_list|,
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"gs_imagemask"
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|<
literal|0
condition|?
name|code
else|:
literal|0
operator|)
return|;
block|}
end_function

end_unit

