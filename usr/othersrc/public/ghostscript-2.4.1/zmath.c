begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zmath.c */
end_comment

begin_comment
comment|/* Mathematical operators for GhostScript */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Factors for converting between degrees and radians */
end_comment

begin_decl_stmt
name|double
name|degrees_to_radians
init|=
name|M_PI
operator|/
literal|180.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|radians_to_degrees
init|=
literal|180.0
operator|/
name|M_PI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current state of random number generator. */
end_comment

begin_comment
comment|/* We have to implement this ourselves because */
end_comment

begin_comment
comment|/* the Unix rand doesn't provide anything equivalent to rrand. */
end_comment

begin_decl_stmt
name|private
name|long
name|rand_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the random number generator. */
end_comment

begin_function
name|private
name|void
name|zmath_init
parameter_list|()
block|{
name|rand_state
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/****** NOTE: none of these operators currently ******/
end_comment

begin_comment
comment|/****** check for floating over- or underflow.	******/
end_comment

begin_comment
comment|/* sqrt */
end_comment

begin_function
name|int
name|zsqrt
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|num
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
operator|&
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|num
operator|<
literal|0.0
condition|)
return|return
name|e_rangecheck
return|;
name|make_real
argument_list|(
name|op
argument_list|,
name|sqrt
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* arccos */
end_comment

begin_function
name|int
name|zarccos
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|num
decl_stmt|,
name|result
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
operator|&
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|result
operator|=
name|acos
argument_list|(
name|num
argument_list|)
operator|*
name|radians_to_degrees
expr_stmt|;
name|make_real
argument_list|(
name|op
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* arcsin */
end_comment

begin_function
name|int
name|zarcsin
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|num
decl_stmt|,
name|result
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
operator|&
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|result
operator|=
name|asin
argument_list|(
name|num
argument_list|)
operator|*
name|radians_to_degrees
expr_stmt|;
name|make_real
argument_list|(
name|op
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* atan */
end_comment

begin_function
name|int
name|zatan
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|args
index|[
literal|2
index|]
decl_stmt|;
name|float
name|result
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|2
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* on X-axis, special case */
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
name|e_undefinedresult
return|;
name|result
operator|=
operator|(
name|args
index|[
literal|1
index|]
operator|<
literal|0
condition|?
literal|180
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|atan2
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
operator|*
name|radians_to_degrees
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|+=
literal|360
expr_stmt|;
block|}
name|make_real
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* cos */
end_comment

begin_function
name|int
name|zcos
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|angle
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
operator|&
name|angle
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_real
argument_list|(
name|op
argument_list|,
name|cos
argument_list|(
name|angle
operator|*
name|degrees_to_radians
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* sin */
end_comment

begin_function
name|int
name|zsin
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|angle
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
operator|&
name|angle
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|make_real
argument_list|(
name|op
argument_list|,
name|sin
argument_list|(
name|angle
operator|*
name|degrees_to_radians
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* exp */
end_comment

begin_function
name|int
name|zexp
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|args
index|[
literal|2
index|]
decl_stmt|;
name|float
name|result
decl_stmt|;
name|double
name|ipart
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|2
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|0.0
operator|&&
name|args
index|[
literal|1
index|]
operator|==
literal|0.0
condition|)
return|return
name|e_undefinedresult
return|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|<
literal|0.0
operator|&&
name|modf
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
operator|&
name|ipart
argument_list|)
operator|!=
literal|0.0
condition|)
return|return
name|e_undefinedresult
return|;
name|result
operator|=
name|pow
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ln */
end_comment

begin_function
name|int
name|zln
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|num
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
operator|&
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|num
operator|<=
literal|0.0
condition|)
return|return
name|e_rangecheck
return|;
name|make_real
argument_list|(
name|op
argument_list|,
name|log
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* log */
end_comment

begin_function
name|int
name|zlog
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|float
name|num
decl_stmt|;
name|int
name|code
init|=
name|num_params
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
operator|&
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|num
operator|<=
literal|0.0
condition|)
return|return
name|e_rangecheck
return|;
name|make_real
argument_list|(
name|op
argument_list|,
name|log10
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* rand */
end_comment

begin_function
name|int
name|zrand
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
comment|/* 	 * We use an algorithm from CACM 31 no. 10, pp. 1192-1201, 	 * October 1988.  According to a posting by Ed Taft on 	 * comp.lang.postscript, Level 2 (Adobe) PostScript interpreters use 	 * this algorithm too: 	 *	x[n+1] = (16807 * x[n]) mod (2^31 - 1) 	 */
define|#
directive|define
name|A
value|16807
define|#
directive|define
name|M
value|0x7fffffff
define|#
directive|define
name|Q
value|127773
comment|/* M / A */
define|#
directive|define
name|R
value|2836
comment|/* M % A */
name|rand_state
operator|=
name|A
operator|*
operator|(
name|rand_state
operator|%
name|Q
operator|)
operator|-
name|R
operator|*
operator|(
name|rand_state
operator|/
name|Q
operator|)
expr_stmt|;
while|while
condition|(
name|rand_state
operator|<=
literal|0
condition|)
name|rand_state
operator|+=
name|M
expr_stmt|;
undef|#
directive|undef
name|A
undef|#
directive|undef
name|M
undef|#
directive|undef
name|Q
undef|#
directive|undef
name|R
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|rand_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* srand */
end_comment

begin_function
name|int
name|zsrand
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|rand_state
operator|=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* rrand */
end_comment

begin_function
name|int
name|zrrand
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|rand_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zmath_op_defs
index|[]
init|=
block|{
block|{
literal|"1arccos"
block|,
name|zarccos
block|}
block|,
comment|/* extension */
block|{
literal|"1arcsin"
block|,
name|zarcsin
block|}
block|,
comment|/* extension */
block|{
literal|"2atan"
block|,
name|zatan
block|}
block|,
block|{
literal|"1cos"
block|,
name|zcos
block|}
block|,
block|{
literal|"2exp"
block|,
name|zexp
block|}
block|,
block|{
literal|"1ln"
block|,
name|zln
block|}
block|,
block|{
literal|"1log"
block|,
name|zlog
block|}
block|,
block|{
literal|"0rand"
block|,
name|zrand
block|}
block|,
block|{
literal|"0rrand"
block|,
name|zrrand
block|}
block|,
block|{
literal|"1sin"
block|,
name|zsin
block|}
block|,
block|{
literal|"1sqrt"
block|,
name|zsqrt
block|}
block|,
block|{
literal|"1srand"
block|,
name|zsrand
block|}
block|,
name|op_def_end
argument_list|(
argument|zmath_init
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

