begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsstate.c */
end_comment

begin_comment
comment|/* Miscellaneous graphics state operators for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_comment
comment|/* for gzstate */
end_comment

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gzdevice.h"
end_include

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_comment
comment|/* requires gxdevice.h */
end_comment

begin_include
include|#
directive|include
file|"gzht.h"
end_include

begin_include
include|#
directive|include
file|"gzline.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|gs_state
modifier|*
name|alloc_gstate
argument_list|(
name|P4
argument_list|(
name|proc_alloc_t
argument_list|,
name|proc_free_t
argument_list|,
specifier|const
name|gs_state
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|alloc_gstate_contents
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|free_gstate_contents
argument_list|(
name|P1
argument_list|(
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|copy_gstate_contents
argument_list|(
name|P2
argument_list|(
name|gs_state
operator|*
name|pto
argument_list|,
specifier|const
name|gs_state
operator|*
name|pfrom
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate and free a structure */
end_comment

begin_define
define|#
directive|define
name|alloc_struct
parameter_list|(
name|pgs
parameter_list|,
name|typ
parameter_list|,
name|cname
parameter_list|)
define|\
value|(typ *)(*(pgs)->memory_procs.alloc)(1, sizeof(typ), cname)
end_define

begin_define
define|#
directive|define
name|free_struct
parameter_list|(
name|pgs
parameter_list|,
name|ptr
parameter_list|,
name|cname
parameter_list|)
define|\
value|(*(pgs)->memory_procs.free)((char *)(ptr), 1, sizeof(*(ptr)), cname)
end_define

begin_comment
comment|/* ------ Operations on the entire graphics state ------ */
end_comment

begin_comment
comment|/* Allocate and initialize a graphics state. */
end_comment

begin_function
name|private
name|float
name|null_transfer
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|gray
parameter_list|)
block|{
return|return
name|gray
return|;
block|}
end_function

begin_function
name|gs_state
modifier|*
name|gs_state_alloc
parameter_list|(
name|proc_alloc_t
name|palloc
parameter_list|,
name|proc_free_t
name|pfree
parameter_list|)
block|{
specifier|register
name|gs_state
modifier|*
name|pgs
init|=
name|alloc_gstate
argument_list|(
name|palloc
argument_list|,
name|pfree
argument_list|,
operator|(
name|gs_state
operator|*
operator|)
literal|0
argument_list|,
literal|"gs_state_alloc"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pgs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|pgs
operator|->
name|saved
operator|=
literal|0
expr_stmt|;
comment|/* Initialize things not covered by initgraphics */
name|gx_path_init
argument_list|(
name|pgs
operator|->
name|path
argument_list|,
operator|&
name|pgs
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
name|gx_path_init
argument_list|(
operator|&
name|pgs
operator|->
name|clip_path
operator|->
name|path
argument_list|,
operator|&
name|pgs
operator|->
name|memory_procs
argument_list|)
expr_stmt|;
name|gx_clip_list_init
argument_list|(
operator|&
name|pgs
operator|->
name|clip_path
operator|->
name|list
argument_list|)
expr_stmt|;
name|pgs
operator|->
name|halftone
operator|->
name|width
operator|=
name|pgs
operator|->
name|halftone
operator|->
name|height
operator|=
name|pgs
operator|->
name|halftone
operator|->
name|order_size
operator|=
literal|0
expr_stmt|;
name|gs_sethalftonephase
argument_list|(
name|pgs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the color so that gx_remap_color won't crash. */
name|gx_set_gray_only
argument_list|(
name|pgs
operator|->
name|color
argument_list|,
operator|(
name|color_param
operator|)
literal|0
argument_list|)
expr_stmt|;
name|gs_settransfer
argument_list|(
name|pgs
argument_list|,
name|null_transfer
argument_list|)
expr_stmt|;
name|gs_nulldevice
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
name|gs_setflat
argument_list|(
name|pgs
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|gs_setstrokeadjust
argument_list|(
name|pgs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/****** What about the font ? ******/
name|pgs
operator|->
name|in_cachedevice
operator|=
name|pgs
operator|->
name|in_charpath
operator|=
literal|0
expr_stmt|;
name|pgs
operator|->
name|level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gs_initgraphics
argument_list|(
name|pgs
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Something went very wrong */
return|return
literal|0
return|;
block|}
return|return
name|pgs
return|;
block|}
end_function

begin_comment
comment|/* Free a graphics state */
end_comment

begin_function
name|int
name|gs_state_free
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|free_gstate_contents
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
name|free_struct
argument_list|(
name|pgs
argument_list|,
name|pgs
argument_list|,
literal|"gs_state_free"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Save the graphics state */
end_comment

begin_function
name|int
name|gs_gsave
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gs_state
modifier|*
name|pnew
init|=
name|alloc_struct
argument_list|(
name|pgs
argument_list|,
name|gs_state
argument_list|,
literal|"gs_gsave"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pnew
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
operator|*
name|pnew
operator|=
operator|*
name|pgs
expr_stmt|;
if|if
condition|(
name|alloc_gstate_contents
argument_list|(
name|pgs
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|pgs
operator|=
operator|*
name|pnew
expr_stmt|;
comment|/* undo partial alloc */
name|free_struct
argument_list|(
name|pgs
argument_list|,
name|pnew
argument_list|,
literal|"gs_gsave"
argument_list|)
expr_stmt|;
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
block|}
name|copy_gstate_contents
argument_list|(
name|pgs
argument_list|,
name|pnew
argument_list|)
expr_stmt|;
name|pgs
operator|->
name|saved
operator|=
name|pnew
expr_stmt|;
name|pgs
operator|->
name|level
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Restore the graphics state. */
end_comment

begin_function
name|int
name|gs_grestore
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gs_state
modifier|*
name|saved
init|=
name|pgs
operator|->
name|saved
decl_stmt|;
if|if
condition|(
operator|!
name|saved
condition|)
return|return
name|gs_gsave
argument_list|(
name|pgs
argument_list|)
return|;
comment|/* shouldn't happen */
name|free_gstate_contents
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
operator|*
name|pgs
operator|=
operator|*
name|saved
expr_stmt|;
name|free_struct
argument_list|(
name|pgs
argument_list|,
name|saved
argument_list|,
literal|"gs_grestore"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pgs
operator|->
name|saved
operator|==
literal|0
condition|?
name|gs_gsave
argument_list|(
name|pgs
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Restore to the bottommost graphics state. */
end_comment

begin_function
name|int
name|gs_grestoreall
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pgs
operator|->
name|saved
condition|)
return|return
name|gs_gsave
argument_list|(
name|pgs
argument_list|)
return|;
comment|/* shouldn't happen */
while|while
condition|(
name|pgs
operator|->
name|saved
operator|->
name|saved
condition|)
name|gs_grestore
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
return|return
name|gs_grestore
argument_list|(
name|pgs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate and return a new graphics state. */
end_comment

begin_function
name|gs_state
modifier|*
name|gs_gstate
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gs_state
modifier|*
name|pnew
init|=
name|alloc_gstate
argument_list|(
name|pgs
operator|->
name|memory_procs
operator|.
name|alloc
argument_list|,
name|pgs
operator|->
name|memory_procs
operator|.
name|free
argument_list|,
name|pgs
argument_list|,
literal|"gs_gstate"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pnew
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|copy_gstate_contents
argument_list|(
name|pnew
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
name|pnew
operator|->
name|saved
operator|=
literal|0
expr_stmt|;
return|return
name|pgs
return|;
block|}
end_function

begin_comment
comment|/* Copy the current graphics state to a previously allocated one. */
end_comment

begin_function
name|int
name|gs_currentgstate
parameter_list|(
name|gs_state
modifier|*
name|pto
parameter_list|,
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
comment|/* We have to copy both the scalar and composite parts */
comment|/* of the state. */
name|gs_state
name|sgs
decl_stmt|;
name|sgs
operator|=
operator|*
name|pto
expr_stmt|;
operator|*
name|pto
operator|=
operator|*
name|pgs
expr_stmt|;
comment|/* Put back the composite part pointers. */
define|#
directive|define
name|gcopy
parameter_list|(
name|element
parameter_list|)
define|\
value|pto->element = sgs.element
name|gcopy
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|clip_path
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|line_params
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|halftone
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|dev_color
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|transfer
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|device
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|gcopy
name|copy_gstate_contents
argument_list|(
name|pto
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Restore the current graphics state from a previously allocated one. */
end_comment

begin_function
name|int
name|gs_setgstate
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
specifier|const
name|gs_state
modifier|*
name|pfrom
parameter_list|)
block|{
comment|/* The implementation is the same as currentgstate, */
comment|/* except we must preserve the saved pointer and the level. */
name|gs_state
modifier|*
name|saved
init|=
name|pgs
operator|->
name|saved
decl_stmt|;
name|int
name|level
init|=
name|pgs
operator|->
name|level
decl_stmt|;
name|int
name|code
init|=
name|gs_currentgstate
argument_list|(
name|pgs
argument_list|,
name|pfrom
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pgs
operator|->
name|saved
operator|=
name|saved
expr_stmt|;
name|pgs
operator|->
name|level
operator|=
name|level
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Swap the saved pointer of the graphics state. */
end_comment

begin_comment
comment|/* This is provided only for save/restore. */
end_comment

begin_function
name|gs_state
modifier|*
name|gs_state_swap_saved
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|gs_state
modifier|*
name|new_saved
parameter_list|)
block|{
name|gs_state
modifier|*
name|saved
init|=
name|pgs
operator|->
name|saved
decl_stmt|;
name|pgs
operator|->
name|saved
operator|=
name|new_saved
expr_stmt|;
return|return
name|saved
return|;
block|}
end_function

begin_comment
comment|/* Swap the contents of two graphics states, except for the saved pointer. */
end_comment

begin_comment
comment|/* This is provided only for save/restore. */
end_comment

begin_function
name|void
name|gs_state_swap
parameter_list|(
name|gs_state
modifier|*
name|p1
parameter_list|,
name|gs_state
modifier|*
name|p2
parameter_list|)
block|{
name|gs_state
name|temp
decl_stmt|;
name|temp
operator|=
operator|*
name|p1
operator|,
operator|*
name|p1
operator|=
operator|*
name|p2
operator|,
operator|*
name|p2
operator|=
name|temp
expr_stmt|;
comment|/* Restore the saved pointers. */
name|p2
operator|->
name|saved
operator|=
name|p1
operator|->
name|saved
expr_stmt|;
name|p1
operator|->
name|saved
operator|=
name|temp
operator|.
name|saved
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Operations on components ------ */
end_comment

begin_comment
comment|/* Reset most of the graphics state */
end_comment

begin_function
name|int
name|gs_initgraphics
parameter_list|(
specifier|register
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|gs_initmatrix
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|gs_newpath
argument_list|(
name|pgs
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_initclip
argument_list|(
name|pgs
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_setlinewidth
argument_list|(
name|pgs
argument_list|,
literal|1.0
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_setlinecap
argument_list|(
name|pgs
argument_list|,
name|gs_cap_butt
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_setlinejoin
argument_list|(
name|pgs
argument_list|,
name|gs_join_miter
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_setdash
argument_list|(
name|pgs
argument_list|,
operator|(
name|float
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0.0
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_setgray
argument_list|(
name|pgs
argument_list|,
literal|0.0
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|gs_setmiterlimit
argument_list|(
name|pgs
argument_list|,
literal|10.0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* setflat */
end_comment

begin_function
name|int
name|gs_setflat
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|floatp
name|flat
parameter_list|)
block|{
if|if
condition|(
name|flat
operator|<=
literal|0.2
condition|)
name|flat
operator|=
literal|0.2
expr_stmt|;
elseif|else
if|if
condition|(
name|flat
operator|>
literal|100
condition|)
name|flat
operator|=
literal|100
expr_stmt|;
name|pgs
operator|->
name|flatness
operator|=
name|flat
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentflat */
end_comment

begin_function
name|float
name|gs_currentflat
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|flatness
return|;
block|}
end_function

begin_comment
comment|/* setstrokeadjust */
end_comment

begin_function
name|int
name|gs_setstrokeadjust
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|stroke_adjust
parameter_list|)
block|{
name|pgs
operator|->
name|stroke_adjust
operator|=
name|stroke_adjust
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* currentstrokeadjust */
end_comment

begin_function
name|int
name|gs_currentstrokeadjust
parameter_list|(
specifier|const
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
return|return
name|pgs
operator|->
name|stroke_adjust
return|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Allocate a graphics state object and its contents, */
end_comment

begin_comment
comment|/* optionally initializing it from an existing object. */
end_comment

begin_comment
comment|/* Return 0 if the allocation fails. */
end_comment

begin_function
name|private
name|gs_state
modifier|*
name|alloc_gstate
parameter_list|(
name|proc_alloc_t
name|palloc
parameter_list|,
name|proc_free_t
name|pfree
parameter_list|,
specifier|const
name|gs_state
modifier|*
name|pold
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|)
block|{
name|gs_state
modifier|*
name|pgs
init|=
operator|(
name|gs_state
operator|*
operator|)
call|(
modifier|*
name|palloc
call|)
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_state
argument_list|)
argument_list|,
name|cname
argument_list|)
decl_stmt|;
if|if
condition|(
name|pgs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pold
operator|!=
literal|0
condition|)
operator|*
name|pgs
operator|=
operator|*
name|pold
expr_stmt|;
else|else
name|pgs
operator|->
name|transfer
operator|=
literal|0
expr_stmt|;
name|pgs
operator|->
name|memory_procs
operator|.
name|alloc
operator|=
name|palloc
expr_stmt|;
name|pgs
operator|->
name|memory_procs
operator|.
name|free
operator|=
name|pfree
expr_stmt|;
if|if
condition|(
name|alloc_gstate_contents
argument_list|(
name|pgs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free_struct
argument_list|(
name|pgs
argument_list|,
name|pgs
argument_list|,
name|cname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|pgs
return|;
block|}
end_function

begin_comment
comment|/* Allocate the contents of a graphics state object. */
end_comment

begin_comment
comment|/* Return -1 if the allocation fails. */
end_comment

begin_comment
comment|/* Note that the contents have been smashed in this case. */
end_comment

begin_function
name|private
name|int
name|alloc_gstate_contents
parameter_list|(
specifier|register
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|proc_alloc_t
name|palloc
init|=
name|pgs
operator|->
name|memory_procs
operator|.
name|alloc
decl_stmt|;
specifier|static
specifier|const
name|char
name|cname
index|[]
init|=
literal|"alloc_gstate_contents"
decl_stmt|;
define|#
directive|define
name|galloc
parameter_list|(
name|element
parameter_list|,
name|type
parameter_list|,
name|fail
parameter_list|)
define|\
value|if ( (pgs->element = (type *)(*palloc)(1, sizeof(type), cname)) == 0 ) goto fail
name|galloc
argument_list|(
name|path
argument_list|,
name|gx_path
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|galloc
argument_list|(
name|clip_path
argument_list|,
name|gx_clip_path
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
name|galloc
argument_list|(
name|line_params
argument_list|,
name|line_params
argument_list|,
name|ulp
argument_list|)
expr_stmt|;
name|galloc
argument_list|(
name|halftone
argument_list|,
name|halftone_params
argument_list|,
name|uht
argument_list|)
expr_stmt|;
name|galloc
argument_list|(
name|color
argument_list|,
name|gs_color
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|galloc
argument_list|(
name|dev_color
argument_list|,
name|gx_device_color
argument_list|,
name|udc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgs
operator|->
name|transfer
operator|!=
literal|0
condition|)
name|pgs
operator|->
name|transfer
operator|->
name|ref_count
operator|++
expr_stmt|;
else|else
block|{
name|galloc
argument_list|(
name|transfer
argument_list|,
name|gx_transfer
argument_list|,
name|ut
argument_list|)
expr_stmt|;
name|pgs
operator|->
name|transfer
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
block|}
name|galloc
argument_list|(
name|device
argument_list|,
name|device
argument_list|,
name|ud
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|galloc
name|pgs
operator|->
name|device_is_shared
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* Undo partial allocations if an allocation failed. */
define|#
directive|define
name|gunalloc
parameter_list|(
name|element
parameter_list|)
value|free_struct(pgs, pgs->element, cname)
name|ud
label|:
name|gunalloc
argument_list|(
name|transfer
argument_list|)
expr_stmt|;
name|ut
label|:
name|gunalloc
argument_list|(
name|dev_color
argument_list|)
expr_stmt|;
name|udc
label|:
name|gunalloc
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|uc
label|:
name|gunalloc
argument_list|(
name|halftone
argument_list|)
expr_stmt|;
name|uht
label|:
name|gunalloc
argument_list|(
name|line_params
argument_list|)
expr_stmt|;
name|ulp
label|:
name|gunalloc
argument_list|(
name|clip_path
argument_list|)
expr_stmt|;
name|ucp
label|:
name|gunalloc
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|up
label|:
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|gunalloc
block|}
end_function

begin_comment
comment|/* Free the contents of a graphics state, but not the state itself. */
end_comment

begin_function
name|private
name|void
name|free_gstate_contents
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|proc_free_t
name|pfree
init|=
name|pgs
operator|->
name|memory_procs
operator|.
name|free
decl_stmt|;
specifier|static
specifier|const
name|char
name|cname
index|[]
init|=
literal|"free_gstate_contents"
decl_stmt|;
name|gx_cpath_release
argument_list|(
name|pgs
operator|->
name|clip_path
argument_list|)
expr_stmt|;
name|gx_path_release
argument_list|(
name|pgs
operator|->
name|path
argument_list|)
expr_stmt|;
define|#
directive|define
name|gfree
parameter_list|(
name|element
parameter_list|)
define|\
value|(*pfree)((char *)pgs->element, 1, sizeof(*pgs->element), cname)
if|if
condition|(
operator|!
name|pgs
operator|->
name|device_is_shared
condition|)
name|gfree
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
operator|(
name|pgs
operator|->
name|transfer
operator|->
name|ref_count
operator|)
condition|)
name|gfree
argument_list|(
name|transfer
argument_list|)
expr_stmt|;
name|gfree
argument_list|(
name|dev_color
argument_list|)
expr_stmt|;
name|gfree
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|gfree
argument_list|(
name|halftone
argument_list|)
expr_stmt|;
name|gfree
argument_list|(
name|line_params
argument_list|)
expr_stmt|;
name|gfree
argument_list|(
name|clip_path
argument_list|)
expr_stmt|;
name|gfree
argument_list|(
name|path
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|gfree
block|}
end_function

begin_comment
comment|/* Copy the composite parts of a graphics state. */
end_comment

begin_function
name|private
name|void
name|copy_gstate_contents
parameter_list|(
name|gs_state
modifier|*
name|pto
parameter_list|,
specifier|const
name|gs_state
modifier|*
name|pfrom
parameter_list|)
block|{
define|#
directive|define
name|gcopy
parameter_list|(
name|element
parameter_list|)
define|\
value|*pto->element = *pfrom->element
name|gcopy
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|clip_path
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|line_params
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|halftone
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|color
argument_list|)
expr_stmt|;
name|gcopy
argument_list|(
name|dev_color
argument_list|)
expr_stmt|;
if|if
condition|(
name|pto
operator|->
name|transfer
operator|!=
name|pfrom
operator|->
name|transfer
condition|)
block|{
if|if
condition|(
operator|!
operator|--
operator|(
name|pto
operator|->
name|transfer
operator|->
name|ref_count
operator|)
condition|)
block|{
comment|/* We could just copy the contents, but */
comment|/* we'd rather free the storage and hope that */
comment|/* we won't have to reallocate later. */
name|free_struct
argument_list|(
name|pto
argument_list|,
name|pto
operator|->
name|transfer
argument_list|,
literal|"copy gstate"
argument_list|)
expr_stmt|;
block|}
operator|(
name|pto
operator|->
name|transfer
operator|=
name|pfrom
operator|->
name|transfer
operator|)
operator|->
name|ref_count
operator|++
expr_stmt|;
block|}
name|gcopy
argument_list|(
name|device
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|gcopy
name|gx_path_share
argument_list|(
name|pto
operator|->
name|path
argument_list|)
expr_stmt|;
name|gx_cpath_share
argument_list|(
name|pto
operator|->
name|clip_path
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

