begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zarith.c */
end_comment

begin_comment
comment|/* Arithmetic operators for GhostScript */
end_comment

begin_include
include|#
directive|include
file|"math_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/****** NOTE: none of the arithmetic operators  ******/
end_comment

begin_comment
comment|/****** currently check for floating exceptions ******/
end_comment

begin_comment
comment|/* Imported operators */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|zcvi
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for accessing next-to-top stack element */
end_comment

begin_define
define|#
directive|define
name|opm1
value|(op-1)
end_define

begin_comment
comment|/* Macros for generating non-integer cases for arithmetic operations. */
end_comment

begin_comment
comment|/* 'frob' is one of the arithmetic operators, +, -, or *. */
end_comment

begin_define
define|#
directive|define
name|non_int_cases
parameter_list|(
name|frob
parameter_list|,
name|frob_equals
parameter_list|)
define|\
value|switch ( r_type(op) ) {\   default: return e_typecheck;\   case t_real: switch ( r_type(opm1) ) {\    default: return e_typecheck;\    case t_real: op[-1].value.realval frob_equals op->value.realval; break;\    case t_integer: make_real(opm1, op[-1].value.intval frob op->value.realval);\   } break;\   case t_integer: switch ( r_type(opm1) ) {\    default: return e_typecheck;\    case t_real: op[-1].value.realval frob_equals op->value.intval; break;\    case t_integer:
end_define

begin_define
define|#
directive|define
name|end_cases
parameter_list|()
define|\
value|} }
end_define

begin_comment
comment|/* add */
end_comment

begin_comment
comment|/* We make this into a separate procedure because */
end_comment

begin_comment
comment|/* the interpreter will almost always call it directly. */
end_comment

begin_function
name|int
name|zop_add
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|non_int_cases
argument_list|(
argument|+
argument_list|,
argument|+=
argument_list|)
block|{
name|long
name|int2
init|=
name|op
operator|->
name|value
operator|.
name|intval
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|+=
name|int2
operator|)
operator|^
name|int2
operator|)
operator|<
literal|0
operator|&&
operator|(
operator|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|-
name|int2
operator|)
operator|^
name|int2
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Overflow, convert to real */
name|make_real
argument_list|(
name|opm1
argument_list|,
call|(
name|float
call|)
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|-
name|int2
argument_list|)
operator|+
name|int2
argument_list|)
expr_stmt|;
block|}
block|}
name|end_cases
argument_list|()
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|zadd
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|zop_add
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* div */
end_comment

begin_function
name|int
name|zdiv
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
specifier|register
name|os_ptr
name|op1
init|=
name|op
operator|-
literal|1
decl_stmt|;
comment|/* We can't use the non_int_cases macro, */
comment|/* because we have to check explicitly for op == 0. */
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|realval
operator|==
literal|0
condition|)
return|return
name|e_undefinedresult
return|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op1
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
name|op1
operator|->
name|value
operator|.
name|realval
operator|/=
name|op
operator|->
name|value
operator|.
name|realval
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|make_real
argument_list|(
name|op1
argument_list|,
name|op1
operator|->
name|value
operator|.
name|intval
operator|/
name|op
operator|->
name|value
operator|.
name|realval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|t_integer
case|:
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|==
literal|0
condition|)
return|return
name|e_undefinedresult
return|;
switch|switch
condition|(
name|r_type
argument_list|(
name|op1
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
name|op1
operator|->
name|value
operator|.
name|realval
operator|/=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
name|make_real
argument_list|(
name|op1
argument_list|,
operator|(
name|float
operator|)
name|op1
operator|->
name|value
operator|.
name|intval
operator|/
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* mul */
end_comment

begin_function
name|int
name|zmul
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|non_int_cases
argument_list|(
argument|*
argument_list|,
argument|*=
argument_list|)
block|{
name|long
name|int1
init|=
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
decl_stmt|;
name|long
name|int2
init|=
name|op
operator|->
name|value
operator|.
name|intval
decl_stmt|;
name|long
name|abs1
init|=
operator|(
name|int1
operator|>=
literal|0
condition|?
name|int1
else|:
operator|-
name|int1
operator|)
decl_stmt|;
name|long
name|abs2
init|=
operator|(
name|int2
operator|>=
literal|0
condition|?
name|int2
else|:
operator|-
name|int2
operator|)
decl_stmt|;
name|float
name|fprod
decl_stmt|;
if|if
condition|(
operator|(
name|abs1
operator|>
literal|0x7fff
operator|||
name|abs2
operator|>
literal|0x7fff
operator|)
operator|&&
comment|/* At least one of the operands is very large. */
comment|/* Check for integer overflow. */
name|abs1
operator|!=
literal|0
operator|&&
name|abs2
operator|>
literal|0x7fffffffL
operator|/
name|abs1
operator|&&
comment|/* Check for the boundary case */
operator|(
name|fprod
operator|=
operator|(
name|float
operator|)
name|int1
operator|*
name|int2
operator|,
operator|(
name|int1
operator|*
name|int2
operator|!=
operator|-
literal|0x80000000L
operator|||
name|fprod
operator|!=
operator|(
name|float
operator|)
operator|-
literal|0x80000000L
operator|)
operator|)
condition|)
name|make_real
argument_list|(
name|opm1
argument_list|,
name|fprod
argument_list|)
expr_stmt|;
else|else
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|=
name|int1
operator|*
name|int2
expr_stmt|;
block|}
name|end_cases
argument_list|()
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* sub */
end_comment

begin_comment
comment|/* We make this into a separate procedure because */
end_comment

begin_comment
comment|/* the interpreter will almost always call it directly. */
end_comment

begin_function
name|int
name|zop_sub
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|non_int_cases
argument_list|(
argument|-
argument_list|,
argument|-=
argument_list|)
block|{
name|long
name|int1
init|=
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
decl_stmt|;
if|if
condition|(
operator|(
name|int1
operator|^
operator|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|=
name|int1
operator|-
name|op
operator|->
name|value
operator|.
name|intval
operator|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|int1
operator|^
name|op
operator|->
name|value
operator|.
name|intval
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Overflow, convert to real */
name|make_real
argument_list|(
name|opm1
argument_list|,
operator|(
name|float
operator|)
name|int1
operator|-
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
block|}
block|}
name|end_cases
argument_list|()
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|zsub
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|zop_sub
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* idiv */
end_comment

begin_function
name|int
name|zidiv
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
comment|/* The Red Book says this only works on integers, */
comment|/* but implementations also accept reals. */
name|ref
name|save_num
decl_stmt|;
name|int
name|code
decl_stmt|;
name|save_num
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|code
operator|=
name|zdiv
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* division failed */
name|code
operator|=
name|zcvi
argument_list|(
name|op
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
block|{
comment|/* cvi failed, restore numerator */
name|op
index|[
operator|-
literal|1
index|]
operator|=
name|save_num
expr_stmt|;
name|osp
operator|=
name|op
expr_stmt|;
comment|/* restore osp as well */
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* mod */
end_comment

begin_function
name|int
name|zmod
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|==
literal|0
condition|)
return|return
name|e_undefinedresult
return|;
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|%=
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* neg */
end_comment

begin_function
name|int
name|zneg
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
name|op
operator|->
name|value
operator|.
name|realval
operator|=
operator|-
name|op
operator|->
name|value
operator|.
name|realval
expr_stmt|;
break|break;
case|case
name|t_integer
case|:
if|if
condition|(
name|op
operator|->
name|value
operator|.
name|intval
operator|==
operator|-
literal|0x80000000L
condition|)
comment|/* min integer */
name|make_real
argument_list|(
name|op
argument_list|,
operator|-
operator|(
name|float
operator|)
operator|-
literal|0x80000000L
argument_list|)
expr_stmt|;
else|else
name|op
operator|->
name|value
operator|.
name|intval
operator|=
operator|-
name|op
operator|->
name|value
operator|.
name|intval
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ceiling */
end_comment

begin_function
name|int
name|zceiling
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
name|op
operator|->
name|value
operator|.
name|realval
operator|=
name|ceil
argument_list|(
name|op
operator|->
name|value
operator|.
name|realval
argument_list|)
expr_stmt|;
case|case
name|t_integer
case|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* floor */
end_comment

begin_function
name|int
name|zfloor
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
name|op
operator|->
name|value
operator|.
name|realval
operator|=
name|floor
argument_list|(
name|op
operator|->
name|value
operator|.
name|realval
argument_list|)
expr_stmt|;
case|case
name|t_integer
case|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* round */
end_comment

begin_function
name|int
name|zround
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
name|op
operator|->
name|value
operator|.
name|realval
operator|=
name|floor
argument_list|(
name|op
operator|->
name|value
operator|.
name|realval
operator|+
literal|0.5
argument_list|)
expr_stmt|;
case|case
name|t_integer
case|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* truncate */
end_comment

begin_function
name|int
name|ztruncate
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
argument_list|(
name|op
argument_list|)
condition|)
block|{
default|default:
return|return
name|e_typecheck
return|;
case|case
name|t_real
case|:
name|op
operator|->
name|value
operator|.
name|realval
operator|=
operator|(
name|op
operator|->
name|value
operator|.
name|realval
operator|<
literal|0.0
condition|?
name|ceil
argument_list|(
name|op
operator|->
name|value
operator|.
name|realval
argument_list|)
else|:
name|floor
argument_list|(
name|op
operator|->
name|value
operator|.
name|realval
argument_list|)
operator|)
expr_stmt|;
case|case
name|t_integer
case|:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization table ------ */
end_comment

begin_decl_stmt
name|op_def
name|zarith_op_defs
index|[]
init|=
block|{
block|{
literal|"2add"
block|,
name|zadd
block|}
block|,
block|{
literal|"1ceiling"
block|,
name|zceiling
block|}
block|,
block|{
literal|"2div"
block|,
name|zdiv
block|}
block|,
block|{
literal|"2idiv"
block|,
name|zidiv
block|}
block|,
block|{
literal|"1floor"
block|,
name|zfloor
block|}
block|,
block|{
literal|"2mod"
block|,
name|zmod
block|}
block|,
block|{
literal|"2mul"
block|,
name|zmul
block|}
block|,
block|{
literal|"1neg"
block|,
name|zneg
block|}
block|,
block|{
literal|"1round"
block|,
name|zround
block|}
block|,
block|{
literal|"2sub"
block|,
name|zsub
block|}
block|,
block|{
literal|"1truncate"
block|,
name|ztruncate
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

