begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zpaint.c */
end_comment

begin_comment
comment|/* Painting operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_comment
comment|/* for image[mask] */
end_comment

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gspaint.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|image_opaque_setup
argument_list|(
name|P2
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|image_setup
argument_list|(
name|P3
argument_list|(
name|os_ptr
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|image_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_image_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* erasepage */
end_comment

begin_function
name|int
name|zerasepage
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_erasepage
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* fill */
end_comment

begin_function
name|int
name|zfill
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_fill
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* eofill */
end_comment

begin_function
name|int
name|zeofill
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_eofill
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* stroke */
end_comment

begin_function
name|int
name|zstroke
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_stroke
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* colorimage */
end_comment

begin_function
name|int
name|zcolorimage
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|spp
decl_stmt|;
comment|/* samples per pixel */
name|int
name|npop
init|=
literal|7
decl_stmt|;
name|os_ptr
name|procp
init|=
name|op
operator|-
literal|2
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
comment|/* ncolors */
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
comment|/* multiproc */
if|if
condition|(
call|(
name|ulong
call|)
argument_list|(
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|>
literal|4
condition|)
return|return
name|e_rangecheck
return|;
switch|switch
condition|(
operator|(
name|spp
operator|=
call|(
name|int
call|)
argument_list|(
name|op
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
if|if
condition|(
name|op
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|index
condition|)
comment|/* planar format */
name|npop
operator|+=
name|spp
operator|-
literal|1
operator|,
name|procp
operator|-=
name|spp
operator|-
literal|1
operator|,
name|spp
operator|=
operator|-
name|spp
expr_stmt|;
break|break;
default|default:
return|return
name|e_rangecheck
return|;
block|}
name|code
operator|=
name|image_opaque_setup
argument_list|(
name|procp
argument_list|,
name|spp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
name|npop
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* image */
end_comment

begin_function
name|int
name|zimage
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
init|=
name|image_opaque_setup
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* imagemask */
end_comment

begin_function
name|int
name|zimagemask
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|2
index|]
argument_list|,
name|t_boolean
argument_list|)
expr_stmt|;
name|code
operator|=
name|image_setup
argument_list|(
name|op
argument_list|,
operator|!
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
name|pop
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Common setup for image and colorimage. */
end_comment

begin_function
name|private
name|int
name|image_opaque_setup
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|,
name|int
name|spp
parameter_list|)
block|{
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|2
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
comment|/* bits/sample */
if|if
condition|(
call|(
name|ulong
call|)
argument_list|(
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
argument_list|)
operator|>
literal|8
condition|)
return|return
name|e_rangecheck
return|;
return|return
name|image_setup
argument_list|(
name|op
argument_list|,
operator|(
name|int
operator|)
name|op
index|[
operator|-
literal|2
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
name|spp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Common setup for [color]image and imagemask. */
end_comment

begin_comment
comment|/* spp is 0 for imagemask, 1 for image, and [-]3 or [-]4 for colorimage. */
end_comment

begin_function
name|private
name|int
name|image_setup
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|,
name|int
name|param3
comment|/* bits/sample or invert */
parameter_list|,
name|int
name|spp
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|gs_image_enum
modifier|*
name|penum
decl_stmt|;
name|gs_matrix
name|mat
decl_stmt|;
name|int
name|px
decl_stmt|;
name|int
name|pmax
init|=
operator|(
name|spp
operator|<
literal|0
condition|?
operator|~
name|spp
else|:
literal|0
operator|)
decl_stmt|;
comment|/* We push on the estack: */
comment|/*	Control mark, 4 procs, last plane index, */
comment|/*	enumeration structure (as bytes). */
define|#
directive|define
name|inumpush
value|7
name|check_estack
argument_list|(
name|inumpush
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* stuff above, + continuation + proc */
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|4
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
comment|/* width */
name|check_type
argument_list|(
name|op
index|[
operator|-
literal|3
index|]
argument_list|,
name|t_integer
argument_list|)
expr_stmt|;
comment|/* height */
comment|/* Note that the "procedures" might not be procedures, */
comment|/* but might be literal strings. */
for|for
control|(
name|px
operator|=
literal|0
init|;
name|px
operator|<=
name|pmax
condition|;
name|px
operator|++
control|)
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|op
operator|+
name|px
argument_list|,
name|t_string
argument_list|)
condition|)
block|{
name|check_proc
argument_list|(
name|op
index|[
name|px
index|]
argument_list|)
expr_stmt|;
comment|/* proc(s) */
block|}
if|if
condition|(
name|op
index|[
operator|-
literal|4
index|]
operator|.
name|value
operator|.
name|intval
operator|<=
literal|0
operator|||
name|op
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
operator|<
literal|0
condition|)
return|return
name|e_undefinedresult
return|;
if|if
condition|(
name|op
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* empty image */
if|if
condition|(
operator|(
name|code
operator|=
name|read_matrix
argument_list|(
name|op
operator|-
literal|1
argument_list|,
operator|&
name|mat
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
operator|(
name|penum
operator|=
operator|(
name|gs_image_enum
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"image_setup"
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|code
operator|=
operator|(
name|spp
operator|==
literal|0
condition|?
name|gs_imagemask_init
argument_list|(
name|penum
argument_list|,
name|igs
argument_list|,
operator|(
name|int
operator|)
name|op
index|[
operator|-
literal|4
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
operator|(
name|int
operator|)
name|op
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
name|param3
argument_list|,
operator|&
name|mat
argument_list|,
literal|1
argument_list|)
else|:
name|gs_image_init
argument_list|(
name|penum
argument_list|,
name|igs
argument_list|,
operator|(
name|int
operator|)
name|op
index|[
operator|-
literal|4
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
operator|(
name|int
operator|)
name|op
index|[
operator|-
literal|3
index|]
operator|.
name|value
operator|.
name|intval
argument_list|,
name|param3
argument_list|,
name|spp
argument_list|,
operator|&
name|mat
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|mark_estack
argument_list|(
name|es_other
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
for|for
control|(
name|px
operator|=
literal|0
init|;
name|px
operator|<
literal|4
condition|;
name|esp
operator|++
operator|,
name|px
operator|++
control|)
if|if
condition|(
name|px
operator|<=
name|pmax
condition|)
operator|*
name|esp
operator|=
name|op
index|[
name|px
index|]
expr_stmt|;
else|else
name|make_null
argument_list|(
name|esp
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|esp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* current plane */
name|r_set_size
argument_list|(
name|esp
argument_list|,
name|pmax
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
name|make_tasv
argument_list|(
name|esp
argument_list|,
name|t_string
argument_list|,
literal|0
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|penum
argument_list|)
expr_stmt|;
name|push_op_estack
argument_list|(
name|image_continue
argument_list|,
name|i_image_continue
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
operator|*
name|op
expr_stmt|;
comment|/* run the (first) procedure */
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* Continuation procedure.  Hand the string to the enumerator. */
end_comment

begin_function
name|private
name|int
name|image_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_image_enum
modifier|*
name|penum
init|=
operator|(
name|gs_image_enum
operator|*
operator|)
name|esp
operator|->
name|value
operator|.
name|bytes
decl_stmt|;
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|op
argument_list|,
name|t_string
argument_list|)
condition|)
block|{
comment|/* Procedure didn't return a string.  Quit. */
name|esp
operator|-=
name|inumpush
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
argument_list|,
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"image_continue(quit)"
argument_list|)
expr_stmt|;
return|return
name|e_typecheck
return|;
block|}
name|code
operator|=
name|gs_image_next
argument_list|(
name|penum
argument_list|,
name|op
operator|->
name|value
operator|.
name|bytes
argument_list|,
name|r_size
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_size
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|||
name|code
operator|!=
literal|0
condition|)
comment|/* stop now */
block|{
name|esp
operator|-=
name|inumpush
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
argument_list|,
literal|1
argument_list|,
name|gs_image_enum_sizeof
argument_list|,
literal|"image_continue(finished)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|code
operator|=
name|o_pop_estack
expr_stmt|;
block|}
else|else
block|{
name|int
name|px
init|=
operator|(
name|int
operator|)
operator|++
operator|(
name|esp
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|)
decl_stmt|;
name|es_ptr
name|pproc
init|=
name|esp
operator|-
literal|5
decl_stmt|;
if|if
condition|(
name|px
operator|>
name|r_size
argument_list|(
name|esp
operator|-
literal|1
argument_list|)
condition|)
name|esp
index|[
operator|-
literal|1
index|]
operator|.
name|value
operator|.
name|intval
operator|=
name|px
operator|=
literal|0
expr_stmt|;
name|push_op_estack
argument_list|(
name|image_continue
argument_list|,
name|i_image_continue
argument_list|)
expr_stmt|;
operator|*
operator|++
name|esp
operator|=
name|pproc
index|[
name|px
index|]
expr_stmt|;
name|code
operator|=
name|o_push_estack
expr_stmt|;
block|}
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zpaint_op_defs
index|[]
init|=
block|{
block|{
literal|"0eofill"
block|,
name|zeofill
block|}
block|,
block|{
literal|"0erasepage"
block|,
name|zerasepage
block|}
block|,
block|{
literal|"0fill"
block|,
name|zfill
block|}
block|,
block|{
literal|"7colorimage"
block|,
name|zcolorimage
block|}
block|,
block|{
literal|"5image"
block|,
name|zimage
block|}
block|,
block|{
literal|"5imagemask"
block|,
name|zimagemask
block|}
block|,
block|{
literal|"0stroke"
block|,
name|zstroke
block|}
block|,
comment|/* Internal operators */
block|{
literal|"0%image_continue"
block|,
name|image_continue
block|,
operator|&
name|i_image_continue
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

