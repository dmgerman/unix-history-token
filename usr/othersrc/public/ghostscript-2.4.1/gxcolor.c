begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxcolor.c */
end_comment

begin_comment
comment|/* Private color procedures for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_comment
comment|/* for gxmatrix.h */
end_comment

begin_include
include|#
directive|include
file|"gxlum.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* for gx_color_index */
end_comment

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_include
include|#
directive|include
file|"gzht.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_comment
comment|/* Imported procedures */
end_comment

begin_decl_stmt
name|void
name|gx_color_render
argument_list|(
name|P3
argument_list|(
name|gs_color
operator|*
argument_list|,
name|gx_device_color
operator|*
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|void
name|gx_color_from_rgb
argument_list|(
name|P1
argument_list|(
name|gs_color
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Color setup routines ------ */
end_comment

begin_comment
comment|/* Set up black for writing into the character cache. */
end_comment

begin_function
name|void
name|gx_set_black
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
specifier|register
name|gs_color
modifier|*
name|pcolor
init|=
name|pgs
operator|->
name|color
decl_stmt|;
name|pcolor
operator|->
name|red
operator|=
name|pcolor
operator|->
name|green
operator|=
name|pcolor
operator|->
name|blue
operator|=
name|pcolor
operator|->
name|luminance
operator|=
literal|0
expr_stmt|;
name|pcolor
operator|->
name|luminance_set
operator|=
literal|1
expr_stmt|;
name|pcolor
operator|->
name|is_gray
operator|=
literal|1
expr_stmt|;
name|pcolor
operator|->
name|space
operator|=
operator|(
name|byte
operator|)
name|gs_color_space_DeviceGray
expr_stmt|;
name|gx_color_render
argument_list|(
name|pcolor
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up a gray color.  This is an internal routine */
end_comment

begin_comment
comment|/* for use by initialization and gx_remap_color. */
end_comment

begin_function
name|void
name|gx_set_gray_only
parameter_list|(
specifier|register
name|gs_color
modifier|*
name|pcolor
parameter_list|,
name|color_param
name|gray
parameter_list|)
block|{
name|pcolor
operator|->
name|red
operator|=
name|pcolor
operator|->
name|green
operator|=
name|pcolor
operator|->
name|blue
operator|=
name|pcolor
operator|->
name|luminance
operator|=
name|gray
expr_stmt|;
name|pcolor
operator|->
name|luminance_set
operator|=
literal|1
expr_stmt|;
name|pcolor
operator|->
name|is_gray
operator|=
literal|1
expr_stmt|;
name|pcolor
operator|->
name|space
operator|=
operator|(
name|byte
operator|)
name|gs_color_space_DeviceGray
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up an RGB color.  This is an internal routine */
end_comment

begin_comment
comment|/* for use by gx_remap_color. */
end_comment

begin_function
name|void
name|gx_set_rgb_only
parameter_list|(
specifier|register
name|gs_color
modifier|*
name|pcolor
parameter_list|,
name|color_param
name|r
parameter_list|,
name|color_param
name|g
parameter_list|,
name|color_param
name|b
parameter_list|)
block|{
name|pcolor
operator|->
name|red
operator|=
name|r
expr_stmt|;
name|pcolor
operator|->
name|green
operator|=
name|g
expr_stmt|;
name|pcolor
operator|->
name|blue
operator|=
name|b
expr_stmt|;
name|gx_color_from_rgb
argument_list|(
name|pcolor
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up an RGB color. */
end_comment

begin_function
name|void
name|gx_color_from_rgb
parameter_list|(
specifier|register
name|gs_color
modifier|*
name|pcolor
parameter_list|)
block|{
if|if
condition|(
name|pcolor
operator|->
name|red
operator|==
name|pcolor
operator|->
name|green
operator|&&
name|pcolor
operator|->
name|green
operator|==
name|pcolor
operator|->
name|blue
condition|)
block|{
name|pcolor
operator|->
name|luminance
operator|=
name|pcolor
operator|->
name|red
expr_stmt|;
comment|/* pick any one */
name|pcolor
operator|->
name|is_gray
operator|=
name|pcolor
operator|->
name|luminance_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute luminance later */
name|pcolor
operator|->
name|is_gray
operator|=
name|pcolor
operator|->
name|luminance_set
operator|=
literal|0
expr_stmt|;
block|}
name|pcolor
operator|->
name|space
operator|=
operator|(
name|byte
operator|)
name|gs_color_space_DeviceRGB
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force a parameter into the range [0..1], */
end_comment

begin_comment
comment|/* and convert to a color_param. */
end_comment

begin_function
name|color_param
name|gx_color_unit_param
parameter_list|(
name|floatp
name|fval
parameter_list|)
block|{
if|if
condition|(
name|fval
operator|<=
literal|0.0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|fval
operator|>=
literal|1.0
condition|)
return|return
name|max_color_param
return|;
else|else
return|return
call|(
name|color_param
call|)
argument_list|(
name|fval
operator|*
name|max_color_param_float
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Map a color_param through a transfer map. */
end_comment

begin_function
name|color_param
name|gx_color_param_map
parameter_list|(
name|color_param
name|cv
parameter_list|,
name|color_param
modifier|*
name|values
parameter_list|)
block|{
define|#
directive|define
name|cp_frac_bits
value|(color_param_bits - log2_transfer_map_size)
name|int
name|cmi
init|=
name|cv
operator|>>
name|cp_frac_bits
decl_stmt|;
name|color_param
name|mv
init|=
name|values
index|[
name|cmi
index|]
decl_stmt|;
name|int
name|rem
decl_stmt|,
name|mdv
decl_stmt|;
comment|/* Interpolate between two adjacent values if needed. */
name|rem
operator|=
operator|(
name|cv
operator|&
operator|(
operator|(
literal|1
operator|<<
name|cp_frac_bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
operator|(
name|cv
operator|>>
operator|(
name|color_param_bits
operator|-
name|cp_frac_bits
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|rem
operator|==
literal|0
condition|)
return|return
name|mv
return|;
elseif|else
if|if
condition|(
name|rem
operator|>
literal|0
condition|)
name|mdv
operator|=
name|values
index|[
name|cmi
operator|+
literal|1
index|]
operator|-
name|mv
expr_stmt|;
else|else
name|mdv
operator|=
name|mv
operator|-
name|values
index|[
name|cmi
operator|-
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|arch_ints_are_short
comment|/* Only use long multiplication if necessary. */
if|if
condition|(
name|mdv
operator|>
literal|1
operator|<<
operator|(
literal|16
operator|-
name|cp_frac_bits
operator|)
condition|)
return|return
name|mv
operator|+
call|(
name|uint
call|)
argument_list|(
operator|(
operator|(
name|ulong
operator|)
name|rem
operator|*
name|mdv
operator|)
operator|>>
name|cp_frac_bits
argument_list|)
return|;
endif|#
directive|endif
return|return
name|mv
operator|+
operator|(
operator|(
name|rem
operator|*
name|mdv
operator|)
operator|>>
name|cp_frac_bits
operator|)
return|;
undef|#
directive|undef
name|cp_frac_bits
block|}
end_function

begin_comment
comment|/* Remap the color in the graphics state. */
end_comment

begin_decl_stmt
name|void
name|gx_render_color
argument_list|(
name|P2
argument_list|(
name|gs_color
operator|*
argument_list|,
name|gs_state
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|gx_remap_color
parameter_list|(
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gs_color
modifier|*
name|pcolor
init|=
name|pgs
operator|->
name|color
decl_stmt|;
name|gs_color
name|mcolor
decl_stmt|;
comment|/* color mapped by transfer procs */
define|#
directive|define
name|mapcp
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
value|gx_map_color_param(pgs, pcolor->c, p)
switch|switch
condition|(
operator|(
name|gs_color_space
operator|)
name|pcolor
operator|->
name|space
condition|)
block|{
case|case
name|gs_color_space_DeviceGray
case|:
name|gx_set_gray_only
argument_list|(
operator|&
name|mcolor
argument_list|,
name|mapcp
argument_list|(
name|gray
argument_list|,
name|red
argument_list|)
argument_list|)
expr_stmt|;
comment|/* any one */
break|break;
case|case
name|gs_color_space_DeviceRGB
case|:
name|gx_set_rgb_only
argument_list|(
operator|&
name|mcolor
argument_list|,
name|mapcp
argument_list|(
name|red
argument_list|,
name|red
argument_list|)
argument_list|,
name|mapcp
argument_list|(
name|green
argument_list|,
name|green
argument_list|)
argument_list|,
name|mapcp
argument_list|(
name|blue
argument_list|,
name|blue
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|return_error
argument_list|(
name|gs_error_undefined
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|mapcp
name|gx_render_color
argument_list|(
operator|&
name|mcolor
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|gx_render_color
parameter_list|(
name|gs_color
modifier|*
name|pmcolor
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|)
block|{
name|gx_color_render
argument_list|(
name|pmcolor
argument_list|,
name|pgs
operator|->
name|dev_color
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Color conversion routines ------ */
end_comment

begin_comment
comment|/* Note: the color model conversion algorithms are taken from */
end_comment

begin_comment
comment|/* Rogers, Procedural Elements for Computer Graphics, pp. 401-403. */
end_comment

begin_comment
comment|/* Compute (if necessary) and return the luminance of a color. */
end_comment

begin_function
name|color_param
name|gx_color_luminance
parameter_list|(
specifier|register
name|gs_color
modifier|*
name|pcolor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pcolor
operator|->
name|luminance_set
condition|)
block|{
name|pcolor
operator|->
name|luminance
operator|=
operator|(
name|pcolor
operator|->
name|red
operator|*
operator|(
name|unsigned
name|long
operator|)
name|lum_red_weight
operator|+
name|pcolor
operator|->
name|green
operator|*
operator|(
name|unsigned
name|long
operator|)
name|lum_green_weight
operator|+
name|pcolor
operator|->
name|blue
operator|*
operator|(
name|unsigned
name|long
operator|)
name|lum_blue_weight
operator|+
operator|(
name|lum_all_weights
operator|/
literal|2
operator|)
operator|)
operator|/
name|lum_all_weights
expr_stmt|;
name|pcolor
operator|->
name|luminance_set
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|pcolor
operator|->
name|luminance
return|;
block|}
end_function

begin_comment
comment|/* Convert RGB to HSB */
end_comment

begin_function
name|void
name|gx_color_to_hsb
parameter_list|(
specifier|register
name|gs_color
modifier|*
name|pcolor
parameter_list|,
name|color_param
name|hsb
index|[
literal|3
index|]
parameter_list|)
block|{
define|#
directive|define
name|rhue
value|hsb[0]
define|#
directive|define
name|rsat
value|hsb[1]
define|#
directive|define
name|rbri
value|hsb[2]
if|if
condition|(
name|pcolor
operator|->
name|is_gray
condition|)
block|{
name|rhue
operator|=
literal|0
expr_stmt|;
comment|/* arbitrary */
name|rsat
operator|=
literal|0
expr_stmt|;
name|rbri
operator|=
name|pcolor
operator|->
name|red
expr_stmt|;
comment|/* pick any one */
block|}
else|else
block|{
comment|/* Convert rgb to hsb */
name|gs_color
name|c
decl_stmt|;
name|color_param
name|V
decl_stmt|,
name|Temp
decl_stmt|;
name|long
name|diff
decl_stmt|,
name|H
decl_stmt|;
name|c
operator|.
name|red
operator|=
name|pcolor
operator|->
name|red
expr_stmt|;
name|c
operator|.
name|green
operator|=
name|pcolor
operator|->
name|green
expr_stmt|;
name|c
operator|.
name|blue
operator|=
name|pcolor
operator|->
name|blue
expr_stmt|;
name|V
operator|=
operator|(
name|c
operator|.
name|red
operator|>
name|c
operator|.
name|green
condition|?
name|c
operator|.
name|red
else|:
name|c
operator|.
name|green
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|blue
operator|>
name|V
condition|)
name|V
operator|=
name|c
operator|.
name|blue
expr_stmt|;
name|Temp
operator|=
operator|(
name|c
operator|.
name|red
operator|>
name|c
operator|.
name|green
condition|?
name|c
operator|.
name|green
else|:
name|c
operator|.
name|red
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|blue
operator|<
name|Temp
condition|)
name|Temp
operator|=
name|c
operator|.
name|blue
expr_stmt|;
name|diff
operator|=
name|V
operator|-
name|Temp
expr_stmt|;
if|if
condition|(
name|V
operator|==
name|c
operator|.
name|red
condition|)
name|H
operator|=
operator|(
name|c
operator|.
name|green
operator|-
name|c
operator|.
name|blue
operator|)
operator|*
name|max_color_param_long
operator|/
name|diff
expr_stmt|;
elseif|else
if|if
condition|(
name|V
operator|==
name|c
operator|.
name|green
condition|)
name|H
operator|=
operator|(
name|c
operator|.
name|blue
operator|-
name|c
operator|.
name|red
operator|)
operator|*
name|max_color_param_long
operator|/
name|diff
operator|+
literal|2
operator|*
name|max_color_param_long
expr_stmt|;
else|else
comment|/* V == c.blue */
name|H
operator|=
operator|(
name|c
operator|.
name|red
operator|-
name|c
operator|.
name|green
operator|)
operator|*
name|max_color_param_long
operator|/
name|diff
operator|+
literal|4
operator|*
name|max_color_param_long
expr_stmt|;
if|if
condition|(
name|H
operator|<
literal|0
condition|)
name|H
operator|+=
literal|6
operator|*
name|max_color_param_long
expr_stmt|;
name|rhue
operator|=
name|H
operator|/
literal|6
expr_stmt|;
name|rsat
operator|=
name|diff
operator|*
name|max_color_param_long
operator|/
name|V
expr_stmt|;
name|rbri
operator|=
name|V
expr_stmt|;
block|}
undef|#
directive|undef
name|rhue
undef|#
directive|undef
name|rsat
undef|#
directive|undef
name|rbri
block|}
end_function

begin_comment
comment|/* Complete color specified by hsb */
end_comment

begin_function
name|void
name|gx_color_from_hsb
parameter_list|(
specifier|register
name|gs_color
modifier|*
name|pcolor
parameter_list|,
name|color_param
name|hue
parameter_list|,
name|color_param
name|saturation
parameter_list|,
name|color_param
name|brightness
parameter_list|)
block|{
if|if
condition|(
name|saturation
operator|==
literal|0
condition|)
block|{
name|pcolor
operator|->
name|red
operator|=
name|pcolor
operator|->
name|green
operator|=
name|pcolor
operator|->
name|blue
operator|=
name|brightness
expr_stmt|;
block|}
else|else
block|{
comment|/* Convert hsb to rgb. */
comment|/* We rely on the fact that the product of two */
comment|/* color_params fits into an unsigned long. */
name|ulong
name|V
init|=
name|brightness
decl_stmt|;
comment|/* force arithmetic to long */
name|color_param
name|S
init|=
name|saturation
decl_stmt|;
define|#
directive|define
name|mcp
value|max_color_param
define|#
directive|define
name|mcpl
value|max_color_param_long
define|#
directive|define
name|mcp6
value|(mcp / 6 + 1)
name|ulong
name|F
init|=
operator|(
name|hue
operator|%
name|mcp6
operator|)
operator|*
literal|6
decl_stmt|;
comment|/* ditto */
name|int
name|I
init|=
name|hue
operator|/
name|mcp6
decl_stmt|;
name|color_param
name|M
init|=
name|V
operator|*
operator|(
name|mcpl
operator|-
name|S
operator|)
operator|/
name|mcpl
decl_stmt|;
name|color_param
name|N
init|=
name|V
operator|*
operator|(
name|mcpl
operator|-
name|S
operator|*
name|F
operator|/
name|mcpl
operator|)
operator|/
name|mcpl
decl_stmt|;
name|color_param
name|K
init|=
name|V
operator|*
operator|(
name|mcpl
operator|-
name|S
operator|*
operator|(
name|mcpl
operator|-
name|F
operator|)
operator|/
name|mcpl
operator|)
operator|/
name|mcpl
decl_stmt|;
undef|#
directive|undef
name|mcp6
undef|#
directive|undef
name|mcpl
undef|#
directive|undef
name|mcp
name|color_param
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
switch|switch
condition|(
name|I
condition|)
block|{
default|default:
name|R
operator|=
name|V
expr_stmt|;
name|G
operator|=
name|K
expr_stmt|;
name|B
operator|=
name|M
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|R
operator|=
name|N
expr_stmt|;
name|G
operator|=
name|V
expr_stmt|;
name|B
operator|=
name|M
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|R
operator|=
name|M
expr_stmt|;
name|G
operator|=
name|V
expr_stmt|;
name|B
operator|=
name|K
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|R
operator|=
name|M
expr_stmt|;
name|G
operator|=
name|N
expr_stmt|;
name|B
operator|=
name|V
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|R
operator|=
name|K
expr_stmt|;
name|G
operator|=
name|M
expr_stmt|;
name|B
operator|=
name|V
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|R
operator|=
name|V
expr_stmt|;
name|G
operator|=
name|M
expr_stmt|;
name|B
operator|=
name|N
expr_stmt|;
break|break;
block|}
name|pcolor
operator|->
name|red
operator|=
name|R
expr_stmt|;
name|pcolor
operator|->
name|green
operator|=
name|G
expr_stmt|;
name|pcolor
operator|->
name|blue
operator|=
name|B
expr_stmt|;
block|}
name|gx_color_from_rgb
argument_list|(
name|pcolor
argument_list|)
expr_stmt|;
comment|/* compute luminance */
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Heapsort (algorithm 5.2.3H, Knuth vol. 2, p. 146), */
end_comment

begin_comment
comment|/* modified for 0-origin indexing. */
end_comment

begin_function
name|void
name|gx_sort_ht_order
parameter_list|(
name|ht_bit
modifier|*
name|recs
parameter_list|,
name|uint
name|N
parameter_list|)
block|{
name|uint
name|l
init|=
name|N
operator|>>
literal|1
decl_stmt|;
name|uint
name|r
init|=
name|N
operator|-
literal|1
decl_stmt|;
name|uint
name|j
decl_stmt|;
name|ht_bit
name|R
decl_stmt|;
if|if
condition|(
name|N
operator|<=
literal|1
condition|)
return|return;
define|#
directive|define
name|key
parameter_list|(
name|m
parameter_list|)
value|recs[m].mask
define|#
directive|define
name|K
value|R.mask
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|l
operator|>
literal|0
condition|)
name|R
operator|=
name|recs
index|[
operator|--
name|l
index|]
expr_stmt|;
else|else
block|{
name|R
operator|=
name|recs
index|[
name|r
index|]
expr_stmt|;
name|recs
index|[
name|r
index|]
operator|=
name|recs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|r
operator|==
literal|0
condition|)
block|{
name|recs
index|[
literal|0
index|]
operator|=
name|R
expr_stmt|;
break|break;
block|}
block|}
name|j
operator|=
name|l
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|uint
name|i
init|=
name|j
decl_stmt|;
name|j
operator|=
name|j
operator|+
name|j
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|r
condition|)
if|if
condition|(
name|key
argument_list|(
name|j
argument_list|)
operator|<
name|key
argument_list|(
name|j
operator|+
literal|1
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|r
operator|||
name|K
operator|>=
name|key
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|recs
index|[
name|i
index|]
operator|=
name|R
expr_stmt|;
break|break;
comment|/* to outer loop */
block|}
name|recs
index|[
name|i
index|]
operator|=
name|recs
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

