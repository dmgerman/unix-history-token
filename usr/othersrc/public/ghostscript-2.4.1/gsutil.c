begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gsutil.c */
end_comment

begin_comment
comment|/* Utilities for Ghostscript library */
end_comment

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"string_.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"gsprops.h"
end_include

begin_include
include|#
directive|include
file|"gsutil.h"
end_include

begin_comment
comment|/* for prototype checking */
end_comment

begin_comment
comment|/* ------ String utilities ------ */
end_comment

begin_comment
comment|/* Compare two strings, returning -1 if the first is less, */
end_comment

begin_comment
comment|/* 0 if they are equal, and 1 if first is greater. */
end_comment

begin_comment
comment|/* We can't use memcmp, because we always use unsigned characters. */
end_comment

begin_function
name|int
name|bytes_compare
parameter_list|(
specifier|const
name|byte
modifier|*
name|s1
parameter_list|,
name|uint
name|len1
parameter_list|,
specifier|const
name|byte
modifier|*
name|s2
parameter_list|,
name|uint
name|len2
parameter_list|)
block|{
specifier|register
name|uint
name|len
init|=
name|len1
decl_stmt|;
if|if
condition|(
name|len2
operator|<
name|len
condition|)
name|len
operator|=
name|len2
expr_stmt|;
block|{
specifier|register
specifier|const
name|byte
modifier|*
name|p1
init|=
name|s1
decl_stmt|;
specifier|register
specifier|const
name|byte
modifier|*
name|p2
init|=
name|s2
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
operator|(
name|p1
index|[
operator|-
literal|1
index|]
operator|<
name|p2
index|[
operator|-
literal|1
index|]
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
comment|/* Now check for differing lengths */
return|return
operator|(
name|len1
operator|==
name|len2
condition|?
literal|0
else|:
name|len1
operator|<
name|len2
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test whether a string matches a pattern with wildcards. */
end_comment

begin_comment
comment|/* '*' = any substring, '?' = any character, '\' quotes next character. */
end_comment

begin_function
name|int
name|string_match
parameter_list|(
specifier|const
name|byte
modifier|*
name|str
parameter_list|,
name|uint
name|len
parameter_list|,
specifier|const
name|byte
modifier|*
name|pstr
parameter_list|,
name|uint
name|plen
parameter_list|,
name|int
name|ignore_case
parameter_list|)
block|{
specifier|const
name|byte
modifier|*
name|pback
init|=
literal|0
decl_stmt|;
specifier|const
name|byte
modifier|*
name|p
init|=
name|pstr
decl_stmt|,
modifier|*
name|pend
init|=
name|pstr
operator|+
name|plen
decl_stmt|;
specifier|const
name|byte
modifier|*
name|sp
init|=
name|str
decl_stmt|,
modifier|*
name|spend
init|=
name|str
operator|+
name|len
decl_stmt|;
name|uint
name|matched
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|pend
condition|)
block|{
name|byte
name|ch
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'*'
case|:
name|pback
operator|=
operator|++
name|p
operator|,
name|matched
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'?'
case|:
if|if
condition|(
name|sp
operator|==
name|spend
condition|)
return|return
literal|0
return|;
comment|/* str too short */
name|p
operator|++
operator|,
name|sp
operator|++
operator|,
name|matched
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|++
name|p
operator|==
name|pend
condition|)
return|return
literal|1
return|;
comment|/* bad pattern */
name|ch
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|spend
condition|)
return|return
literal|0
return|;
comment|/* str too short */
if|if
condition|(
operator|*
name|sp
operator|==
name|ch
operator|||
name|ignore_case
operator|&&
operator|(
operator|*
name|sp
operator|^
name|ch
operator|)
operator|==
literal|0x20
operator|&&
operator|(
name|ch
operator|&=
operator|~
literal|0x20
operator|)
operator|>=
literal|0x41
operator|&&
name|ch
operator|<=
literal|0x5a
condition|)
name|p
operator|++
operator|,
name|sp
operator|++
operator|,
name|matched
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|pback
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no * to back up to */
else|else
block|{
name|sp
operator|+=
literal|1
operator|-
name|matched
expr_stmt|;
name|p
operator|=
name|pback
expr_stmt|;
name|matched
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash for a string */
end_comment

begin_function
name|uint
name|string_hash
parameter_list|(
specifier|const
name|byte
modifier|*
name|ptr
parameter_list|,
name|uint
name|len
parameter_list|)
block|{
specifier|register
specifier|const
name|byte
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
specifier|register
name|uint
name|hash
init|=
literal|0
decl_stmt|;
specifier|register
name|uint
name|n
init|=
name|len
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
name|hash
operator|=
name|hash
operator|*
literal|19
operator|+
operator|*
name|p
operator|++
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* ------ Property list utilities ------ */
end_comment

begin_comment
comment|/* Extract known properties from a list.  See gsutil.h for more details. */
end_comment

begin_function
name|int
name|props_extract
parameter_list|(
name|gs_prop_item
modifier|*
name|plist
parameter_list|,
name|int
name|count
parameter_list|,
specifier|const
name|gs_prop_item
modifier|*
name|template
parameter_list|,
name|int
name|tcount
parameter_list|,
name|gs_prop_item
modifier|*
modifier|*
name|pknown
parameter_list|,
name|int
name|finished
parameter_list|)
block|{
specifier|const
name|gs_prop_item
modifier|*
name|pti
decl_stmt|;
name|gs_prop_item
modifier|*
modifier|*
name|ppi
decl_stmt|;
name|gs_prop_item
modifier|*
name|pli
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|pti
operator|=
name|template
operator|,
name|ppi
operator|=
name|pknown
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|tcount
condition|;
name|pti
operator|++
operator|,
name|ppi
operator|++
operator|,
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|tstr
init|=
name|pti
operator|->
name|pname
decl_stmt|;
name|int
name|tlen
init|=
name|pti
operator|->
name|name_size
decl_stmt|;
if|if
condition|(
name|tstr
operator|==
literal|0
condition|)
continue|continue;
comment|/* no name */
if|if
condition|(
name|tlen
operator|<
literal|0
condition|)
name|tlen
operator|=
name|strlen
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
operator|*
name|ppi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pli
operator|=
name|plist
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|pli
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|pli
operator|->
name|status
operator|==
name|pv_set
condition|)
block|{
specifier|const
name|char
modifier|*
name|lstr
init|=
name|pli
operator|->
name|pname
decl_stmt|;
name|int
name|llen
init|=
name|pli
operator|->
name|name_size
decl_stmt|;
if|if
condition|(
name|lstr
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|llen
operator|<
literal|0
condition|)
name|llen
operator|=
name|strlen
argument_list|(
name|lstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|llen
operator|==
name|tlen
operator|&&
operator|!
name|memcmp
argument_list|(
name|tstr
argument_list|,
name|lstr
argument_list|,
name|llen
argument_list|)
condition|)
block|{
comment|/* Names match, check types. */
if|if
condition|(
name|pli
operator|->
name|type
operator|!=
name|pti
operator|->
name|type
condition|)
block|{
comment|/* Check for int [array] -> float [array] */
if|if
condition|(
name|pli
operator|->
name|type
operator|==
name|prt_int
operator|&&
name|pti
operator|->
name|type
operator|==
name|prt_float
condition|)
name|pli
operator|->
name|type
operator|=
name|prt_float
operator|,
name|pli
operator|->
name|value
operator|.
name|f
operator|=
name|pli
operator|->
name|value
operator|.
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|pli
operator|->
name|type
operator|==
name|prt_int_array
operator|&&
name|pti
operator|->
name|type
operator|==
name|prt_float_array
condition|)
block|{
name|int
name|i
decl_stmt|;
name|gs_prop_item
modifier|*
name|vp
init|=
name|pli
operator|->
name|value
operator|.
name|a
operator|.
name|p
operator|.
name|v
decl_stmt|;
name|pli
operator|->
name|type
operator|=
name|prt_float_array
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pli
operator|->
name|value
operator|.
name|a
operator|.
name|size
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|vp
operator|++
control|)
name|vp
operator|->
name|type
operator|=
name|prt_float
operator|,
name|vp
operator|->
name|value
operator|.
name|f
operator|=
name|vp
operator|->
name|value
operator|.
name|i
expr_stmt|;
block|}
else|else
block|{
name|pli
operator|->
name|status
operator|=
name|pv_typecheck
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|ppi
operator|=
name|pli
operator|,
name|pli
operator|->
name|status
operator|=
name|pv_OK
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|finished
condition|)
for|for
control|(
name|pli
operator|=
name|plist
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|pli
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|pli
operator|->
name|status
operator|!=
name|pv_OK
condition|)
name|pli
operator|->
name|status
operator|=
name|pv_unknown
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

