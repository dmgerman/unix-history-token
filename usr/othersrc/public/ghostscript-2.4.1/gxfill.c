begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gxfill.c */
end_comment

begin_comment
comment|/* Lower-level path filling procedures for GhostScript library */
end_comment

begin_include
include|#
directive|include
file|"gx.h"
end_include

begin_include
include|#
directive|include
file|"gserrors.h"
end_include

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* for gx_color_index */
end_comment

begin_include
include|#
directive|include
file|"gzcolor.h"
end_include

begin_include
include|#
directive|include
file|"gzpath.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_include
include|#
directive|include
file|"gxcpath.h"
end_include

begin_comment
comment|/* Import the fixed * fixed / fixed routine from gxdraw.c. */
end_comment

begin_comment
comment|/* The second argument must be less than or equal to the third; */
end_comment

begin_comment
comment|/* all must be non-negative, and the last must be non-zero. */
end_comment

begin_decl_stmt
specifier|extern
name|fixed
name|fixed_mult_quo
argument_list|(
name|P3
argument_list|(
name|fixed
argument_list|,
name|fixed
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the structure for keeping track of active lines. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|active_line_s
name|active_line
typedef|;
end_typedef

begin_struct
struct|struct
name|active_line_s
block|{
name|gs_fixed_point
name|start
decl_stmt|;
comment|/* x,y where line starts */
name|gs_fixed_point
name|end
decl_stmt|;
comment|/* x,y where line ends */
define|#
directive|define
name|al_dx
parameter_list|(
name|alp
parameter_list|)
value|((alp)->end.x - (alp)->start.x)
define|#
directive|define
name|al_dy
parameter_list|(
name|alp
parameter_list|)
value|((alp)->end.y - (alp)->start.y)
name|fixed
name|y_fast_max
decl_stmt|;
comment|/* can do x_at_y in fixed point */
comment|/* if y<= y_fast_max */
define|#
directive|define
name|set_al_points
parameter_list|(
name|alp
parameter_list|,
name|startp
parameter_list|,
name|endp
parameter_list|)
define|\
value|(alp)->y_fast_max = max_fixed / (((endp).x> (startp).x ?\     (endp).x - (startp).x : (startp).x - (endp).x) | 1) + (startp).y,\   (alp)->start = startp, (alp)->end = endp
define|#
directive|define
name|al_x_at_y
parameter_list|(
name|alp
parameter_list|,
name|yv
parameter_list|)
define|\
value|((yv) == (alp)->end.y ? (alp)->end.x :\    ((yv)<= (alp)->y_fast_max ?\     ((yv) - (alp)->start.y) * al_dx(alp) / al_dy(alp) :\     (stat(n_slow_x),\      fixed_mult_quo(al_dx(alp), (yv) - (alp)->start.y, al_dy(alp)))) +\    (alp)->start.x)
name|fixed
name|x_current
decl_stmt|;
comment|/* current x position */
name|fixed
name|x_next
decl_stmt|;
comment|/* x position at end of band */
name|segment
modifier|*
name|pseg
decl_stmt|;
comment|/* endpoint of this line */
name|int
name|direction
decl_stmt|;
comment|/* direction of line segment */
define|#
directive|define
name|dir_up
value|1
define|#
directive|define
name|dir_down
value|(-1)
comment|/* "Pending" lines (not reached in the Y ordering yet) use next and prev */
comment|/* to order lines by increasing starting Y.  "Active" lines (being scanned) */
comment|/* use next and prev to order lines by increasing current X, or if the */
comment|/* current Xs are equal, by increasing final X. */
name|active_line
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Link together active_lines allocated individually */
name|active_line
modifier|*
name|alloc_next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Define the ordering criterion for active lines. */
end_comment

begin_comment
comment|/* The xc argument is a copy of lp2->x_current. */
end_comment

begin_define
define|#
directive|define
name|x_precedes
parameter_list|(
name|lp1
parameter_list|,
name|lp2
parameter_list|,
name|xc
parameter_list|)
define|\
value|(lp1->x_current< xc || lp1->x_current == xc&&\    (lp1->start.x> lp2->start.x || lp1->end.x< lp2->end.x))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* Internal procedures for printing active lines */
end_comment

begin_function
name|private
name|void
name|print_active_line
parameter_list|(
name|char
modifier|*
name|label
parameter_list|,
name|active_line
modifier|*
name|alp
parameter_list|)
block|{
name|dprintf5
argument_list|(
literal|"[f]%s %lx(%d): x_current=%f x_next=%f\n"
argument_list|,
name|label
argument_list|,
operator|(
name|ulong
operator|)
name|alp
argument_list|,
name|alp
operator|->
name|direction
argument_list|,
name|fixed2float
argument_list|(
name|alp
operator|->
name|x_current
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|alp
operator|->
name|x_next
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf5
argument_list|(
literal|"    start=(%f,%f) pt_end=%lx(%f,%f)\n"
argument_list|,
name|fixed2float
argument_list|(
name|alp
operator|->
name|start
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|alp
operator|->
name|start
operator|.
name|y
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|alp
operator|->
name|pseg
argument_list|,
name|fixed2float
argument_list|(
name|alp
operator|->
name|end
operator|.
name|x
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|alp
operator|->
name|end
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf2
argument_list|(
literal|"    prev=%lx next=%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|alp
operator|->
name|prev
argument_list|,
operator|(
name|ulong
operator|)
name|alp
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|print_line_list
parameter_list|(
name|active_line
modifier|*
name|flp
parameter_list|)
block|{
name|active_line
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|flp
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|fixed
name|xc
init|=
name|lp
operator|->
name|x_current
decl_stmt|,
name|xn
init|=
name|lp
operator|->
name|x_next
decl_stmt|;
name|dprintf3
argument_list|(
literal|"[f]%lx(%d): x_current/next=%g"
argument_list|,
operator|(
name|ulong
operator|)
name|lp
argument_list|,
name|lp
operator|->
name|direction
argument_list|,
name|fixed2float
argument_list|(
name|xc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xn
operator|!=
name|xc
condition|)
name|dprintf1
argument_list|(
literal|"/%g"
argument_list|,
name|fixed2float
argument_list|(
name|xn
argument_list|)
argument_list|)
expr_stmt|;
name|dputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|print_al
parameter_list|(
name|label
parameter_list|,
name|alp
parameter_list|)
define|\
value|if ( gs_debug['F'] ) print_active_line(label, alp)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print_al
parameter_list|(
name|label
parameter_list|,
name|alp
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Line list structure */
end_comment

begin_struct
struct|struct
name|line_list_s
block|{
name|active_line
modifier|*
name|active_area
decl_stmt|;
comment|/* allocated active_line list */
name|line_close_segment
modifier|*
name|close_area
decl_stmt|;
comment|/* allocated closing line area */
name|uint
name|close_count
decl_stmt|;
name|gs_fixed_rect
name|box
decl_stmt|;
comment|/* intersection of bounding boxes, */
comment|/* disregard lines outside this */
name|active_line
modifier|*
name|next_active
decl_stmt|;
comment|/* next allocation slot */
name|active_line
modifier|*
name|limit
decl_stmt|;
comment|/* limit of local allocation */
name|line_close_segment
modifier|*
name|next_line
decl_stmt|;
comment|/* next line allocation slot */
name|active_line
modifier|*
name|y_list
decl_stmt|;
comment|/* Y-sorted list of pending lines */
name|active_line
modifier|*
name|y_line
decl_stmt|;
comment|/* most recently inserted line */
name|active_line
name|x_head
decl_stmt|;
comment|/* X-sorted list of active lines */
define|#
directive|define
name|x_list
value|x_head.next
comment|/* Put the arrays last so the scalars will have */
comment|/* small displacements. */
comment|/* Allocate a few active_lines and line_close_segments */
comment|/* locally to avoid round trips through the allocator. */
define|#
directive|define
name|max_local_active
value|20
name|active_line
name|local_active
index|[
name|max_local_active
index|]
decl_stmt|;
define|#
directive|define
name|max_local_close
value|5
name|line_close_segment
name|local_close
index|[
name|max_local_close
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|line_list_s
name|line_list
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|line_list
name|_ss
modifier|*
name|ll_ptr
typedef|;
end_typedef

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
name|private
name|int
name|alloc_line_list
argument_list|(
name|P2
argument_list|(
name|ll_ptr
argument_list|,
name|uint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|free_line_list
argument_list|(
name|P1
argument_list|(
name|ll_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|add_y_list
argument_list|(
name|P2
argument_list|(
name|gx_path
operator|*
argument_list|,
name|ll_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|add_y_line
argument_list|(
name|P4
argument_list|(
name|segment
operator|*
argument_list|,
name|segment
operator|*
argument_list|,
name|int
argument_list|,
name|ll_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|fill_loop
argument_list|(
name|P5
argument_list|(
name|gx_device_color
operator|*
argument_list|,
name|int
argument_list|,
name|ll_ptr
argument_list|,
name|gs_state
operator|*
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|insert_x_new
argument_list|(
name|P2
argument_list|(
name|active_line
operator|*
argument_list|,
name|ll_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|update_x_list
argument_list|(
name|P2
argument_list|(
name|active_line
operator|*
argument_list|,
name|fixed
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|stat
parameter_list|(
name|x
parameter_list|)
value|(x++)
end_define

begin_define
define|#
directive|define
name|statn
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(x += (n))
end_define

begin_decl_stmt
name|private
name|long
name|n_fill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_fill_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_y_up
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_y_down
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_x_step
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_slow_x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_iter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_find_y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_band
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_band_step
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|n_band_fill
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|stat
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|statn
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* General area filling algorithm. */
end_comment

begin_comment
comment|/* The adjust parameter is a hack for keeping small characters */
end_comment

begin_comment
comment|/* from coming out too faint: it specifies an amount by which to expand */
end_comment

begin_comment
comment|/* all sides of every filled region. */
end_comment

begin_function
name|int
name|gx_fill_path
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|gx_device_color
modifier|*
name|pdevc
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|int
name|rule
parameter_list|,
name|fixed
name|adjust
parameter_list|)
block|{
name|gx_clip_path
modifier|*
name|pcpath
init|=
name|pgs
operator|->
name|clip_path
decl_stmt|;
name|gs_fixed_rect
name|cbox
decl_stmt|;
name|gx_path
modifier|*
name|pfpath
decl_stmt|;
name|gx_path
name|ffpath
decl_stmt|;
name|int
name|code
decl_stmt|;
name|line_list
name|lst
decl_stmt|;
name|uint
name|sub_count
decl_stmt|;
name|gx_device_clip
name|cdev
decl_stmt|;
name|int
name|do_clip
decl_stmt|;
comment|/* Fatten everything a little to make it look better. */
comment|/****** This is something of a hack. ******/
if|if
condition|(
name|adjust
operator|==
literal|0
condition|)
name|adjust
operator|=
name|float2fixed
argument_list|(
literal|0.25
argument_list|)
expr_stmt|;
comment|/* Start by flattening the path.  We should do this on-the-fly.... */
if|if
condition|(
operator|!
name|ppath
operator|->
name|curve_count
condition|)
comment|/* don't need to flatten */
name|pfpath
operator|=
name|ppath
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|code
operator|=
name|gx_path_flatten
argument_list|(
name|ppath
argument_list|,
operator|&
name|ffpath
argument_list|,
name|pgs
operator|->
name|flatness
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|pfpath
operator|=
operator|&
name|ffpath
expr_stmt|;
block|}
comment|/* Check the bounding boxes. */
define|#
directive|define
name|ibox
value|lst.box
name|gx_path_bbox
argument_list|(
name|pfpath
argument_list|,
operator|&
name|ibox
argument_list|)
expr_stmt|;
name|gx_cpath_box_for_check
argument_list|(
name|pcpath
argument_list|,
operator|&
name|cbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibox
operator|.
name|q
operator|.
name|y
operator|<=
name|cbox
operator|.
name|q
operator|.
name|y
operator|&&
name|ibox
operator|.
name|q
operator|.
name|x
operator|<=
name|cbox
operator|.
name|q
operator|.
name|x
operator|&&
name|ibox
operator|.
name|p
operator|.
name|y
operator|>=
name|cbox
operator|.
name|p
operator|.
name|y
operator|&&
name|ibox
operator|.
name|p
operator|.
name|x
operator|>=
name|cbox
operator|.
name|p
operator|.
name|x
condition|)
block|{
comment|/* Path lies entirely within clipping rectangle */
name|do_clip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Intersect the path box and the clip bounding box. */
comment|/* If the intersection is empty, this fill is a no-op. */
name|gs_fixed_rect
name|bbox
decl_stmt|;
name|bbox
operator|=
name|pcpath
operator|->
name|path
operator|.
name|bbox
expr_stmt|;
if|if
condition|(
name|ibox
operator|.
name|p
operator|.
name|x
operator|>=
name|bbox
operator|.
name|q
operator|.
name|x
operator|||
name|ibox
operator|.
name|p
operator|.
name|y
operator|>=
name|bbox
operator|.
name|q
operator|.
name|y
operator|||
name|ibox
operator|.
name|q
operator|.
name|x
operator|<=
name|bbox
operator|.
name|p
operator|.
name|x
operator|||
name|ibox
operator|.
name|q
operator|.
name|y
operator|<=
name|bbox
operator|.
name|p
operator|.
name|y
condition|)
block|{
comment|/* Intersection of boxes is empty! */
name|code
operator|=
literal|0
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|do_clip
operator|=
literal|1
expr_stmt|;
block|}
undef|#
directive|undef
name|ibox
name|sub_count
operator|=
name|pfpath
operator|->
name|subpath_count
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code
operator|=
name|alloc_line_list
argument_list|(
operator|&
name|lst
argument_list|,
name|sub_count
argument_list|)
operator|)
condition|)
block|{
name|gx_device
modifier|*
name|save_dev
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|add_y_list
argument_list|(
name|pfpath
argument_list|,
operator|&
name|lst
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
if|if
condition|(
name|do_clip
condition|)
block|{
comment|/* Set up a clipping device. */
name|gx_device
modifier|*
name|dev
init|=
operator|(
name|gx_device
operator|*
operator|)
operator|&
name|cdev
decl_stmt|;
name|save_dev
operator|=
name|gs_currentdevice
argument_list|(
name|pgs
argument_list|)
expr_stmt|;
name|cdev
operator|=
name|gs_clip_device
expr_stmt|;
name|cdev
operator|.
name|target
operator|=
name|save_dev
expr_stmt|;
name|cdev
operator|.
name|list
operator|=
name|pcpath
operator|->
name|list
expr_stmt|;
name|gx_set_device_only
argument_list|(
name|pgs
argument_list|,
name|dev
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|procs
operator|->
name|open_device
call|)
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|fill_loop
argument_list|(
name|pdevc
argument_list|,
name|rule
argument_list|,
operator|&
name|lst
argument_list|,
name|pgs
argument_list|,
name|adjust
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_clip
condition|)
name|gx_set_device_only
argument_list|(
name|pgs
argument_list|,
name|save_dev
argument_list|)
expr_stmt|;
name|nope
label|:
name|free_line_list
argument_list|(
operator|&
name|lst
argument_list|)
expr_stmt|;
block|}
name|skip
label|:
if|if
condition|(
name|pfpath
operator|!=
name|ppath
condition|)
comment|/* had to flatten */
name|gx_path_release
argument_list|(
name|pfpath
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'f'
index|]
operator|||
name|gs_debug
index|[
literal|'F'
index|]
condition|)
block|{
name|dputs
argument_list|(
literal|"[f]calls alloc   up   down  step slowx  iter  find  band bstep bfill\n"
argument_list|)
expr_stmt|;
name|dprintf4
argument_list|(
literal|"   %5ld %5ld %5ld %5ld"
argument_list|,
name|n_fill
argument_list|,
name|n_fill_alloc
argument_list|,
name|n_y_up
argument_list|,
name|n_y_down
argument_list|)
expr_stmt|;
name|dprintf4
argument_list|(
literal|" %5ld %5ld %5ld %5ld"
argument_list|,
name|n_x_step
argument_list|,
name|n_slow_x
argument_list|,
name|n_iter
argument_list|,
name|n_find_y
argument_list|)
expr_stmt|;
name|dprintf3
argument_list|(
literal|" %5ld %5ld %5ld\n"
argument_list|,
name|n_band
argument_list|,
name|n_band_step
argument_list|,
name|n_band_fill
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Create a line list for a (flattened) path. */
end_comment

begin_comment
comment|/* We pass in the list size, so that we can use this to iterate */
end_comment

begin_comment
comment|/* over more than one path simultaneously (needed for clipping). */
end_comment

begin_function
name|private
name|int
name|alloc_line_list
parameter_list|(
name|ll_ptr
name|ll
parameter_list|,
name|uint
name|sub_count
parameter_list|)
block|{
name|ll
operator|->
name|active_area
operator|=
literal|0
expr_stmt|;
name|ll
operator|->
name|close_count
operator|=
name|sub_count
expr_stmt|;
name|ll
operator|->
name|close_area
operator|=
operator|(
name|sub_count
operator|<=
name|max_local_close
condition|?
name|ll
operator|->
name|local_close
else|:
operator|(
name|line_close_segment
operator|*
operator|)
name|gs_malloc
argument_list|(
name|sub_count
argument_list|,
sizeof|sizeof
argument_list|(
name|line_close_segment
argument_list|)
argument_list|,
literal|"closing lines"
argument_list|)
operator|)
expr_stmt|;
name|ll
operator|->
name|next_line
operator|=
name|ll
operator|->
name|close_area
expr_stmt|;
if|if
condition|(
name|ll
operator|->
name|close_area
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|ll
operator|->
name|next_active
operator|=
name|ll
operator|->
name|local_active
expr_stmt|;
name|ll
operator|->
name|limit
operator|=
name|ll
operator|->
name|next_active
operator|+
name|max_local_active
expr_stmt|;
name|ll
operator|->
name|y_list
operator|=
literal|0
expr_stmt|;
name|ll
operator|->
name|y_line
operator|=
literal|0
expr_stmt|;
name|stat
argument_list|(
name|n_fill
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free the line list */
end_comment

begin_function
name|private
name|void
name|free_line_list
parameter_list|(
name|ll_ptr
name|ll
parameter_list|)
block|{
name|line_close_segment
modifier|*
name|lp
decl_stmt|;
name|active_line
modifier|*
name|alp
decl_stmt|;
comment|/* Splice out any inserted closing lines */
for|for
control|(
name|lp
operator|=
name|ll
operator|->
name|close_area
init|;
name|lp
operator|!=
name|ll
operator|->
name|next_line
condition|;
name|lp
operator|++
control|)
block|{
name|segment
modifier|*
name|prev
init|=
name|lp
operator|->
name|prev
decl_stmt|,
modifier|*
name|next
init|=
name|lp
operator|->
name|next
decl_stmt|;
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|lp
operator|->
name|sub
operator|->
name|last
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Free any individually allocated active_lines. */
while|while
condition|(
operator|(
name|alp
operator|=
name|ll
operator|->
name|active_area
operator|)
operator|!=
literal|0
condition|)
block|{
name|active_line
modifier|*
name|next
init|=
name|alp
operator|->
name|alloc_next
decl_stmt|;
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alp
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|active_line
argument_list|)
argument_list|,
literal|"active line"
argument_list|)
expr_stmt|;
name|ll
operator|->
name|active_area
operator|=
name|next
expr_stmt|;
block|}
comment|/* Free any separately allocated closing lines. */
if|if
condition|(
name|ll
operator|->
name|close_area
operator|!=
name|ll
operator|->
name|local_close
operator|&&
name|ll
operator|->
name|close_area
operator|!=
literal|0
condition|)
block|{
name|gs_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ll
operator|->
name|close_area
argument_list|,
name|ll
operator|->
name|close_count
argument_list|,
sizeof|sizeof
argument_list|(
name|line_close_segment
argument_list|)
argument_list|,
literal|"closing lines"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Construct a Y-sorted list of lines for a (flattened) path. */
end_comment

begin_comment
comment|/* We assume the path is non-empty.  Only include non-horizontal */
end_comment

begin_comment
comment|/* lines where one endpoint is locally Y-minimal. */
end_comment

begin_function
name|private
name|int
name|add_y_list
parameter_list|(
name|gx_path
modifier|*
name|ppath
parameter_list|,
name|ll_ptr
name|ll
parameter_list|)
block|{
specifier|register
name|segment
modifier|*
name|pseg
init|=
operator|(
name|segment
operator|*
operator|)
name|ppath
operator|->
name|first_subpath
decl_stmt|;
name|subpath
modifier|*
name|psub
decl_stmt|;
name|segment
modifier|*
name|plast
decl_stmt|;
name|int
name|first_dir
decl_stmt|,
name|prev_dir
decl_stmt|,
name|dir
decl_stmt|;
name|segment
modifier|*
name|prev
decl_stmt|;
comment|/* fixed xmin = ll->box.p.x; */
comment|/* not currently used */
name|fixed
name|ymin
init|=
name|ll
operator|->
name|box
operator|.
name|p
operator|.
name|y
decl_stmt|;
name|fixed
name|xmax
init|=
name|ll
operator|->
name|box
operator|.
name|q
operator|.
name|x
decl_stmt|;
name|fixed
name|ymax
init|=
name|ll
operator|->
name|box
operator|.
name|q
operator|.
name|y
decl_stmt|;
name|int
name|code
decl_stmt|;
while|while
condition|(
name|pseg
condition|)
block|{
switch|switch
condition|(
name|pseg
operator|->
name|type
condition|)
block|{
comment|/* No curves left */
case|case
name|s_start
case|:
name|psub
operator|=
operator|(
name|subpath
operator|*
operator|)
name|pseg
expr_stmt|;
name|plast
operator|=
name|psub
operator|->
name|last
expr_stmt|;
name|dir
operator|=
literal|2
expr_stmt|;
comment|/* hack to skip first line */
if|if
condition|(
name|plast
operator|->
name|type
operator|!=
name|s_line_close
condition|)
block|{
comment|/* Create a fake s_line_close */
name|line_close_segment
modifier|*
name|lp
init|=
name|ll
operator|->
name|next_line
operator|++
decl_stmt|;
name|segment
modifier|*
name|next
init|=
name|plast
operator|->
name|next
decl_stmt|;
name|lp
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|lp
operator|->
name|prev
operator|=
name|plast
expr_stmt|;
name|plast
operator|->
name|next
operator|=
operator|(
name|segment
operator|*
operator|)
name|lp
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
operator|(
name|segment
operator|*
operator|)
name|lp
expr_stmt|;
name|lp
operator|->
name|type
operator|=
name|s_line_close
expr_stmt|;
name|lp
operator|->
name|pt
operator|=
name|psub
operator|->
name|pt
expr_stmt|;
name|lp
operator|->
name|sub
operator|=
name|psub
expr_stmt|;
name|plast
operator|=
operator|(
name|segment
operator|*
operator|)
name|lp
expr_stmt|;
name|psub
operator|->
name|last
operator|=
name|plast
expr_stmt|;
block|}
break|break;
default|default:
comment|/* s_line, _close */
block|{
name|fixed
name|iy
init|=
name|pseg
operator|->
name|pt
operator|.
name|y
decl_stmt|;
name|fixed
name|py
init|=
name|prev
operator|->
name|pt
operator|.
name|y
decl_stmt|;
comment|/* Lines falling entirely outside the ibox */
comment|/* are treated as though they were horizontal, */
comment|/* i.e., they are never put on the list. */
define|#
directive|define
name|compute_dir
parameter_list|(
name|xo
parameter_list|,
name|xe
parameter_list|,
name|yo
parameter_list|,
name|ye
parameter_list|)
define|\
value|(xo> xmax&& xe> xmax ? 0 :\    ye> yo ? (ye<= ymin || yo>= ymax ? 0 : dir_up) :\    ye< yo ? (yo<= ymin || ye>= ymax ? 0 : dir_down) :\    0)
define|#
directive|define
name|add_dir_lines
parameter_list|(
name|prev2
parameter_list|,
name|prev
parameter_list|,
name|this
parameter_list|,
name|pdir
parameter_list|,
name|dir
parameter_list|)
define|\
value|if ( pdir )\    { if ( (code = add_y_line(prev2, prev, pdir, ll))< 0 ) return code; }\   if ( dir )\    { if ( (code = add_y_line(prev, this, dir, ll))< 0 ) return code; }
name|dir
operator|=
name|compute_dir
argument_list|(
name|prev
operator|->
name|pt
operator|.
name|x
argument_list|,
name|pseg
operator|->
name|pt
operator|.
name|x
argument_list|,
name|py
argument_list|,
name|iy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|>
name|prev_dir
condition|)
block|{
name|add_dir_lines
argument_list|(
name|prev
operator|->
name|prev
argument_list|,
name|prev
argument_list|,
name|pseg
argument_list|,
name|prev_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_dir
operator|==
literal|2
condition|)
comment|/* first line */
name|first_dir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|pseg
operator|==
name|plast
condition|)
block|{
comment|/* We skipped the first segment of the */
comment|/* subpath, so the last segment must */
comment|/* receive special consideration. */
comment|/* Note that we have `closed' all subpaths. */
if|if
condition|(
name|first_dir
operator|>
name|dir
condition|)
block|{
name|add_dir_lines
argument_list|(
name|prev
argument_list|,
name|pseg
argument_list|,
name|psub
operator|->
name|next
argument_list|,
name|dir
argument_list|,
name|first_dir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|compute_dir
undef|#
directive|undef
name|add_dir_lines
block|}
name|prev
operator|=
name|pseg
expr_stmt|;
name|prev_dir
operator|=
name|dir
expr_stmt|;
name|pseg
operator|=
name|pseg
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal routine to test a line segment and add it to the */
end_comment

begin_comment
comment|/* pending list if appropriate. */
end_comment

begin_function
name|private
name|int
name|add_y_line
parameter_list|(
name|segment
modifier|*
name|prev_lp
parameter_list|,
name|segment
modifier|*
name|lp
parameter_list|,
name|int
name|dir
parameter_list|,
name|ll_ptr
name|ll
parameter_list|)
block|{
name|gs_fixed_point
name|this
decl_stmt|,
name|prev
decl_stmt|;
specifier|register
name|active_line
modifier|*
name|alp
init|=
name|ll
operator|->
name|next_active
decl_stmt|;
name|fixed
name|y_start
decl_stmt|;
if|if
condition|(
name|alp
operator|==
name|ll
operator|->
name|limit
condition|)
block|{
comment|/* Allocate separately */
name|alp
operator|=
operator|(
name|active_line
operator|*
operator|)
name|gs_malloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|active_line
argument_list|)
argument_list|,
literal|"active line"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alp
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|gs_error_VMerror
argument_list|)
expr_stmt|;
name|alp
operator|->
name|alloc_next
operator|=
name|ll
operator|->
name|active_area
expr_stmt|;
name|ll
operator|->
name|active_area
operator|=
name|alp
expr_stmt|;
name|stat
argument_list|(
name|n_fill_alloc
argument_list|)
expr_stmt|;
block|}
else|else
name|ll
operator|->
name|next_active
operator|++
expr_stmt|;
name|this
operator|.
name|x
operator|=
name|lp
operator|->
name|pt
operator|.
name|x
expr_stmt|;
name|this
operator|.
name|y
operator|=
name|lp
operator|->
name|pt
operator|.
name|y
expr_stmt|;
name|prev
operator|.
name|x
operator|=
name|prev_lp
operator|->
name|pt
operator|.
name|x
expr_stmt|;
name|prev
operator|.
name|y
operator|=
name|prev_lp
operator|->
name|pt
operator|.
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|alp
operator|->
name|direction
operator|=
name|dir
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* Upward line */
name|y_start
operator|=
name|prev
operator|.
name|y
expr_stmt|;
name|set_al_points
argument_list|(
name|alp
argument_list|,
name|prev
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|alp
operator|->
name|pseg
operator|=
name|lp
expr_stmt|;
block|}
else|else
block|{
comment|/* Downward line */
name|y_start
operator|=
name|this
operator|.
name|y
expr_stmt|;
name|set_al_points
argument_list|(
name|alp
argument_list|,
name|this
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|alp
operator|->
name|pseg
operator|=
name|prev_lp
expr_stmt|;
block|}
comment|/* Insert the new line in the Y ordering */
block|{
specifier|register
name|active_line
modifier|*
name|yp
init|=
name|ll
operator|->
name|y_line
decl_stmt|;
specifier|register
name|active_line
modifier|*
name|nyp
decl_stmt|;
if|if
condition|(
name|yp
operator|==
literal|0
condition|)
block|{
name|alp
operator|->
name|next
operator|=
name|alp
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|ll
operator|->
name|y_list
operator|=
name|alp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y_start
operator|>=
name|yp
operator|->
name|start
operator|.
name|y
condition|)
block|{
comment|/* Insert the new line after y_line */
while|while
condition|(
name|stat
argument_list|(
name|n_y_up
argument_list|)
operator|,
operator|(
name|nyp
operator|=
name|yp
operator|->
name|next
operator|)
operator|!=
name|NULL
operator|&&
name|y_start
operator|>
name|nyp
operator|->
name|start
operator|.
name|y
condition|)
name|yp
operator|=
name|nyp
expr_stmt|;
name|alp
operator|->
name|next
operator|=
name|nyp
expr_stmt|;
name|alp
operator|->
name|prev
operator|=
name|yp
expr_stmt|;
name|yp
operator|->
name|next
operator|=
name|alp
expr_stmt|;
if|if
condition|(
name|nyp
condition|)
name|nyp
operator|->
name|prev
operator|=
name|alp
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert the new line before y_line */
while|while
condition|(
name|stat
argument_list|(
name|n_y_down
argument_list|)
operator|,
operator|(
name|nyp
operator|=
name|yp
operator|->
name|prev
operator|)
operator|!=
name|NULL
operator|&&
name|y_start
operator|<
name|nyp
operator|->
name|start
operator|.
name|y
condition|)
name|yp
operator|=
name|nyp
expr_stmt|;
name|alp
operator|->
name|prev
operator|=
name|nyp
expr_stmt|;
name|alp
operator|->
name|next
operator|=
name|yp
expr_stmt|;
name|yp
operator|->
name|prev
operator|=
name|alp
expr_stmt|;
if|if
condition|(
name|nyp
condition|)
name|nyp
operator|->
name|next
operator|=
name|alp
expr_stmt|;
else|else
name|ll
operator|->
name|y_list
operator|=
name|alp
expr_stmt|;
block|}
block|}
name|ll
operator|->
name|y_line
operator|=
name|alp
expr_stmt|;
name|print_al
argument_list|(
literal|"add "
argument_list|,
name|alp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Main filling loop.  Takes lines off of y_list and adds them to */
end_comment

begin_comment
comment|/* x_list as needed. */
end_comment

begin_function
name|private
name|int
name|fill_loop
parameter_list|(
name|gx_device_color
modifier|*
name|pdevc
parameter_list|,
name|int
name|rule
parameter_list|,
name|ll_ptr
name|ll
parameter_list|,
name|gs_state
modifier|*
name|pgs
parameter_list|,
name|fixed
name|adjust
parameter_list|)
block|{
name|fixed
name|adj2
init|=
name|adjust
operator|<<
literal|1
decl_stmt|;
name|active_line
modifier|*
name|yll
init|=
name|ll
operator|->
name|y_list
decl_stmt|;
name|gs_fixed_point
name|pmax
decl_stmt|;
name|fixed
name|y
decl_stmt|;
if|if
condition|(
name|yll
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* empty list */
name|pmax
operator|=
name|ll
operator|->
name|box
operator|.
name|q
expr_stmt|;
name|y
operator|=
name|yll
operator|->
name|start
operator|.
name|y
expr_stmt|;
comment|/* first Y value */
name|ll
operator|->
name|x_list
operator|=
literal|0
expr_stmt|;
name|ll
operator|->
name|x_head
operator|.
name|x_current
operator|=
name|min_fixed
expr_stmt|;
comment|/* stop backward scan */
while|while
condition|(
literal|1
condition|)
block|{
name|fixed
name|y1
decl_stmt|,
name|y0
decl_stmt|;
name|active_line
modifier|*
name|endp
decl_stmt|,
modifier|*
name|alp
decl_stmt|,
modifier|*
name|stopx
decl_stmt|;
name|fixed
name|x
decl_stmt|;
name|int
name|draw
decl_stmt|;
name|stat
argument_list|(
name|n_iter
argument_list|)
expr_stmt|;
comment|/* Check whether we've reached the maximum y. */
if|if
condition|(
name|y
operator|>=
name|pmax
operator|.
name|y
condition|)
break|break;
comment|/* Move newly active lines from y to x list. */
while|while
condition|(
name|yll
operator|!=
literal|0
operator|&&
name|yll
operator|->
name|start
operator|.
name|y
operator|==
name|y
condition|)
block|{
name|active_line
modifier|*
name|ynext
init|=
name|yll
operator|->
name|next
decl_stmt|;
comment|/* insert smashes next/prev links */
name|insert_x_new
argument_list|(
name|yll
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|yll
operator|=
name|ynext
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|->
name|x_list
operator|==
literal|0
condition|)
block|{
comment|/* No active lines, skip to next start */
if|if
condition|(
name|yll
operator|==
literal|0
condition|)
break|break;
comment|/* no lines left */
name|y
operator|=
name|yll
operator|->
name|start
operator|.
name|y
expr_stmt|;
continue|continue;
block|}
comment|/* Find the next evaluation point. */
comment|/* Start by finding the smallest y value */
comment|/* at which any currently active line ends */
comment|/* (or the next to-be-active line begins). */
name|y1
operator|=
operator|(
name|yll
operator|!=
literal|0
condition|?
name|yll
operator|->
name|start
operator|.
name|y
else|:
name|max_fixed
operator|)
expr_stmt|;
for|for
control|(
name|alp
operator|=
name|ll
operator|->
name|x_list
init|;
name|alp
operator|!=
literal|0
condition|;
name|alp
operator|=
name|alp
operator|->
name|next
control|)
if|if
condition|(
name|alp
operator|->
name|end
operator|.
name|y
operator|<
name|y1
condition|)
name|y1
operator|=
name|alp
operator|->
name|end
operator|.
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'F'
index|]
condition|)
block|{
name|dprintf2
argument_list|(
literal|"[f]before loop: y=%f y1=%f:\n"
argument_list|,
name|fixed2float
argument_list|(
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|print_line_list
argument_list|(
name|ll
operator|->
name|x_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now look for line intersections before y1. */
name|x
operator|=
name|min_fixed
expr_stmt|;
name|y0
operator|=
name|y
operator|-
name|adjust
expr_stmt|;
define|#
directive|define
name|have_pixels
parameter_list|()
value|(fixed_rounded(y0)< fixed_rounded(y1 + adjust))
name|draw
operator|=
operator|(
name|have_pixels
argument_list|()
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 		 * Loop invariants: 		 *	alp = endp->next; 		 *	for all lines lp from stopx up to alp, 		 *	  lp->x_next = al_x_at_y(lp, y1). 		 */
for|for
control|(
name|alp
operator|=
name|stopx
operator|=
name|ll
operator|->
name|x_list
init|;
name|stat
argument_list|(
name|n_find_y
argument_list|)
operator|,
name|alp
operator|!=
literal|0
condition|;
name|endp
operator|=
name|alp
operator|,
name|alp
operator|=
name|alp
operator|->
name|next
control|)
block|{
name|fixed
name|nx
init|=
name|al_x_at_y
argument_list|(
name|alp
argument_list|,
name|y1
argument_list|)
decl_stmt|;
name|fixed
name|dx_old
decl_stmt|,
name|dx_den
decl_stmt|;
comment|/* Check for intersecting lines. */
if|if
condition|(
name|nx
operator|>=
name|x
condition|)
name|x
operator|=
name|nx
expr_stmt|;
elseif|else
if|if
condition|(
name|draw
operator|>=
literal|0
operator|&&
comment|/* don't bother if no pixels */
operator|(
name|dx_old
operator|=
name|alp
operator|->
name|x_current
operator|-
name|endp
operator|->
name|x_current
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|dx_den
operator|=
name|dx_old
operator|+
name|endp
operator|->
name|x_next
operator|-
name|nx
operator|)
operator|>
name|dx_old
condition|)
block|{
comment|/* Make a good guess at the intersection */
comment|/* Y value using only local information. */
name|fixed
name|dy
init|=
name|y1
operator|-
name|y
decl_stmt|,
name|y_new
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'f'
index|]
operator|||
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[f]cross: dy=%g, dx_old=%g, dx_new=%g\n"
argument_list|,
name|fixed2float
argument_list|(
name|dy
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|dx_old
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|dx_den
operator|-
name|dx_old
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do the computation in single precision */
comment|/* if the values are small enough. */
name|y_new
operator|=
operator|(
operator|(
name|dy
operator||
name|dx_old
operator|)
operator|<
literal|1L
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|fixed
argument_list|)
operator|*
literal|4
operator|-
literal|1
operator|)
condition|?
name|dy
operator|*
name|dx_old
operator|/
name|dx_den
else|:
name|fixed_mult_quo
argument_list|(
name|dy
argument_list|,
name|dx_old
argument_list|,
name|dx_den
argument_list|)
operator|)
operator|+
name|y
expr_stmt|;
comment|/* The crossing value doesn't have to be */
comment|/* very accurate, but it does have to be */
comment|/* greater than y and less than y1. */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'f'
index|]
operator|||
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[f]cross y=%g, y_new=%g, y1=%g\n"
argument_list|,
name|fixed2float
argument_list|(
name|y
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y_new
argument_list|)
argument_list|,
name|fixed2float
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stopx
operator|=
name|alp
expr_stmt|;
if|if
condition|(
name|y_new
operator|<=
name|y
condition|)
name|y_new
operator|=
name|y
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|y_new
operator|<
name|y1
condition|)
block|{
name|y1
operator|=
name|y_new
expr_stmt|;
name|nx
operator|=
name|al_x_at_y
argument_list|(
name|alp
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|draw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nx
operator|>
name|x
condition|)
name|x
operator|=
name|nx
expr_stmt|;
block|}
name|alp
operator|->
name|x_next
operator|=
name|nx
expr_stmt|;
block|}
comment|/* Recompute next_x for lines before the intersection. */
for|for
control|(
name|alp
operator|=
name|ll
operator|->
name|x_list
init|;
name|alp
operator|!=
name|stopx
condition|;
name|alp
operator|=
name|alp
operator|->
name|next
control|)
name|alp
operator|->
name|x_next
operator|=
name|al_x_at_y
argument_list|(
name|alp
argument_list|,
name|y1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'F'
index|]
condition|)
block|{
name|dprintf1
argument_list|(
literal|"[f]after loop: y1=%f\n"
argument_list|,
name|fixed2float
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|print_line_list
argument_list|(
name|ll
operator|->
name|x_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Fill a multi-trapezoid band for the active lines. */
comment|/* Don't bother if no pixel centers lie within the band. */
if|if
condition|(
name|draw
operator|>
literal|0
operator|||
name|draw
operator|==
literal|0
operator|&&
name|have_pixels
argument_list|()
condition|)
block|{
name|active_line
modifier|*
name|alp
init|=
name|ll
operator|->
name|x_list
decl_stmt|;
name|fixed
name|height
init|=
name|y1
operator|-
name|y
operator|+
name|adj2
decl_stmt|;
name|fixed
name|xlbot
decl_stmt|,
name|xltop
decl_stmt|;
comment|/* as of last "outside" line */
name|int
name|inside
init|=
literal|0
decl_stmt|;
name|stat
argument_list|(
name|n_band
argument_list|)
expr_stmt|;
name|x
operator|=
name|min_fixed
expr_stmt|;
comment|/* rule = -1 for winding number rule, i.e. */
comment|/* we are inside if the winding number is non-zero; */
comment|/* rule = 1 for even-odd rule, i.e. */
comment|/* we are inside if the winding number is odd. */
comment|/* Clever, eh? */
define|#
directive|define
name|inside_path_p
parameter_list|()
value|(inside& rule)
while|while
condition|(
name|alp
operator|!=
literal|0
condition|)
block|{
name|fixed
name|xbot
init|=
name|alp
operator|->
name|x_current
decl_stmt|;
name|fixed
name|xtop
init|=
name|alp
operator|->
name|x_next
decl_stmt|;
name|print_al
argument_list|(
literal|"step"
argument_list|,
name|alp
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|n_band_step
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside_path_p
argument_list|()
condition|)
block|{
name|inside
operator|+=
name|alp
operator|->
name|direction
expr_stmt|;
if|if
condition|(
operator|!
name|inside_path_p
argument_list|()
condition|)
comment|/* about to go out */
block|{
name|fixed
name|wbot
init|=
name|xbot
operator|-
name|xlbot
operator|+
name|adj2
decl_stmt|;
name|fixed
name|wtop
init|=
name|xtop
operator|-
name|xltop
operator|+
name|adj2
decl_stmt|;
name|int
name|code
decl_stmt|;
name|stat
argument_list|(
name|n_band_fill
argument_list|)
expr_stmt|;
comment|/* If lines are temporarily out of */
comment|/* order, wtop might be negative. */
comment|/* Patch this up now. */
if|if
condition|(
name|wtop
operator|<
literal|0
condition|)
block|{
name|xltop
operator|+=
name|wtop
operator|>>
literal|1
expr_stmt|;
name|wtop
operator|=
literal|0
expr_stmt|;
block|}
name|code
operator|=
name|gz_fill_trapezoid_fixed
argument_list|(
name|xlbot
operator|-
name|adjust
argument_list|,
name|wbot
argument_list|,
name|y0
argument_list|,
name|xltop
operator|-
name|adjust
argument_list|,
name|wtop
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|pdevc
argument_list|,
name|pgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
block|}
else|else
comment|/* outside */
block|{
name|inside
operator|+=
name|alp
operator|->
name|direction
expr_stmt|;
if|if
condition|(
name|inside_path_p
argument_list|()
condition|)
comment|/* about to go in */
name|xlbot
operator|=
name|xbot
operator|,
name|xltop
operator|=
name|xtop
expr_stmt|;
block|}
name|alp
operator|=
name|alp
operator|->
name|next
expr_stmt|;
block|}
block|}
name|update_x_list
argument_list|(
name|ll
operator|->
name|x_list
argument_list|,
name|y1
argument_list|)
expr_stmt|;
name|y
operator|=
name|y1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert a newly active line in the X ordering. */
end_comment

begin_function
name|private
name|void
name|insert_x_new
parameter_list|(
name|active_line
modifier|*
name|alp
parameter_list|,
name|ll_ptr
name|ll
parameter_list|)
block|{
specifier|register
name|active_line
modifier|*
name|next
decl_stmt|;
specifier|register
name|active_line
modifier|*
name|prev
init|=
operator|&
name|ll
operator|->
name|x_head
decl_stmt|;
specifier|register
name|fixed
name|x
init|=
name|alp
operator|->
name|start
operator|.
name|x
decl_stmt|;
name|alp
operator|->
name|x_current
operator|=
name|x
expr_stmt|;
while|while
condition|(
name|stat
argument_list|(
name|n_x_step
argument_list|)
operator|,
operator|(
name|next
operator|=
name|prev
operator|->
name|next
operator|)
operator|!=
literal|0
operator|&&
name|x_precedes
argument_list|(
name|next
argument_list|,
name|alp
argument_list|,
name|x
argument_list|)
condition|)
name|prev
operator|=
name|next
expr_stmt|;
name|alp
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|alp
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|0
condition|)
name|next
operator|->
name|prev
operator|=
name|alp
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|alp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after a pass through the main loop. */
end_comment

begin_comment
comment|/* If any lines are out of order, re-sort them now. */
end_comment

begin_comment
comment|/* Also drop any ended lines. */
end_comment

begin_function
name|private
name|void
name|update_x_list
parameter_list|(
name|active_line
modifier|*
name|x_first
parameter_list|,
name|fixed
name|y1
parameter_list|)
block|{
name|fixed
name|x
decl_stmt|;
specifier|register
name|active_line
modifier|*
name|alp
decl_stmt|;
name|active_line
modifier|*
name|nlp
decl_stmt|;
for|for
control|(
name|x
operator|=
name|min_fixed
operator|,
name|alp
operator|=
name|x_first
init|;
name|alp
operator|!=
literal|0
condition|;
name|alp
operator|=
name|nlp
control|)
block|{
name|fixed
name|nx
init|=
name|alp
operator|->
name|x_current
operator|=
name|alp
operator|->
name|x_next
decl_stmt|;
name|nlp
operator|=
name|alp
operator|->
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'f'
index|]
operator|||
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf4
argument_list|(
literal|"[f]check %lx,x=%g %lx,x=%g\n"
argument_list|,
operator|(
name|ulong
operator|)
name|alp
operator|->
name|prev
argument_list|,
name|fixed2float
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|alp
argument_list|,
name|fixed2float
argument_list|(
name|nx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|alp
operator|->
name|end
operator|.
name|y
operator|==
name|y1
condition|)
block|{
comment|/* Handle a line segment that just ended. */
name|segment
modifier|*
name|pseg
init|=
name|alp
operator|->
name|pseg
decl_stmt|;
name|segment
modifier|*
name|next
decl_stmt|;
name|gs_fixed_point
name|npt
decl_stmt|;
comment|/* 			 * The computation of next relies on the fact that 			 * all subpaths have been closed.  When we cycle 			 * around to the other end of a subpath, we must be 			 * sure not to process the start/end point twice. 			 */
name|next
operator|=
operator|(
name|alp
operator|->
name|direction
operator|==
name|dir_up
condition|?
operator|(
comment|/* Upward line, go forward along path. */
name|pseg
operator|->
name|type
operator|==
name|s_line_close
condition|?
comment|/* end of subpath */
operator|(
operator|(
name|line_close_segment
operator|*
operator|)
name|pseg
operator|)
operator|->
name|sub
operator|->
name|next
else|:
name|pseg
operator|->
name|next
operator|)
else|:
operator|(
comment|/* Downward line, go backward along path. */
name|pseg
operator|->
name|type
operator|==
name|s_start
condition|?
comment|/* start of subpath */
operator|(
operator|(
name|subpath
operator|*
operator|)
name|pseg
operator|)
operator|->
name|last
operator|->
name|prev
else|:
name|pseg
operator|->
name|prev
operator|)
operator|)
expr_stmt|;
name|npt
operator|.
name|y
operator|=
name|next
operator|->
name|pt
operator|.
name|y
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf5
argument_list|(
literal|"[f]ended %lx: pseg=%lx y=%f next=%lx npt.y=%f\n"
argument_list|,
operator|(
name|ulong
operator|)
name|alp
argument_list|,
operator|(
name|ulong
operator|)
name|pseg
argument_list|,
name|fixed2float
argument_list|(
name|pseg
operator|->
name|pt
operator|.
name|y
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|next
argument_list|,
name|fixed2float
argument_list|(
name|npt
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|npt
operator|.
name|y
operator|<=
name|pseg
operator|->
name|pt
operator|.
name|y
condition|)
block|{
comment|/* End of a line sequence */
name|alp
operator|->
name|prev
operator|->
name|next
operator|=
name|nlp
expr_stmt|;
if|if
condition|(
name|nlp
condition|)
name|nlp
operator|->
name|prev
operator|=
name|alp
operator|->
name|prev
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf1
argument_list|(
literal|"[f]drop %lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|alp
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
else|else
block|{
name|alp
operator|->
name|pseg
operator|=
name|next
expr_stmt|;
name|npt
operator|.
name|x
operator|=
name|next
operator|->
name|pt
operator|.
name|x
expr_stmt|;
name|set_al_points
argument_list|(
name|alp
argument_list|,
name|alp
operator|->
name|end
argument_list|,
name|npt
argument_list|)
expr_stmt|;
name|print_al
argument_list|(
literal|"repl"
argument_list|,
name|alp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nx
operator|<=
name|x
condition|)
block|{
comment|/* Move alp backward in the list. */
name|active_line
modifier|*
name|prev
init|=
name|alp
operator|->
name|prev
decl_stmt|;
name|active_line
modifier|*
name|next
init|=
name|nlp
decl_stmt|;
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
while|while
condition|(
operator|!
name|x_precedes
argument_list|(
name|prev
argument_list|,
name|alp
argument_list|,
name|nx
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'f'
index|]
operator|||
name|gs_debug
index|[
literal|'F'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"[f]swap %lx,%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|alp
argument_list|,
operator|(
name|ulong
operator|)
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next
operator|=
name|prev
operator|,
name|prev
operator|=
name|prev
operator|->
name|prev
expr_stmt|;
block|}
name|alp
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|alp
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
comment|/* next might be null, if alp was in */
comment|/* the correct spot already. */
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|alp
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|alp
expr_stmt|;
block|}
else|else
name|x
operator|=
name|nx
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'f'
index|]
operator|||
name|gs_debug
index|[
literal|'F'
index|]
condition|)
for|for
control|(
name|alp
operator|=
name|x_first
init|;
name|alp
operator|!=
literal|0
condition|;
name|alp
operator|=
name|alp
operator|->
name|next
control|)
if|if
condition|(
name|alp
operator|->
name|next
operator|!=
literal|0
operator|&&
name|alp
operator|->
name|next
operator|->
name|x_current
operator|<
name|alp
operator|->
name|x_current
condition|)
block|{
name|lprintf
argument_list|(
literal|"[f]Lines out of order!\n"
argument_list|)
expr_stmt|;
name|print_active_line
argument_list|(
literal|"   1:"
argument_list|,
name|alp
argument_list|)
expr_stmt|;
name|print_active_line
argument_list|(
literal|"   2:"
argument_list|,
name|alp
operator|->
name|next
argument_list|)
expr_stmt|;
name|gs_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

