begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* isave.c */
end_comment

begin_comment
comment|/* Save/restore machinery for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"astate.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* for ref_assign */
end_comment

begin_comment
comment|/* Imported restore routines */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|file_restore
argument_list|(
name|P1
argument_list|(
name|alloc_save
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|font_restore
argument_list|(
name|P1
argument_list|(
name|alloc_save
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The logic for saving and restore the state is rather subtle.  * Both the changes to individual objects, and the overall state  * of the memory manager, must be saved and restored.  */
end_comment

begin_comment
comment|/*  * To save the state of the memory manager:  *	Save the state of the current chunk in which we are allocating.  *	Save the identity of the current chunk.  *	Save and reset the malloc chain and the orphan block chains.  * By doing this, we guarantee that no object older than the save  * can be freed.  *  * To restore the state of the memory manager:  *	Free all chunks newer than the save.  *	Free all malloc'ed blocks newer than the save.  *	Make current the chunk that was current at the time of the save.  *	Free all objects allocated in the current chunk since the save.  */
end_comment

begin_comment
comment|/*  * For saving changes to individual objects, we add an "attribute" bit  * (l_new) that logically belongs to the slot where the descriptor is stored,  * not to the descriptor itself.  The bit means "the contents  * of this slot have been changed since the last save."  * To keep track of changes since the save, we associate a chain of  *<slot, old_contents> pairs that remembers the old contents of slots.  *  * When creating an object, if the save level is non-zero:  *	Set the bit in all slots.  *  * When storing into a slot, if the save level is non-zero:  *	If the bit isn't set, save the address and contents of the slot  *	  on the current contents chain.  *	Set the bit after storing the new value.  *  * To do a save:  *	If the save level is non-zero:  *		Reset the bit in all slots on the contents chain, and in all  *		  objects created since the previous save.  *	Push the head of contents chain, and reset the chain to empty.  *  * To do a restore:  *	Check all the stacks to make sure they don't contain references  *	  to objects created since the save.  *	Restore all the slots on the contents chain.  *	Pop the contents chain head.  *	If the save level is now non-zero:  *		Scan the newly restored contents chain, and set the bit in all  *		  the slots it references.  *		Scan all objects created since the previous save, and set the  *		  bit in all the slots of each object.  */
end_comment

begin_comment
comment|/* Declare the mask for checking stores. */
end_comment

begin_comment
comment|/* This is -1 if we are not in a save, 0 if we are in a save. */
end_comment

begin_decl_stmt
name|int
name|alloc_save_test_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare the mask for tagging new objects. */
end_comment

begin_comment
comment|/* This is 0 if we are not in a save, l_new if we are in a save. */
end_comment

begin_decl_stmt
name|int
name|alloc_save_new_mask
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|set_in_save
parameter_list|()
define|\
value|(alloc_save_test_mask = 0, alloc_save_new_mask = l_new)
end_define

begin_define
define|#
directive|define
name|set_not_in_save
parameter_list|()
define|\
value|(alloc_save_test_mask = -1, alloc_save_new_mask = 0)
end_define

begin_comment
comment|/* Structure for saved change chain for save/restore. */
end_comment

begin_comment
comment|/* If where = 0, contents is a t_array that refers to */
end_comment

begin_comment
comment|/* a newly allocated object; if contents.value.refs is 0, */
end_comment

begin_comment
comment|/* this is a free record (possible since we allocate them two at a time.) */
end_comment

begin_comment
comment|/* We merge adjacent objects to reduce */
end_comment

begin_comment
comment|/* the need to allocate alloc_change records. */
end_comment

begin_struct
struct|struct
name|alloc_change_s
block|{
name|alloc_change
modifier|*
name|next
decl_stmt|;
name|ref
modifier|*
name|where
decl_stmt|;
name|ref
name|contents
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|alloc_change_is_free
parameter_list|(
name|cp
parameter_list|)
define|\
value|((cp)->where == 0&& (cp)->contents.value.refs == 0)
end_define

begin_comment
comment|/*  * Macro to allocate a pair of change records.  * Must be used in the following form:  *	if_not_alloc_change_pair(cp, ap, cname)  *	 { ... failure code ...  *	 }  */
end_comment

begin_define
define|#
directive|define
name|if_not_alloc_change_pair
parameter_list|(
name|cp
parameter_list|,
name|ap
parameter_list|,
name|cname
parameter_list|)
define|\
value|cp = (alloc_change *)alloc(2, sizeof(alloc_change), cname);\   if ( cp != 0 )\    { cp->next = ap->changes;\      cp[1].next = cp;\      cp[1].where = 0;\      cp[1].contents.value.refs = 0;\      r_set_size(&cp[1].contents, 0);\      ap->changes = cp + 1;\    }\   else
end_define

begin_comment
comment|/* Saved state of allocator and other things as needed. */
end_comment

begin_struct
struct|struct
name|alloc_save_s
block|{
name|alloc_state
name|state
decl_stmt|;
name|alloc_state_ptr
name|cap
decl_stmt|;
name|uint
name|name_cnt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Debugging printout */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|private
name|void
name|alloc_save_print
parameter_list|(
name|alloc_change
modifier|*
name|cp
parameter_list|)
block|{
name|dprintf1
argument_list|(
literal|" %lx:"
argument_list|,
operator|(
name|ulong
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|where
condition|)
name|dprintf4
argument_list|(
literal|" %lx: %x %x %lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cp
operator|->
name|where
argument_list|,
name|r_type_attrs
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|)
argument_list|,
name|r_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|intval
argument_list|)
expr_stmt|;
else|else
name|dprintf2
argument_list|(
literal|" %lx(%u)\n"
argument_list|,
operator|(
name|ulong
operator|)
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|refs
argument_list|,
name|r_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|void
name|save_set_new
argument_list|(
name|P2
argument_list|(
name|alloc_state_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the save/restore machinery. */
end_comment

begin_function
name|void
name|alloc_save_init
parameter_list|()
block|{
name|set_not_in_save
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the state. */
end_comment

begin_function
name|alloc_save
modifier|*
name|alloc_save_state
parameter_list|()
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
name|alloc_state_current
decl_stmt|;
name|alloc_save
modifier|*
name|save
init|=
operator|(
name|alloc_save
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|alloc_save
argument_list|)
argument_list|,
literal|"alloc_save_state"
argument_list|)
decl_stmt|;
if|if
condition|(
name|save
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|save
operator|->
name|state
operator|=
operator|*
name|ap
expr_stmt|;
name|save
operator|->
name|cap
operator|=
name|ap
expr_stmt|;
name|save
operator|->
name|name_cnt
operator|=
name|name_count
argument_list|()
expr_stmt|;
comment|/* Reset the l_new attribute in all slots.  The only slots that */
comment|/* can have the attribute set are the ones on the changes chain. */
name|save_set_new
argument_list|(
name|ap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear the free chains, to prevent old objects from being freed. */
name|memset
argument_list|(
operator|&
name|ap
operator|->
name|free
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|num_free_chains
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|malloc_chain
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|saved
operator|=
name|save
expr_stmt|;
name|ap
operator|->
name|save_level
operator|++
expr_stmt|;
name|ap
operator|->
name|changes
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|saved_cbot
operator|=
name|ap
operator|->
name|cbot
expr_stmt|;
name|ap
operator|->
name|saved_ctop
operator|=
name|ap
operator|->
name|ctop
expr_stmt|;
comment|/* Clear the last_freed cache, because the cache pointer */
comment|/* must point to a chunk at the current save level. */
name|ap
operator|->
name|last_freed
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'u'
index|]
condition|)
block|{
name|dprintf3
argument_list|(
literal|"[u]save at %lx: cbot=%lx ctop=%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|save
argument_list|,
operator|(
name|ulong
operator|)
name|ap
operator|->
name|cbot
argument_list|,
operator|(
name|ulong
operator|)
name|ap
operator|->
name|ctop
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|set_in_save
argument_list|()
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/* Allocate a ref-containing object and record it as new. */
end_comment

begin_function
name|ref
modifier|*
name|alloc_refs
parameter_list|(
name|uint
name|num_refs
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
name|alloc_state_current
decl_stmt|;
specifier|register
name|alloc_change
modifier|*
name|cp
decl_stmt|;
specifier|register
name|ref
modifier|*
name|obj
init|=
operator|(
name|ref
operator|*
operator|)
name|alloc
argument_list|(
name|num_refs
argument_list|,
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|,
name|client_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ap
operator|->
name|save_level
operator|==
literal|0
condition|)
comment|/* no saving */
return|return
name|obj
return|;
name|cp
operator|=
name|ap
operator|->
name|changes
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|0
operator|&&
name|cp
operator|->
name|where
operator|==
literal|0
operator|&&
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|refs
operator|!=
literal|0
operator|&&
name|obj
operator|==
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|refs
operator|+
name|r_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|)
operator|&&
comment|/* Don't create a single block that is large enough to */
comment|/* mislead the allocator into thinking it was allocated */
comment|/* with a single malloc. */
name|r_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|)
operator|+
name|num_refs
operator|<
name|ap
operator|->
name|big_size
operator|/
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|/* Merge adjacent allocations. */
name|r_inc_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|,
name|num_refs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'u'
index|]
condition|)
block|{
name|dprintf1
argument_list|(
literal|"[u]alloc_refs %s merge"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|alloc_save_print
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|==
literal|0
operator|||
operator|!
name|alloc_change_is_free
argument_list|(
name|cp
argument_list|)
condition|)
block|{
comment|/* Allocate a pair of entries. */
name|if_not_alloc_change_pair
argument_list|(
argument|cp
argument_list|,
argument|ap
argument_list|,
literal|"alloc_refs"
argument_list|)
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|obj
argument_list|,
name|num_refs
argument_list|,
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cp
operator|->
name|where
operator|=
literal|0
expr_stmt|;
name|r_set_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|,
name|num_refs
argument_list|)
expr_stmt|;
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|refs
operator|=
name|obj
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'u'
index|]
condition|)
block|{
name|dprintf1
argument_list|(
literal|"[u]alloc_refs %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|alloc_save_print
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|obj
return|;
block|}
end_function

begin_comment
comment|/* Deallocate a ref-containing object.  This is a dummy for now. */
end_comment

begin_function
name|void
name|alloc_free_refs
parameter_list|(
name|ref
modifier|*
name|ptr
parameter_list|,
name|uint
name|num_refs
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'u'
index|]
condition|)
block|{
name|dprintf3
argument_list|(
literal|"[u]alloc_free_refs (%lx,%d) %s\n"
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|,
name|num_refs
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Record a state change that must be undone for restore, */
end_comment

begin_comment
comment|/* and mark it as having been saved. */
end_comment

begin_comment
comment|/* This can only be called if we are in a save. */
end_comment

begin_function
name|int
name|alloc_save_change
parameter_list|(
name|ref
modifier|*
name|where
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
name|alloc_state_current
decl_stmt|;
specifier|register
name|alloc_change
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|save_level
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* no saving */
name|cp
operator|=
name|ap
operator|->
name|changes
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
operator|||
operator|!
name|alloc_change_is_free
argument_list|(
name|cp
argument_list|)
condition|)
block|{
comment|/* Allocate a pair of entries. */
name|if_not_alloc_change_pair
argument_list|(
argument|cp
argument_list|,
argument|ap
argument_list|,
literal|"alloc_save_change"
argument_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|cp
operator|->
name|where
operator|=
name|where
expr_stmt|;
name|ref_assign
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|,
name|where
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'u'
index|]
condition|)
block|{
name|dprintf1
argument_list|(
literal|"[u]save %s"
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|alloc_save_print
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|r_is_packed
argument_list|(
name|where
argument_list|)
condition|)
name|r_set_attrs
argument_list|(
name|where
argument_list|,
name|l_new
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the current save level */
end_comment

begin_function
name|int
name|alloc_save_level
parameter_list|()
block|{
return|return
name|alloc_state_current
operator|->
name|save_level
return|;
block|}
end_function

begin_comment
comment|/* Test whether a reference would be invalidated by a restore. */
end_comment

begin_function
name|int
name|alloc_is_since_save
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|alloc_save
modifier|*
name|save
parameter_list|)
block|{
comment|/* A reference can postdate a save in one of three ways: */
comment|/*	- It is in the chunk that was current at the time */
comment|/*	    of the save, and allocated more recently. */
comment|/*	- It is in a chunk allocated since the save; */
comment|/*	- It was malloc'ed since the save; */
specifier|register
name|alloc_state_ptr
name|ap
init|=
name|save
operator|->
name|cap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'U'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"[U]is_since_save %lx, %lx:\n"
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|,
operator|(
name|ulong
operator|)
name|save
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check against current chunk at the time of the save */
if|if
condition|(
name|ptr_is_in_chunk
argument_list|(
name|ptr
argument_list|,
operator|&
name|save
operator|->
name|state
operator|.
name|current
argument_list|)
condition|)
block|{
comment|/* In the chunk, check against allocation pointers */
comment|/* at the time of the save */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'U'
index|]
condition|)
name|dprintf2
argument_list|(
literal|"[U?]  current chunk %lx, %lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|save
operator|->
name|state
operator|.
name|cbot
argument_list|,
operator|(
name|ulong
operator|)
name|save
operator|->
name|state
operator|.
name|ctop
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|ptr_ord_t
operator|)
name|ptr
operator|>=
operator|(
name|ptr_ord_t
operator|)
name|save
operator|->
name|state
operator|.
name|cbot
operator|&&
operator|(
name|ptr_ord_t
operator|)
name|ptr
operator|<
operator|(
name|ptr_ord_t
operator|)
name|save
operator|->
name|state
operator|.
name|ctop
operator|)
return|;
block|}
comment|/* Check against chunks allocated since the save */
block|{
name|alloc_chunk
modifier|*
name|chunk
init|=
operator|&
name|ap
operator|->
name|current
decl_stmt|;
while|while
condition|(
name|chunk
operator|->
name|save_level
operator|>
name|save
operator|->
name|state
operator|.
name|save_level
condition|)
block|{
if|if
condition|(
name|ptr_is_in_chunk
argument_list|(
name|ptr
argument_list|,
name|chunk
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'U'
index|]
condition|)
name|dprintf3
argument_list|(
literal|"[U+]  new chunk %lx: %lx, %lx\n"
argument_list|,
name|chunk
argument_list|,
operator|(
name|ulong
operator|)
name|chunk
operator|->
name|base
argument_list|,
operator|(
name|ulong
operator|)
name|chunk
operator|->
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|chunk
operator|=
name|chunk
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Check the malloc chains since the save */
block|{
name|alloc_state
modifier|*
name|asp
init|=
name|ap
decl_stmt|;
for|for
control|(
init|;
name|asp
operator|!=
operator|&
name|save
operator|->
name|state
condition|;
name|asp
operator|=
operator|&
name|asp
operator|->
name|saved
operator|->
name|state
control|)
block|{
name|alloc_block
modifier|*
name|mblk
init|=
name|asp
operator|->
name|malloc_chain
decl_stmt|;
for|for
control|(
init|;
name|mblk
operator|!=
literal|0
condition|;
name|mblk
operator|=
name|mblk
operator|->
name|next
control|)
if|if
condition|(
name|alloc_block_size
operator|+
operator|(
name|char
operator|*
operator|)
name|mblk
operator|==
name|ptr
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'U'
index|]
condition|)
name|dprintf
argument_list|(
literal|"[U+]  malloc'ed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* Not in any of those places, must be OK. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Test whether a name would be invalidated by a restore. */
end_comment

begin_function
name|int
name|alloc_name_is_since_save
parameter_list|(
name|ref
modifier|*
name|pnref
parameter_list|,
name|alloc_save
modifier|*
name|save
parameter_list|)
block|{
return|return
name|name_is_since_count
argument_list|(
name|pnref
argument_list|,
name|save
operator|->
name|name_cnt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Validate a saved state pointer. */
end_comment

begin_function
name|int
name|alloc_restore_state_check
parameter_list|(
name|alloc_save
modifier|*
name|save
parameter_list|)
block|{
name|alloc_save
modifier|*
name|sprev
init|=
name|save
operator|->
name|cap
operator|->
name|saved
decl_stmt|;
while|while
condition|(
name|sprev
operator|!=
name|save
condition|)
block|{
if|if
condition|(
name|sprev
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* not on chain */
name|sprev
operator|=
name|sprev
operator|->
name|state
operator|.
name|saved
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Restore the state.  The client is responsible for calling */
end_comment

begin_comment
comment|/* alloc_restore_state_check first, and for ensuring that */
end_comment

begin_comment
comment|/* there are no surviving pointers for which alloc_is_since_save is true. */
end_comment

begin_function
name|void
name|alloc_restore_state
parameter_list|(
name|alloc_save
modifier|*
name|save
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
name|save
operator|->
name|cap
decl_stmt|;
name|alloc_save
modifier|*
name|sprev
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'u'
index|]
condition|)
block|{
name|dprintf1
argument_list|(
literal|"[u]restore from %lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|save
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Iteratively restore the state */
do|do
block|{
name|sprev
operator|=
name|ap
operator|->
name|saved
expr_stmt|;
comment|/* Close inaccessible files. */
name|file_restore
argument_list|(
name|save
argument_list|)
expr_stmt|;
comment|/* Remove entries from font and character caches. */
name|font_restore
argument_list|(
name|save
argument_list|)
expr_stmt|;
comment|/* Adjust the name table. */
name|name_restore
argument_list|(
name|sprev
operator|->
name|name_cnt
argument_list|)
expr_stmt|;
comment|/* Undo changes since the save. */
block|{
name|alloc_change
modifier|*
name|cp
init|=
name|ap
operator|->
name|changes
decl_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'u'
index|]
condition|)
block|{
name|dprintf
argument_list|(
literal|"[u]restore"
argument_list|)
expr_stmt|;
name|alloc_save_print
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cp
operator|->
name|where
condition|)
name|ref_assign
argument_list|(
name|cp
operator|->
name|where
argument_list|,
operator|&
name|cp
operator|->
name|contents
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|refs
operator|!=
literal|0
condition|)
comment|/* might be an unfilled save record */
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|refs
argument_list|,
name|r_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
argument_list|,
literal|"alloc_restore_state"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|cp
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Free chunks allocated since the save. */
block|{
name|alloc_chunk
modifier|*
name|cp
init|=
name|ap
operator|->
name|current_ptr
decl_stmt|;
operator|*
name|cp
operator|=
name|ap
operator|->
name|current
expr_stmt|;
comment|/* update in memory */
block|}
while|while
condition|(
name|ap
operator|->
name|current
operator|.
name|save_level
operator|==
name|ap
operator|->
name|save_level
condition|)
block|{
name|byte
modifier|*
name|cp
init|=
operator|(
name|byte
operator|*
operator|)
name|ap
operator|->
name|current_ptr
decl_stmt|;
name|uint
name|csize
init|=
name|ap
operator|->
name|climit
operator|-
name|cp
decl_stmt|;
name|ap
operator|->
name|current_ptr
operator|=
name|ap
operator|->
name|current
operator|.
name|next
expr_stmt|;
name|ap
operator|->
name|current
operator|=
operator|*
name|ap
operator|->
name|current_ptr
expr_stmt|;
call|(
modifier|*
name|ap
operator|->
name|pfree
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|1
argument_list|,
name|csize
argument_list|,
literal|"alloc_restore_state(chunk)"
argument_list|)
expr_stmt|;
block|}
comment|/* Free blocks allocated with malloc since the save. */
comment|/* Since we reset the chain when we did the save, */
comment|/* we just free all the objects on the current chain. */
block|{
while|while
condition|(
name|ap
operator|->
name|malloc_chain
operator|!=
literal|0
condition|)
block|{
name|alloc_block
modifier|*
name|mblock
init|=
name|ap
operator|->
name|malloc_chain
decl_stmt|;
name|ap
operator|->
name|malloc_chain
operator|=
name|mblock
operator|->
name|next
expr_stmt|;
call|(
modifier|*
name|ap
operator|->
name|pfree
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mblock
argument_list|,
literal|1
argument_list|,
name|alloc_block_size
operator|+
name|mblock
operator|->
name|size
argument_list|,
literal|"alloc_restore_state(malloc'ed)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore the allocator state. */
operator|*
name|ap
operator|=
name|sprev
operator|->
name|state
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sprev
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|alloc_save
argument_list|)
argument_list|,
literal|"alloc_restore_state"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sprev
operator|!=
name|save
condition|)
do|;
comment|/* Clean up */
if|if
condition|(
name|sprev
operator|!=
literal|0
condition|)
name|ap
operator|->
name|saved_cbot
operator|=
name|sprev
operator|->
name|state
operator|.
name|cbot
operator|,
name|ap
operator|->
name|saved_ctop
operator|=
name|sprev
operator|->
name|state
operator|.
name|ctop
expr_stmt|;
comment|/* Clear the last_freed cache, because the cache pointer */
comment|/* must point to a chunk at the current save level. */
name|ap
operator|->
name|last_freed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|save_level
operator|==
literal|0
condition|)
name|set_not_in_save
argument_list|()
expr_stmt|;
comment|/* Set the l_new attribute in all slots that have been saved. */
name|save_set_new
argument_list|(
name|ap
argument_list|,
name|l_new
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Set or reset the l_new attribute in every slot on the current */
end_comment

begin_comment
comment|/* change chain. */
end_comment

begin_function
name|private
name|void
name|save_set_new
parameter_list|(
name|alloc_state_ptr
name|ap
parameter_list|,
name|int
name|new
parameter_list|)
comment|/* l_new or 0 */
block|{
specifier|register
name|alloc_change
modifier|*
name|cp
init|=
name|ap
operator|->
name|changes
decl_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
name|ref
modifier|*
name|rp
init|=
name|cp
operator|->
name|where
decl_stmt|;
if|if
condition|(
name|rp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|r_is_packed
argument_list|(
name|rp
argument_list|)
condition|)
name|rp
operator|->
name|tas
operator|.
name|type_attrs
operator|=
operator|(
name|rp
operator|->
name|tas
operator|.
name|type_attrs
operator|&
operator|~
name|l_new
operator|)
operator|+
name|new
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|ushort
name|size
init|=
name|r_size
argument_list|(
operator|&
name|cp
operator|->
name|contents
argument_list|)
decl_stmt|;
specifier|register
name|ref
modifier|*
name|ep
init|=
name|cp
operator|->
name|contents
operator|.
name|value
operator|.
name|refs
decl_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|r_is_packed
argument_list|(
name|ep
argument_list|)
condition|)
name|ep
operator|->
name|tas
operator|.
name|type_attrs
operator|=
operator|(
name|ep
operator|->
name|tas
operator|.
name|type_attrs
operator|&
operator|~
name|l_new
operator|)
operator|+
name|new
operator|,
name|ep
operator|++
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|cp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

