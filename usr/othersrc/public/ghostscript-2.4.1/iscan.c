begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* iscan.c */
end_comment

begin_comment
comment|/* Token scanner for Ghostscript interpreter */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_comment
comment|/* for //name lookup */
end_comment

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"iutil.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"ostack.h"
end_include

begin_comment
comment|/* for accumulating proc bodies */
end_comment

begin_include
include|#
directive|include
file|"packed.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_include
include|#
directive|include
file|"scanchar.h"
end_include

begin_comment
comment|/* Array packing flag */
end_comment

begin_decl_stmt
name|ref
name|array_packing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* t_boolean */
end_comment

begin_comment
comment|/* Binary object format flag. This will never be set non-zero */
end_comment

begin_comment
comment|/* unless the binary token feature is enabled. */
end_comment

begin_decl_stmt
name|ref
name|binary_object_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* t_integer */
end_comment

begin_define
define|#
directive|define
name|recognize_btokens
parameter_list|()
value|(binary_object_format.value.intval != 0)
end_define

begin_comment
comment|/* Procedure for binary tokens.  Set at initialization if the binary token */
end_comment

begin_comment
comment|/* option is included; only called if recognize_btokens() is true. */
end_comment

begin_comment
comment|/* Returns 0 on success,<0 on failure. */
end_comment

begin_expr_stmt
name|int
argument_list|(
operator|*
name|scan_btoken_proc
argument_list|)
argument_list|(
name|P3
argument_list|(
name|stream
operator|*
argument_list|,
name|ref
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Level 2 includes some changes in the scanner:  *	- \ is always recognized in strings, regardless of the data source;  *	-<< and>> are legal tokens;  *	-<~ introduces an ASCII-85 encoded string (terminated by ~>)  *		(not implemented yet);  *	- Character codes above 127 introduce binary objects.  * We explicitly enable or disable these changes here.  */
end_comment

begin_decl_stmt
name|int
name|scan_enable_level2
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|scan_hex_string
argument_list|(
name|P2
argument_list|(
name|stream
operator|*
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|scan_int
argument_list|(
name|P6
argument_list|(
name|byte
operator|*
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|long
operator|*
argument_list|,
name|double
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|scan_number
argument_list|(
name|P3
argument_list|(
name|byte
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|,
name|scan_string
argument_list|(
name|P3
argument_list|(
name|stream
operator|*
argument_list|,
name|int
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the character scanning table (see scanchar.h). */
end_comment

begin_decl_stmt
name|byte
name|scan_char_array
index|[
literal|258
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A structure for dynamically growable objects */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dynamic_area_s
block|{
name|byte
modifier|*
name|base
decl_stmt|;
name|byte
modifier|*
name|next
decl_stmt|;
name|uint
name|num_elts
decl_stmt|;
name|uint
name|elt_size
decl_stmt|;
name|int
name|is_dynamic
decl_stmt|;
comment|/* false if using fixed buffer */
name|byte
modifier|*
name|limit
decl_stmt|;
block|}
name|dynamic_area
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|dynamic_area
name|_ss
modifier|*
name|da_ptr
typedef|;
end_typedef

begin_comment
comment|/* Begin a dynamic object. */
end_comment

begin_comment
comment|/* dynamic_begin returns the value of alloc, which may be 0: */
end_comment

begin_comment
comment|/* the invoker of dynamic_begin must test the value against 0. */
end_comment

begin_define
define|#
directive|define
name|dynamic_begin
parameter_list|(
name|pda
parameter_list|,
name|dnum
parameter_list|,
name|desize
parameter_list|)
define|\
value|((pda)->base = (byte *)alloc((pda)->num_elts = (dnum),\ 				     (pda)->elt_size = (desize), "scanner"),\ 	 (pda)->limit = (pda)->base + (dnum) * (desize),\ 	 (pda)->is_dynamic = 1,\ 	 (pda)->next = (pda)->base)
end_define

begin_comment
comment|/* Free a dynamic object. */
end_comment

begin_function
name|private
name|void
name|dynamic_free
parameter_list|(
name|da_ptr
name|pda
parameter_list|)
block|{
if|if
condition|(
name|pda
operator|->
name|is_dynamic
condition|)
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pda
operator|->
name|base
operator|)
argument_list|,
name|pda
operator|->
name|num_elts
argument_list|,
name|pda
operator|->
name|elt_size
argument_list|,
literal|"scanner"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Grow a dynamic object. */
end_comment

begin_comment
comment|/* If the allocation fails, free the old contents, and return NULL; */
end_comment

begin_comment
comment|/* otherwise, return the new `next' pointer. */
end_comment

begin_function
name|private
name|byte
modifier|*
name|dynamic_grow
parameter_list|(
specifier|register
name|da_ptr
name|pda
parameter_list|,
name|byte
modifier|*
name|next
parameter_list|)
block|{
if|if
condition|(
name|next
operator|!=
name|pda
operator|->
name|limit
condition|)
return|return
name|next
return|;
name|pda
operator|->
name|next
operator|=
name|next
expr_stmt|;
block|{
name|uint
name|num
init|=
name|pda
operator|->
name|num_elts
decl_stmt|;
name|uint
name|old_size
init|=
name|num
operator|*
name|pda
operator|->
name|elt_size
decl_stmt|;
name|uint
name|pos
init|=
name|pda
operator|->
name|next
operator|-
name|pda
operator|->
name|base
decl_stmt|;
name|uint
name|new_size
init|=
operator|(
name|old_size
operator|<
literal|10
condition|?
literal|20
else|:
name|old_size
operator|>=
operator|(
name|max_uint
operator|>>
literal|1
operator|)
condition|?
name|max_uint
else|:
name|old_size
operator|<<
literal|1
operator|)
decl_stmt|;
name|uint
name|new_num
init|=
name|new_size
operator|/
name|pda
operator|->
name|elt_size
decl_stmt|;
if|if
condition|(
name|pda
operator|->
name|is_dynamic
condition|)
block|{
name|byte
modifier|*
name|base
init|=
name|alloc_grow
argument_list|(
name|pda
operator|->
name|base
argument_list|,
name|num
argument_list|,
name|new_num
argument_list|,
name|pda
operator|->
name|elt_size
argument_list|,
literal|"scanner"
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
name|dynamic_free
argument_list|(
name|pda
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pda
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|pda
operator|->
name|num_elts
operator|=
name|new_num
expr_stmt|;
name|pda
operator|->
name|limit
operator|=
name|pda
operator|->
name|base
operator|+
name|new_size
expr_stmt|;
block|}
else|else
block|{
name|byte
modifier|*
name|base
init|=
name|pda
operator|->
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|dynamic_begin
argument_list|(
name|pda
argument_list|,
name|new_num
argument_list|,
name|pda
operator|->
name|elt_size
argument_list|)
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|pda
operator|->
name|base
argument_list|,
name|base
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|pda
operator|->
name|is_dynamic
operator|=
literal|1
expr_stmt|;
block|}
name|pda
operator|->
name|next
operator|=
name|pda
operator|->
name|base
operator|+
name|pos
expr_stmt|;
block|}
return|return
name|pda
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/* Initialize the scanner. */
end_comment

begin_function
name|void
name|scan_init
parameter_list|()
block|{
comment|/* Initialize decoder array */
specifier|register
name|byte
name|_ds
modifier|*
name|decoder
init|=
name|scan_char_decoder
decl_stmt|;
specifier|static
name|char
name|stop_chars
index|[]
init|=
literal|"()<>[]{}/%"
decl_stmt|;
specifier|static
name|char
name|space_chars
index|[]
init|=
literal|" \f\t\n\r"
decl_stmt|;
name|decoder
index|[
name|ERRC
index|]
operator|=
name|ctype_eof
expr_stmt|;
comment|/* ****** FIX THIS? ****** */
name|decoder
index|[
name|EOFC
index|]
operator|=
name|ctype_eof
expr_stmt|;
name|memset
argument_list|(
name|decoder
argument_list|,
name|ctype_name
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|decoder
operator|+
literal|128
argument_list|,
name|ctype_btoken
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
name|_ds
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|space_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|decoder
index|[
operator|*
name|p
index|]
operator|=
name|ctype_space
expr_stmt|;
name|decoder
index|[
name|char_NULL
index|]
operator|=
name|decoder
index|[
name|char_VT
index|]
operator|=
name|decoder
index|[
name|char_DOS_EOF
index|]
operator|=
name|ctype_space
expr_stmt|;
for|for
control|(
name|p
operator|=
name|stop_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|decoder
index|[
operator|*
name|p
index|]
operator|=
name|ctype_other
expr_stmt|;
block|}
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|decoder
index|[
literal|'0'
operator|+
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_radix
operator|-
literal|10
condition|;
name|i
operator|++
control|)
name|decoder
index|[
literal|'A'
operator|+
name|i
index|]
operator|=
name|decoder
index|[
literal|'a'
operator|+
name|i
index|]
operator|=
name|i
operator|+
literal|10
expr_stmt|;
block|}
comment|/* Other initialization */
name|make_false
argument_list|(
operator|&
name|array_packing
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
operator|&
name|binary_object_format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a token from a stream. */
end_comment

begin_comment
comment|/* Return 1 for end-of-stream, 0 if a token was read, */
end_comment

begin_comment
comment|/* or a (negative) error code. */
end_comment

begin_comment
comment|/* If the token required a terminating character (i.e., was a name or */
end_comment

begin_comment
comment|/* number) and the next character was whitespace, read and discard */
end_comment

begin_comment
comment|/* that character: see the description of the 'token' operator on */
end_comment

begin_comment
comment|/* p. 232 of the Red Book. */
end_comment

begin_comment
comment|/* from_string indicates reading from a string vs. a file, */
end_comment

begin_comment
comment|/* because \ escapes are not recognized in the former case. */
end_comment

begin_comment
comment|/* (See the footnote on p. 23 of the Red Book.) */
end_comment

begin_function
name|int
name|scan_token
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|int
name|from_string
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|ref
modifier|*
name|myref
init|=
name|pref
decl_stmt|;
name|dynamic_area
name|proc_da
decl_stmt|;
comment|/* (not actually dynamic) */
name|int
name|pstack
init|=
literal|0
decl_stmt|;
comment|/* offset from proc_da.base */
name|int
name|retcode
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|name_type
decl_stmt|;
comment|/* number of /'s preceding */
name|int
name|try_number
decl_stmt|;
name|byte
name|s1
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|byte
name|_ds
modifier|*
name|decoder
init|=
name|scan_char_decoder
decl_stmt|;
comment|/* Only old P*stScr*pt interpreters use from_string.... */
name|from_string
operator|&=
operator|!
name|scan_enable_level2
expr_stmt|;
name|top
label|:
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|gs_debug
index|[
literal|'s'
index|]
condition|)
name|fprintf
argument_list|(
name|gs_debug_out
argument_list|,
operator|(
name|c
operator|>=
literal|32
operator|&&
name|c
operator|<=
literal|126
condition|?
literal|"`%c'"
else|:
literal|"`%03o'"
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
name|char_NULL
case|:
case|case
name|char_VT
case|:
case|case
name|char_DOS_EOF
case|:
goto|goto
name|top
goto|;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
name|s1
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|c
expr_stmt|;
name|name_ref
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|,
name|myref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r_set_attrs
argument_list|(
name|myref
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|scan_enable_level2
condition|)
block|{
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|name_type
operator|=
name|try_number
operator|=
literal|0
expr_stmt|;
goto|goto
name|try_funny_name
goto|;
comment|/****** Check for<~ here ******/
block|}
block|}
name|retcode
operator|=
name|scan_hex_string
argument_list|(
name|s
argument_list|,
name|myref
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|retcode
operator|=
name|scan_string
argument_list|(
name|s
argument_list|,
name|from_string
argument_list|,
name|myref
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
name|pstack
operator|==
literal|0
condition|)
block|{
comment|/* Use the operand stack to accumulate procedures. */
name|myref
operator|=
name|osp
operator|+
literal|1
expr_stmt|;
name|proc_da
operator|.
name|base
operator|=
operator|(
name|byte
operator|*
operator|)
name|myref
expr_stmt|;
name|proc_da
operator|.
name|limit
operator|=
operator|(
name|byte
operator|*
operator|)
operator|(
name|ostop
operator|+
literal|1
operator|)
expr_stmt|;
name|proc_da
operator|.
name|is_dynamic
operator|=
literal|0
expr_stmt|;
name|proc_da
operator|.
name|elt_size
operator|=
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|proc_da
operator|.
name|num_elts
operator|=
name|ostop
operator|-
name|osp
expr_stmt|;
block|}
if|if
condition|(
name|proc_da
operator|.
name|limit
operator|-
operator|(
name|byte
operator|*
operator|)
name|myref
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
condition|)
return|return
name|e_limitcheck
return|;
comment|/* ****** SHOULD GROW OSTACK ****** */
name|r_set_size
argument_list|(
name|myref
argument_list|,
name|pstack
argument_list|)
expr_stmt|;
name|myref
operator|++
expr_stmt|;
name|pstack
operator|=
operator|(
name|byte
operator|*
operator|)
name|myref
operator|-
name|proc_da
operator|.
name|base
expr_stmt|;
goto|goto
name|top
goto|;
case|case
literal|'>'
case|:
if|if
condition|(
name|scan_enable_level2
condition|)
block|{
name|name_type
operator|=
name|try_number
operator|=
literal|0
expr_stmt|;
goto|goto
name|try_funny_name
goto|;
block|}
comment|/* falls through */
case|case
literal|')'
case|:
name|retcode
operator|=
name|e_syntaxerror
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
name|pstack
operator|==
literal|0
condition|)
block|{
name|retcode
operator|=
name|e_syntaxerror
expr_stmt|;
break|break;
block|}
block|{
name|ref
modifier|*
name|ref0
init|=
operator|(
name|ref
operator|*
operator|)
operator|(
name|proc_da
operator|.
name|base
operator|+
name|pstack
operator|)
decl_stmt|;
name|uint
name|size
init|=
name|myref
operator|-
name|ref0
decl_stmt|;
name|ref
modifier|*
name|aref
decl_stmt|;
name|myref
operator|=
name|ref0
operator|-
literal|1
expr_stmt|;
name|pstack
operator|=
name|r_size
argument_list|(
name|myref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pstack
operator|==
literal|0
condition|)
name|myref
operator|=
name|pref
expr_stmt|;
if|if
condition|(
name|array_packing
operator|.
name|value
operator|.
name|index
condition|)
block|{
name|retcode
operator|=
name|make_packed_array
argument_list|(
name|ref0
argument_list|,
name|size
argument_list|,
name|myref
argument_list|,
literal|"scanner(packed)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
return|return
name|retcode
return|;
name|r_set_attrs
argument_list|(
name|myref
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aref
operator|=
name|alloc_refs
argument_list|(
name|size
argument_list|,
literal|"scanner(proc)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aref
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|refcpy_to_new
argument_list|(
name|aref
argument_list|,
name|ref0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|make_tasv_new
argument_list|(
name|myref
argument_list|,
name|t_array
argument_list|,
name|a_executable
operator|+
name|a_all
argument_list|,
name|size
argument_list|,
name|refs
argument_list|,
name|aref
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'/'
case|:
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|name_type
operator|=
literal|2
expr_stmt|;
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|name_type
operator|=
literal|1
expr_stmt|;
name|try_number
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|decoder
index|[
name|c
index|]
condition|)
block|{
case|case
name|ctype_name
case|:
default|default:
goto|goto
name|do_name
goto|;
case|case
name|ctype_btoken
case|:
if|if
condition|(
operator|!
name|recognize_btokens
argument_list|()
condition|)
goto|goto
name|do_name
goto|;
comment|/* otherwise, an empty name */
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
case|case
name|ctype_eof
case|:
comment|/* Empty name: bizarre but legitimate. */
name|name_ref
argument_list|(
operator|(
name|byte
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|myref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|have_name
goto|;
case|case
name|ctype_other
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'['
case|:
comment|/* only special as first character */
case|case
literal|']'
case|:
comment|/* ditto */
name|s1
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|c
expr_stmt|;
name|name_ref
argument_list|(
name|s1
argument_list|,
literal|1
argument_list|,
name|myref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|have_name
goto|;
case|case
literal|'<'
case|:
comment|/* legal in Level 2 */
case|case
literal|'>'
case|:
if|if
condition|(
name|scan_enable_level2
condition|)
goto|goto
name|try_funny_name
goto|;
default|default:
comment|/* Empty name: bizarre but legitimate. */
name|name_ref
argument_list|(
operator|(
name|byte
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|myref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|have_name
goto|;
block|}
case|case
name|ctype_space
case|:
comment|/* Empty name: bizarre but legitimate. */
name|name_ref
argument_list|(
operator|(
name|byte
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|myref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for \r\n */
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
operator|(
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|have_name
goto|;
block|}
comment|/* NOTREACHED */
case|case
literal|'%'
case|:
block|{
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|sgetc
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
literal|'\r'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* falls through */
case|case
literal|'\n'
case|:
case|case
literal|'\f'
case|:
goto|goto
name|top
goto|;
case|case
name|EOFC
case|:
goto|goto
name|ceof
goto|;
case|case
name|ERRC
case|:
goto|goto
name|cerr
goto|;
block|}
name|ceof
label|:
empty_stmt|;
block|}
comment|/* falls through */
case|case
name|EOFC
case|:
name|retcode
operator|=
operator|(
name|pstack
operator|!=
literal|0
condition|?
name|e_syntaxerror
else|:
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|ERRC
case|:
name|cerr
label|:
name|retcode
operator|=
name|e_ioerror
expr_stmt|;
break|break;
comment|/* Check for a Level 2 funny name (<< or>>). */
comment|/* c is '<' or '>'. */
name|try_funny_name
label|:
block|{
name|int
name|c1
init|=
name|sgetc
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|==
name|c
condition|)
block|{
name|s1
index|[
literal|0
index|]
operator|=
name|s1
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|retcode
operator|=
name|name_ref
argument_list|(
name|s1
argument_list|,
literal|2
argument_list|,
name|myref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|have_name
goto|;
block|}
if|if
condition|(
name|char_is_data
argument_list|(
name|c1
argument_list|)
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|retcode
operator|=
name|e_syntaxerror
expr_stmt|;
break|break;
comment|/* Handle separately the names that might be a number */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
name|name_type
operator|=
literal|0
expr_stmt|;
name|try_number
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_name
goto|;
comment|/* Check for a binary object */
define|#
directive|define
name|case4
parameter_list|(
name|c
parameter_list|)
value|case c: case c+1: case c+2: case c+3
name|case4
argument_list|(
literal|128
argument_list|)
operator|:
name|case4
argument_list|(
literal|132
argument_list|)
operator|:
name|case4
argument_list|(
literal|136
argument_list|)
operator|:
name|case4
argument_list|(
literal|140
argument_list|)
operator|:
name|case4
argument_list|(
literal|144
argument_list|)
operator|:
name|case4
argument_list|(
literal|148
argument_list|)
operator|:
name|case4
argument_list|(
literal|152
argument_list|)
operator|:
name|case4
argument_list|(
literal|156
argument_list|)
operator|:
undef|#
directive|undef
name|case4
if|if
condition|(
name|recognize_btokens
argument_list|()
condition|)
block|{
name|retcode
operator|=
call|(
modifier|*
name|scan_btoken_proc
call|)
argument_list|(
name|s
argument_list|,
name|myref
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Not a binary object, fall through. */
comment|/* The default is a name. */
default|default:
comment|/* Handle the common cases (letters and _) explicitly, */
comment|/* rather than going through the default test. */
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'_'
case|:
comment|/* Common code for scanning a name. */
comment|/* try_number and name_type are already set. */
comment|/* We know c has ctype_name (or maybe ctype_btoken) */
comment|/* or is a digit. */
name|name_type
operator|=
literal|0
expr_stmt|;
name|try_number
operator|=
literal|0
expr_stmt|;
name|do_name
label|:
block|{
name|dynamic_area
name|da
decl_stmt|;
name|int
name|max_name_ctype
init|=
operator|(
name|recognize_btokens
argument_list|()
condition|?
name|ctype_name
else|:
name|ctype_btoken
operator|)
decl_stmt|;
comment|/* Try to scan entirely within the stream buffer. */
comment|/* We stop 1 character early, so we don't switch buffers */
comment|/* looking ahead if the name is terminated by \r\n. */
specifier|register
name|byte
modifier|*
name|ptr
init|=
name|sbufptr
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|byte
modifier|*
name|end
init|=
name|sbufend
argument_list|(
name|s
argument_list|)
operator|-
literal|1
decl_stmt|;
name|da
operator|.
name|base
operator|=
name|ptr
operator|-
literal|1
expr_stmt|;
name|da
operator|.
name|is_dynamic
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ptr
operator|>=
name|end
condition|)
block|{
name|ssetbufptr
argument_list|(
name|s
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Initialize the dynamic area. */
comment|/* We have to do this before the next */
comment|/* sgetc, which will overwrite the buffer. */
name|da
operator|.
name|limit
operator|=
name|ptr
expr_stmt|;
name|da
operator|.
name|num_elts
operator|=
name|ptr
operator|-
name|da
operator|.
name|base
expr_stmt|;
name|da
operator|.
name|elt_size
operator|=
literal|1
expr_stmt|;
name|ptr
operator|=
name|dynamic_grow
argument_list|(
operator|&
name|da
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|e_VMerror
return|;
goto|goto
name|dyn_name
goto|;
block|}
name|c
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|decoder
index|[
name|c
index|]
operator|<=
name|max_name_ctype
condition|)
do|;
comment|/* digit or name */
comment|/* Name ended within the buffer. */
name|ssetbufptr
argument_list|(
name|s
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|--
expr_stmt|;
goto|goto
name|nx
goto|;
comment|/* Name overran buffer. */
name|dyn_name
label|:
while|while
condition|(
name|decoder
index|[
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
index|]
operator|<=
name|max_name_ctype
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|da
operator|.
name|limit
condition|)
block|{
name|ptr
operator|=
name|dynamic_grow
argument_list|(
operator|&
name|da
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|e_VMerror
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|nx
label|:
switch|switch
condition|(
name|decoder
index|[
name|c
index|]
condition|)
block|{
case|case
name|ctype_btoken
case|:
case|case
name|ctype_other
case|:
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctype_space
case|:
comment|/* Check for \r\n */
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
operator|(
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
case|case
name|ctype_eof
case|:
empty_stmt|;
block|}
comment|/* Check for a number */
if|if
condition|(
name|try_number
condition|)
block|{
name|retcode
operator|=
name|scan_number
argument_list|(
name|da
operator|.
name|base
argument_list|,
name|ptr
argument_list|,
name|myref
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
name|e_syntaxerror
condition|)
block|{
name|dynamic_free
argument_list|(
operator|&
name|da
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_type
operator|==
literal|2
condition|)
return|return
name|e_syntaxerror
return|;
break|break;
comment|/* might be e_limitcheck */
block|}
block|}
name|retcode
operator|=
name|name_ref
argument_list|(
name|da
operator|.
name|base
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|ptr
operator|-
name|da
operator|.
name|base
argument_list|)
argument_list|,
name|myref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dynamic_free
argument_list|(
operator|&
name|da
argument_list|)
expr_stmt|;
block|}
comment|/* Done scanning.  Check for preceding /'s. */
name|have_name
label|:
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
return|return
name|retcode
return|;
switch|switch
condition|(
name|name_type
condition|)
block|{
case|case
literal|0
case|:
comment|/* ordinary executable name */
if|if
condition|(
name|r_has_type
argument_list|(
name|myref
argument_list|,
name|t_name
argument_list|)
condition|)
comment|/* i.e., not a number */
name|r_set_attrs
argument_list|(
name|myref
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* quoted name */
break|break;
case|case
literal|2
case|:
comment|/* immediate lookup */
block|{
name|ref
modifier|*
name|pvalue
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|myref
argument_list|,
name|t_name
argument_list|)
condition|)
return|return
name|e_undefined
return|;
if|if
condition|(
operator|(
name|pvalue
operator|=
name|dict_find_name
argument_list|(
name|myref
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|e_undefined
return|;
name|ref_assign_new
argument_list|(
name|myref
argument_list|,
name|pvalue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we are at the top level, return the object, */
comment|/* otherwise keep going. */
if|if
condition|(
name|pstack
operator|==
literal|0
operator|||
name|retcode
operator|<
literal|0
condition|)
return|return
name|retcode
return|;
if|if
condition|(
name|proc_da
operator|.
name|limit
operator|-
operator|(
name|byte
operator|*
operator|)
name|myref
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ref
argument_list|)
condition|)
return|return
name|e_limitcheck
return|;
comment|/* ****** SHOULD GROW OSTACK ****** */
name|myref
operator|++
expr_stmt|;
goto|goto
name|top
goto|;
block|}
end_function

begin_comment
comment|/* The internal scanning procedures return 0 on success, */
end_comment

begin_comment
comment|/* or a (negative) error code on failure. */
end_comment

begin_comment
comment|/* Scan a number for cvi or cvr. */
end_comment

begin_comment
comment|/* The first argument is a t_string.  This is just like scan_number, */
end_comment

begin_comment
comment|/* but allows leading or trailing whitespace. */
end_comment

begin_function
name|int
name|scan_number_only
parameter_list|(
name|ref
modifier|*
name|psref
parameter_list|,
name|ref
modifier|*
name|pnref
parameter_list|)
block|{
name|byte
modifier|*
name|str
init|=
name|psref
operator|->
name|value
operator|.
name|bytes
decl_stmt|;
name|byte
modifier|*
name|end
init|=
name|str
operator|+
name|r_size
argument_list|(
name|psref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_attr
argument_list|(
name|psref
argument_list|,
name|a_read
argument_list|)
condition|)
return|return
name|e_invalidaccess
return|;
while|while
condition|(
name|str
operator|<
name|end
operator|&&
name|scan_char_decoder
index|[
operator|*
name|str
index|]
operator|==
name|ctype_space
condition|)
name|str
operator|++
expr_stmt|;
while|while
condition|(
name|str
operator|<
name|end
operator|&&
name|scan_char_decoder
index|[
name|end
index|[
operator|-
literal|1
index|]
index|]
operator|==
name|ctype_space
condition|)
name|end
operator|--
expr_stmt|;
return|return
name|scan_number
argument_list|(
name|str
argument_list|,
name|end
argument_list|,
name|pnref
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Note that the number scanning procedures use a byte ** and a byte * */
end_comment

begin_comment
comment|/* rather than a stream.  (It makes quite a difference in performance.) */
end_comment

begin_define
define|#
directive|define
name|ngetc
parameter_list|(
name|sp
parameter_list|)
value|(sp< end ? *sp++ : EOFC)
end_define

begin_define
define|#
directive|define
name|nputback
parameter_list|(
name|sp
parameter_list|)
value|(--sp)
end_define

begin_define
define|#
directive|define
name|nreturn
parameter_list|(
name|v
parameter_list|)
value|return (*pstr = sp, v)
end_define

begin_comment
comment|/* Procedure to scan a number. */
end_comment

begin_function
name|private
name|int
name|scan_number
parameter_list|(
name|byte
modifier|*
name|str
parameter_list|,
name|byte
modifier|*
name|end
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
comment|/* Powers of 10 up to 6 can be represented accurately as */
comment|/* a single-precision float. */
define|#
directive|define
name|num_powers_10
value|6
specifier|static
name|float
name|powers_10
index|[
name|num_powers_10
operator|+
literal|1
index|]
init|=
block|{
literal|1e0
block|,
literal|1e1
block|,
literal|1e2
block|,
literal|1e3
block|,
literal|1e4
block|,
literal|1e5
block|,
literal|1e6
block|}
decl_stmt|;
specifier|static
name|double
name|neg_powers_10
index|[
name|num_powers_10
operator|+
literal|1
index|]
init|=
block|{
literal|1e0
block|,
literal|1e-1
block|,
literal|1e-2
block|,
literal|1e-3
block|,
literal|1e-4
block|,
literal|1e-5
block|,
literal|1e-6
block|}
decl_stmt|;
name|byte
modifier|*
name|sp
init|=
name|str
decl_stmt|;
comment|/* can't be register because of& */
name|int
name|sign
init|=
literal|0
decl_stmt|;
name|long
name|ival
decl_stmt|;
name|double
name|dval
decl_stmt|;
name|int
name|exp10
init|=
literal|0
decl_stmt|;
name|int
name|code
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
condition|)
block|{
case|case
literal|'+'
case|:
name|sign
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|e_syntaxerror
operator|)
return|;
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|e_syntaxerror
operator|)
return|;
name|ival
operator|=
literal|0
expr_stmt|;
goto|goto
name|fi
goto|;
block|}
name|nputback
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|scan_int
argument_list|(
operator|&
name|sp
argument_list|,
name|end
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
operator|&
name|ival
argument_list|,
operator|&
name|dval
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
operator|(
name|code
operator|)
return|;
comment|/* e_syntaxerror */
comment|/* Code == 1, i.e., the integer overflowed. */
switch|switch
condition|(
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
condition|)
block|{
default|default:
return|return
operator|(
name|e_syntaxerror
operator|)
return|;
comment|/* not terminated properly */
case|case
literal|'.'
case|:
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|fd
goto|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
goto|goto
name|fsd
goto|;
case|case
name|EOFC
case|:
comment|/* return a float */
name|make_real_new
argument_list|(
name|pref
argument_list|,
call|(
name|float
call|)
argument_list|(
name|sign
operator|<
literal|0
condition|?
operator|-
name|dval
else|:
name|dval
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ERRC
case|:
return|return
name|e_ioerror
return|;
block|}
block|}
switch|switch
condition|(
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
condition|)
block|{
case|case
name|EOFC
case|:
break|break;
case|case
name|ERRC
case|:
return|return
name|e_ioerror
return|;
case|case
literal|'.'
case|:
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|fi
goto|;
default|default:
return|return
operator|(
name|e_syntaxerror
operator|)
return|;
comment|/* not terminated properly */
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
goto|goto
name|fsi
goto|;
case|case
literal|'#'
case|:
if|if
condition|(
name|sign
operator|||
name|ival
operator|<
name|min_radix
operator|||
name|ival
operator|>
name|max_radix
condition|)
return|return
operator|(
name|e_syntaxerror
operator|)
return|;
name|code
operator|=
name|scan_int
argument_list|(
operator|&
name|sp
argument_list|,
name|end
argument_list|,
operator|(
name|int
operator|)
name|ival
argument_list|,
literal|1
argument_list|,
operator|&
name|ival
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
return|return
operator|(
name|code
operator|)
return|;
switch|switch
condition|(
name|ngetc
argument_list|(
name|sp
argument_list|)
condition|)
block|{
case|case
name|EOFC
case|:
break|break;
case|case
name|ERRC
case|:
return|return
operator|(
name|e_ioerror
operator|)
return|;
default|default:
return|return
operator|(
name|e_syntaxerror
operator|)
return|;
block|}
block|}
comment|/* Return an integer */
name|make_int_new
argument_list|(
name|pref
argument_list|,
operator|(
name|sign
operator|<
literal|0
condition|?
operator|-
name|ival
else|:
name|ival
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Handle a real.  We just saw the decimal point. */
comment|/* Enter here if we are still accumulating an integer in ival. */
name|fi
label|:
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Check for overflowing ival */
if|if
condition|(
name|ival
operator|>=
operator|(
name|max_ulong
operator|>>
literal|1
operator|)
operator|/
literal|10
operator|-
literal|1
condition|)
block|{
name|dval
operator|=
name|ival
expr_stmt|;
goto|goto
name|fd
goto|;
block|}
name|ival
operator|=
name|ival
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|exp10
operator|--
expr_stmt|;
block|}
name|fsi
label|:
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|ival
operator|=
operator|-
name|ival
expr_stmt|;
comment|/* Take a shortcut for the common case */
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|exp10
operator|<
operator|-
name|num_powers_10
operator|)
condition|)
block|{
name|make_real_new
argument_list|(
name|pref
argument_list|,
call|(
name|float
call|)
argument_list|(
name|ival
operator|*
name|neg_powers_10
index|[
operator|-
name|exp10
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dval
operator|=
name|ival
expr_stmt|;
goto|goto
name|fe
goto|;
comment|/* Now we are accumulating a double in dval. */
name|fd
label|:
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|dval
operator|=
name|dval
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|exp10
operator|--
expr_stmt|;
block|}
name|fsd
label|:
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|dval
operator|=
operator|-
name|dval
expr_stmt|;
name|fe
label|:
comment|/* dval contains the value, negated if necessary */
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
comment|/* Check for a following exponent. */
name|int
name|esign
init|=
literal|0
decl_stmt|;
name|long
name|eexp
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
condition|)
block|{
case|case
literal|'+'
case|:
break|break;
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|nputback
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|scan_int
argument_list|(
operator|&
name|sp
argument_list|,
name|end
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
operator|&
name|eexp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
operator|(
name|code
operator|)
return|;
if|if
condition|(
name|code
operator|>
literal|0
operator|||
name|eexp
operator|>
literal|999
condition|)
return|return
operator|(
name|e_limitcheck
operator|)
return|;
comment|/* semi-arbitrary */
if|if
condition|(
name|esign
condition|)
name|exp10
operator|-=
operator|(
name|int
operator|)
name|eexp
expr_stmt|;
else|else
name|exp10
operator|+=
operator|(
name|int
operator|)
name|eexp
expr_stmt|;
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|EOFC
condition|)
return|return
operator|(
name|c
operator|==
name|ERRC
condition|?
name|e_ioerror
else|:
name|e_syntaxerror
operator|)
return|;
comment|/* Compute dval * 10^exp10. */
if|if
condition|(
name|exp10
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|exp10
operator|>
name|num_powers_10
condition|)
name|dval
operator|*=
name|powers_10
index|[
name|num_powers_10
index|]
operator|,
name|exp10
operator|-=
name|num_powers_10
expr_stmt|;
if|if
condition|(
name|exp10
operator|>
literal|0
condition|)
name|dval
operator|*=
name|powers_10
index|[
name|exp10
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp10
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|exp10
operator|<
operator|-
name|num_powers_10
condition|)
name|dval
operator|/=
name|powers_10
index|[
name|num_powers_10
index|]
operator|,
name|exp10
operator|+=
name|num_powers_10
expr_stmt|;
if|if
condition|(
name|exp10
operator|<
literal|0
condition|)
name|dval
operator|/=
name|powers_10
index|[
operator|-
name|exp10
index|]
expr_stmt|;
block|}
name|make_real_new
argument_list|(
name|pref
argument_list|,
operator|(
name|float
operator|)
name|dval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Internal subroutine to scan an integer. */
end_comment

begin_comment
comment|/* Return 0, e_limitcheck, or e_syntaxerror. */
end_comment

begin_comment
comment|/* (The only syntax error is no digits encountered.) */
end_comment

begin_comment
comment|/* Put back the terminating character. */
end_comment

begin_comment
comment|/* If nosign is true, the integer is scanned as unsigned; */
end_comment

begin_comment
comment|/* overflowing a ulong returns e_limitcheck.  If nosign is false, */
end_comment

begin_comment
comment|/* the integer is scanned as signed; if the integer won't fit in a long, */
end_comment

begin_comment
comment|/* then: */
end_comment

begin_comment
comment|/*   if pdval == NULL, return e_limitcheck; */
end_comment

begin_comment
comment|/*   if pdval != NULL, return 1 and store a double value in *pdval. */
end_comment

begin_function
name|private
name|int
name|scan_int
parameter_list|(
name|byte
modifier|*
modifier|*
name|pstr
parameter_list|,
name|byte
modifier|*
name|end
parameter_list|,
name|int
name|radix
parameter_list|,
name|int
name|nosign
parameter_list|,
name|long
modifier|*
name|pval
parameter_list|,
name|double
modifier|*
name|pdval
parameter_list|)
block|{
specifier|register
name|byte
modifier|*
name|sp
init|=
operator|*
name|pstr
decl_stmt|;
name|uint
name|ival
init|=
literal|0
decl_stmt|,
name|imax
decl_stmt|,
name|irem
decl_stmt|;
if|#
directive|if
name|arch_ints_are_short
name|ulong
name|lval
decl_stmt|,
name|lmax
decl_stmt|;
name|uint
name|lrem
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|lval
value|ival
comment|/* for overflowing into double */
endif|#
directive|endif
name|double
name|dval
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|byte
name|_ds
modifier|*
name|decoder
init|=
name|scan_char_decoder
decl_stmt|;
comment|/* Avoid the long divisions when radix = 10 */
define|#
directive|define
name|set_max
parameter_list|(
name|vmax
parameter_list|,
name|vrem
parameter_list|,
name|big
parameter_list|)
define|\
value|if ( radix == 10 )	vmax = (big) / 10, vrem = (big) % 10;\   else			vmax = (big) / radix, vrem = (big) % radix
name|set_max
argument_list|(
name|imax
argument_list|,
name|irem
argument_list|,
name|max_uint
argument_list|)
expr_stmt|;
define|#
directive|define
name|convert_digit_fails
parameter_list|(
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|(d = decoder[c])>= radix
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_digit_fails
argument_list|(
name|c
argument_list|,
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|nputback
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|ival
operator|<
literal|0
operator|&&
operator|!
name|nosign
condition|)
block|{
name|d
operator|=
name|ival
operator|%
name|radix
expr_stmt|;
name|ival
operator|/=
name|radix
expr_stmt|;
break|break;
block|}
operator|*
name|pval
operator|=
name|ival
expr_stmt|;
name|nreturn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ival
operator|>=
name|imax
operator|&&
operator|(
name|ival
operator|>
name|imax
operator|||
name|d
operator|>
name|irem
operator|)
condition|)
break|break;
comment|/* overflow */
name|ival
operator|=
name|ival
operator|*
name|radix
operator|+
name|d
expr_stmt|;
block|}
if|#
directive|if
name|arch_ints_are_short
comment|/* Short integer overflowed.  Accumulate in a long. */
name|lval
operator|=
operator|(
name|ulong
operator|)
name|ival
operator|*
name|radix
operator|+
name|d
expr_stmt|;
name|set_max
argument_list|(
name|lmax
argument_list|,
name|lrem
argument_list|,
name|max_ulong
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_digit_fails
argument_list|(
name|c
argument_list|,
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|nputback
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|lval
operator|<
literal|0
operator|&&
operator|!
name|nosign
condition|)
block|{
name|d
operator|=
name|lval
operator|%
name|radix
expr_stmt|;
name|lval
operator|/=
name|radix
expr_stmt|;
break|break;
block|}
operator|*
name|pval
operator|=
name|lval
expr_stmt|;
name|nreturn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lval
operator|>=
name|lmax
operator|&&
operator|(
name|lval
operator|>
name|lmax
operator|||
name|d
operator|>
name|lrem
operator|)
condition|)
break|break;
comment|/* overflow */
name|lval
operator|=
name|lval
operator|*
name|radix
operator|+
name|d
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Integer overflowed.  Accumulate the result as a double. */
if|if
condition|(
name|pdval
operator|==
name|NULL
condition|)
name|nreturn
argument_list|(
name|e_limitcheck
argument_list|)
expr_stmt|;
name|dval
operator|=
operator|(
name|double
operator|)
name|lval
operator|*
name|radix
operator|+
name|d
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|ngetc
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|convert_digit_fails
argument_list|(
name|c
argument_list|,
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|nputback
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|*
name|pdval
operator|=
name|dval
expr_stmt|;
name|nreturn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dval
operator|=
name|dval
operator|*
name|radix
operator|+
name|d
expr_stmt|;
block|}
comment|/* Control doesn't get here */
block|}
end_function

begin_comment
comment|/* Make a string.  If the allocation fails, release any dynamic storage. */
end_comment

begin_function
name|private
name|int
name|mk_string
parameter_list|(
name|ref
modifier|*
name|pref
parameter_list|,
name|da_ptr
name|pda
parameter_list|,
name|byte
modifier|*
name|next
parameter_list|)
block|{
name|uint
name|size
init|=
operator|(
name|pda
operator|->
name|next
operator|=
name|next
operator|)
operator|-
name|pda
operator|->
name|base
decl_stmt|;
name|byte
modifier|*
name|body
init|=
name|alloc_shrink
argument_list|(
name|pda
operator|->
name|base
argument_list|,
name|pda
operator|->
name|num_elts
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
literal|"scanner(string)"
argument_list|)
decl_stmt|;
if|if
condition|(
name|body
operator|==
literal|0
condition|)
block|{
name|dynamic_free
argument_list|(
name|pda
argument_list|)
expr_stmt|;
return|return
name|e_VMerror
return|;
block|}
name|make_tasv_new
argument_list|(
name|pref
argument_list|,
name|t_string
argument_list|,
name|a_all
argument_list|,
name|size
argument_list|,
name|bytes
argument_list|,
name|body
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Internal procedure to scan a string. */
end_comment

begin_function
name|private
name|int
name|scan_string
parameter_list|(
specifier|register
name|stream
modifier|*
name|s
parameter_list|,
name|int
name|from_string
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|dynamic_area
name|da
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|byte
modifier|*
name|ptr
init|=
name|dynamic_begin
argument_list|(
operator|&
name|da
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|plevel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|top
label|:
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|(
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
case|case
name|EOFC
case|:
name|dynamic_free
argument_list|(
operator|&
name|da
argument_list|)
expr_stmt|;
return|return
name|e_syntaxerror
return|;
case|case
name|ERRC
case|:
name|dynamic_free
argument_list|(
operator|&
name|da
argument_list|)
expr_stmt|;
return|return
name|e_ioerror
return|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|from_string
condition|)
break|break;
switch|switch
condition|(
operator|(
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* ignore, check for following \n */
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
literal|'\n'
case|:
goto|goto
name|top
goto|;
comment|/* ignore */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|int
name|d
init|=
name|sgetc
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|'0'
operator|&&
name|d
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|d
operator|-
literal|'0'
expr_stmt|;
name|d
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|'0'
operator|&&
name|d
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|=
operator|(
name|c
operator|<<
literal|3
operator|)
operator|+
name|d
operator|-
literal|'0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|char_is_signal
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|dynamic_free
argument_list|(
operator|&
name|da
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|==
name|ERRC
condition|?
name|e_ioerror
else|:
name|e_syntaxerror
operator|)
return|;
block|}
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
comment|/* ignore the \ */
block|}
break|break;
case|case
literal|'('
case|:
name|plevel
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
name|plevel
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
literal|'\r'
case|:
comment|/* convert to \n */
name|c
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|char_is_data
argument_list|(
name|c
argument_list|)
condition|)
name|sputback
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|da
operator|.
name|limit
condition|)
block|{
name|ptr
operator|=
name|dynamic_grow
argument_list|(
operator|&
name|da
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|e_VMerror
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|out
label|:
return|return
name|mk_string
argument_list|(
name|pref
argument_list|,
operator|&
name|da
argument_list|,
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Internal procedure to scan a hex string. */
end_comment

begin_function
name|private
name|int
name|scan_hex_string
parameter_list|(
name|stream
modifier|*
name|s
parameter_list|,
name|ref
modifier|*
name|pref
parameter_list|)
block|{
name|dynamic_area
name|da
decl_stmt|;
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|byte
modifier|*
name|ptr
init|=
name|dynamic_begin
argument_list|(
operator|&
name|da
argument_list|,
literal|100
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|byte
name|_ds
modifier|*
name|decoder
init|=
name|scan_char_decoder
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|l1
label|:
do|do
block|{
name|c1
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val1
operator|=
name|decoder
index|[
name|c1
index|]
operator|)
operator|<
literal|0x10
condition|)
block|{
do|do
block|{
name|c2
operator|=
name|sgetc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val2
operator|=
name|decoder
index|[
name|c2
index|]
operator|)
operator|<
literal|0x10
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|da
operator|.
name|limit
condition|)
block|{
name|ptr
operator|=
name|dynamic_grow
argument_list|(
operator|&
name|da
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|e_VMerror
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
operator|(
name|val1
operator|<<
literal|4
operator|)
operator|+
name|val2
expr_stmt|;
goto|goto
name|l1
goto|;
block|}
block|}
do|while
condition|(
name|val2
operator|==
name|ctype_space
condition|)
do|;
if|if
condition|(
name|c2
operator|!=
literal|'>'
condition|)
block|{
name|dynamic_free
argument_list|(
operator|&
name|da
argument_list|)
expr_stmt|;
return|return
name|e_syntaxerror
return|;
block|}
if|if
condition|(
name|ptr
operator|==
name|da
operator|.
name|limit
condition|)
block|{
name|ptr
operator|=
name|dynamic_grow
argument_list|(
operator|&
name|da
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|e_VMerror
return|;
block|}
operator|*
name|ptr
operator|++
operator|=
name|val1
operator|<<
literal|4
expr_stmt|;
comment|/* no 2nd char */
goto|goto
name|lx
goto|;
block|}
block|}
do|while
condition|(
name|val1
operator|==
name|ctype_space
condition|)
do|;
if|if
condition|(
name|c1
operator|!=
literal|'>'
condition|)
block|{
name|dynamic_free
argument_list|(
operator|&
name|da
argument_list|)
expr_stmt|;
return|return
name|e_syntaxerror
return|;
block|}
name|lx
label|:
return|return
name|mk_string
argument_list|(
name|pref
argument_list|,
operator|&
name|da
argument_list|,
name|ptr
argument_list|)
return|;
block|}
end_function

end_unit

