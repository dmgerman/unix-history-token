begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zfont0.c */
end_comment

begin_comment
comment|/* Composite font creation operator for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_comment
comment|/*  * The following lines used to say:  *	#include "gsmatrix.h"  *	#include "gxdevice.h"		/. for gxfont.h ./  * Tony Li says the longer list is necessary to keep the GNU compiler  * happy, but this is pretty hard to understand....  */
end_comment

begin_include
include|#
directive|include
file|"gxfixed.h"
end_include

begin_include
include|#
directive|include
file|"gxmatrix.h"
end_include

begin_include
include|#
directive|include
file|"gzstate.h"
end_include

begin_comment
comment|/* must precede gxdevice */
end_comment

begin_include
include|#
directive|include
file|"gxdevice.h"
end_include

begin_comment
comment|/* must precede gxfont */
end_comment

begin_include
include|#
directive|include
file|"gschar.h"
end_include

begin_include
include|#
directive|include
file|"gxfont.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"font.h"
end_include

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* Imports */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|build_gs_font
argument_list|(
name|P4
argument_list|(
name|os_ptr
argument_list|,
name|gs_font
operator|*
operator|*
argument_list|,
name|font_type
argument_list|,
name|ref
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ref
name|name_FID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|ensure_char_entry
argument_list|(
name|P4
argument_list|(
name|os_ptr
argument_list|,
name|ref
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of system-known keys in type 0 font dictionaries: */
end_comment

begin_decl_stmt
name|private
name|ref
name|name_EscChar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|name_FDepVector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|name_FMapType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|name_PrefEnc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|name_ShiftIn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|name_ShiftOut
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|name_SubsVector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ref
name|name_Type0BuildChar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the composite font operators */
end_comment

begin_function
name|private
name|void
name|zfont0_init
parameter_list|()
block|{
specifier|static
name|names_def
name|fnd0
index|[]
init|=
block|{
block|{
literal|"EscChar"
block|,
operator|&
name|name_EscChar
block|}
block|,
block|{
literal|"FDepVector"
block|,
operator|&
name|name_FDepVector
block|}
block|,
block|{
literal|"FMapType"
block|,
operator|&
name|name_FMapType
block|}
block|,
block|{
literal|"PrefEnc"
block|,
operator|&
name|name_PrefEnc
block|}
block|,
block|{
literal|"ShiftIn"
block|,
operator|&
name|name_ShiftIn
block|}
block|,
block|{
literal|"ShiftOut"
block|,
operator|&
name|name_ShiftOut
block|}
block|,
block|{
literal|"SubsVector"
block|,
operator|&
name|name_SubsVector
block|}
block|,
block|{
literal|"Type0BuildChar"
block|,
operator|&
name|name_Type0BuildChar
block|}
block|,
name|names_def_end
block|}
decl_stmt|;
name|init_names
argument_list|(
name|fnd0
argument_list|)
expr_stmt|;
comment|/* Make the standard BuildChar procedure executable. */
name|r_set_attrs
argument_list|(
operator|&
name|name_Type0BuildChar
argument_list|,
name|a_executable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* .buildfont0 */
end_comment

begin_comment
comment|/* Build a type 0 (composite) font. */
end_comment

begin_function
name|int
name|zbuildfont0
parameter_list|(
name|os_ptr
name|op
parameter_list|)
block|{
name|ref
modifier|*
name|pfmaptype
decl_stmt|;
name|gs_type0_data
name|data
decl_stmt|;
name|ref
modifier|*
name|pfdepvector
decl_stmt|;
name|ref
modifier|*
name|pprefenc
decl_stmt|;
name|ref
modifier|*
name|psubsvector
decl_stmt|;
name|gs_font
modifier|*
name|pfont
decl_stmt|;
name|font_data
modifier|*
name|pdata
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|code
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_dictionary
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict_find
argument_list|(
name|op
argument_list|,
operator|&
name|name_FMapType
argument_list|,
operator|&
name|pfmaptype
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|r_has_type
argument_list|(
name|pfmaptype
argument_list|,
name|t_integer
argument_list|)
operator|||
name|pfmaptype
operator|->
name|value
operator|.
name|intval
operator|<
operator|(
name|int
operator|)
name|fmap_type_min
operator|||
name|pfmaptype
operator|->
name|value
operator|.
name|intval
operator|>
operator|(
name|int
operator|)
name|fmap_type_max
operator|||
name|dict_find
argument_list|(
name|op
argument_list|,
operator|&
name|name_FDepVector
argument_list|,
operator|&
name|pfdepvector
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|r_has_type
argument_list|(
name|pfdepvector
argument_list|,
name|t_array
argument_list|)
condition|)
return|return
name|e_invalidfont
return|;
name|data
operator|.
name|FMapType
operator|=
operator|(
name|fmap_type
operator|)
name|pfmaptype
operator|->
name|value
operator|.
name|intval
expr_stmt|;
comment|/* Check that every element of the FDepVector is a font. */
name|data
operator|.
name|fdep_size
operator|=
name|r_size
argument_list|(
name|pfdepvector
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|fdep_size
condition|;
name|i
operator|++
control|)
block|{
name|ref
modifier|*
name|pdep
init|=
name|pfdepvector
operator|->
name|value
operator|.
name|refs
operator|+
name|i
decl_stmt|;
name|ref
modifier|*
name|pfid
decl_stmt|;
name|gs_font
modifier|*
name|psub
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pdep
argument_list|,
name|t_dictionary
argument_list|)
operator|||
name|dict_find
argument_list|(
name|pdep
argument_list|,
operator|&
name|name_FID
argument_list|,
operator|&
name|pfid
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|r_has_type
argument_list|(
name|pfid
argument_list|,
name|t_fontID
argument_list|)
condition|)
return|return
name|e_invalidfont
return|;
comment|/* 		 * Check the inheritance rules.  Allowed configurations 		 * (paths from root font) are defined by the regular 		 * expression: 		 *	(shift | double_escape escape* | escape*) 		 *	  non_modal* non_composite 		 */
name|psub
operator|=
name|pfid
operator|->
name|value
operator|.
name|pfont
expr_stmt|;
if|if
condition|(
name|psub
operator|->
name|FontType
operator|==
name|ft_composite
condition|)
block|{
name|fmap_type
name|fmt
init|=
name|psub
operator|->
name|data
operator|.
name|type0_data
operator|.
name|FMapType
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|fmap_double_escape
operator|||
name|fmt
operator|==
name|fmap_shift
operator|||
name|fmt
operator|==
name|fmap_escape
operator|&&
operator|!
operator|(
name|data
operator|.
name|FMapType
operator|==
name|fmap_escape
operator|||
name|data
operator|.
name|FMapType
operator|==
name|fmap_double_escape
operator|)
condition|)
return|return
name|e_invalidfont
return|;
block|}
block|}
switch|switch
condition|(
name|data
operator|.
name|FMapType
condition|)
block|{
case|case
name|fmap_escape
case|:
case|case
name|fmap_double_escape
case|:
comment|/* need EscChar */
name|code
operator|=
name|ensure_char_entry
argument_list|(
name|op
argument_list|,
operator|&
name|name_EscChar
argument_list|,
operator|&
name|data
operator|.
name|EscChar
argument_list|,
literal|255
argument_list|)
expr_stmt|;
break|break;
case|case
name|fmap_shift
case|:
comment|/* need ShiftIn& ShiftOut */
name|code
operator|=
name|ensure_char_entry
argument_list|(
name|op
argument_list|,
operator|&
name|name_ShiftIn
argument_list|,
operator|&
name|data
operator|.
name|ShiftIn
argument_list|,
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
name|code
operator|=
name|ensure_char_entry
argument_list|(
name|op
argument_list|,
operator|&
name|name_ShiftOut
argument_list|,
operator|&
name|data
operator|.
name|ShiftOut
argument_list|,
literal|14
argument_list|)
expr_stmt|;
break|break;
case|case
name|fmap_SubsVector
case|:
comment|/* need SubsVector */
if|if
condition|(
name|dict_find
argument_list|(
name|op
argument_list|,
operator|&
name|name_SubsVector
argument_list|,
operator|&
name|psubsvector
argument_list|)
operator|<=
literal|0
operator|||
operator|!
name|r_has_type
argument_list|(
name|psubsvector
argument_list|,
name|t_string
argument_list|)
operator|||
name|r_size
argument_list|(
name|psubsvector
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|data
operator|.
name|subs_width
operator|=
operator|(
name|int
operator|)
operator|*
name|psubsvector
operator|->
name|value
operator|.
name|bytes
operator|+
literal|1
operator|)
operator|>
literal|4
operator|||
operator|(
name|r_size
argument_list|(
name|psubsvector
argument_list|)
operator|-
literal|1
operator|)
operator|%
name|data
operator|.
name|subs_width
operator|!=
literal|0
condition|)
return|return
name|e_invalidfont
return|;
default|default:
name|code
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|code
operator|=
name|build_gs_font
argument_list|(
name|op
argument_list|,
operator|&
name|pfont
argument_list|,
name|ft_composite
argument_list|,
operator|&
name|name_Type0BuildChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
condition|)
return|return
name|code
return|;
if|if
condition|(
name|dict_find
argument_list|(
name|op
argument_list|,
operator|&
name|name_PrefEnc
argument_list|,
operator|&
name|pprefenc
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ref
name|nul
decl_stmt|;
name|make_null_new
argument_list|(
operator|&
name|nul
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|dict_put
argument_list|(
name|op
argument_list|,
operator|&
name|name_PrefEnc
argument_list|,
operator|&
name|nul
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
comment|/* Fill in the font data */
name|pdata
operator|=
operator|(
name|font_data
operator|*
operator|)
operator|(
name|pfont
operator|->
name|client_data
operator|)
expr_stmt|;
name|data
operator|.
name|subs_size
operator|=
operator|(
name|r_size
argument_list|(
name|psubsvector
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|data
operator|.
name|subs_width
expr_stmt|;
name|data
operator|.
name|SubsVector
operator|=
name|psubsvector
operator|->
name|value
operator|.
name|bytes
operator|+
literal|1
expr_stmt|;
name|data
operator|.
name|encoding_size
operator|=
name|r_size
argument_list|(
operator|&
name|pdata
operator|->
name|Encoding
argument_list|)
expr_stmt|;
name|data
operator|.
name|Encoding
operator|=
operator|(
name|uint
operator|*
operator|)
name|alloc
argument_list|(
name|data
operator|.
name|encoding_size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint
argument_list|)
argument_list|,
literal|"buildfont0(Encoding)"
argument_list|)
expr_stmt|;
comment|/* Fill in the encoding vector, checking to make sure that */
comment|/* each element is an integer between 0 and fdep_size-1. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|encoding_size
condition|;
name|i
operator|++
control|)
block|{
name|ref
modifier|*
name|penc
init|=
name|pdata
operator|->
name|Encoding
operator|.
name|value
operator|.
name|refs
operator|+
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|penc
argument_list|,
name|t_integer
argument_list|)
operator|||
operator|(
name|ulong
operator|)
name|penc
operator|->
name|value
operator|.
name|intval
operator|>=
name|data
operator|.
name|fdep_size
condition|)
return|return
name|e_invalidfont
return|;
name|data
operator|.
name|Encoding
index|[
name|i
index|]
operator|=
operator|(
name|uint
operator|)
name|penc
operator|->
name|value
operator|.
name|intval
expr_stmt|;
block|}
name|data
operator|.
name|FDepVector
operator|=
operator|(
name|gs_font
operator|*
operator|*
operator|)
name|alloc
argument_list|(
name|data
operator|.
name|fdep_size
argument_list|,
sizeof|sizeof
argument_list|(
name|gs_font
operator|*
argument_list|)
argument_list|,
literal|"buildfont0(FDepVector)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|fdep_size
condition|;
name|i
operator|++
control|)
block|{
name|ref
modifier|*
name|pfid
decl_stmt|;
comment|/* The lookup can't fail, because of the pre-check above. */
name|dict_find
argument_list|(
name|pfdepvector
operator|->
name|value
operator|.
name|refs
operator|+
name|i
argument_list|,
operator|&
name|name_FID
argument_list|,
operator|&
name|pfid
argument_list|)
expr_stmt|;
name|data
operator|.
name|FDepVector
index|[
name|i
index|]
operator|=
name|pfid
operator|->
name|value
operator|.
name|pfont
expr_stmt|;
block|}
name|pfont
operator|->
name|data
operator|.
name|type0_data
operator|=
name|data
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Private routine to find or add an integer entry in a font dictionary. */
end_comment

begin_function
name|private
name|int
name|ensure_char_entry
parameter_list|(
name|os_ptr
name|op
parameter_list|,
name|ref
modifier|*
name|pname
parameter_list|,
name|byte
modifier|*
name|pvalue
parameter_list|,
name|int
name|default_value
parameter_list|)
block|{
name|ref
modifier|*
name|pentry
decl_stmt|;
if|if
condition|(
name|dict_find
argument_list|(
name|op
argument_list|,
name|pname
argument_list|,
operator|&
name|pentry
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ref
name|ent
decl_stmt|;
name|make_int
argument_list|(
operator|&
name|ent
argument_list|,
name|default_value
argument_list|)
expr_stmt|;
return|return
name|dict_put
argument_list|(
name|op
argument_list|,
name|pname
argument_list|,
operator|&
name|ent
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|r_has_type
argument_list|(
name|pentry
argument_list|,
name|t_integer
argument_list|)
operator|||
call|(
name|ulong
call|)
argument_list|(
name|pentry
operator|->
name|value
operator|.
name|intval
argument_list|)
operator|>
literal|255
condition|)
return|return
name|e_invalidfont
return|;
operator|*
name|pvalue
operator|=
operator|(
name|byte
operator|)
name|pentry
operator|->
name|value
operator|.
name|intval
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zfont0_op_defs
index|[]
init|=
block|{
block|{
literal|"1.buildfont0"
block|,
name|zbuildfont0
block|}
block|,
name|op_def_end
argument_list|(
argument|zfont0_init
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

