begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1990, 1991 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zpath2.c */
end_comment

begin_comment
comment|/* Non-constructor path operators for GhostScript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_comment
comment|/* for pathforall */
end_comment

begin_include
include|#
directive|include
file|"gspath.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_comment
comment|/* flattenpath */
end_comment

begin_function
name|int
name|zflattenpath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_flattenpath
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* reversepath */
end_comment

begin_function
name|int
name|zreversepath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_reversepath
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* strokepath */
end_comment

begin_function
name|int
name|zstrokepath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_strokepath
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* clippath */
end_comment

begin_function
name|int
name|zclippath
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_clippath
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* pathbbox */
end_comment

begin_function
name|int
name|zpathbbox
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_rect
name|box
decl_stmt|;
name|int
name|code
init|=
name|gs_pathbbox
argument_list|(
name|igs
argument_list|,
operator|&
name|box
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
name|push
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
operator|-
literal|3
argument_list|,
name|box
operator|.
name|p
operator|.
name|x
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
operator|-
literal|2
argument_list|,
name|box
operator|.
name|p
operator|.
name|y
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|box
operator|.
name|q
operator|.
name|x
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
argument_list|,
name|box
operator|.
name|q
operator|.
name|y
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* pathforall */
end_comment

begin_decl_stmt
name|private
name|int
name|path_continue
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|i_path_continue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zpathforall
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_path_enum
modifier|*
name|penum
decl_stmt|;
name|check_proc
argument_list|(
name|op
index|[
operator|-
literal|3
index|]
argument_list|)
expr_stmt|;
name|check_proc
argument_list|(
name|op
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|check_proc
argument_list|(
name|op
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|check_proc
argument_list|(
operator|*
name|op
argument_list|)
expr_stmt|;
name|check_estack
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|penum
operator|=
operator|(
name|gs_path_enum
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
name|gs_path_enum_sizeof
argument_list|,
literal|"pathforall"
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|e_VMerror
return|;
name|gs_path_enum_init
argument_list|(
name|penum
argument_list|,
name|igs
argument_list|)
expr_stmt|;
comment|/* Push a mark, the four procedures, and a pseudo-integer */
comment|/* in which value.bytes points to the path enumerator, */
comment|/* and then call the continuation procedure. */
name|mark_estack
argument_list|(
name|es_for
argument_list|)
expr_stmt|;
comment|/* iterator */
operator|*
operator|++
name|esp
operator|=
name|op
index|[
operator|-
literal|3
index|]
expr_stmt|;
comment|/* moveto proc */
operator|*
operator|++
name|esp
operator|=
name|op
index|[
operator|-
literal|2
index|]
expr_stmt|;
comment|/* lineto proc */
operator|*
operator|++
name|esp
operator|=
name|op
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* curveto proc */
operator|*
operator|++
name|esp
operator|=
operator|*
name|op
expr_stmt|;
comment|/* closepath proc */
operator|++
name|esp
expr_stmt|;
name|make_tv
argument_list|(
name|esp
argument_list|,
name|t_integer
argument_list|,
name|bytes
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|penum
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|op
operator|-=
literal|4
expr_stmt|;
return|return
name|path_continue
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Continuation procedure for pathforall */
end_comment

begin_decl_stmt
name|private
name|int
name|pf_push
argument_list|(
name|P3
argument_list|(
name|gs_point
operator|*
argument_list|,
name|int
argument_list|,
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|path_continue
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|gs_path_enum
modifier|*
name|penum
init|=
operator|(
name|gs_path_enum
operator|*
operator|)
name|esp
operator|->
name|value
operator|.
name|bytes
decl_stmt|;
name|gs_point
name|ppts
index|[
literal|3
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
name|code
operator|=
name|gs_path_enum_next
argument_list|(
name|penum
argument_list|,
name|ppts
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* all done */
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|penum
argument_list|,
literal|1
argument_list|,
name|gs_path_enum_sizeof
argument_list|,
literal|"pathforall"
argument_list|)
expr_stmt|;
name|esp
operator|-=
literal|6
expr_stmt|;
return|return
name|o_pop_estack
return|;
block|}
default|default:
comment|/* error */
return|return
name|code
return|;
case|case
name|gs_pe_moveto
case|:
name|esp
index|[
literal|2
index|]
operator|=
name|esp
index|[
operator|-
literal|4
index|]
expr_stmt|;
comment|/* moveto proc */
name|code
operator|=
name|pf_push
argument_list|(
name|ppts
argument_list|,
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|gs_pe_lineto
case|:
name|esp
index|[
literal|2
index|]
operator|=
name|esp
index|[
operator|-
literal|3
index|]
expr_stmt|;
comment|/* lineto proc */
name|code
operator|=
name|pf_push
argument_list|(
name|ppts
argument_list|,
literal|1
argument_list|,
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|gs_pe_curveto
case|:
name|esp
index|[
literal|2
index|]
operator|=
name|esp
index|[
operator|-
literal|2
index|]
expr_stmt|;
comment|/* curveto proc */
name|code
operator|=
name|pf_push
argument_list|(
name|ppts
argument_list|,
literal|3
argument_list|,
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|gs_pe_closepath
case|:
name|esp
index|[
literal|2
index|]
operator|=
name|esp
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* closepath proc */
name|code
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* ostack overflow in pf_push */
name|push_op_estack
argument_list|(
name|path_continue
argument_list|,
name|i_path_continue
argument_list|)
expr_stmt|;
operator|++
name|esp
expr_stmt|;
comment|/* include pushed procedure */
return|return
name|o_push_estack
return|;
block|}
end_function

begin_comment
comment|/* Internal procedure to push one or more points */
end_comment

begin_function
name|private
name|int
name|pf_push
parameter_list|(
name|gs_point
modifier|*
name|ppts
parameter_list|,
name|int
name|n
parameter_list|,
name|os_ptr
name|op
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|push
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|ppts
operator|->
name|x
argument_list|)
expr_stmt|;
name|make_real
argument_list|(
name|op
argument_list|,
name|ppts
operator|->
name|y
argument_list|)
expr_stmt|;
name|ppts
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* initclip */
end_comment

begin_function
name|int
name|zinitclip
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_initclip
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* clip */
end_comment

begin_function
name|int
name|zclip
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_clip
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* eoclip */
end_comment

begin_function
name|int
name|zeoclip
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
return|return
name|gs_eoclip
argument_list|(
name|igs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zpath2_op_defs
index|[]
init|=
block|{
block|{
literal|"0clip"
block|,
name|zclip
block|}
block|,
block|{
literal|"0clippath"
block|,
name|zclippath
block|}
block|,
block|{
literal|"0eoclip"
block|,
name|zeoclip
block|}
block|,
block|{
literal|"0flattenpath"
block|,
name|zflattenpath
block|}
block|,
block|{
literal|"0initclip"
block|,
name|zinitclip
block|}
block|,
block|{
literal|"0pathbbox"
block|,
name|zpathbbox
block|}
block|,
block|{
literal|"4pathforall"
block|,
name|zpathforall
block|}
block|,
block|{
literal|"0reversepath"
block|,
name|zreversepath
block|}
block|,
block|{
literal|"0strokepath"
block|,
name|zstrokepath
block|}
block|,
comment|/* Internal operators */
block|{
literal|"0%path_continue"
block|,
name|path_continue
block|,
operator|&
name|i_path_continue
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

