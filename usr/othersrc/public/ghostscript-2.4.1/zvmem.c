begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* zvmem.c */
end_comment

begin_comment
comment|/* "Virtual memory" operators for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"ghost.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"oper.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"estack.h"
end_include

begin_comment
comment|/* for checking in restore */
end_comment

begin_include
include|#
directive|include
file|"dict.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"dstack.h"
end_include

begin_include
include|#
directive|include
file|"save.h"
end_include

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"store.h"
end_include

begin_include
include|#
directive|include
file|"gsmatrix.h"
end_include

begin_comment
comment|/* for gsstate.h */
end_comment

begin_include
include|#
directive|include
file|"gsstate.h"
end_include

begin_comment
comment|/* Imported operators */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|zgsave
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zgrestore
argument_list|(
name|P1
argument_list|(
name|os_ptr
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Import the routine for setting the attributes of the identity matrix. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|init_identity_matrix
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'Save' structure */
end_comment

begin_typedef
typedef|typedef
name|struct
name|vm_save_s
name|vm_save
typedef|;
end_typedef

begin_struct
struct|struct
name|vm_save_s
block|{
name|alloc_save
modifier|*
name|asave
decl_stmt|;
comment|/* allocator save */
name|int_gstate
name|isave
decl_stmt|;
comment|/* old interpreter state */
name|gs_state
modifier|*
name|gsave
decl_stmt|;
comment|/* old graphics state */
block|}
struct|;
end_struct

begin_comment
comment|/* save */
end_comment

begin_function
name|int
name|zsave
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|vm_save
modifier|*
name|vmsave
init|=
operator|(
name|vm_save
operator|*
operator|)
name|alloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_save
argument_list|)
argument_list|,
literal|"zsave"
argument_list|)
decl_stmt|;
name|alloc_save
modifier|*
name|asave
decl_stmt|;
name|int
name|code
decl_stmt|;
name|gs_state
modifier|*
name|prev
decl_stmt|,
modifier|*
name|prev2
decl_stmt|;
if|if
condition|(
name|vmsave
operator|==
literal|0
condition|)
name|return_error
argument_list|(
name|e_VMerror
argument_list|)
expr_stmt|;
name|asave
operator|=
name|alloc_save_state
argument_list|()
expr_stmt|;
if|if
condition|(
name|asave
operator|==
literal|0
condition|)
block|{
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vmsave
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_save
argument_list|)
argument_list|,
literal|"zsave"
argument_list|)
expr_stmt|;
name|return_error
argument_list|(
name|e_VMerror
argument_list|)
expr_stmt|;
block|}
name|vmsave
operator|->
name|asave
operator|=
name|asave
expr_stmt|;
comment|/* Save the old interpreter state, */
comment|/* and cut the chains so we can't grestore past here. */
name|vmsave
operator|->
name|isave
operator|=
name|istate
expr_stmt|;
name|code
operator|=
name|zgsave
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|<
literal|0
condition|)
return|return
name|code
return|;
comment|/* Swap the contents of the old and new states, */
comment|/* so the new state points to the newly allocated components. */
name|prev
operator|=
name|gs_state_swap_saved
argument_list|(
name|igs
argument_list|,
operator|(
name|gs_state
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|prev2
operator|=
name|gs_state_swap_saved
argument_list|(
name|prev
argument_list|,
operator|(
name|gs_state
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|gs_state_swap_saved
argument_list|(
name|igs
argument_list|,
name|prev2
argument_list|)
expr_stmt|;
name|gs_state_swap
argument_list|(
name|igs
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|vmsave
operator|->
name|gsave
operator|=
name|igs
expr_stmt|;
name|igs
operator|=
name|prev
expr_stmt|;
name|istate
operator|.
name|saved
operator|=
literal|0
expr_stmt|;
name|push
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|make_tv
argument_list|(
name|op
argument_list|,
name|t_save
argument_list|,
name|psave
argument_list|,
name|vmsave
argument_list|)
expr_stmt|;
name|init_identity_matrix
argument_list|()
expr_stmt|;
comment|/* update l_new attribute */
return|return
name|zgsave
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* restore */
end_comment

begin_decl_stmt
name|private
name|int
name|restore_check_stack
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|ref
operator|*
argument_list|,
name|alloc_save
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|restore_fix_stack
argument_list|(
name|P3
argument_list|(
name|ref
operator|*
argument_list|,
name|ref
operator|*
argument_list|,
name|alloc_save
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zrestore
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|vm_save
modifier|*
name|vmsave
decl_stmt|;
name|alloc_save
modifier|*
name|asave
decl_stmt|;
name|check_type
argument_list|(
operator|*
name|op
argument_list|,
name|t_save
argument_list|)
expr_stmt|;
name|vmsave
operator|=
name|op
operator|->
name|value
operator|.
name|psave
expr_stmt|;
if|if
condition|(
name|vmsave
operator|==
literal|0
condition|)
comment|/* invalidated save */
name|return_error
argument_list|(
name|e_invalidrestore
argument_list|)
expr_stmt|;
name|asave
operator|=
name|vmsave
operator|->
name|asave
expr_stmt|;
comment|/* Check the contents of the stacks. */
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|restore_check_stack
argument_list|(
name|osbot
argument_list|,
name|op
argument_list|,
name|asave
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|restore_check_stack
argument_list|(
name|esbot
argument_list|,
name|esp
operator|+
literal|1
argument_list|,
name|asave
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|code
operator|=
name|restore_check_stack
argument_list|(
name|dstack
argument_list|,
name|dsp
operator|+
literal|1
argument_list|,
name|asave
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|code
return|;
block|}
if|if
condition|(
name|alloc_restore_state_check
argument_list|(
name|asave
argument_list|)
operator|<
literal|0
condition|)
name|return_error
argument_list|(
name|e_invalidrestore
argument_list|)
expr_stmt|;
comment|/* Invalidate any other copies of this save object on the stacks, */
comment|/* and reset l_new in all stack entries if the new restore level */
comment|/* is zero. */
name|restore_fix_stack
argument_list|(
name|osbot
argument_list|,
name|op
argument_list|,
name|asave
argument_list|)
expr_stmt|;
name|restore_fix_stack
argument_list|(
name|esbot
argument_list|,
name|esp
operator|+
literal|1
argument_list|,
name|asave
argument_list|)
expr_stmt|;
name|restore_fix_stack
argument_list|(
name|dstack
argument_list|,
name|dsp
operator|+
literal|1
argument_list|,
name|asave
argument_list|)
expr_stmt|;
comment|/* Now it's safe to restore the state of memory. */
name|alloc_restore_state
argument_list|(
name|asave
argument_list|)
expr_stmt|;
comment|/* Restore the interpreter and graphics state. */
name|istate
operator|=
name|vmsave
operator|->
name|isave
expr_stmt|;
name|igs
operator|=
name|vmsave
operator|->
name|gsave
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vmsave
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_save
argument_list|)
argument_list|,
literal|"zrestore"
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|init_identity_matrix
argument_list|()
expr_stmt|;
comment|/* update l_new attribute */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check a stack to make sure all its elements are older than a save. */
end_comment

begin_function
name|private
name|int
name|restore_check_stack
parameter_list|(
name|ref
modifier|*
name|bot
parameter_list|,
name|ref
modifier|*
name|top
parameter_list|,
name|alloc_save
modifier|*
name|asave
parameter_list|)
block|{
name|ref
modifier|*
name|stkp
decl_stmt|;
for|for
control|(
name|stkp
operator|=
name|bot
init|;
name|stkp
operator|<
name|top
condition|;
name|stkp
operator|++
control|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
switch|switch
condition|(
name|r_type
argument_list|(
name|stkp
argument_list|)
condition|)
block|{
case|case
name|t_array
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|refs
expr_stmt|;
break|break;
case|case
name|t_condition
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|pcond
expr_stmt|;
break|break;
case|case
name|t_dictionary
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|pdict
expr_stmt|;
break|break;
case|case
name|t_fontID
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|pfont
expr_stmt|;
break|break;
case|case
name|t_gstate
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|pgstate
expr_stmt|;
break|break;
comment|/* case t_file: ****** WHAT? ****** */
case|case
name|t_lock
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|plock
expr_stmt|;
break|break;
case|case
name|t_name
case|:
comment|/* Names are special because of how they are allocated. */
if|if
condition|(
name|alloc_name_is_since_save
argument_list|(
name|stkp
argument_list|,
name|asave
argument_list|)
condition|)
name|return_error
argument_list|(
name|e_invalidrestore
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|t_save
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|psave
expr_stmt|;
break|break;
case|case
name|t_string
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|bytes
expr_stmt|;
break|break;
case|case
name|t_mixedarray
case|:
case|case
name|t_shortarray
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|packed
expr_stmt|;
break|break;
case|case
name|t_color
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|pcolor
expr_stmt|;
break|break;
case|case
name|t_device
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|pdevice
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|alloc_is_since_save
argument_list|(
name|ptr
argument_list|,
name|asave
argument_list|)
condition|)
name|return_error
argument_list|(
name|e_invalidrestore
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* OK */
block|}
end_function

begin_comment
comment|/* Fix up the contents of a stack by invalidating */
end_comment

begin_comment
comment|/* any save objects newer than the save being restored, */
end_comment

begin_comment
comment|/* and, if the new save level is zero, clearing the l_new */
end_comment

begin_comment
comment|/* bit in all the entries (since we can't tolerate values with */
end_comment

begin_comment
comment|/* l_new set if the save level is zero). */
end_comment

begin_function
name|private
name|void
name|restore_fix_stack
parameter_list|(
name|ref
modifier|*
name|bot
parameter_list|,
name|ref
modifier|*
name|top
parameter_list|,
name|alloc_save
modifier|*
name|asave
parameter_list|)
block|{
name|ref
modifier|*
name|stkp
decl_stmt|;
for|for
control|(
name|stkp
operator|=
name|bot
init|;
name|stkp
operator|<
name|top
condition|;
name|stkp
operator|++
control|)
block|{
if|if
condition|(
name|r_type
argument_list|(
name|stkp
argument_list|)
operator|==
name|t_save
operator|&&
name|stkp
operator|->
name|value
operator|.
name|psave
operator|!=
literal|0
operator|&&
operator|(
name|stkp
operator|->
name|value
operator|.
name|psave
operator|->
name|asave
operator|==
name|asave
operator|||
name|alloc_is_since_save
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stkp
operator|->
name|value
operator|.
name|psave
argument_list|,
name|asave
argument_list|)
operator|)
condition|)
name|stkp
operator|->
name|value
operator|.
name|psave
operator|=
literal|0
expr_stmt|;
name|r_clear_attrs
argument_list|(
name|stkp
argument_list|,
name|l_new
argument_list|)
expr_stmt|;
comment|/* always do it, no harm */
block|}
block|}
end_function

begin_comment
comment|/* vmstatus */
end_comment

begin_function
name|int
name|zvmstatus
parameter_list|(
specifier|register
name|os_ptr
name|op
parameter_list|)
block|{
name|long
name|used
decl_stmt|,
name|total
decl_stmt|;
name|alloc_status
argument_list|(
operator|&
name|used
argument_list|,
operator|&
name|total
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
operator|-
literal|2
argument_list|,
name|alloc_save_level
argument_list|()
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
operator|-
literal|1
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|make_int
argument_list|(
name|op
argument_list|,
name|total
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ------ Initialization procedure ------ */
end_comment

begin_decl_stmt
name|op_def
name|zvmem_op_defs
index|[]
init|=
block|{
block|{
literal|"1restore"
block|,
name|zrestore
block|}
block|,
block|{
literal|"0save"
block|,
name|zsave
block|}
block|,
block|{
literal|"0vmstatus"
block|,
name|zvmstatus
block|}
block|,
name|op_def_end
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

end_unit

