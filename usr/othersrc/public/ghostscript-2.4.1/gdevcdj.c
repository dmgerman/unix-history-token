begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1991, 1992 Aladdin Enterprises.  All rights reserved.  * Distributed by Free Software Foundation, Inc.  *   * This file is part of Ghostscript.  *   * Ghostscript is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY.  No author or distributor accepts responsibility to anyone  * for the consequences of using it or for whether it serves any particular  * purpose or works at all, unless he says so in writing.  Refer to the  * Ghostscript General Public License for full details.  *   * Everyone is granted permission to copy, modify and redistribute Ghostscript,  * but only under the conditions described in the Ghostscript General Public  * License.  A copy of this license is supposed to have been given to you  * along with Ghostscript so you can know your rights and responsibilities.  * It should be in a file named COPYING.  Among other things, the copyright  * notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* gdevcdj.c */
end_comment

begin_comment
comment|/* H-P DeskJet 500C driver (colour) for Ghostscript */
end_comment

begin_include
include|#
directive|include
file|"gdevprn.h"
end_include

begin_include
include|#
directive|include
file|"gdevpcl.h"
end_include

begin_comment
comment|/***  *** Note: this driver was contributed by a user, George Cameron:  ***       please contact g.cameron@aberdeen.ac.uk if you have questions.  ***/
end_comment

begin_comment
comment|/*  *   Definitions affecting print quality/speed  */
end_comment

begin_comment
comment|/* #define A4               * .. if in Europe */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHINGLING
end_ifndef

begin_comment
comment|/* Interlaced, multi-pass printing */
end_comment

begin_define
define|#
directive|define
name|SHINGLING
value|1
end_define

begin_comment
comment|/* 0 = none, 1 = 50%, 2 = 25%, 2 is best& slowest */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEPLETION
end_ifndef

begin_comment
comment|/* 'Intelligent' dot-removal */
end_comment

begin_define
define|#
directive|define
name|DEPLETION
value|1
end_define

begin_comment
comment|/* 0 = none, 1 = 25%, 2 = 50%, 1 best for graphics? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use 0 for transparencies */
end_comment

begin_comment
comment|/*  * You may select a resolution of 75, 100, 150, or 300 DPI.  * Normally you would do this in the makefile or on the gs command line,  * not here.  */
end_comment

begin_define
define|#
directive|define
name|X_DPI_MAX
value|300
end_define

begin_define
define|#
directive|define
name|Y_DPI_MAX
value|300
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|X_DPI
end_ifndef

begin_define
define|#
directive|define
name|X_DPI
value|X_DPI_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Y_DPI
end_ifndef

begin_define
define|#
directive|define
name|Y_DPI
value|Y_DPI_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We round up LINE_SIZE to a multiple of 8 bytes */
end_comment

begin_comment
comment|/* because that's the unit of transposition from pixels to planes. */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE
value|((X_DPI_MAX * 85 / 10 + 63) / 64 * 8)
end_define

begin_comment
comment|/* For all DeskJet Printers:  *  *  Maximum printing width               = 2400 dots = 8"  *  Maximum printing height (colour)     = 3100 dots = 10.3"  *                          (monochrome) = 3150 dots = 10.5"  *  All Deskjets have 1/2" unprintable bottom margin  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|A4
end_ifndef

begin_define
define|#
directive|define
name|PAPER_SIZE
value|2
end_define

begin_comment
comment|/* US Letter is default size */
end_comment

begin_define
define|#
directive|define
name|WIDTH_10THS
value|85
end_define

begin_define
define|#
directive|define
name|HEIGHT_10THS
value|110
end_define

begin_define
define|#
directive|define
name|L_MARGIN
value|0.25
end_define

begin_define
define|#
directive|define
name|B_MARGIN
value|0.5
end_define

begin_define
define|#
directive|define
name|R_MARGIN
value|0.25
end_define

begin_define
define|#
directive|define
name|T_MARGIN
value|0.2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PAPER_SIZE
value|26
end_define

begin_comment
comment|/* A4 size normal in Europe */
end_comment

begin_define
define|#
directive|define
name|WIDTH_10THS
value|83
end_define

begin_comment
comment|/* 210mm */
end_comment

begin_define
define|#
directive|define
name|HEIGHT_10THS
value|117
end_define

begin_comment
comment|/* 297mm */
end_comment

begin_define
define|#
directive|define
name|L_MARGIN
value|0.134
end_define

begin_define
define|#
directive|define
name|B_MARGIN
value|0.7
end_define

begin_define
define|#
directive|define
name|R_MARGIN
value|0.134
end_define

begin_define
define|#
directive|define
name|T_MARGIN
value|0.66
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The device descriptor */
end_comment

begin_function_decl
name|private
name|dev_proc_print_page
parameter_list|(
name|cdeskjet_print_page
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|gx_device_procs
name|cdeskjet_procs
init|=
name|prn_color_procs
argument_list|(
name|gdev_prn_open
argument_list|,
name|gdev_prn_output_page
argument_list|,
name|gdev_prn_close
argument_list|,
name|gdev_pcl_3bit_map_rgb_color
argument_list|,
name|gdev_pcl_3bit_map_color_rgb
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gx_device_printer
name|gs_cdeskjet_device
init|=
name|prn_device
argument_list|(
name|cdeskjet_procs
argument_list|,
literal|"cdeskjet"
argument_list|,
name|WIDTH_10THS
argument_list|,
name|HEIGHT_10THS
argument_list|,
name|X_DPI
argument_list|,
name|Y_DPI
argument_list|,
name|L_MARGIN
argument_list|,
name|R_MARGIN
argument_list|,
name|T_MARGIN
argument_list|,
name|B_MARGIN
argument_list|,
literal|3
argument_list|,
name|cdeskjet_print_page
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|gdev_pcl_mode9compress
argument_list|(
name|P4
argument_list|(
name|int
argument_list|,
specifier|const
name|byte
operator|*
argument_list|,
name|byte
operator|*
argument_list|,
name|byte
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------ Internal routines ------ */
end_comment

begin_comment
comment|/* Send the page to the printer.  Compress each scan line. */
end_comment

begin_function
name|private
name|int
name|cdeskjet_print_page
parameter_list|(
name|gx_device_printer
modifier|*
name|pdev
parameter_list|,
name|FILE
modifier|*
name|prn_stream
parameter_list|)
block|{
define|#
directive|define
name|DATA_SIZE
value|(LINE_SIZE * 8)
name|byte
name|data
index|[
name|DATA_SIZE
index|]
decl_stmt|;
name|byte
name|plane_data
index|[
literal|3
index|]
index|[
name|LINE_SIZE
index|]
decl_stmt|,
name|prev_plane_data
index|[
literal|3
index|]
index|[
name|LINE_SIZE
index|]
decl_stmt|;
name|int
name|x_dpi
init|=
name|pdev
operator|->
name|x_pixels_per_inch
decl_stmt|;
comment|/* Initialize printer. */
name|fputs
argument_list|(
literal|"\033E"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* reset printer */
comment|/* ends raster graphics to set raster graphics resolution */
name|fputs
argument_list|(
literal|"\033*rbC"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* set raster graphics resolution -- 75, 100, 150 or300 dpi */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*t%dR"
argument_list|,
name|x_dpi
argument_list|)
expr_stmt|;
comment|/* set the line width */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*r%dS"
argument_list|,
name|DATA_SIZE
argument_list|)
expr_stmt|;
comment|/* paper size, orientation, perf skip, feed from tray*/
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033&l%da0o0l1H"
argument_list|,
name|PAPER_SIZE
argument_list|)
expr_stmt|;
comment|/* set the number of color planes */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*r-%dU"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* always 3, -ve for CMY */
comment|/* set depletion level */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*o%dD"
argument_list|,
name|DEPLETION
argument_list|)
expr_stmt|;
comment|/* set shingling level */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*o%dQ"
argument_list|,
name|SHINGLING
argument_list|)
expr_stmt|;
comment|/* move to top left of page */
name|fputs
argument_list|(
literal|"\033&a0H\033&a0V"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* select data compression */
name|fputs
argument_list|(
literal|"\033*b9M"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* mode 9 */
comment|/* start raster graphics */
name|fputs
argument_list|(
literal|"\033*r1A"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|prev_plane_data
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|LINE_SIZE
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* Send each scan line in turn */
block|{
name|int
name|lnum
decl_stmt|;
name|int
name|line_size
init|=
name|gdev_prn_bytes_per_scan_line
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|int
name|line_count
init|=
name|line_size
operator|/
name|pdev
operator|->
name|color_info
operator|.
name|depth
decl_stmt|;
name|int
name|num_blank_lines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|lnum
operator|<
name|pdev
operator|->
name|height
condition|;
name|lnum
operator|++
control|)
block|{
name|byte
name|_ss
modifier|*
name|end_data
init|=
name|data
operator|+
name|line_size
decl_stmt|;
name|gdev_prn_copy_scan_lines
argument_list|(
name|pdev
argument_list|,
name|lnum
argument_list|,
operator|(
name|byte
operator|*
operator|)
name|data
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
comment|/* Remove trailing 0s. */
while|while
condition|(
name|end_data
operator|>
name|data
operator|&&
name|end_data
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|end_data
operator|--
expr_stmt|;
if|if
condition|(
name|end_data
operator|==
name|data
condition|)
block|{
comment|/* Blank line */
name|num_blank_lines
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|byte
name|_ss
modifier|*
name|odp
decl_stmt|;
comment|/* Pad with 0s to fill out the last */
comment|/* block of 8 bytes. */
name|memset
argument_list|(
name|end_data
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Transpose the data to get pixel planes. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|odp
operator|=
operator|&
name|plane_data
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
name|i
operator|<
name|DATA_SIZE
condition|;
name|i
operator|+=
literal|8
operator|,
name|odp
operator|++
control|)
block|{
comment|/* The following is for 16-bit machines */
define|#
directive|define
name|spread3
parameter_list|(
name|c
parameter_list|)
define|\
value|{ 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }
specifier|static
name|ulong
name|spr40
index|[
literal|8
index|]
init|=
name|spread3
argument_list|(
literal|0x40
argument_list|)
decl_stmt|;
specifier|static
name|ulong
name|spr8
index|[
literal|8
index|]
init|=
name|spread3
argument_list|(
literal|8
argument_list|)
decl_stmt|;
specifier|static
name|ulong
name|spr2
index|[
literal|8
index|]
init|=
name|spread3
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|register
name|byte
name|_ss
modifier|*
name|dp
init|=
name|data
operator|+
name|i
decl_stmt|;
specifier|register
name|ulong
name|pword
init|=
operator|(
name|spr40
index|[
name|dp
index|[
literal|0
index|]
index|]
operator|<<
literal|1
operator|)
operator|+
operator|(
name|spr40
index|[
name|dp
index|[
literal|1
index|]
index|]
operator|)
operator|+
operator|(
name|spr40
index|[
name|dp
index|[
literal|2
index|]
index|]
operator|>>
literal|1
operator|)
operator|+
operator|(
name|spr8
index|[
name|dp
index|[
literal|3
index|]
index|]
operator|<<
literal|1
operator|)
operator|+
operator|(
name|spr8
index|[
name|dp
index|[
literal|4
index|]
index|]
operator|)
operator|+
operator|(
name|spr8
index|[
name|dp
index|[
literal|5
index|]
index|]
operator|>>
literal|1
operator|)
operator|+
operator|(
name|spr2
index|[
name|dp
index|[
literal|6
index|]
index|]
operator|)
operator|+
operator|(
name|spr2
index|[
name|dp
index|[
literal|7
index|]
index|]
operator|>>
literal|1
operator|)
decl_stmt|;
name|odp
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pword
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|odp
index|[
name|LINE_SIZE
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pword
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|odp
index|[
name|LINE_SIZE
operator|*
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|pword
argument_list|)
expr_stmt|;
block|}
comment|/* Skip blank lines if any */
if|if
condition|(
name|num_blank_lines
operator|>
literal|0
condition|)
block|{
comment|/* move down from current 						 * position */
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033&a+%dV"
argument_list|,
name|num_blank_lines
operator|*
operator|(
literal|720
operator|/
name|Y_DPI
operator|)
argument_list|)
expr_stmt|;
name|num_blank_lines
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|prev_plane_data
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|LINE_SIZE
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Transfer raster graphics */
comment|/* in the order C, M, Y. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|temp
index|[
name|LINE_SIZE
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|count
init|=
name|gdev_pcl_mode9compress
argument_list|(
name|line_count
argument_list|,
name|plane_data
index|[
literal|2
operator|-
name|i
index|]
argument_list|,
name|prev_plane_data
index|[
literal|2
operator|-
name|i
index|]
argument_list|,
name|temp
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|prn_stream
argument_list|,
literal|"\033*b%d%c"
argument_list|,
name|count
argument_list|,
literal|"VVW"
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|byte
argument_list|)
argument_list|,
name|count
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end raster graphics */
name|fputs
argument_list|(
literal|"\033*rbC"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* reset to monochrome */
name|fputs
argument_list|(
literal|"\033*r1U"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
comment|/* eject page */
name|fputs
argument_list|(
literal|"\033&l0H"
argument_list|,
name|prn_stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|gdev_pcl_mode9compress
parameter_list|(
name|int
name|bytecount
parameter_list|,
specifier|const
name|byte
modifier|*
name|current
parameter_list|,
name|byte
modifier|*
name|previous
parameter_list|,
name|byte
modifier|*
name|compressed
parameter_list|)
block|{
specifier|register
specifier|const
name|byte
modifier|*
name|cur
init|=
name|current
decl_stmt|;
specifier|register
name|byte
modifier|*
name|prev
init|=
name|previous
decl_stmt|;
specifier|register
name|byte
modifier|*
name|out
init|=
name|compressed
decl_stmt|;
specifier|const
name|byte
modifier|*
name|end
init|=
name|current
operator|+
name|bytecount
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|end
condition|)
block|{
comment|/* Detect a run of unchanged bytes. */
specifier|const
name|byte
modifier|*
name|run
init|=
name|cur
decl_stmt|;
specifier|register
specifier|const
name|byte
modifier|*
name|diff
decl_stmt|;
name|int
name|offset
decl_stmt|;
while|while
condition|(
name|cur
operator|<
name|end
operator|&&
operator|*
name|cur
operator|==
operator|*
name|prev
condition|)
block|{
name|cur
operator|++
operator|,
name|prev
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|==
name|end
condition|)
break|break;
comment|/* rest of row is unchanged */
comment|/* Detect a run of changed bytes. */
comment|/* We know that *cur != *prev. */
name|diff
operator|=
name|cur
expr_stmt|;
do|do
block|{
operator|*
name|prev
operator|++
operator|=
operator|*
name|cur
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|cur
operator|<
name|end
operator|&&
operator|*
name|cur
operator|!=
operator|*
name|prev
condition|)
do|;
comment|/* Now [run..diff) are unchanged, and */
comment|/* [diff..cur) are changed. */
name|offset
operator|=
name|diff
operator|-
name|run
expr_stmt|;
block|{
specifier|const
name|byte
modifier|*
name|stop_test
init|=
name|cur
operator|-
literal|4
decl_stmt|;
name|int
name|dissimilar
decl_stmt|,
name|similar
decl_stmt|;
while|while
condition|(
name|diff
operator|<
name|cur
condition|)
block|{
specifier|const
name|byte
modifier|*
name|compr
init|=
name|diff
decl_stmt|;
specifier|const
name|byte
modifier|*
name|next
decl_stmt|;
comment|/* end of run */
name|byte
name|value
decl_stmt|;
while|while
condition|(
name|diff
operator|<=
name|stop_test
operator|&&
operator|(
operator|(
name|value
operator|=
operator|*
name|diff
operator|)
operator|!=
name|diff
index|[
literal|1
index|]
operator|||
name|value
operator|!=
name|diff
index|[
literal|2
index|]
operator|||
name|value
operator|!=
name|diff
index|[
literal|3
index|]
operator|)
condition|)
name|diff
operator|++
expr_stmt|;
comment|/* Find out how long the run is */
if|if
condition|(
name|diff
operator|>
name|stop_test
condition|)
comment|/* no run */
name|next
operator|=
name|diff
operator|=
name|cur
expr_stmt|;
else|else
block|{
name|next
operator|=
name|diff
operator|+
literal|4
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|cur
operator|&&
operator|*
name|next
operator|==
name|value
condition|)
name|next
operator|++
expr_stmt|;
block|}
define|#
directive|define
name|MAXOFFSETU
value|15
define|#
directive|define
name|MAXCOUNTU
value|7
comment|/* output 'dissimilar' bytes, uncompressed */
if|if
condition|(
operator|(
name|dissimilar
operator|=
name|diff
operator|-
name|compr
operator|)
condition|)
block|{
name|int
name|temp
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
operator|--
name|dissimilar
operator|)
operator|>
name|MAXCOUNTU
condition|)
name|temp
operator|=
name|MAXCOUNTU
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|MAXOFFSETU
condition|)
operator|*
name|out
operator|++
operator|=
operator|(
name|offset
operator|<<
literal|3
operator|)
operator||
operator|(
name|byte
operator|)
name|temp
expr_stmt|;
else|else
block|{
operator|*
name|out
operator|++
operator|=
operator|(
name|MAXOFFSETU
operator|<<
literal|3
operator|)
operator||
operator|(
name|byte
operator|)
name|temp
expr_stmt|;
name|offset
operator|-=
name|MAXOFFSETU
expr_stmt|;
while|while
condition|(
name|offset
operator|>=
literal|255
condition|)
block|{
operator|*
name|out
operator|++
operator|=
literal|255
expr_stmt|;
name|offset
operator|-=
literal|255
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|MAXCOUNTU
condition|)
block|{
name|temp
operator|=
name|dissimilar
operator|-
name|MAXCOUNTU
expr_stmt|;
while|while
condition|(
name|temp
operator|>=
literal|255
condition|)
block|{
operator|*
name|out
operator|++
operator|=
literal|255
expr_stmt|;
name|temp
operator|-=
literal|255
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
operator|(
name|byte
operator|)
name|temp
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dissimilar
condition|;
name|i
operator|++
control|)
operator|*
name|out
operator|++
operator|=
operator|*
name|compr
operator|++
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end uncompressed */
define|#
directive|define
name|MAXOFFSETC
value|3
define|#
directive|define
name|MAXCOUNTC
value|31
comment|/* output 'similar' bytes, run-length endcoded */
if|if
condition|(
operator|(
name|similar
operator|=
name|next
operator|-
name|diff
operator|)
condition|)
block|{
name|int
name|temp
decl_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
operator|(
name|similar
operator|-=
literal|2
operator|)
operator|)
operator|>
name|MAXCOUNTC
condition|)
name|temp
operator|=
name|MAXCOUNTC
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|MAXOFFSETC
condition|)
operator|*
name|out
operator|++
operator|=
literal|0x80
operator||
operator|(
name|offset
operator|<<
literal|5
operator|)
operator||
operator|(
name|byte
operator|)
name|temp
expr_stmt|;
else|else
block|{
operator|*
name|out
operator|++
operator|=
literal|0x80
operator||
operator|(
name|MAXOFFSETC
operator|<<
literal|5
operator|)
operator||
operator|(
name|byte
operator|)
name|temp
expr_stmt|;
name|offset
operator|-=
name|MAXOFFSETC
expr_stmt|;
while|while
condition|(
name|offset
operator|>=
literal|255
condition|)
block|{
operator|*
name|out
operator|++
operator|=
literal|255
expr_stmt|;
name|offset
operator|-=
literal|255
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|MAXCOUNTC
condition|)
block|{
name|temp
operator|=
name|similar
operator|-
name|MAXCOUNTC
expr_stmt|;
while|while
condition|(
name|temp
operator|>=
literal|255
condition|)
block|{
operator|*
name|out
operator|++
operator|=
literal|255
expr_stmt|;
name|temp
operator|-=
literal|255
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
operator|(
name|byte
operator|)
name|temp
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
name|value
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end compressed */
name|diff
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
return|return
name|out
operator|-
name|compressed
return|;
block|}
end_function

end_unit

