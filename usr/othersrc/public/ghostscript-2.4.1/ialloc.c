begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1992 Aladdin Enterprises.  All rights reserved.    Distributed by Free Software Foundation, Inc.  This file is part of Ghostscript.  Ghostscript is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the Ghostscript General Public License for full details.  Everyone is granted permission to copy, modify and redistribute Ghostscript, but only under the conditions described in the Ghostscript General Public License.  A copy of this license is supposed to have been given to you along with Ghostscript so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* ialloc.c */
end_comment

begin_comment
comment|/* Memory allocator for Ghostscript interpreter */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* for NULL */
end_comment

begin_include
include|#
directive|include
file|"gs.h"
end_include

begin_include
include|#
directive|include
file|"memory_.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_include
include|#
directive|include
file|"astate.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|gs_debug
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward references */
end_comment

begin_decl_stmt
name|private
name|int
name|alloc_add_chunk
argument_list|(
name|P2
argument_list|(
name|alloc_state_ptr
argument_list|,
name|uint
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|alloc_large
argument_list|(
name|P3
argument_list|(
name|alloc_state_ptr
argument_list|,
name|uint
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|alloc_free_large
argument_list|(
name|P3
argument_list|(
name|char
operator|*
argument_list|,
name|uint
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The only allocator instance (for now). */
end_comment

begin_decl_stmt
name|private
name|alloc_state
name|as_current
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|alloc_state_ptr
name|alloc_state_current
init|=
operator|&
name|as_current
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debugging printout */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|alloc_print
parameter_list|(
name|rtag
parameter_list|,
name|tag
parameter_list|,
name|blk
parameter_list|,
name|sz
parameter_list|)
define|\
value|if ( gs_debug['A'] )\ 	  fprintf(gs_debug_out, "[a:%c:%c:%s] %lx(%u)\n", rtag, tag,\ 		  client_name, (ulong)blk, sz)
end_define

begin_define
define|#
directive|define
name|alloc_print_large
parameter_list|(
name|rtag
parameter_list|,
name|tag
parameter_list|,
name|blk
parameter_list|,
name|sz
parameter_list|)
define|\
value|if ( gs_debug['A'] | gs_debug['a'] )\ 	  fprintf(gs_debug_out, "[a:%c:%c:%s] %lx(%u)\n", rtag, tag,\ 		  client_name, (ulong)blk, sz)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|alloc_print
parameter_list|(
name|rtag
parameter_list|,
name|tag
parameter_list|,
name|blk
parameter_list|,
name|sz
parameter_list|)
end_define

begin_define
define|#
directive|define
name|alloc_print_large
parameter_list|(
name|rtag
parameter_list|,
name|tag
parameter_list|,
name|blk
parameter_list|,
name|sz
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------ Initialize/status ------ */
end_comment

begin_comment
comment|/* Initialize the allocator */
end_comment

begin_function
name|void
name|alloc_init
parameter_list|(
name|proc_alloc_t
name|palloc
parameter_list|,
name|proc_free_t
name|pfree
parameter_list|,
name|uint
name|chunk_size
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
operator|&
name|as_current
decl_stmt|;
name|memset
argument_list|(
name|ap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|alloc_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do it all at once */
name|ap
operator|->
name|chunk_size
operator|=
name|chunk_size
expr_stmt|;
name|ap
operator|->
name|big_size
operator|=
name|chunk_size
operator|/
literal|4
expr_stmt|;
name|ap
operator|->
name|palloc
operator|=
name|palloc
expr_stmt|;
name|ap
operator|->
name|pfree
operator|=
name|pfree
expr_stmt|;
name|ap
operator|->
name|last_freed
operator|=
literal|0
expr_stmt|;
block|{
specifier|extern
name|void
name|alloc_save_init
argument_list|(
name|P0
argument_list|()
argument_list|)
decl_stmt|;
name|alloc_save_init
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the status of the allocator: space used, total space. */
end_comment

begin_function
name|void
name|alloc_status
parameter_list|(
name|long
modifier|*
name|pused
parameter_list|,
name|long
modifier|*
name|ptotal
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
operator|&
name|as_current
decl_stmt|;
operator|*
name|pused
operator|=
operator|(
name|ap
operator|->
name|cbot
operator|-
name|ap
operator|->
name|cbase
operator|)
operator|+
operator|(
name|ap
operator|->
name|climit
operator|-
name|ap
operator|->
name|ctop
operator|)
operator|+
name|ap
operator|->
name|used
expr_stmt|;
operator|*
name|ptotal
operator|=
name|ap
operator|->
name|total
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------ Allocation and freeing ------ */
end_comment

begin_comment
comment|/* Allocate an object.  Return 0 if not enough room. */
end_comment

begin_function
name|char
modifier|*
name|alloc
parameter_list|(
name|uint
name|num_elts
parameter_list|,
name|uint
name|elt_size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
operator|&
name|as_current
decl_stmt|;
name|uint
name|size
init|=
name|num_elts
operator|*
name|elt_size
decl_stmt|;
name|uint
name|block_size
decl_stmt|;
name|uint
name|left
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|ap
operator|->
name|big_size
condition|)
block|{
comment|/* Large object, do a separate malloc. */
name|char
modifier|*
name|block
init|=
name|alloc_large
argument_list|(
name|ap
argument_list|,
name|size
argument_list|,
name|client_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|!=
name|NULL
condition|)
return|return
name|block
return|;
if|if
condition|(
name|size
operator|>
name|ap
operator|->
name|chunk_size
condition|)
return|return
literal|0
return|;
comment|/* can't alloc */
block|}
name|block_size
operator|=
name|align_round
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_size
operator|<=
name|max_chain_size
condition|)
block|{
comment|/* See if we can use a freed block. */
name|char
modifier|*
modifier|*
name|fptr
init|=
operator|&
name|ap
operator|->
name|free
index|[
name|block_size
operator|>>
name|log2_align_mod
index|]
decl_stmt|;
name|char
modifier|*
name|block
init|=
operator|*
name|fptr
decl_stmt|;
if|if
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
operator|*
name|fptr
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|block
expr_stmt|;
name|alloc_print
argument_list|(
literal|'+'
argument_list|,
literal|'#'
argument_list|,
name|block
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
block|}
name|left
operator|=
name|ap
operator|->
name|ctop
operator|-
name|ap
operator|->
name|cbot
expr_stmt|;
if|if
condition|(
name|block_size
operator|>
name|left
condition|)
block|{
name|uint
name|csize
init|=
name|ap
operator|->
name|chunk_size
decl_stmt|;
while|while
condition|(
operator|!
name|alloc_add_chunk
argument_list|(
name|ap
argument_list|,
name|csize
argument_list|)
condition|)
block|{
name|alloc_print
argument_list|(
literal|'+'
argument_list|,
literal|'?'
argument_list|,
operator|(
name|ulong
operator|)
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Things are desperate, but perhaps not hopeless. */
if|if
condition|(
operator|(
name|csize
operator|>>=
literal|1
operator|)
operator|<
name|block_size
condition|)
return|return
literal|0
return|;
comment|/* no hope */
block|}
block|}
if|if
condition|(
name|elt_size
operator|==
literal|1
condition|)
block|{
comment|/* Unaligned block */
name|ap
operator|->
name|ctop
operator|-=
name|size
expr_stmt|;
name|alloc_print
argument_list|(
literal|'+'
argument_list|,
literal|'>'
argument_list|,
name|ap
operator|->
name|ctop
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|ctop
return|;
block|}
else|else
block|{
comment|/* Aligned block */
name|char
modifier|*
name|block
init|=
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|cbot
decl_stmt|;
name|ap
operator|->
name|cbot
operator|+=
name|block_size
expr_stmt|;
name|alloc_print
argument_list|(
literal|'+'
argument_list|,
literal|'<'
argument_list|,
name|block
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
block|}
end_function

begin_comment
comment|/* Free an object, if possible. */
end_comment

begin_comment
comment|/* Note that if a save is in effect, objects in chunks older than */
end_comment

begin_comment
comment|/* the save, and objects allocated with malloc before the save, */
end_comment

begin_comment
comment|/* must not be freed. */
end_comment

begin_function
name|void
name|alloc_free
parameter_list|(
name|char
modifier|*
name|cobj
parameter_list|,
name|uint
name|num_elts
parameter_list|,
name|uint
name|elt_size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
operator|&
name|as_current
decl_stmt|;
name|uint
name|size
init|=
name|num_elts
operator|*
name|elt_size
decl_stmt|;
name|uint
name|block_size
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|ap
operator|->
name|big_size
condition|)
block|{
comment|/* Object was allocated with malloc. */
name|alloc_free_large
argument_list|(
name|cobj
argument_list|,
name|size
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|obj
value|((byte *)cobj)
elseif|else
if|if
condition|(
name|obj
operator|==
name|ap
operator|->
name|ctop
condition|)
block|{
comment|/* Don't free the object if we're in a save and */
comment|/* this object wasn't allocated since the save. */
if|if
condition|(
name|ap
operator|->
name|save_level
operator|==
literal|0
operator|||
name|ap
operator|->
name|current
operator|.
name|save_level
operator|>=
name|ap
operator|->
name|save_level
operator|||
comment|/* We know the current chunk is the same as */
comment|/* the one in as->saved->state */
name|obj
operator|<
name|ap
operator|->
name|saved_ctop
condition|)
name|ap
operator|->
name|ctop
operator|+=
name|size
expr_stmt|;
name|alloc_print
argument_list|(
literal|'-'
argument_list|,
literal|'>'
argument_list|,
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|obj
operator|+
operator|(
name|block_size
operator|=
name|align_round
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|ap
operator|->
name|cbot
condition|)
block|{
comment|/* Freeing an aligned object.  Same check. */
if|if
condition|(
name|ap
operator|->
name|save_level
operator|==
literal|0
operator|||
name|ap
operator|->
name|current
operator|.
name|save_level
operator|>=
name|ap
operator|->
name|save_level
operator|||
name|obj
operator|>=
name|ap
operator|->
name|saved_cbot
condition|)
name|ap
operator|->
name|cbot
operator|=
name|obj
expr_stmt|;
name|alloc_print
argument_list|(
literal|'-'
argument_list|,
literal|'<'
argument_list|,
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|ptr_is_in_chunk
argument_list|(
name|obj
argument_list|,
operator|&
name|ap
operator|->
name|current
argument_list|)
condition|)
block|{
comment|/* In another segment, check its save level. */
name|int
name|level
init|=
name|ap
operator|->
name|save_level
decl_stmt|;
name|alloc_chunk
modifier|*
name|cp
init|=
name|ap
operator|->
name|last_freed
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|0
operator|&&
name|ptr_is_in_chunk
argument_list|(
name|obj
argument_list|,
name|cp
argument_list|)
condition|)
comment|/* cache hit */
block|{
if|if ptr_lt
condition|(
name|obj
operator|,
name|cp
operator|->
name|bot
condition|)
goto|goto
name|pxf
goto|;
else|else
goto|goto
name|pnf
goto|;
block|}
for|for
control|(
name|cp
operator|=
name|ap
operator|->
name|current
operator|.
name|next
init|;
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|cp
operator|->
name|save_level
operator|-
name|level
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ptr_is_in_chunk
argument_list|(
name|obj
argument_list|,
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr_lt
argument_list|(
name|obj
argument_list|,
name|cp
operator|->
name|bot
argument_list|)
condition|)
goto|goto
name|pbf
goto|;
else|else
goto|goto
name|pnf
goto|;
block|}
else|else
continue|continue;
case|case
operator|-
literal|1
case|:
comment|/* Might be alloc'ed since the save, */
comment|/* or might not be aligned. */
if|if
condition|(
name|ptr_lt
argument_list|(
name|obj
argument_list|,
name|ap
operator|->
name|saved_cbot
argument_list|)
condition|)
goto|goto
name|pbf
goto|;
block|}
block|}
name|pnf
label|:
comment|/* Older save level or unaligned, not freeable. */
name|alloc_print
argument_list|(
literal|'-'
argument_list|,
literal|'\\'
argument_list|,
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
name|pbf
label|:
comment|/* If we get here, OK to put the block on a free list. */
name|ap
operator|->
name|last_freed
operator|=
name|cp
expr_stmt|;
name|pxf
label|:
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|>=
name|ap
operator|->
name|cbot
condition|)
comment|/* not aligned object, punt */
block|{
name|alloc_print
argument_list|(
literal|'-'
argument_list|,
literal|'~'
argument_list|,
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Put on a free list if small enough */
name|alloc_print
argument_list|(
literal|'-'
argument_list|,
literal|'#'
argument_list|,
name|obj
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_size
operator|<=
name|max_chain_size
operator|&&
name|block_size
operator|>=
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|fptr
init|=
operator|&
name|ap
operator|->
name|free
index|[
name|block_size
operator|>>
name|log2_align_mod
index|]
decl_stmt|;
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|cobj
operator|=
operator|*
name|fptr
expr_stmt|;
operator|*
name|fptr
operator|=
name|cobj
expr_stmt|;
block|}
undef|#
directive|undef
name|obj
block|}
end_function

begin_comment
comment|/* Grow an object.  This may require allocating a new copy. */
end_comment

begin_comment
comment|/* Return 0 if not enough room. */
end_comment

begin_comment
comment|/****** Note: the object must have been allocated at  ****** the current save level. */
end_comment

begin_function
name|byte
modifier|*
name|alloc_grow
parameter_list|(
name|byte
modifier|*
name|obj
parameter_list|,
name|uint
name|old_num
parameter_list|,
name|uint
name|new_num
parameter_list|,
name|uint
name|elt_size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
operator|&
name|as_current
decl_stmt|;
name|uint
name|old_size
init|=
name|old_num
operator|*
name|elt_size
decl_stmt|;
name|uint
name|new_size
init|=
name|new_num
operator|*
name|elt_size
decl_stmt|;
name|byte
modifier|*
name|nobj
decl_stmt|;
if|if
condition|(
name|new_size
operator|==
name|old_size
condition|)
return|return
name|obj
return|;
if|if
condition|(
name|new_size
operator|<
name|ap
operator|->
name|big_size
condition|)
comment|/* try to grow in place */
block|{
name|uint
name|old_block_size
decl_stmt|;
name|uint
name|new_block_size
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|ap
operator|->
name|ctop
condition|)
block|{
comment|/* Might be able to grow in place */
name|uint
name|diff
init|=
name|new_size
operator|-
name|old_size
decl_stmt|;
if|if
condition|(
name|diff
operator|<=
name|ap
operator|->
name|ctop
operator|-
name|ap
operator|->
name|cbot
condition|)
block|{
name|alloc_print
argument_list|(
literal|'>'
argument_list|,
literal|'>'
argument_list|,
name|obj
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|ap
operator|->
name|ctop
operator|-=
name|diff
expr_stmt|;
name|memcpy
argument_list|(
name|ap
operator|->
name|ctop
argument_list|,
name|obj
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
return|return
name|ap
operator|->
name|ctop
return|;
block|}
block|}
name|old_block_size
operator|=
name|align_round
argument_list|(
name|old_size
argument_list|)
expr_stmt|;
name|new_block_size
operator|=
name|align_round
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|+
name|old_block_size
operator|==
name|ap
operator|->
name|cbot
condition|)
block|{
comment|/* Might be able to grow in place */
name|uint
name|diff
init|=
name|new_block_size
operator|-
name|old_block_size
decl_stmt|;
if|if
condition|(
name|diff
operator|<=
name|ap
operator|->
name|ctop
operator|-
name|ap
operator|->
name|cbot
condition|)
block|{
name|alloc_print
argument_list|(
literal|'>'
argument_list|,
literal|'<'
argument_list|,
name|obj
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|ap
operator|->
name|cbot
operator|+=
name|diff
expr_stmt|;
return|return
name|obj
return|;
block|}
block|}
block|}
comment|/* Can't grow in place.  Allocate a new object and copy. */
name|nobj
operator|=
operator|(
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|new_num
argument_list|,
name|elt_size
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nobj
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|nobj
argument_list|,
name|obj
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|obj
argument_list|,
name|old_num
argument_list|,
name|elt_size
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|alloc_print
argument_list|(
literal|'>'
argument_list|,
literal|'&'
argument_list|,
name|obj
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
return|return
name|nobj
return|;
block|}
end_function

begin_comment
comment|/* Shrink an object. */
end_comment

begin_comment
comment|/****** Note: the object must have been allocated at  ****** the current save level. */
end_comment

begin_function
name|byte
modifier|*
name|alloc_shrink
parameter_list|(
name|byte
modifier|*
name|obj
parameter_list|,
name|uint
name|old_num
parameter_list|,
name|uint
name|new_num
parameter_list|,
name|uint
name|elt_size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
specifier|register
name|alloc_state_ptr
name|ap
init|=
operator|&
name|as_current
decl_stmt|;
name|uint
name|old_size
init|=
name|old_num
operator|*
name|elt_size
decl_stmt|;
name|uint
name|new_size
init|=
name|new_num
operator|*
name|elt_size
decl_stmt|;
if|if
condition|(
name|new_size
operator|==
name|old_size
condition|)
return|return
name|obj
return|;
if|if
condition|(
name|old_size
operator|>=
name|ap
operator|->
name|big_size
condition|)
block|{
comment|/* Allocate a new block. */
name|byte
modifier|*
name|nobj
init|=
operator|(
name|byte
operator|*
operator|)
name|alloc
argument_list|(
name|new_num
argument_list|,
name|elt_size
argument_list|,
name|client_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nobj
operator|==
literal|0
condition|)
return|return
name|obj
return|;
comment|/* can't shrink, leave as is */
name|memcpy
argument_list|(
name|nobj
argument_list|,
name|obj
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|obj
argument_list|,
name|old_num
argument_list|,
name|elt_size
argument_list|,
name|client_name
argument_list|)
expr_stmt|;
name|alloc_print
argument_list|(
literal|'<'
argument_list|,
literal|'&'
argument_list|,
name|obj
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
return|return
name|nobj
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|==
name|ap
operator|->
name|ctop
condition|)
block|{
comment|/* Move the object up in place. */
comment|/* memcpy doesn't do this properly. */
specifier|register
name|byte
modifier|*
name|from
init|=
name|obj
operator|+
name|new_size
decl_stmt|;
specifier|register
name|byte
modifier|*
name|to
init|=
name|obj
operator|+
name|old_size
decl_stmt|;
while|while
condition|(
name|from
operator|>
name|obj
condition|)
operator|*
operator|--
name|to
operator|=
operator|*
operator|--
name|from
expr_stmt|;
name|obj
operator|=
name|ap
operator|->
name|ctop
operator|=
name|to
expr_stmt|;
block|}
else|else
block|{
name|uint
name|new_block_size
init|=
name|align_round
argument_list|(
name|new_size
argument_list|)
decl_stmt|;
name|alloc_free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|obj
operator|+
name|new_block_size
operator|)
argument_list|,
literal|1
argument_list|,
name|align_round
argument_list|(
name|old_size
argument_list|)
operator|-
name|new_block_size
argument_list|,
literal|"alloc_shrink"
argument_list|)
expr_stmt|;
block|}
name|alloc_print
argument_list|(
literal|'<'
argument_list|,
literal|' '
argument_list|,
name|obj
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_comment
comment|/* ------ Private routines ------ */
end_comment

begin_comment
comment|/* Allocate (with malloc) an object too large to be put in a chunk. */
end_comment

begin_comment
comment|/* Return NULL on failure. */
end_comment

begin_function
name|private
name|char
modifier|*
name|alloc_large
parameter_list|(
name|alloc_state_ptr
name|ap
parameter_list|,
name|uint
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
name|alloc_block
modifier|*
name|mblock
init|=
operator|(
name|alloc_block
operator|*
operator|)
call|(
modifier|*
name|ap
operator|->
name|palloc
call|)
argument_list|(
literal|1
argument_list|,
name|alloc_block_size
operator|+
name|size
argument_list|,
name|client_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|mblock
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|block
operator|=
operator|(
name|char
operator|*
operator|)
name|mblock
operator|+
name|alloc_block_size
expr_stmt|;
name|alloc_print_large
argument_list|(
literal|'+'
argument_list|,
literal|'*'
argument_list|,
name|block
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mblock
operator|->
name|next
operator|=
name|ap
operator|->
name|malloc_chain
expr_stmt|;
name|mblock
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|mblock
operator|->
name|save_level
operator|=
name|ap
operator|->
name|save_level
expr_stmt|;
name|mblock
operator|->
name|cap
operator|=
name|ap
expr_stmt|;
name|ap
operator|->
name|malloc_chain
operator|=
name|mblock
expr_stmt|;
name|ap
operator|->
name|used
operator|+=
name|size
expr_stmt|;
name|ap
operator|->
name|total
operator|+=
name|size
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new chunk.  Return true if successful. */
end_comment

begin_define
define|#
directive|define
name|chunk_head_size
value|align_round(sizeof(alloc_chunk))
end_define

begin_function
name|private
name|int
name|alloc_add_chunk
parameter_list|(
specifier|register
name|alloc_state_ptr
name|ap
parameter_list|,
name|uint
name|csize
parameter_list|)
block|{
name|char
modifier|*
name|space
init|=
call|(
modifier|*
name|ap
operator|->
name|palloc
call|)
argument_list|(
literal|1
argument_list|,
name|chunk_head_size
operator|+
name|csize
argument_list|,
literal|"alloc chunk"
argument_list|)
decl_stmt|;
name|long
name|discard
decl_stmt|;
if|if
condition|(
name|space
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ap
operator|->
name|num_chunks
operator|++
expr_stmt|;
comment|/* Accumulate statistics */
name|ap
operator|->
name|total
operator|+=
name|csize
expr_stmt|;
name|alloc_status
argument_list|(
operator|&
name|ap
operator|->
name|used
argument_list|,
operator|&
name|discard
argument_list|)
expr_stmt|;
comment|/* Stash the state of the old chunk */
if|if
condition|(
name|ap
operator|->
name|current_ptr
operator|!=
literal|0
condition|)
comment|/* check for very first chunk */
operator|*
name|ap
operator|->
name|current_ptr
operator|=
name|ap
operator|->
name|current
expr_stmt|;
comment|/* Initialize the new chunk */
name|ap
operator|->
name|cbase
operator|=
name|ap
operator|->
name|cbot
operator|=
operator|(
name|byte
operator|*
operator|)
name|space
operator|+
name|chunk_head_size
expr_stmt|;
name|ap
operator|->
name|climit
operator|=
name|ap
operator|->
name|ctop
operator|=
name|ap
operator|->
name|cbot
operator|+
name|csize
expr_stmt|;
name|ap
operator|->
name|current
operator|.
name|next
operator|=
name|ap
operator|->
name|current_ptr
expr_stmt|;
name|ap
operator|->
name|current
operator|.
name|save_level
operator|=
name|ap
operator|->
name|save_level
expr_stmt|;
name|ap
operator|->
name|current_ptr
operator|=
operator|(
name|alloc_chunk
operator|*
operator|)
name|space
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|chunk_head_size
end_undef

begin_comment
comment|/* Free a large object (allocated with malloc). */
end_comment

begin_function
name|private
name|void
name|alloc_free_large
parameter_list|(
name|char
modifier|*
name|cobj
parameter_list|,
name|uint
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|client_name
parameter_list|)
block|{
name|alloc_block
modifier|*
modifier|*
name|prev
decl_stmt|;
name|alloc_block
modifier|*
name|mblock
init|=
operator|(
name|alloc_block
operator|*
operator|)
operator|(
name|cobj
operator|-
name|alloc_block_size
operator|)
decl_stmt|;
name|alloc_state_ptr
name|ap
init|=
name|mblock
operator|->
name|cap
decl_stmt|;
if|if
condition|(
name|mblock
operator|->
name|save_level
operator|==
name|ap
operator|->
name|save_level
condition|)
for|for
control|(
name|prev
operator|=
operator|&
name|ap
operator|->
name|malloc_chain
init|;
operator|*
name|prev
operator|!=
literal|0
condition|;
name|prev
operator|=
operator|&
name|mblock
operator|->
name|next
control|)
block|{
name|mblock
operator|=
operator|*
name|prev
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|mblock
operator|+
name|alloc_block_size
operator|==
name|cobj
condition|)
block|{
operator|*
name|prev
operator|=
name|mblock
operator|->
name|next
expr_stmt|;
name|ap
operator|->
name|used
operator|-=
name|size
expr_stmt|;
name|ap
operator|->
name|total
operator|-=
name|size
expr_stmt|;
call|(
modifier|*
name|ap
operator|->
name|pfree
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mblock
argument_list|,
literal|1
argument_list|,
name|size
operator|+
name|alloc_block_size
argument_list|,
literal|"large object"
argument_list|)
expr_stmt|;
name|alloc_print_large
argument_list|(
literal|'-'
argument_list|,
literal|'*'
argument_list|,
name|cobj
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|alloc_print
argument_list|(
literal|'-'
argument_list|,
literal|'?'
argument_list|,
name|cobj
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

