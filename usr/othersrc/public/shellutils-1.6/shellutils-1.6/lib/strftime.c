begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* strftime - custom formatting of date and/or time    Copyright (C) 1989, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Note: this version of strftime lacks locale support,    but it is standalone.     Performs `%' substitutions similar to those in printf.  Except    where noted, substituted fields have a fixed size; numeric fields are    padded if necessary.  Padding is with zeros by default; for fields    that display a single number, padding can be changed or inhibited by    following the `%' with one of the modifiers described below.  Unknown    field specifiers are copied as normal characters.  All other    characters are copied to the output without change.     Supports a superset of the ANSI C field specifiers.     Literal character fields:    %	%    n	newline    t	tab     Numeric modifiers (a nonstandard extension):    -	do not pad the field    _	pad the field with spaces     Time fields:    %H	hour (00..23)    %I	hour (00..12)    %M	minute (00..59)    %p	locale's AM or PM    %r	time, 12-hour (hh:mm:ss [AP]M)    %R	time, 24-hour (hh:mm)    %S	second (00..61)    %T	time, 24-hour (hh:mm:ss)    %X	locale's time representation (%H:%M:%S)    %Z	time zone (EDT), or nothing if no time zone is determinable     Date fields:    %a	locale's abbreviated weekday name (Sun..Sat)    %A	locale's full weekday name, variable length (Sunday..Saturday)    %b	locale's abbreviated month name (Jan..Dec)    %B	locale's full month name, variable length (January..December)    %c	locale's date and time (Sat Nov 04 12:02:33 EST 1989)    %C	century (00..99)    %d	day of month (01..31)    %e	day of month ( 1..31)    %D	date (mm/dd/yy)    %h	same as %b    %j	day of year (001..366)    %m	month (01..12)    %U	week number of year with Sunday as first day of week (00..53)    %w	day of week (0..6)    %W	week number of year with Monday as first day of week (00..53)    %x	locale's date representation (mm/dd/yy)    %y	last two digits of year (00..99)    %Y	year (1970...)     David MacKenzie<djm@ai.mit.edu> */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TM_IN_SYS_TIME
argument_list|)
operator|||
name|defined
argument_list|(
name|TZNAME_MISSING
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TM_ZONE_MISSING
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|TZNAME_MISSING
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tzname
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Types of padding for numbers in date and time. */
end_comment

begin_enum
enum|enum
name|padding
block|{
name|none
block|,
name|blank
block|,
name|zero
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|char
modifier|*
name|days
index|[]
init|=
block|{
literal|"Sunday"
block|,
literal|"Monday"
block|,
literal|"Tuesday"
block|,
literal|"Wednesday"
block|,
literal|"Thursday"
block|,
literal|"Friday"
block|,
literal|"Saturday"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|months
index|[]
init|=
block|{
literal|"January"
block|,
literal|"February"
block|,
literal|"March"
block|,
literal|"April"
block|,
literal|"May"
block|,
literal|"June"
block|,
literal|"July"
block|,
literal|"August"
block|,
literal|"September"
block|,
literal|"October"
block|,
literal|"November"
block|,
literal|"December"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add character C to STRING and increment LENGTH,    unless LENGTH would exceed MAX. */
end_comment

begin_define
define|#
directive|define
name|add_char
parameter_list|(
name|c
parameter_list|)
value|(length + 1<= max)&& (string[length++] = (c))
end_define

begin_comment
comment|/* Add a 2 digit number to STRING, padding if specified.    Return the number of characters added, up to MAX. */
end_comment

begin_function
specifier|static
name|int
name|add_num2
parameter_list|(
name|string
parameter_list|,
name|num
parameter_list|,
name|max
parameter_list|,
name|pad
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|max
decl_stmt|;
name|enum
name|padding
name|pad
decl_stmt|;
block|{
name|int
name|top
init|=
name|num
operator|/
literal|10
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|pad
operator|==
name|blank
condition|)
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|top
operator|!=
literal|0
operator|||
name|pad
operator|==
name|zero
condition|)
name|add_char
argument_list|(
name|top
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|num
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Add a 3 digit number to STRING, padding if specified.    Return the number of characters added, up to MAX. */
end_comment

begin_function
specifier|static
name|int
name|add_num3
parameter_list|(
name|string
parameter_list|,
name|num
parameter_list|,
name|max
parameter_list|,
name|pad
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|max
decl_stmt|;
name|enum
name|padding
name|pad
decl_stmt|;
block|{
name|int
name|top
init|=
name|num
operator|/
literal|100
decl_stmt|;
name|int
name|mid
init|=
operator|(
name|num
operator|-
name|top
operator|*
literal|100
operator|)
operator|/
literal|10
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|pad
operator|==
name|blank
condition|)
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|top
operator|!=
literal|0
operator|||
name|pad
operator|==
name|zero
condition|)
name|add_char
argument_list|(
name|top
operator|+
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
operator|&&
name|top
operator|==
literal|0
operator|&&
name|pad
operator|==
name|blank
condition|)
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mid
operator|!=
literal|0
operator|||
name|top
operator|!=
literal|0
operator|||
name|pad
operator|==
name|zero
condition|)
name|add_char
argument_list|(
name|mid
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|num
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Like strncpy except return the number of characters copied. */
end_comment

begin_function
specifier|static
name|int
name|add_str
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|from
index|[
name|i
index|]
operator|&&
name|i
operator|<=
name|max
condition|;
operator|++
name|i
control|)
name|to
index|[
name|i
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return the week in the year of the time in TM, with the weeks    starting on Sundays. */
end_comment

begin_function
specifier|static
name|int
name|sun_week
parameter_list|(
name|tm
parameter_list|)
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
block|{
name|int
name|dl
decl_stmt|;
comment|/* Set `dl' to the day in the year of the last day of the week previous      to the one containing the day specified in TM.  If the day specified      in TM is in the first week of the year, `dl' will be negative or 0.      Otherwise, calculate the number of complete weeks before our week      (dl / 7) and add any partial week at the start of the year (dl % 7). */
name|dl
operator|=
name|tm
operator|->
name|tm_yday
operator|-
name|tm
operator|->
name|tm_wday
expr_stmt|;
return|return
name|dl
operator|<=
literal|0
condition|?
literal|0
else|:
name|dl
operator|/
literal|7
operator|+
operator|(
name|dl
operator|%
literal|7
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the week in the year of the time in TM, with the weeks    starting on Mondays. */
end_comment

begin_function
specifier|static
name|int
name|mon_week
parameter_list|(
name|tm
parameter_list|)
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
block|{
name|int
name|dl
decl_stmt|,
name|wday
decl_stmt|;
if|if
condition|(
name|tm
operator|->
name|tm_wday
operator|==
literal|0
condition|)
name|wday
operator|=
literal|6
expr_stmt|;
else|else
name|wday
operator|=
name|tm
operator|->
name|tm_wday
operator|-
literal|1
expr_stmt|;
name|dl
operator|=
name|tm
operator|->
name|tm_yday
operator|-
name|wday
expr_stmt|;
return|return
name|dl
operator|<=
literal|0
condition|?
literal|0
else|:
name|dl
operator|/
literal|7
operator|+
operator|(
name|dl
operator|%
literal|7
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TZNAME_MISSING
end_ifdef

begin_function
name|char
modifier|*
name|zone_name
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
block|{
name|char
modifier|*
name|timezone
parameter_list|()
function_decl|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
return|return
name|timezone
argument_list|(
name|tz
operator|.
name|tz_minuteswest
argument_list|,
name|tp
operator|->
name|tm_isdst
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Format the time given in TM according to FORMAT, and put the    results in STRING.    Return the number of characters (not including terminating null)    that were put into STRING, or 0 if the length would have    exceeded MAX. */
end_comment

begin_function
name|size_t
name|strftime
parameter_list|(
name|string
parameter_list|,
name|max
parameter_list|,
name|format
parameter_list|,
name|tm
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|max
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
block|{
name|enum
name|padding
name|pad
decl_stmt|;
comment|/* Type of padding to apply. */
name|size_t
name|length
init|=
literal|0
decl_stmt|;
comment|/* Characters put in STRING so far. */
for|for
control|(
init|;
operator|*
name|format
operator|&&
name|length
operator|<
name|max
condition|;
operator|++
name|format
control|)
block|{
if|if
condition|(
operator|*
name|format
operator|!=
literal|'%'
condition|)
name|add_char
argument_list|(
operator|*
name|format
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|format
expr_stmt|;
comment|/* Modifiers: */
if|if
condition|(
operator|*
name|format
operator|==
literal|'-'
condition|)
block|{
name|pad
operator|=
name|none
expr_stmt|;
operator|++
name|format
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|format
operator|==
literal|'_'
condition|)
block|{
name|pad
operator|=
name|blank
expr_stmt|;
operator|++
name|format
expr_stmt|;
block|}
else|else
name|pad
operator|=
name|zero
expr_stmt|;
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
comment|/* Literal character fields: */
case|case
literal|0
case|:
case|case
literal|'%'
case|:
name|add_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|add_char
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|add_char
argument_list|(
operator|*
name|format
argument_list|)
expr_stmt|;
break|break;
comment|/* Time fields: */
case|case
literal|'H'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|==
literal|0
condition|)
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
literal|12
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|>
literal|12
condition|)
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_hour
operator|-
literal|12
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|<
literal|12
condition|)
name|add_char
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|length
operator|+=
name|strftime
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|,
literal|"%I:%M:%S %p"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|length
operator|+=
name|strftime
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|,
literal|"%H:%M"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|length
operator|+=
name|strftime
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|,
literal|"%H:%M:%S"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|length
operator|+=
name|strftime
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|,
literal|"%H:%M:%S"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
ifndef|#
directive|ifndef
name|TM_ZONE_MISSING
name|length
operator|+=
name|add_str
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_zone
argument_list|,
name|max
operator|-
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|TZNAME_MISSING
if|if
condition|(
name|tm
operator|->
name|tm_isdst
operator|&&
name|tzname
index|[
literal|1
index|]
operator|&&
operator|*
name|tzname
index|[
literal|1
index|]
condition|)
name|length
operator|+=
name|add_str
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tzname
index|[
literal|1
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|add_str
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tzname
index|[
literal|0
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|length
operator|+=
name|add_str
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|zone_name
argument_list|(
name|tm
argument_list|)
argument_list|,
name|max
operator|-
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
comment|/* Date fields: */
case|case
literal|'a'
case|:
name|add_char
argument_list|(
name|days
index|[
name|tm
operator|->
name|tm_wday
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|days
index|[
name|tm
operator|->
name|tm_wday
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|days
index|[
name|tm
operator|->
name|tm_wday
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|length
operator|+=
name|add_str
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|days
index|[
name|tm
operator|->
name|tm_wday
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'h'
case|:
name|add_char
argument_list|(
name|months
index|[
name|tm
operator|->
name|tm_mon
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|months
index|[
name|tm
operator|->
name|tm_mon
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|months
index|[
name|tm
operator|->
name|tm_mon
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|length
operator|+=
name|add_str
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|months
index|[
name|tm
operator|->
name|tm_mon
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|length
operator|+=
name|strftime
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|,
literal|"%a %b %d %H:%M:%S %Z %Y"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
operator|(
name|tm
operator|->
name|tm_year
operator|+
literal|1900
operator|)
operator|/
literal|100
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|blank
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|length
operator|+=
name|strftime
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|,
literal|"%m/%d/%y"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|length
operator|+=
name|add_num3
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_yday
operator|+
literal|1
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|sun_week
argument_list|(
name|tm
argument_list|)
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|add_char
argument_list|(
name|tm
operator|->
name|tm_wday
operator|+
literal|'0'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|mon_week
argument_list|(
name|tm
argument_list|)
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|length
operator|+=
name|strftime
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|max
operator|-
name|length
argument_list|,
literal|"%m/%d/%y"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|length
operator|+=
name|add_num2
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
name|tm
operator|->
name|tm_year
operator|%
literal|100
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|pad
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|add_char
argument_list|(
operator|(
name|tm
operator|->
name|tm_year
operator|+
literal|1900
operator|)
operator|/
literal|1000
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|length
operator|+=
name|add_num3
argument_list|(
operator|&
name|string
index|[
name|length
index|]
argument_list|,
operator|(
literal|1900
operator|+
name|tm
operator|->
name|tm_year
operator|)
operator|%
literal|1000
argument_list|,
name|max
operator|-
name|length
argument_list|,
name|zero
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|add_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|length
operator|-
literal|1
return|;
block|}
end_function

end_unit

