begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathchk -- check whether pathnames are valid or portable    Copyright (C) 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Usage: pathchk [-p] [--portability] path...     For each PATH, print a message if any of these conditions are false:    * all leading directories in PATH have search (execute) permission    * strlen (PATH)<= PATH_MAX    * strlen (each_directory_in_PATH)<= NAME_MAX     Exit status:    0			All PATH names passed all of the tests.    1			An error occurred.     Options:    -p, --portability	Instead of performing length checks on the 			underlying filesystem, test the length of the 			pathname and its components against the POSIX.1 			minimum limits for portability, _POSIX_NAME_MAX 			and _POSIX_PATH_MAX in 2.9.2.  Also check that 			the pathname contains no characters not in the 			portable filename character set.     David MacKenzie<djm@ai.mit.edu>    and Jim Meyering<meyering@cs.utexas.edu> */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_VERSION
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|PATH_MAX_FOR
parameter_list|(
name|p
parameter_list|)
value|pathconf ((p), _PC_PATH_MAX)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PATH_MAX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME_MAX
end_ifndef

begin_define
define|#
directive|define
name|NAME_MAX_FOR
parameter_list|(
name|p
parameter_list|)
value|pathconf ((p), _PC_NAME_MAX);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAME_MAX */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not _POSIX_VERSION */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAXPATHLEN
end_ifdef

begin_define
define|#
directive|define
name|PATH_MAX
value|MAXPATHLEN
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not MAXPATHLEN */
end_comment

begin_define
define|#
directive|define
name|PATH_MAX
value|_POSIX_PATH_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAXPATHLEN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PATH_MAX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAXNAMLEN
end_ifdef

begin_define
define|#
directive|define
name|NAME_MAX
value|MAXNAMLEN
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not MAXNAMLEN */
end_comment

begin_define
define|#
directive|define
name|NAME_MAX
value|_POSIX_NAME_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAXNAMLEN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAME_MAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _POSIX_VERSION */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|_POSIX_PATH_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_NAME_MAX
end_ifndef

begin_define
define|#
directive|define
name|_POSIX_NAME_MAX
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX_FOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_MAX_FOR
parameter_list|(
name|p
parameter_list|)
value|PATH_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAME_MAX_FOR
end_ifndef

begin_define
define|#
directive|define
name|NAME_MAX_FOR
parameter_list|(
name|p
parameter_list|)
value|NAME_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|xstrdup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|validate_new_path
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|strip_trailing_slashes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"portability"
block|,
literal|0
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
name|int
name|check_portability
init|=
literal|0
decl_stmt|;
name|int
name|optc
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"p"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'p'
case|:
name|check_portability
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
block|{
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|exit_status
operator||=
name|validate_new_path
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|check_portability
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Each element is nonzero if the corresponding ASCII character is    in the POSIX portable character set, and zero if it is not.    In addition, the entry for `/' is nonzero to simplify checking. */
end_comment

begin_decl_stmt
name|char
name|portable_chars
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0-15 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 16-31 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 32-47 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 48-63 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 64-79 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 80-95 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 96-111 */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 112-127 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make sure that    strlen (PATH)<= PATH_MAX&& strlen (each-directory-in-PATH)<= NAME_MAX     If PORTABILITY is nonzero, compare against _POSIX_PATH_MAX and    _POSIX_NAME_MAX instead, and make sure that PATH contains no    characters not in the POSIX portable filename character set, which    consists of A-Z, a-z, 0-9, ., _, -.     Make sure that all leading directories along PATH that exist have    `x' permission.     Return 0 if all of these tests are successful, 1 if any fail. */
end_comment

begin_function
name|int
name|validate_new_path
parameter_list|(
name|path
parameter_list|,
name|portability
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|portability
decl_stmt|;
block|{
name|int
name|path_max
decl_stmt|;
name|int
name|last_elem
decl_stmt|;
comment|/* Nonzero if checking last element of path. */
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|stat
name|stats
decl_stmt|;
if|if
condition|(
name|portability
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
for|for
control|(
name|start
operator|=
name|path
init|;
operator|*
name|start
condition|;
operator|++
name|start
control|)
if|if
condition|(
name|portable_chars
index|[
operator|*
name|start
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"path `%s' contains nonportable character `%c'"
argument_list|,
name|path
argument_list|,
operator|*
name|start
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|*
name|path
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|parent
operator|=
name|xstrdup
argument_list|(
operator|*
name|path
operator|==
literal|'/'
condition|?
literal|"/"
else|:
literal|"."
argument_list|)
expr_stmt|;
name|slash
operator|=
name|path
expr_stmt|;
name|last_elem
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|name_max
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Length of partial path being checked. */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of path element being checked. */
comment|/* Find the end of this element of the path. 	 Then chop off the rest of the path after this element. */
while|while
condition|(
operator|*
name|slash
operator|==
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
name|start
operator|=
name|slash
expr_stmt|;
name|slash
operator|=
name|index
argument_list|(
name|slash
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|last_elem
operator|=
literal|1
expr_stmt|;
name|slash
operator|=
name|index
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|last_elem
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|stats
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' is not a directory"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Use access to test for search permission because 	     testing permission bits of st_mode can lose with new 	     access control mechanisms.  Of course, access loses if you're 	     running setuid. */
if|if
condition|(
name|access
argument_list|(
name|path
argument_list|,
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"directory `%s' is not searchable"
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|length
operator|=
name|slash
operator|-
name|start
expr_stmt|;
comment|/* Now, since we know that `parent' is a directory, it's ok to call 	 pathconf with it as the argument.  If `parent' isn't a directory 	 or doesn't exist, the behavior of pathconf is undefined. 	 But if `parent' is a directory and lies on a remote file system, 	 it's likely that pathconf can't give us a reasonable value 	 and will return -1.  (NFS and tempfs are not POSIX . . .)  */
name|name_max
operator|=
name|portability
condition|?
name|_POSIX_NAME_MAX
else|:
name|NAME_MAX_FOR
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_max
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: pathconf failed on `%s'; using minimum length"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|name_max
operator|=
name|_POSIX_NAME_MAX
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
name|name_max
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"name `%s' has length %d; exceeds limit of %d"
argument_list|,
name|path
argument_list|,
name|length
argument_list|,
name|name_max
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|last_elem
condition|)
break|break;
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|=
name|xstrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* We know that `parent' is a directory,      so it's ok to call pathconf with it as the argument.  */
name|path_max
operator|=
name|portability
condition|?
name|_POSIX_PATH_MAX
else|:
name|PATH_MAX_FOR
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_max
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: pathconf failed on `%s'; using minimum length"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|path_max
operator|=
name|_POSIX_PATH_MAX
expr_stmt|;
block|}
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|>
name|path_max
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"path `%s' has length %d; exceeds limit of %d"
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|,
name|path_max
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-p] [--portability] path...\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

