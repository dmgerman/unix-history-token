begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* printf - format and print data    Copyright (C) 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Usage: printf format [argument...]     A front end to the printf function that lets it be used from the shell.     Backslash escapes:     \" = double quote    \\ = backslash    \a = alert (bell)    \b = backspace    \c = produce no further output    \f = form feed    \n = new line    \r = carriage return    \t = horizontal tab    \v = vertical tab    \0ooo = octal number (ooo is 0 to 3 digits)    \xhhh = hexadecimal number (hhh is 1 to 3 digits)     Additional directive:     %b = print an argument string, interpreting backslash escapes     David MacKenzie<djm@ai.mit.edu> */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_define
define|#
directive|define
name|isodigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '7')
end_define

begin_define
define|#
directive|define
name|hextobin
parameter_list|(
name|c
parameter_list|)
value|((c)>='a'&&(c)<='f' ? (c)-'a'+10 : (c)>='A'&&(c)<='F' ? (c)-'A'+10 : (c)-'0')
end_define

begin_define
define|#
directive|define
name|octtobin
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|print_esc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_direc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_esc_char
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_esc_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|format
decl_stmt|;
comment|/* Pointer into the format argument. */
name|char
modifier|*
name|direc_start
decl_stmt|;
comment|/* Start of % directive. */
name|int
name|direc_length
decl_stmt|;
comment|/* Length of % directive. */
name|int
name|field_width
decl_stmt|;
comment|/* Arg to first '*', or -1 if none. */
name|int
name|precision
decl_stmt|;
comment|/* Arg to second '*', or -1 if none. */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s format [argument...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|format
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
for|for
control|(
init|;
operator|*
name|format
condition|;
operator|++
name|format
control|)
block|{
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|'%'
case|:
name|direc_start
operator|=
name|format
operator|++
expr_stmt|;
name|direc_length
operator|=
literal|1
expr_stmt|;
name|field_width
operator|=
name|precision
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|format
operator|==
literal|'%'
condition|)
block|{
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|format
operator|==
literal|'b'
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument"
argument_list|)
expr_stmt|;
name|print_esc_string
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|index
argument_list|(
literal|"-+ #"
argument_list|,
operator|*
name|format
argument_list|)
condition|)
block|{
operator|++
name|format
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|format
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument"
argument_list|)
expr_stmt|;
operator|++
name|format
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
name|field_width
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_width
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"negative field width"
argument_list|)
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
else|else
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|format
argument_list|)
condition|)
block|{
operator|++
name|format
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|format
operator|==
literal|'.'
condition|)
block|{
operator|++
name|format
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
if|if
condition|(
operator|*
name|format
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument"
argument_list|)
expr_stmt|;
operator|++
name|format
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
name|precision
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"negative precision"
argument_list|)
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
block|}
else|else
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|format
argument_list|)
condition|)
block|{
operator|++
name|format
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|format
operator|==
literal|'l'
operator|||
operator|*
name|format
operator|==
literal|'L'
operator|||
operator|*
name|format
operator|==
literal|'h'
condition|)
block|{
operator|++
name|format
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|index
argument_list|(
literal|"diouxXfeEgGcs"
argument_list|,
operator|*
name|format
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%%%c: invalid directive"
argument_list|,
operator|*
name|format
argument_list|)
expr_stmt|;
operator|++
name|direc_length
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing argument"
argument_list|)
expr_stmt|;
name|print_direc
argument_list|(
name|direc_start
argument_list|,
name|direc_length
argument_list|,
name|field_width
argument_list|,
name|precision
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|++
name|argv
expr_stmt|;
operator|--
name|argc
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|format
operator|+=
name|print_esc
argument_list|(
name|format
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
operator|*
name|format
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a \ escape sequence starting at ESCSTART.    Return the number of characters in the escape sequence. */
end_comment

begin_function
name|int
name|print_esc
parameter_list|(
name|escstart
parameter_list|)
name|char
modifier|*
name|escstart
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|escstart
operator|+
literal|1
decl_stmt|;
name|int
name|esc_value
init|=
literal|0
decl_stmt|;
comment|/* Value of \nnn escape. */
name|int
name|esc_length
decl_stmt|;
comment|/* Length of \nnn escape. */
comment|/* \0ooo and \xhhh escapes have maximum length of 3 chars. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
condition|)
block|{
for|for
control|(
name|esc_length
operator|=
literal|0
operator|,
operator|++
name|p
init|;
name|esc_length
operator|<
literal|3
operator|&&
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|esc_length
operator|,
operator|++
name|p
control|)
name|esc_value
operator|=
name|esc_value
operator|*
literal|16
operator|+
name|hextobin
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc_length
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing hexadecimal number in escape"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|esc_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
for|for
control|(
name|esc_length
operator|=
literal|0
operator|,
operator|++
name|p
init|;
name|esc_length
operator|<
literal|3
operator|&&
name|isodigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|esc_length
operator|,
operator|++
name|p
control|)
name|esc_value
operator|=
name|esc_value
operator|*
literal|8
operator|+
name|octtobin
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|esc_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|index
argument_list|(
literal|"\"\\abcfnrtv"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\\%c: invalid escape"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|print_esc_char
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|p
operator|-
name|escstart
return|;
block|}
end_function

begin_comment
comment|/* Output a single-character \ escape.  */
end_comment

begin_function
name|void
name|print_esc_char
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Alert. */
name|putchar
argument_list|(
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Backspace. */
name|putchar
argument_list|(
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Cancel the rest of the output. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Form feed. */
name|putchar
argument_list|(
literal|12
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* New line. */
name|putchar
argument_list|(
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Carriage return. */
name|putchar
argument_list|(
literal|13
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Horizontal tab. */
name|putchar
argument_list|(
literal|9
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Vertical tab. */
name|putchar
argument_list|(
literal|11
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print string STR, evaluating \ escapes. */
end_comment

begin_function
name|void
name|print_esc_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
literal|'\\'
condition|)
name|str
operator|+=
name|print_esc
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a % directive.  START is the start of the directive,    LENGTH is its length, and ARGUMENT is its argument.    If FIELD_WIDTH or PRECISION is non-negative, they are args for    '*' values in those fields. */
end_comment

begin_function
name|void
name|print_direc
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|,
name|field_width
parameter_list|,
name|precision
parameter_list|,
name|argument
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|field_width
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|char
modifier|*
name|argument
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Null-terminated copy of % directive. */
name|p
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|p
index|[
name|length
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|field_width
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|printf
argument_list|(
name|p
argument_list|,
name|atol
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|p
argument_list|,
name|precision
argument_list|,
name|atol
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|printf
argument_list|(
name|p
argument_list|,
name|field_width
argument_list|,
name|atol
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|p
argument_list|,
name|field_width
argument_list|,
name|precision
argument_list|,
name|atol
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
if|if
condition|(
name|field_width
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|printf
argument_list|(
name|p
argument_list|,
name|atof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|p
argument_list|,
name|precision
argument_list|,
name|atof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|printf
argument_list|(
name|p
argument_list|,
name|field_width
argument_list|,
name|atof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|p
argument_list|,
name|field_width
argument_list|,
name|precision
argument_list|,
name|atof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|printf
argument_list|(
name|p
argument_list|,
operator|*
name|argument
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|field_width
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|printf
argument_list|(
name|p
argument_list|,
name|argument
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|p
argument_list|,
name|precision
argument_list|,
name|argument
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|precision
operator|<
literal|0
condition|)
name|printf
argument_list|(
name|p
argument_list|,
name|field_width
argument_list|,
name|argument
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|p
argument_list|,
name|field_width
argument_list|,
name|precision
argument_list|,
name|argument
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

