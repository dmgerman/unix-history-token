begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expr -- evaluate expressions.    Copyright (C) 1986, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Author: Mike Parker.     This program evaluates expressions.  Each token (operator, operand,    parenthesis) of the expression must be a seperate argument.  The    parser used is a reasonably general one, though any incarnation of    it is language-specific.  It is especially nice for expressions.     The way it works is (parse_expr is special, parse_expr_1 is    typical) follows.  Note that when the summary below speaks of a new    node in this implementation no parse tree is needed; the node is    evaluated immediately.  Note that one function can handle multiple    operators all of equal precedence, provided they all associate    ((x op x) op x).  	global token-list  	parse_expr () 	while true 		lhs = parse_expr_1 () 		if next-token = lowest-precendence-operator then 			advance token-list 			rhs = parse_expr_1 () 			lhs = new-node (lhs, operator, rhs) 			continue while 		else if no more tokens then 			return lhs 		else 			syntax error (unrecognized operator) 		endif 	end while  	parse_expr_1 () 	while true 		lhs = parse_expr_2 () 		if next-token = second-lowest-precedence-operator then 			advance token-list 			rhs = parse_expr_1 () 			lhs = new-node (lhs, operator, rhs) 			continue while 		else 			return lhs 		endif 	end while  	parse_expr_2 () similar, with a different operator 	parse_expr_3 () similar, with a different operator 	etc, until finally  	parse_expr_N () 	if next-token is a left paren then 		advance token-list 		node = parse_expr () (the top parse_expr) 		check that next token is a right paren (syntax error if not) 		advance token-list 		return node 	else if next-token is a legal operand then 		advance token-list 		return new-leaf-node (operand) 	else 		syntax error (invalid operand) 	endif     Define EVAL_TRACE to print an evaluation trace.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_define
define|#
directive|define
name|NEW
parameter_list|(
name|type
parameter_list|)
value|((type *) xmalloc (sizeof (type)))
end_define

begin_define
define|#
directive|define
name|OLD
parameter_list|(
name|x
parameter_list|)
value|free ((char *) x)
end_define

begin_comment
comment|/* the kinds of value we can have */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|integer
block|,
name|string
block|}
name|TYPE
typedef|;
end_typedef

begin_comment
comment|/* a value is.... */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|TYPE
name|type
decl_stmt|;
comment|/* which kind */
union|union
block|{
comment|/* the value itself */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|}
name|u
union|;
block|}
name|VALUE
typedef|;
end_typedef

begin_comment
comment|/* The arguments given to the program, minus the program name. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|VALUE
modifier|*
name|docolon
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|VALUE
modifier|*
name|eval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|VALUE
modifier|*
name|int_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|VALUE
modifier|*
name|str_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xstrdup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isstring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|nextarg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|nomoreargs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|null
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|toarith
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|freev
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|printv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tostring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|trace
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s expression...\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|args
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|v
operator|=
name|eval
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nomoreargs
argument_list|()
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
name|printv
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|null
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a VALUE for integer I. */
end_comment

begin_function
name|VALUE
modifier|*
name|int_value
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|NEW
argument_list|(
name|VALUE
argument_list|)
expr_stmt|;
name|v
operator|->
name|type
operator|=
name|integer
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|i
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a VALUE for string S. */
end_comment

begin_function
name|VALUE
modifier|*
name|str_value
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|NEW
argument_list|(
name|VALUE
argument_list|)
expr_stmt|;
name|v
operator|->
name|type
operator|=
name|string
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|s
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free VALUE V, including structure components. */
end_comment

begin_function
name|void
name|freev
parameter_list|(
name|v
parameter_list|)
name|VALUE
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|->
name|type
operator|==
name|string
condition|)
block|{
name|free
argument_list|(
name|v
operator|->
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
name|OLD
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print VALUE V. */
end_comment

begin_function
name|void
name|printv
parameter_list|(
name|v
parameter_list|)
name|VALUE
modifier|*
name|v
decl_stmt|;
block|{
switch|switch
condition|(
name|v
operator|->
name|type
condition|)
block|{
case|case
name|integer
case|:
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|v
operator|->
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|string
case|:
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|v
operator|->
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if V is a null-string or zero-number. */
end_comment

begin_function
name|int
name|null
parameter_list|(
name|v
parameter_list|)
name|VALUE
modifier|*
name|v
decl_stmt|;
block|{
switch|switch
condition|(
name|v
operator|->
name|type
condition|)
block|{
case|case
name|integer
case|:
return|return
operator|(
name|v
operator|->
name|u
operator|.
name|i
operator|==
literal|0
operator|)
return|;
case|case
name|string
case|:
return|return
operator|(
name|v
operator|->
name|u
operator|.
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if V is a string value. */
end_comment

begin_function
name|int
name|isstring
parameter_list|(
name|v
parameter_list|)
name|VALUE
modifier|*
name|v
decl_stmt|;
block|{
return|return
operator|(
name|v
operator|->
name|type
operator|==
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Coerce V to a string value (can't fail). */
end_comment

begin_function
name|void
name|tostring
parameter_list|(
name|v
parameter_list|)
name|VALUE
modifier|*
name|v
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
switch|switch
condition|(
name|v
operator|->
name|type
condition|)
block|{
case|case
name|integer
case|:
name|temp
operator|=
name|xmalloc
argument_list|(
literal|4
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|v
operator|->
name|u
operator|.
name|i
argument_list|)
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|s
operator|=
name|temp
expr_stmt|;
name|v
operator|->
name|type
operator|=
name|string
expr_stmt|;
break|break;
case|case
name|string
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Coerce V to an integer value.  Return 1 on success, 0 on failure. */
end_comment

begin_function
name|int
name|toarith
parameter_list|(
name|v
parameter_list|)
name|VALUE
modifier|*
name|v
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|v
operator|->
name|type
condition|)
block|{
case|case
name|integer
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|string
case|:
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|v
operator|->
name|u
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|neg
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
name|i
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|v
operator|->
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|i
operator|=
name|i
operator|*
operator|(
name|neg
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
name|v
operator|->
name|type
operator|=
name|integer
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the next token matches STR exactly.    STR must not be NULL.  */
end_comment

begin_function
name|int
name|nextarg
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|args
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
name|str
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there no more tokens. */
end_comment

begin_function
name|int
name|nomoreargs
parameter_list|()
block|{
return|return
operator|(
operator|*
name|args
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* the comparison operator handling functions */
end_comment

begin_define
define|#
directive|define
name|cmpf
parameter_list|(
name|name
parameter_list|,
name|rel
parameter_list|)
define|\
value|int name (l, r) VALUE *l; VALUE *r;		\ {						\   if (isstring (l) || isstring (r))		\     {						\        tostring (l);				\        tostring (r);				\        return strcmp (l->u.s, r->u.s) rel 0;	\     }						\  else						\    return l->u.i rel r->u.i;			\ }
end_define

begin_macro
name|cmpf
argument_list|(
argument|less_than
argument_list|,
argument|<
argument_list|)
end_macro

begin_macro
name|cmpf
argument_list|(
argument|less_equal
argument_list|,
argument|<=
argument_list|)
end_macro

begin_macro
name|cmpf
argument_list|(
argument|equal
argument_list|,
argument|==
argument_list|)
end_macro

begin_macro
name|cmpf
argument_list|(
argument|not_equal
argument_list|,
argument|!=
argument_list|)
end_macro

begin_macro
name|cmpf
argument_list|(
argument|greater_equal
argument_list|,
argument|>=
argument_list|)
end_macro

begin_macro
name|cmpf
argument_list|(
argument|greater_than
argument_list|,
argument|>
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|cmpf
end_undef

begin_comment
comment|/* the arithmetic operator handling functions */
end_comment

begin_define
define|#
directive|define
name|arithf
parameter_list|(
name|name
parameter_list|,
name|op
parameter_list|)
define|\
value|int name (l, r) VALUE *l; VALUE *r;		\ {						\   if (!toarith (l) || !toarith (r))		\     error (2, 0, "non-numeric argument");	\   return l->u.i op r->u.i;			\ }
end_define

begin_macro
name|arithf
argument_list|(
argument|plus
argument_list|,
argument|+
argument_list|)
end_macro

begin_macro
name|arithf
argument_list|(
argument|minus
argument_list|,
argument|-
argument_list|)
end_macro

begin_macro
name|arithf
argument_list|(
argument|multiply
argument_list|,
argument|*
argument_list|)
end_macro

begin_macro
name|arithf
argument_list|(
argument|divide
argument_list|,
argument|/
argument_list|)
end_macro

begin_macro
name|arithf
argument_list|(
argument|mod
argument_list|,
argument|%
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|arithf
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|EVAL_TRACE
end_ifdef

begin_comment
comment|/* function to print evaluation trace and args remaining */
end_comment

begin_function
name|void
name|trace
parameter_list|(
name|fxn
parameter_list|)
name|char
modifier|*
name|fxn
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|fxn
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|args
init|;
operator|*
name|a
condition|;
name|a
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* do the : operator.  SV is the VALUE for the lhs (the string), PV is the     VALUE for the rhs (the pattern). */
end_comment

begin_function
name|VALUE
modifier|*
name|docolon
parameter_list|(
name|sv
parameter_list|,
name|pv
parameter_list|)
name|VALUE
modifier|*
name|sv
decl_stmt|;
name|VALUE
modifier|*
name|pv
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
name|struct
name|re_pattern_buffer
name|re_buffer
decl_stmt|;
name|struct
name|re_registers
name|re_regs
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tostring
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|tostring
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|pv
operator|->
name|u
operator|.
name|s
argument_list|)
expr_stmt|;
name|re_buffer
operator|.
name|allocated
operator|=
literal|2
operator|*
name|len
expr_stmt|;
name|re_buffer
operator|.
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|re_buffer
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|re_buffer
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
name|errmsg
operator|=
name|re_compile_pattern
argument_list|(
name|pv
operator|->
name|u
operator|.
name|s
argument_list|,
name|len
argument_list|,
operator|&
name|re_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|len
operator|=
name|re_match
argument_list|(
operator|&
name|re_buffer
argument_list|,
name|sv
operator|->
name|u
operator|.
name|s
argument_list|,
name|strlen
argument_list|(
name|sv
operator|->
name|u
operator|.
name|s
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|re_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
block|{
comment|/* Were \(...\) used? */
if|if
condition|(
name|re_buffer
operator|.
name|re_nsub
operator|>
literal|0
condition|)
comment|/* was (re_regs.start[1]>= 0) */
block|{
name|sv
operator|->
name|u
operator|.
name|s
index|[
name|re_regs
operator|.
name|end
index|[
literal|1
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|str_value
argument_list|(
name|sv
operator|->
name|u
operator|.
name|s
operator|+
name|re_regs
operator|.
name|start
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|int_value
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* match failed -- return right kind of null */
if|if
condition|(
name|strstr
argument_list|(
name|pv
operator|->
name|u
operator|.
name|s
argument_list|,
literal|"\\("
argument_list|)
condition|)
block|{
name|v
operator|=
name|str_value
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|int_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|re_buffer
operator|.
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/* eval6 -- handles bare operands and ( expr ) syntax */
end_comment

begin_function
name|VALUE
modifier|*
name|eval6
parameter_list|()
block|{
name|VALUE
modifier|*
name|v
decl_stmt|;
name|VALUE
modifier|*
name|eval
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|EVAL_TRACE
name|trace
argument_list|(
literal|"eval6"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nextarg
argument_list|(
literal|"("
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|v
operator|=
name|eval
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nextarg
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
block|}
name|args
operator|++
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|")"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|str_value
argument_list|(
operator|*
name|args
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|toarith
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* eval5 -- handles : operator (pattern matching).  Calls ``docolon'' to do     the real work. */
end_comment

begin_function
name|VALUE
modifier|*
name|eval5
parameter_list|()
block|{
name|VALUE
modifier|*
name|l
decl_stmt|;
name|VALUE
modifier|*
name|r
decl_stmt|;
name|VALUE
modifier|*
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|EVAL_TRACE
name|trace
argument_list|(
literal|"eval5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l
operator|=
name|eval6
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|nextarg
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|r
operator|=
name|eval6
argument_list|()
expr_stmt|;
name|v
operator|=
name|docolon
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|l
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* eval4 -- handles *, /, % operators */
end_comment

begin_function
name|VALUE
modifier|*
name|eval4
parameter_list|()
block|{
name|VALUE
modifier|*
name|l
decl_stmt|;
name|VALUE
modifier|*
name|r
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fxn
function_decl|)
parameter_list|()
function_decl|;
name|int
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|EVAL_TRACE
name|trace
argument_list|(
literal|"eval4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l
operator|=
name|eval5
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fxn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextarg
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|multiply
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|divide
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|"%"
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|mod
expr_stmt|;
block|}
if|if
condition|(
name|fxn
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|r
operator|=
name|eval5
argument_list|()
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|fxn
call|)
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|l
operator|=
name|int_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* eval3 -- handles +, - operators */
end_comment

begin_function
name|VALUE
modifier|*
name|eval3
parameter_list|()
block|{
name|VALUE
modifier|*
name|l
decl_stmt|;
name|VALUE
modifier|*
name|r
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fxn
function_decl|)
parameter_list|()
function_decl|;
name|int
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|EVAL_TRACE
name|trace
argument_list|(
literal|"eval3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l
operator|=
name|eval4
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fxn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextarg
argument_list|(
literal|"+"
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|plus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|minus
expr_stmt|;
block|}
if|if
condition|(
name|fxn
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|r
operator|=
name|eval4
argument_list|()
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|fxn
call|)
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|l
operator|=
name|int_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* eval2 -- handles comparisons */
end_comment

begin_function
name|VALUE
modifier|*
name|eval2
parameter_list|()
block|{
name|VALUE
modifier|*
name|l
decl_stmt|;
name|VALUE
modifier|*
name|r
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fxn
function_decl|)
parameter_list|()
function_decl|;
name|int
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|EVAL_TRACE
name|trace
argument_list|(
literal|"eval2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l
operator|=
name|eval3
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fxn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextarg
argument_list|(
literal|"<"
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|less_than
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|"<="
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|less_equal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|"="
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|equal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|"!="
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|not_equal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|">="
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|greater_equal
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextarg
argument_list|(
literal|">"
argument_list|)
condition|)
block|{
name|fxn
operator|=
name|greater_than
expr_stmt|;
block|}
if|if
condition|(
name|fxn
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|r
operator|=
name|eval3
argument_list|()
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|fxn
call|)
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|l
operator|=
name|int_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* eval1 -- handles& */
end_comment

begin_function
name|VALUE
modifier|*
name|eval1
parameter_list|()
block|{
name|VALUE
modifier|*
name|l
decl_stmt|;
name|VALUE
modifier|*
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|EVAL_TRACE
name|trace
argument_list|(
literal|"eval1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l
operator|=
name|eval2
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|nextarg
argument_list|(
literal|"&"
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|r
operator|=
name|eval2
argument_list|()
expr_stmt|;
if|if
condition|(
name|null
argument_list|(
name|l
argument_list|)
operator|||
name|null
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|freev
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|freev
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|l
operator|=
name|int_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freev
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* eval -- handles | */
end_comment

begin_function
name|VALUE
modifier|*
name|eval
parameter_list|()
block|{
name|VALUE
modifier|*
name|l
decl_stmt|;
name|VALUE
modifier|*
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|EVAL_TRACE
name|trace
argument_list|(
literal|"eval"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l
operator|=
name|eval1
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|nextarg
argument_list|(
literal|"|"
argument_list|)
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|r
operator|=
name|eval1
argument_list|()
expr_stmt|;
if|if
condition|(
name|null
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|freev
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|freev
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|l
operator|)
return|;
block|}
block|}
block|}
end_function

end_unit

