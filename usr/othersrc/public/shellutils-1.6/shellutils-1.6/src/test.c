begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU test program (ksb and mjb) */
end_comment

begin_comment
comment|/* Modified to run with the GNU shell by bfox. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1988, 1989, 1990, 1991 Free Software Foundation, Inc.     This file is part of GNU Bash, the Bourne Again SHell.     Bash is free software; you can redistribute it and/or modify it under    the terms of the GNU General Public License as published by the Free    Software Foundation; either version 2, or (at your option) any later    version.     Bash is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    for more details.     You should have received a copy of the GNU General Public License along    with Bash; see the file COPYING.  If not, write to the Free Software    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* Define STANDALONE to get the /bin/test version.  Otherwise, you get     the shell builtin version. */
end_comment

begin_comment
comment|/* #define STANDALONE */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STANDALONE
argument_list|)
end_if

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_include
include|#
directive|include
file|"filecntl.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* STANDALONE */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_IXUGO
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_IXUGO
value|0111
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* S_IXUGO */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _POSIX_VERSION */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NGROUPS_MAX
argument_list|)
operator|||
name|defined
argument_list|(
name|_SC_NGROUPS_MAX
argument_list|)
operator|||
name|defined
argument_list|(
name|NGROUPS
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_GETGROUPS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NGROUPS_MAX || _SC_NGROUPS_MAX || NGROUPS */
end_comment

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == ' ') || ((c) == '\t'))
end_define

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_define
define|#
directive|define
name|digit_value
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STANDALONE */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STREQ
argument_list|)
end_if

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)[0] == (b)[0]&& strcmp (a, b) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !STREQ */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|member
argument_list|)
end_if

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|(int)((c) ? index ((s), (c)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !member */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ultrix
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__386BSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|GETGROUPS_T
value|gid_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GETGROUPS_T
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_define
define|#
directive|define
name|GETGROUPS_T
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_POSIX_VERSION */
end_comment

begin_decl_stmt
specifier|extern
name|gid_t
name|getgid
argument_list|()
decl_stmt|,
name|getegid
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|uid_t
name|geteuid
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|R_OK
argument_list|)
end_if

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_define
define|#
directive|define
name|F_OK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* R_OK */
end_comment

begin_comment
comment|/* The following few defines control the truth and false output of each stage.    TRUE and FALSE are what we use to compute the final output value.    SHELL_BOOLEAN is the form which returns truth or falseness in shell terms.    TRUTH_OR is how to do logical or with TRUE and FALSE.    TRUTH_AND is how to do logical and with TRUE and FALSE..    Default is TRUE = 1, FALSE = 0, TRUTH_OR = a | b, TRUTH_AND = a& b,     SHELL_BOOLEAN = (!value). */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|SHELL_BOOLEAN
parameter_list|(
name|value
parameter_list|)
value|(!(value))
end_define

begin_define
define|#
directive|define
name|TRUTH_OR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) | (b))
end_define

begin_define
define|#
directive|define
name|TRUTH_AND
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)& (b))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STANDALONE
argument_list|)
end_if

begin_define
define|#
directive|define
name|test_exit
parameter_list|(
name|val
parameter_list|)
value|exit (val)
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|jmp_buf
name|test_exit_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|test_error_return
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|test_exit
parameter_list|(
name|val
parameter_list|)
value|test_error_return = val, longjmp (test_exit_buf, 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STANDALONE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset of the current argument in ARGV. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of arguments present in ARGV. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The argument list. */
end_comment

begin_function_decl
specifier|static
name|int
name|unop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|binop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unary_operator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|binary_operator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|two_arguments
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|three_arguments
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|posixtest
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|term
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|and
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|or
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|test_syntax_error
parameter_list|(
name|format
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* A wrapper for stat () which disallows pathnames that are empty strings. */
end_comment

begin_function
specifier|static
name|int
name|test_stat
parameter_list|(
name|path
parameter_list|,
name|finfo
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|path
operator|==
literal|'\0'
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|stat
argument_list|(
name|path
argument_list|,
name|finfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the same thing access(2) does, but use the effective uid and gid,    and don't make the mistake of telling root that any file is    executable. */
end_comment

begin_function
specifier|static
name|int
name|eaccess
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|extern
name|int
name|group_member
parameter_list|()
function_decl|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|static
name|int
name|euid
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|euid
operator|==
operator|-
literal|1
condition|)
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|euid
operator|==
literal|0
condition|)
block|{
comment|/* Root can read or write any file. */
if|if
condition|(
name|mode
operator|!=
name|X_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Root can execute any file that has any one of the execute 	 bits set. */
if|if
condition|(
name|st
operator|.
name|st_mode
operator|&
name|S_IXUGO
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_uid
operator|==
name|euid
condition|)
comment|/* owner */
name|mode
operator|<<=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|group_member
argument_list|(
name|st
operator|.
name|st_gid
argument_list|)
condition|)
name|mode
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_mode
operator|&
name|mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETGROUPS
argument_list|)
end_if

begin_comment
comment|/* The number of groups that this user is a member of. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ngroups
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GETGROUPS_T
modifier|*
name|group_array
init|=
operator|(
name|GETGROUPS_T
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_group_array_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETGROUPS */
end_comment

begin_comment
comment|/* Return non-zero if GID is one that we have in our groups list. */
end_comment

begin_function
name|int
name|group_member
parameter_list|(
name|gid
parameter_list|)
name|gid_t
name|gid
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_GETGROUPS
argument_list|)
return|return
operator|(
operator|(
name|gid
operator|==
name|getgid
argument_list|()
operator|)
operator|||
operator|(
name|gid
operator|==
name|getegid
argument_list|()
operator|)
operator|)
return|;
else|#
directive|else
specifier|register
name|int
name|i
decl_stmt|;
comment|/* getgroups () returns the number of elements that it was able to      place into the array.  We simply continue to call getgroups ()      until the number of elements placed into the array is smaller than      the physical size of the array. */
while|while
condition|(
name|ngroups
operator|==
name|default_group_array_size
condition|)
block|{
name|default_group_array_size
operator|+=
literal|64
expr_stmt|;
name|group_array
operator|=
operator|(
name|GETGROUPS_T
operator|*
operator|)
name|xrealloc
argument_list|(
name|group_array
argument_list|,
name|default_group_array_size
operator|*
sizeof|sizeof
argument_list|(
name|GETGROUPS_T
argument_list|)
argument_list|)
expr_stmt|;
name|ngroups
operator|=
name|getgroups
argument_list|(
name|default_group_array_size
argument_list|,
name|group_array
argument_list|)
expr_stmt|;
block|}
comment|/* In case of error, the user loses. */
if|if
condition|(
name|ngroups
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Search through the list looking for GID. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngroups
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|gid
operator|==
name|group_array
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_GETGROUPS */
block|}
end_function

begin_comment
comment|/* Increment our position in the argument list.  Check that we're not    past the end of the argument list.  This check is supressed if the    argument is FALSE.  Made a macro for efficiency. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_define
define|#
directive|define
name|advance
parameter_list|(
name|f
parameter_list|)
value|(++pos, f&& (pos< argc ? 0 : beyond()))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|advance
argument_list|)
end_if

begin_function
specifier|static
name|int
name|advance
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
operator|++
name|pos
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|pos
operator|>=
name|argc
condition|)
name|beyond
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* advance */
end_comment

begin_define
define|#
directive|define
name|unary_advance
parameter_list|()
value|(advance (1),++pos)
end_define

begin_comment
comment|/*  * beyond - call when we're beyond the end of the argument list (an  *	error condition)  */
end_comment

begin_function
specifier|static
name|int
name|beyond
parameter_list|()
block|{
name|test_syntax_error
argument_list|(
literal|"argument expected\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Syntax error for when an integer argument was expected, but    something else was found. */
end_comment

begin_function
specifier|static
name|void
name|integer_expected_error
parameter_list|(
name|pch
parameter_list|)
name|char
modifier|*
name|pch
decl_stmt|;
block|{
name|test_syntax_error
argument_list|(
literal|"integer expression expected %s\n"
argument_list|,
name|pch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the characters pointed to by STRING constitute a    valid number.  Stuff the converted number into RESULT if RESULT is    a non-null pointer to a long. */
end_comment

begin_function
specifier|static
name|int
name|isint
parameter_list|(
name|string
parameter_list|,
name|result
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|long
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|sign
decl_stmt|;
name|long
name|value
decl_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Skip leading whitespace characters. */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|string
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We allow leading `-' or `+'. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
operator|||
operator|*
name|string
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|digit
argument_list|(
name|string
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|digit
argument_list|(
operator|*
name|string
argument_list|)
condition|)
block|{
if|if
condition|(
name|result
condition|)
name|value
operator|=
operator|(
name|value
operator|*
literal|10
operator|)
operator|+
name|digit_value
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
comment|/* Skip trailing whitespace, if any. */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|string
operator|++
expr_stmt|;
comment|/* Error if not at end of string. */
if|if
condition|(
operator|*
name|string
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|result
condition|)
block|{
name|value
operator|*=
name|sign
expr_stmt|;
operator|*
name|result
operator|=
name|value
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the modification time of FILE, and stuff it into AGE, a pointer    to a long.  Return non-zero if successful, else zero. */
end_comment

begin_function
specifier|static
name|int
name|age_of
parameter_list|(
name|filename
parameter_list|,
name|age
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|long
modifier|*
name|age
decl_stmt|;
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|age
condition|)
operator|*
name|age
operator|=
name|finfo
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term - parse a term and return 1 or 0 depending on whether the term  *	evaluates to true or false, respectively.  *  * term ::=  *	'-'('h'|'d'|'f'|'r'|'s'|'w'|'c'|'b'|'p'|'u'|'g'|'k') filename  *	'-'('L'|'x') filename  * 	'-t' [ int ]  *	'-'('z'|'n') string  *	string  *	string ('!='|'=') string  *<int> '-'(eq|ne|le|lt|ge|gt)<int>  *	file '-'(nt|ot|ef) file  *	'('<expr> ')'  * int ::=  *	'-l' string  *	positive and negative integers  */
end_comment

begin_function
specifier|static
name|int
name|term
parameter_list|()
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|argc
condition|)
name|beyond
argument_list|()
expr_stmt|;
comment|/* Deal with leading "not"'s. */
if|if
condition|(
literal|'!'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
block|{
name|value
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|argc
operator|&&
literal|'!'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
block|{
name|advance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|value
operator|^=
operator|(
name|TRUE
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|^
operator|(
name|term
argument_list|()
operator|)
operator|)
return|;
block|}
comment|/* A paren-bracketed argument. */
if|if
condition|(
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|!
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
block|{
name|advance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|!=
literal|')'
operator|||
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
name|test_syntax_error
argument_list|(
literal|"')' expected, found %s\n"
argument_list|,
name|argv
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|value
operator|)
operator|)
return|;
block|}
comment|/* are there enough arguments left that this could be dyadic? */
if|if
condition|(
operator|(
operator|(
name|pos
operator|+
literal|3
operator|<=
name|argc
operator|)
operator|&&
name|binop
argument_list|(
name|argv
index|[
name|pos
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|pos
operator|+
literal|4
operator|<=
name|argc
operator|&&
name|STREQ
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|&&
name|binop
argument_list|(
name|argv
index|[
name|pos
operator|+
literal|2
index|]
argument_list|)
operator|)
operator|)
condition|)
name|value
operator|=
name|binary_operator
argument_list|()
expr_stmt|;
comment|/* Might be a switch type argument */
elseif|else
if|if
condition|(
literal|'-'
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|&&
literal|0
operator|==
name|argv
index|[
name|pos
index|]
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|unop
argument_list|(
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
name|value
operator|=
name|unary_operator
argument_list|()
expr_stmt|;
else|else
name|test_syntax_error
argument_list|(
literal|"%s: unary operator expected\n"
argument_list|,
name|argv
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|(
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|binary_operator
parameter_list|()
block|{
specifier|register
name|int
name|op
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|,
name|stat_spare
decl_stmt|;
name|long
name|int
name|l
decl_stmt|,
name|r
decl_stmt|,
name|value
decl_stmt|;
comment|/* Are the left and right integer expressions of the form '-l string'? */
name|int
name|l_is_l
decl_stmt|,
name|r_is_l
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|l_is_l
operator|=
literal|1
expr_stmt|;
name|op
operator|=
name|pos
operator|+
literal|2
expr_stmt|;
comment|/* Make sure that OP is still a valid binary operator. */
if|if
condition|(
operator|(
name|op
operator|>=
name|argc
operator|-
literal|1
operator|)
operator|||
operator|(
name|binop
argument_list|(
name|argv
index|[
name|op
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|test_syntax_error
argument_list|(
literal|"%s: binary operator expected\n"
argument_list|,
name|argv
index|[
name|op
index|]
argument_list|)
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|l_is_l
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|<
name|argc
operator|-
literal|2
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|r_is_l
operator|=
literal|1
expr_stmt|;
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|r_is_l
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* check for eq, nt, and stuff */
switch|switch
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|1
index|]
condition|)
block|{
default|default:
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* lt */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"before -lt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"after -lt"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|<
name|r
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* le */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"before -le"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"after -le"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|<=
name|r
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* gt integer greater than */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"before -gt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"after -gt"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|>
name|r
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ge - integer greater than or equal to */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"before -ge"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"after -ge"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|>=
name|r
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* nt - newer than */
name|pos
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|l_is_l
operator|||
name|r_is_l
condition|)
name|test_syntax_error
argument_list|(
literal|"-nt does not accept -l\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|age_of
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
operator|&&
name|age_of
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|>
name|r
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'e'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ne - integer not equal */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"before -ne"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"after -ne"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|!=
name|r
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'q'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* eq - integer equal */
if|if
condition|(
name|l_is_l
condition|)
name|l
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"before -eq"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_is_l
condition|)
name|r
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|op
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isint
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
name|integer_expected_error
argument_list|(
literal|"after -eq"
argument_list|)
expr_stmt|;
block|}
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|==
name|r
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|==
literal|'f'
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ef - hard link? */
name|pos
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|l_is_l
operator|||
name|r_is_l
condition|)
name|test_syntax_error
argument_list|(
literal|"-ef does not accept -l\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|stat_spare
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|stat_buf
operator|.
name|st_dev
operator|==
name|stat_spare
operator|.
name|st_dev
operator|&&
name|stat_buf
operator|.
name|st_ino
operator|==
name|stat_spare
operator|.
name|st_ino
operator|)
operator|)
return|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
literal|'t'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|2
index|]
operator|&&
literal|'\000'
operator|==
name|argv
index|[
name|op
index|]
index|[
literal|3
index|]
condition|)
block|{
comment|/* ot - older than */
name|pos
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|l_is_l
operator|||
name|r_is_l
condition|)
name|test_syntax_error
argument_list|(
literal|"-nt does not accept -l\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|age_of
argument_list|(
name|argv
index|[
name|op
operator|-
literal|1
index|]
argument_list|,
operator|&
name|l
argument_list|)
operator|&&
name|age_of
argument_list|(
name|argv
index|[
name|op
operator|+
literal|1
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|==
operator|(
name|l
operator|<
name|r
operator|)
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
break|break;
block|}
name|test_syntax_error
argument_list|(
literal|"unknown binary operator"
argument_list|,
name|argv
index|[
name|op
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
name|op
index|]
index|[
literal|0
index|]
operator|==
literal|'='
operator|&&
operator|!
name|argv
index|[
name|op
index|]
index|[
literal|1
index|]
condition|)
block|{
name|value
operator|=
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
name|argv
index|[
name|pos
operator|+
literal|2
index|]
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|op
index|]
argument_list|,
literal|"!="
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
operator|(
name|strcmp
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
name|argv
index|[
name|pos
operator|+
literal|2
index|]
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|unary_operator
parameter_list|()
block|{
name|long
name|r
decl_stmt|,
name|value
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
switch|switch
condition|(
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
condition|)
block|{
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* All of the following unary operators use unary_advance (), which 	 checks to make sure that there is an argument, and then advances 	 pos right past it.  This means that pos - 1 is the location of the 	 argument. */
case|case
literal|'a'
case|:
comment|/* file exists in the file system? */
case|case
literal|'e'
case|:
name|unary_advance
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
operator|!=
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
case|case
literal|'r'
case|:
comment|/* file is readable? */
name|unary_advance
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
operator|!=
name|eaccess
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
case|case
literal|'w'
case|:
comment|/* File is writeable? */
name|unary_advance
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
operator|!=
name|eaccess
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
name|W_OK
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
case|case
literal|'x'
case|:
comment|/* File is executable? */
name|unary_advance
argument_list|()
expr_stmt|;
name|value
operator|=
operator|-
literal|1
operator|!=
name|eaccess
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
name|X_OK
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
case|case
literal|'O'
case|:
comment|/* File is owned by you? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|geteuid
argument_list|()
operator|==
name|stat_buf
operator|.
name|st_uid
operator|)
operator|)
return|;
case|case
literal|'G'
case|:
comment|/* File is owned by your group? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|getegid
argument_list|()
operator|==
name|stat_buf
operator|.
name|st_gid
operator|)
operator|)
return|;
case|case
literal|'f'
case|:
comment|/* File is a file? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Under POSIX, -f is true if the given file exists 	 and is a regular file. */
return|return
operator|(
name|TRUE
operator|==
operator|(
operator|(
name|S_ISREG
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|)
operator|)
return|;
case|case
literal|'d'
case|:
comment|/* File is a directory? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_ISDIR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
return|;
case|case
literal|'s'
case|:
comment|/* File has something in it? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|stat_buf
operator|.
name|st_size
operator|>
operator|(
name|off_t
operator|)
literal|0
operator|)
operator|)
return|;
case|case
literal|'S'
case|:
comment|/* File is a socket? */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISSOCK
argument_list|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|#
directive|else
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_ISSOCK
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* S_ISSOCK */
case|case
literal|'c'
case|:
comment|/* File is character special? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_ISCHR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
return|;
case|case
literal|'b'
case|:
comment|/* File is block special? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_ISBLK
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
return|;
case|case
literal|'p'
case|:
comment|/* File is a named pipe? */
name|unary_advance
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|S_ISFIFO
return|return
operator|(
name|FALSE
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_ISFIFO
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* S_ISFIFO */
case|case
literal|'L'
case|:
comment|/* Same as -h  */
comment|/*FALLTHROUGH*/
case|case
literal|'h'
case|:
comment|/* File is a symbolic link? */
name|unary_advance
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|S_ISLNK
return|return
operator|(
name|FALSE
operator|)
return|;
else|#
directive|else
comment|/* An empty filename is not a valid pathname. */
if|if
condition|(
operator|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|lstat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|S_ISLNK
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* S_IFLNK */
case|case
literal|'u'
case|:
comment|/* File is setuid? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|!=
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_ISUID
operator|)
operator|)
operator|)
return|;
case|case
literal|'g'
case|:
comment|/* File is setgid? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|!=
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|)
operator|)
operator|)
return|;
case|case
literal|'k'
case|:
comment|/* File has sticky bit set? */
name|unary_advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|test_stat
argument_list|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISVTX
argument_list|)
comment|/* This is not Posix, and is not defined on some Posix systems. */
return|return
operator|(
name|FALSE
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|TRUE
operator|==
operator|(
literal|0
operator|!=
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_ISVTX
operator|)
operator|)
operator|)
return|;
endif|#
directive|endif
case|case
literal|'t'
case|:
comment|/* File (fd) is a terminal?  (fd) defaults to stdout. */
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|argc
operator|&&
name|isint
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|isatty
argument_list|(
operator|(
name|int
operator|)
name|r
argument_list|)
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|==
operator|(
name|isatty
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
return|;
case|case
literal|'n'
case|:
comment|/* True if arg has some length. */
name|unary_advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
operator|)
return|;
case|case
literal|'z'
case|:
comment|/* True if arg has no length. */
name|unary_advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|==
operator|(
name|argv
index|[
name|pos
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * and:  *	term  *	term '-a' and  */
end_comment

begin_function
specifier|static
name|int
name|and
parameter_list|()
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|term
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pos
operator|<
name|argc
operator|)
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|TRUTH_AND
argument_list|(
name|value
argument_list|,
name|and
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * or:  *	and  *	and '-o' or  */
end_comment

begin_function
specifier|static
name|int
name|or
parameter_list|()
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|and
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pos
operator|<
name|argc
operator|)
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|advance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|TRUTH_OR
argument_list|(
name|value
argument_list|,
name|or
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|==
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * expr:  *	or  */
end_comment

begin_function
specifier|static
name|int
name|expr
parameter_list|()
block|{
if|if
condition|(
name|pos
operator|>=
name|argc
condition|)
name|beyond
argument_list|()
expr_stmt|;
return|return
operator|(
name|FALSE
operator|^
operator|(
name|or
argument_list|()
operator|)
operator|)
return|;
comment|/* Same with this. */
block|}
end_function

begin_comment
comment|/* Return TRUE if S is one of the test command's binary operators. */
end_comment

begin_function
specifier|static
name|int
name|binop
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"="
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"!="
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-nt"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-ot"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-ef"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-eq"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-ne"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-lt"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-le"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-gt"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|s
argument_list|,
literal|"-ge"
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if OP is one of the test command's unary operators. */
end_comment

begin_function
specifier|static
name|int
name|unop
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
return|return
operator|(
name|member
argument_list|(
name|op
argument_list|,
literal|"abcdefgkLhprsStuwxOGnz"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|two_arguments
parameter_list|()
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
literal|"!"
argument_list|)
condition|)
name|value
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|pos
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|argv
index|[
name|pos
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|unop
argument_list|(
name|argv
index|[
name|pos
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
name|value
operator|=
name|unary_operator
argument_list|()
expr_stmt|;
else|else
name|test_syntax_error
argument_list|(
literal|"%s: unary operator expected\n"
argument_list|,
name|argv
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|beyond
argument_list|()
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|three_arguments
parameter_list|()
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
literal|"!"
argument_list|)
condition|)
block|{
name|advance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
operator|!
name|two_arguments
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binop
argument_list|(
name|argv
index|[
name|pos
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|value
operator|=
name|binary_operator
argument_list|()
expr_stmt|;
name|pos
operator|=
name|argc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|STREQ
argument_list|(
name|argv
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
literal|"-a"
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|argv
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
literal|"-o"
argument_list|)
operator|)
operator|||
operator|(
name|argv
index|[
name|pos
index|]
index|[
literal|0
index|]
operator|==
literal|'('
operator|)
condition|)
name|value
operator|=
name|expr
argument_list|()
expr_stmt|;
else|else
name|test_syntax_error
argument_list|(
literal|"%s: binary operator expected\n"
argument_list|,
name|argv
index|[
name|pos
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is an implementation of a Posix.2 proposal by David Korn. */
end_comment

begin_function
specifier|static
name|int
name|posixtest
parameter_list|()
block|{
name|int
name|value
decl_stmt|;
switch|switch
condition|(
name|argc
operator|-
literal|1
condition|)
comment|/* one extra passed in */
block|{
case|case
literal|0
case|:
name|value
operator|=
name|FALSE
expr_stmt|;
name|pos
operator|=
name|argc
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|value
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|pos
operator|=
name|argc
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|value
operator|=
name|two_arguments
argument_list|()
expr_stmt|;
name|pos
operator|=
name|argc
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|value
operator|=
name|three_arguments
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|STREQ
argument_list|(
name|argv
index|[
name|pos
index|]
argument_list|,
literal|"!"
argument_list|)
condition|)
block|{
name|advance
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
operator|!
name|three_arguments
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|5
case|:
default|default:
name|value
operator|=
name|expr
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * [:  *	'[' expr ']'  * test:  *	test expr  */
end_comment

begin_function
name|int
if|#
directive|if
name|defined
argument_list|(
name|STANDALONE
argument_list|)
name|main
parameter_list|(
name|margc
parameter_list|,
name|margv
parameter_list|)
else|#
directive|else
function|test_command
parameter_list|(
name|margc
parameter_list|,
name|margv
parameter_list|)
endif|#
directive|endif
comment|/* STANDALONE */
name|int
name|margc
decl_stmt|;
name|char
modifier|*
modifier|*
name|margv
decl_stmt|;
block|{
specifier|auto
name|int
name|value
decl_stmt|;
name|int
name|expr
parameter_list|()
function_decl|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STANDALONE
argument_list|)
name|int
name|code
decl_stmt|;
name|code
operator|=
name|setjmp
argument_list|(
name|test_exit_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
return|return
operator|(
name|test_error_return
operator|)
return|;
else|#
directive|else
comment|/* STANDALONE */
name|program_name
operator|=
name|margv
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* STANDALONE */
name|argv
operator|=
name|margv
expr_stmt|;
if|if
condition|(
name|margv
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|margv
index|[
literal|0
index|]
argument_list|,
literal|"["
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|--
name|margc
expr_stmt|;
if|if
condition|(
name|margc
operator|<
literal|2
condition|)
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|margv
index|[
name|margc
index|]
operator|&&
name|strcmp
argument_list|(
name|margv
index|[
name|margc
index|]
argument_list|,
literal|"]"
argument_list|)
operator|!=
literal|0
condition|)
name|test_syntax_error
argument_list|(
literal|"missing `]'\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|argc
operator|=
name|margc
expr_stmt|;
name|pos
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|argc
condition|)
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|posixtest
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|argc
condition|)
name|test_syntax_error
argument_list|(
literal|"too many arguments\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|test_exit
argument_list|(
name|SHELL_BOOLEAN
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

