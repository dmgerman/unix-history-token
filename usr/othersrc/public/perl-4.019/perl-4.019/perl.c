begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|char
name|rcsid
index|[]
init|=
literal|"$RCSfile: perl.c,v $$Revision: 4.0.1.6 $$Date: 91/11/11 16:38:45 $\nPatch level: ###\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log:	perl.c,v $  * Revision 4.0.1.6  91/11/11  16:38:45  lwall  * patch19: default arg for shift was wrong after first subroutine definition  * patch19: op/regexp.t failed from missing arg to bcmp()  *   * Revision 4.0.1.5  91/11/05  18:03:32  lwall  * patch11: random cleanup  * patch11: $0 was being truncated at times  * patch11: cppstdin now installed outside of source directory  * patch11: -P didn't allow use of #elif or #undef  * patch11: prepared for ctype implementations that don't define isascii()  * patch11: added eval {}  * patch11: eval confused by string containing null  *   * Revision 4.0.1.4  91/06/10  01:23:07  lwall  * patch10: perl -v printed incorrect copyright notice  *   * Revision 4.0.1.3  91/06/07  11:40:18  lwall  * patch4: changed old $^P to $^X  *   * Revision 4.0.1.2  91/06/07  11:26:16  lwall  * patch4: new copyright notice  * patch4: added $^P variable to control calling of perldb routines  * patch4: added $^F variable to specify maximum system fd, default 2  * patch4: debugger lost track of lines in eval  *   * Revision 4.0.1.1  91/04/11  17:49:05  lwall  * patch1: fixed undefined environ problem  *   * Revision 4.0  91/03/20  01:37:44  lwall  * 4.0 baseline.  *   */
end_comment

begin_comment
comment|/*SUPPRESS 560*/
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"perly.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|"patchlev.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IAMSUID
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DOSUID
end_ifndef

begin_define
define|#
directive|define
name|DOSUID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DOSUID
end_ifdef

begin_undef
undef|#
directive|undef
name|DOSUID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|moreswitches
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cddir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|minus_c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|patchlevel
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nrs
init|=
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nrschar
init|=
literal|'\n'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* final char of rs, or 0777 if none */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrslen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|env
parameter_list|)
specifier|register
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|scriptname
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|bool
name|dosearch
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|DOSUID
name|char
modifier|*
name|validarg
init|=
literal|""
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
ifdef|#
directive|ifdef
name|IAMSUID
undef|#
directive|undef
name|IAMSUID
name|fatal
argument_list|(
literal|"suidperl is no longer needed since the kernel can now execute\n\ setuid perl scripts securely.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|origargv
operator|=
name|argv
expr_stmt|;
name|origargc
operator|=
name|argc
expr_stmt|;
name|origenviron
operator|=
name|environ
expr_stmt|;
name|uid
operator|=
operator|(
name|int
operator|)
name|getuid
argument_list|()
expr_stmt|;
name|euid
operator|=
operator|(
name|int
operator|)
name|geteuid
argument_list|()
expr_stmt|;
name|gid
operator|=
operator|(
name|int
operator|)
name|getgid
argument_list|()
expr_stmt|;
name|egid
operator|=
operator|(
name|int
operator|)
name|getegid
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|patchlevel
argument_list|,
literal|"%3.3s%2.2d"
argument_list|,
name|index
argument_list|(
name|rcsid
argument_list|,
literal|'4'
argument_list|)
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
comment|/*      * There is no way we can refer to them from Perl so close them to save      * space.  The other alternative would be to provide STDAUX and STDPRN      * filehandles.      */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdaux
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdprn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|do_undump
condition|)
block|{
name|origfilename
operator|=
name|savestr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|do_undump
operator|=
literal|0
expr_stmt|;
name|loop_ptr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* start label stack again */
goto|goto
name|just_doit
goto|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|index
argument_list|(
name|rcsid
argument_list|,
literal|'#'
argument_list|)
argument_list|,
literal|"%d\n"
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
name|linestr
operator|=
name|Str_new
argument_list|(
literal|65
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|linestr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
name|str_make
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* first used for -I flags */
name|curstash
operator|=
name|defstash
operator|=
name|hnew
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|curstname
operator|=
name|str_make
argument_list|(
literal|"main"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|stab_xhash
argument_list|(
name|stabent
argument_list|(
literal|"_main"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
operator|=
name|defstash
expr_stmt|;
name|defstash
operator|->
name|tbl_name
operator|=
literal|"main"
expr_stmt|;
name|incstab
operator|=
name|hadd
argument_list|(
name|aadd
argument_list|(
name|stabent
argument_list|(
literal|"INC"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|incstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
operator|!
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
break|break;
ifdef|#
directive|ifdef
name|DOSUID
if|if
condition|(
operator|*
name|validarg
condition|)
name|validarg
operator|=
literal|" PHOOEY "
expr_stmt|;
else|else
name|validarg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'a'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'i'
case|:
case|case
literal|'l'
case|:
case|case
literal|'n'
case|:
case|case
literal|'p'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
if|if
condition|(
name|s
operator|=
name|moreswitches
argument_list|(
name|s
argument_list|)
condition|)
goto|goto
name|reswitch
goto|;
break|break;
case|case
literal|'e'
case|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -e allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|e_fp
condition|)
block|{
name|e_tmpname
operator|=
name|savestr
argument_list|(
name|TMPPATH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|e_tmpname
argument_list|)
expr_stmt|;
name|e_fp
operator|=
name|fopen
argument_list|(
name|e_tmpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e_fp
condition|)
name|fatal
argument_list|(
literal|"Cannot open temporary file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|fputs
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|e_fp
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|e_fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -I allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
condition|)
block|{
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -P allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|preprocess
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'s'
case|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -s allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|doswitches
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'S'
case|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -S allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dosearch
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'x'
case|:
name|doextract
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|cddir
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
goto|goto
name|switch_end
goto|;
case|case
literal|0
case|:
break|break;
default|default:
name|fatal
argument_list|(
literal|"Unrecognized switch: -%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|switch_end
label|:
name|scriptname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|e_fp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e_fp
argument_list|)
expr_stmt|;
name|argc
operator|++
operator|,
name|argv
operator|--
expr_stmt|;
name|scriptname
operator|=
name|e_tmpname
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MSDOS
define|#
directive|define
name|PERLLIB_SEP
value|';'
else|#
directive|else
define|#
directive|define
name|PERLLIB_SEP
value|':'
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TAINT
comment|/* Can't allow arbitrary PERLLIB in setuid script */
block|{
name|char
modifier|*
name|s2
init|=
name|getenv
argument_list|(
literal|"PERLLIB"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s2
condition|)
block|{
comment|/* Break at all separators */
while|while
condition|(
operator|*
name|s2
condition|)
block|{
comment|/* First, skip any consecutive separators */
while|while
condition|(
operator|*
name|s2
operator|==
name|PERLLIB_SEP
condition|)
block|{
comment|/* Uncomment the next line for PATH semantics */
comment|/* (void)apush(stab_array(incstab),str_make(".",1)); */
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|s2
argument_list|,
name|PERLLIB_SEP
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
name|s2
argument_list|,
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
name|s2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* TAINT */
ifndef|#
directive|ifndef
name|PRIVLIB
define|#
directive|define
name|PRIVLIB
value|"/usr/local/lib/perl"
endif|#
directive|endif
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
name|PRIVLIB
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
operator|&
name|str_no
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
operator|&
name|str_yes
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
comment|/* open script */
if|if
condition|(
name|scriptname
operator|==
name|Nullch
condition|)
ifdef|#
directive|ifdef
name|MSDOS
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|moreswitches
argument_list|(
literal|"v"
argument_list|)
expr_stmt|;
name|scriptname
operator|=
literal|"-"
expr_stmt|;
block|}
else|#
directive|else
name|scriptname
operator|=
literal|"-"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dosearch
operator|&&
operator|!
name|index
argument_list|(
name|scriptname
argument_list|,
literal|'/'
argument_list|)
operator|&&
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|xfound
init|=
name|Nullch
decl_stmt|,
modifier|*
name|xfailed
init|=
name|Nullch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bufend
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
ifndef|#
directive|ifndef
name|MSDOS
name|s
operator|=
name|cpytill
argument_list|(
name|tokenbuf
argument_list|,
name|s
argument_list|,
name|bufend
argument_list|,
literal|':'
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|len
operator|=
literal|0
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|';'
condition|;
name|tokenbuf
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|s
operator|++
control|)
empty_stmt|;
name|tokenbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
name|len
operator|&&
name|tokenbuf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
else|#
directive|else
if|if
condition|(
name|len
operator|&&
name|tokenbuf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tokenbuf
operator|+
name|len
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tokenbuf
operator|+
name|len
argument_list|,
name|scriptname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for %s\n"
argument_list|,
name|tokenbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|tokenbuf
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
comment|/* not there? */
continue|continue;
if|if
condition|(
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|cando
argument_list|(
name|S_IRUSR
argument_list|,
name|TRUE
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|&&
name|cando
argument_list|(
name|S_IXUSR
argument_list|,
name|TRUE
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
name|xfound
operator|=
name|tokenbuf
expr_stmt|;
comment|/* bingo! */
break|break;
block|}
if|if
condition|(
operator|!
name|xfailed
condition|)
name|xfailed
operator|=
name|savestr
argument_list|(
name|tokenbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xfound
condition|)
name|fatal
argument_list|(
literal|"Can't execute %s"
argument_list|,
name|xfailed
condition|?
name|xfailed
else|:
name|scriptname
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfailed
condition|)
name|Safefree
argument_list|(
name|xfailed
argument_list|)
expr_stmt|;
name|scriptname
operator|=
name|savestr
argument_list|(
name|xfound
argument_list|)
expr_stmt|;
block|}
name|fdpid
operator|=
name|anew
argument_list|(
name|Nullstab
argument_list|)
expr_stmt|;
comment|/* for remembering popen pids by fd */
name|pidstatus
operator|=
name|hnew
argument_list|(
name|COEFFSIZE
argument_list|)
expr_stmt|;
comment|/* for remembering status of dead pids */
name|origfilename
operator|=
name|savestr
argument_list|(
name|scriptname
argument_list|)
expr_stmt|;
name|curcmd
operator|->
name|c_filestab
operator|=
name|fstab
argument_list|(
name|origfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|origfilename
argument_list|,
literal|"-"
argument_list|)
condition|)
name|scriptname
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|preprocess
condition|)
block|{
name|char
modifier|*
name|cpp
init|=
name|CPPSTDIN
decl_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|cpp
argument_list|,
literal|"cppstdin"
argument_list|)
condition|)
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|SCRIPTDIR
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"%s"
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"-I"
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|PRIVLIB
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\ %ssed %s -e '/^[^#]/b' \  -e '/^#[ 	]*include[ 	]/b' \  -e '/^#[ 	]*define[ 	]/b' \  -e '/^#[ 	]*if[ 	]/b' \  -e '/^#[ 	]*ifdef[ 	]/b' \  -e '/^#[ 	]*ifndef[ 	]/b' \  -e '/^#[ 	]*else/b' \  -e '/^#[ 	]*elif[ 	]/b' \  -e '/^#[ 	]*undef[ 	]/b' \  -e '/^#[ 	]*endif/b' \  -e 's/^[ 	]*#.*//' \  %s | %s -C %s %s"
argument_list|,
ifdef|#
directive|ifdef
name|MSDOS
literal|""
argument_list|,
else|#
directive|else
literal|"/bin/"
argument_list|,
endif|#
directive|endif
operator|(
name|doextract
condition|?
literal|"-e '1,/^#/d\n'"
else|:
literal|""
operator|)
argument_list|,
name|scriptname
argument_list|,
name|tokenbuf
argument_list|,
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
name|CPPMINUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|64
condition|)
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|doextract
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|IAMSUID
comment|/* actually, this is caught earlier */
if|if
condition|(
name|euid
operator|!=
name|uid
operator|&&
operator|!
name|euid
condition|)
comment|/* if running suidperl */
ifdef|#
directive|ifdef
name|HAS_SETEUID
operator|(
name|void
operator|)
name|seteuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
comment|/* musn't stay setuid root */
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
operator|(
name|void
operator|)
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
name|uid
argument_list|)
expr_stmt|;
else|#
directive|else
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* IAMSUID */
name|rsfp
operator|=
name|mypopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|scriptname
condition|)
block|{
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"Can't take set-id script from stdin"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rsfp
operator|=
name|stdin
expr_stmt|;
block|}
else|else
name|rsfp
operator|=
name|fopen
argument_list|(
name|scriptname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FILE
operator|*
operator|)
name|rsfp
operator|==
name|Nullfp
condition|)
block|{
ifdef|#
directive|ifdef
name|DOSUID
ifndef|#
directive|ifndef
name|IAMSUID
comment|/* in case script is not readable before setuid */
if|if
condition|(
name|euid
operator|&&
name|stat
argument_list|(
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|&&
name|statbuf
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/sperl%s"
argument_list|,
name|BIN
argument_list|,
name|patchlevel
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|buf
argument_list|,
name|origargv
argument_list|)
expr_stmt|;
comment|/* try again */
name|fatal
argument_list|(
literal|"Can't do setuid\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|fatal
argument_list|(
literal|"Can't open perl script \"%s\": %s\n"
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* free -I directories */
name|str
operator|=
name|Nullstr
expr_stmt|;
comment|/* do we need to emulate setuid on scripts? */
comment|/* This code is for those BSD systems that have setuid #! scripts disabled      * in the kernel because of a security problem.  Merely defining DOSUID      * in perl will not fix that problem, but if you have disabled setuid      * scripts in the kernel, this will attempt to emulate setuid and setgid      * on scripts that have those now-otherwise-useless bits set.  The setuid      * root version must be called suidperl or sperlN.NNN.  If regular perl      * discovers that it has opened a setuid script, it calls suidperl with      * the same argv that it had.  If suidperl finds that the script it has      * just opened is NOT setuid root, it sets the effective uid back to the      * uid.  We don't just make perl setuid root because that loses the      * effective uid we had before invoking perl, if it was different from the      * uid.      *      * DOSUID must be defined in both perl and suidperl, and IAMSUID must      * be defined in suidperl only.  suidperl must be setuid root.  The      * Configure script will set this up for you if you want it.      *      * There is also the possibility of have a script which is running      * set-id due to a C wrapper.  We want to do the TAINT checks      * on these set-id scripts, but don't want to have the overhead of      * them in normal perl, and can't use suidperl because it will lose      * the effective uid info, so we have an additional non-setuid root      * version called taintperl or tperlN.NNN that just does the TAINT checks.      */
ifdef|#
directive|ifdef
name|DOSUID
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|rsfp
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
comment|/* normal stat is insecure */
name|fatal
argument_list|(
literal|"Can't stat script \"%s\""
argument_list|,
name|origfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|statbuf
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|IAMSUID
ifndef|#
directive|ifndef
name|HAS_SETREUID
comment|/* On this access check to make sure the directories are readable, 	 * there is actually a small window that the user could use to make 	 * filename point to an accessible directory.  So there is a faint 	 * chance that someone could execute a setuid script down in a 	 * non-accessible directory.  I don't know what to do about that. 	 * But I don't think it's too important.  The manual lies when 	 * it says access() is useful in setuid programs. 	 */
if|if
condition|(
name|access
argument_list|(
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
literal|1
argument_list|)
condition|)
comment|/*double check*/
name|fatal
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If we can swap euid and uid, then we can determine access rights 	 * with a simple stat of the file, and then compare device and 	 * inode to make sure we did stat() on the same file we opened. 	 * Then we just have to make sure he or she can execute it. 	 */
block|{
name|struct
name|stat
name|tmpstatbuf
decl_stmt|;
if|if
condition|(
name|setreuid
argument_list|(
name|euid
argument_list|,
name|uid
argument_list|)
operator|<
literal|0
operator|||
name|getuid
argument_list|()
operator|!=
name|euid
operator|||
name|geteuid
argument_list|()
operator|!=
name|uid
condition|)
name|fatal
argument_list|(
literal|"Can't swap uid and euid"
argument_list|)
expr_stmt|;
comment|/* really paranoid */
if|if
condition|(
name|stat
argument_list|(
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
operator|&
name|tmpstatbuf
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
comment|/* testing full pathname here */
if|if
condition|(
name|tmpstatbuf
operator|.
name|st_dev
operator|!=
name|statbuf
operator|.
name|st_dev
operator|||
name|tmpstatbuf
operator|.
name|st_ino
operator|!=
name|statbuf
operator|.
name|st_ino
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsfp
operator|=
name|mypopen
argument_list|(
literal|"/bin/mail root"
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
comment|/* heh, heh */
name|fprintf
argument_list|(
name|rsfp
argument_list|,
literal|"User %d tried to run dev %d ino %d in place of dev %d ino %d!\n\ (Filename of set-id script was %s, uid %d gid %d.)\n\nSincerely,\nperl\n"
argument_list|,
name|uid
argument_list|,
name|tmpstatbuf
operator|.
name|st_dev
argument_list|,
name|tmpstatbuf
operator|.
name|st_ino
argument_list|,
name|statbuf
operator|.
name|st_dev
argument_list|,
name|statbuf
operator|.
name|st_ino
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
name|statbuf
operator|.
name|st_uid
argument_list|,
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mypclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
block|}
name|fatal
argument_list|(
literal|"Permission denied\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setreuid
argument_list|(
name|uid
argument_list|,
name|euid
argument_list|)
operator|<
literal|0
operator|||
name|getuid
argument_list|()
operator|!=
name|uid
operator|||
name|geteuid
argument_list|()
operator|!=
name|euid
condition|)
name|fatal
argument_list|(
literal|"Can't reswap uid and euid"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cando
argument_list|(
name|S_IXUSR
argument_list|,
name|FALSE
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
comment|/* can real uid exec? */
name|fatal
argument_list|(
literal|"Permission denied\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_SETREUID */
endif|#
directive|endif
comment|/* IAMSUID */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
if|if
condition|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IWOTH
condition|)
name|fatal
argument_list|(
literal|"Setuid/gid script is writable by world"
argument_list|)
expr_stmt|;
name|doswitches
operator|=
name|FALSE
expr_stmt|;
comment|/* -s is insecure in suid */
name|curcmd
operator|->
name|c_line
operator|++
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|,
name|rsfp
argument_list|)
operator|==
name|Nullch
operator|||
name|strnNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"#!"
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* required even on Sys V */
name|fatal
argument_list|(
literal|"No #! line"
argument_list|)
expr_stmt|;
name|s
operator|=
name|tokenbuf
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strnNE
argument_list|(
name|s
operator|-
literal|4
argument_list|,
literal|"perl"
argument_list|,
literal|4
argument_list|)
operator|&&
name|strnNE
argument_list|(
name|s
operator|-
literal|9
argument_list|,
literal|"perl"
argument_list|,
literal|4
argument_list|)
condition|)
comment|/* sanity check */
name|fatal
argument_list|(
literal|"Not a perl script"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* 	 * #! arg must be what we saw above.  They can invoke it by 	 * mentioning suidperl explicitly, but they may not add any strange 	 * arguments beyond what #! says if they do invoke suidperl that way. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|validarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|validarg
argument_list|,
literal|" PHOOEY "
argument_list|)
operator|||
name|strnNE
argument_list|(
name|s
argument_list|,
name|validarg
argument_list|,
name|len
argument_list|)
operator|||
operator|!
name|isSPACE
argument_list|(
name|s
index|[
name|len
index|]
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Args must match #! line"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IAMSUID
if|if
condition|(
name|euid
operator|!=
name|uid
operator|&&
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_ISUID
operator|)
operator|&&
name|euid
operator|==
name|statbuf
operator|.
name|st_uid
condition|)
if|if
condition|(
operator|!
name|do_undump
condition|)
name|fatal
argument_list|(
literal|"YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\ FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IAMSUID */
if|if
condition|(
name|euid
condition|)
block|{
comment|/* oops, we're not the setuid root perl */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IAMSUID
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/sperl%s"
argument_list|,
name|BIN
argument_list|,
name|patchlevel
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|buf
argument_list|,
name|origargv
argument_list|)
expr_stmt|;
comment|/* try again */
endif|#
directive|endif
name|fatal
argument_list|(
literal|"Can't do setuid\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|&&
name|statbuf
operator|.
name|st_gid
operator|!=
name|egid
condition|)
ifdef|#
directive|ifdef
name|HAS_SETEGID
operator|(
name|void
operator|)
name|setegid
argument_list|(
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREGID
operator|(
name|void
operator|)
name|setregid
argument_list|(
operator|(
name|GIDTYPE
operator|)
operator|-
literal|1
argument_list|,
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
else|#
directive|else
name|setgid
argument_list|(
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_ISUID
condition|)
block|{
if|if
condition|(
name|statbuf
operator|.
name|st_uid
operator|!=
name|euid
condition|)
ifdef|#
directive|ifdef
name|HAS_SETEUID
operator|(
name|void
operator|)
name|seteuid
argument_list|(
name|statbuf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
comment|/* all that for this */
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
operator|(
name|void
operator|)
name|setreuid
argument_list|(
operator|(
name|UIDTYPE
operator|)
operator|-
literal|1
argument_list|,
name|statbuf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
else|#
directive|else
name|setuid
argument_list|(
name|statbuf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|uid
condition|)
comment|/* oops, mustn't run as root */
ifdef|#
directive|ifdef
name|HAS_SETEUID
operator|(
name|void
operator|)
name|seteuid
argument_list|(
operator|(
name|UIDTYPE
operator|)
name|uid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
operator|(
name|void
operator|)
name|setreuid
argument_list|(
operator|(
name|UIDTYPE
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|UIDTYPE
operator|)
name|uid
argument_list|)
expr_stmt|;
else|#
directive|else
name|setuid
argument_list|(
operator|(
name|UIDTYPE
operator|)
name|uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|uid
operator|=
operator|(
name|int
operator|)
name|getuid
argument_list|()
expr_stmt|;
name|euid
operator|=
operator|(
name|int
operator|)
name|geteuid
argument_list|()
expr_stmt|;
name|gid
operator|=
operator|(
name|int
operator|)
name|getgid
argument_list|()
expr_stmt|;
name|egid
operator|=
operator|(
name|int
operator|)
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cando
argument_list|(
name|S_IXUSR
argument_list|,
name|TRUE
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Permission denied\n"
argument_list|)
expr_stmt|;
comment|/* they can't do this */
block|}
ifdef|#
directive|ifdef
name|IAMSUID
elseif|else
if|if
condition|(
name|preprocess
condition|)
name|fatal
argument_list|(
literal|"-P not allowed for setuid/setgid script\n"
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"Script is not setuid/setgid in suidperl\n"
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|TAINT
comment|/* we aren't taintperl or suidperl */
comment|/* script has a wrapper--can't run suidperl or we lose euid */
elseif|else
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/tperl%s"
argument_list|,
name|BIN
argument_list|,
name|patchlevel
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|buf
argument_list|,
name|origargv
argument_list|)
expr_stmt|;
comment|/* try again */
name|fatal
argument_list|(
literal|"Can't run setuid script with taint checks"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TAINT */
endif|#
directive|endif
comment|/* IAMSUID */
else|#
directive|else
comment|/* !DOSUID */
ifndef|#
directive|ifndef
name|TAINT
comment|/* we aren't taintperl or suidperl */
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
block|{
comment|/* (suidperl doesn't exist, in fact) */
ifndef|#
directive|ifndef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
name|fstat
argument_list|(
name|fileno
argument_list|(
name|rsfp
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
comment|/* may be either wrapped or real suid */
if|if
condition|(
operator|(
name|euid
operator|!=
name|uid
operator|&&
name|euid
operator|==
name|statbuf
operator|.
name|st_uid
operator|&&
name|statbuf
operator|.
name|st_mode
operator|&
name|S_ISUID
operator|)
operator|||
operator|(
name|egid
operator|!=
name|gid
operator|&&
name|egid
operator|==
name|statbuf
operator|.
name|st_gid
operator|&&
name|statbuf
operator|.
name|st_mode
operator|&
name|S_ISGID
operator|)
condition|)
if|if
condition|(
operator|!
name|do_undump
condition|)
name|fatal
argument_list|(
literal|"YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\ FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SETUID_SCRIPTS_ARE_SECURE_NOW */
comment|/* not set-id, must be wrapped */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/tperl%s"
argument_list|,
name|BIN
argument_list|,
name|patchlevel
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|buf
argument_list|,
name|origargv
argument_list|)
expr_stmt|;
comment|/* try again */
name|fatal
argument_list|(
literal|"Can't run setuid script with taint checks"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TAINT */
endif|#
directive|endif
comment|/* DOSUID */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IAMSUID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TAINT
argument_list|)
comment|/* skip forward in input to the real script? */
while|while
condition|(
name|doextract
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
name|fatal
argument_list|(
literal|"No Perl script found in input\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'!'
operator|&&
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl"
argument_list|)
condition|)
block|{
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|rsfp
argument_list|)
expr_stmt|;
comment|/* to keep line count right */
name|doextract
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl -"
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|6
expr_stmt|;
comment|/*SUPPRESS 530*/
while|while
condition|(
name|s
operator|=
name|moreswitches
argument_list|(
name|s
argument_list|)
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|cddir
operator|&&
name|chdir
argument_list|(
name|cddir
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Can't chdir to %s"
argument_list|,
name|cddir
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !defined(IAMSUID)&& !defined(TAINT) */
name|defstab
operator|=
name|stabent
argument_list|(
literal|"_"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|subname
operator|=
name|str_make
argument_list|(
literal|"main"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
block|{
name|debstash
operator|=
name|hnew
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|stab_xhash
argument_list|(
name|stabent
argument_list|(
literal|"_DB"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
operator|=
name|debstash
expr_stmt|;
name|curstash
operator|=
name|debstash
expr_stmt|;
name|dbargs
operator|=
name|stab_xarray
argument_list|(
name|aadd
argument_list|(
operator|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"args"
argument_list|,
name|TRUE
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|dbargs
operator|->
name|ary_flags
operator|=
literal|0
expr_stmt|;
name|DBstab
operator|=
name|stabent
argument_list|(
literal|"DB"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DBstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|DBline
operator|=
name|stabent
argument_list|(
literal|"dbline"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DBline
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|DBsub
operator|=
name|hadd
argument_list|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"sub"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|DBsingle
operator|=
name|stab_val
argument_list|(
operator|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"single"
argument_list|,
name|TRUE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|DBtrace
operator|=
name|stab_val
argument_list|(
operator|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"trace"
argument_list|,
name|TRUE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|DBsignal
operator|=
name|stab_val
argument_list|(
operator|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"signal"
argument_list|,
name|TRUE
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|curstash
operator|=
name|defstash
expr_stmt|;
block|}
comment|/* init tokener */
name|bufend
operator|=
name|bufptr
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|savestack
operator|=
name|anew
argument_list|(
name|Nullstab
argument_list|)
expr_stmt|;
comment|/* for saving non-local values */
name|stack
operator|=
name|anew
argument_list|(
name|Nullstab
argument_list|)
expr_stmt|;
comment|/* for saving non-local values */
name|stack
operator|->
name|ary_flags
operator|=
literal|0
expr_stmt|;
comment|/* not a real array */
name|afill
argument_list|(
name|stack
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|afill
argument_list|(
name|stack
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* preextend stack */
name|afill
argument_list|(
name|savestack
argument_list|,
literal|63
argument_list|)
expr_stmt|;
name|afill
argument_list|(
name|savestack
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* now parse the script */
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
operator|||
name|error_count
condition|)
block|{
if|if
condition|(
name|minus_c
condition|)
name|fatal
argument_list|(
literal|"%s had compilation errors.\n"
argument_list|,
name|origfilename
argument_list|)
expr_stmt|;
else|else
block|{
name|fatal
argument_list|(
literal|"Execution of %s aborted due to compilation errors.\n"
argument_list|,
name|origfilename
argument_list|)
expr_stmt|;
block|}
block|}
name|New
argument_list|(
literal|50
argument_list|,
name|loop_stack
argument_list|,
literal|128
argument_list|,
expr|struct
name|loop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|New
argument_list|(
literal|51
argument_list|,
name|debname
argument_list|,
literal|128
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|52
argument_list|,
name|debdelim
argument_list|,
literal|128
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|curstash
operator|=
name|defstash
expr_stmt|;
name|preprocess
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|e_fp
condition|)
block|{
name|e_fp
operator|=
name|Nullfp
expr_stmt|;
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|e_tmpname
argument_list|)
expr_stmt|;
block|}
comment|/* initialize everything that won't change if we undump */
if|if
condition|(
name|sigstab
operator|=
name|stabent
argument_list|(
literal|"SIG"
argument_list|,
name|allstabs
argument_list|)
condition|)
block|{
name|sigstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
operator|(
name|void
operator|)
name|hadd
argument_list|(
name|sigstab
argument_list|)
expr_stmt|;
block|}
name|magicalize
argument_list|(
literal|"!#?^~=-%.+&*()<>,\\/[|`':\004\t\020\024\027\006"
argument_list|)
expr_stmt|;
name|userinit
argument_list|()
expr_stmt|;
comment|/* in case linked C routines want magical variables */
name|amperstab
operator|=
name|stabent
argument_list|(
literal|"&"
argument_list|,
name|allstabs
argument_list|)
expr_stmt|;
name|leftstab
operator|=
name|stabent
argument_list|(
literal|"`"
argument_list|,
name|allstabs
argument_list|)
expr_stmt|;
name|rightstab
operator|=
name|stabent
argument_list|(
literal|"'"
argument_list|,
name|allstabs
argument_list|)
expr_stmt|;
name|sawampersand
operator|=
operator|(
name|amperstab
operator|||
name|leftstab
operator|||
name|rightstab
operator|)
expr_stmt|;
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|":"
argument_list|,
name|allstabs
argument_list|)
condition|)
name|str_set
argument_list|(
name|STAB_STR
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
name|chopset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"\024"
argument_list|,
name|allstabs
argument_list|)
condition|)
name|time
argument_list|(
operator|&
name|basetime
argument_list|)
expr_stmt|;
comment|/* these aren't necessarily magical */
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|";"
argument_list|,
name|allstabs
argument_list|)
condition|)
name|str_set
argument_list|(
name|STAB_STR
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
literal|"\034"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"]"
argument_list|,
name|allstabs
argument_list|)
condition|)
block|{
name|str
operator|=
name|STAB_STR
argument_list|(
name|tmpstab
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|rcsid
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
name|atof
argument_list|(
name|patchlevel
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|1
expr_stmt|;
block|}
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"\""
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stdinstab
operator|=
name|stabent
argument_list|(
literal|"STDIN"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stdinstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|stab_io
argument_list|(
name|stdinstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|stab_io
argument_list|(
name|stdinstab
argument_list|)
operator|->
name|ifp
operator|=
name|stdin
expr_stmt|;
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"stdin"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|=
name|stab_io
argument_list|(
name|stdinstab
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"STDOUT"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ofp
operator|=
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ifp
operator|=
name|stdout
expr_stmt|;
name|defoutstab
operator|=
name|tmpstab
expr_stmt|;
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"stdout"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|=
name|stab_io
argument_list|(
name|defoutstab
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|curoutstab
operator|=
name|stabent
argument_list|(
literal|"STDERR"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|curoutstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|ofp
operator|=
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|ifp
operator|=
name|stderr
expr_stmt|;
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"stderr"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|=
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
expr_stmt|;
name|tmpstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
name|curoutstab
operator|=
name|defoutstab
expr_stmt|;
comment|/* switch back to STDOUT */
name|statname
operator|=
name|Str_new
argument_list|(
literal|66
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* last filename we did stat on */
comment|/* now that script is parsed, we can modify record separator */
name|rs
operator|=
name|nrs
expr_stmt|;
name|rslen
operator|=
name|nrslen
expr_stmt|;
name|rschar
operator|=
name|nrschar
expr_stmt|;
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"/"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|rs
argument_list|,
name|rslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_undump
condition|)
name|my_unexec
argument_list|()
expr_stmt|;
name|just_doit
label|:
comment|/* come here if running an undumped a.out */
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
comment|/* skip name of script */
if|if
condition|(
name|doswitches
condition|)
block|{
for|for
control|(
init|;
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|=
name|index
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
operator|(
name|double
operator|)
literal|1.0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"0"
argument_list|,
name|allstabs
argument_list|)
condition|)
block|{
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
name|origfilename
argument_list|)
expr_stmt|;
name|magicname
argument_list|(
literal|"0"
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"\030"
argument_list|,
name|allstabs
argument_list|)
condition|)
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
name|origargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvstab
operator|=
name|stabent
argument_list|(
literal|"ARGV"
argument_list|,
name|allstabs
argument_list|)
condition|)
block|{
name|argvstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
operator|(
name|void
operator|)
name|aadd
argument_list|(
name|argvstab
argument_list|)
expr_stmt|;
name|aclear
argument_list|(
name|stab_array
argument_list|(
name|argvstab
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|argvstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TAINT
operator|(
name|void
operator|)
name|stabent
argument_list|(
literal|"ENV"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* must test PATH and IFS */
endif|#
directive|endif
if|if
condition|(
name|envstab
operator|=
name|stabent
argument_list|(
literal|"ENV"
argument_list|,
name|allstabs
argument_list|)
condition|)
block|{
name|envstab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
operator|(
name|void
operator|)
name|hadd
argument_list|(
name|envstab
argument_list|)
expr_stmt|;
name|hclear
argument_list|(
name|stab_hash
argument_list|(
name|envstab
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|environ
condition|)
name|environ
index|[
literal|0
index|]
operator|=
name|Nullch
expr_stmt|;
for|for
control|(
init|;
operator|*
name|env
condition|;
name|env
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|index
argument_list|(
operator|*
name|env
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
continue|continue;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|=
name|str_make
argument_list|(
name|s
operator|--
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_magic
argument_list|(
name|str
argument_list|,
name|envstab
argument_list|,
literal|'E'
argument_list|,
operator|*
name|env
argument_list|,
name|s
operator|-
operator|*
name|env
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hstore
argument_list|(
name|stab_hash
argument_list|(
name|envstab
argument_list|)
argument_list|,
operator|*
name|env
argument_list|,
name|s
operator|-
operator|*
name|env
argument_list|,
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'='
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"$"
argument_list|,
name|allstabs
argument_list|)
condition|)
name|str_numset
argument_list|(
name|STAB_STR
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dowarn
condition|)
block|{
name|stab_check
argument_list|(
literal|'A'
argument_list|,
literal|'Z'
argument_list|)
expr_stmt|;
name|stab_check
argument_list|(
literal|'a'
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|top_env
argument_list|)
condition|)
comment|/* sets goto_targ on longjump */
name|loop_ptr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* start label stack again */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|1024
condition|)
name|dump_all
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nEXECUTING...\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|minus_c
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s syntax OK\n"
argument_list|,
name|origfilename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* do it */
operator|(
name|void
operator|)
name|cmd_exec
argument_list|(
name|main_root
argument_list|,
name|G_SCALAR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|goto_targ
condition|)
name|fatal
argument_list|(
literal|"Can't find label \"%s\"--aborting"
argument_list|,
name|goto_targ
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|void
name|magicalize
parameter_list|(
name|list
parameter_list|)
specifier|register
name|char
modifier|*
name|list
decl_stmt|;
block|{
name|char
name|sym
index|[
literal|2
index|]
decl_stmt|;
name|sym
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|sym
operator|=
operator|*
name|list
operator|++
condition|)
name|magicname
argument_list|(
name|sym
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|magicname
parameter_list|(
name|sym
parameter_list|,
name|name
parameter_list|,
name|namlen
parameter_list|)
name|char
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namlen
decl_stmt|;
block|{
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
if|if
condition|(
name|stab
operator|=
name|stabent
argument_list|(
name|sym
argument_list|,
name|allstabs
argument_list|)
condition|)
block|{
name|stab_flags
argument_list|(
name|stab
argument_list|)
operator|=
name|SF_VMAGIC
expr_stmt|;
name|str_magic
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|stab
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|savelines
parameter_list|(
name|array
parameter_list|,
name|str
parameter_list|)
name|ARRAY
modifier|*
name|array
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|str
operator|->
name|str_ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
init|=
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|line
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|s
operator|&&
name|s
operator|<
name|send
condition|)
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|Str_new
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|t
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|t
operator|++
expr_stmt|;
else|else
name|t
operator|=
name|send
expr_stmt|;
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
name|s
argument_list|,
name|t
operator|-
name|s
argument_list|)
expr_stmt|;
name|astore
argument_list|(
name|array
argument_list|,
name|line
operator|++
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* this routine is in perl.c by virtue of being sort of an alternate main() */
end_comment

begin_function
name|int
name|do_eval
parameter_list|(
name|str
parameter_list|,
name|optype
parameter_list|,
name|stash
parameter_list|,
name|savecmd
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|optype
decl_stmt|;
name|HASH
modifier|*
name|stash
decl_stmt|;
name|int
name|savecmd
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|CMD
modifier|*
name|myroot
init|=
name|Nullcmd
decl_stmt|;
name|ARRAY
modifier|*
name|ar
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CMD
modifier|*
name|VOLATILE
name|oldcurcmd
init|=
name|curcmd
decl_stmt|;
name|VOLATILE
name|int
name|oldtmps_base
init|=
name|tmps_base
decl_stmt|;
name|VOLATILE
name|int
name|oldsave
init|=
name|savestack
operator|->
name|ary_fill
decl_stmt|;
name|VOLATILE
name|int
name|oldperldb
init|=
name|perldb
decl_stmt|;
name|SPAT
modifier|*
name|VOLATILE
name|oldspat
init|=
name|curspat
decl_stmt|;
name|SPAT
modifier|*
name|VOLATILE
name|oldlspat
init|=
name|lastspat
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_eval
init|=
name|Nullch
decl_stmt|;
specifier|static
name|long
name|last_elen
init|=
literal|0
decl_stmt|;
specifier|static
name|CMD
modifier|*
name|last_root
init|=
name|Nullcmd
decl_stmt|;
name|VOLATILE
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|specfilename
decl_stmt|;
name|char
modifier|*
name|tmpfilename
decl_stmt|;
name|int
name|parsing
init|=
literal|1
decl_stmt|;
name|tmps_base
operator|=
name|tmps_max
expr_stmt|;
if|if
condition|(
name|curstash
operator|!=
name|stash
condition|)
block|{
operator|(
name|void
operator|)
name|savehptr
argument_list|(
operator|&
name|curstash
argument_list|)
expr_stmt|;
name|curstash
operator|=
name|stash
expr_stmt|;
block|}
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|curcmd
operator|->
name|c_line
operator|==
literal|0
condition|)
comment|/* don't debug debugger... */
name|perldb
operator|=
name|FALSE
expr_stmt|;
name|curcmd
operator|=
operator|&
name|compiling
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|O_EVAL
condition|)
block|{
comment|/* normal eval */
name|curcmd
operator|->
name|c_filestab
operator|=
name|fstab
argument_list|(
literal|"(eval)"
argument_list|)
expr_stmt|;
name|curcmd
operator|->
name|c_line
operator|=
literal|1
expr_stmt|;
name|str_sset
argument_list|(
name|linestr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|linestr
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
comment|/* be kind to them */
if|if
condition|(
name|perldb
condition|)
name|savelines
argument_list|(
name|stab_xarray
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
argument_list|,
name|linestr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|last_root
operator|&&
operator|!
name|in_eval
condition|)
block|{
name|Safefree
argument_list|(
name|last_eval
argument_list|)
expr_stmt|;
name|last_eval
operator|=
name|Nullch
expr_stmt|;
name|cmd_free
argument_list|(
name|last_root
argument_list|)
expr_stmt|;
name|last_root
operator|=
name|Nullcmd
expr_stmt|;
block|}
name|specfilename
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|O_REQUIRE
operator|&&
operator|&
name|str_undef
operator|!=
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|specfilename
argument_list|,
name|strlen
argument_list|(
name|specfilename
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|curcmd
operator|=
name|oldcurcmd
expr_stmt|;
name|tmps_base
operator|=
name|oldtmps_base
expr_stmt|;
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|&
name|str_yes
expr_stmt|;
name|perldb
operator|=
name|oldperldb
expr_stmt|;
return|return
name|sp
return|;
block|}
name|tmpfilename
operator|=
name|savestr
argument_list|(
name|specfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"/."
argument_list|,
operator|*
name|tmpfilename
argument_list|)
condition|)
name|rsfp
operator|=
name|fopen
argument_list|(
name|tmpfilename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
block|{
name|ar
operator|=
name|stab_array
argument_list|(
name|incstab
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ar
operator|->
name|ary_fill
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|str_get
argument_list|(
name|afetch
argument_list|(
name|ar
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|specfilename
argument_list|)
expr_stmt|;
name|rsfp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsfp
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|buf
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|s
operator|+=
literal|2
expr_stmt|;
name|Safefree
argument_list|(
name|tmpfilename
argument_list|)
expr_stmt|;
name|tmpfilename
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|curcmd
operator|->
name|c_filestab
operator|=
name|fstab
argument_list|(
name|tmpfilename
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|tmpfilename
argument_list|)
expr_stmt|;
name|tmpfilename
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
operator|!
name|rsfp
condition|)
block|{
name|curcmd
operator|=
name|oldcurcmd
expr_stmt|;
name|tmps_base
operator|=
name|oldtmps_base
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|O_REQUIRE
condition|)
block|{
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"Can't locate %s in @INC"
argument_list|,
name|specfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
argument_list|(
name|tokenbuf
argument_list|,
literal|".h "
argument_list|)
condition|)
name|strcat
argument_list|(
name|tokenbuf
argument_list|,
literal|" (change .h to .ph maybe?)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
argument_list|(
name|tokenbuf
argument_list|,
literal|".ph "
argument_list|)
condition|)
name|strcat
argument_list|(
name|tokenbuf
argument_list|,
literal|" (did you run h2ph?)"
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|tokenbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
name|perldb
operator|=
name|oldperldb
expr_stmt|;
return|return
name|sp
return|;
block|}
name|curcmd
operator|->
name|c_line
operator|=
literal|0
expr_stmt|;
block|}
name|in_eval
operator|++
expr_stmt|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|bufptr
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|bufptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
operator|++
name|loop_ptr
operator|>=
name|loop_max
condition|)
block|{
name|loop_max
operator|+=
literal|128
expr_stmt|;
name|Renew
argument_list|(
name|loop_stack
argument_list|,
name|loop_max
argument_list|,
expr|struct
name|loop
argument_list|)
expr_stmt|;
block|}
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|=
literal|"_EVAL_"
expr_stmt|;
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_sp
operator|=
name|sp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Pushing label #%d _EVAL_)\n"
argument_list|,
name|loop_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|eval_root
operator|=
name|Nullcmd
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|)
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rsfp
condition|)
block|{
name|retval
operator|=
name|yyparse
argument_list|()
expr_stmt|;
name|retval
operator||=
name|error_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_root
operator|&&
name|last_elen
operator|==
name|bufend
operator|-
name|bufptr
operator|&&
operator|*
name|bufptr
operator|==
operator|*
name|last_eval
operator|&&
operator|!
name|bcmp
argument_list|(
name|bufptr
argument_list|,
name|last_eval
argument_list|,
name|last_elen
argument_list|)
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|eval_root
operator|=
name|last_root
expr_stmt|;
comment|/* no point in reparsing */
block|}
elseif|else
if|if
condition|(
name|in_eval
operator|==
literal|1
operator|&&
operator|!
name|savecmd
condition|)
block|{
if|if
condition|(
name|last_root
condition|)
block|{
name|Safefree
argument_list|(
name|last_eval
argument_list|)
expr_stmt|;
name|last_eval
operator|=
name|Nullch
expr_stmt|;
name|cmd_free
argument_list|(
name|last_root
argument_list|)
expr_stmt|;
block|}
name|last_root
operator|=
name|Nullcmd
expr_stmt|;
name|last_elen
operator|=
name|bufend
operator|-
name|bufptr
expr_stmt|;
name|last_eval
operator|=
name|nsavestr
argument_list|(
name|bufptr
argument_list|,
name|last_elen
argument_list|)
expr_stmt|;
name|retval
operator|=
name|yyparse
argument_list|()
expr_stmt|;
name|retval
operator||=
name|error_count
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
name|last_root
operator|=
name|eval_root
expr_stmt|;
if|if
condition|(
operator|!
name|last_root
condition|)
block|{
name|Safefree
argument_list|(
name|last_eval
argument_list|)
expr_stmt|;
name|last_eval
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
else|else
name|retval
operator|=
name|yyparse
argument_list|()
expr_stmt|;
block|}
name|myroot
operator|=
name|eval_root
expr_stmt|;
comment|/* in case cmd_exec does another eval! */
if|if
condition|(
name|retval
condition|)
block|{
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
if|if
condition|(
name|parsing
condition|)
block|{
ifndef|#
directive|ifndef
name|MANGLEDPARSE
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Freeing eval_root %lx\n"
argument_list|,
operator|(
name|long
operator|)
name|eval_root
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cmd_free
argument_list|(
name|eval_root
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|CMD
operator|*
operator|)
name|eval_root
operator|==
name|last_root
condition|)
name|last_root
operator|=
name|Nullcmd
expr_stmt|;
name|eval_root
operator|=
name|myroot
operator|=
name|Nullcmd
expr_stmt|;
block|}
if|if
condition|(
name|rsfp
condition|)
block|{
name|fclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
name|rsfp
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|parsing
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|cmd_exec
argument_list|(
name|eval_root
argument_list|,
name|gimme
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
init|;
name|i
operator|<=
name|sp
condition|;
name|i
operator|++
control|)
name|st
index|[
name|i
index|]
operator|=
name|str_mortal
argument_list|(
name|st
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* if we don't save result, free zaps it */
if|if
condition|(
name|savecmd
condition|)
name|eval_root
operator|=
name|myroot
expr_stmt|;
elseif|else
if|if
condition|(
name|in_eval
operator|!=
literal|1
operator|&&
name|myroot
operator|!=
name|last_root
condition|)
name|cmd_free
argument_list|(
name|myroot
argument_list|)
expr_stmt|;
block|}
name|perldb
operator|=
name|oldperldb
expr_stmt|;
name|in_eval
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|char
modifier|*
name|tmps
init|=
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
decl_stmt|;
name|deb
argument_list|(
literal|"(Popping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|tmps
condition|?
name|tmps
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
name|tmps_base
operator|=
name|oldtmps_base
expr_stmt|;
name|curspat
operator|=
name|oldspat
expr_stmt|;
name|lastspat
operator|=
name|oldlspat
expr_stmt|;
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
comment|/* let them use local() */
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
operator|!=
name|O_EVAL
condition|)
block|{
if|if
condition|(
name|retval
condition|)
block|{
if|if
condition|(
name|optype
operator|==
name|O_REQUIRE
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curcmd
operator|=
name|oldcurcmd
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|?
name|str_true
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|)
else|:
name|sp
operator|>
name|arglast
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|hstore
argument_list|(
name|stab_hash
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|specfilename
argument_list|,
name|strlen
argument_list|(
name|specfilename
argument_list|)
argument_list|,
name|str_smake
argument_list|(
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype
operator|==
name|O_REQUIRE
condition|)
name|fatal
argument_list|(
literal|"%s did not return a true value"
argument_list|,
name|specfilename
argument_list|)
expr_stmt|;
block|}
block|}
name|curcmd
operator|=
name|oldcurcmd
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|int
name|do_try
parameter_list|(
name|cmd
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|CMD
modifier|*
name|cmd
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
name|CMD
modifier|*
name|VOLATILE
name|oldcurcmd
init|=
name|curcmd
decl_stmt|;
name|VOLATILE
name|int
name|oldtmps_base
init|=
name|tmps_base
decl_stmt|;
name|VOLATILE
name|int
name|oldsave
init|=
name|savestack
operator|->
name|ary_fill
decl_stmt|;
name|SPAT
modifier|*
name|VOLATILE
name|oldspat
init|=
name|curspat
decl_stmt|;
name|SPAT
modifier|*
name|VOLATILE
name|oldlspat
init|=
name|lastspat
decl_stmt|;
name|VOLATILE
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|tmps_base
operator|=
name|tmps_max
expr_stmt|;
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|in_eval
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|loop_ptr
operator|>=
name|loop_max
condition|)
block|{
name|loop_max
operator|+=
literal|128
expr_stmt|;
name|Renew
argument_list|(
name|loop_stack
argument_list|,
name|loop_max
argument_list|,
expr|struct
name|loop
argument_list|)
expr_stmt|;
block|}
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|=
literal|"_EVAL_"
expr_stmt|;
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_sp
operator|=
name|sp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Pushing label #%d _EVAL_)\n"
argument_list|,
name|loop_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|setjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|)
condition|)
block|{
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|cmd_exec
argument_list|(
name|cmd
argument_list|,
name|gimme
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/*	for (i = arglast[0] + 1; i<= sp; i++) 	    st[i] = str_mortal(st[i]);  not needed, I think */
comment|/* if we don't save result, free zaps it */
block|}
name|in_eval
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|char
modifier|*
name|tmps
init|=
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
decl_stmt|;
name|deb
argument_list|(
literal|"(Popping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|tmps
condition|?
name|tmps
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
name|tmps_base
operator|=
name|oldtmps_base
expr_stmt|;
name|curspat
operator|=
name|oldspat
expr_stmt|;
name|lastspat
operator|=
name|oldlspat
expr_stmt|;
name|curcmd
operator|=
name|oldcurcmd
expr_stmt|;
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
comment|/* let them use local() */
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* This routine handles any switches that can be given during run */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|moreswitches
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|numlen
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'0'
case|:
name|nrschar
operator|=
name|scanoct
argument_list|(
name|s
argument_list|,
literal|4
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|nrs
operator|=
name|nsavestr
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|nrs
operator|=
name|nrschar
expr_stmt|;
if|if
condition|(
name|nrschar
operator|>
literal|0377
condition|)
block|{
name|nrslen
operator|=
literal|0
expr_stmt|;
name|nrs
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nrschar
operator|&&
name|numlen
operator|>=
literal|2
condition|)
block|{
name|nrslen
operator|=
literal|2
expr_stmt|;
name|nrs
operator|=
literal|"\n\n"
expr_stmt|;
name|nrschar
operator|=
literal|'\n'
expr_stmt|;
block|}
return|return
name|s
operator|+
name|numlen
return|;
case|case
literal|'a'
case|:
name|minus_a
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'c'
case|:
name|minus_c
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -d allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|perldb
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'D'
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -D allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
operator||
literal|32768
expr_stmt|;
else|#
directive|else
name|warn
argument_list|(
literal|"Recompile perl with -DDEBUGGING to use -D switch\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*SUPPRESS 530*/
for|for
control|(
name|s
operator|++
init|;
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
return|return
name|s
return|;
case|case
literal|'i'
case|:
name|inplace
operator|=
name|savestr
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
name|s
operator|=
name|inplace
init|;
operator|*
name|s
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
condition|)
name|fatal
argument_list|(
literal|"No -I allowed in setuid scripts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
operator|++
name|s
condition|)
block|{
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|incstab
argument_list|)
argument_list|,
name|str_make
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"No space allowed after -I"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|minus_l
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|ors
operator|=
name|savestr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|orslen
operator|=
literal|1
expr_stmt|;
operator|*
name|ors
operator|=
name|scanoct
argument_list|(
name|s
argument_list|,
literal|3
operator|+
operator|(
operator|*
name|s
operator|==
literal|'0'
operator|)
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|s
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
block|{
name|ors
operator|=
name|nsavestr
argument_list|(
name|nrs
argument_list|,
name|nrslen
argument_list|)
expr_stmt|;
name|orslen
operator|=
name|nrslen
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
literal|'n'
case|:
name|minus_n
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'p'
case|:
name|minus_p
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'u'
case|:
name|do_undump
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'U'
case|:
name|unsafe
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'v'
case|:
name|fputs
argument_list|(
literal|"\nThis is perl, version 4.0\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|rcsid
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\nCopyright (c) 1989, 1990, 1991, Larry Wall\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|fputs
argument_list|(
literal|"MS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
name|fputs
argument_list|(
literal|"OS/2 port Copyright (c) 1990, Raymond Chen, Kai Uwe Rommel\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\n\ Perl may be copied only under the terms of either the Artistic License or the\n\ GNU General Public License, which may be found in the Perl 4.0 source kit.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|usage
argument_list|(
name|origargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
name|dowarn
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
break|break;
default|default:
name|fatal
argument_list|(
literal|"Switch meaningless after -x: -%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* compliments of Tom Christiansen */
end_comment

begin_comment
comment|/* unexec() can be found in the Gnu emacs distribution */
end_comment

begin_macro
name|my_unexec
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|UNEXEC
name|int
name|status
decl_stmt|;
specifier|extern
name|int
name|etext
decl_stmt|;
specifier|static
name|char
name|dumpname
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
name|perlpath
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|dumpname
argument_list|,
literal|"%s.perldump"
argument_list|,
name|origfilename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|perlpath
argument_list|,
literal|"%s/perl"
argument_list|,
name|BIN
argument_list|)
expr_stmt|;
name|status
operator|=
name|unexec
argument_list|(
name|dumpname
argument_list|,
name|perlpath
argument_list|,
operator|&
name|etext
argument_list|,
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexec of %s into %s failed!\n"
argument_list|,
name|perlpath
argument_list|,
name|dumpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MSDOS
name|abort
argument_list|()
expr_stmt|;
comment|/* nothing else to do */
else|#
directive|else
comment|/* ! MSDOS */
ifndef|#
directive|ifndef
name|SIGABRT
define|#
directive|define
name|SIGABRT
value|SIGILL
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SIGILL
define|#
directive|define
name|SIGILL
value|6
comment|/* blech */
endif|#
directive|endif
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGABRT
argument_list|)
expr_stmt|;
comment|/* for use with undump */
endif|#
directive|endif
comment|/* ! MSDOS */
endif|#
directive|endif
block|}
end_block

end_unit

