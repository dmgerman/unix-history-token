begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      UTIL.C  *      UTREE utility functions.  *      3.01-um klin, Sat Apr 20 11:02:33 1991  *              klin, Tue Oct 15 14:02:37 1991, Handling of symlinks changed  *      3.02-um klin, Fri Nov  1 10:46:14 1991, APOLLO stuff added  *      3.03-um klin, Tue Feb 11 22:58:03 1992, statusfile() into stat.c  *                                              getopt() into sup/getopt.c  *              klin, Fri Mar  6 10:45:49 1992, strclean() added  *  *      Copyright (c) 1991/92 Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03-um (klin) Mar  6 1992 util.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ---- Local variables and definitions ------------------------------- */
end_comment

begin_define
define|#
directive|define
name|TRASH
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '#')
end_define

begin_comment
comment|/* ---- Functions and procedures -------------------------------------- */
end_comment

begin_comment
comment|/*  *      COMMON USED UTILITIY FUNCTIONS  *  */
end_comment

begin_comment
comment|/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
end_comment

begin_comment
comment|/* !  This function is a modified version of adjustname() `stolen'    ! */
end_comment

begin_comment
comment|/* !  from the public domain editor MICRO GNU EMACS (mg) version 2a.  ! */
end_comment

begin_comment
comment|/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
end_comment

begin_comment
comment|/* Return pathname of filename fn and current directory cwd */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|pathname
parameter_list|(
name|fn
parameter_list|,
name|cwd
parameter_list|)
specifier|register
name|char
modifier|*
name|fn
decl_stmt|,
decl|*
name|cwd
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|pn
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
name|fn
operator|==
literal|'/'
condition|)
block|{
name|cp
operator|=
name|pn
expr_stmt|;
ifdef|#
directive|ifdef
name|APOLLO
comment|/* Stuff for APOLLO node names: //node */
if|if
condition|(
name|fn
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|fn
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* APOLLO */
while|while
condition|(
name|fn
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|++
name|fn
expr_stmt|;
ifdef|#
directive|ifdef
name|MUNET
comment|/* Stuff for MUNIX/NET: /../node */
if|if
condition|(
name|fn
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|fn
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|fn
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|*
name|fn
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MUNET */
operator|*
name|cp
operator|++
operator|=
operator|*
name|fn
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pn
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|cp
operator|=
name|pn
operator|+
name|strlen
argument_list|(
name|pn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|pn
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
operator|*
name|fn
condition|)
block|{
switch|switch
condition|(
operator|*
name|fn
condition|)
block|{
case|case
literal|'.'
case|:
switch|switch
condition|(
name|fn
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|pn
operator|)
return|;
case|case
literal|'/'
case|:
name|fn
operator|+=
literal|2
expr_stmt|;
continue|continue;
case|case
literal|'.'
case|:
if|if
condition|(
name|fn
index|[
literal|2
index|]
operator|==
literal|'/'
operator|||
name|fn
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|--
name|cp
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|pn
operator|&&
operator|*
operator|--
name|cp
operator|!=
literal|'/'
condition|)
empty_stmt|;
operator|++
name|cp
expr_stmt|;
if|if
condition|(
name|fn
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|pn
operator|)
return|;
block|}
name|fn
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'/'
case|:
name|fn
operator|++
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
while|while
condition|(
operator|*
name|fn
operator|&&
operator|(
operator|*
name|cp
operator|++
operator|=
operator|*
name|fn
operator|++
operator|)
operator|!=
literal|'/'
condition|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|APOLLO
if|if
condition|(
name|cp
operator|!=
operator|&
name|pn
index|[
literal|2
index|]
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
else|#
directive|else
comment|/* !APOLLO */
if|if
condition|(
name|cp
operator|!=
operator|&
name|pn
index|[
literal|1
index|]
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
endif|#
directive|endif
comment|/* APOLLO */
operator|--
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|pn
operator|)
return|;
block|}
end_block

begin_comment
comment|/* pathname() */
end_comment

begin_comment
comment|/* Return basename of filename s */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|basename
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|>=
name|s
condition|)
if|if
condition|(
operator|*
name|sp
operator|==
literal|'/'
condition|)
return|return
operator|(
operator|*
operator|(
operator|++
name|sp
operator|)
condition|?
name|sp
else|:
name|s
operator|)
return|;
else|else
operator|--
name|sp
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* basename() */
end_comment

begin_comment
comment|/* Save string s */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|strsav
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|sp
operator|=
name|ualloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* strsav() */
end_comment

begin_comment
comment|/* Convert string from lower to upper case */
end_comment

begin_function
name|GLOBL
name|VOID
name|strupper
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|toupper
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* strupper() */
end_comment

begin_comment
comment|/* Delete leading and trailing trash characters from s */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|strclean
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|TRASH
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|s
operator|&&
name|TRASH
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* strclean() */
end_comment

begin_comment
comment|/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
end_comment

begin_comment
comment|/* !   This function is a modified and tuned version of a wild card   ! */
end_comment

begin_comment
comment|/* !   pattern matcher written by Rich Salz (mirror!rs, Nov 26 1986)  ! */
end_comment

begin_comment
comment|/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
end_comment

begin_comment
comment|/* Shell like pattern matching for meta characters *, ?, [class] */
end_comment

begin_comment
comment|/* Check string s against pattern p and return 1 on match 0 else */
end_comment

begin_function
name|GLOBL
name|int
name|match
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|lc
decl_stmt|,
name|ok
decl_stmt|,
name|ex
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|s
operator|++
operator|,
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* Literal match next char */
operator|++
name|p
expr_stmt|;
comment|/*FALLTHRU*/
default|default:
comment|/* Literal match char */
if|if
condition|(
operator|*
name|s
operator|!=
operator|*
name|p
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
case|case
literal|'?'
case|:
comment|/* Match any char */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
case|case
literal|'*'
case|:
comment|/* Match any chars */
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'\0'
condition|)
comment|/* Matches all */
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|match
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'['
case|:
comment|/* Class */
if|if
condition|(
name|ex
operator|=
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'^'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'!'
operator|)
condition|)
operator|++
name|p
expr_stmt|;
for|for
control|(
name|lc
operator|=
literal|0400
operator|,
name|ok
operator|=
literal|0
init|;
operator|*
operator|++
name|p
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|;
name|lc
operator|=
operator|*
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|?
operator|*
name|s
operator|<=
operator|*
operator|++
name|p
operator|&&
operator|*
name|s
operator|>=
name|lc
else|:
operator|*
name|s
operator|==
operator|*
name|p
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ok
operator|==
name|ex
condition|)
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
block|}
block|}
return|return
operator|(
operator|*
name|s
operator|==
literal|'\0'
operator|)
return|;
block|}
end_block

begin_comment
comment|/* match() */
end_comment

begin_comment
comment|/* Get and return next valid filename entry from directory file d */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|readdname
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NODIRENT
argument_list|)
ifdef|#
directive|ifdef
name|BSD
specifier|register
name|struct
name|direct
modifier|*
name|d
decl_stmt|;
else|#
directive|else
comment|/* SYSV */
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
endif|#
directive|endif
comment|/* BSD */
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
comment|/* Get next valid directory entry and return filename */
while|while
condition|(
name|d
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|f
operator|=
name|d
operator|->
name|d_name
expr_stmt|;
comment|/* Skip "." and ".." */
if|if
condition|(
name|f
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|f
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|f
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|f
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
continue|continue;
return|return
operator|(
name|f
operator|)
return|;
else|#
directive|else
comment|/* SYSV&& NODIRENT */
specifier|static
name|char
name|n
index|[
name|DIRSIZ
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|direct
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|f
operator|=
name|d
operator|.
name|d_name
expr_stmt|;
comment|/* Skip removed files, "." and ".." */
if|if
condition|(
name|d
operator|.
name|d_ino
operator|==
literal|0
operator|||
operator|(
name|f
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|f
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|f
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|f
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|n
argument_list|,
name|d
operator|.
name|d_name
argument_list|,
name|DIRSIZ
argument_list|)
expr_stmt|;
name|n
index|[
name|DIRSIZ
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
endif|#
directive|endif
comment|/* BSD || !NODIRENT */
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* readdname() */
end_comment

end_unit

