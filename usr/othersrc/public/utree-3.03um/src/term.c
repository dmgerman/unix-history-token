begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      TERM.C  *      UTREE terminal, screen and keyboard routines.  *      3.01-um klin, Wed May  1 14:21:09 1991  *              klin, Mon Oct  7 15:16:22 1991, Bug in putchar() deleted  *              klin, Sat Oct 26 15:26:07 1991, Marking directories changed  *      3.02-um klin, Fri Nov  1 10:44:45 1991, Screen layout changed  *                    Sun Nov 10 19:46:21 1991, Function key handling changed  *                    Sun Nov 24 12:22:56 1991, Extensions for XENIX reported  *                                              by Rolf Gebhardt (RG 11/22/91)  *                                              Bug fixes in output reported by  *                                              Reinhard Wobst and Rolf Gebhardt  *                                              Video attributes changed  *      3.03-um klin, Tue Feb 11 19:39:09 1992, Video handling changed  *                                              Handle glitch capabilities  *                                              properly  *              klin, Sun Feb 23 20:33:30 1992, Key handling and key bindings  *                                              changed. getkey() changed for  *                                              handling key bindings from  *                                              key bindings list  *            a klin, Sun Mar 15 19:08:25 1992, Bug fix in getkey(), clearline()  *                                              and cleartoend().  *                                              Minor changes for AIX 3.2  *            c klin, Mon Mar 30 15:37:45 1992, More bug fixes in clearxxx()  *                                              from Rolf Gebhardt (RG 03/19/92)  *            e klin, Sat Apr 11 11:05:54 1992, Use colors for video attributes  *  *      Copyright (c) 1991/92 by Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03e-um (klin) Apr 11 1992 term.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*      TEST:   Handling of sg/ug glitches (i.e. for bando terminal)  *      Handling of sg/ug glitches may be wrong because i could test  *      their handling on xterm simulating the sg/ug glitches only.  */
end_comment

begin_comment
comment|/* ---- Local/global variables and definitions ------------------------ */
end_comment

begin_define
define|#
directive|define
name|TCAPLEN
value|1024
end_define

begin_comment
comment|/* Length of termcap buffers            */
end_comment

begin_define
define|#
directive|define
name|KBUFLEN
value|254
end_define

begin_comment
comment|/* Length of keyboard buffer            */
end_comment

begin_define
define|#
directive|define
name|HUGE
value|9999
end_define

begin_comment
comment|/* A huge number                        */
end_comment

begin_decl_stmt
name|GLOBL
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Needed by termcap (?)                */
end_comment

begin_decl_stmt
name|GLOBL
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Needed by termcap (?)                */
end_comment

begin_decl_stmt
name|GLOBL
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Needed by termcap (?)                */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|_XR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carriage return glitch               */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|_MS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can move cursor in standout mode     */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|_SG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standout mode glitch: # of blanks    */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|_UG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Underline glitch: # of blanks        */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_CM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor motion                        */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_CL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear screen                         */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_CD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear to end of screen               */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_CE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear to end of line                 */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_TI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Init string for cursor motion        */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_TE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exit string for cursor motion        */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_KS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn on keypad transmit mode         */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_KE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn off keypad transmit mode        */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_MR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn on reverse video mode           */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_MB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn on blink video mode             */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_MD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn on bold video mode              */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_MH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn on half bright video mode       */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_ME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn off all video attributes        */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_US
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start underlining                    */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_UE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End underlining                      */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_IC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert character at cursor position  */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_DC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Delete character at cursor position  */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_AL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert line above line cursor is on  */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_DL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Delete line cursor is on             */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_CS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set scroll region                    */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_NL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New line (default: ^J = NL)          */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_CR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carriage return (default: ^M = CR)   */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_LE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor left (default: ^H = BS)       */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_DO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor down                          */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_SF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scroll screen up                     */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_SR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scroll screen down                   */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_SC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save cursor position                 */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_RC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Restore cursor position              */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_VE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor normal                        */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_VS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor very visible                  */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_VI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor invisible                     */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_BL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bell (default ^G = BEL)              */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_AC
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alternate character set              */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_EA
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable alternate character set       */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_AS
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alternate character set on           */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_AE
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alternate character set off          */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX
end_ifdef

begin_comment
comment|/* RG 11/22/91 */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_G2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Upper left corner                    */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_GH
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Horizontal bar                       */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_G1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Upper right corner                   */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_GV
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vertical bar                         */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_G4
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lower right corner                   */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_G3
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lower left corner                    */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_GD
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top tee                              */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_GL
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Right tee                            */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_GU
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bottom tee                           */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_GR
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Left tee                             */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_GC
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Plus sign = mark sign                */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XENIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USEANSICOLORS
end_ifdef

begin_decl_stmt
name|LOCAL
name|int
name|_CO
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of colors                     */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|_AM
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Automargin                           */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_OP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset original color pair            */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_AB
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set background color                 */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|_AF
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set foreground color                 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USEANSICOLORS */
end_comment

begin_decl_stmt
name|LOCAL
name|char
name|termbuf
index|[
name|TCAPLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Termcap buffer                       */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|nfkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of defined function keys      */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_decl_stmt
name|LOCAL
name|struct
name|sgttyb
name|raw
decl_stmt|,
name|tty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal driver data record          */
end_comment

begin_define
define|#
directive|define
name|TCGETA
value|TIOCGETP
end_define

begin_define
define|#
directive|define
name|TCSETA
value|TIOCSETP
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SYSV */
end_comment

begin_decl_stmt
name|LOCAL
name|struct
name|termio
name|raw
decl_stmt|,
name|tty
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HASFIONREAD
end_ifndef

begin_decl_stmt
name|LOCAL
name|int
name|kbflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input mode flag                      */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HASFIONREAD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_decl_stmt
name|LOCAL
name|kchar
name|kbuf
index|[
name|KBUFLEN
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input buffer                         */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|kcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input buffer counter                 */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|kind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input buffer index                   */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|curx
init|=
name|HUGE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current screen column                */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|cury
init|=
name|HUGE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current screen line                  */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|vatt
init|=
name|VA_NORMAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current video attributes setting     */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|gatt
init|=
name|GC_OFF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current graphic character set flag   */
end_comment

begin_comment
comment|/* ---- External variables and functions ------------------------------ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_decl_stmt
name|EXTRN
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is ospeed really needed?             */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_function_decl
name|EXTRN
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ---- Local/global functions and procedures ------------------------- */
end_comment

begin_comment
comment|/*  *      INTERNAL USED ROUTINES  */
end_comment

begin_comment
comment|/* Output one character for tputs() */
end_comment

begin_function
name|LOCAL
name|int
name|_putch
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|putc
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|,
name|stdout
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* _putch() */
end_comment

begin_comment
comment|/*TEST: Handling of sg/ug glitches */
end_comment

begin_comment
comment|/* Move cursor back for terminals with underline or standout glitch */
end_comment

begin_function
name|LOCAL
name|VOID
name|_backglitch
parameter_list|(
name|j
parameter_list|)
specifier|register
name|int
name|j
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_LE
condition|)
name|tputs
argument_list|(
name|_LE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BC
condition|)
name|tputs
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|_putch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* _backglitch() */
end_comment

begin_comment
comment|/*  *      VIDEO ATTRIBUTE AND GRAPHIC CHARSET ROUTINES  */
end_comment

begin_comment
comment|/* Turn on/off video attributes as defined in mask v */
end_comment

begin_function
name|GLOBL
name|VOID
name|videoset
parameter_list|(
name|v
parameter_list|)
specifier|register
name|int
name|v
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
block|{
comment|/* Use colors for video attributes */
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|DA_NORMAL
case|:
comment|/* Normal colors */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_BLUE
argument_list|,
name|CS_BLUE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_CYAN
argument_list|,
name|CS_CYAN
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_REVERSE
case|:
comment|/* Reverse colors */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_CYAN
argument_list|,
name|CS_CYAN
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_BLUE
argument_list|,
name|CS_BLUE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_BOLD
case|:
comment|/* Bold color */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_BLUE
argument_list|,
name|CS_BLUE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_WHITE
argument_list|,
name|CS_WHITE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_HALF
case|:
comment|/* Half color */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_BLUE
argument_list|,
name|CS_BLUE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_CYAN
argument_list|,
name|CS_CYAN
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_ERROR
case|:
comment|/* Error color */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_WHITE
argument_list|,
name|CS_WHITE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_RED
argument_list|,
name|CS_RED
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_MARK
case|:
comment|/* Menu mark color */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_CYAN
argument_list|,
name|CS_CYAN
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_RED
argument_list|,
name|CS_RED
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_BOLDREV
case|:
comment|/* Reverse bold color */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_WHITE
argument_list|,
name|CS_WHITE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_BLUE
argument_list|,
name|CS_BLUE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_HALFREV
case|:
comment|/* Reverse half color */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_WHITE
argument_list|,
name|CS_WHITE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_CYAN
argument_list|,
name|CS_CYAN
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DA_BLINKREV
case|:
comment|/* Reverse blink color */
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AB
argument_list|,
name|CS_WHITE
argument_list|,
name|CS_WHITE
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_AF
argument_list|,
name|CS_RED
argument_list|,
name|CS_RED
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
break|break;
block|}
name|vatt
operator|=
name|v
expr_stmt|;
return|return;
block|}
elseif|else
endif|#
directive|endif
comment|/* USEANSICOLORS */
if|if
condition|(
name|vatt
condition|)
block|{
comment|/* Video attributes off */
if|if
condition|(
operator|(
name|vatt
operator|&
name|VA_UNDERLINE
operator|)
operator|&&
name|_UE
condition|)
block|{
name|tputs
argument_list|(
name|_UE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
comment|/*TEST: Handling of sg/ug glitches */
if|if
condition|(
name|_UG
operator|>
literal|0
condition|)
name|_backglitch
argument_list|(
name|_UG
argument_list|)
expr_stmt|;
name|vatt
operator|&=
operator|~
name|VA_UNDERLINE
expr_stmt|;
block|}
if|if
condition|(
name|vatt
operator|&&
name|_ME
condition|)
block|{
name|tputs
argument_list|(
name|_ME
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
comment|/*TEST: Handling of sg/ug glitches */
if|if
condition|(
name|_SG
operator|>
literal|0
condition|)
name|_backglitch
argument_list|(
name|_SG
argument_list|)
expr_stmt|;
block|}
block|}
name|vatt
operator|=
name|VA_NORMAL
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|VA_REVERSE
operator|&&
name|_MR
condition|)
block|{
comment|/* Video reverse */
name|tputs
argument_list|(
name|_MR
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
comment|/*TEST: Handling of sg/ug glitches */
if|if
condition|(
name|_SG
operator|>
literal|0
condition|)
name|_backglitch
argument_list|(
name|_SG
argument_list|)
expr_stmt|;
name|vatt
operator||=
name|VA_REVERSE
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|VA_UNDERLINE
operator|&&
name|_US
condition|)
block|{
comment|/* Start underlining */
name|tputs
argument_list|(
name|_US
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
comment|/*TEST: Handling of sg/ug glitches */
if|if
condition|(
name|_UG
operator|>
literal|0
condition|)
name|_backglitch
argument_list|(
name|_UG
argument_list|)
expr_stmt|;
name|vatt
operator||=
name|VA_UNDERLINE
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|VA_BLINK
operator|&&
name|_MB
condition|)
block|{
comment|/* Video blink */
name|tputs
argument_list|(
name|_MB
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|vatt
operator||=
name|VA_BLINK
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|VA_BOLD
operator|&&
name|_MD
condition|)
block|{
comment|/* Video bold */
name|tputs
argument_list|(
name|_MD
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|vatt
operator||=
name|VA_BOLD
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&
name|VA_HALF
operator|&&
name|_MH
condition|)
block|{
comment|/* Video half bright */
name|tputs
argument_list|(
name|_MH
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|vatt
operator||=
name|VA_HALF
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* videoset() */
end_comment

begin_comment
comment|/* Turn on/off graphic character set as defined in flag f */
end_comment

begin_function
name|GLOBL
name|VOID
name|graphicset
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|gatt
operator|!=
name|f
condition|)
block|{
if|if
condition|(
name|f
operator|&&
name|_AS
condition|)
comment|/* Enable graphic charset */
name|tputs
argument_list|(
name|_AS
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_AE
condition|)
comment|/* Disable graphic charset */
name|tputs
argument_list|(
name|_AE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|gatt
operator|=
name|f
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USEANSICOLORS
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
comment|/* Setting may destroy color settings ! */
name|videoset
argument_list|(
name|vatt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USEANSICOLORS */
block|}
end_function

begin_comment
comment|/* graphicset() */
end_comment

begin_comment
comment|/*  *      OUTPUT ROUTINES  */
end_comment

begin_comment
comment|/* Ring the bell */
end_comment

begin_function
name|GLOBL
name|VOID
name|bell
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
condition|)
block|{
if|if
condition|(
name|_BL
condition|)
name|tputs
argument_list|(
name|_BL
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|_putch
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* bell() */
end_comment

begin_comment
comment|/* Move cursor back one character */
end_comment

begin_function
name|GLOBL
name|VOID
name|backspace
parameter_list|()
block|{
if|if
condition|(
name|curx
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|_LE
condition|)
name|tputs
argument_list|(
name|_LE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BC
condition|)
name|tputs
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|_putch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
operator|--
name|curx
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* backspace() */
end_comment

begin_comment
comment|/* Move to beginning of line */
end_comment

begin_function
name|GLOBL
name|VOID
name|begline
parameter_list|()
block|{
if|if
condition|(
name|curx
operator|>
literal|0
condition|)
block|{
name|curx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_XR
condition|)
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|cury
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_CR
condition|)
name|tputs
argument_list|(
name|_CR
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|_putch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* begline() */
end_comment

begin_comment
comment|/* Move to beginning of next line */
end_comment

begin_function
name|GLOBL
name|VOID
name|newline
parameter_list|()
block|{
if|if
condition|(
name|cury
operator|<
name|lines
condition|)
block|{
name|begline
argument_list|()
expr_stmt|;
operator|++
name|cury
expr_stmt|;
if|if
condition|(
name|_NL
condition|)
name|tputs
argument_list|(
name|_NL
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_DO
condition|)
name|tputs
argument_list|(
name|_DO
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|_putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* newline() */
end_comment

begin_comment
comment|/* Write character c if cursor is on screen */
end_comment

begin_function
name|GLOBL
name|int
name|putchar
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|videoattr
operator|!=
name|vatt
condition|)
comment|/* Check and set video attributes */
name|videoset
argument_list|(
name|videoattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|graphattr
operator|!=
name|gatt
condition|)
comment|/* Check and set graphic charset */
name|graphicset
argument_list|(
name|graphattr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|7
case|:
comment|/* Bell */
name|bell
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
comment|/* Backspace */
name|backspace
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
comment|/* Tab */
if|if
condition|(
name|curx
operator|<
name|columns
operator|&&
name|cury
operator|<
name|lines
condition|)
block|{
do|do
operator|(
name|void
operator|)
name|_putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
do|while
condition|(
operator|++
name|curx
operator|%
literal|8
operator|&&
name|curx
operator|<
name|columns
condition|)
do|;
block|}
break|break;
case|case
literal|'\n'
case|:
comment|/* Newline */
name|newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* Carriage return */
name|begline
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* Others */
if|if
condition|(
name|curx
operator|<
name|columns
operator|&&
name|cury
operator|<
name|lines
operator|&&
name|isprint
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|_putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|curx
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|curx
operator|<
name|columns
operator|&&
name|cury
operator|<
name|lines
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* putchar() */
end_comment

begin_comment
comment|/* Flush output buffer */
end_comment

begin_function
name|GLOBL
name|VOID
name|flushout
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* flushout() */
end_comment

begin_comment
comment|/*  *      INPUT ROUTINES  */
end_comment

begin_comment
comment|/* Read one character from keyboard. Ignore or handle signals */
end_comment

begin_function
name|GLOBL
name|int
name|getchar
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|atread
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
comment|/* BSD: Signal SIGWINCH doesn't interrupt systemcall read() ! */
comment|/*      Set up here if SIGWINCH is catched and return K_SIZE  */
if|if
condition|(
name|setjmp
argument_list|(
name|winchjump
argument_list|)
operator|&&
name|sizechange
condition|)
block|{
name|sizechange
operator|=
name|atread
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|K_SIZE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SIGWINCH&& TIOCGWINSZ */
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|atread
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
else|#
directive|else
comment|/* SYSV */
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
comment|/* SYSV: Signal SIGWINCH interrupts systemcall read() ! */
comment|/*       So return K_SIZE if signal SIGWINCH is catched */
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|sizechange
condition|)
block|{
name|sizechange
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|K_SIZE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SIGWINCH&& TIOCGWINSZ */
block|}
do|while
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
return|return
operator|(
name|c
operator|)
return|;
endif|#
directive|endif
comment|/* BSD */
block|}
end_function

begin_comment
comment|/* getchar() */
end_comment

begin_comment
comment|/* Check if input from keyboard is pending */
end_comment

begin_function
name|GLOBL
name|int
name|keypressed
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|HASFIONREAD
argument_list|)
comment|/* Quick check how many chars are to read */
return|return
operator|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|c
argument_list|)
operator|<
literal|0
condition|?
literal|0
else|:
name|c
operator|)
return|;
else|#
directive|else
comment|/* SYSV&& !HASFIONREAD */
comment|/* Set stdin to no delay and try to read one char */
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|kbflag
operator||
name|O_NDELAY
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|kbflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* BSD || HASFIONREAD */
block|}
end_function

begin_comment
comment|/* keypressed() */
end_comment

begin_comment
comment|/* Read a character from keyboard with respect to function keys */
end_comment

begin_function
name|GLOBL
name|int
name|getkey
parameter_list|()
block|{
specifier|register
name|klist
modifier|*
name|fp
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|kchar
name|c
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
comment|/* Flush output buffer */
name|flushout
argument_list|()
expr_stmt|;
comment|/* Input buffer contains character(s) */
if|if
condition|(
name|kcnt
operator|>
literal|0
condition|)
block|{
operator|--
name|kcnt
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|kbuf
index|[
name|kind
operator|++
index|]
operator|)
return|;
block|}
comment|/* Get next character */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|0
condition|)
comment|/* Map ASCII-NUL */
name|c
operator|=
literal|0200
expr_stmt|;
comment|/* Search for first matching entry in key binding list */
for|for
control|(
name|fp
operator|=
name|kroot
init|;
name|fp
condition|;
name|fp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|fp
argument_list|)
control|)
if|if
condition|(
name|KBCHR
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
operator|==
name|c
condition|)
break|break;
comment|/* No match: return character */
if|if
condition|(
name|fp
operator|==
name|KNULL
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|c
operator|)
return|;
comment|/* Search for last matching entry in key binding list */
name|lp
operator|=
name|fp
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|lp
argument_list|)
operator|)
operator|&&
name|KBCHR
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|==
name|c
condition|)
name|lp
operator|=
name|p
expr_stmt|;
comment|/* Continue comparison of input and key strings */
for|for
control|(
name|k
operator|=
literal|1
init|;
condition|;
name|k
operator|++
control|)
block|{
comment|/* Match: return bound key symbol */
if|if
condition|(
name|fp
operator|==
name|lp
operator|&&
name|KBCHR
argument_list|(
name|fp
argument_list|,
name|k
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|KBSYM
argument_list|(
name|fp
argument_list|)
operator|==
name|K_STR
operator|&&
name|KBINS
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|kind
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ungetstring
argument_list|(
name|KBINS
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|KBSYM
argument_list|(
name|fp
argument_list|)
operator|)
return|;
block|}
comment|/* Else: get next character */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|0
condition|)
comment|/* Map ASCII-NUL */
name|c
operator|=
literal|0200
expr_stmt|;
name|kbuf
index|[
name|kcnt
operator|++
index|]
operator|=
name|c
expr_stmt|;
comment|/* Search for next first and last matching entries in binding list */
while|while
condition|(
name|KBCHR
argument_list|(
name|fp
argument_list|,
name|k
argument_list|)
operator|!=
name|c
operator|&&
name|fp
operator|!=
name|lp
condition|)
name|fp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBNXT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|KBCHR
argument_list|(
name|lp
argument_list|,
name|k
argument_list|)
operator|!=
name|c
operator|&&
name|lp
operator|!=
name|fp
condition|)
name|lp
operator|=
operator|(
name|klist
operator|*
operator|)
name|KBPRV
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* No match: exit loop */
if|if
condition|(
name|KBCHR
argument_list|(
name|fp
argument_list|,
name|k
argument_list|)
operator|!=
name|c
condition|)
break|break;
block|}
comment|/* No match: return character from input buffer */
operator|--
name|kcnt
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|kbuf
index|[
name|kind
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* getkey() */
end_comment

begin_comment
comment|/* Put back character c into input buffer */
end_comment

begin_function
name|GLOBL
name|VOID
name|ungetkey
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|kcnt
operator|<
name|KBUFLEN
condition|)
name|kbuf
index|[
name|kcnt
operator|++
index|]
operator|=
operator|(
name|kchar
operator|)
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ungetkey() */
end_comment

begin_comment
comment|/* Put back string s into input buffer */
end_comment

begin_function
name|GLOBL
name|int
name|ungetstring
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
default|default:
comment|/* Error */
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'b'
case|:
comment|/* Backspace ?? */
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Formfeed  ?? */
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Carriage return */
case|case
literal|'n'
case|:
comment|/* Newline */
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Tab */
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Space */
name|c
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Escape */
case|case
literal|'E'
case|:
name|c
operator|=
literal|0x1b
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'^'
condition|)
block|{
comment|/* Control chars ?? */
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'?'
condition|)
comment|/* DEL */
name|c
operator|=
literal|0x7f
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>=
literal|'@'
operator|&&
operator|*
name|s
operator|<=
literal|'_'
condition|)
comment|/* NUL .. US */
name|c
operator|=
operator|*
name|s
operator|-
literal|'@'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>=
literal|'a'
operator|&&
operator|*
name|s
operator|<=
literal|'z'
condition|)
comment|/* SOH .. SUB */
name|c
operator|=
operator|*
name|s
operator|-
literal|'`'
expr_stmt|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|c
operator|=
operator|*
name|s
expr_stmt|;
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ungetstring() */
end_comment

begin_comment
comment|/*  *      GLOBAL SCREEN ROUTINES  */
end_comment

begin_comment
comment|/* Move the cursor to new x,y position */
end_comment

begin_function
name|GLOBL
name|int
name|cursorxy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
name|columns
operator|+
name|x
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
name|lines
operator|+
name|y
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|columns
operator|||
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|lines
condition|)
block|{
name|curx
operator|=
name|cury
operator|=
name|HUGE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|_MS
operator|&&
name|vatt
condition|)
comment|/* Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatt
condition|)
comment|/* Reset graphic charset */
name|graphicset
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_CM
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|curx
operator|=
name|x
expr_stmt|;
name|cury
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cursorxy() */
end_comment

begin_comment
comment|/* Return current cursor position */
end_comment

begin_function
name|GLOBL
name|VOID
name|cursorpos
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|int
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|x
operator|=
name|curx
expr_stmt|;
operator|*
name|y
operator|=
name|cury
expr_stmt|;
block|}
end_block

begin_comment
comment|/* cursorpos() */
end_comment

begin_comment
comment|/* Insert character at cursor position */
end_comment

begin_function
name|GLOBL
name|int
name|insertchar
parameter_list|()
block|{
if|if
condition|(
name|_IC
condition|)
block|{
name|tputs
argument_list|(
name|_IC
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* insertchar() */
end_comment

begin_comment
comment|/* Delete character under cursor */
end_comment

begin_function
name|GLOBL
name|int
name|deletechar
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* USEANSICOLORS */
if|if
condition|(
name|_DC
condition|)
block|{
name|tputs
argument_list|(
name|_DC
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* deletechar() */
end_comment

begin_comment
comment|/* Insert n lines above line cursor is on */
end_comment

begin_function
name|GLOBL
name|int
name|insertline
parameter_list|(
name|y
parameter_list|,
name|n
parameter_list|)
specifier|register
name|int
name|y
decl_stmt|,
name|n
decl_stmt|;
block|{
if|if
condition|(
name|_AL
operator|&&
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
condition|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
name|tputs
argument_list|(
name|_AL
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* insertline() */
end_comment

begin_comment
comment|/* Delete n lines cursor is on */
end_comment

begin_function
name|GLOBL
name|int
name|deleteline
parameter_list|(
name|y
parameter_list|,
name|n
parameter_list|)
specifier|register
name|int
name|y
decl_stmt|,
name|n
decl_stmt|;
block|{
if|if
condition|(
name|_DL
operator|&&
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|y
argument_list|)
condition|)
block|{
while|while
condition|(
name|n
operator|--
condition|)
name|tputs
argument_list|(
name|_DL
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* deleteline() */
end_comment

begin_comment
comment|/* Set scroll window from line f to line t */
end_comment

begin_function
name|GLOBL
name|int
name|windowset
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|t
decl_stmt|;
block|{
comment|/* Set scroll region from line f to line t */
if|if
condition|(
name|_CS
operator|&&
name|f
operator|<=
name|t
condition|)
block|{
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_CS
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
argument_list|,
name|t
operator|-
name|f
operator|+
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* windowset() */
end_comment

begin_comment
comment|/* Scroll n lines up window from line f to line t */
end_comment

begin_function
name|GLOBL
name|int
name|windowup
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|t
decl_stmt|,
name|n
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
comment|/* No scrolling ! */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* USEANSICOLORS */
comment|/* Set scrollregion from f to t and scroll up n lines */
if|if
condition|(
name|_SF
operator|&&
name|windowset
argument_list|(
name|f
argument_list|,
name|t
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|tputs
argument_list|(
name|_SF
argument_list|,
name|lines
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
comment|/* Reset scroll region to screen */
operator|(
name|void
operator|)
name|windowset
argument_list|(
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Scroll up with a combination of insert and delete line */
elseif|else
if|if
condition|(
name|_AL
operator|&&
name|deleteline
argument_list|(
name|f
argument_list|,
name|n
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|insertline
argument_list|(
name|t
operator|-
name|n
operator|+
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* windowup() */
end_comment

begin_comment
comment|/* Scroll n lines down in window from line f to line t */
end_comment

begin_function
name|GLOBL
name|int
name|windowdown
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|t
decl_stmt|,
name|n
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
comment|/* No scrolling ! */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* USEANSICOLORS */
comment|/* Set scrollregion from f to t and scroll down n lines */
if|if
condition|(
name|_SR
operator|&&
name|windowset
argument_list|(
name|f
argument_list|,
name|t
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|tputs
argument_list|(
name|_SR
argument_list|,
name|lines
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
comment|/* Reset scroll region to screen */
operator|(
name|void
operator|)
name|windowset
argument_list|(
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Scroll down with a combination of insert and delete line */
elseif|else
if|if
condition|(
name|_AL
operator|&&
name|deleteline
argument_list|(
name|t
operator|-
name|n
operator|+
literal|1
argument_list|,
name|n
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|insertline
argument_list|(
name|f
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* windowdown() */
end_comment

begin_comment
comment|/* Clear from cursor position to end of line */
end_comment

begin_function
name|GLOBL
name|VOID
name|clearline
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
specifier|register
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
block|{
comment|/* Fill with blanks ! */
name|x
operator|=
name|curx
expr_stmt|;
for|for
control|(
name|i
operator|=
name|curx
init|;
name|i
operator|<
name|columns
operator|-
literal|1
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|_putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|_AM
operator|&&
name|_IC
condition|)
block|{
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_CM
argument_list|,
name|columns
operator|-
literal|2
argument_list|,
name|cury
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_IC
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
name|_putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|_CM
argument_list|,
name|x
argument_list|,
name|cury
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|curx
operator|=
name|x
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* USEANSICOLORS */
if|if
condition|(
operator|!
name|_MS
operator|&&
name|vatt
condition|)
comment|/* Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatt
condition|)
comment|/* Reset graphic charset */
name|graphicset
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_CE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clearline() */
end_comment

begin_comment
comment|/* Clear the screen */
end_comment

begin_function
name|GLOBL
name|VOID
name|clearscreen
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
block|{
comment|/* Fill with blanks ! */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|clearline
argument_list|()
expr_stmt|;
block|}
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* USEANSICOLORS */
if|if
condition|(
operator|!
name|_MS
operator|&&
name|vatt
condition|)
comment|/* RG 03/19/92: Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatt
condition|)
comment|/* RG 03/19/92: Reset graphic charset */
name|graphicset
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_CL
argument_list|,
name|lines
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clearscreen() */
end_comment

begin_comment
comment|/* Clear to end of screen */
end_comment

begin_function
name|GLOBL
name|int
name|cleartoend
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
block|{
comment|/* Fill with blanks ! */
for|for
control|(
name|i
operator|=
name|cury
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|clearline
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* USEANSICOLORS */
if|if
condition|(
name|_CD
condition|)
block|{
if|if
condition|(
operator|!
name|_MS
operator|&&
name|vatt
condition|)
comment|/* RG 03/19/92: Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatt
condition|)
comment|/* RG 03/19/92: Reset graphic charset */
name|graphicset
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_CD
argument_list|,
name|lines
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cleartoend() */
end_comment

begin_comment
comment|/* Clear screen from line f to line t */
end_comment

begin_function
name|GLOBL
name|VOID
name|clearwindow
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|t
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USEANSICOLORS
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
block|{
comment|/* Fill with blanks ! */
for|for
control|(
name|i
operator|=
name|f
init|;
name|i
operator|<=
name|t
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|clearline
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* USEANSICOLORS */
comment|/* Clear one line only */
if|if
condition|(
name|f
operator|==
name|t
condition|)
block|{
if|if
condition|(
operator|!
name|_MS
operator|&&
name|vatt
condition|)
comment|/* RG 03/19/92: Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatt
condition|)
comment|/* RG 03/19/92: Reset graphic charset */
name|graphicset
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_CE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
comment|/* Try clear to end of screen */
elseif|else
if|if
condition|(
name|t
operator|==
name|lines
operator|-
literal|1
operator|&&
name|_CD
condition|)
block|{
if|if
condition|(
operator|!
name|_MS
operator|&&
name|vatt
condition|)
comment|/* RG 03/19/92: Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatt
condition|)
comment|/* RG 03/19/92: Reset graphic charset */
name|graphicset
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_CD
argument_list|,
name|lines
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
comment|/* Try clear by window scrolling */
elseif|else
if|if
condition|(
operator|!
name|windowup
argument_list|(
name|f
argument_list|,
name|t
argument_list|,
name|t
operator|-
name|f
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* Clear line by line */
if|if
condition|(
operator|!
name|_MS
operator|&&
name|vatt
condition|)
comment|/* RG 03/19/92: Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatt
condition|)
comment|/* RG 03/19/92: Reset graphic charset */
name|graphicset
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
while|while
condition|(
name|f
operator|<=
name|t
condition|)
block|{
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|f
operator|++
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_CE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* clearwindow() */
end_comment

begin_comment
comment|/* Turn on/off keypad transmit mode if f is set/unset */
end_comment

begin_function
name|GLOBL
name|VOID
name|keypadxmit
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|&&
name|_KS
condition|)
comment|/* Keypad transmit mode */
name|tputs
argument_list|(
name|_KS
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_KE
condition|)
comment|/* Keypad normal mode */
name|tputs
argument_list|(
name|_KE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* keypadxmit() */
end_comment

begin_comment
comment|/* Do some cursor functions defined in mask c */
end_comment

begin_function
name|GLOBL
name|VOID
name|cursorset
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|&
name|CF_SAVE
operator|&&
name|_SC
condition|)
block|{
comment|/* Save cursor */
if|if
condition|(
name|vatt
condition|)
comment|/* Reset video attributes */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_SC
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|&
name|CF_RESTORE
operator|&&
name|_RC
condition|)
comment|/* Restore cursor */
name|tputs
argument_list|(
name|_RC
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|CF_VISIBLE
operator|&&
name|_VE
condition|)
comment|/* Cursor visible */
name|tputs
argument_list|(
name|_VE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|&
name|CF_INVISIBLE
operator|&&
name|_VI
condition|)
comment|/* Cursor invisible */
name|tputs
argument_list|(
name|_VI
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cursorset() */
end_comment

begin_comment
comment|/* Init graphical character set if f is set */
end_comment

begin_function
name|GLOBL
name|VOID
name|initgraphics
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ac
decl_stmt|;
name|GC_HB
operator|=
literal|'-'
expr_stmt|;
comment|/* Use ascii meta chars as default */
name|GC_VB
operator|=
name|GC_LT
operator|=
name|GC_RT
operator|=
literal|'|'
expr_stmt|;
name|GC_TT
operator|=
name|GC_BT
operator|=
name|GC_UL
operator|=
name|GC_LL
operator|=
name|GC_UR
operator|=
name|GC_LR
operator|=
name|GC_TG
operator|=
literal|'+'
expr_stmt|;
name|graphcap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|&&
operator|(
name|ac
operator|=
name|_AC
operator|)
condition|)
block|{
comment|/* If f is set and acsc is defined */
ifdef|#
directive|ifdef
name|AIX
name|GC_UL
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'+'
expr_stmt|;
comment|/* Upper left corner */
name|GC_HB
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'-'
expr_stmt|;
comment|/* Horizontal bar */
name|GC_UR
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'+'
expr_stmt|;
comment|/* Upper right corner */
name|GC_VB
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'|'
expr_stmt|;
comment|/* Vertical bar */
name|GC_LR
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'+'
expr_stmt|;
comment|/* Lower right corner */
name|GC_LL
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'+'
expr_stmt|;
comment|/* Lower left corner */
name|GC_TT
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'+'
expr_stmt|;
comment|/* Top tee */
name|GC_RT
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'|'
expr_stmt|;
comment|/* Right tee */
name|GC_BT
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'+'
expr_stmt|;
comment|/* Bottom tee */
name|GC_LT
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'|'
expr_stmt|;
comment|/* Left tee */
name|GC_TG
operator|=
operator|*
name|ac
condition|?
operator|*
name|ac
operator|++
else|:
literal|'+'
expr_stmt|;
comment|/* Tag: plus sign */
else|#
directive|else
comment|/* !AIX */
ifdef|#
directive|ifdef
name|XENIX
comment|/* RG 11/22/91 */
if|if
condition|(
operator|*
name|ac
operator|==
literal|'\0'
condition|)
block|{
name|GC_UL
operator|=
name|_G2
condition|?
operator|*
name|_G2
else|:
literal|'+'
expr_stmt|;
comment|/* Upper left corner */
name|GC_HB
operator|=
name|_GH
condition|?
operator|*
name|_GH
else|:
literal|'-'
expr_stmt|;
comment|/* Horizontal bar */
name|GC_UR
operator|=
name|_G1
condition|?
operator|*
name|_G1
else|:
literal|'+'
expr_stmt|;
comment|/* Upper right corner */
name|GC_VB
operator|=
name|_GV
condition|?
operator|*
name|_GV
else|:
literal|'|'
expr_stmt|;
comment|/* Vertical bar */
name|GC_LR
operator|=
name|_G4
condition|?
operator|*
name|_G4
else|:
literal|'+'
expr_stmt|;
comment|/* Lower right corner */
name|GC_LL
operator|=
name|_G3
condition|?
operator|*
name|_G3
else|:
literal|'+'
expr_stmt|;
comment|/* Lower left corner */
name|GC_TT
operator|=
name|_GD
condition|?
operator|*
name|_GD
else|:
literal|'+'
expr_stmt|;
comment|/* Top tee */
name|GC_RT
operator|=
name|_GL
condition|?
operator|*
name|_GL
else|:
literal|'|'
expr_stmt|;
comment|/* Right tee */
name|GC_BT
operator|=
name|_GU
condition|?
operator|*
name|_GU
else|:
literal|'+'
expr_stmt|;
comment|/* Bottom tee */
name|GC_LT
operator|=
name|_GR
condition|?
operator|*
name|_GR
else|:
literal|'|'
expr_stmt|;
comment|/* Left tee */
name|GC_TG
operator|=
name|_GC
condition|?
operator|*
name|_GC
else|:
literal|'+'
expr_stmt|;
comment|/* Tag: plus sign */
block|}
endif|#
directive|endif
comment|/* XENIX */
do|do
block|{
switch|switch
condition|(
operator|*
name|ac
condition|)
block|{
default|default:
comment|/* Skip */
operator|++
name|ac
expr_stmt|;
case|case
literal|'\0'
case|:
comment|/* End of acsc */
break|break;
case|case
literal|'j'
case|:
comment|/* Lower right corner */
name|GC_LR
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Upper right corner */
name|GC_UR
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Upper left corner */
name|GC_UL
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Lower left corner */
name|GC_LL
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Horizontal bar */
name|GC_HB
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Left tee */
name|GC_LT
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Right tee */
name|GC_RT
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Bottom tee */
name|GC_BT
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Top tee */
name|GC_TT
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Vertical bar */
name|GC_VB
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
comment|/* Tag sign: diamond */
name|GC_TG
operator|=
operator|*
operator|++
name|ac
condition|?
operator|*
name|ac
else|:
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Alternate tag sign: plus */
if|if
condition|(
operator|*
operator|++
name|ac
operator|&&
name|GC_TG
operator|==
literal|'+'
condition|)
name|GC_TG
operator|=
operator|*
name|ac
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
name|ac
operator|&&
operator|*
operator|++
name|ac
condition|)
do|;
endif|#
directive|endif
comment|/* AIX */
name|graphcap
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|_EA
condition|)
name|tputs
argument_list|(
name|_EA
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* initgraphics() */
end_comment

begin_comment
comment|/*  *      COLOR HANDLING ON ANSI COMPATIBLE TERMINALS  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USEANSICOLORS
end_ifdef

begin_comment
comment|/* Reset any color settings to original colors and clear screen */
end_comment

begin_function
name|GLOBL
name|VOID
name|colorset
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|colorcap
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|CS_RESET
condition|)
block|{
if|if
condition|(
name|_OP
condition|)
name|tputs
argument_list|(
name|_OP
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_CL
argument_list|,
name|lines
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
name|CS_INIT
operator|&&
name|usecolors
condition|)
block|{
name|clearscreen
argument_list|()
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* colorset() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USEANSICOLORS */
end_comment

begin_comment
comment|/*  *      TERMINAL ROUTINES  */
end_comment

begin_comment
comment|/* Switch terminal to raw mode */
end_comment

begin_function
name|GLOBL
name|VOID
name|terminalraw
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|_TI
operator|&&
name|f
condition|)
name|tputs
argument_list|(
name|_TI
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|curx
operator|=
name|cury
operator|=
name|HUGE
expr_stmt|;
name|keypadxmit
argument_list|(
name|KP_XMIT
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|raw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminalraw() */
end_comment

begin_comment
comment|/* Reset terminal to initial mode */
end_comment

begin_function
name|GLOBL
name|VOID
name|terminalreset
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|&&
name|_TE
condition|)
name|tputs
argument_list|(
name|_TE
argument_list|,
literal|1
argument_list|,
name|_putch
argument_list|)
expr_stmt|;
name|curx
operator|=
name|cury
operator|=
name|HUGE
expr_stmt|;
name|keypadxmit
argument_list|(
name|KP_NORMAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USEANSICOLORS
if|if
condition|(
name|colorcap
operator|&&
name|usecolors
condition|)
name|colorset
argument_list|(
name|CS_RESET
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* USEANSICOLORS */
name|videoset
argument_list|(
name|VA_NORMAL
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminalreset() */
end_comment

begin_comment
comment|/* Enable signal handling */
end_comment

begin_function
name|GLOBL
name|VOID
name|enablesignals
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BSD
name|raw
operator|.
name|sg_flags
operator|&=
operator|~
name|RAW
expr_stmt|;
name|raw
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
else|#
directive|else
comment|/* SYSV */
name|raw
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|flushout
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|raw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* enablesignals() */
end_comment

begin_comment
comment|/* Disable signal handling */
end_comment

begin_function
name|GLOBL
name|VOID
name|disablesignals
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|BSD
name|raw
operator|.
name|sg_flags
operator|&=
operator|~
name|CBREAK
expr_stmt|;
name|raw
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
else|#
directive|else
comment|/* SYSV */
name|raw
operator|.
name|c_lflag
operator|&=
operator|~
name|ISIG
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|flushout
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|raw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* disablesignals() */
end_comment

begin_comment
comment|/*  *      INITIALIZATION AND RESET  */
end_comment

begin_comment
comment|/* Init screen, return error message on error */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|initscreen
parameter_list|(
name|term
parameter_list|)
specifier|register
name|char
modifier|*
name|term
decl_stmt|;
block|{
name|char
name|termcap
index|[
name|TCAPLEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|termbuf
decl_stmt|,
modifier|*
name|pc
decl_stmt|;
comment|/* Get terminal type and init terminal data base */
if|if
condition|(
name|term
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"Terminal variable TERM not defined"
operator|)
return|;
switch|switch
condition|(
name|tgetent
argument_list|(
name|termcap
argument_list|,
name|term
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
operator|(
literal|"Terminfo library not found"
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
literal|"Unknown terminal type"
operator|)
return|;
block|}
comment|/* Get all needed terminal capabilities from data base */
if|if
condition|(
operator|(
name|columns
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|columns
operator|=
name|MINCOLS
expr_stmt|;
if|if
condition|(
operator|(
name|lines
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|lines
operator|=
name|MINLINS
expr_stmt|;
name|UP
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|cp
argument_list|)
condition|)
name|PC
operator|=
operator|*
name|pc
expr_stmt|;
name|_CM
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_CL
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_CE
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* Cursor motion, clear screen and clear line must be defined ! */
if|if
condition|(
name|_CM
operator|==
name|NULL
operator|||
name|_CE
operator|==
name|NULL
operator|||
name|_CL
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"Terminal too stupid"
operator|)
return|;
name|_XR
operator|=
name|tgetflag
argument_list|(
literal|"xr"
argument_list|)
expr_stmt|;
name|_MS
operator|=
name|tgetflag
argument_list|(
literal|"ms"
argument_list|)
expr_stmt|;
name|_SG
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|_UG
operator|=
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYSV */
name|_UG
operator|=
name|_SG
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|_CD
operator|=
name|tgetstr
argument_list|(
literal|"cd"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_TI
operator|=
name|tgetstr
argument_list|(
literal|"ti"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_TE
operator|=
name|tgetstr
argument_list|(
literal|"te"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_KS
operator|=
name|tgetstr
argument_list|(
literal|"ks"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_KE
operator|=
name|tgetstr
argument_list|(
literal|"ke"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_ME
operator|=
name|tgetstr
argument_list|(
literal|"me"
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|_ME
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_MR
operator|=
name|tgetstr
argument_list|(
literal|"mr"
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|_MR
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|_US
operator|=
name|tgetstr
argument_list|(
literal|"us"
argument_list|,
operator|&
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|_UE
operator|=
name|tgetstr
argument_list|(
literal|"ue"
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
operator|&&
name|_ME
operator|&&
name|EQU
argument_list|(
name|_ME
argument_list|,
name|_UE
argument_list|)
condition|)
name|_UE
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* No more video attributes and no cursor visibility functions for   */
comment|/* terminals with standout mode and/or underline glitch (i.e. bando) */
if|if
condition|(
name|_UG
operator|<=
literal|0
operator|&&
name|_SG
operator|<=
literal|0
condition|)
block|{
name|_MB
operator|=
name|tgetstr
argument_list|(
literal|"mb"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_MD
operator|=
name|tgetstr
argument_list|(
literal|"md"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_MH
operator|=
name|tgetstr
argument_list|(
literal|"mh"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_VS
operator|=
name|tgetstr
argument_list|(
literal|"vs"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_VI
operator|=
name|tgetstr
argument_list|(
literal|"vi"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_VE
operator|=
name|tgetstr
argument_list|(
literal|"ve"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
name|_IC
operator|=
name|tgetstr
argument_list|(
literal|"ic"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_DC
operator|=
name|tgetstr
argument_list|(
literal|"dc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_AL
operator|=
name|tgetstr
argument_list|(
literal|"al"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_DL
operator|=
name|tgetstr
argument_list|(
literal|"dl"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_CS
operator|=
name|tgetstr
argument_list|(
literal|"cs"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_NL
operator|=
name|tgetstr
argument_list|(
literal|"nl"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_CR
operator|=
name|tgetstr
argument_list|(
literal|"cr"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_LE
operator|=
name|tgetstr
argument_list|(
literal|"le"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_DO
operator|=
name|tgetstr
argument_list|(
literal|"do"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_SF
operator|=
name|tgetstr
argument_list|(
literal|"sf"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_SR
operator|=
name|tgetstr
argument_list|(
literal|"sr"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_SC
operator|=
name|tgetstr
argument_list|(
literal|"sc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_RC
operator|=
name|tgetstr
argument_list|(
literal|"rc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_BL
operator|=
name|tgetstr
argument_list|(
literal|"bl"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AIX
name|_AC
operator|=
name|tgetstr
argument_list|(
literal|"bx"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* Use box1 (bx) instead of acsc (ac) */
if|if
condition|(
operator|!
operator|(
name|_AS
operator|=
name|tgetstr
argument_list|(
literal|"as"
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
condition|)
name|_AS
operator|=
name|tgetstr
argument_list|(
literal|"f1"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* 3.2: Use font1 (f1) instead of smacs (as) */
if|if
condition|(
operator|!
operator|(
name|_AE
operator|=
name|tgetstr
argument_list|(
literal|"ae"
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
condition|)
name|_AE
operator|=
name|tgetstr
argument_list|(
literal|"f0"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* 3.2: Use font0 (f0) instead of rmacs (ae) */
else|#
directive|else
comment|/* ACSC */
name|_EA
operator|=
name|tgetstr
argument_list|(
literal|"eA"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_AC
operator|=
name|tgetstr
argument_list|(
literal|"ac"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_AS
operator|=
name|tgetstr
argument_list|(
literal|"as"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_AE
operator|=
name|tgetstr
argument_list|(
literal|"ae"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XENIX
comment|/* RG 11/22/91 */
if|if
condition|(
name|_AC
operator|==
name|NULL
condition|)
block|{
name|_AC
operator|=
literal|""
expr_stmt|;
comment|/* Use empty string _AC as flag */
name|_AS
operator|=
name|tgetstr
argument_list|(
literal|"GS"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_AE
operator|=
name|tgetstr
argument_list|(
literal|"GE"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_G2
operator|=
name|tgetstr
argument_list|(
literal|"G2"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_GH
operator|=
name|tgetstr
argument_list|(
literal|"GH"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_G1
operator|=
name|tgetstr
argument_list|(
literal|"G1"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_GV
operator|=
name|tgetstr
argument_list|(
literal|"GV"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_G4
operator|=
name|tgetstr
argument_list|(
literal|"G4"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_G3
operator|=
name|tgetstr
argument_list|(
literal|"G3"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_GD
operator|=
name|tgetstr
argument_list|(
literal|"GD"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_GL
operator|=
name|tgetstr
argument_list|(
literal|"GL"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_GU
operator|=
name|tgetstr
argument_list|(
literal|"GU"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_GR
operator|=
name|tgetstr
argument_list|(
literal|"GR"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|_GC
operator|=
name|tgetstr
argument_list|(
literal|"GC"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XENIX */
endif|#
directive|endif
comment|/* AIX */
ifdef|#
directive|ifdef
name|USEANSICOLORS
if|if
condition|(
operator|(
name|_CO
operator|=
name|tgetnum
argument_list|(
literal|"Co"
argument_list|)
operator|)
operator|>
literal|7
condition|)
block|{
comment|/* Seems to know ansi colors */
name|_AM
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|_OP
operator|=
name|tgetstr
argument_list|(
literal|"op"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_AB
operator|=
name|tgetstr
argument_list|(
literal|"AB"
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
condition|)
name|_AB
operator|=
name|tgetstr
argument_list|(
literal|"Sb"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_AF
operator|=
name|tgetstr
argument_list|(
literal|"AF"
argument_list|,
operator|&
name|cp
argument_list|)
operator|)
condition|)
name|_AF
operator|=
name|tgetstr
argument_list|(
literal|"Sf"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_CO
operator|<
literal|8
operator|||
operator|!
name|_AB
operator|||
operator|!
name|_AF
condition|)
name|colorcap
operator|=
literal|0
expr_stmt|;
else|else
name|colorcap
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* USEANSICOLORS */
if|if
condition|(
name|_CS
operator|&&
operator|!
name|_SF
condition|)
block|{
if|if
condition|(
name|_DO
condition|)
name|_SF
operator|=
name|_DO
expr_stmt|;
elseif|else
if|if
condition|(
name|_NL
condition|)
name|_SF
operator|=
name|_NL
expr_stmt|;
else|else
name|_SF
operator|=
literal|"\n"
expr_stmt|;
block|}
if|if
condition|(
name|_VS
operator|&&
operator|!
name|_VE
condition|)
name|_VE
operator|=
name|_VS
expr_stmt|;
comment|/* Set capability flags */
name|glitchcap
operator|=
name|_UG
operator|>
literal|0
operator|||
name|_SG
operator|>
literal|0
expr_stmt|;
name|scrollcap
operator|=
operator|(
name|_AL
operator|&&
name|_DL
operator|)
operator|||
operator|(
name|_CS
operator|&&
name|_SF
operator|&&
name|_SR
operator|)
expr_stmt|;
name|cursorcap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_VE
operator|&&
name|_VI
condition|)
name|cursorcap
operator||=
name|CF_VISIBLE
operator||
name|CF_INVISIBLE
expr_stmt|;
if|if
condition|(
name|_SC
operator|&&
name|_RC
condition|)
name|cursorcap
operator||=
name|CF_SAVE
operator||
name|CF_RESTORE
expr_stmt|;
name|videocap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_MR
condition|)
name|videocap
operator||=
name|VA_REVERSE
expr_stmt|;
if|if
condition|(
name|_MB
condition|)
name|videocap
operator||=
name|VA_BLINK
expr_stmt|;
if|if
condition|(
name|_MD
condition|)
name|videocap
operator||=
name|VA_BOLD
expr_stmt|;
if|if
condition|(
name|_MH
condition|)
name|videocap
operator||=
name|VA_HALF
expr_stmt|;
if|if
condition|(
name|_US
condition|)
name|videocap
operator||=
name|VA_UNDERLINE
expr_stmt|;
comment|/* Initialize key bindings */
name|initbindings
argument_list|(
name|term
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* Get terminal driver data and initialize raw mode */
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|"Error in ioctl"
operator|)
return|;
ifdef|#
directive|ifdef
name|STRUCTCOPY
operator|(
name|void
operator|)
name|STRUCTCOPY
argument_list|(
name|tty
argument_list|,
name|raw
argument_list|,
sizeof|sizeof
argument_list|(
name|tty
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STRUCTASSIGN */
name|raw
operator|=
name|tty
expr_stmt|;
endif|#
directive|endif
comment|/* STRUCTCOPY */
ifdef|#
directive|ifdef
name|BSD
name|ospeed
operator|=
name|tty
operator|.
name|sg_ospeed
expr_stmt|;
name|raw
operator|.
name|sg_flags
operator||=
name|ANYP
operator||
name|RAW
expr_stmt|;
name|raw
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|XTABS
operator|)
expr_stmt|;
else|#
directive|else
comment|/* SYSV */
name|raw
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|raw
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|raw
operator|.
name|c_iflag
operator||=
name|IGNBRK
expr_stmt|;
name|raw
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|ICRNL
operator||
name|ISTRIP
operator|)
expr_stmt|;
name|raw
operator|.
name|c_oflag
operator||=
name|ONLCR
operator||
name|TAB0
expr_stmt|;
name|raw
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
name|raw
operator|.
name|c_cflag
operator|&=
operator|~
name|PARENB
expr_stmt|;
name|raw
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|ISIG
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HASFIONREAD
argument_list|)
comment|/* Get keyboard flag and set to no delay mode */
name|kbflag
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
name|O_NDELAY
expr_stmt|;
endif|#
directive|endif
comment|/* !BSD&& !HASFIONREAD */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* initscreen() */
end_comment

begin_comment
comment|/* Restore screen and exit */
end_comment

begin_function
name|GLOBL
name|int
name|exitscreen
parameter_list|(
name|rval
parameter_list|)
name|int
name|rval
decl_stmt|;
block|{
name|cursorset
argument_list|(
name|CF_VISIBLE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|terminalreset
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exitscreen() */
end_comment

end_unit

