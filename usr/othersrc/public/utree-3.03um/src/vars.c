begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      VARS.C  *      UTREE variable handling routines.  *      3.01-um klin, Sun May  5 11:05:05 1991  *      3.02-um klin, Fri Nov  1 10:46:14 1991, Option -u changed to -n  *              klin, Sun Nov 24 15:26:19 1991, Video attributes changed  *      3.03-um klin, Tue Feb 11 14:18:50 1992, Generic lists for variables  *                                              and file type commands  *              klin, Sat Feb 15 14:44:52 1992, Video handling and partinioning of  *                                              directory and file windows changed  *              klin, Sun Feb 23 18:45:19 1992, Keybindings and variable  *                                              AUTOSAVE added  *              klin, Fri Mar  6 09:34:43 1992, Release undefined commands  *            a klin, Sun Mar 15 19:08:25 1992, Accept command without comment  *            b klin, Sun Mar 22 10:41:36 1992, Bug fix and minor changes  *            e klin, Sat Apr 11 11:05:54 1992, Use colors for video attributes  *  *      Copyright (c) 1991/92 by Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03e-um (klin) Apr 11 1992 vars.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ---- Local variables and definitions ------------------------------- */
end_comment

begin_comment
comment|/* Format for user command menulines on tree and file screen            */
end_comment

begin_define
define|#
directive|define
name|UMENUFORM
define|\
value|" 1:      2:      3:      4:      5:      6:      7:      8:      9:     "
end_define

begin_define
define|#
directive|define
name|FIRST
value|3
end_define

begin_define
define|#
directive|define
name|OFFSET
value|8
end_define

begin_define
define|#
directive|define
name|TITLE
value|5
end_define

begin_define
define|#
directive|define
name|XUNDEF
value|((xlist *) -1)
end_define

begin_comment
comment|/* Undefined or released xlist          */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|vcchg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables/commands changed           */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|novar
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Empty string variable                */
end_comment

begin_function_decl
name|GLOBL
name|VOID
name|checkindent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|GLOBL
name|VOID
name|checklines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|LOCAL
name|VOID
name|setsortflag
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USEANSICOLORS
end_ifdef

begin_function_decl
name|LOCAL
name|VOID
name|setcolorflag
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USEANSICOLORS */
end_comment

begin_comment
comment|/* ---- External variables and functions ------------------------------ */
end_comment

begin_function_decl
name|EXTRN
name|char
modifier|*
name|getversion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|strclean
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ---- Functions and procedures -------------------------------------- */
end_comment

begin_comment
comment|/*  *      INTERNAL USED ROUTINES  */
end_comment

begin_comment
comment|/* Show all variables */
end_comment

begin_function
name|LOCAL
name|int
name|showallvars
parameter_list|()
block|{
specifier|register
name|vlist
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|,
name|c
decl_stmt|;
name|l
operator|=
name|firstline
expr_stmt|;
name|c
operator|=
name|RV_OK
expr_stmt|;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|VARTAB
argument_list|(
literal|0
argument_list|)
operator|,
name|l
operator|=
name|firstline
init|;
name|vp
condition|;
name|vp
operator|=
operator|(
name|vlist
operator|*
operator|)
name|VNEXT
argument_list|(
name|vp
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|putfxy
argument_list|(
literal|0
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s %12s="
argument_list|,
name|VSCUT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|VNAME
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VTYPE
argument_list|(
name|vp
argument_list|)
operator|==
name|VT_B
condition|)
name|c
operator|=
name|putfxy
argument_list|(
literal|16
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|==
name|VB_ON
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|putfxy
argument_list|(
literal|16
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|VVALE
argument_list|(
name|vp
argument_list|)
condition|?
name|VVALE
argument_list|(
name|vp
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|VCOMM
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|c
operator|>
name|columns
operator|/
literal|2
condition|?
name|c
else|:
name|columns
operator|/
literal|2
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"#%s"
argument_list|,
name|VCOMM
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|l
operator|>
name|lastline
operator|&&
name|VNEXT
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|puthelp
argument_list|(
literal|"VARIABLES (CR:continue  Q:quit  ELSE:set/unset)"
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"More variables ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
break|break;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
name|l
operator|=
name|firstline
expr_stmt|;
block|}
block|}
name|treeflag
operator|=
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* showallvars() */
end_comment

begin_comment
comment|/* Display file type dependent commands */
end_comment

begin_function
name|LOCAL
name|int
name|showallcmds
parameter_list|()
block|{
specifier|register
name|xlist
modifier|*
name|xp
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|,
name|c
decl_stmt|;
name|l
operator|=
name|firstline
expr_stmt|;
name|c
operator|=
name|RV_OK
expr_stmt|;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|xroot
operator|,
name|l
operator|=
name|firstline
init|;
name|xp
condition|;
name|xp
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|xp
argument_list|)
control|)
block|{
name|c
operator|=
name|putfxy
argument_list|(
literal|0
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s:%s"
argument_list|,
name|XTYPE
argument_list|(
name|xp
argument_list|)
argument_list|,
name|XCOMD
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XCOMM
argument_list|(
name|xp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|c
operator|>
operator|(
name|columns
operator|/
literal|2
operator|)
condition|?
name|c
operator|+
literal|1
else|:
name|columns
operator|/
literal|2
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"#%s"
argument_list|,
name|XCOMM
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|l
operator|>
name|lastline
operator|&&
name|XNEXT
argument_list|(
name|xp
argument_list|)
condition|)
block|{
name|puthelp
argument_list|(
literal|"FILETYPE COMMANDS (CR:continue  Q:quit  ELSE:set/unset)"
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"More filetype commands ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
break|break;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
name|l
operator|=
name|firstline
expr_stmt|;
block|}
block|}
name|treeflag
operator|=
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* showallcmds() */
end_comment

begin_comment
comment|/* Set sort criteria flag for file lists */
end_comment

begin_function
name|LOCAL
name|VOID
name|setsortflag
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
name|sortbytime
operator|=
name|f
condition|?
literal|0
else|:
literal|1
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|droot
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
operator|(
name|void
operator|)
name|sortlist
argument_list|(
name|dp
argument_list|,
name|sortbytime
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* setsortflag() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USEANSICOLORS
end_ifdef

begin_comment
comment|/* Set color using flag */
end_comment

begin_function
name|LOCAL
name|VOID
name|setcolorflag
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
name|usecolors
operator|=
name|f
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|colorcap
condition|)
name|colorset
argument_list|(
name|usecolors
condition|?
name|CS_INIT
else|:
name|CS_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* setcolorflag() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USEANSICOLORS */
end_comment

begin_comment
comment|/* Set tree indention variable */
end_comment

begin_function
name|LOCAL
name|int
name|setindent
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
name|MININD
operator|||
name|i
operator|>
name|MAXIND
condition|)
comment|/* Out of range */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|maxindent
operator|=
name|indent
operator|=
name|i
expr_stmt|;
comment|/* Set indention variables */
name|checkindent
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* setindent() */
end_comment

begin_comment
comment|/* Set video mode variable */
end_comment

begin_function
name|GLOBL
name|int
name|setvideomode
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
name|VMODE0
operator|||
name|i
operator|>
name|VMODE2
condition|)
comment|/* Out of range */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|glitchcap
operator|&&
name|i
operator|>
name|VMODE1
condition|)
comment|/* Respect glitches */
name|i
operator|=
name|VMODE1
expr_stmt|;
name|videomode
operator|=
name|i
expr_stmt|;
comment|/* Set video mode variables */
operator|*
name|VARVAL
argument_list|(
name|V_VM
argument_list|)
operator|=
name|videomode
operator|+
literal|'0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* setvideomode() */
end_comment

begin_comment
comment|/* Set number of file lines on tree screen */
end_comment

begin_function
name|LOCAL
name|int
name|setfilelines
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<
name|MINFIL
operator|||
name|n
operator|>
name|MAXFIL
condition|)
comment|/* Out of range */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|maxnflines
operator|=
name|n
expr_stmt|;
name|checklines
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* setfilelines() */
end_comment

begin_comment
comment|/*  *      USER COMMAND ROUTINES  */
end_comment

begin_comment
comment|/* Build command line s from user command v with value p */
end_comment

begin_function
name|GLOBL
name|int
name|userformat
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|v
parameter_list|,
name|w
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|p
decl_stmt|,
modifier|*
name|w
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|INPLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|pp
operator|=
name|p
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
comment|/* Scan command format */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|s
operator|++
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* Request for parameter */
case|case
literal|'S'
case|:
name|puthelp
argument_list|(
literal|"%s: Parameter %d for %s"
argument_list|,
name|w
argument_list|,
operator|++
name|n
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Give Parameter %d:"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|fp
operator|=
name|buf
expr_stmt|;
goto|goto
name|DOCOPY
goto|;
case|case
literal|'B'
case|:
comment|/* Basename of directory or file */
case|case
literal|'b'
case|:
if|if
condition|(
name|v
operator|>
name|V_FC0
condition|)
block|{
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
return|return
operator|(
name|RV_NUL
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
name|fp
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|=
name|buf
expr_stmt|;
goto|goto
name|DOCOPY
goto|;
case|case
literal|'F'
case|:
comment|/* Filename of directory or file */
case|case
literal|'f'
case|:
if|if
condition|(
name|v
operator|>
name|V_FC0
condition|)
block|{
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
return|return
operator|(
name|RV_NUL
operator|)
return|;
name|fp
operator|=
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|CFNAM
expr_stmt|;
goto|goto
name|DOCOPY
goto|;
case|case
literal|'R'
case|:
comment|/* Root directory */
case|case
literal|'r'
case|:
name|fp
operator|=
name|rootdir
expr_stmt|;
goto|goto
name|DOCOPY
goto|;
case|case
literal|'H'
case|:
comment|/* Home directory */
case|case
literal|'h'
case|:
name|fp
operator|=
name|home
expr_stmt|;
goto|goto
name|DOCOPY
goto|;
case|case
literal|'P'
case|:
comment|/* Full pathname of directory or file */
case|case
literal|'p'
case|:
if|if
condition|(
name|v
operator|>
name|V_FC0
condition|)
block|{
if|if
condition|(
name|CNFIL
operator|==
literal|0
condition|)
return|return
operator|(
name|RV_NUL
operator|)
return|;
name|fp
operator|=
name|CPNAM
expr_stmt|;
while|while
condition|(
operator|*
name|fp
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'/'
expr_stmt|;
name|fp
operator|=
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|CFCUR
argument_list|)
expr_stmt|;
goto|goto
name|DOCOPY
goto|;
block|}
comment|/* Directory: fall thru */
case|case
literal|'D'
case|:
comment|/* Current directory name */
case|case
literal|'d'
case|:
name|fp
operator|=
name|CPNAM
expr_stmt|;
name|DOCOPY
label|:
while|while
condition|(
operator|*
name|fp
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
comment|/* As it is */
operator|*
name|s
operator|++
operator|=
literal|'%'
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|RV_NUL
operator|)
return|;
comment|/* Bad format */
block|}
operator|++
name|p
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate command line */
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/* userformat() */
end_comment

begin_comment
comment|/* Execute an user defined command v */
end_comment

begin_function
name|GLOBL
name|int
name|usercommand
parameter_list|(
name|v
parameter_list|)
specifier|register
name|int
name|v
decl_stmt|;
block|{
name|char
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Check if usercommand is set */
if|if
condition|(
operator|!
name|VARSET
argument_list|(
name|v
argument_list|)
condition|)
return|return
operator|(
name|errequest
argument_list|(
literal|"User command"
argument_list|,
literal|"Not defined"
argument_list|)
operator|)
return|;
comment|/* Build command line */
else|else
block|{
name|c
operator|=
name|userformat
argument_list|(
name|buf
argument_list|,
name|VARVAL
argument_list|(
name|v
argument_list|)
argument_list|,
name|v
argument_list|,
name|VARNAM
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
return|return
operator|(
name|errequest
argument_list|(
literal|"User command"
argument_list|,
literal|"Bad format"
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"USER COMMAND: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|c
operator|=
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|checkdlist
argument_list|(
name|CPNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|errequest
argument_list|(
literal|"User command"
argument_list|,
literal|"Error in executing"
argument_list|)
operator|)
return|;
return|return
operator|(
name|hitakey
argument_list|(
literal|"Return from user command (Hit a key)"
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|DA_REVERSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* usercommand() */
end_comment

begin_comment
comment|/*  *      FILE TYPE COMMAND ROUTINES  */
end_comment

begin_comment
comment|/* Set file type command */
end_comment

begin_function
name|GLOBL
name|xlist
modifier|*
name|setcommand
parameter_list|(
name|type
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|type
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|xlist
modifier|*
name|xp
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|comd
decl_stmt|,
modifier|*
name|comm
decl_stmt|;
comment|/* Search for filetype - command separator ':' */
if|if
condition|(
operator|(
name|comd
operator|=
name|strchr
argument_list|(
name|type
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|comd
operator|==
name|type
condition|)
return|return
operator|(
name|XNULL
operator|)
return|;
else|else
operator|*
name|comd
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get additional comment lead in by '#' */
if|if
condition|(
name|comm
operator|=
name|strchr
argument_list|(
name|comd
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
operator|*
name|comm
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|comm
operator|=
name|strclean
argument_list|(
name|comm
argument_list|)
expr_stmt|;
block|}
name|comd
operator|=
name|strclean
argument_list|(
name|comd
argument_list|)
expr_stmt|;
comment|/* Search for file type to set in command list */
for|for
control|(
name|xp
operator|=
name|xroot
init|;
name|xp
condition|;
name|xp
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|xp
argument_list|)
control|)
if|if
condition|(
name|EQU
argument_list|(
name|type
argument_list|,
name|XTYPE
argument_list|(
name|xp
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Replace or delete an existing file type command */
if|if
condition|(
name|xp
condition|)
block|{
name|ufree
argument_list|(
name|XCOMD
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
name|XCOMM
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comd
operator|==
name|NULL
operator|||
operator|*
name|comd
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|xroot
operator|&&
name|xp
operator|==
name|xroot
condition|)
block|{
if|if
condition|(
name|xroot
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|xp
argument_list|)
condition|)
name|XPREV
argument_list|(
name|xroot
argument_list|)
operator|=
name|GNULL
expr_stmt|;
else|else
name|xroot
operator|=
name|XNULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XPREV
argument_list|(
name|xp
argument_list|)
condition|)
name|XNEXT
argument_list|(
name|p
argument_list|)
operator|=
name|XNEXT
argument_list|(
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|xp
argument_list|)
condition|)
name|XPREV
argument_list|(
name|p
argument_list|)
operator|=
name|XPREV
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
name|ufree
argument_list|(
name|XTYPE
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
name|ufree
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|XUNDEF
expr_stmt|;
block|}
block|}
comment|/* Ignore invalid definition */
elseif|else
if|if
condition|(
name|comd
operator|==
name|NULL
operator|||
operator|*
name|comd
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|XUNDEF
operator|)
return|;
comment|/* Create and insert a new entry in file type command list */
elseif|else
if|if
condition|(
name|xp
operator|=
operator|(
name|xlist
operator|*
operator|)
name|ualloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|xlist
argument_list|)
argument_list|)
condition|)
block|{
name|XTYPE
argument_list|(
name|xp
argument_list|)
operator|=
name|strsav
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|xroot
operator|&&
name|CMP
argument_list|(
name|type
argument_list|,
name|XTYPE
argument_list|(
name|xroot
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|pp
operator|=
name|xroot
init|;
name|XNEXT
argument_list|(
name|pp
argument_list|)
condition|;
name|pp
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|pp
argument_list|)
control|)
block|{
name|p
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|CMP
argument_list|(
name|type
argument_list|,
name|XTYPE
argument_list|(
name|pp
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
break|break;
block|}
name|XPREV
argument_list|(
name|xp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|pp
expr_stmt|;
name|XNEXT
argument_list|(
name|xp
argument_list|)
operator|=
name|XNEXT
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|pp
argument_list|)
condition|)
name|XPREV
argument_list|(
name|p
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|xp
expr_stmt|;
name|XNEXT
argument_list|(
name|pp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|xp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xroot
condition|)
name|XPREV
argument_list|(
name|xroot
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|xp
expr_stmt|;
name|XPREV
argument_list|(
name|xp
argument_list|)
operator|=
name|GNULL
expr_stmt|;
name|XNEXT
argument_list|(
name|xp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|xroot
expr_stmt|;
name|xroot
operator|=
name|xp
expr_stmt|;
block|}
block|}
comment|/* Insert command and comment and return */
if|if
condition|(
name|comd
operator|&&
operator|*
name|comd
condition|)
block|{
name|XCOMD
argument_list|(
name|xp
argument_list|)
operator|=
name|strsav
argument_list|(
name|comd
argument_list|)
expr_stmt|;
name|XCOMM
argument_list|(
name|xp
argument_list|)
operator|=
name|comm
operator|&&
operator|*
name|comm
condition|?
name|strsav
argument_list|(
name|comm
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xp
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|VC_CHG
condition|)
name|vcchg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|xp
operator|)
return|;
block|}
else|else
return|return
operator|(
name|XNULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* setcommand() */
end_comment

begin_comment
comment|/* Show and set/unset filetype commands */
end_comment

begin_function
name|GLOBL
name|int
name|commands
parameter_list|()
block|{
name|char
name|buf
index|[
literal|3
operator|*
name|INPLEN
index|]
decl_stmt|,
name|typ
index|[
name|INPLEN
index|]
decl_stmt|,
name|cmd
index|[
name|INPLEN
index|]
decl_stmt|,
name|cmt
index|[
name|INPLEN
index|]
decl_stmt|;
specifier|register
name|xlist
modifier|*
name|xp
init|=
name|XUNDEF
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|;
name|who
operator|=
literal|"SET COMMAND"
expr_stmt|;
name|f
operator|=
literal|1
expr_stmt|;
comment|/* Filetype command loop */
while|while
condition|(
literal|1
condition|)
block|{
name|cmd
index|[
literal|0
index|]
operator|=
name|cmt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|f
operator|&&
operator|(
operator|(
name|c
operator|=
name|showallcmds
argument_list|()
operator|)
operator|<
name|RV_NUL
operator|||
name|c
operator|==
literal|'q'
operator|)
condition|)
break|break;
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xp
operator|==
name|XUNDEF
operator|||
name|xp
operator|==
name|XNULL
condition|)
name|xp
operator|=
name|xroot
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give filetype or type:command (CR:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Set command:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|typ
argument_list|,
sizeof|sizeof
argument_list|(
name|typ
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'d'
argument_list|,
name|NULL
argument_list|,
name|xp
condition|?
name|XLIST
argument_list|(
name|xp
argument_list|)
else|:
name|GNULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
break|break;
if|if
condition|(
name|strchr
argument_list|(
name|typ
argument_list|,
literal|':'
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|typ
argument_list|)
expr_stmt|;
else|else
block|{
name|puthelp
argument_list|(
literal|"%s: Give command for %s (CR:unset)"
argument_list|,
name|who
argument_list|,
name|typ
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Command for %s:"
argument_list|,
name|typ
argument_list|)
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|xroot
init|;
name|xp
condition|;
name|xp
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|xp
argument_list|)
control|)
if|if
condition|(
name|EQU
argument_list|(
name|typ
argument_list|,
name|XTYPE
argument_list|(
name|xp
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'d'
argument_list|,
name|xp
condition|?
name|XCOMD
argument_list|(
name|xp
argument_list|)
else|:
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:"
argument_list|,
name|typ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|cmd
argument_list|,
literal|'#'
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s"
argument_list|,
name|typ
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
block|{
name|puthelp
argument_list|(
literal|"%s: Give comment for %s"
argument_list|,
name|who
argument_list|,
name|typ
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Comment for %s:"
argument_list|,
name|typ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|cmt
argument_list|,
sizeof|sizeof
argument_list|(
name|cmt
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'d'
argument_list|,
name|xp
condition|?
name|XCOMM
argument_list|(
name|xp
argument_list|)
else|:
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s#%s"
argument_list|,
name|typ
argument_list|,
name|cmd
argument_list|,
name|cmt
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s"
argument_list|,
name|typ
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|xp
operator|=
name|setcommand
argument_list|(
name|buf
argument_list|,
name|VC_CHG
argument_list|)
operator|)
operator|==
name|XNULL
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|errequest
argument_list|(
name|buf
argument_list|,
literal|"Error in setting"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
block|}
else|else
name|f
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* commands() */
end_comment

begin_comment
comment|/*  *      VARIABLE ROUTINES  */
end_comment

begin_comment
comment|/* Init variables */
end_comment

begin_function
name|GLOBL
name|VOID
name|initvariables
parameter_list|()
block|{
name|char
name|buf
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Init user commands menu lines for tree and file screen */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|utreemenu
argument_list|,
name|UMENUFORM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ufilemenu
argument_list|,
name|utreemenu
argument_list|)
expr_stmt|;
comment|/* First: Get and set variables from environment */
if|if
condition|(
name|ep
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
condition|)
name|VARDEF
argument_list|(
name|V_SH
argument_list|)
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|ep
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
condition|)
name|VARDEF
argument_list|(
name|V_ED
argument_list|)
operator|=
name|ep
expr_stmt|;
if|if
condition|(
name|ep
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
condition|)
name|VARDEF
argument_list|(
name|V_PG
argument_list|)
operator|=
name|ep
expr_stmt|;
comment|/* Second: Initialize and link variables table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VARNAM
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VARDEF
argument_list|(
name|i
argument_list|)
operator|==
name|NULL
condition|)
name|VARDEF
argument_list|(
name|i
argument_list|)
operator|=
name|novar
expr_stmt|;
name|VARVAL
argument_list|(
name|i
argument_list|)
operator|=
name|VARDEF
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|VARNXT
argument_list|(
literal|0
argument_list|)
operator|=
name|VARLST
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|VARNAM
argument_list|(
name|i
operator|+
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|VARNXT
argument_list|(
name|i
argument_list|)
operator|=
name|VARLST
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VARPRV
argument_list|(
name|i
argument_list|)
operator|=
name|VARLST
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|VARPRV
argument_list|(
name|i
argument_list|)
operator|=
name|VARLST
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTSTART
comment|/* Third: Get and set variables from startup file */
if|if
condition|(
name|startup
argument_list|(
name|buf
argument_list|,
name|UTSTART
argument_list|)
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
if|if
condition|(
name|VALID
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'='
argument_list|)
condition|)
operator|(
name|void
operator|)
name|setvariable
argument_list|(
name|buf
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
condition|)
operator|(
name|void
operator|)
name|setcommand
argument_list|(
name|buf
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UTSTART */
comment|/* Last: Check environment variable UTREE */
if|if
condition|(
name|ep
operator|=
name|getenv
argument_list|(
literal|"UTREE"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ep
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|ep
index|[
name|i
index|]
condition|)
block|{
default|default:
comment|/* Do nothing */
break|break;
case|case
literal|'b'
case|:
comment|/* No bell */
operator|(
name|void
operator|)
name|setvariable
argument_list|(
literal|"BL="
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* No clock */
operator|(
name|void
operator|)
name|setvariable
argument_list|(
literal|"CL="
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* No graphic chars */
operator|(
name|void
operator|)
name|setvariable
argument_list|(
literal|"GC="
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Tree indention */
if|if
condition|(
name|isdigit
argument_list|(
name|ep
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"TI=%c"
argument_list|,
name|ep
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvariable
argument_list|(
name|buf
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* No tree scan for changes */
operator|(
name|void
operator|)
name|setvariable
argument_list|(
literal|"ST="
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Omit saving definition changes */
operator|(
name|void
operator|)
name|setvariable
argument_list|(
literal|"AS="
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* File lines on tree screen */
if|if
condition|(
name|isdigit
argument_list|(
name|ep
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"FL=%c"
argument_list|,
name|ep
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvariable
argument_list|(
name|buf
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* No hardware scrolling */
operator|(
name|void
operator|)
name|setvariable
argument_list|(
literal|"TS="
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Set video mode */
if|if
condition|(
name|isdigit
argument_list|(
name|ep
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"VM=%c"
argument_list|,
name|ep
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvariable
argument_list|(
name|buf
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
comment|/* No warning about unreadable dirs */
operator|(
name|void
operator|)
name|setvariable
argument_list|(
literal|"WD="
argument_list|,
name|VC_SET
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* initvariables() */
end_comment

begin_comment
comment|/* Save current settings after changes */
end_comment

begin_function
name|GLOBL
name|VOID
name|savevariables
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|UTSTART
name|char
name|buf
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|xlist
modifier|*
name|xp
decl_stmt|;
specifier|register
name|vlist
modifier|*
name|vp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|VARVAL
argument_list|(
name|V_AS
argument_list|)
operator|&&
name|vcchg
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".%s"
argument_list|,
name|UTSTART
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pathname
argument_list|(
name|buf
argument_list|,
name|home
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
name|t
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# %s: ~/.%s, %s"
argument_list|,
name|getversion
argument_list|()
argument_list|,
name|UTSTART
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save variables */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# Variables\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|VARTAB
argument_list|(
literal|0
argument_list|)
init|;
name|vp
condition|;
name|vp
operator|=
operator|(
name|vlist
operator|*
operator|)
name|VNEXT
argument_list|(
name|vp
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s="
argument_list|,
name|VNAME
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VVALE
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|VTYPE
argument_list|(
name|vp
argument_list|)
operator|==
name|VT_B
condition|?
literal|"ON"
else|:
name|VVALE
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VCOMM
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t#%s\n"
argument_list|,
name|VCOMM
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Save command settings */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# Commands\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|xroot
init|;
name|xp
condition|;
name|xp
operator|=
operator|(
name|xlist
operator|*
operator|)
name|XNEXT
argument_list|(
name|xp
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s:%s"
argument_list|,
name|XTYPE
argument_list|(
name|xp
argument_list|)
argument_list|,
name|XCOMD
argument_list|(
name|xp
argument_list|)
condition|?
name|XCOMD
argument_list|(
name|xp
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|XCOMM
argument_list|(
name|xp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t#%s\n"
argument_list|,
name|XCOMM
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* UTSTART */
block|}
end_function

begin_comment
comment|/* savevariables() */
end_comment

begin_comment
comment|/* Check tree indention */
end_comment

begin_function
name|GLOBL
name|VOID
name|checkindent
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|maxlevel
operator|>
literal|0
condition|)
comment|/* Calculate max possible indention */
name|i
operator|=
operator|(
name|columns
operator|-
name|FNAMSZ
operator|-
literal|6
operator|)
operator|/
name|maxlevel
expr_stmt|;
else|else
name|i
operator|=
name|indent
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|MININD
condition|)
name|i
operator|=
name|MININD
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|MAXIND
condition|)
name|i
operator|=
name|MAXIND
expr_stmt|;
if|if
condition|(
name|maxindent
operator|&&
name|i
operator|>
name|maxindent
condition|)
comment|/* Check and set indention */
name|i
operator|=
name|maxindent
expr_stmt|;
name|indent
operator|=
name|i
expr_stmt|;
operator|*
name|VARVAL
argument_list|(
name|V_TI
argument_list|)
operator|=
name|indent
operator|+
literal|'0'
expr_stmt|;
comment|/* Set indention variable value */
name|treeflag
operator|=
name|SF_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* checkindent() */
end_comment

begin_comment
comment|/* Calculate max possible number of file lines on tree screen */
end_comment

begin_function
name|GLOBL
name|int
name|calculatelines
parameter_list|()
block|{
specifier|register
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
operator|(
name|lines
operator|-
literal|3
operator|)
operator|/
literal|2
operator|)
operator|>
name|MAXFIL
condition|)
name|l
operator|=
name|MAXFIL
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* calculatelines() */
end_comment

begin_comment
comment|/* Check line partitioning on tree screen */
end_comment

begin_function
name|GLOBL
name|VOID
name|checklines
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|int
name|m
decl_stmt|,
name|nf
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
comment|/* Calculate new line values */
name|nf
operator|=
name|nflines
expr_stmt|;
if|if
condition|(
name|maxnflines
operator|<
name|MINFIL
condition|)
name|nflines
operator|=
name|MINFIL
expr_stmt|;
else|else
block|{
name|m
operator|=
name|calculatelines
argument_list|()
expr_stmt|;
name|nflines
operator|=
name|maxnflines
operator|>
name|m
condition|?
name|m
else|:
name|maxnflines
expr_stmt|;
block|}
name|firstfline
operator|=
name|lastfline
operator|-
name|nflines
operator|+
literal|1
expr_stmt|;
name|lastdline
operator|=
name|firstfline
operator|-
literal|2
expr_stmt|;
name|ndlines
operator|=
name|lastdline
operator|-
name|firstdline
expr_stmt|;
if|if
condition|(
name|nf
operator|!=
name|nflines
condition|)
comment|/* Check directory window */
name|calculatetree
argument_list|(
name|nf
operator|-
name|nflines
argument_list|)
expr_stmt|;
name|treeflag
operator|=
name|SF_TREE
expr_stmt|;
block|}
else|else
comment|/* Update after resizing */
name|maxnflines
operator|=
name|nflines
expr_stmt|;
operator|*
name|VARVAL
argument_list|(
name|V_FL
argument_list|)
operator|=
name|maxnflines
operator|+
literal|'0'
expr_stmt|;
comment|/* Set number of file lines */
block|}
end_function

begin_comment
comment|/* checklines() */
end_comment

begin_comment
comment|/* Set/unset or reset user defined variables */
end_comment

begin_function
name|GLOBL
name|int
name|setvariable
parameter_list|(
name|line
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|vlist
modifier|*
name|vp
decl_stmt|;
specifier|register
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|comm
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Search for variable - value separator '=' */
if|if
condition|(
name|f
operator|!=
name|VC_TST
condition|)
block|{
if|if
condition|(
name|value
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'='
argument_list|)
condition|)
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|line
operator|=
name|strclean
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|strupper
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Search for variable to set in variable list */
for|for
control|(
name|vp
operator|=
name|VARTAB
argument_list|(
literal|0
argument_list|)
init|;
name|vp
condition|;
name|vp
operator|=
operator|(
name|vlist
operator|*
operator|)
name|VNEXT
argument_list|(
name|vp
argument_list|)
control|)
if|if
condition|(
operator|*
name|line
operator|==
operator|*
name|VNAME
argument_list|(
name|vp
argument_list|)
operator|&&
operator|(
name|EQU
argument_list|(
name|line
argument_list|,
name|VSCUT
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|||
name|EQU
argument_list|(
name|line
argument_list|,
name|VNAME
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|vp
operator|==
name|VNULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|f
operator|==
name|VC_TST
condition|)
return|return
operator|(
name|VNUMB
argument_list|(
name|vp
argument_list|)
operator|)
return|;
comment|/* Ignore additional comment */
if|if
condition|(
name|comm
operator|=
name|strchr
argument_list|(
name|value
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
operator|*
name|comm
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|comm
operator|=
name|strclean
argument_list|(
name|comm
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|strclean
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Set or unset variable */
name|n
operator|=
name|VNUMB
argument_list|(
name|vp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|VTYPE
argument_list|(
name|vp
argument_list|)
condition|)
block|{
case|case
name|VT_B
case|:
comment|/* Booleans */
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|=
operator|*
name|value
condition|?
name|VB_ON
else|:
name|VB_OFF
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|V_GC
condition|)
name|initgraphics
argument_list|(
operator|(
name|int
operator|)
name|VVALE
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
name|V_LS
condition|)
name|setsortflag
argument_list|(
operator|(
name|int
operator|)
name|VVALE
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USEANSICOLORS
elseif|else
if|if
condition|(
name|n
operator|==
name|V_UC
condition|)
name|setcolorflag
argument_list|(
operator|(
name|int
operator|)
name|VVALE
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USEANSICOLORS */
break|break;
case|case
name|VT_N
case|:
comment|/* Numbers */
if|if
condition|(
name|n
operator|==
name|V_TI
operator|&&
name|setindent
argument_list|(
name|atoi
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
name|V_VM
operator|&&
name|setvideomode
argument_list|(
name|atoi
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
name|V_FL
operator|&&
name|setfilelines
argument_list|(
name|atoi
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
name|V_HS
operator|&&
operator|(
name|f
operator|!=
name|VC_SET
operator|||
name|sethistorysize
argument_list|(
name|atoi
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|VT_S
case|:
comment|/* General strings */
if|if
condition|(
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|&&
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|!=
name|VDFLT
argument_list|(
name|vp
argument_list|)
condition|)
name|ufree
argument_list|(
name|VVALE
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|&&
operator|*
name|value
operator|!=
literal|'#'
operator|&&
operator|(
name|dp
operator|=
name|strsav
argument_list|(
name|value
argument_list|)
operator|)
condition|)
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|=
name|dp
expr_stmt|;
elseif|else
if|if
condition|(
name|VDFLT
argument_list|(
name|vp
argument_list|)
condition|)
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|=
name|VDFLT
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|VT_U
case|:
comment|/* Command strings */
if|if
condition|(
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|&&
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|!=
name|VDFLT
argument_list|(
name|vp
argument_list|)
condition|)
name|ufree
argument_list|(
name|VVALE
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VCOMM
argument_list|(
name|vp
argument_list|)
condition|)
name|ufree
argument_list|(
name|VCOMM
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|=
name|VCOMM
argument_list|(
name|vp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
block|{
if|if
condition|(
name|dp
operator|=
name|strsav
argument_list|(
name|value
argument_list|)
condition|)
name|VVALE
argument_list|(
name|vp
argument_list|)
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|comm
operator|&&
operator|*
name|comm
condition|)
name|VCOMM
argument_list|(
name|vp
argument_list|)
operator|=
name|strsav
argument_list|(
name|comm
argument_list|)
expr_stmt|;
block|}
comment|/* Update user command menulines if needed */
if|if
condition|(
name|n
operator|>
name|V_FC0
condition|)
for|for
control|(
name|i
operator|=
operator|(
name|n
operator|-
name|V_FC1
operator|)
operator|*
name|OFFSET
operator|+
name|FIRST
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TITLE
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|ufilemenu
index|[
name|i
index|]
operator|=
name|comm
operator|&&
operator|*
name|comm
condition|?
operator|*
name|comm
operator|++
else|:
literal|' '
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
operator|(
name|n
operator|-
name|V_TC1
operator|)
operator|*
name|OFFSET
operator|+
name|FIRST
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TITLE
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|utreemenu
index|[
name|i
index|]
operator|=
name|comm
operator|&&
operator|*
name|comm
condition|?
operator|*
name|comm
operator|++
else|:
literal|' '
expr_stmt|;
break|break;
case|case
name|VT_O
case|:
comment|/* User defined strings: not yet! */
default|default:
comment|/* ??? */
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|f
operator|==
name|VC_CHG
condition|)
name|vcchg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* setvariable() */
end_comment

begin_comment
comment|/* Show and set/unset common and user defined variables */
end_comment

begin_function
name|GLOBL
name|int
name|variables
parameter_list|()
block|{
name|char
name|buf
index|[
literal|3
operator|*
name|INPLEN
index|]
decl_stmt|,
name|var
index|[
name|INPLEN
index|]
decl_stmt|,
name|def
index|[
name|INPLEN
index|]
decl_stmt|,
name|cmt
index|[
name|INPLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|who
operator|=
literal|"SET VARIABLE"
expr_stmt|;
comment|/* Variable loop */
name|f
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|&&
operator|(
operator|(
name|c
operator|=
name|showallvars
argument_list|()
operator|)
operator|<
name|RV_NUL
operator|||
name|c
operator|==
literal|'q'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|f
operator|=
literal|0
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give variable or variable=value (CR:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Set variable:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|var
argument_list|,
sizeof|sizeof
argument_list|(
name|var
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'v'
argument_list|,
name|NULL
argument_list|,
name|VARLST
argument_list|(
name|n
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
break|break;
if|if
condition|(
name|strchr
argument_list|(
name|var
argument_list|,
literal|'='
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|var
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|setvariable
argument_list|(
name|var
argument_list|,
name|VC_TST
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|errequest
argument_list|(
name|var
argument_list|,
literal|"Unknown"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
else|else
continue|continue;
block|}
name|puthelp
argument_list|(
literal|"%s: Give definition for %s (CR:unset)"
argument_list|,
name|who
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Set %s to:"
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|VARTYP
argument_list|(
name|n
argument_list|)
operator|==
name|VT_B
condition|)
name|dp
operator|=
name|VARSET
argument_list|(
name|n
argument_list|)
condition|?
literal|"ON"
else|:
literal|""
expr_stmt|;
else|else
name|dp
operator|=
name|VARVAL
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|def
argument_list|,
sizeof|sizeof
argument_list|(
name|def
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'v'
argument_list|,
name|dp
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
if|if
condition|(
name|VARTYP
argument_list|(
name|n
argument_list|)
operator|!=
name|VT_U
operator|||
name|strchr
argument_list|(
name|def
argument_list|,
literal|'#'
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|var
argument_list|,
name|def
argument_list|)
expr_stmt|;
else|else
block|{
name|puthelp
argument_list|(
literal|"%s: Give comment for user command %s"
argument_list|,
name|who
argument_list|,
name|VARNAM
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Comment for %s:"
argument_list|,
name|VARNAM
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|cmt
argument_list|,
sizeof|sizeof
argument_list|(
name|cmt
argument_list|)
argument_list|,
name|c
argument_list|,
literal|'v'
argument_list|,
name|VARCOM
argument_list|(
name|n
argument_list|)
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s#%s"
argument_list|,
name|var
argument_list|,
name|def
argument_list|,
name|cmt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setvariable
argument_list|(
name|buf
argument_list|,
name|VC_CHG
argument_list|)
operator|<
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|errequest
argument_list|(
name|buf
argument_list|,
literal|"Error in setting"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
break|break;
block|}
else|else
name|f
operator|=
literal|1
expr_stmt|;
block|}
name|treeflag
operator|=
name|fileflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* variables() */
end_comment

end_unit

