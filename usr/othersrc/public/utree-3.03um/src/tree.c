begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      TREE.C  *      UTREE tree menu routines.  *      3.01-um klin, Tue Jun  4 14:19:16 1991  *              klin, Tue Oct 15 14:02:37 1991, Handling of symlinks changed  *              klin, Sat Oct 26 15:07:06 1991, Tagging files changed  *                                              Sorting and zooming changed  *                                              Select directories added  *                                              Print tree list added  *                                              More local functions  *      3.02-um klin, Fri Nov  1 10:46:14 1991, Screen layout changed  *                                              Goto parent added  *              klin, Sun Nov 24 19:30:43 1991, Cd to current directory before  *                                              executing some commands  *                                              Video attributes changed  *      3.03-um klin, Tue Feb 11 22:58:03 1992, Screen layout changed  *                                              Shell escape, variables and  *                                              filetype commands changed  *              klin, Sat Feb 15 14:44:52 1992, Video handling and partinioning of  *                                              directory and file windows changed  *              klin, Sat Feb 22 10:34:03 1992, Many commands changed to work  *                                              on current directory or subtree  *                                              or tagged files  *              klin, Sun Feb 23 17:32:57 1992, Key handling and key bindings  *                                              changed  *                                              No removing of subtrees  *            a klin, Sun Mar 15 19:08:25 1992, Bug fix in gotree()  *            b klin, Sun Mar 22 10:56:31 1992, Minor changes  *  *      Copyright (c) 1991/92 by Peter Klingebiel& UNIX Magazin Muenchen.  *      For copying and distribution information see the file COPYRIGHT.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) utree 3.03b-um (klin) Mar 22 1992 tree.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !lint */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ---- Local variables and definitions ------------------------------- */
end_comment

begin_decl_stmt
name|LOCAL
name|dlist
modifier|*
name|tdlist
init|=
name|DNULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top dlist on tree screen             */
end_comment

begin_decl_stmt
name|LOCAL
name|dlist
modifier|*
name|mdlist
init|=
name|DNULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Marked dlist entry                   */
end_comment

begin_decl_stmt
name|LOCAL
name|dlist
modifier|*
name|tdlast
init|=
name|DNULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last tdlist                          */
end_comment

begin_decl_stmt
name|LOCAL
name|dlist
modifier|*
name|cdlast
init|=
name|DNULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last current dlist entry             */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|mustup
init|=
literal|"Tree must be updated. Continue ?"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|cancel
init|=
literal|"(Hit BREAK to abort)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tree menu commands in help line                                      */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|tmline
init|=
literal|" Help Backup Chdir Find Grep Info List Mkdir Out Rmdir Stat Tag Untag Quit"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|menuline
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BCOL
value|0
end_define

begin_comment
comment|/* Column for tree position bar         */
end_comment

begin_define
define|#
directive|define
name|SCOL
value|1
end_define

begin_comment
comment|/* Column for tag or mark sign          */
end_comment

begin_define
define|#
directive|define
name|TCOL
value|2
end_define

begin_comment
comment|/* Startcolumn for directory tree       */
end_comment

begin_define
define|#
directive|define
name|UCOL
value|-1
end_define

begin_comment
comment|/* Column for number of files unknown   */
end_comment

begin_define
define|#
directive|define
name|FCOL
value|-5
end_define

begin_comment
comment|/* Column for number of files           */
end_comment

begin_define
define|#
directive|define
name|SLIN
value|(lastdline+1)
end_define

begin_comment
comment|/* Line for separator line              */
end_comment

begin_define
define|#
directive|define
name|NFFMT
value|"%5d"
end_define

begin_comment
comment|/* Format for number of files           */
end_comment

begin_define
define|#
directive|define
name|ONTR
parameter_list|(
name|c
parameter_list|)
value|((c)< 'a')
end_define

begin_comment
comment|/* Command works on subtree             */
end_comment

begin_define
define|#
directive|define
name|ONTG
parameter_list|(
name|c
parameter_list|)
value|((c)< 'a')
end_define

begin_comment
comment|/* Command works on tagged files        */
end_comment

begin_comment
comment|/* ---- External variables and functions ------------------------------ */
end_comment

begin_function_decl
name|EXTRN
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|writedlist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|EXTRN
name|char
modifier|*
name|selectdir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|LOCAL
name|char
modifier|*
name|dirselect
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ---- Functions and procedures -------------------------------------- */
end_comment

begin_comment
comment|/*  *      TREE DISPLAY ROUTINES  */
end_comment

begin_comment
comment|/* Display files of current directory in file window starting at line l */
end_comment

begin_function
name|LOCAL
name|VOID
name|showflist
parameter_list|(
name|l
parameter_list|)
specifier|register
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
operator|(
name|l
operator|-
name|firstfline
operator|)
operator|*
name|fperline
operator|)
operator|<
name|CNFIL
condition|)
block|{
while|while
condition|(
name|f
operator|<
name|CNFIL
operator|&&
name|l
operator|++
operator|<=
name|lastfline
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
operator|&&
name|i
operator|<
name|fperline
condition|;
name|f
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|putfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clearline
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<=
name|lastfline
condition|)
name|clearwindow
argument_list|(
name|l
argument_list|,
name|lastfline
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CNFIL
operator|==
literal|0
operator|&&
name|l
operator|==
name|firstfline
condition|)
name|clearwindow
argument_list|(
name|l
argument_list|,
name|lastfline
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* showflist() */
end_comment

begin_comment
comment|/* Display directory list entry dp */
end_comment

begin_function
name|LOCAL
name|VOID
name|showdlist
parameter_list|(
name|dp
parameter_list|,
name|f
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|;
block|{
comment|/* Is directory on screen? */
if|if
condition|(
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|>=
name|firstdline
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<=
name|lastdline
condition|)
block|{
comment|/* Display directory tag marker */
if|if
condition|(
name|DNTAG
argument_list|(
name|dp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|setgraphic
argument_list|(
name|GC_ON
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putcxy
argument_list|(
name|SCOL
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
name|GC_TG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgraphic
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|putcxy
argument_list|(
name|SCOL
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* Display directory filename */
if|if
condition|(
name|f
operator|&&
name|dp
operator|==
name|cdlist
condition|)
block|{
comment|/* Highlight current directory */
if|if
condition|(
name|CCANC
condition|)
block|{
name|setvideo
argument_list|(
name|DA_BOLDREV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|TCOL
operator|+
name|DTCOL
argument_list|(
name|dp
argument_list|)
operator|-
literal|1
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|">%s "
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setvideo
argument_list|(
name|DA_HALFREV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|TCOL
operator|+
name|DTCOL
argument_list|(
name|dp
argument_list|)
operator|-
literal|1
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|" %s "
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Other directory */
name|setvideo
argument_list|(
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|?
name|DA_BOLD
else|:
name|DA_HALF
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|TCOL
operator|+
name|DTCOL
argument_list|(
name|dp
argument_list|)
operator|-
literal|1
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|" %s "
argument_list|,
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Display number of files if known */
name|setvideo
argument_list|(
name|DA_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
block|{
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
condition|)
name|putcxy
argument_list|(
name|UCOL
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|FCOL
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NFFMT
argument_list|,
name|DNFIL
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putcxy
argument_list|(
name|UCOL
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* showdlist() */
end_comment

begin_comment
comment|/* Display whole directory line for directory dp */
end_comment

begin_function
name|LOCAL
name|VOID
name|showdline
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Is directory on screen? */
if|if
condition|(
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|>=
name|firstdline
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<=
name|lastdline
condition|)
block|{
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
name|TCOL
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|clearline
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setgraphic
argument_list|(
name|GC_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|droot
condition|)
comment|/* Root directory */
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|DNEXT
argument_list|(
name|dp
argument_list|)
condition|?
name|GC_UL
else|:
name|GC_HB
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Other directory */
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|DNEXT
argument_list|(
name|dp
argument_list|)
condition|?
name|GC_VB
else|:
name|GC_LL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|-
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DINFO
argument_list|(
name|dp
argument_list|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|)
name|putcxy
argument_list|(
name|TCOL
operator|+
name|i
operator|*
name|indent
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
name|GC_VB
argument_list|)
expr_stmt|;
if|if
condition|(
name|DINFO
argument_list|(
name|dp
argument_list|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|)
name|putcxy
argument_list|(
name|TCOL
operator|+
name|i
operator|*
name|indent
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
name|GC_LT
argument_list|)
expr_stmt|;
else|else
name|putcxy
argument_list|(
name|TCOL
operator|+
name|i
operator|*
name|indent
argument_list|,
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
name|GC_LL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|GC_HB
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgraphic
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
name|showdlist
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Display name */
block|}
block|}
end_function

begin_comment
comment|/* showdline() */
end_comment

begin_comment
comment|/* Display the directory list from line f to line t */
end_comment

begin_function
name|LOCAL
name|VOID
name|showdtree
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|c
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|,
name|t
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
comment|/* Search for first directory to print ... */
for|for
control|(
name|dp
operator|=
name|tdlist
init|;
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<
name|f
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
empty_stmt|;
comment|/* ... and print out from f to t */
for|for
control|(
init|;
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<=
name|t
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
name|showdline
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* Clear to end of tree window */
if|if
condition|(
name|c
operator|&&
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<
name|lastdline
condition|)
name|clearwindow
argument_list|(
name|DTROW
argument_list|(
name|dp
argument_list|)
argument_list|,
name|lastdline
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* showdtree() */
end_comment

begin_comment
comment|/* Display tree position bar */
end_comment

begin_function
name|LOCAL
name|VOID
name|showtbar
parameter_list|()
block|{
specifier|static
name|int
name|bar
init|=
literal|0
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|dircount
operator|>
operator|(
name|ndlines
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* More dirs than lines */
name|dp
operator|=
name|tdlist
expr_stmt|;
while|while
condition|(
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<
name|lastdline
condition|)
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|f
operator|=
operator|(
operator|(
name|DDNUM
argument_list|(
name|tdlist
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|ndlines
operator|)
operator|/
name|dircount
operator|+
name|firstdline
expr_stmt|;
name|l
operator|=
operator|(
operator|(
name|DDNUM
argument_list|(
name|dp
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|ndlines
operator|)
operator|/
name|dircount
operator|+
name|firstdline
expr_stmt|;
if|if
condition|(
name|f
operator|<=
name|firstdline
condition|)
name|f
operator|=
name|DPREV
argument_list|(
name|tdlist
argument_list|)
condition|?
name|firstdline
operator|+
literal|1
else|:
name|firstdline
expr_stmt|;
if|if
condition|(
name|l
operator|>=
name|lastdline
condition|)
name|l
operator|=
name|DNEXT
argument_list|(
name|dp
argument_list|)
condition|?
name|lastdline
operator|-
literal|1
else|:
name|lastdline
expr_stmt|;
name|i
operator|=
name|firstdline
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|f
condition|)
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
operator|++
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|videomode
operator|&&
operator|(
name|videocap
operator|&
name|VA_REVERSE
operator|)
condition|)
block|{
name|setvideo
argument_list|(
name|DA_HALFREV
argument_list|)
expr_stmt|;
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
operator|++
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|l
condition|)
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
operator|++
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|setvideo
argument_list|(
name|DA_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setgraphic
argument_list|(
name|GC_ON
argument_list|)
expr_stmt|;
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
operator|++
argument_list|,
name|GC_TT
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|l
condition|)
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
operator|++
argument_list|,
name|GC_VB
argument_list|)
expr_stmt|;
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
operator|++
argument_list|,
name|GC_BT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgraphic
argument_list|(
name|GC_OFF
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<=
name|lastdline
condition|)
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
operator|++
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|bar
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bar
condition|)
block|{
for|for
control|(
name|i
operator|=
name|firstdline
init|;
name|i
operator|<=
name|lastdline
condition|;
name|i
operator|++
control|)
name|putcxy
argument_list|(
name|BCOL
argument_list|,
name|i
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|bar
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* showtbar() */
end_comment

begin_comment
comment|/* Display separator line between tree and file window */
end_comment

begin_function
name|LOCAL
name|VOID
name|showsline
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cz
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|CPNAM
operator|+
name|strlen
argument_list|(
name|rootdir
argument_list|)
expr_stmt|;
name|cz
operator|=
name|CZOOM
condition|?
name|CZOOM
else|:
literal|"*"
expr_stmt|;
name|setvideo
argument_list|(
name|DA_REVERSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|i
operator|=
name|putfxy
argument_list|(
literal|0
argument_list|,
name|SLIN
argument_list|,
literal|0
argument_list|,
literal|".%s/%s: %d file(s) %d dir(s)"
argument_list|,
name|cp
argument_list|,
name|cz
argument_list|,
name|CNFIL
argument_list|,
name|CNDIR
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|putfxy
argument_list|(
literal|0
argument_list|,
name|SLIN
argument_list|,
literal|0
argument_list|,
literal|"./%s: %d file(s) %d dir(s)"
argument_list|,
name|cz
argument_list|,
name|CNFIL
argument_list|,
name|CNDIR
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
name|columns
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|setvideo
argument_list|(
name|DA_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* showsline() */
end_comment

begin_comment
comment|/*  *      TREE SCREEN UPDATE AND REFRESH  */
end_comment

begin_comment
comment|/* Update tree screen */
end_comment

begin_function
name|LOCAL
name|int
name|updatetree
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|rv
decl_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_LIST
condition|)
block|{
comment|/* Check current directory */
if|if
condition|(
operator|(
name|CFLAG
operator|!=
name|FL_FIL
operator|||
name|changedlist
argument_list|(
name|cdlist
argument_list|)
operator|)
operator|&&
name|newflist
argument_list|(
name|cdlist
argument_list|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|RV_ERR
operator|)
return|;
block|}
name|rv
operator|=
name|RV_OK
expr_stmt|;
if|if
condition|(
name|keypressed
argument_list|()
condition|)
comment|/* There are chars in input buffer */
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|treeflag
operator|==
name|SF_FULL
condition|)
block|{
comment|/* Full screen update */
name|clearscreen
argument_list|()
expr_stmt|;
name|cdlast
operator|=
name|tdlast
operator|=
name|DNULL
expr_stmt|;
block|}
if|if
condition|(
name|treeflag
operator|&
name|SF_TREE
condition|)
block|{
comment|/* Tree screen */
name|n
operator|=
name|tdlast
condition|?
name|DDNUM
argument_list|(
name|tdlast
argument_list|)
operator|-
name|DDNUM
argument_list|(
name|tdlist
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|CANSCROLL
operator|&&
name|n
operator|<
literal|0
operator|&&
name|n
operator|>
operator|-
name|ndlines
condition|)
block|{
operator|(
name|void
operator|)
name|windowup
argument_list|(
name|firstdline
argument_list|,
name|lastdline
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
name|showdtree
argument_list|(
name|lastdline
operator|+
name|n
operator|+
literal|1
argument_list|,
name|lastdline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|showdlist
argument_list|(
name|cdlast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CANSCROLL
operator|&&
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
name|ndlines
condition|)
block|{
operator|(
name|void
operator|)
name|windowdown
argument_list|(
name|firstdline
argument_list|,
name|lastdline
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|showdtree
argument_list|(
name|firstdline
argument_list|,
name|firstdline
operator|+
name|n
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|showdlist
argument_list|(
name|cdlast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|showdtree
argument_list|(
name|firstdline
argument_list|,
name|lastdline
argument_list|,
name|treeflag
operator|!=
name|SF_FULL
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_PBAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|treeflag
operator|&
name|SF_LAST
condition|)
comment|/* Last directory */
name|showdlist
argument_list|(
name|cdlast
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_PBAR
condition|)
comment|/* Tree position bar */
name|showtbar
argument_list|()
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_LIST
condition|)
block|{
comment|/* Current directory */
name|showdlist
argument_list|(
name|cdlist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showsline
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|treeflag
operator|&
name|SF_SEPL
condition|)
name|showsline
argument_list|()
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_FILE
condition|)
comment|/* File list */
name|showflist
argument_list|(
name|firstfline
argument_list|)
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_HELP
operator|&&
operator|!
name|f
condition|)
comment|/* Help line */
name|putmenu
argument_list|(
literal|"TREE:"
argument_list|,
name|menuline
argument_list|)
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_ECHO
operator|&&
operator|!
name|f
condition|)
comment|/* Echo line */
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"%s: %d dir(s) %d file(s)"
argument_list|,
name|rootdir
argument_list|,
name|dircount
argument_list|,
name|filecount
argument_list|)
expr_stmt|;
comment|/* Position to current directory, set variables and return */
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
name|TCOL
operator|+
name|DTCOL
argument_list|(
name|cdlist
argument_list|)
operator|-
literal|1
argument_list|,
name|DTROW
argument_list|(
name|cdlist
argument_list|)
argument_list|)
expr_stmt|;
name|cdlast
operator|=
name|cdlist
expr_stmt|;
name|tdlast
operator|=
name|tdlist
expr_stmt|;
name|treeflag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* updatetree() */
end_comment

begin_comment
comment|/*  *      SCROLL UP OR DOWN DIRECTORY TREE  */
end_comment

begin_comment
comment|/* Scroll directory tree */
end_comment

begin_function
name|LOCAL
name|int
name|scrolltree
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Is scrolling possible? */
if|if
condition|(
operator|(
name|dir
operator|<
literal|0
operator|&&
name|DPREV
argument_list|(
name|tdlist
argument_list|)
operator|==
name|GNULL
operator|)
operator|||
operator|(
name|dir
operator|>
literal|0
operator|&&
name|CNEXT
operator|==
name|GNULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
block|{
comment|/* Scroll down */
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowdown
argument_list|(
name|firstdline
argument_list|,
name|lastdline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showdline
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_MOVE
operator||
name|SF_PBAR
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_TREE
operator||
name|SF_LIST
operator||
name|SF_PBAR
expr_stmt|;
block|}
else|else
block|{
comment|/* Scroll up */
for|for
control|(
name|dp
operator|=
name|tdlist
operator|,
name|i
operator|=
name|ndlines
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|)
operator|==
name|DNULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowup
argument_list|(
name|firstdline
argument_list|,
name|lastdline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|tdlist
init|;
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<
name|lastdline
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
empty_stmt|;
name|showdline
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_MOVE
operator||
name|SF_PBAR
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_TREE
operator||
name|SF_LIST
operator||
name|SF_PBAR
expr_stmt|;
block|}
if|if
condition|(
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|<
name|firstdline
condition|)
comment|/* Change current directory */
operator|(
name|void
operator|)
name|gotree
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* if out of screen         */
elseif|else
if|if
condition|(
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|>
name|lastdline
condition|)
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scrolltree() */
end_comment

begin_comment
comment|/*  *      CHECK TREE  */
end_comment

begin_comment
comment|/* Check if all directories in tree are unchanged or read in */
end_comment

begin_function
name|LOCAL
name|int
name|checktree
parameter_list|(
name|msg
parameter_list|)
specifier|register
name|char
modifier|*
name|msg
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|VARSET
argument_list|(
name|V_ST
argument_list|)
operator|&&
name|scandlist
argument_list|(
name|cdlist
argument_list|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|RV_NUL
operator|)
return|;
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
init|;
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
condition|)
block|{
operator|++
name|buildflag
expr_stmt|;
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s (Y:continue  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|msg
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|==
literal|'y'
condition|?
name|RV_OK
else|:
name|c
operator|)
return|;
block|}
block|}
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* checktree() */
end_comment

begin_comment
comment|/*  *      TAG/UNTAG FILES IN TREE  */
end_comment

begin_comment
comment|/* Tag files in directory tree */
end_comment

begin_function
name|LOCAL
name|int
name|tagtree
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|input
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|ff
decl_stmt|,
name|nt
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"TAG TREE"
else|:
literal|"TAG DIRECTORY"
expr_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
name|c
operator|=
name|checktree
argument_list|(
name|mustup
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:%s)"
argument_list|,
name|who
argument_list|,
name|tpattern
index|[
literal|0
index|]
condition|?
name|tpattern
else|:
literal|"quit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|input
argument_list|,
literal|"Tag which files:"
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tpattern
argument_list|,
name|input
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|RV_NUL
operator|||
operator|(
name|c
operator|==
name|RV_NUL
operator|&&
name|tpattern
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Walk thru subtree */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cdlist
expr_stmt|;
name|ff
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|nt
operator|=
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
operator|&&
operator|(
name|f
operator|=
name|newflist
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
comment|/* Update! */
return|return
operator|(
name|f
operator|)
return|;
elseif|else
if|if
condition|(
name|keypressed
argument_list|()
operator|&&
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|<
name|RV_NUL
condition|)
break|break;
comment|/* Walk thru file list */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|umatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|,
name|tpattern
argument_list|)
operator|>
literal|0
condition|)
block|{
name|FITAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FF_TAG
expr_stmt|;
operator|++
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|++
name|ff
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|!=
name|DNTAG
argument_list|(
name|dp
argument_list|)
condition|)
name|showdlist
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|&&
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|)
do|;
if|if
condition|(
name|ff
operator|>
literal|0
condition|)
name|treeflag
operator||=
name|SF_FILE
operator||
name|SF_LIST
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: %s %s"
argument_list|,
name|who
argument_list|,
name|tpattern
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Tagged %d file(s) matching %s"
argument_list|,
name|ff
argument_list|,
name|tpattern
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tagtree() */
end_comment

begin_comment
comment|/* Untag files in directory tree */
end_comment

begin_function
name|LOCAL
name|int
name|untagtree
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|pat
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|ff
decl_stmt|,
name|nt
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"UNTAG TREE"
else|:
literal|"UNTAG DIRECTORY"
expr_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
name|c
operator|=
name|checktree
argument_list|(
name|mustup
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:all files)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|pat
argument_list|,
literal|"Untag which files:"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pat
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
comment|/* Walk thru subtree */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cdlist
expr_stmt|;
name|ff
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|nt
operator|=
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
operator|&&
operator|(
name|f
operator|=
name|newflist
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|f
operator|)
return|;
elseif|else
if|if
condition|(
name|keypressed
argument_list|()
operator|&&
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|<
name|RV_NUL
condition|)
break|break;
comment|/* Walk thru file list */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|&&
name|umatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|,
name|pat
argument_list|)
operator|>
literal|0
condition|)
block|{
name|FITAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
if|if
condition|(
name|DNTAG
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|++
name|ff
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|!=
name|DNTAG
argument_list|(
name|dp
argument_list|)
condition|)
name|showdlist
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|&&
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|)
do|;
if|if
condition|(
name|ff
operator|>
literal|0
condition|)
name|treeflag
operator||=
name|SF_FILE
operator||
name|SF_LIST
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: %s %s"
argument_list|,
name|who
argument_list|,
name|pat
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Untagged %d file(s) matching %s"
argument_list|,
name|ff
argument_list|,
name|pat
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* untagtree() */
end_comment

begin_comment
comment|/* Check if there are tagged files */
end_comment

begin_function
name|LOCAL
name|int
name|checktagged
parameter_list|()
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|n
decl_stmt|;
comment|/* Walk thru subtree */
name|dp
operator|=
name|cdlist
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
comment|/* Walk thru file list */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|ISTAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
condition|)
operator|++
name|n
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|)
do|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/* checktagged() */
end_comment

begin_comment
comment|/*  *      COMMANDS WORKING ON TAGGED FILES  */
end_comment

begin_comment
comment|/* Remove tagged files in tree */
end_comment

begin_function
name|GLOBL
name|int
name|removetagged
parameter_list|()
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|,
name|n
decl_stmt|,
name|rflag
decl_stmt|;
name|who
operator|=
literal|"REMOVE TAGGED FILES"
expr_stmt|;
if|if
condition|(
name|checktagged
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* No tagged files */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"No tagged files found"
argument_list|)
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s (Y:request  N:don't request  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Request before removing tagged files ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'n'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|rflag
operator|=
name|c
operator|==
literal|'y'
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|puthelp
argument_list|(
literal|"REMOVE FILE (Y:remove  Q:quit  ELSE:don't remove)"
argument_list|)
expr_stmt|;
else|else
name|puthelp
argument_list|(
literal|"%s (In progress ...)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
comment|/* Walk thru subtree */
name|dp
operator|=
name|cdlist
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
block|{
comment|/* Contains tagged files */
name|treeflag
operator|&=
operator|~
operator|(
name|SF_ECHO
operator||
name|SF_HELP
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Walk thru file list */
for|for
control|(
name|f
operator|=
name|CNFIL
operator|-
literal|1
init|;
name|f
operator|>=
literal|0
condition|;
name|f
operator|--
control|)
block|{
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|c
operator|=
name|removefile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
goto|goto
name|ENDLOOP
goto|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
operator|--
name|CNTAG
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|showflist
argument_list|(
name|firstfline
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|CFLAG
operator|==
name|FL_CHG
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|cdlist
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
goto|goto
name|ENDLOOP
goto|;
else|else
name|showdlist
argument_list|(
name|cdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|gotree
argument_list|(
literal|1
argument_list|)
operator|&&
name|CLEVL
operator|>
name|DLEVL
argument_list|(
name|dp
argument_list|)
condition|)
do|;
name|ENDLOOP
label|:
if|if
condition|(
name|c
operator|==
name|RV_END
condition|)
return|return
operator|(
name|c
operator|)
return|;
while|while
condition|(
name|cdlist
operator|!=
name|dp
condition|)
comment|/* Position to starting directory */
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Removed %d tagged file(s)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"No files removed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* removetagged() */
end_comment

begin_function
name|LOCAL
name|char
modifier|*
name|dirselect
parameter_list|(
name|what
parameter_list|)
specifier|register
name|char
modifier|*
name|what
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dn
decl_stmt|;
name|dn
operator|=
name|selectdir
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
name|treeflag
operator|&=
operator|~
operator|(
name|SF_HELP
operator||
name|SF_ECHO
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dn
operator|)
return|;
block|}
end_function

begin_comment
comment|/* dirselect() */
end_comment

begin_comment
comment|/* Move tagged files in tree */
end_comment

begin_function
name|GLOBL
name|int
name|movetagged
parameter_list|()
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|,
name|n
decl_stmt|,
name|rflag
decl_stmt|;
name|who
operator|=
literal|"MOVE TAGGED FILES"
expr_stmt|;
if|if
condition|(
name|checktagged
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* No tagged files */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"No tagged files found"
argument_list|)
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s: Give destination directory (CR:select one)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Move tagged files to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
block|{
name|to
operator|=
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|to
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Cannot stat"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|STFMT
argument_list|(
operator|&
name|st
argument_list|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Is not a directory"
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|to
operator|=
name|dirselect
argument_list|(
literal|"moving files"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s (Y:request  N:don't request  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Request before moving tagged files ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'n'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|rflag
operator|=
name|c
operator|==
literal|'y'
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|puthelp
argument_list|(
literal|"MOVE FILE (Y:copy  Q:quit  ELSE:don't copy)"
argument_list|)
expr_stmt|;
else|else
name|puthelp
argument_list|(
literal|"%s (In progress ...)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
comment|/* Walk thru subtree */
name|dp
operator|=
name|cdlist
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
block|{
comment|/* Contains tagged files */
name|treeflag
operator|&=
operator|~
operator|(
name|SF_ECHO
operator||
name|SF_HELP
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Walk thru file list */
for|for
control|(
name|f
operator|=
name|CNFIL
operator|-
literal|1
init|;
name|f
operator|>=
literal|0
condition|;
name|f
operator|--
control|)
block|{
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|c
operator|=
name|movefile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|to
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
goto|goto
name|ENDLOOP
goto|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
operator|--
name|CNTAG
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|CFLAG
operator|==
name|FL_CHG
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|cdlist
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
goto|goto
name|ENDLOOP
goto|;
else|else
name|showdlist
argument_list|(
name|cdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|gotree
argument_list|(
literal|1
argument_list|)
operator|&&
name|CLEVL
operator|>
name|DLEVL
argument_list|(
name|dp
argument_list|)
condition|)
do|;
name|ENDLOOP
label|:
if|if
condition|(
name|c
operator|==
name|RV_END
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|checkdlist
argument_list|(
name|to
argument_list|)
expr_stmt|;
while|while
condition|(
name|cdlist
operator|!=
name|dp
condition|)
comment|/* Position to starting directory */
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Moved %d file(s) to %s"
argument_list|,
name|n
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"No files moved"
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* movetagged() */
end_comment

begin_comment
comment|/* Copy tagged files in tree */
end_comment

begin_function
name|GLOBL
name|int
name|copytagged
parameter_list|()
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|,
name|n
decl_stmt|,
name|rflag
decl_stmt|;
name|who
operator|=
literal|"COPY TAGGED FILES"
expr_stmt|;
if|if
condition|(
name|checktagged
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* No tagged files */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"No tagged files found"
argument_list|)
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s: Give destination directory (CR:select one)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Copy tagged files to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
block|{
name|to
operator|=
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|to
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Cannot stat"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|STFMT
argument_list|(
operator|&
name|st
argument_list|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|name
argument_list|,
literal|"Is not a directory"
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|to
operator|=
name|dirselect
argument_list|(
literal|"copying files"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fileflag
operator||=
name|SF_ECHO
operator||
name|SF_HELP
expr_stmt|;
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s (Y:request  N:don't request  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Request before copying tagged files ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'n'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|rflag
operator|=
name|c
operator|==
literal|'y'
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|puthelp
argument_list|(
literal|"COPY FILE (Y:copy  Q:quit  ELSE:don't copy)"
argument_list|)
expr_stmt|;
else|else
name|puthelp
argument_list|(
literal|"%s (In progress ...)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
comment|/* Walk thru subtree */
name|dp
operator|=
name|cdlist
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
block|{
comment|/* Contains tagged files */
name|treeflag
operator|&=
operator|~
operator|(
name|SF_ECHO
operator||
name|SF_HELP
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Walk thru file list */
for|for
control|(
name|f
operator|=
name|CNFIL
operator|-
literal|1
init|;
name|f
operator|>=
literal|0
condition|;
name|f
operator|--
control|)
block|{
if|if
condition|(
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|c
operator|=
name|copyfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|to
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
goto|goto
name|ENDLOOP
goto|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_OK
condition|)
block|{
operator|++
name|n
expr_stmt|;
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
operator|--
name|CNTAG
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
do|while
condition|(
name|gotree
argument_list|(
literal|1
argument_list|)
operator|&&
name|CLEVL
operator|>
name|DLEVL
argument_list|(
name|dp
argument_list|)
condition|)
do|;
name|ENDLOOP
label|:
if|if
condition|(
name|c
operator|==
name|RV_END
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|checkdlist
argument_list|(
name|to
argument_list|)
expr_stmt|;
while|while
condition|(
name|cdlist
operator|!=
name|dp
condition|)
comment|/* Position to starting directory */
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Copied %d file(s) to %s"
argument_list|,
name|n
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"No files copied"
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copytagged() */
end_comment

begin_comment
comment|/*  *      RESIZE DIRECTORY TREE WINDOW  */
end_comment

begin_comment
comment|/* Recalculate and update dlists on directory window */
end_comment

begin_function
name|GLOBL
name|VOID
name|calculatetree
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|tdlist
operator|&&
name|cdlist
condition|)
block|{
comment|/* Tree window needs update */
if|if
condition|(
name|n
operator|<
literal|0
operator|&&
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|>
name|lastdline
condition|)
block|{
while|while
condition|(
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|>
name|lastdline
condition|)
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
for|for
control|(
name|dp
operator|=
name|cdlist
init|;
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<
name|lastdline
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|DPREV
argument_list|(
name|tdlist
argument_list|)
operator|&&
name|dp
operator|==
name|DNULL
condition|)
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* calculatetree() */
end_comment

begin_comment
comment|/* Enlarge or shrink the tree window  */
end_comment

begin_function
name|LOCAL
name|int
name|resizetree
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
comment|/* Enlarge tree window if possible */
if|if
condition|(
name|dir
operator|>
literal|0
operator|&&
name|nflines
operator|>
name|MINFIL
condition|)
block|{
operator|++
name|lastdline
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|cdlist
init|;
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<
name|lastdline
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|DPREV
argument_list|(
name|tdlist
argument_list|)
operator|&&
name|dp
operator|==
name|DNULL
condition|)
block|{
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowdown
argument_list|(
name|firstdline
argument_list|,
name|lastfline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showdline
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_MOVE
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_TREE
operator||
name|SF_LIST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowdown
argument_list|(
name|lastdline
argument_list|,
name|lastfline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showdline
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_MOVE
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_TREE
operator||
name|SF_LIST
operator||
name|SF_FILE
expr_stmt|;
operator|++
name|ndlines
expr_stmt|;
operator|--
name|nflines
expr_stmt|;
operator|++
name|firstfline
expr_stmt|;
name|checklines
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Shrink tree window if possible */
elseif|else
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|nflines
operator|<
name|calculatelines
argument_list|()
condition|)
block|{
operator|--
name|ndlines
expr_stmt|;
operator|--
name|firstfline
expr_stmt|;
if|if
condition|(
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|==
name|lastdline
condition|)
block|{
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowup
argument_list|(
name|firstdline
argument_list|,
name|lastfline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showflist
argument_list|(
name|lastfline
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_MOVE
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_TREE
operator||
name|SF_LIST
operator||
name|SF_FILE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CANSCROLL
condition|)
block|{
operator|(
name|void
operator|)
name|windowup
argument_list|(
name|lastdline
argument_list|,
name|lastfline
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|showflist
argument_list|(
name|lastfline
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_MOVE
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_TREE
operator||
name|SF_LIST
operator||
name|SF_FILE
expr_stmt|;
operator|--
name|lastdline
expr_stmt|;
operator|++
name|nflines
expr_stmt|;
name|checklines
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|treeflag
operator||=
name|SF_SEPL
operator||
name|SF_PBAR
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* resizetree() */
end_comment

begin_comment
comment|/*  *      INFORMATION AND STATUS OF DIRECTORY  */
end_comment

begin_comment
comment|/* Show some directory information */
end_comment

begin_function
name|LOCAL
name|int
name|infodir
parameter_list|()
block|{
name|char
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|who
operator|=
literal|"INFO"
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: %s %s"
argument_list|,
name|who
argument_list|,
name|CPNAM
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|statfun
call|)
argument_list|(
name|CPNAM
argument_list|,
operator|&
name|st
argument_list|)
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Cannot stat"
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Scanning disk for disk usage, wait a moment ... "
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|DUDIR
argument_list|,
name|CPNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
comment|/* Let du summarize used blocks */
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|buf
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
operator|++
name|i
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* Error in calling du */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Access:%s Blocks:%s Files:%d Dirs:%d Date:%s"
argument_list|,
name|fileaccess
argument_list|(
operator|&
name|st
argument_list|)
argument_list|,
name|buf
argument_list|,
name|CNFIL
argument_list|,
name|CNDIR
argument_list|,
name|ctime
argument_list|(
operator|&
name|st
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* infodir() */
end_comment

begin_comment
comment|/* Show and change directory status */
end_comment

begin_function
name|LOCAL
name|int
name|statusdir
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|statusfile
argument_list|(
name|CPNAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buildflag
condition|)
block|{
comment|/* Rebuilding needed */
name|c
operator|=
name|newflist
argument_list|(
name|cdlist
argument_list|)
expr_stmt|;
name|buildflag
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* statusdir() */
end_comment

begin_comment
comment|/*  *      BACKUP DIRECTORY OR TREE  */
end_comment

begin_comment
comment|/* Create filelist for backup */
end_comment

begin_function
name|LOCAL
name|int
name|backuplist
parameter_list|(
name|name
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|fname
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|dname
decl_stmt|;
specifier|register
name|int
name|dlen
decl_stmt|,
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|pathname
argument_list|(
name|name
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
comment|/* Write out tree or subtree list */
name|dlen
operator|=
name|strlen
argument_list|(
name|CPNAM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CNFIL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|t
operator|||
name|ISTAG
argument_list|(
name|cdlist
argument_list|,
name|i
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|i
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
if|if
condition|(
name|CNTAG
operator|>
literal|0
condition|)
operator|--
name|CNTAG
expr_stmt|;
block|}
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
init|;
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
name|dname
operator|=
operator|&
operator|(
name|DPNAM
argument_list|(
name|dp
argument_list|)
index|[
name|dlen
operator|+
literal|1
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|t
operator|||
name|ISTAG
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
argument_list|,
name|dname
argument_list|)
argument_list|)
expr_stmt|;
name|FITAG
argument_list|(
name|dp
argument_list|,
name|i
argument_list|)
operator|=
name|FF_NONE
expr_stmt|;
if|if
condition|(
name|DNTAG
argument_list|(
name|dp
argument_list|)
operator|>
literal|0
condition|)
operator|--
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|prgname
argument_list|,
literal|"Cannot create backup list file"
argument_list|)
operator|)
return|;
block|}
name|checkdlist
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* Update needed? */
return|return
operator|(
name|buildflag
condition|?
name|updatedlist
argument_list|()
else|:
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* backuplist() */
end_comment

begin_comment
comment|/* Backup directory/subtree or tagged files in subtree */
end_comment

begin_function
name|LOCAL
name|int
name|backupdir
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|name
index|[
name|INPLEN
index|]
decl_stmt|,
name|list
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"BACKUP TAGGED FILES"
else|:
literal|"BACKUP TREE"
expr_stmt|;
if|if
condition|(
operator|!
name|VARSET
argument_list|(
name|V_BK
argument_list|)
condition|)
block|{
comment|/* No backup program */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|prgname
argument_list|,
literal|"No backup program defined"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|&&
name|checktagged
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* No tagged files */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"No tagged files found"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|changelist
argument_list|(
name|cdlist
argument_list|,
name|who
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Update subtree if needed */
if|if
condition|(
operator|!
name|t
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|checktree
argument_list|(
name|mustup
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
init|;
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
else|else
name|treeflag
operator||=
name|SF_TREE
operator||
name|SF_LIST
expr_stmt|;
block|}
if|if
condition|(
name|treeflag
condition|)
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|puthelp
argument_list|(
literal|"%s: Give filename for backup list (CR:$HOME/%s)"
argument_list|,
name|who
argument_list|,
name|UTBACK
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"List file name:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|list
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|list
argument_list|,
name|pathname
argument_list|(
name|UTBACK
argument_list|,
name|home
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|backuplist
argument_list|(
name|list
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Build command line and call backup program */
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
if|if
condition|(
operator|!
name|VARSET
argument_list|(
name|V_BKO
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|VARVAL
argument_list|(
name|V_BK
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s %s"
argument_list|,
name|VARVAL
argument_list|(
name|V_BK
argument_list|)
argument_list|,
name|VARVAL
argument_list|(
name|V_BKO
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Executing backup program %s ..."
argument_list|,
name|VARVAL
argument_list|(
name|V_BK
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|VARVAL
argument_list|(
name|V_BK
argument_list|)
argument_list|,
literal|"Error in backup"
argument_list|)
operator|)
return|;
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
literal|"Backup done"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* backupdir() */
end_comment

begin_comment
comment|/*  *      CHANGE TO DIRECTORY  */
end_comment

begin_comment
comment|/* Goto a directory */
end_comment

begin_function
name|LOCAL
name|int
name|changedir
parameter_list|()
block|{
specifier|static
name|char
name|pattern
index|[
name|PATLEN
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|char
name|input
index|[
name|PATLEN
index|]
decl_stmt|;
name|dlist
modifier|*
name|dp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|path
decl_stmt|,
name|found
decl_stmt|;
name|who
operator|=
literal|"CHANGE DIRECTORY"
expr_stmt|;
comment|/* Get directory name to change to */
name|puthelp
argument_list|(
literal|"%s: Give directory name (CR:next %s)"
argument_list|,
name|who
argument_list|,
name|pattern
index|[
literal|0
index|]
condition|?
name|pattern
else|:
literal|"quit"
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Change to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|input
argument_list|,
sizeof|sizeof
argument_list|(
name|input
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
block|{
if|if
condition|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pattern
argument_list|,
name|input
argument_list|)
expr_stmt|;
comment|/* Search for directory in tree */
name|found
operator|=
operator|-
literal|1
expr_stmt|;
name|path
operator|=
name|strchr
argument_list|(
name|pattern
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|match
argument_list|(
name|path
condition|?
name|DPNAM
argument_list|(
name|dp
argument_list|)
else|:
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|,
name|pattern
argument_list|)
operator|>
literal|0
condition|)
block|{
name|found
operator|=
name|DDNUM
argument_list|(
name|dp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|<
literal|0
condition|)
for|for
control|(
name|dp
operator|=
name|droot
init|;
name|dp
operator|&&
name|DDNUM
argument_list|(
name|dp
argument_list|)
operator|<=
name|CDNUM
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|match
argument_list|(
name|path
condition|?
name|DPNAM
argument_list|(
name|dp
argument_list|)
else|:
name|DFNAM
argument_list|(
name|dp
argument_list|)
argument_list|,
name|pattern
argument_list|)
operator|>
literal|0
condition|)
block|{
name|found
operator|=
name|DDNUM
argument_list|(
name|dp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|<
literal|0
condition|)
block|{
comment|/* Not found */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|hitkey
argument_list|,
name|who
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|pattern
argument_list|,
literal|"Not found"
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|CDNUM
operator|==
name|found
condition|)
comment|/* Found */
return|return
operator|(
name|RV_OK
operator|)
return|;
elseif|else
if|if
condition|(
name|CDNUM
operator|>
name|found
condition|)
comment|/* Position to directory in tree */
while|while
condition|(
name|CDNUM
operator|>
name|found
condition|)
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|CDNUM
operator|<
name|found
condition|)
operator|(
name|void
operator|)
name|gotree
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* changedir() */
end_comment

begin_comment
comment|/*  *      LIST FILES IN TREE  */
end_comment

begin_comment
comment|/* List matching/tagged files in tree */
end_comment

begin_function
name|LOCAL
name|int
name|listtree
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|pat
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|,
name|ff
decl_stmt|,
name|l
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"LIST TAGGED FILES"
else|:
literal|"LIST FILES"
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|checktagged
argument_list|()
operator|==
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"No tagged files found"
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|checktree
argument_list|(
name|mustup
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:all files)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|pat
argument_list|,
literal|"List which files:"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pat
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
comment|/* Show all matching files */
name|dp
operator|=
name|cdlist
expr_stmt|;
name|l
operator|=
name|firstline
expr_stmt|;
name|ff
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|RV_OK
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
operator|&&
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|DNFIL
argument_list|(
name|dp
argument_list|)
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|(
name|t
operator|&&
name|ISTAG
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
operator|)
operator|||
name|umatch
argument_list|(
name|dp
argument_list|,
name|f
argument_list|,
name|pat
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|==
name|firstline
condition|)
block|{
if|if
condition|(
name|ff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|t
condition|)
name|puthelp
argument_list|(
literal|"%s (CR:continue  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
else|else
name|puthelp
argument_list|(
literal|"%s: %s (CR:continue  ELSE:quit)"
argument_list|,
name|who
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Continue listing ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|' '
operator|)
condition|)
break|break;
else|else
name|c
operator|=
name|RV_OK
expr_stmt|;
block|}
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
name|clearwindow
argument_list|(
name|firstline
argument_list|,
name|lastline
argument_list|)
expr_stmt|;
block|}
operator|++
name|ff
expr_stmt|;
operator|(
name|void
operator|)
name|putfxy
argument_list|(
literal|0
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|dp
argument_list|,
name|f
argument_list|)
argument_list|,
name|DPNAM
argument_list|(
name|dp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|l
operator|>
name|lastline
condition|)
name|l
operator|=
name|firstline
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
name|RV_OK
operator|&&
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|)
do|;
if|if
condition|(
name|c
operator|>=
name|RV_NUL
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Listed %d tagged file(s)"
argument_list|,
name|ff
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Listed %d file(s) matching %s"
argument_list|,
name|ff
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* listtree() */
end_comment

begin_comment
comment|/*  *      CREATE A DIRECTORY  */
end_comment

begin_comment
comment|/* Create a directory */
end_comment

begin_function
name|LOCAL
name|int
name|makedir
parameter_list|()
block|{
name|char
name|newname
index|[
name|NAMELEN
index|]
decl_stmt|,
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|who
operator|=
literal|"MAKE DIRECTORY"
expr_stmt|;
if|if
condition|(
operator|!
name|CCANC
condition|)
block|{
comment|/* Cannot change to directory */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Cannot make directory"
argument_list|)
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s: Give directory name (CR:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Make directory:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|newname
argument_list|,
literal|'/'
argument_list|)
operator|||
name|EQU
argument_list|(
name|newname
argument_list|,
literal|"."
argument_list|)
operator|||
name|EQU
argument_list|(
name|newname
argument_list|,
literal|".."
argument_list|)
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|newname
argument_list|,
literal|"Cannot make directory"
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CNFIL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EQU
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|i
argument_list|)
argument_list|,
name|newname
argument_list|)
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|newname
argument_list|,
literal|"Already exists"
argument_list|)
operator|)
return|;
comment|/* Build command line and call mkdir program */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|MKDIR
argument_list|,
name|pathname
argument_list|(
name|newname
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|errequest
argument_list|(
name|newname
argument_list|,
literal|"Error in creating"
argument_list|)
operator|)
return|;
comment|/* Insert new directory into tree and file lists */
name|dp
operator|=
name|newdlist
argument_list|(
name|newname
argument_list|,
name|FL_FIL
argument_list|)
expr_stmt|;
name|c
operator|=
name|newflist
argument_list|(
name|cdlist
argument_list|)
expr_stmt|;
comment|/* Update flag and return */
if|if
condition|(
name|dp
condition|)
block|{
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
return|return
operator|(
name|RV_NUL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* makedir() */
end_comment

begin_comment
comment|/*  *      REMOVE A DIRECTORY OR TREE  */
end_comment

begin_comment
comment|/* Remove a directory */
end_comment

begin_function
name|LOCAL
name|int
name|removedir
parameter_list|()
block|{
name|char
name|buf
index|[
name|EXECLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|rflag
decl_stmt|;
name|who
operator|=
literal|"REMOVE DIRECTORY"
expr_stmt|;
comment|/* Check if removing is permitted */
if|if
condition|(
operator|!
name|CCANC
operator|||
name|cdlist
operator|==
name|droot
operator|||
name|CNDIR
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CCANC
condition|)
comment|/* Cannot change to directory */
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Cannot remove"
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|cdlist
operator|==
name|droot
condition|)
comment|/* Root cannot be removed */
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Cannot remove root directory"
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|CNDIR
operator|>
literal|0
condition|)
comment|/* Contains subdirectories */
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Contains subdirectories. Cannot remove subtrees"
argument_list|)
operator|)
return|;
block|}
name|puthelp
argument_list|(
literal|"%s (Y:remove  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Remove directory %s ?"
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|CNFIL
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s (Y:request  N:don't request  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|hitakey
argument_list|(
literal|"Directory is not empty, request before removing files ?"
argument_list|,
name|echoline
argument_list|,
name|DA_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'n'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|rflag
operator|=
name|c
operator|==
literal|'y'
expr_stmt|;
block|}
comment|/* First remove files from directory */
if|if
condition|(
name|rflag
condition|)
name|puthelp
argument_list|(
literal|"REMOVE FILE (Y:remove  Q:quit  ELSE:don't remove)"
argument_list|)
expr_stmt|;
else|else
name|puthelp
argument_list|(
literal|"%s (In progress ...)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CNFIL
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|c
operator|=
name|removefile
argument_list|(
name|cdlist
argument_list|,
name|i
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_OK
operator|&&
name|rflag
condition|)
block|{
name|showflist
argument_list|(
name|firstfline
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putfxy
argument_list|(
name|FCOL
argument_list|,
name|DTROW
argument_list|(
name|cdlist
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NFFMT
argument_list|,
name|CNFIL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There are files: cannot remove directory */
if|if
condition|(
name|CNFIL
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Is not empty"
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|rflag
condition|)
block|{
comment|/* Request before removing */
name|puthelp
argument_list|(
literal|"%s (Y:remove  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Remove directory %s ?"
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
literal|'y'
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|changelist
argument_list|(
name|droot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|RMDIR
argument_list|,
name|CPNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|callsystem
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
name|RV_OK
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Error in removing"
argument_list|)
operator|)
return|;
block|}
comment|/* Get new top directory on screen and current directory */
for|for
control|(
name|dp
operator|=
name|cdlist
init|;
name|dp
operator|&&
name|DTROW
argument_list|(
name|dp
argument_list|)
operator|<=
name|lastdline
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|cdlist
operator|==
name|tdlist
operator|||
operator|(
name|tdlist
operator|!=
name|droot
operator|&&
name|dp
operator|==
name|DNULL
operator|)
condition|)
block|{
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tdlast
operator|=
name|DNULL
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
name|cdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CPREV
expr_stmt|;
comment|/* Delete directory list entry */
name|deletedlist
argument_list|(
name|CNEXT
argument_list|)
expr_stmt|;
comment|/* Update flags */
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
name|writeflag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* removedir() */
end_comment

begin_comment
comment|/*  *      BUILD SUBDIRECTORY TREE  */
end_comment

begin_comment
comment|/* Scan current directory for subdirs and build up and insert subtree */
end_comment

begin_function
name|LOCAL
name|int
name|buildtree
parameter_list|()
block|{
name|char
name|inp
index|[
literal|5
index|]
decl_stmt|,
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|np
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|lev
decl_stmt|,
name|f
decl_stmt|,
name|n
decl_stmt|;
name|who
operator|=
literal|"BUILD TREE"
expr_stmt|;
comment|/* Check if current directory already contains subdirectories */
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
operator|)
operator|&&
name|DLEVL
argument_list|(
name|p
argument_list|)
operator|>
name|CLEVL
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"Contains subdirectories"
argument_list|)
operator|)
return|;
block|}
comment|/* Check if there is any directory to build */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|==
name|FF_DIR
condition|)
break|break;
if|if
condition|(
name|f
operator|>=
name|CNFIL
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|CFNAM
argument_list|,
literal|"No subdirectories found"
argument_list|)
operator|)
return|;
block|}
comment|/* Get max level to build up the subtree */
name|puthelp
argument_list|(
literal|"%s: Give max tree level (CR:quit)"
argument_list|,
name|who
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
name|n
operator|=
name|putecho
argument_list|(
literal|"Give level:"
argument_list|)
expr_stmt|;
name|n
operator|=
name|getline
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
argument_list|(
name|inp
argument_list|)
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|RV_OK
operator|||
operator|(
name|lev
operator|=
name|atoi
argument_list|(
name|inp
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
comment|/* Preserve next dlist and open dlist chain for buildread() */
name|np
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
expr_stmt|;
name|CNEXT
operator|=
name|GNULL
expr_stmt|;
name|n
operator|=
name|dircount
expr_stmt|;
comment|/* Build up the tree for all files which are directories */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|FMODE
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|==
name|FF_DIR
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Building %s %s"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|who
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
if|if
condition|(
name|buildread
argument_list|(
name|name
argument_list|,
name|CLEVL
operator|+
literal|1
argument_list|,
name|CLEVL
operator|+
name|lev
argument_list|,
literal|1
argument_list|)
operator|==
name|RV_INT
condition|)
break|break;
block|}
name|n
operator|=
name|dircount
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* Search for last new dlist, update dlist numbers and close dlist chain */
name|dp
operator|=
name|cdlist
expr_stmt|;
name|f
operator|=
name|CDNUM
expr_stmt|;
do|do
name|DDNUM
argument_list|(
name|dp
argument_list|)
operator|=
name|f
operator|++
expr_stmt|;
do|while
condition|(
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|&&
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
condition|)
do|;
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|np
expr_stmt|;
comment|/* Close the chain */
if|if
condition|(
name|np
condition|)
name|DPREV
argument_list|(
name|np
argument_list|)
operator|=
operator|(
name|glist
operator|*
operator|)
name|dp
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|,
name|f
operator|++
control|)
name|DDNUM
argument_list|(
name|dp
argument_list|)
operator|=
name|f
expr_stmt|;
name|infodlist
argument_list|()
expr_stmt|;
comment|/* Rebuild treeinfo */
name|checkindent
argument_list|()
expr_stmt|;
comment|/* Check indention */
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"%d new directories built and inserted"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No new directories found and inserted, close dlist chain */
name|CNEXT
operator|=
operator|(
name|glist
operator|*
operator|)
name|np
expr_stmt|;
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"No new directories built or inserted"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* buildtree() */
end_comment

begin_comment
comment|/*  *      UPDATE ALL FILE LISTS  */
end_comment

begin_comment
comment|/* Scan directory tree and update all file lists not yet read in or changed */
end_comment

begin_function
name|LOCAL
name|int
name|scantree
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|who
operator|=
literal|"UPDATE TREE"
expr_stmt|;
if|if
condition|(
name|f
operator|&&
operator|(
name|c
operator|=
name|checktree
argument_list|(
literal|"Update tree ?"
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Walk thru directory list and update file lists if needed */
if|if
condition|(
name|buildflag
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cdlist
expr_stmt|;
do|do
block|{
if|if
condition|(
name|keypressed
argument_list|()
operator|&&
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|<
name|RV_NUL
condition|)
break|break;
if|if
condition|(
operator|!
name|DCANC
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* Cannot cd: skip */
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|=
name|FL_FIL
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|DFLAG
argument_list|(
name|dp
argument_list|)
operator|!=
name|FL_FIL
condition|)
block|{
comment|/* Rebuild file list */
if|if
condition|(
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|showdline
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
name|treeflag
operator||=
name|SF_MOVE
operator||
name|SF_ECHO
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|)
do|;
block|}
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scantree() */
end_comment

begin_comment
comment|/*  *      SORT FILELISTS IN TREE  */
end_comment

begin_comment
comment|/* Sort filelists in current directory or subtree */
end_comment

begin_function
name|LOCAL
name|int
name|sorttree
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"SORT TREE"
else|:
literal|"SORT DIRECTORY"
expr_stmt|;
name|s
operator|=
name|CSORT
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* Toggle sort flag */
comment|/* Walk thru subtree */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
init|;
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|keypressed
argument_list|()
operator|&&
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|RV_NUL
operator|)
return|;
operator|(
name|void
operator|)
name|sortlist
argument_list|(
name|dp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|sortlist
argument_list|(
name|cdlist
argument_list|,
name|s
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
name|treeflag
operator||=
name|SF_FILE
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sorttree() */
end_comment

begin_comment
comment|/*  *      ZOOM FILELISTS IN TREE  */
end_comment

begin_comment
comment|/* Get zoom pattern and rebuild filelists in directory or subtree */
end_comment

begin_function
name|LOCAL
name|int
name|zoomtree
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|pat
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"ZOOM TREE"
else|:
literal|"ZOOM DIRECTORY"
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:all files)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|pat
argument_list|,
literal|"Zoom which files:"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Walk thru subtree */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|cancel
argument_list|)
expr_stmt|;
name|dp
operator|=
name|cdlist
expr_stmt|;
do|do
block|{
if|if
condition|(
name|keypressed
argument_list|()
operator|&&
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|<
name|RV_NUL
condition|)
break|break;
if|if
condition|(
name|zoomlist
argument_list|(
name|dp
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|showdline
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|t
operator|&&
operator|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
operator|)
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|>
name|CLEVL
condition|)
do|;
name|treeflag
operator||=
name|SF_FILE
operator||
name|SF_LIST
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* zoomtree() */
end_comment

begin_comment
comment|/*  *      MARKED AND TAGGED DIRECTORIES  */
end_comment

begin_comment
comment|/* Set/unset mark on current directory */
end_comment

begin_function
name|LOCAL
name|VOID
name|markdir
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
if|if
condition|(
name|mdlist
operator|==
name|cdlist
operator|&&
operator|!
name|f
condition|)
comment|/* Reset mark */
name|mdlist
operator|=
name|DNULL
expr_stmt|;
else|else
comment|/* Set mark */
name|mdlist
operator|=
name|cdlist
expr_stmt|;
block|}
end_function

begin_comment
comment|/* markdir() */
end_comment

begin_comment
comment|/* Go to marked directory */
end_comment

begin_function
name|LOCAL
name|int
name|gomarkdir
parameter_list|()
block|{
specifier|register
name|dlist
modifier|*
name|mp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|mdlist
condition|)
block|{
name|mp
operator|=
name|mdlist
expr_stmt|;
name|mdlist
operator|=
name|cdlist
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|cdlist
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
comment|/* Search forward */
if|if
condition|(
name|dp
operator|==
name|mp
condition|)
block|{
while|while
condition|(
name|cdlist
operator|!=
name|mp
operator|&&
name|gotree
argument_list|(
literal|1
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|droot
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
comment|/* Search backward */
if|if
condition|(
name|dp
operator|==
name|mp
condition|)
block|{
while|while
condition|(
name|cdlist
operator|!=
name|mp
operator|&&
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No mark set */
block|}
end_function

begin_comment
comment|/* gomarkdir() */
end_comment

begin_comment
comment|/* Goto directory containing tagged files */
end_comment

begin_function
name|LOCAL
name|int
name|gotagged
parameter_list|()
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|cdlist
argument_list|)
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|DNTAG
argument_list|(
name|dp
argument_list|)
condition|)
block|{
while|while
condition|(
name|gotree
argument_list|(
literal|1
argument_list|)
operator|&&
name|dp
operator|!=
name|cdlist
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|droot
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
comment|/* Search backward */
if|if
condition|(
name|DNTAG
argument_list|(
name|dp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dp
operator|!=
name|cdlist
condition|)
while|while
condition|(
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
operator|&&
name|dp
operator|!=
name|cdlist
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No match */
block|}
end_function

begin_comment
comment|/* gotagged() */
end_comment

begin_comment
comment|/* Goto parent directory */
end_comment

begin_function
name|LOCAL
name|int
name|goparent
parameter_list|()
block|{
specifier|register
name|int
name|lev
decl_stmt|;
if|if
condition|(
name|cdlist
operator|!=
name|droot
condition|)
block|{
name|lev
operator|=
name|CLEVL
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
operator|&&
name|CLEVL
operator|!=
name|lev
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* goparent() */
end_comment

begin_comment
comment|/*  *      SEARCH FOR PATTERN IN TREE  */
end_comment

begin_comment
comment|/* Search for pattern in tree */
end_comment

begin_function
name|LOCAL
name|int
name|greptree
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|input
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|ff
decl_stmt|,
name|nt
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"GREP TREE"
else|:
literal|"GREP DIRECTORY"
expr_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
name|c
operator|=
name|checktree
argument_list|(
name|mustup
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: Give search pattern (CR:%s)"
argument_list|,
name|who
argument_list|,
name|gpattern
index|[
literal|0
index|]
condition|?
name|gpattern
else|:
literal|"quit"
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Search for pattern:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|input
argument_list|,
sizeof|sizeof
argument_list|(
name|input
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|GNULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|gpattern
argument_list|,
name|input
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|RV_NUL
operator|||
operator|(
name|c
operator|==
name|RV_NUL
operator|&&
name|gpattern
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:all files)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|input
argument_list|,
literal|"Search in which files:"
argument_list|)
operator|)
operator|==
name|RV_NUL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|input
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Walk thru subtree */
name|dp
operator|=
name|cdlist
expr_stmt|;
do|do
block|{
name|nt
operator|=
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ff
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|CFLAG
operator|!=
name|FL_FIL
operator|&&
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|cdlist
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
comment|/* Update! */
return|return
operator|(
name|c
operator|)
return|;
comment|/* Walk thru file list */
for|for
control|(
name|c
operator|=
name|RV_NUL
operator|,
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
block|{
name|ff
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Search in all matching files */
if|if
condition|(
operator|(
name|c
operator|=
name|umatch
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|,
name|input
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Search for \'%s\' in %s"
argument_list|,
name|gpattern
argument_list|,
name|pathname
argument_list|(
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|CPNAM
argument_list|)
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
comment|/* Search pattern found: what to do? */
if|if
condition|(
operator|(
name|c
operator|=
name|grepfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
block|{
name|ff
operator|=
name|f
expr_stmt|;
name|treeflag
operator|&=
operator|~
operator|(
name|SF_ECHO
operator||
name|SF_HELP
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s (CR:next  SP:change dir  M:mark dir  T:tag file  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Found \'%s\': %s -> %s"
argument_list|,
name|gpattern
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
literal|'t'
condition|)
block|{
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|=
name|FF_TAG
expr_stmt|;
operator|++
name|CNTAG
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
condition|)
block|{
name|markdir
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|filemenu
argument_list|(
name|ff
argument_list|,
name|RV_NUL
argument_list|)
operator|)
operator|==
name|RV_END
condition|)
return|return
operator|(
name|c
operator|)
return|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s (CR:continue  SP:select  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Continue searching for \'%s\':"
argument_list|,
name|gpattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
literal|' '
condition|)
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|RV_INT
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|nt
operator|!=
name|DNTAG
argument_list|(
name|dp
argument_list|)
condition|)
name|showdlist
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|&&
operator|(
name|c
operator|==
name|RV_NUL
operator|||
name|c
operator|==
literal|'\n'
operator|)
operator|&&
name|gotree
argument_list|(
literal|1
argument_list|)
operator|&&
name|CLEVL
operator|>
name|DLEVL
argument_list|(
name|dp
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|RV_END
condition|)
return|return
operator|(
name|c
operator|)
return|;
while|while
condition|(
name|cdlist
operator|!=
name|dp
condition|)
comment|/* Position to starting directory */
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ff
operator|<
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|gpattern
argument_list|,
literal|"Not found"
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* greptree() */
end_comment

begin_comment
comment|/*  *      FIND A FILE IN TREE  */
end_comment

begin_comment
comment|/* Find a file in file tree */
end_comment

begin_function
name|LOCAL
name|int
name|findtree
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
name|char
name|input
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|c
decl_stmt|,
name|ff
decl_stmt|,
name|nt
decl_stmt|;
name|who
operator|=
name|t
condition|?
literal|"FIND TREE"
else|:
literal|"FIND DIRECTORY"
expr_stmt|;
if|if
condition|(
name|t
operator|&&
operator|(
name|c
operator|=
name|checktree
argument_list|(
name|mustup
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: Give file pattern (CR:%s)"
argument_list|,
name|who
argument_list|,
name|fpattern
index|[
literal|0
index|]
condition|?
name|fpattern
else|:
literal|"quit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|input
argument_list|,
literal|"Search for which file:"
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fpattern
argument_list|,
name|input
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|RV_NUL
operator|||
operator|(
name|c
operator|==
name|RV_NUL
operator|&&
name|fpattern
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Walk thru subtree */
name|dp
operator|=
name|cdlist
expr_stmt|;
do|do
block|{
name|nt
operator|=
name|DNTAG
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ff
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|CFLAG
operator|!=
name|FL_FIL
operator|&&
operator|(
name|c
operator|=
name|newflist
argument_list|(
name|cdlist
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
comment|/* Update! */
return|return
operator|(
name|c
operator|)
return|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Find \'%s\' in %s"
argument_list|,
name|fpattern
argument_list|,
name|CPNAM
argument_list|)
expr_stmt|;
name|flushout
argument_list|()
expr_stmt|;
comment|/* Walk thru file list */
for|for
control|(
name|c
operator|=
name|RV_NUL
operator|,
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|CNFIL
condition|;
name|f
operator|++
control|)
block|{
name|ff
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* File found: what to do now? */
if|if
condition|(
operator|(
name|c
operator|=
name|findfile
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|)
operator|==
name|RV_OK
condition|)
block|{
name|ff
operator|=
name|f
expr_stmt|;
name|treeflag
operator|&=
operator|~
operator|(
name|SF_ECHO
operator||
name|SF_HELP
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s (CR:next  SP:change dir  M:mark dir  T:tag file  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Found: %s -> %s"
argument_list|,
name|FFNAM
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
argument_list|,
name|CFNAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
literal|'t'
condition|)
block|{
name|FITAG
argument_list|(
name|cdlist
argument_list|,
name|f
argument_list|)
operator|=
name|FF_TAG
expr_stmt|;
operator|++
name|CNTAG
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'m'
condition|)
block|{
name|markdir
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|filemenu
argument_list|(
name|ff
argument_list|,
name|RV_NUL
argument_list|)
operator|)
operator|==
name|RV_END
condition|)
return|return
operator|(
name|c
operator|)
return|;
operator|(
name|void
operator|)
name|updatetree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|puthelp
argument_list|(
literal|"%s (CR:continue  SP:select  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Continue searching file \'%s\':"
argument_list|,
name|fpattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
literal|' '
condition|)
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|nt
operator|!=
name|DNTAG
argument_list|(
name|dp
argument_list|)
condition|)
name|showdlist
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|&&
operator|(
name|c
operator|==
name|RV_NUL
operator|||
name|c
operator|==
literal|'\n'
operator|)
operator|&&
name|gotree
argument_list|(
literal|1
argument_list|)
operator|&&
name|CLEVL
operator|>
name|DLEVL
argument_list|(
name|dp
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|RV_END
condition|)
return|return
operator|(
name|c
operator|)
return|;
while|while
condition|(
name|cdlist
operator|!=
name|dp
condition|)
comment|/* Position to starting directory */
operator|(
name|void
operator|)
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ff
operator|<
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|errequest
argument_list|(
name|fpattern
argument_list|,
literal|"Not found"
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* findtree() */
end_comment

begin_comment
comment|/*  *      WRITE TREE LIST  */
end_comment

begin_comment
comment|/* Write tree list */
end_comment

begin_function
name|LOCAL
name|int
name|writetreelist
parameter_list|()
block|{
name|char
name|list
index|[
name|INPLEN
index|]
decl_stmt|,
name|name
index|[
name|NAMELEN
index|]
decl_stmt|,
name|pat
index|[
name|PATLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|w
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|wc
decl_stmt|;
name|who
operator|=
literal|"WRITE TREE"
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|changelist
argument_list|(
name|cdlist
argument_list|,
name|who
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: Give list filename (CR:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
name|c
operator|=
name|putecho
argument_list|(
literal|"Write list to:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getline
argument_list|(
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|list
argument_list|)
argument_list|,
name|c
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CLIST
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|puthelp
argument_list|(
literal|"%s: Give choice (D:dirs  F:files  L:list  M:matches  T:tags  ELSE:quit)"
argument_list|,
name|who
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Write out what:"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|hitakey
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
default|default:
return|return
operator|(
name|c
operator|)
return|;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
name|wc
operator|=
literal|'d'
expr_stmt|;
name|w
operator|=
literal|"Directory"
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
name|wc
operator|=
literal|'f'
expr_stmt|;
name|w
operator|=
literal|"File"
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
name|wc
operator|=
literal|'l'
expr_stmt|;
name|w
operator|=
literal|"Tree"
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
case|case
literal|'t'
case|:
name|wc
operator|=
literal|'t'
expr_stmt|;
name|w
operator|=
literal|"Tagged file"
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|puthelp
argument_list|(
literal|"WRITE MATCHING FILES: Give file pattern (CR:quit)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getpattern
argument_list|(
name|pat
argument_list|,
literal|"Write which files:"
argument_list|)
operator|)
operator|<
name|RV_NUL
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|wc
operator|=
literal|'m'
expr_stmt|;
name|w
operator|=
name|pat
expr_stmt|;
break|break;
block|}
comment|/* Write out list file */
name|puthelp
argument_list|(
literal|"%s %s"
argument_list|,
name|who
argument_list|,
name|hitkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|=
name|writedlist
argument_list|(
name|list
argument_list|,
name|cdlist
argument_list|,
name|w
argument_list|,
name|wc
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|checkdlist
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|buildflag
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|updatedlist
argument_list|()
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|treeflag
operator||=
name|SF_FILE
expr_stmt|;
block|}
if|if
condition|(
name|wc
operator|==
literal|'m'
condition|)
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Files matching \'%s\' written to \'%s\'"
argument_list|,
name|w
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"%s list written to \'%s\'"
argument_list|,
name|w
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|hitakey
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
block|}
comment|/* Error in writing */
return|return
operator|(
name|errequest
argument_list|(
name|list
argument_list|,
literal|"Cannot write"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* writetreelist() */
end_comment

begin_comment
comment|/*  *      MOVE UP OR DOWN IN DIRECTORY TREE  */
end_comment

begin_comment
comment|/* Go up or down in directory list */
end_comment

begin_function
name|GLOBL
name|int
name|gotree
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* At beginning or end of directory tree */
if|if
condition|(
operator|(
name|dir
operator|<
literal|0
operator|&&
name|CPREV
operator|==
name|GNULL
operator|)
operator|||
operator|(
name|dir
operator|>
literal|0
operator|&&
name|CNEXT
operator|==
name|GNULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
block|{
comment|/* Previous directory in tree */
name|cdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CPREV
expr_stmt|;
name|treeflag
operator||=
name|SF_LIST
expr_stmt|;
comment|/* Out of screen boundaries */
if|if
condition|(
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|<=
name|firstdline
operator|&&
name|cdlist
operator|!=
name|droot
condition|)
block|{
name|tdlist
operator|=
name|cdlist
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ndlines
operator|/
literal|2
init|;
name|i
operator|>
literal|0
operator|&&
name|DPREV
argument_list|(
name|tdlist
argument_list|)
condition|;
name|i
operator|--
control|)
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_TREE
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_LAST
expr_stmt|;
block|}
else|else
block|{
comment|/* Next directory in tree */
name|cdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
expr_stmt|;
name|treeflag
operator||=
name|SF_LIST
expr_stmt|;
comment|/* Out of screen boundaries */
if|if
condition|(
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|>
name|lastdline
operator|||
operator|(
name|DTROW
argument_list|(
name|cdlist
argument_list|)
operator|==
name|lastdline
operator|&&
name|CNEXT
operator|)
condition|)
block|{
name|tdlist
operator|=
name|cdlist
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ndlines
operator|/
literal|2
init|;
name|i
operator|>
literal|0
operator|&&
name|DNEXT
argument_list|(
name|tdlist
argument_list|)
condition|;
name|i
operator|--
control|)
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ndlines
init|;
name|DPREV
argument_list|(
name|tdlist
argument_list|)
operator|&&
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|tdlist
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|tdlist
argument_list|)
expr_stmt|;
name|treeflag
operator||=
name|SF_TREE
expr_stmt|;
block|}
else|else
name|treeflag
operator||=
name|SF_LAST
expr_stmt|;
block|}
name|treeflag
operator||=
name|SF_FILE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gotree() */
end_comment

begin_comment
comment|/* Go up or down on same level */
end_comment

begin_function
name|LOCAL
name|int
name|golevel
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
name|l
operator|=
name|CLEVL
expr_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|cdlist
operator|!=
name|droot
condition|)
block|{
comment|/* Up */
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CPREV
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DPREV
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|<=
name|l
condition|)
break|break;
do|do
operator|(
name|void
operator|)
name|gotree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
do|while
condition|(
name|dp
operator|&&
name|cdlist
operator|!=
name|dp
condition|)
do|;
if|if
condition|(
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|==
name|l
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|>
literal|0
operator|&&
name|CNEXT
condition|)
block|{
comment|/* Down */
for|for
control|(
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|CNEXT
init|;
name|dp
condition|;
name|dp
operator|=
operator|(
name|dlist
operator|*
operator|)
name|DNEXT
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|<=
name|l
condition|)
break|break;
do|do
operator|(
name|void
operator|)
name|gotree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
do|while
condition|(
name|dp
operator|&&
name|cdlist
operator|!=
name|dp
condition|)
do|;
if|if
condition|(
name|dp
operator|&&
name|DLEVL
argument_list|(
name|dp
argument_list|)
operator|==
name|l
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not possible */
block|}
end_function

begin_comment
comment|/* golevel() */
end_comment

begin_comment
comment|/* Go page up or down */
end_comment

begin_function
name|LOCAL
name|int
name|gopage
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|int
name|l
decl_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|CPREV
condition|)
block|{
comment|/* Page up */
for|for
control|(
name|l
operator|=
name|ndlines
init|;
name|l
operator|>
literal|0
operator|&&
name|gotree
argument_list|(
name|dir
argument_list|)
condition|;
name|l
operator|--
control|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|>
literal|0
operator|&&
name|CNEXT
condition|)
block|{
comment|/* Page down */
for|for
control|(
name|l
operator|=
name|ndlines
init|;
name|l
operator|>
literal|0
operator|&&
name|gotree
argument_list|(
literal|1
argument_list|)
condition|;
name|l
operator|--
control|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not possible */
block|}
end_function

begin_comment
comment|/* gopage() */
end_comment

begin_comment
comment|/* Go to beginning or end of tree */
end_comment

begin_function
name|LOCAL
name|int
name|gobegend
parameter_list|(
name|dir
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
block|{
if|if
condition|(
name|dir
operator|<
literal|0
operator|&&
name|CPREV
condition|)
block|{
comment|/* Beginning */
name|mdlist
operator|=
name|cdlist
expr_stmt|;
while|while
condition|(
name|gotree
argument_list|(
name|dir
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|>
literal|0
operator|&&
name|CNEXT
condition|)
block|{
comment|/* End */
name|mdlist
operator|=
name|cdlist
expr_stmt|;
while|while
condition|(
name|gotree
argument_list|(
name|dir
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not possible */
block|}
end_function

begin_comment
comment|/* gobegend() */
end_comment

begin_comment
comment|/*  *      REFRESH ON SCREEN RESIZING  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
end_if

begin_comment
comment|/* Refresh tree screen after screen size changes */
end_comment

begin_function
name|GLOBL
name|int
name|refreshtree
parameter_list|(
name|f
parameter_list|)
specifier|register
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|f
condition|)
operator|(
name|void
operator|)
name|refreshfile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checkindent
argument_list|()
expr_stmt|;
name|ndlines
operator|=
name|lastdline
operator|-
name|firstdline
expr_stmt|;
name|dp
operator|=
name|cdlist
expr_stmt|;
name|cdlist
operator|=
name|tdlist
operator|=
name|droot
expr_stmt|;
while|while
condition|(
name|cdlist
operator|!=
name|dp
operator|&&
name|gotree
argument_list|(
literal|1
argument_list|)
condition|)
empty_stmt|;
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
return|return
operator|(
name|RV_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* refreshtree() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGWINCH&& TIOCGWINSZ */
end_comment

begin_comment
comment|/*  *      SELECT DIRECTORY  */
end_comment

begin_comment
comment|/* Walk thru tree and select a directory */
end_comment

begin_function
name|GLOBL
name|char
modifier|*
name|selectdir
parameter_list|(
name|what
parameter_list|)
specifier|register
name|char
modifier|*
name|what
decl_stmt|;
block|{
specifier|register
name|dlist
modifier|*
name|cd
decl_stmt|,
modifier|*
name|td
decl_stmt|;
specifier|register
name|char
modifier|*
name|dn
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|f
decl_stmt|;
comment|/* Save current and top dirs */
name|cd
operator|=
name|cdlist
expr_stmt|;
name|td
operator|=
name|tdlist
expr_stmt|;
name|dn
operator|=
name|what
expr_stmt|;
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
comment|/* Select tree loop */
do|do
block|{
comment|/* Special update for tree screen if needed */
if|if
condition|(
name|treeflag
condition|)
block|{
name|f
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_HELP
condition|)
name|f
operator||=
name|SF_HELP
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&
name|SF_ECHO
condition|)
name|f
operator||=
name|SF_ECHO
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|updatetree
argument_list|(
literal|1
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
block|{
name|dn
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|f
operator|&
name|SF_HELP
condition|)
name|puthelp
argument_list|(
literal|"SELECT DIRECTORY (CR:select  Q:quit)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|SF_ECHO
condition|)
operator|(
name|void
operator|)
name|putecho
argument_list|(
literal|"Move to and select directory for %s"
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
operator|(
name|void
operator|)
name|cursorxy
argument_list|(
name|TCOL
operator|+
name|DTCOL
argument_list|(
name|cdlist
argument_list|)
operator|-
literal|1
argument_list|,
name|DTROW
argument_list|(
name|cdlist
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|=
name|getkey
argument_list|()
condition|)
block|{
default|default:
comment|/* Ignore */
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
comment|/* Select current directory */
case|case
literal|' '
case|:
case|case
name|K_SEL
case|:
case|case
name|K_INS
case|:
name|dn
operator|=
name|CPNAM
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
comment|/* Parent */
case|case
name|K_DEL
case|:
if|if
condition|(
operator|!
name|goparent
argument_list|()
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Return */
case|case
literal|'Q'
case|:
case|case
name|K_BRK
case|:
case|case
name|K_EOF
case|:
comment|/* EOF */
name|dn
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|K_PREV
case|:
comment|/* Previous */
case|case
literal|'k'
case|:
comment|/* For vi fans */
if|if
condition|(
operator|!
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_NEXT
case|:
comment|/* Next */
case|case
literal|'j'
case|:
comment|/* For vi fans */
if|if
condition|(
operator|!
name|gotree
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_BACK
case|:
comment|/* Up on same level */
if|if
condition|(
operator|!
name|golevel
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_FORW
case|:
comment|/* Down on same level */
if|if
condition|(
operator|!
name|golevel
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_PPAG
case|:
comment|/* Page up */
if|if
condition|(
operator|!
name|gopage
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_NPAG
case|:
comment|/* Page down */
if|if
condition|(
operator|!
name|gopage
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_HOME
case|:
comment|/* Beginning */
if|if
condition|(
operator|!
name|gobegend
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_END
case|:
comment|/* End */
if|if
condition|(
operator|!
name|gobegend
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Change to directory */
name|c
operator|=
name|changedir
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* Mark current directory */
case|case
name|K_MARK
case|:
name|markdir
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Goto previously marked directory */
case|case
name|K_GOTO
case|:
if|if
condition|(
operator|!
name|gomarkdir
argument_list|()
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_SIZE
case|:
comment|/* Screen size changed */
name|c
operator|=
name|RV_SIZ
expr_stmt|;
comment|/*FALL THROUGH*/
case|case
name|K_REFR
case|:
comment|/* Refresh */
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
comment|/* Refresh screen after screen resize */
if|if
condition|(
name|c
operator|==
name|RV_SIZ
condition|)
operator|(
name|void
operator|)
name|refreshtree
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGWINCH&& TIOCGWINSZ */
block|}
do|while
condition|(
name|dn
operator|==
name|what
condition|)
do|;
comment|/* Restore current and top dirs */
name|cdlist
operator|=
name|cd
expr_stmt|;
name|tdlist
operator|=
name|td
expr_stmt|;
return|return
operator|(
name|dn
operator|)
return|;
block|}
end_function

begin_comment
comment|/* selectdir() */
end_comment

begin_comment
comment|/*  *      DIRECTORY TREE MENU LOOP  */
end_comment

begin_comment
comment|/* Tree menu */
end_comment

begin_function
name|GLOBL
name|int
name|treemenu
parameter_list|(
name|update
parameter_list|)
specifier|register
name|int
name|update
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Init tree variables */
name|checkindent
argument_list|()
expr_stmt|;
name|cdlist
operator|=
name|tdlist
operator|=
name|droot
expr_stmt|;
name|menuline
operator|=
name|tmline
expr_stmt|;
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
comment|/* Scan and update file lists in tree if reading from a list file */
if|if
condition|(
name|update
operator|&&
operator|(
name|c
operator|=
name|scantree
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* Tree menu loop */
do|do
block|{
comment|/* Update tree screen if needed and clock */
name|buildflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|treeflag
operator|&&
operator|(
name|c
operator|=
name|updatetree
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
name|RV_OK
condition|)
return|return
operator|(
name|c
operator|)
return|;
ifdef|#
directive|ifdef
name|UTCLOCK
if|if
condition|(
name|VARSET
argument_list|(
name|V_CL
argument_list|)
condition|)
name|clockon
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* UTCLOCK */
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UTCLOCK
if|if
condition|(
name|VARSET
argument_list|(
name|V_CL
argument_list|)
condition|)
name|clockoff
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* UTCLOCK */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|K_BRK
case|:
comment|/* Ignore interrupt */
default|default:
comment|/* Unknown: ring the bell */
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_PREV
case|:
comment|/* Previous */
case|case
literal|'k'
case|:
comment|/* For vi fans */
if|if
condition|(
operator|!
name|gotree
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_NEXT
case|:
comment|/* Next */
case|case
literal|'j'
case|:
comment|/* For vi fans */
if|if
condition|(
operator|!
name|gotree
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_BACK
case|:
comment|/* Up on same level */
if|if
condition|(
operator|!
name|golevel
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_FORW
case|:
comment|/* Down on same level */
if|if
condition|(
operator|!
name|golevel
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_TAG
case|:
comment|/* Next directory containing tagged files */
if|if
condition|(
operator|!
name|gotagged
argument_list|()
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_UP
case|:
comment|/* Scroll up */
if|if
condition|(
operator|!
name|scrolltree
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_DOWN
case|:
comment|/* Scroll down */
if|if
condition|(
operator|!
name|scrolltree
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_PPAG
case|:
comment|/* Page up */
if|if
condition|(
operator|!
name|gopage
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_NPAG
case|:
comment|/* Page down */
if|if
condition|(
operator|!
name|gopage
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_HOME
case|:
comment|/* Begin */
if|if
condition|(
operator|!
name|gobegend
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_END
case|:
comment|/* End */
if|if
condition|(
operator|!
name|gobegend
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* Mark current directory */
case|case
name|K_MARK
case|:
name|markdir
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Goto previously marked directory */
case|case
name|K_GOTO
case|:
if|if
condition|(
operator|!
name|gomarkdir
argument_list|()
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_SIZE
case|:
comment|/* Screen size changed */
name|c
operator|=
name|RV_SIZ
expr_stmt|;
comment|/*FALL THROUGH*/
case|case
name|K_REFR
case|:
comment|/* Refresh */
name|treeflag
operator|=
name|SF_FULL
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Help */
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
name|K_HELP
case|:
name|c
operator|=
name|showhelp
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
comment|/* Change to parent */
case|case
name|K_DEL
case|:
if|if
condition|(
operator|!
name|goparent
argument_list|()
condition|)
block|{
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*FALL THROUGH*/
case|case
literal|' '
case|:
comment|/* Change to directory */
case|case
literal|'>'
case|:
case|case
name|K_SEL
case|:
case|case
name|K_INS
case|:
do|do
name|c
operator|=
name|filemenu
argument_list|(
operator|-
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|==
name|RV_DIR
condition|)
do|;
break|break;
case|case
literal|'b'
case|:
comment|/* Backup tree */
name|c
operator|=
name|backupdir
argument_list|(
name|ONTG
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* List file in tree */
name|c
operator|=
name|listtree
argument_list|(
name|ONTG
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Create a directory */
name|c
operator|=
name|makedir
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Remove a directory */
name|c
operator|=
name|removedir
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Change to directory */
name|c
operator|=
name|changedir
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* List tagged files */
name|c
operator|=
name|listtree
argument_list|(
name|ONTG
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Backup tagged files */
name|c
operator|=
name|backupdir
argument_list|(
name|ONTG
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Copy tagged files */
name|c
operator|=
name|copytagged
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Remove tagged files */
name|c
operator|=
name|removetagged
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Move tagged files */
name|c
operator|=
name|movetagged
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Display directory status info */
case|case
literal|'S'
case|:
name|c
operator|=
name|statusdir
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Display directory information */
case|case
literal|'I'
case|:
name|c
operator|=
name|infodir
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Search for string */
case|case
literal|'G'
case|:
name|c
operator|=
name|greptree
argument_list|(
name|ONTR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Find a file */
case|case
literal|'F'
case|:
name|c
operator|=
name|findtree
argument_list|(
name|ONTR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Tag files */
case|case
literal|'T'
case|:
name|c
operator|=
name|tagtree
argument_list|(
name|ONTR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Untag files */
case|case
literal|'U'
case|:
name|c
operator|=
name|untagtree
argument_list|(
name|ONTR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* New sort file list */
case|case
literal|'N'
case|:
name|c
operator|=
name|sorttree
argument_list|(
name|ONTR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* Zoom file list */
case|case
literal|'Z'
case|:
name|c
operator|=
name|zoomtree
argument_list|(
name|ONTR
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* Switch menu line */
name|menuline
operator|=
name|menuline
operator|==
name|utreemenu
condition|?
name|tmline
else|:
name|utreemenu
expr_stmt|;
name|treeflag
operator||=
name|SF_HELP
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* User defined tree command 1..9 */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|changelist
argument_list|(
name|cdlist
argument_list|,
literal|"USER COMMAND"
argument_list|)
operator|<
name|RV_NUL
condition|)
break|break;
name|c
operator|=
name|usercommand
argument_list|(
name|c
operator|-
literal|'0'
operator|+
name|V_TC0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
comment|/* Escape to shell */
case|case
literal|'$'
case|:
if|if
condition|(
name|changelist
argument_list|(
name|cdlist
argument_list|,
literal|"SHELL ESCAPE"
argument_list|)
operator|<
name|RV_NUL
condition|)
break|break;
name|c
operator|=
name|history
argument_list|(
name|c
argument_list|,
name|V_TC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VARSET
argument_list|(
name|V_ST
argument_list|)
condition|)
operator|(
name|void
operator|)
name|scandlist
argument_list|(
name|droot
argument_list|)
expr_stmt|;
if|if
condition|(
name|buildflag
condition|)
name|c
operator|=
name|updatedlist
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* Show/set variables */
name|c
operator|=
name|variables
argument_list|()
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* Show/set file type commands */
name|c
operator|=
name|commands
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* Show key bindings */
name|c
operator|=
name|bindings
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
comment|/* Enlarge tree window */
if|if
condition|(
operator|!
name|resizetree
argument_list|(
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* Shrink tree window */
if|if
condition|(
operator|!
name|resizetree
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bell
argument_list|(
name|VARSET
argument_list|(
name|V_BL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Write out tree list */
case|case
literal|'O'
case|:
name|c
operator|=
name|writetreelist
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
comment|/* Scan directory tree and update file lists */
name|c
operator|=
name|scantree
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Build subdirectory tree */
name|c
operator|=
name|buildtree
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Display version string */
case|case
literal|'A'
case|:
name|c
operator|=
name|putversion
argument_list|(
name|echoline
argument_list|,
literal|"ABOUT: Utree version"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Date */
case|case
literal|'D'
case|:
name|c
operator|=
name|printdate
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Print current working directory */
case|case
literal|'W'
case|:
name|c
operator|=
name|printcwd
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Exit utree */
case|case
literal|'Q'
case|:
case|case
name|K_EOF
case|:
name|c
operator|=
name|RV_END
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
comment|/* Refresh screen after screen resize */
if|if
condition|(
name|c
operator|==
name|RV_SIZ
condition|)
name|c
operator|=
name|refreshtree
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGWINCH&& TIOCGWINSZ */
block|}
do|while
condition|(
operator|!
operator|(
name|c
operator|==
name|RV_END
operator|||
name|c
operator|==
name|RV_ERR
operator|)
condition|)
do|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* treemenu() */
end_comment

end_unit

