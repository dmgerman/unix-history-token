begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * The routines contained in this file do all the rcs file parsing and  * manipulation  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)rcs.c 1.28 92/03/31"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|RCS_getbranch
parameter_list|(
name|RCSNode
modifier|*
name|rcs
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|force_tag_match
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
parameter_list|(
name|RCSNode
modifier|*
name|rcs
parameter_list|,
name|char
modifier|*
name|date
parameter_list|,
name|char
modifier|*
name|branch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getrcskey
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
modifier|*
name|keyp
parameter_list|,
name|char
modifier|*
modifier|*
name|valp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_rcs_proc
parameter_list|(
name|Node
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkmagic_proc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_branches
parameter_list|(
name|List
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_symbols
parameter_list|(
name|List
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|null_delproc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rcsnode_delproc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rcsvers_delproc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|parse_rcs_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkmagic_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rcsnode_delproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rcsvers_delproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|null_delproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getrcskey
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_symbols
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_branches
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|RCS_getbranch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|rcslist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repository
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse all the rcs files specified and return a list  */
end_comment

begin_function
name|List
modifier|*
name|RCS_parsefiles
parameter_list|(
name|files
parameter_list|,
name|xrepos
parameter_list|)
name|List
modifier|*
name|files
decl_stmt|;
name|char
modifier|*
name|xrepos
decl_stmt|;
block|{
comment|/* initialize */
name|repository
operator|=
name|xrepos
expr_stmt|;
name|rcslist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* walk the list parsing files */
if|if
condition|(
name|walklist
argument_list|(
name|files
argument_list|,
name|parse_rcs_proc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* free the list and return NULL on error */
name|dellist
argument_list|(
operator|&
name|rcslist
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|List
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
comment|/* return the list we built */
return|return
operator|(
name|rcslist
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an rcs file into a node on the rcs list  */
end_comment

begin_function
specifier|static
name|int
name|parse_rcs_proc
parameter_list|(
name|file
parameter_list|)
name|Node
modifier|*
name|file
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
comment|/* parse the rcs file into rdata */
name|rdata
operator|=
name|RCS_parse
argument_list|(
name|file
operator|->
name|key
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* if we got a valid RCSNode back, put it on the list */
if|if
condition|(
name|rdata
operator|!=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|file
operator|->
name|key
argument_list|)
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|rcsnode_delproc
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|RCSNODE
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|rdata
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|rcslist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an rcsfile given a user file name and a repository  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parse
parameter_list|(
name|file
parameter_list|,
name|repos
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
name|rcsfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcsfile
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcsfile
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rcs
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|->
name|flags
operator||=
name|INATTIC
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
block|}
return|return
operator|(
name|rcs
operator|)
return|;
block|}
name|rcs
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
return|return
operator|(
name|rcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the real work of parsing an RCS file  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parsercsfile
parameter_list|(
name|rcsfile
parameter_list|)
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|Node
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* open the rcsfile */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|rcsfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcs file `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* make a node */
name|rdata
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rdata
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|versions
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|rdata
operator|->
name|dates
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * process all the special header information, break out when we get to      * the first revision delta      */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get the next key/value pair */
comment|/* if key is NULL here, then the file is missing some headers */
if|if
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|key
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' does not appear to be a valid rcs file"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* process it */
if|if
condition|(
name|strcmp
argument_list|(
name|RCSHEAD
argument_list|,
name|key
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|NULL
condition|)
block|{
name|rdata
operator|->
name|head
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|RCSBRANCH
argument_list|,
name|key
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|NULL
condition|)
block|{
name|rdata
operator|->
name|branch
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|rdata
operator|->
name|branch
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* turn it into a branch if it's a revision */
name|cp
operator|=
name|rindex
argument_list|(
name|rdata
operator|->
name|branch
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|RCSSYMBOLS
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
comment|/* if there are tags, set up the tag list */
name|rdata
operator|->
name|symbols
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_symbols
argument_list|(
name|rdata
operator|->
name|symbols
argument_list|,
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 	 * check key for '.''s and digits (probably a rev) if it is a 	 * revision, we are done with the headers and are down to the 	 * revision deltas, so we break out of the loop 	 */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* if we haven't grabbed it yet, we didn't want it */
block|}
comment|/*      * we got out of the loop, so we have the first part of the first      * revision delta in our hand key=the revision and value=the date key and      * its value      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|valp
decl_stmt|;
name|char
name|date
index|[
name|MAXDATELEN
index|]
decl_stmt|;
comment|/* grab the value of the date from value */
name|valp
operator|=
name|value
operator|+
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
expr_stmt|;
comment|/* skip the "date" keyword */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|valp
argument_list|)
condition|)
comment|/* take space off front of value */
name|valp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|date
argument_list|,
name|valp
argument_list|)
expr_stmt|;
comment|/* get the nodes (q is by version, r is by date) */
name|q
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|r
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|RCSVERS
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|RCSVERS
expr_stmt|;
name|q
operator|->
name|delproc
operator|=
name|rcsvers_delproc
expr_stmt|;
name|r
operator|->
name|delproc
operator|=
name|null_delproc
expr_stmt|;
name|q
operator|->
name|data
operator|=
name|r
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|q
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|q
operator|->
name|data
expr_stmt|;
comment|/* fill in the version before we forget it */
name|q
operator|->
name|key
operator|=
name|vnode
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* throw away the author field */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* throw away the state field */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* fill in the date field */
name|r
operator|->
name|key
operator|=
name|vnode
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
comment|/* fill in the branch list (if any branches exist) */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|vnode
operator|->
name|branches
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_branches
argument_list|(
name|vnode
operator|->
name|branches
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the next field if there is a next revision */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|vnode
operator|->
name|next
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* 	 * at this point, we skip any user defined fields XXX - this is where 	 * we put the symbolic link stuff??? 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* if we have a revision, break and do it */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* add the nodes to the lists */
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|rdata
operator|->
name|versions
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|rdata
operator|->
name|dates
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* 	 * if we left the loop because there were no more keys, we break out 	 * of the revision processing loop 	 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rdata
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rcsnode_delproc - free up an RCS type node  */
end_comment

begin_function
specifier|static
name|void
name|rcsnode_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|freercsnode
argument_list|(
operator|(
name|RCSNode
operator|*
operator|*
operator|)
operator|&
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * freercsnode - free up the info for an RCSNode  */
end_comment

begin_function
name|void
name|freercsnode
parameter_list|(
name|rnodep
parameter_list|)
name|RCSNode
modifier|*
modifier|*
name|rnodep
decl_stmt|;
block|{
if|if
condition|(
name|rnodep
operator|==
name|NULL
operator|||
operator|*
name|rnodep
operator|==
name|NULL
condition|)
return|return;
operator|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|path
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|versions
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|dates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|symbols
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|rnodep
argument_list|)
expr_stmt|;
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rcsvers_delproc - free up an RCSVers type node  */
end_comment

begin_function
specifier|static
name|void
name|rcsvers_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|RCSVers
modifier|*
name|rnode
decl_stmt|;
name|rnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|branches
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|branches
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|next
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * null_delproc - don't free anything since it will be free'd by someone else  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|null_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
comment|/* don't do anything */
block|}
end_function

begin_comment
comment|/*  * getrcskey - fill in the key and value from the rcs file the algorithm is  *             as follows   *  *    o skip whitespace o fill in key with everything up to next white   *      space or semicolon   *    o if key == "desc" then key and data are NULL and return -1   *    o if key wasn't terminated by a semicolon, skip white space and fill   *      in value with everything up to a semicolon o compress all whitespace  *      down to a single space   *    o if a word starts with @, do funky rcs processing  *    o strip whitespace off end of value or set value to NULL if it empty   *    o return 0 since we found something besides "desc"  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|keysize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|valsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALLOCINCR
value|1024
end_define

begin_function
specifier|static
name|int
name|getrcskey
parameter_list|(
name|fp
parameter_list|,
name|keyp
parameter_list|,
name|valp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|keyp
decl_stmt|;
name|char
modifier|*
modifier|*
name|valp
decl_stmt|;
block|{
name|char
modifier|*
name|cur
decl_stmt|,
modifier|*
name|max
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|funky
init|=
literal|0
decl_stmt|;
name|int
name|white
init|=
literal|1
decl_stmt|;
comment|/* skip leading whitespace */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
comment|/* fill in key */
name|cur
operator|=
name|key
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
name|cur
operator|<
name|max
condition|)
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|key
operator|=
name|xrealloc
argument_list|(
name|key
argument_list|,
name|keysize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
name|keysize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
comment|/* if we got "desc", we are done with the file */
if|if
condition|(
name|strcmp
argument_list|(
name|RCSDESC
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* if we ended key with a semicolon, there is no value */
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* otherwise, there might be a value, so fill it in */
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
comment|/* process the value */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get a character */
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* if we are in funky mode, do the rest of this string */
if|if
condition|(
name|funky
condition|)
block|{
comment|/* 	     * funky mode processing does the following: o @@ means one @ o 	     * all other characters are literal up to a single @ (including 	     * ';') 	     */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'@'
condition|)
block|{
comment|/* @ followed by non @ turns off funky mode */
name|funky
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* otherwise, we already ate one @ so copy the other one */
block|}
comment|/* put the character on the value (maybe allocating space) */
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|value
operator|=
name|xrealloc
argument_list|(
name|value
argument_list|,
name|valsize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
name|valsize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* if we got the semi-colon we are done with the entire value */
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
break|break;
comment|/* process the character we got */
if|if
condition|(
name|white
operator|&&
name|c
operator|==
literal|'@'
condition|)
block|{
comment|/* 	     * if we are starting a word with an '@', enable funky processing 	     */
name|white
operator|=
literal|0
expr_stmt|;
comment|/* you can't be funky and white :-) */
name|funky
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * we put the character on the list, compressing all whitespace 	     * to a single space 	     */
comment|/* whitespace with white set means compress it out */
if|if
condition|(
name|white
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* make c a space and set white */
name|white
operator|=
literal|1
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
else|else
name|white
operator|=
literal|0
expr_stmt|;
comment|/* put the char on the end of value (maybe allocating space) */
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|value
operator|=
name|xrealloc
argument_list|(
name|value
argument_list|,
name|valsize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
name|valsize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* if the last char was white space, take it off */
if|if
condition|(
name|white
operator|&&
name|cur
operator|!=
name|value
condition|)
name|cur
operator|--
expr_stmt|;
comment|/* terminate the string */
if|if
condition|(
name|cur
condition|)
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
comment|/* if the string is empty, make it null */
if|if
condition|(
name|value
operator|&&
operator|*
name|value
operator|!=
literal|'\0'
condition|)
operator|*
name|valp
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process the symbols list of the rcs file  */
end_comment

begin_function
specifier|static
name|void
name|do_symbols
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* split it up into tag and rev */
name|tag
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process the branches list of a revision delta  */
end_comment

begin_function
specifier|static
name|void
name|do_branches
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* find the end of this branch */
name|branch
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Version Number  *   * Returns the requested version number of the RCS file, satisfying tags and/or  * dates, and walking branches, if necessary.  *   * The result is returned; null-string if error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getversion
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
comment|/* make sure we have something to look at... */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|tag
operator|&&
name|date
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|rev
decl_stmt|,
modifier|*
name|tagrev
decl_stmt|;
comment|/* 	 * first lookup the tag; if that works, turn the revision into 	 * a branch and lookup the date. 	 */
name|tagrev
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|tagrev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|tagrev
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|tagrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tagrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|rev
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tag
condition|)
return|return
operator|(
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|date
condition|)
return|return
operator|(
name|RCS_getdate
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the revision for a specific tag.  * If force_tag_match is set, return NULL if an exact match is not  * possible otherwise return RCS_head ().  We are careful to look for  * and handle "magic" revisions specially.  *   * If the matched tag is a branch tag, find the head of the branch.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_gettag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* make sure we have something to look at... */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* If tag is "HEAD", special case to get head RCS revision */
if|if
condition|(
name|tag
operator|&&
operator|(
name|strcmp
argument_list|(
name|tag
argument_list|,
name|TAG_HEAD
argument_list|)
operator|==
literal|0
operator|||
operator|*
name|tag
operator|==
literal|'\0'
operator|)
condition|)
if|if
condition|(
name|force_tag_match
operator|&&
operator|(
name|rcs
operator|->
name|flags
operator|&
name|VALID
operator|)
operator|&&
operator|(
name|rcs
operator|->
name|flags
operator|&
name|INATTIC
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* head request for removed file */
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* If we got a symbolic tag, resolve it to a numeric */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
else|else
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|magic
decl_stmt|,
modifier|*
name|branch
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|tag
operator|=
name|p
operator|->
name|data
expr_stmt|;
comment|/* 	     * If this is a magic revision, we turn it into either its 	     * physical branch equivalent (if one exists) or into 	     * its base revision, which we assume exists. 	     */
name|dots
operator|=
name|numdots
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dots
operator|>
literal|2
operator|&&
operator|(
name|dots
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|branch
operator|=
name|rindex
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|cp
operator|=
name|branch
operator|++
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|xtag
decl_stmt|;
comment|/* it's magic.  See if the branch exists */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
name|xtag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
comment|/* and back again */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|xtag
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|magic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|branch
operator|)
return|;
block|}
return|return
operator|(
name|xtag
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The tag wasn't there, so return the head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
comment|/*      * numeric tag processing:      *		1) revision number - just return it      *		2) branch number   - find head of branch      */
comment|/* strip trailing dots */
while|while
condition|(
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|tag
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* we have a branch tag, so we need to walk the branch */
return|return
operator|(
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* we have a revision tag, so make sure it exists */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
else|else
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|tag
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* The revision wasn't there, so return the head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return a "magic" revision as a virtual branch off of REV for the RCS file.  * A "magic" revision is one which is unique in the RCS file.  By unique, I  * mean we return a revision which:  *	- has a branch of 0 (see rcs.h RCS_MAGIC_BRANCH)  *	- has a revision component which is not an existing branch off REV  *	- has a revision component which is not an existing magic revision  *	- is an even-numbered revision, to avoid conflicts with vendor branches  * The first point is what makes it "magic".  *  * As an example, if we pass in 1.37 as REV, we will look for an existing  * branch called 1.37.2.  If it did not exist, we would look for an  * existing symbolic tag with a numeric part equal to 1.37.0.2.  If that  * didn't exist, then we know that the 1.37.2 branch can be reserved by  * creating a symbolic tag with 1.37.0.2 as the numeric part.  *  * This allows us to fork development with very little overhead -- just a  * symbolic tag is used in the RCS file.  When a commit is done, a physical  * branch is dynamically created to hold the new revision.  *  * Note: We assume that REV is an RCS revision and not a branch number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_rev
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|RCS_magicrev
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|rev_num
decl_stmt|;
name|char
modifier|*
name|xrev
decl_stmt|,
modifier|*
name|test_branch
decl_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev
argument_list|)
operator|+
literal|14
argument_list|)
expr_stmt|;
comment|/* enough for .0.number */
name|check_rev
operator|=
name|xrev
expr_stmt|;
comment|/* only look at even numbered branches */
for|for
control|(
name|rev_num
operator|=
literal|2
init|;
condition|;
name|rev_num
operator|+=
literal|2
control|)
block|{
comment|/* see if the physical branch exists */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d"
argument_list|,
name|rev
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
name|test_branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|xrev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_branch
operator|!=
name|NULL
condition|)
comment|/* it did, so keep looking */
block|{
name|free
argument_list|(
name|test_branch
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now, create a "magic" revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|rev
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
comment|/* walk the symbols list to see if a magic one already exists */
if|if
condition|(
name|walklist
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|checkmagic_proc
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* we found a free magic branch.  Claim it as ours */
return|return
operator|(
name|xrev
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * walklist proc to look for a match in the symbols list.  * Returns 0 if the symbol does not match, 1 if it does.  */
end_comment

begin_function
specifier|static
name|int
name|checkmagic_proc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|check_rev
argument_list|,
name|p
operator|->
name|data
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the specified revision number or symbolic tag  * resolves to a "branch" within the rcs file.  We do take into account  * any magic branches as well.  */
end_comment

begin_function
name|int
name|RCS_isbranch
parameter_list|(
name|file
parameter_list|,
name|rev
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|int
name|dots
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
comment|/* numeric revisions are easy -- even number of dots is a branch */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
condition|)
return|return
operator|(
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
comment|/* assume a revision if you can't find the RCS info */
name|p
operator|=
name|findnode
argument_list|(
name|srcfiles
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* now, look for a match in the symbols list */
name|rcs
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|rindex
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to malloc'ed memory which contains the branch  * for the specified *symbolic* tag.  Magic branches are handled correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_whatbranch
parameter_list|(
name|file
parameter_list|,
name|rev
parameter_list|,
name|srcfiles
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|List
modifier|*
name|srcfiles
decl_stmt|;
block|{
name|int
name|dots
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
comment|/* assume no branch if you can't find the RCS info */
name|p
operator|=
name|findnode
argument_list|(
name|srcfiles
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* now, look for a match in the symbols list */
name|rcs
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|)
return|;
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|rindex
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|++
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* yep.  it's magic.  now, construct the real branch */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|p
operator|->
name|data
argument_list|,
name|branch
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
comment|/* and turn it back */
return|return
operator|(
name|magic
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the specified branch.  If the branch does not exist,  * return NULL or RCS_head depending on force_tag_match  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|RCS_getbranch
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|RCSVers
modifier|*
name|vn
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|nextvers
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* make sure we have something to look at... */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* find out if the tag contains a dot, or is on the trunk */
name|cp
operator|=
name|rindex
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* trunk processing is the special case */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for an extra . */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|rcs
operator|->
name|head
init|;
name|cp
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|xtag
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|cp
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|xstrdup
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
comment|/* if it had a `.', terminate the string so we have the base revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* look up the revision this branch is based on */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* put the . back so we have the branch again */
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* if the base revision didn't exist, return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* find the first element of the branch we are looking for */
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 for the extra '.' */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|head
operator|=
name|vn
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xtag
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|head
condition|)
block|{
comment|/* we didn't find a match so return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* now walk the next pointers of the branch */
name|nextvers
operator|=
name|p
operator|->
name|key
expr_stmt|;
do|do
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|nextvers
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* a link in the chain is missing - return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|nextvers
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|nextvers
operator|!=
name|NULL
condition|)
do|;
comment|/* we have the version in our hand, so go for it */
return|return
operator|(
name|xstrdup
argument_list|(
name|vn
operator|->
name|version
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the RCS file.  If branch is set, this is the head of the  * branch, otherwise the real head  */
end_comment

begin_function
name|char
modifier|*
name|RCS_head
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
comment|/* make sure we have something to look at... */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|rcs
operator|->
name|branch
condition|)
return|return
operator|(
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|branch
argument_list|,
literal|1
argument_list|)
operator|)
return|;
comment|/*      * NOTE: we call getbranch with force_tag_match set to avoid any      * possibility of recursion      */
else|else
return|return
operator|(
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the most recent revision, based on the supplied date, but use some  * funky stuff and follow the vendor branch maybe  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getdate
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
init|=
name|NULL
decl_stmt|;
comment|/* make sure we have something to look at... */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* if the head is on a branch, try the branch first */
if|if
condition|(
name|rcs
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
comment|/* if we found a match, we are done */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
comment|/* otherwise if we have a trunk, try it */
if|if
condition|(
name|rcs
operator|->
name|head
condition|)
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* if the date of this one is before date, take it */
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
break|break;
block|}
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * at this point, either we have the revision we want, or we have the      * first revision on the trunk (1.1?) in our hands      */
comment|/* if we found what we're looking for, and it's not 1.1 return it */
if|if
condition|(
name|cur_rev
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|cur_rev
argument_list|,
literal|"1.1"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
operator|)
return|;
comment|/* look on the vendor branch */
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|CVSBRANCH
argument_list|)
expr_stmt|;
comment|/*      * if we found a match, return it; otherwise, we return the first      * revision on the trunk or NULL depending on force_tag_match and the      * date of the first rev      */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
operator|!
name|force_tag_match
operator|||
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|vers
operator|->
name|version
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the last element on a branch that was put in before the specified  * date (return the rev or NULL)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|branch
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|xbranch
decl_stmt|,
modifier|*
name|xrev
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* look up the first revision on the branch */
name|xrev
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|xrev
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|xrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* if no branches list, return NULL */
if|if
condition|(
name|vers
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* walk the branches list looking for the branch number */
name|xbranch
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for the extra dot */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xbranch
argument_list|,
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xbranch
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vers
operator|->
name|branches
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|vers
operator|->
name|branches
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xbranch
argument_list|,
name|strlen
argument_list|(
name|xbranch
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|vers
operator|->
name|branches
operator|->
name|list
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* walk the next pointers until you find the end, or the date is too late */
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
else|else
break|break;
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* if we found something acceptable, return it - otherwise NULL */
if|if
condition|(
name|cur_rev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two dates in RCS format. Beware the change in format on January 1,  * 2000, when years go from 2-digit to full format.  */
end_comment

begin_function
name|int
name|RCS_datecmp
parameter_list|(
name|date1
parameter_list|,
name|date2
parameter_list|)
name|char
modifier|*
name|date1
decl_stmt|,
decl|*
name|date2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|length_diff
init|=
name|strlen
argument_list|(
name|date1
argument_list|)
operator|-
name|strlen
argument_list|(
name|date2
argument_list|)
decl_stmt|;
return|return
operator|(
name|length_diff
condition|?
name|length_diff
else|:
name|strcmp
argument_list|(
name|date1
argument_list|,
name|date2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Lookup the specified revision in the ,v file and return, in the date  * argument, the date specified for the revision *minus one second*, so that  * the logically previous revision will be found later.  *   * Returns zero on failure, RCS revision time as a Unix "time_t" on success.  */
end_comment

begin_function
name|time_t
name|RCS_getrevtime
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|date
parameter_list|,
name|fudge
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|fudge
decl_stmt|;
block|{
name|char
name|tdate
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|struct
name|tm
name|xtm
decl_stmt|,
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|revdate
init|=
literal|0
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* make sure we have something to look at... */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
name|revdate
operator|)
return|;
comment|/* look up the revision */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* split up the date */
name|ftm
operator|=
operator|&
name|xtm
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|ftm
operator|->
name|tm_year
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mon
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mday
argument_list|,
operator|&
name|ftm
operator|->
name|tm_hour
argument_list|,
operator|&
name|ftm
operator|->
name|tm_min
argument_list|,
operator|&
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftm
operator|->
name|tm_year
operator|>
literal|1900
condition|)
name|ftm
operator|->
name|tm_year
operator|-=
literal|1900
expr_stmt|;
comment|/* put the date in a form getdate can grok */
ifdef|#
directive|ifdef
name|HAVE_RCS5
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tdate
argument_list|,
literal|"%d/%d/%d GMT %d:%d:%d"
argument_list|,
name|ftm
operator|->
name|tm_mon
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_year
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tdate
argument_list|,
literal|"%d/%d/%d %d:%d:%d"
argument_list|,
name|ftm
operator|->
name|tm_mon
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_year
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* turn it into seconds since the epoch */
name|revdate
operator|=
name|get_date
argument_list|(
name|tdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|revdate
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|revdate
operator|-=
name|fudge
expr_stmt|;
comment|/* remove "fudge" seconds */
if|if
condition|(
name|date
condition|)
block|{
comment|/* put an appropriate string into ``date'' if we were given one */
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|revdate
argument_list|)
expr_stmt|;
else|#
directive|else
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|revdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revdate
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The argument ARG is the getopt remainder of the -k option specified on the  * command line.  This function returns malloc'ed space that can be used  * directly in calls to RCS V5, with the -k flag munged correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_check_kflag
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|kflags
index|[]
init|=
block|{
literal|"kv"
block|,
literal|"kvl"
block|,
literal|"k"
block|,
literal|"v"
block|,
literal|"o"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
name|char
name|karg
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|cpp
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_RCS5
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s %s: your version of RCS does not support the -k option"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arg
condition|)
block|{
for|for
control|(
name|cpp
operator|=
name|kflags
init|;
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
operator|*
name|cpp
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|cpp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s: invalid -k option\n"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvalid options are:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|kflags
init|;
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-k%s\n"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Please retry with a valid -k option"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|karg
argument_list|,
literal|"-k%s"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xstrdup
argument_list|(
name|karg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do some consistency checks on the symbolic tag... These should equate  * pretty close to what RCS checks, though I don't know for certain.  */
end_comment

begin_function
name|void
name|RCS_check_tag
parameter_list|(
name|tag
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|char
modifier|*
name|invalid
init|=
literal|"$,.:;@"
decl_stmt|;
comment|/* invalid RCS tag characters */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/*      * The first character must be an alphabetic letter. The remaining      * characters cannot be non-visible graphic characters, and must not be      * in the set of "invalid" RCS identifier characters.      */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|tag
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isgraph
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' has non-visible graphic characters"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|invalid
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must not contain the characters `%s'"
argument_list|,
name|tag
argument_list|,
name|invalid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must start with a letter"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

