begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Display an MSDOS directory  *  * Emmet P. Gray			US Army, HQ III Corps& Fort Hood  * ...!uunet!uiucuxc!fthood!egray	Attn: AFZF-DE-ENV  * fthood!egray@uxc.cso.uiuc.edu	Directorate of Engineering& Housing  * 					Environmental Management Office  * 					Fort Hood, TX 76544-5057  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"msdos.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_decl_stmt
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the file descriptor for the device */
end_comment

begin_decl_stmt
name|int
name|dir_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starting sector for directory */
end_comment

begin_decl_stmt
name|int
name|dir_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of directory (in sectors) */
end_comment

begin_decl_stmt
name|int
name|dir_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of directory entries */
end_comment

begin_decl_stmt
name|int
name|clus_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cluster size (in sectors) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mcwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the Current Working Directory */
end_comment

begin_decl_stmt
name|int
name|fat_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FAT error detected? */
end_comment

begin_function_decl
specifier|static
name|long
name|getfree
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|conv_date
argument_list|()
decl_stmt|,
modifier|*
name|conv_time
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|entry
decl_stmt|,
name|files
decl_stmt|,
name|fargn
decl_stmt|,
name|wide
decl_stmt|,
name|faked
decl_stmt|;
name|long
name|size
decl_stmt|,
name|blocks
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|,
modifier|*
name|time
decl_stmt|,
name|last_drive
decl_stmt|,
modifier|*
name|fix_mcwd
argument_list|()
decl_stmt|;
name|char
modifier|*
name|strncpy
argument_list|()
decl_stmt|,
name|newpath
index|[
name|MAX_PATH
index|]
decl_stmt|,
modifier|*
name|get_name
argument_list|()
decl_stmt|,
modifier|*
name|get_path
argument_list|()
decl_stmt|,
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|newfile
decl_stmt|,
modifier|*
name|filename
decl_stmt|,
modifier|*
name|unix_name
argument_list|()
decl_stmt|,
name|volume
index|[
literal|12
index|]
decl_stmt|,
name|drive
decl_stmt|,
modifier|*
name|strpbrk
argument_list|()
decl_stmt|;
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|,
name|newname
index|[
literal|13
index|]
decl_stmt|,
modifier|*
name|strncat
argument_list|()
decl_stmt|,
name|get_drive
argument_list|()
decl_stmt|;
name|void
name|exit
parameter_list|()
function_decl|;
name|struct
name|directory
modifier|*
name|dir
decl_stmt|,
modifier|*
name|dir_read
argument_list|()
decl_stmt|;
name|fargn
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
literal|0
expr_stmt|;
name|files
operator|=
literal|0
expr_stmt|;
comment|/* first argument */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-w"
argument_list|)
condition|)
block|{
name|wide
operator|=
literal|1
expr_stmt|;
name|fargn
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|wide
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal option -- %c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mtools version %s, dated %s\n"
argument_list|,
name|VERSION
argument_list|,
name|DATE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s: [-w] msdosdirectory\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       %s: [-w] msdosfile [msdosfiles...]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fake an argument */
name|faked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|==
name|fargn
condition|)
block|{
name|faked
operator|++
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
name|last_drive
operator|=
literal|'x'
expr_stmt|;
name|mcwd
operator|=
name|fix_mcwd
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|fargn
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|faked
condition|)
block|{
name|drive
operator|=
name|get_drive
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|filename
operator|=
name|get_name
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|get_path
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drive
operator|=
name|get_drive
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|filename
operator|=
name|get_name
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|get_path
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* is this a new device? */
if|if
condition|(
name|drive
operator|!=
name|last_drive
condition|)
block|{
if|if
condition|(
name|last_drive
operator|!=
literal|'x'
condition|)
block|{
name|blocks
operator|=
name|getfree
argument_list|()
operator|*
name|MSECTOR_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|files
condition|)
name|printf
argument_list|(
literal|"File \"%s\" not found\n\n"
argument_list|,
name|newname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"     %3d File(s)     %6ld bytes free\n\n"
argument_list|,
name|files
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
argument_list|(
name|drive
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot initialize '%c:'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|drive
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|last_drive
operator|=
name|drive
expr_stmt|;
name|files
operator|=
literal|0
expr_stmt|;
comment|/* find the volume label */
name|volume
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|dir_entries
condition|;
name|entry
operator|++
control|)
block|{
name|dir
operator|=
name|dir_read
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* if empty */
if|if
condition|(
name|dir
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0x0
condition|)
break|break;
comment|/* if erased */
if|if
condition|(
name|dir
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0xe5
condition|)
continue|continue;
comment|/* if not volume label */
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|attr
operator|&
literal|0x08
operator|)
condition|)
continue|continue;
name|strncpy
argument_list|(
name|volume
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dir
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|volume
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|volume
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dir
operator|->
name|ext
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|volume
index|[
literal|11
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|volume
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|" Volume in drive %c has no label\n"
argument_list|,
name|drive
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" Volume in drive %c is %s\n"
argument_list|,
name|drive
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Move to "first guess" subdirectory, so that is_dir() can 		 * search to see if filename is also a directory. 		 */
if|if
condition|(
name|subdir
argument_list|(
name|drive
argument_list|,
name|pathname
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Under MSDOS, wildcards that match directories don't 		 * display the contents of that directory.  So I guess I'll 		 * do that too. 		 */
if|if
condition|(
operator|(
name|strpbrk
argument_list|(
name|filename
argument_list|,
literal|"*[?"
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
name|is_dir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpath
index|[
name|strlen
argument_list|(
name|newpath
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|newpath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newpath
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* move to real subdirectory */
if|if
condition|(
name|subdir
argument_list|(
name|drive
argument_list|,
name|newpath
argument_list|)
condition|)
continue|continue;
name|strcpy
argument_list|(
name|newname
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|newpath
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* if no files, assume '*' */
if|if
condition|(
operator|*
name|filename
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|newname
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Directory for %c:%s\n\n"
argument_list|,
name|drive
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|dir_entries
condition|;
name|entry
operator|++
control|)
block|{
name|dir
operator|=
name|dir_read
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* if empty */
if|if
condition|(
name|dir
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0x0
condition|)
break|break;
comment|/* if erased */
if|if
condition|(
name|dir
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0xe5
condition|)
continue|continue;
comment|/* if a volume label */
if|if
condition|(
name|dir
operator|->
name|attr
operator|&
literal|0x08
condition|)
continue|continue;
name|newfile
operator|=
name|unix_name
argument_list|(
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|newfile
argument_list|,
name|newname
argument_list|)
condition|)
continue|continue;
name|files
operator|++
expr_stmt|;
if|if
condition|(
name|wide
operator|&&
name|files
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|files
operator|-
literal|1
operator|)
operator|%
literal|5
operator|)
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|date
operator|=
name|conv_date
argument_list|(
name|dir
operator|->
name|date
index|[
literal|1
index|]
argument_list|,
name|dir
operator|->
name|date
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|time
operator|=
name|conv_time
argument_list|(
name|dir
operator|->
name|time
index|[
literal|1
index|]
argument_list|,
name|dir
operator|->
name|time
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
name|dir
operator|->
name|size
index|[
literal|3
index|]
operator|*
literal|0x1000000L
operator|+
name|dir
operator|->
name|size
index|[
literal|2
index|]
operator|*
literal|0x10000L
operator|+
name|dir
operator|->
name|size
index|[
literal|1
index|]
operator|*
literal|0x100
operator|+
name|dir
operator|->
name|size
index|[
literal|0
index|]
expr_stmt|;
comment|/* is a subdirectory */
if|if
condition|(
name|dir
operator|->
name|attr
operator|&
literal|0x10
condition|)
block|{
if|if
condition|(
name|wide
condition|)
name|printf
argument_list|(
literal|"%-8.8s %-3.3s   "
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|ext
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-8.8s %-3.3s<DIR>     %s  %s\n"
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|ext
argument_list|,
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wide
condition|)
name|printf
argument_list|(
literal|"%-8.8s %-3.3s   "
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|ext
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-8.8s %-3.3s    %8ld   %s  %s\n"
argument_list|,
name|dir
operator|->
name|name
argument_list|,
name|dir
operator|->
name|ext
argument_list|,
name|size
argument_list|,
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|blocks
operator|=
name|getfree
argument_list|()
operator|*
name|MSECTOR_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|files
condition|)
name|printf
argument_list|(
literal|"File \"%s\" not found\n"
argument_list|,
name|newname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"     %3d File(s)     %6ld bytes free\n"
argument_list|,
name|files
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the amount of free space on the diskette  */
end_comment

begin_function
specifier|static
name|long
name|getfree
parameter_list|()
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|long
name|total
decl_stmt|;
specifier|extern
name|unsigned
name|int
name|num_clus
decl_stmt|;
name|unsigned
name|int
name|fat_decode
parameter_list|()
function_decl|;
name|total
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|num_clus
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* if fat_decode returns zero */
if|if
condition|(
operator|!
name|fat_decode
argument_list|(
name|i
argument_list|)
condition|)
name|total
operator|+=
name|clus_size
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an MSDOS directory date stamp to ASCII  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|conv_date
parameter_list|(
name|date_high
parameter_list|,
name|date_low
parameter_list|)
name|unsigned
name|date_high
decl_stmt|,
name|date_low
decl_stmt|;
block|{
comment|/*  *	    hi byte     |    low byte  *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|  *      | | | | | | | | | | | | | | | | |  *      \   7 bits    /\4 bits/\ 5 bits /  *         year +80      month     day  */
specifier|static
name|char
name|ans
index|[
literal|9
index|]
decl_stmt|;
name|unsigned
name|char
name|year
decl_stmt|,
name|month_hi
decl_stmt|,
name|month_low
decl_stmt|,
name|day
decl_stmt|;
name|year
operator|=
operator|(
name|date_high
operator|>>
literal|1
operator|)
operator|+
literal|80
expr_stmt|;
name|month_hi
operator|=
operator|(
name|date_high
operator|&
literal|0x1
operator|)
operator|<<
literal|3
expr_stmt|;
name|month_low
operator|=
name|date_low
operator|>>
literal|5
expr_stmt|;
name|day
operator|=
name|date_low
operator|&
literal|0x1f
expr_stmt|;
name|sprintf
argument_list|(
name|ans
argument_list|,
literal|"%2d-%02d-%02d"
argument_list|,
name|month_hi
operator|+
name|month_low
argument_list|,
name|day
argument_list|,
name|year
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an MSDOS directory time stamp to ASCII.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|conv_time
parameter_list|(
name|time_high
parameter_list|,
name|time_low
parameter_list|)
name|unsigned
name|time_high
decl_stmt|,
name|time_low
decl_stmt|;
block|{
comment|/*  *	    hi byte     |    low byte  *	|7|6|5|4|3|2|1|0|7|6|5|4|3|2|1|0|  *      | | | | | | | | | | | | | | | | |  *      \  5 bits /\  6 bits  /\ 5 bits /  *         hour      minutes     sec*2  */
specifier|static
name|char
name|ans
index|[
literal|7
index|]
decl_stmt|;
name|char
name|am_pm
decl_stmt|;
name|unsigned
name|char
name|hour
decl_stmt|,
name|min_hi
decl_stmt|,
name|min_low
decl_stmt|;
name|hour
operator|=
name|time_high
operator|>>
literal|3
expr_stmt|;
name|am_pm
operator|=
operator|(
name|hour
operator|>=
literal|12
operator|)
condition|?
literal|'p'
else|:
literal|'a'
expr_stmt|;
if|if
condition|(
name|hour
operator|>
literal|12
condition|)
name|hour
operator|=
name|hour
operator|-
literal|12
expr_stmt|;
if|if
condition|(
name|hour
operator|==
literal|0
condition|)
name|hour
operator|=
literal|12
expr_stmt|;
name|min_hi
operator|=
operator|(
name|time_high
operator|&
literal|0x7
operator|)
operator|<<
literal|3
expr_stmt|;
name|min_low
operator|=
name|time_low
operator|>>
literal|5
expr_stmt|;
name|sprintf
argument_list|(
name|ans
argument_list|,
literal|"%2d:%02d%c"
argument_list|,
name|hour
argument_list|,
name|min_hi
operator|+
name|min_low
argument_list|,
name|am_pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * stubs for read-only programs  */
end_comment

begin_function
name|void
name|disk_flush
parameter_list|()
block|{
specifier|extern
name|int
name|disk_dirty
decl_stmt|;
name|disk_dirty
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|dir_flush
parameter_list|()
block|{
specifier|extern
name|int
name|dir_dirty
decl_stmt|;
name|dir_dirty
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

end_unit

