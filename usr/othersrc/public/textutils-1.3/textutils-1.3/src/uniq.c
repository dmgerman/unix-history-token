begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* uniq -- remove duplicate lines from a sorted file    Copyright (C) 1986, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Richard Stallman and David MacKenzie. */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"linebuffer.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_function_decl
name|char
modifier|*
name|find_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|different
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|check_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|writeline
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Number of fields to skip on each line when doing comparisons. */
end_comment

begin_decl_stmt
name|int
name|skip_fields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars to skip after skipping any fields. */
end_comment

begin_decl_stmt
name|int
name|skip_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars to compare; if 0, compare the whole lines. */
end_comment

begin_decl_stmt
name|int
name|check_chars
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|countmode
block|{
name|count_occurrences
block|,
comment|/* -c Print count before output lines. */
name|count_none
comment|/* Default.  Do not print counts. */
block|}
enum|;
end_enum

begin_comment
comment|/* Whether and how to precede the output lines with a count of the number of    times they occurred in the input. */
end_comment

begin_decl_stmt
name|enum
name|countmode
name|countmode
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|output_mode
block|{
name|output_repeated
block|,
comment|/* -d Only lines that are repeated. */
name|output_unique
block|,
comment|/* -u Only lines that are not repeated. */
name|output_all
comment|/* Default.  Print first copy of each line. */
block|}
enum|;
end_enum

begin_comment
comment|/* Which lines to output. */
end_comment

begin_decl_stmt
name|enum
name|output_mode
name|mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"count"
block|,
literal|0
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"repeated"
block|,
literal|0
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"unique"
block|,
literal|0
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"skip-fields"
block|,
literal|1
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"skip-chars"
block|,
literal|1
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"check-chars"
block|,
literal|1
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|optc
decl_stmt|;
name|char
modifier|*
name|infile
init|=
literal|"-"
decl_stmt|,
modifier|*
name|outfile
init|=
literal|"-"
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|skip_chars
operator|=
literal|0
expr_stmt|;
name|skip_fields
operator|=
literal|0
expr_stmt|;
name|check_chars
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|output_all
expr_stmt|;
name|countmode
operator|=
name|count_none
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0123456789cdf:s:uw:"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|skip_fields
operator|=
name|skip_fields
operator|*
literal|10
operator|+
name|optc
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|countmode
operator|=
name|count_occurrences
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mode
operator|=
name|output_repeated
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Like '-#'. */
name|skip_fields
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Like '+#'. */
name|skip_chars
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|mode
operator|=
name|output_unique
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|check_chars
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
while|while
condition|(
name|optind
operator|<
name|argc
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|skip_chars
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|infile
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|outfile
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* Extra arguments. */
name|check_file
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process input file INFILE with output to OUTFILE.    If either is "-", use the standard I/O stream for it instead. */
end_comment

begin_function
name|void
name|check_file
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
name|infile
decl_stmt|,
decl|*
name|outfile
decl_stmt|;
end_function

begin_block
block|{
name|FILE
modifier|*
name|istream
decl_stmt|;
name|FILE
modifier|*
name|ostream
decl_stmt|;
name|struct
name|linebuffer
name|lb1
decl_stmt|,
name|lb2
decl_stmt|;
name|struct
name|linebuffer
modifier|*
name|thisline
decl_stmt|,
modifier|*
name|prevline
decl_stmt|,
modifier|*
name|exch
decl_stmt|;
name|char
modifier|*
name|prevfield
decl_stmt|,
modifier|*
name|thisfield
decl_stmt|;
name|int
name|prevlen
decl_stmt|,
name|thislen
decl_stmt|;
name|int
name|match_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|infile
argument_list|,
literal|"-"
argument_list|)
condition|)
name|istream
operator|=
name|stdin
expr_stmt|;
else|else
name|istream
operator|=
name|fopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|istream
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
condition|)
name|ostream
operator|=
name|stdout
expr_stmt|;
else|else
name|ostream
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostream
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|thisline
operator|=
operator|&
name|lb1
expr_stmt|;
name|prevline
operator|=
operator|&
name|lb2
expr_stmt|;
name|initbuffer
argument_list|(
name|thisline
argument_list|)
expr_stmt|;
name|initbuffer
argument_list|(
name|prevline
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline
argument_list|(
name|prevline
argument_list|,
name|istream
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|closefiles
goto|;
name|prevfield
operator|=
name|find_field
argument_list|(
name|prevline
argument_list|)
expr_stmt|;
name|prevlen
operator|=
name|prevline
operator|->
name|length
operator|-
operator|(
name|prevfield
operator|-
name|prevline
operator|->
name|buffer
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|istream
argument_list|)
condition|)
block|{
if|if
condition|(
name|readline
argument_list|(
name|thisline
argument_list|,
name|istream
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|thisfield
operator|=
name|find_field
argument_list|(
name|thisline
argument_list|)
expr_stmt|;
name|thislen
operator|=
name|thisline
operator|->
name|length
operator|-
operator|(
name|thisfield
operator|-
name|thisline
operator|->
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|different
argument_list|(
name|thisfield
argument_list|,
name|prevfield
argument_list|,
name|thislen
argument_list|,
name|prevlen
argument_list|)
condition|)
name|match_count
operator|++
expr_stmt|;
else|else
block|{
name|writeline
argument_list|(
name|prevline
argument_list|,
name|ostream
argument_list|,
name|match_count
argument_list|)
expr_stmt|;
name|match_count
operator|=
literal|0
expr_stmt|;
name|exch
operator|=
name|prevline
expr_stmt|;
name|prevline
operator|=
name|thisline
expr_stmt|;
name|thisline
operator|=
name|exch
expr_stmt|;
name|prevfield
operator|=
name|thisfield
expr_stmt|;
name|prevlen
operator|=
name|thislen
expr_stmt|;
block|}
block|}
name|writeline
argument_list|(
name|prevline
argument_list|,
name|ostream
argument_list|,
name|match_count
argument_list|)
expr_stmt|;
name|closefiles
label|:
if|if
condition|(
name|ferror
argument_list|(
name|istream
argument_list|)
operator|||
name|fclose
argument_list|(
name|istream
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error reading %s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ostream
argument_list|)
operator|||
name|fclose
argument_list|(
name|ostream
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error writing %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb1
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb2
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a linebuffer LINE,    return a pointer to the beginning of the line's field to be compared. */
end_comment

begin_function
name|char
modifier|*
name|find_field
parameter_list|(
name|line
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|line
decl_stmt|;
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
init|=
name|line
operator|->
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|line
operator|->
name|length
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|skip_fields
operator|&&
name|i
operator|<
name|size
condition|;
name|count
operator|++
control|)
block|{
while|while
condition|(
name|i
operator|<
name|size
operator|&&
name|isblank
argument_list|(
name|lp
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|size
operator|&&
operator|!
name|isblank
argument_list|(
name|lp
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|skip_chars
operator|&&
name|i
operator|<
name|size
condition|;
name|count
operator|++
control|)
name|i
operator|++
expr_stmt|;
return|return
name|lp
operator|+
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return zero if two strings OLD and NEW match, nonzero if not.    OLD and NEW point not to the beginnings of the lines    but rather to the beginnings of the fields to compare.    OLDLEN and NEWLEN are their lengths. */
end_comment

begin_function
name|int
name|different
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|oldlen
parameter_list|,
name|newlen
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|oldlen
decl_stmt|;
name|int
name|newlen
decl_stmt|;
block|{
specifier|register
name|int
name|order
decl_stmt|;
if|if
condition|(
name|check_chars
condition|)
block|{
if|if
condition|(
name|oldlen
operator|>
name|check_chars
condition|)
name|oldlen
operator|=
name|check_chars
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|check_chars
condition|)
name|newlen
operator|=
name|check_chars
expr_stmt|;
block|}
name|order
operator|=
name|memcmp
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|min
argument_list|(
name|oldlen
argument_list|,
name|newlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
literal|0
condition|)
return|return
name|oldlen
operator|-
name|newlen
return|;
return|return
name|order
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the line in linebuffer LINE to stream STREAM    provided that the switches say it should be output.    If requested, print the number of times it occurred, as well;    LINECOUNT + 1 is the number of times that the line occurred. */
end_comment

begin_function
name|void
name|writeline
parameter_list|(
name|line
parameter_list|,
name|stream
parameter_list|,
name|linecount
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|line
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|linecount
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|output_unique
operator|&&
name|linecount
operator|!=
literal|0
operator|)
operator|||
operator|(
name|mode
operator|==
name|output_repeated
operator|&&
name|linecount
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
name|countmode
operator|==
name|count_occurrences
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%7d\t"
argument_list|,
name|linecount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|line
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|line
operator|->
name|length
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-cdu] [-f skip-fields] [-s skip-chars] [-w check-chars]\n\        [-#skip-fields] [+#skip-chars] [--count] [--repeated] [--unique]\n\        [--skip-fields=skip-fields] [--skip-chars=skip-chars]\n\        [--check-chars=check-chars] [infile] [outfile]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

