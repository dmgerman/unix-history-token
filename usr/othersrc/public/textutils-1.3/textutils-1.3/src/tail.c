begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tail -- output last part of file(s)    Copyright (C) 1989, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Can display any amount of data, unlike the Unix version, which uses    a fixed size buffer and therefore can only deliver a limited number    of lines.     Options:    -b			Tail by N 512-byte blocks.    -c, --bytes=N[bkm]	Tail by N bytes 			[or 512-byte blocks, kilobytes, or megabytes].    -f, --follow		Loop forever trying to read more characters at the 			end of the file, on the assumption that the file 			is growing.  Ignored if reading from a pipe. 			Cannot be used if more than one file is given.    -k			Tail by N kilobytes.    -N, -l, -n, --lines=N	Tail by N lines.    -m			Tail by N megabytes.    -q, --quiet, --silent	Never print filename headers.    -v, --verbose		Always print filename headers.     If a number (N) starts with a `+', begin printing with the Nth item    from the start of each file, instead of from the end.     Reads from standard input if no files are given or when a filename of    ``-'' is encountered.    By default, filename headers are printed only more than one file    is given.    By default, prints the last 10 lines (tail -n 10).     Original version by Paul Rubin<phr@ocf.berkeley.edu>.    Extensions by David MacKenzie<djm@ai.mit.edu>. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|isascii
end_ifdef

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isascii ((c))&& isdigit ((c)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isdigit ((c)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of items to tail. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_NUMBER
value|10
end_define

begin_comment
comment|/* Size of atomic reads. */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|(512 * 8)
end_define

begin_comment
comment|/* Number of bytes per item we are printing.    If 0, tail in lines. */
end_comment

begin_decl_stmt
name|int
name|unit_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, read from end of file until killed. */
end_comment

begin_decl_stmt
name|int
name|forever
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, count from start of file instead of end. */
end_comment

begin_decl_stmt
name|int
name|from_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, print filename headers. */
end_comment

begin_decl_stmt
name|int
name|print_headers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When to print the filename banners. */
end_comment

begin_enum
enum|enum
name|header_mode
block|{
name|multiple_files
block|,
name|always
block|,
name|never
block|}
enum|;
end_enum

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|file_lines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pipe_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pipe_lines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|start_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|start_lines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tail
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tail_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tail_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tail_lines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|atou
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_remainder
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|parse_unit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|xwrite
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have ever read standard input. */
end_comment

begin_decl_stmt
name|int
name|have_read_stdin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"bytes"
block|,
literal|1
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"follow"
block|,
literal|0
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"lines"
block|,
literal|1
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"silent"
block|,
literal|0
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|enum
name|header_mode
name|header_mode
init|=
name|multiple_files
decl_stmt|;
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
comment|/* If from_start, the number of items to skip before printing; otherwise,      the number of items at the end of the file to print.  Initially, -1      means the value has not been set. */
name|long
name|number
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Option character. */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|have_read_stdin
operator|=
literal|0
expr_stmt|;
name|unit_size
operator|=
literal|0
expr_stmt|;
name|forever
operator|=
name|from_start
operator|=
name|print_headers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|(
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ISDIGIT
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
operator|(
name|ISDIGIT
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Old option syntax: a dash or plus, one or more digits (zero digits 	 are acceptable with a plus), and one or more option letters. */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|from_start
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|number
operator|=
literal|0
operator|,
operator|++
name|argv
index|[
literal|1
index|]
init|;
name|ISDIGIT
argument_list|(
operator|*
name|argv
index|[
literal|1
index|]
argument_list|)
condition|;
operator|++
name|argv
index|[
literal|1
index|]
control|)
name|number
operator|=
name|number
operator|*
literal|10
operator|+
operator|*
name|argv
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* Parse any appended option letters. */
while|while
condition|(
operator|*
name|argv
index|[
literal|1
index|]
condition|)
block|{
switch|switch
condition|(
operator|*
name|argv
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|unit_size
operator|=
literal|512
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|unit_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|forever
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|unit_size
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|unit_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|unit_size
operator|=
literal|1048576
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|header_mode
operator|=
name|never
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|header_mode
operator|=
name|always
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unrecognized option `-%c'"
argument_list|,
operator|*
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
operator|++
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* Make the options we just parsed invisible to getopt. */
name|argv
index|[
literal|1
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:n:fqv"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
name|unit_size
operator|=
literal|1
expr_stmt|;
name|parse_unit
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
goto|goto
name|getnum
goto|;
case|case
literal|'n'
case|:
name|unit_size
operator|=
literal|0
expr_stmt|;
name|getnum
label|:
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'+'
condition|)
block|{
name|from_start
operator|=
literal|1
expr_stmt|;
operator|++
name|optarg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'-'
condition|)
operator|++
name|optarg
expr_stmt|;
name|number
operator|=
name|atou
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid number `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|forever
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|header_mode
operator|=
name|never
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|header_mode
operator|=
name|always
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|number
operator|==
operator|-
literal|1
condition|)
name|number
operator|=
name|DEFAULT_NUMBER
expr_stmt|;
comment|/* To start printing with item `number' from the start of the file, skip      `number' - 1 items.  `tail +0' is actually meaningless, but for Unix      compatibility it's treated the same as `tail +1'. */
if|if
condition|(
name|from_start
condition|)
block|{
if|if
condition|(
name|number
condition|)
operator|--
name|number
expr_stmt|;
block|}
if|if
condition|(
name|unit_size
operator|>
literal|1
condition|)
name|number
operator|*=
name|unit_size
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
operator|-
literal|1
operator|&&
name|forever
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot follow the ends of multiple files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_mode
operator|==
name|always
operator|||
operator|(
name|header_mode
operator|==
name|multiple_files
operator|&&
name|optind
operator|<
name|argc
operator|-
literal|1
operator|)
condition|)
name|print_headers
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|exit_status
operator||=
name|tail_file
argument_list|(
literal|"-"
argument_list|,
name|number
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
name|exit_status
operator||=
name|tail_file
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display the last NUMBER units of file FILENAME.    "-" for FILENAME means the standard input.    Return 0 if successful, 1 if an error occurred. */
end_comment

begin_function
name|int
name|tail_file
parameter_list|(
name|filename
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|filename
operator|=
literal|"standard input"
expr_stmt|;
if|if
condition|(
name|print_headers
condition|)
name|write_header
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|tail
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
name|number
argument_list|)
return|;
block|}
else|else
block|{
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|int
name|errors
decl_stmt|;
if|if
condition|(
name|print_headers
condition|)
name|write_header
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|errors
operator|=
name|tail
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|errors
return|;
block|}
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|void
name|write_header
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|static
name|int
name|first_file
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first_file
condition|)
block|{
name|xwrite
argument_list|(
literal|1
argument_list|,
literal|"==> "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|first_file
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|xwrite
argument_list|(
literal|1
argument_list|,
literal|"\n==> "
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|xwrite
argument_list|(
literal|1
argument_list|,
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|xwrite
argument_list|(
literal|1
argument_list|,
literal|"<==\n"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display the last NUMBER units of file FILENAME, open for reading    in FD.    Return 0 if successful, 1 if an error occurred. */
end_comment

begin_function
name|int
name|tail
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
if|if
condition|(
name|unit_size
condition|)
return|return
name|tail_bytes
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|)
return|;
else|else
return|return
name|tail_lines
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Display the last part of file FILENAME, open for reading in FD,    using NUMBER characters.    Return 0 if successful, 1 if an error occurred. */
end_comment

begin_function
name|int
name|tail_bytes
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
name|struct
name|stat
name|stats
decl_stmt|;
comment|/* Use fstat instead of checking for errno == ESPIPE because      lseek doesn't work on some special files but doesn't return an      error, either. */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|from_start
condition|)
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|number
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|start_bytes
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|)
condition|)
return|return
literal|1
return|;
name|dump_remainder
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_END
argument_list|)
operator|<=
name|number
condition|)
comment|/* The file is shorter than we want, or just the right size, so 	       print the whole file. */
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
else|else
comment|/* The file is longer than we want, so go back. */
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
name|number
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|dump_remainder
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|pipe_bytes
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Display the last part of file FILENAME, open for reading on FD,    using NUMBER lines.    Return 0 if successful, 1 if an error occurred. */
end_comment

begin_function
name|int
name|tail_lines
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
name|struct
name|stat
name|stats
decl_stmt|;
name|long
name|length
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|from_start
condition|)
block|{
if|if
condition|(
name|start_lines
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|)
condition|)
return|return
literal|1
return|;
name|dump_remainder
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|length
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0
operator|&&
name|file_lines
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|,
name|length
argument_list|)
condition|)
return|return
literal|1
return|;
name|dump_remainder
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|pipe_lines
argument_list|(
name|filename
argument_list|,
name|fd
argument_list|,
name|number
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print the last NUMBER lines from the end of file FD.    Go backward through the file, reading `BUFSIZE' bytes at a time (except    probably the first), until we hit the start of the file or have    read NUMBER newlines.    POS starts out as the length of the file (the offset of the last    byte of the file + 1).    Return 0 if successful, 1 if an error occurred. */
end_comment

begin_function
name|int
name|file_lines
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
name|long
name|pos
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Index into `buffer' for scanning. */
if|if
condition|(
name|number
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Set `bytes_read' to the size of the last, probably partial, buffer;      0< `bytes_read'<= `BUFSIZE'. */
name|bytes_read
operator|=
name|pos
operator|%
name|BUFSIZE
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
name|bytes_read
operator|=
name|BUFSIZE
expr_stmt|;
comment|/* Make `pos' a multiple of `BUFSIZE' (0 if the file is short), so that all      reads will be on block boundaries, which might increase efficiency. */
name|pos
operator|-=
name|bytes_read
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Count the incomplete line on files that don't end with a newline. */
if|if
condition|(
name|bytes_read
operator|&&
name|buffer
index|[
name|bytes_read
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|number
expr_stmt|;
do|do
block|{
comment|/* Scan backward, counting the newlines in this bufferfull. */
for|for
control|(
name|i
operator|=
name|bytes_read
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Have we counted the requested number of newlines yet? */
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
operator|&&
name|number
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* If this newline wasn't the last character in the buffer, 	         print the text after it. */
if|if
condition|(
name|i
operator|!=
name|bytes_read
operator|-
literal|1
condition|)
name|xwrite
argument_list|(
literal|1
argument_list|,
operator|&
name|buffer
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|bytes_read
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Not enough newlines in that bufferfull. */
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
comment|/* Not enough lines in the file; print the entire file. */
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pos
operator|-=
name|BUFSIZE
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print the last NUMBER lines from the end of the standard input,    open for reading as pipe FD.    Buffer the text as a linked list of LBUFFERs, adding them as needed.    Return 0 if successful, 1 if an error occured. */
end_comment

begin_function
name|int
name|pipe_lines
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
struct|struct
name|linebuffer
block|{
name|int
name|nbytes
decl_stmt|,
name|nlines
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|struct
name|linebuffer
modifier|*
name|next
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|linebuffer
name|LBUFFER
typedef|;
name|LBUFFER
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Index into buffers. */
name|int
name|total_lines
init|=
literal|0
decl_stmt|;
comment|/* Total number of newlines in all buffers. */
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|first
operator|=
name|last
operator|=
operator|(
name|LBUFFER
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|->
name|nbytes
operator|=
name|first
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|=
operator|(
name|LBUFFER
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LBUFFER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Input is always read into a fresh buffer. */
while|while
condition|(
operator|(
name|tmp
operator|->
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tmp
operator|->
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|tmp
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Count the number of newlines just read. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tmp
operator|->
name|nbytes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tmp
operator|->
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
operator|++
name|tmp
operator|->
name|nlines
expr_stmt|;
name|total_lines
operator|+=
name|tmp
operator|->
name|nlines
expr_stmt|;
comment|/* If there is enough room in the last buffer read, just append the new          one to it.  This is because when reading from a pipe, `nbytes' can          often be very small. */
if|if
condition|(
name|tmp
operator|->
name|nbytes
operator|+
name|last
operator|->
name|nbytes
operator|<
name|BUFSIZE
condition|)
block|{
name|bcopy
argument_list|(
name|tmp
operator|->
name|buffer
argument_list|,
operator|&
name|last
operator|->
name|buffer
index|[
name|last
operator|->
name|nbytes
index|]
argument_list|,
name|tmp
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|last
operator|->
name|nbytes
operator|+=
name|tmp
operator|->
name|nbytes
expr_stmt|;
name|last
operator|->
name|nlines
operator|+=
name|tmp
operator|->
name|nlines
expr_stmt|;
block|}
else|else
block|{
comment|/* If there's not enough room, link the new buffer onto the end of 	     the list, then either free up the oldest buffer for the next 	     read if that would leave enough lines, or else malloc a new one. 	     Some compaction mechanism is possible but probably not 	     worthwhile. */
name|last
operator|=
name|last
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|total_lines
operator|-
name|first
operator|->
name|nlines
operator|>
name|number
condition|)
block|{
name|tmp
operator|=
name|first
expr_stmt|;
name|total_lines
operator|-=
name|first
operator|->
name|nlines
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|next
expr_stmt|;
block|}
else|else
name|tmp
operator|=
operator|(
name|LBUFFER
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LBUFFER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmp
operator|->
name|nbytes
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|free_lbuffers
goto|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
comment|/* This prevents a core dump when the pipe contains no newlines. */
if|if
condition|(
name|number
operator|==
literal|0
condition|)
goto|goto
name|free_lbuffers
goto|;
comment|/* Count the incomplete line on files that don't end with a newline. */
if|if
condition|(
name|last
operator|->
name|buffer
index|[
name|last
operator|->
name|nbytes
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|++
name|last
operator|->
name|nlines
expr_stmt|;
operator|++
name|total_lines
expr_stmt|;
block|}
comment|/* Run through the list, printing lines.  First, skip over unneeded      buffers. */
for|for
control|(
name|tmp
operator|=
name|first
init|;
name|total_lines
operator|-
name|tmp
operator|->
name|nlines
operator|>
name|number
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
name|total_lines
operator|-=
name|tmp
operator|->
name|nlines
expr_stmt|;
comment|/* Find the correct beginning, then print the rest of the file. */
if|if
condition|(
name|total_lines
operator|>
name|number
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Skip `total_lines' - `number' newlines.  We made sure that          `total_lines' - `number'<= `tmp->nlines'. */
name|cp
operator|=
name|tmp
operator|->
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
name|total_lines
operator|-
name|number
init|;
name|i
condition|;
operator|--
name|i
control|)
while|while
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\n'
condition|)
comment|/* Do nothing. */
empty_stmt|;
name|i
operator|=
name|cp
operator|-
name|tmp
operator|->
name|buffer
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|xwrite
argument_list|(
literal|1
argument_list|,
operator|&
name|tmp
operator|->
name|buffer
index|[
name|i
index|]
argument_list|,
name|tmp
operator|->
name|nbytes
operator|-
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|tmp
operator|->
name|next
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
name|xwrite
argument_list|(
literal|1
argument_list|,
name|tmp
operator|->
name|buffer
argument_list|,
name|tmp
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|free_lbuffers
label|:
while|while
condition|(
name|first
condition|)
block|{
name|tmp
operator|=
name|first
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|errors
return|;
block|}
end_function

begin_comment
comment|/* Print the last NUMBER characters from the end of pipe FD.    This is a stripped down version of pipe_lines.    Return 0 if successful, 1 if an error occurred. */
end_comment

begin_function
name|int
name|pipe_bytes
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
struct|struct
name|charbuffer
block|{
name|int
name|nbytes
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|struct
name|charbuffer
modifier|*
name|next
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|charbuffer
name|CBUFFER
typedef|;
name|CBUFFER
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Index into buffers. */
name|int
name|total_bytes
init|=
literal|0
decl_stmt|;
comment|/* Total characters in all buffers. */
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|first
operator|=
name|last
operator|=
operator|(
name|CBUFFER
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|->
name|nbytes
operator|=
literal|0
expr_stmt|;
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|=
operator|(
name|CBUFFER
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CBUFFER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Input is always read into a fresh buffer. */
while|while
condition|(
operator|(
name|tmp
operator|->
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tmp
operator|->
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|total_bytes
operator|+=
name|tmp
operator|->
name|nbytes
expr_stmt|;
comment|/* If there is enough room in the last buffer read, just append the new          one to it.  This is because when reading from a pipe, `nbytes' can          often be very small. */
if|if
condition|(
name|tmp
operator|->
name|nbytes
operator|+
name|last
operator|->
name|nbytes
operator|<
name|BUFSIZE
condition|)
block|{
name|bcopy
argument_list|(
name|tmp
operator|->
name|buffer
argument_list|,
operator|&
name|last
operator|->
name|buffer
index|[
name|last
operator|->
name|nbytes
index|]
argument_list|,
name|tmp
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|last
operator|->
name|nbytes
operator|+=
name|tmp
operator|->
name|nbytes
expr_stmt|;
block|}
else|else
block|{
comment|/* If there's not enough room, link the new buffer onto the end of 	     the list, then either free up the oldest buffer for the next 	     read if that would leave enough characters, or else malloc a new 	     one.  Some compaction mechanism is possible but probably not 	     worthwhile. */
name|last
operator|=
name|last
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|total_bytes
operator|-
name|first
operator|->
name|nbytes
operator|>
name|number
condition|)
block|{
name|tmp
operator|=
name|first
expr_stmt|;
name|total_bytes
operator|-=
name|first
operator|->
name|nbytes
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
operator|(
name|CBUFFER
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CBUFFER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tmp
operator|->
name|nbytes
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|free_cbuffers
goto|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
comment|/* Run through the list, printing characters.  First, skip over unneeded      buffers. */
for|for
control|(
name|tmp
operator|=
name|first
init|;
name|total_bytes
operator|-
name|tmp
operator|->
name|nbytes
operator|>
name|number
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
name|total_bytes
operator|-=
name|tmp
operator|->
name|nbytes
expr_stmt|;
comment|/* Find the correct beginning, then print the rest of the file.      We made sure that `total_bytes' - `number'<= `tmp->nbytes'. */
if|if
condition|(
name|total_bytes
operator|>
name|number
condition|)
name|i
operator|=
name|total_bytes
operator|-
name|number
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|xwrite
argument_list|(
literal|1
argument_list|,
operator|&
name|tmp
operator|->
name|buffer
index|[
name|i
index|]
argument_list|,
name|tmp
operator|->
name|nbytes
operator|-
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|tmp
operator|->
name|next
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
name|xwrite
argument_list|(
literal|1
argument_list|,
name|tmp
operator|->
name|buffer
argument_list|,
name|tmp
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|free_cbuffers
label|:
while|while
condition|(
name|first
condition|)
block|{
name|tmp
operator|=
name|first
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|errors
return|;
block|}
end_function

begin_comment
comment|/* Skip NUMBER characters from the start of pipe FD, and print    any extra characters that were read beyond that.    Return 1 on error, 0 if ok.  */
end_comment

begin_function
name|int
name|start_bytes
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|int
name|bytes_read
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|number
operator|>
literal|0
operator|&&
operator|(
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|number
operator|-=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|number
operator|<
literal|0
condition|)
name|xwrite
argument_list|(
literal|1
argument_list|,
operator|&
name|buffer
index|[
name|bytes_read
operator|+
name|number
index|]
argument_list|,
operator|-
name|number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Skip NUMBER lines at the start of file or pipe FD, and print    any extra characters that were read beyond that.    Return 1 on error, 0 if ok.  */
end_comment

begin_function
name|int
name|start_lines
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|,
name|number
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|long
name|number
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|int
name|bytes_read
init|=
literal|0
decl_stmt|;
name|int
name|bytes_to_skip
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|number
operator|&&
operator|(
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bytes_to_skip
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bytes_to_skip
operator|<
name|bytes_read
condition|)
if|if
condition|(
name|buffer
index|[
name|bytes_to_skip
operator|++
index|]
operator|==
literal|'\n'
operator|&&
operator|--
name|number
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bytes_to_skip
operator|<
name|bytes_read
condition|)
name|xwrite
argument_list|(
literal|1
argument_list|,
operator|&
name|buffer
index|[
name|bytes_to_skip
index|]
argument_list|,
name|bytes_read
operator|-
name|bytes_to_skip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Display file FILENAME from the current position in FD    to the end.  If `forever' is nonzero, keep reading from the    end of the file until killed. */
end_comment

begin_function
name|void
name|dump_remainder
parameter_list|(
name|filename
parameter_list|,
name|fd
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|output
label|:
while|while
condition|(
operator|(
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|xwrite
argument_list|(
literal|1
argument_list|,
name|buffer
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|forever
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|output
goto|;
block|}
block|}
end_function

begin_function
name|void
name|parse_unit
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|arglen
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|arglen
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|str
index|[
name|arglen
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|unit_size
operator|=
literal|512
expr_stmt|;
name|str
index|[
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|unit_size
operator|=
literal|1024
expr_stmt|;
name|str
index|[
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|unit_size
operator|=
literal|1048576
expr_stmt|;
name|str
index|[
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Convert STR, a string of ASCII digits, into an unsigned integer.    Return -1 if STR does not represent a valid unsigned integer. */
end_comment

begin_function
name|long
name|atou
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|unsigned
name|long
name|value
decl_stmt|;
for|for
control|(
name|value
operator|=
literal|0
init|;
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|;
operator|++
name|str
control|)
name|value
operator|=
name|value
operator|*
literal|10
operator|+
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
return|return
operator|*
name|str
condition|?
operator|-
literal|1
else|:
name|value
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-c [+]N[bkm]] [-n [+]N] [-fqv] [--bytes=[+]N[bkm]] [--lines=[+]N]\n\        [--follow] [--quiet] [--silent] [--verbose] [file...]\n\        %s [{-,+}Nbcfklmqv] [file...]\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

