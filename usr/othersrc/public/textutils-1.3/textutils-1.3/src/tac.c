begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tac - concatenate and print files in reverse    Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by Jay Lepreau (lepreau@cs.utah.edu).    GNU enhancements by David MacKenzie (djm@ai.mit.edu). */
end_comment

begin_comment
comment|/* Copy each FILE, or the standard input if none are given or when a    FILE name of "-" is encountered, to the standard output with the    order of the records reversed.  The records are separated by    instances of a string, or a newline if none is given.  By default, the    separator string is attached to the end of the record that it    follows in the file.     Options:    -b, --before			The separator is attached to the beginning 				of the record that it precedes in the file.    -r, --regex			The separator is a regular expression.    -s, --separator=separator	Use SEPARATOR as the record separator.     To reverse a file byte by byte, use (in bash, ksh, or sh): tac -r -s '.\| ' file */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_undef
undef|#
directive|undef
name|RE_DUP_MAX
end_undef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_comment
comment|/* XXX need to resolve the conflict in RE_DUP_MAX definitions. */
end_comment

begin_undef
undef|#
directive|undef
name|RE_DUP_MAX
end_undef

begin_define
define|#
directive|define
name|RE_DUP_MAX
value|((1<< 15) - 1)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  __386BSD__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of bytes per atomic read. */
end_comment

begin_define
define|#
directive|define
name|INITIAL_READSIZE
value|8192
end_define

begin_comment
comment|/* The number of bytes per atomic write. */
end_comment

begin_define
define|#
directive|define
name|WRITESIZE
value|8192
end_define

begin_function_decl
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|SIGTYPE
name|cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tac
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tac_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tac_stdin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|save_stdin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|xwrite
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string that separates the records of the file. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|separator
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, print `separator' along with the record preceding it    in the file; otherwise with the record following it. */
end_comment

begin_decl_stmt
name|int
name|separator_ends_record
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 if `separator' is to be matched as a regular expression;    otherwise, the length of `separator', used as a sentinel to    stop the search. */
end_comment

begin_decl_stmt
name|int
name|sentinel_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The length of a match with `separator'.  If `sentinel_length' is 0,    `match_length' is computed every time a match succeeds;    otherwise, it is simply the length of `separator'. */
end_comment

begin_decl_stmt
name|int
name|match_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The input buffer. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of bytes to read at once into `buffer'. */
end_comment

begin_decl_stmt
name|unsigned
name|read_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of `buffer'.  This is read_size * 2 + sentinel_length + 2.    The extra 2 bytes allow `past_end' to have a value beyond the    end of `buffer' and `match_start' to run off the front of `buffer'. */
end_comment

begin_decl_stmt
name|unsigned
name|buffer_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiled regular expression representing `separator'. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|compiled_separator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"before"
block|,
literal|0
block|,
operator|&
name|separator_ends_record
block|,
literal|0
block|}
block|,
block|{
literal|"regex"
block|,
literal|0
block|,
operator|&
name|sentinel_length
block|,
literal|0
block|}
block|,
block|{
literal|"separator"
block|,
literal|1
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|error_message
decl_stmt|;
comment|/* Return value from re_compile_pattern. */
name|int
name|optc
decl_stmt|,
name|errors
decl_stmt|;
name|int
name|have_read_stdin
init|=
literal|0
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|separator
operator|=
literal|"\n"
expr_stmt|;
name|sentinel_length
operator|=
literal|1
expr_stmt|;
name|separator_ends_record
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"brs:"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'b'
case|:
name|separator_ends_record
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|sentinel_length
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|separator
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
operator|*
name|separator
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"separator cannot be empty"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-br] [-s separator] [--before] [--regex] [--separator=separator]\n\        [file...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sentinel_length
operator|==
literal|0
condition|)
block|{
name|compiled_separator
operator|.
name|allocated
operator|=
literal|100
expr_stmt|;
name|compiled_separator
operator|.
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|compiled_separator
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|compiled_separator
operator|.
name|fastmap
operator|=
name|xmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|compiled_separator
operator|.
name|translate
operator|=
literal|0
expr_stmt|;
name|error_message
operator|=
name|re_compile_pattern
argument_list|(
name|separator
argument_list|,
name|strlen
argument_list|(
name|separator
argument_list|)
argument_list|,
operator|&
name|compiled_separator
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_message
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
block|}
else|else
name|match_length
operator|=
name|sentinel_length
operator|=
name|strlen
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|read_size
operator|=
name|INITIAL_READSIZE
expr_stmt|;
comment|/* A precaution that will probably never be needed. */
while|while
condition|(
name|sentinel_length
operator|*
literal|2
operator|>=
name|read_size
condition|)
name|read_size
operator|*=
literal|2
expr_stmt|;
name|buffer_size
operator|=
name|read_size
operator|*
literal|2
operator|+
name|sentinel_length
operator|+
literal|2
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentinel_length
condition|)
block|{
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|separator
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|sentinel_length
expr_stmt|;
block|}
else|else
operator|++
name|buffer
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|errors
operator|=
name|tac_stdin
argument_list|()
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|errors
operator||=
name|tac_stdin
argument_list|()
expr_stmt|;
block|}
else|else
name|errors
operator||=
name|tac_file
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Flush the output buffer. */
name|output
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The name of a temporary file containing a copy of pipe input. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tempfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the standard input in reverse, saving it to temporary    file `tempfile' first if it is a pipe.    Return 0 if ok, 1 if an error occurs. */
end_comment

begin_function
name|int
name|tac_stdin
parameter_list|()
block|{
comment|/* Previous values of signal handlers. */
name|SIGTYPE
argument_list|(
operator|*
name|sigint
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|sighup
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|sigterm
argument_list|)
argument_list|()
decl_stmt|;
name|int
name|errors
decl_stmt|;
name|struct
name|stat
name|stats
decl_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|struct
name|sigaction
name|oldact
decl_stmt|,
name|newact
decl_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VERSION */
comment|/* No tempfile is needed for "tac< file".      Use fstat instead of checking for errno == ESPIPE because      lseek doesn't work on some special files but doesn't return an      error, either. */
if|if
condition|(
name|fstat
argument_list|(
literal|0
argument_list|,
operator|&
name|stats
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|tac
argument_list|(
literal|0
argument_list|,
literal|"standard input"
argument_list|)
return|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|newact
operator|.
name|sa_handler
operator|=
name|cleanup
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|newact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
name|sigint
operator|=
name|oldact
operator|.
name|sa_handler
expr_stmt|;
if|if
condition|(
name|sigint
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
name|sighup
operator|=
name|oldact
operator|.
name|sa_handler
expr_stmt|;
if|if
condition|(
name|sighup
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
name|sigterm
operator|=
name|oldact
operator|.
name|sa_handler
expr_stmt|;
if|if
condition|(
name|sigterm
operator|!=
name|SIG_IGN
condition|)
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_POSIX_VERSION */
name|sigint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigint
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|sighup
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sighup
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|sigterm
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigterm
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VERSION */
name|save_stdin
argument_list|()
expr_stmt|;
name|errors
operator|=
name|tac_file
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|newact
operator|.
name|sa_handler
operator|=
name|sigint
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_handler
operator|=
name|sighup
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_handler
operator|=
name|sigterm
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|newact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !_POSIX_VERSION */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _POSIX_VERSION */
return|return
name|errors
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of the standard input in `tempfile'. */
end_comment

begin_function
name|void
name|save_stdin
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|template
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|tempdir
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
if|if
condition|(
name|template
operator|==
name|NULL
condition|)
block|{
name|tempdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempdir
operator|==
name|NULL
condition|)
name|tempdir
operator|=
literal|"/tmp"
expr_stmt|;
name|template
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tempdir
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|template
argument_list|,
literal|"%s/tacXXXXXX"
argument_list|,
name|tempdir
argument_list|)
expr_stmt|;
name|tempfile
operator|=
name|mktemp
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|fd
operator|=
name|creat
argument_list|(
name|tempfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|bytes_read
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buffer
argument_list|,
name|read_size
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|bytes_read
argument_list|)
operator|!=
name|bytes_read
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print FILE in reverse.    Return 0 if ok, 1 if an error occurs. */
end_comment

begin_function
name|int
name|tac_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|errors
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|errors
operator|=
name|tac
argument_list|(
name|fd
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|errors
return|;
block|}
end_function

begin_comment
comment|/* Print in reverse the file open on descriptor FD for reading FILE.    Return 0 if ok, 1 if an error occurs. */
end_comment

begin_function
name|int
name|tac
parameter_list|(
name|fd
parameter_list|,
name|file
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
comment|/* Pointer to the location in `buffer' where the search for      the next separator will begin. */
name|char
modifier|*
name|match_start
decl_stmt|;
comment|/* Pointer to one past the rightmost character in `buffer' that      has not been printed yet. */
name|char
modifier|*
name|past_end
decl_stmt|;
name|unsigned
name|saved_record_size
decl_stmt|;
comment|/* Length of the record growing in `buffer'. */
name|off_t
name|file_pos
decl_stmt|;
comment|/* Offset in the file of the next read. */
comment|/* Nonzero if `output' has not been called yet for any file.      Only used when the separator is attached to the preceding record. */
name|int
name|first_time
init|=
literal|1
decl_stmt|;
name|char
name|first_char
init|=
operator|*
name|separator
decl_stmt|;
comment|/* Speed optimization, non-regexp. */
name|char
modifier|*
name|separator1
init|=
name|separator
operator|+
literal|1
decl_stmt|;
comment|/* Speed optimization, non-regexp. */
name|int
name|match_length1
init|=
name|match_length
operator|-
literal|1
decl_stmt|;
comment|/* Speed optimization, non-regexp. */
name|struct
name|re_registers
name|regs
decl_stmt|;
comment|/* Find the size of the input file. */
name|file_pos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_pos
operator|<
literal|1
condition|)
return|return
literal|0
return|;
comment|/* It's an empty file. */
comment|/* Arrange for the first read to lop off enough to leave the rest of the      file a multiple of `read_size'.  Since `read_size' can change, this may      not always hold during the program run, but since it usually will, leave      it here for i/o efficiency (page/sector boundaries and all that).      Note: the efficiency gain has not been verified. */
name|saved_record_size
operator|=
name|file_pos
operator|%
name|read_size
expr_stmt|;
if|if
condition|(
name|saved_record_size
operator|==
literal|0
condition|)
name|saved_record_size
operator|=
name|read_size
expr_stmt|;
name|file_pos
operator|-=
name|saved_record_size
expr_stmt|;
comment|/* `file_pos' now points to the start of the last (probably partial) block      in the input file. */
name|lseek
argument_list|(
name|fd
argument_list|,
name|file_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|saved_record_size
argument_list|)
operator|!=
name|saved_record_size
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|match_start
operator|=
name|past_end
operator|=
name|buffer
operator|+
name|saved_record_size
expr_stmt|;
comment|/* For non-regexp search, move past impossible positions for a match. */
if|if
condition|(
name|sentinel_length
condition|)
name|match_start
operator|-=
name|match_length1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Search backward from `match_start' - 1 to `buffer' for a match 	 with `separator'; for speed, use strncmp if `separator' contains no 	 metacharacters. 	 If the match succeeds, set `match_start' to point to the start of 	 the match and `match_length' to the length of the match. 	 Otherwise, make `match_start'< `buffer'. */
if|if
condition|(
name|sentinel_length
operator|==
literal|0
condition|)
block|{
name|int
name|i
init|=
name|match_start
operator|-
name|buffer
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|re_search
argument_list|(
operator|&
name|compiled_separator
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|,
operator|-
name|i
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|match_start
operator|=
name|buffer
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"error in regular expression search"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|match_start
operator|=
name|buffer
operator|+
name|regs
operator|.
name|start
index|[
literal|0
index|]
expr_stmt|;
name|match_length
operator|=
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|regs
operator|.
name|start
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* `match_length' is constant for non-regexp boundaries. */
while|while
condition|(
operator|*
operator|--
name|match_start
operator|!=
name|first_char
operator|||
operator|(
name|match_length1
operator|&&
name|strncmp
argument_list|(
name|match_start
operator|+
literal|1
argument_list|,
name|separator1
argument_list|,
name|match_length1
argument_list|)
operator|)
condition|)
comment|/* Do nothing. */
empty_stmt|;
block|}
comment|/* Check whether we backed off the front of `buffer' without finding          a match for `separator'. */
if|if
condition|(
name|match_start
operator|<
name|buffer
condition|)
block|{
if|if
condition|(
name|file_pos
operator|==
literal|0
condition|)
block|{
comment|/* Hit the beginning of the file; print the remaining record. */
name|output
argument_list|(
name|buffer
argument_list|,
name|past_end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|saved_record_size
operator|=
name|past_end
operator|-
name|buffer
expr_stmt|;
if|if
condition|(
name|saved_record_size
operator|>
name|read_size
condition|)
block|{
comment|/* `buffer_size' is about twice `read_size', so since 		 we want to read in another `read_size' bytes before 		 the data already in `buffer', we need to increase 		 `buffer_size'. */
name|char
modifier|*
name|newbuffer
decl_stmt|;
name|int
name|offset
init|=
name|sentinel_length
condition|?
name|sentinel_length
else|:
literal|1
decl_stmt|;
name|read_size
operator|*=
literal|2
expr_stmt|;
name|buffer_size
operator|=
name|read_size
operator|*
literal|2
operator|+
name|sentinel_length
operator|+
literal|2
expr_stmt|;
name|newbuffer
operator|=
name|xrealloc
argument_list|(
name|buffer
operator|-
name|offset
argument_list|,
name|buffer_size
argument_list|)
operator|+
name|offset
expr_stmt|;
comment|/* Adjust the pointers for the new buffer location.  */
name|match_start
operator|+=
name|newbuffer
operator|-
name|buffer
expr_stmt|;
name|past_end
operator|+=
name|newbuffer
operator|-
name|buffer
expr_stmt|;
name|buffer
operator|=
name|newbuffer
expr_stmt|;
block|}
comment|/* Back up to the start of the next bufferfull of the file.  */
if|if
condition|(
name|file_pos
operator|>=
name|read_size
condition|)
name|file_pos
operator|-=
name|read_size
expr_stmt|;
else|else
block|{
name|read_size
operator|=
name|file_pos
expr_stmt|;
name|file_pos
operator|=
literal|0
expr_stmt|;
block|}
name|lseek
argument_list|(
name|fd
argument_list|,
name|file_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* Shift the pending record data right to make room for the new. */
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|+
name|read_size
argument_list|,
name|saved_record_size
argument_list|)
expr_stmt|;
name|past_end
operator|=
name|buffer
operator|+
name|read_size
operator|+
name|saved_record_size
expr_stmt|;
comment|/* For non-regexp searches, avoid unneccessary scanning. */
if|if
condition|(
name|sentinel_length
condition|)
name|match_start
operator|=
name|buffer
operator|+
name|read_size
expr_stmt|;
else|else
name|match_start
operator|=
name|past_end
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|read_size
argument_list|)
operator|!=
name|read_size
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* Found a match of `separator'. */
if|if
condition|(
name|separator_ends_record
condition|)
block|{
name|char
modifier|*
name|match_end
init|=
name|match_start
operator|+
name|match_length
decl_stmt|;
comment|/* If this match of `separator' isn't at the end of the 	         file, print the record. */
if|if
condition|(
name|first_time
operator|==
literal|0
operator|||
name|match_end
operator|!=
name|past_end
condition|)
name|output
argument_list|(
name|match_end
argument_list|,
name|past_end
argument_list|)
expr_stmt|;
name|past_end
operator|=
name|match_end
expr_stmt|;
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|match_start
argument_list|,
name|past_end
argument_list|)
expr_stmt|;
name|past_end
operator|=
name|match_start
expr_stmt|;
block|}
name|match_start
operator|-=
name|match_length
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print the characters from START to PAST_END - 1.    If START is NULL, just flush the buffer. */
end_comment

begin_function
name|void
name|output
parameter_list|(
name|start
parameter_list|,
name|past_end
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|past_end
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|WRITESIZE
index|]
decl_stmt|;
specifier|static
name|int
name|bytes_in_buffer
init|=
literal|0
decl_stmt|;
name|int
name|bytes_to_add
init|=
name|past_end
operator|-
name|start
decl_stmt|;
name|int
name|bytes_available
init|=
name|WRITESIZE
operator|-
name|bytes_in_buffer
decl_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
condition|)
block|{
name|xwrite
argument_list|(
literal|1
argument_list|,
name|buffer
argument_list|,
name|bytes_in_buffer
argument_list|)
expr_stmt|;
name|bytes_in_buffer
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Write out as many full buffers as possible. */
while|while
condition|(
name|bytes_to_add
operator|>=
name|bytes_available
condition|)
block|{
name|bcopy
argument_list|(
name|start
argument_list|,
name|buffer
operator|+
name|bytes_in_buffer
argument_list|,
name|bytes_available
argument_list|)
expr_stmt|;
name|bytes_to_add
operator|-=
name|bytes_available
expr_stmt|;
name|start
operator|+=
name|bytes_available
expr_stmt|;
name|xwrite
argument_list|(
literal|1
argument_list|,
name|buffer
argument_list|,
name|WRITESIZE
argument_list|)
expr_stmt|;
name|bytes_in_buffer
operator|=
literal|0
expr_stmt|;
name|bytes_available
operator|=
name|WRITESIZE
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|start
argument_list|,
name|buffer
operator|+
name|bytes_in_buffer
argument_list|,
name|bytes_to_add
argument_list|)
expr_stmt|;
name|bytes_in_buffer
operator|+=
name|bytes_to_add
expr_stmt|;
block|}
end_function

begin_function
name|SIGTYPE
name|cleanup
parameter_list|()
block|{
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xwrite
parameter_list|(
name|desc
parameter_list|,
name|buffer
parameter_list|,
name|size
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|write
argument_list|(
name|desc
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate N bytes of memory dynamically, with error checking.  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Change the size of memory area P to N bytes, with error checking. */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

end_unit

