begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cmp -- compare two files.    Copyright (C) 1988, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Differences from the Unix cmp:    * 6 - 40 - oo times faster.    * The file name `-' is always the standard input. If one file name      is omitted, the standard input is used as well.    * -c option to print the differing characters like `cat -t'      (except that newlines are printed as `^J'), with or without -l.     By Torbjorn Granlund and David MacKenzie. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|h
parameter_list|,
name|i
parameter_list|)
value|((h)> (i) ? (h) : (i))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|l
parameter_list|,
name|o
parameter_list|)
value|((l)< (o) ? (l) : (o))
end_define

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bcmp_cnt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bcmp2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bread
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|printc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filenames of the compared files.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|file1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptors of the files.  */
end_comment

begin_decl_stmt
name|int
name|file1_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|file2_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read buffers for the files.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buf1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optimal block size for the files.  */
end_comment

begin_decl_stmt
name|int
name|buf_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output format:    type_first_diff      to print the offset and line number of the first differing bytes    type_all_diffs      to print the (decimal) offsets and (octal) values of all differing bytes    type_status      to only return an exit status indicating whether the files differ */
end_comment

begin_enum
enum|enum
block|{
name|type_first_diff
block|,
name|type_all_diffs
block|,
name|type_status
block|}
name|comparison_type
init|=
name|type_first_diff
enum|;
end_enum

begin_comment
comment|/* If nonzero, print values of bytes quoted like cat -t does. */
end_comment

begin_decl_stmt
name|int
name|opt_print_chars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"show-chars"
block|,
literal|0
block|,
operator|&
name|opt_print_chars
block|,
literal|1
block|}
block|,
block|{
literal|"silent"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|usage
parameter_list|(
name|reason
parameter_list|)
name|char
modifier|*
name|reason
decl_stmt|;
block|{
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-cls] [--show-chars] [--verbose] [--silent] [--quiet]\n\        file1 [file2]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|opened
init|=
literal|0
decl_stmt|,
name|exit_status
decl_stmt|;
name|struct
name|stat
name|stat_buf1
decl_stmt|,
name|stat_buf2
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* If an argument is omitted, default to the standard input.  */
name|file1
operator|=
literal|"-"
expr_stmt|;
name|file2
operator|=
literal|"-"
expr_stmt|;
name|file1_desc
operator|=
literal|0
expr_stmt|;
name|file2_desc
operator|=
literal|0
expr_stmt|;
comment|/* Parse command line options.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cls"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'c'
case|:
name|opt_print_chars
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|comparison_type
operator|=
name|type_all_diffs
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|comparison_type
operator|=
name|type_status
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|file1
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|file2
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|usage
argument_list|(
literal|"extra arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file1
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|opened
operator|=
literal|1
expr_stmt|;
name|file1_desc
operator|=
name|open
argument_list|(
name|file1
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|file1_desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|comparison_type
operator|==
name|type_status
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|file2
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|opened
operator|=
literal|1
expr_stmt|;
name|file2_desc
operator|=
name|open
argument_list|(
name|file2
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|file2_desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|comparison_type
operator|==
name|type_status
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|file1_desc
operator|==
name|file2_desc
condition|)
block|{
if|if
condition|(
name|opened
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"standard input is closed"
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|(
literal|"at least one filename should be specified"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|file1_desc
argument_list|,
operator|&
name|stat_buf1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|file2_desc
argument_list|,
operator|&
name|stat_buf2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* If both the input descriptors are associated with plain files,      we can make the job simpler in some cases.  */
if|if
condition|(
name|S_ISREG
argument_list|(
name|stat_buf1
operator|.
name|st_mode
argument_list|)
operator|&&
name|S_ISREG
argument_list|(
name|stat_buf2
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Find out if the files are links to the same inode, and therefore 	 identical.  */
if|if
condition|(
name|stat_buf1
operator|.
name|st_dev
operator|==
name|stat_buf2
operator|.
name|st_dev
operator|&&
name|stat_buf1
operator|.
name|st_ino
operator|==
name|stat_buf2
operator|.
name|st_ino
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If output is redirected to "/dev/null", we may assume `-s'.  */
if|if
condition|(
name|comparison_type
operator|!=
name|type_status
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|dev_t
name|nulldev
decl_stmt|;
name|ino_t
name|nullino
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/dev/null"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nulldev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|nullino
operator|=
name|sb
operator|.
name|st_ino
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
literal|1
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
name|sb
operator|.
name|st_dev
operator|==
name|nulldev
operator|&&
name|sb
operator|.
name|st_ino
operator|==
name|nullino
condition|)
name|comparison_type
operator|=
name|type_status
expr_stmt|;
block|}
block|}
comment|/* If only a return code is needed, conclude that 	 the files differ if they have different sizes.  */
if|if
condition|(
name|comparison_type
operator|==
name|type_status
operator|&&
name|stat_buf1
operator|.
name|st_size
operator|!=
name|stat_buf2
operator|.
name|st_size
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the optimal block size of the files.  */
name|buf_size
operator|=
name|max
argument_list|(
name|ST_BLKSIZE
argument_list|(
name|stat_buf1
argument_list|)
argument_list|,
name|ST_BLKSIZE
argument_list|(
name|stat_buf2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate buffers, with space for sentinels at the end.  */
name|buf1
operator|=
name|xmalloc
argument_list|(
name|buf_size
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|xmalloc
argument_list|(
name|buf_size
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|exit_status
operator|=
name|cmp
argument_list|()
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|file1_desc
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|file2_desc
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|comparison_type
operator|!=
name|type_status
operator|&&
operator|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
operator|)
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare the two files already open on `file1_desc' and `file2_desc',    using `buf1' and `buf2'.    Return 0 if identical, 1 if different,>1 if error. */
end_comment

begin_function
name|int
name|cmp
parameter_list|()
block|{
name|long
name|line_number
init|=
literal|1
decl_stmt|;
comment|/* Line number (1...) of first difference. */
name|long
name|char_number
init|=
literal|1
decl_stmt|;
comment|/* Offset (1...) in files of 1st difference. */
name|int
name|read1
decl_stmt|,
name|read2
decl_stmt|;
comment|/* Number of bytes read from each file. */
name|int
name|first_diff
decl_stmt|;
comment|/* Offset (0...) in buffers of 1st diff. */
name|int
name|smaller
decl_stmt|;
comment|/* The lesser of `read1' and `read2'. */
name|int
name|ret
init|=
literal|0
decl_stmt|;
do|do
block|{
name|read1
operator|=
name|bread
argument_list|(
name|file1_desc
argument_list|,
name|buf1
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read1
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|read2
operator|=
name|bread
argument_list|(
name|file2_desc
argument_list|,
name|buf2
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read2
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* Insert sentinels for the block compare.  */
name|buf1
index|[
name|read1
index|]
operator|=
operator|~
name|buf2
index|[
name|read1
index|]
expr_stmt|;
name|buf2
index|[
name|read2
index|]
operator|=
operator|~
name|buf1
index|[
name|read2
index|]
expr_stmt|;
if|if
condition|(
name|comparison_type
operator|==
name|type_first_diff
condition|)
block|{
name|int
name|cnt
decl_stmt|;
comment|/* If the line number should be written for differing files, 	     compare the blocks and count the number of newlines 	     simultaneously.  */
name|first_diff
operator|=
name|bcmp_cnt
argument_list|(
operator|&
name|cnt
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|line_number
operator|+=
name|cnt
expr_stmt|;
block|}
else|else
block|{
name|first_diff
operator|=
name|bcmp2
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comparison_type
operator|!=
name|type_all_diffs
condition|)
name|char_number
operator|+=
name|first_diff
expr_stmt|;
else|else
name|smaller
operator|=
name|min
argument_list|(
name|read1
argument_list|,
name|read2
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_diff
operator|<
name|read1
operator|&&
name|first_diff
operator|<
name|read2
condition|)
block|{
switch|switch
condition|(
name|comparison_type
condition|)
block|{
case|case
name|type_first_diff
case|:
comment|/* This format is a proposed POSIX standard.  */
name|printf
argument_list|(
literal|"%s %s differ: char %ld, line %ld"
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|,
name|char_number
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_print_chars
condition|)
block|{
name|printf
argument_list|(
literal|" is"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3o "
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3o "
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf2
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf2
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Fall through. */
case|case
name|type_status
case|:
return|return
literal|1
return|;
case|case
name|type_all_diffs
case|:
while|while
condition|(
name|first_diff
operator|<
name|smaller
condition|)
block|{
if|if
condition|(
name|buf1
index|[
name|first_diff
index|]
operator|!=
name|buf2
index|[
name|first_diff
index|]
condition|)
block|{
if|if
condition|(
name|opt_print_chars
condition|)
block|{
name|printf
argument_list|(
literal|"%6ld"
argument_list|,
name|first_diff
operator|+
name|char_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3o "
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|stdout
argument_list|,
literal|4
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3o "
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf2
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
name|printc
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf2
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This format is a proposed POSIX standard. */
name|printf
argument_list|(
literal|"%6ld %3o %3o\n"
argument_list|,
name|first_diff
operator|+
name|char_number
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf1
index|[
name|first_diff
index|]
argument_list|,
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|char
operator|)
name|buf2
index|[
name|first_diff
index|]
argument_list|)
expr_stmt|;
block|}
name|first_diff
operator|++
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|comparison_type
operator|==
name|type_all_diffs
condition|)
name|char_number
operator|+=
name|smaller
expr_stmt|;
if|if
condition|(
name|read1
operator|!=
name|read2
condition|)
block|{
switch|switch
condition|(
name|comparison_type
condition|)
block|{
case|case
name|type_first_diff
case|:
case|case
name|type_all_diffs
case|:
comment|/* This format is a proposed POSIX standard. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: EOF on %s\n"
argument_list|,
name|program_name
argument_list|,
name|read1
operator|<
name|read2
condition|?
name|file1
else|:
name|file2
argument_list|)
expr_stmt|;
break|break;
case|case
name|type_status
case|:
break|break;
block|}
return|return
literal|1
return|;
block|}
block|}
do|while
condition|(
name|read1
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two blocks of memory P1 and P2 until they differ,    and count the number of occurences of the character C in the common    part of P1 and P2.    Assumes that P1 and P2 are aligned at long addresses!    If the blocks are not guaranteed to be different, put sentinels at the ends    of the blocks before calling this function.    Return the offset of the first byte that differs.    Place the count at the address pointed to by COUNT.  */
end_comment

begin_function
name|int
name|bcmp_cnt
parameter_list|(
name|count
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|c
parameter_list|)
name|int
modifier|*
name|count
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|w
decl_stmt|;
comment|/* Word for counting C. */
name|long
name|i1
decl_stmt|,
name|i2
decl_stmt|;
comment|/* One word from each buffer to compare. */
name|long
modifier|*
name|p1i
decl_stmt|,
modifier|*
name|p2i
decl_stmt|;
comment|/* Pointers into each buffer. */
name|char
modifier|*
name|p1c
decl_stmt|,
modifier|*
name|p2c
decl_stmt|;
comment|/* Pointers for finding exact address. */
name|unsigned
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Number of occurrences of C. */
name|long
name|cccc
decl_stmt|;
comment|/* C, four times. */
name|long
name|m0
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|;
comment|/* Bitmasks for counting C. */
name|cccc
operator|=
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|c
operator|)
expr_stmt|;
name|m0
operator|=
literal|0xff
expr_stmt|;
name|m1
operator|=
literal|0xff00
expr_stmt|;
name|m2
operator|=
literal|0xff0000
expr_stmt|;
name|m3
operator|=
literal|0xff000000
expr_stmt|;
name|p1i
operator|=
operator|(
name|long
operator|*
operator|)
name|p1
expr_stmt|;
name|p2i
operator|=
operator|(
name|long
operator|*
operator|)
name|p2
expr_stmt|;
comment|/* Find the rough position of the first difference by reading long ints,      not bytes.  */
name|i1
operator|=
operator|*
name|p1i
operator|++
expr_stmt|;
name|i2
operator|=
operator|*
name|p2i
operator|++
expr_stmt|;
while|while
condition|(
name|i1
operator|==
name|i2
condition|)
block|{
name|w
operator|=
name|i1
operator|^
name|cccc
expr_stmt|;
name|cnt
operator|+=
operator|(
name|w
operator|&
name|m0
operator|)
operator|==
literal|0
expr_stmt|;
name|cnt
operator|+=
operator|(
name|w
operator|&
name|m1
operator|)
operator|==
literal|0
expr_stmt|;
name|cnt
operator|+=
operator|(
name|w
operator|&
name|m2
operator|)
operator|==
literal|0
expr_stmt|;
name|cnt
operator|+=
operator|(
name|w
operator|&
name|m3
operator|)
operator|==
literal|0
expr_stmt|;
name|i1
operator|=
operator|*
name|p1i
operator|++
expr_stmt|;
name|i2
operator|=
operator|*
name|p2i
operator|++
expr_stmt|;
block|}
comment|/* Find out the exact differing position (endianess independant).  */
name|p1c
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p1i
operator|-
literal|1
operator|)
expr_stmt|;
name|p2c
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p2i
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p1c
operator|==
operator|*
name|p2c
condition|)
block|{
name|cnt
operator|+=
name|c
operator|==
operator|*
name|p1c
expr_stmt|;
name|p1c
operator|++
expr_stmt|;
name|p2c
operator|++
expr_stmt|;
block|}
operator|*
name|count
operator|=
name|cnt
expr_stmt|;
return|return
name|p1c
operator|-
name|p1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Compare two blocks of memory P1 and P2 until they differ.    Assumes that P1 and P2 are aligned at long addresses!    If the blocks are not guaranteed to be different, put sentinels at the ends    of the blocks before calling this function.    Return the offset of the first byte that differs.  */
end_comment

begin_function
name|int
name|bcmp2
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|char
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
name|long
modifier|*
name|i1
decl_stmt|,
modifier|*
name|i2
decl_stmt|;
name|char
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
comment|/* Find the rough position of the first difference by reading long ints,      not bytes.  */
for|for
control|(
name|i1
operator|=
operator|(
name|long
operator|*
operator|)
name|p1
operator|,
name|i2
operator|=
operator|(
name|long
operator|*
operator|)
name|p2
init|;
operator|*
name|i1
operator|++
operator|==
operator|*
name|i2
operator|++
condition|;
control|)
empty_stmt|;
comment|/* Find out the exact differing position (endianess independant).  */
for|for
control|(
name|c1
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|i1
operator|-
literal|1
operator|)
operator|,
name|c2
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|i2
operator|-
literal|1
operator|)
init|;
operator|*
name|c1
operator|==
operator|*
name|c2
condition|;
name|c1
operator|++
operator|,
name|c2
operator|++
control|)
empty_stmt|;
return|return
name|c1
operator|-
name|p1
return|;
block|}
end_block

begin_comment
comment|/* Read NCHARS bytes from descriptor FD into BUF.    Return the number of characters successfully read.  */
end_comment

begin_function
name|int
name|bread
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|nchars
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nchars
decl_stmt|;
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|int
name|nread
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|bp
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|nread
operator|==
name|nchars
operator|||
name|nread
operator|==
literal|0
condition|)
break|break;
name|nchars
operator|-=
name|nread
expr_stmt|;
block|}
return|return
name|bp
operator|-
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Print character C on stream FS, making nonvisible characters    visible by quoting like cat -t does.    Pad with spaces on the right to WIDTH characters.  */
end_comment

begin_function
name|void
name|printc
parameter_list|(
name|fs
parameter_list|,
name|width
parameter_list|,
name|c
parameter_list|)
name|FILE
modifier|*
name|fs
decl_stmt|;
name|int
name|width
decl_stmt|;
name|unsigned
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>=
literal|128
condition|)
block|{
name|putc
argument_list|(
literal|'M'
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|128
expr_stmt|;
name|width
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|c
operator|+=
literal|64
expr_stmt|;
operator|--
name|width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|127
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
operator|--
name|width
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|fs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|width
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

