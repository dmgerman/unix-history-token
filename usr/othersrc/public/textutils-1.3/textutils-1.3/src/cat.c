begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cat -- concatenate files and print on the standard output.    Copyright (C) 1988, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Differences from the Unix cat:    * Always unbuffered, -u is ignored.    * 100 times faster with -v -u.    * 20 times faster with -v.     By tege@sics.se, Torbjorn Granlund, advised by rms, Richard Stallman. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_SOURCE
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|h
parameter_list|,
name|i
parameter_list|)
value|((h)> (i) ? (h) : (i))
end_define

begin_function_decl
name|char
modifier|*
name|stpcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|next_line_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|simple_cat
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of input file.  May be "-".  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor on which input file is open.  */
end_comment

begin_decl_stmt
name|int
name|input_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor on which output file is open.  Always is 1.  */
end_comment

begin_decl_stmt
name|int
name|output_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for line numbers.  */
end_comment

begin_decl_stmt
name|char
name|line_buf
index|[
literal|13
index|]
init|=
block|{
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|'0'
block|,
literal|'\t'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position in `line_buf' where printing starts.  This will not change    unless the number of lines are more than 999999.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line_num_print
init|=
name|line_buf
operator|+
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position of the first digit in `line_buf'.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line_num_start
init|=
name|line_buf
operator|+
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position of the last digit in `line_buf'.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line_num_end
init|=
name|line_buf
operator|+
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preserves the `cat' function's local `newlines' between invocations.  */
end_comment

begin_decl_stmt
name|int
name|newlines2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of non-fatal error conditions.  */
end_comment

begin_decl_stmt
name|int
name|exit_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|reason
parameter_list|)
name|char
modifier|*
name|reason
decl_stmt|;
block|{
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-benstuvAET] [--number] [--number-nonblank] [--squeeze-blank]\n\        [--show-nonprinting] [--show-ends] [--show-tabs] [--show-all]\n\        [file...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
comment|/* Optimal size of i/o operations of output.  */
name|int
name|outsize
decl_stmt|;
comment|/* Optimal size of i/o operations of input.  */
name|int
name|insize
decl_stmt|;
comment|/* Pointer to the input buffer.  */
name|unsigned
name|char
modifier|*
name|inbuf
decl_stmt|;
comment|/* Pointer to the output buffer.  */
name|unsigned
name|char
modifier|*
name|outbuf
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Index in argv to processed argument.  */
name|int
name|argind
decl_stmt|;
comment|/* Device number of the output (file or whatever).  */
name|int
name|out_dev
decl_stmt|;
comment|/* I-node number of the output.  */
name|int
name|out_ino
decl_stmt|;
comment|/* Nonzero if the output file should not be the same as any input file. */
name|int
name|check_redirection
init|=
literal|1
decl_stmt|;
comment|/* Nonzero if we have ever read standard input. */
name|int
name|have_read_stdin
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
comment|/* Variables that are set according to the specified options.  */
name|int
name|numbers
init|=
literal|0
decl_stmt|;
name|int
name|numbers_at_empty_lines
init|=
literal|1
decl_stmt|;
name|int
name|squeeze_empty_lines
init|=
literal|0
decl_stmt|;
name|int
name|mark_line_ends
init|=
literal|0
decl_stmt|;
name|int
name|quote
init|=
literal|0
decl_stmt|;
name|int
name|output_tabs
init|=
literal|1
decl_stmt|;
name|int
name|options
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"number-nonblank"
block|,
literal|0
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"number"
block|,
literal|0
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"squeeze-blank"
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"show-nonprinting"
block|,
literal|0
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"show-ends"
block|,
literal|0
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"show-tabs"
block|,
literal|0
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"show-all"
block|,
literal|0
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Parse command line options.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"benstuvAET"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|options
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|numbers
operator|=
literal|1
expr_stmt|;
name|numbers_at_empty_lines
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|mark_line_ends
operator|=
literal|1
expr_stmt|;
name|quote
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|numbers
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|squeeze_empty_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|output_tabs
operator|=
literal|0
expr_stmt|;
name|quote
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* We provide the -u feature unconditionally.  */
name|options
operator|--
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|quote
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|quote
operator|=
literal|1
expr_stmt|;
name|mark_line_ends
operator|=
literal|1
expr_stmt|;
name|output_tabs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|mark_line_ends
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|output_tabs
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|output_desc
operator|=
literal|1
expr_stmt|;
comment|/* Get device, i-node number, and optimal blocksize of output.  */
if|if
condition|(
name|fstat
argument_list|(
name|output_desc
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"standard output"
argument_list|)
expr_stmt|;
name|outsize
operator|=
name|ST_BLKSIZE
argument_list|(
name|stat_buf
argument_list|)
expr_stmt|;
comment|/* Input file can be output file for non-regular files.      fstat on pipes returns S_IFSOCK on some systems, S_IFIFO      on others, so the checking should not be done for those types,      and to allow things like cat< /dev/tty> /dev/tty, checking      is not done for device files either. */
if|if
condition|(
name|S_ISREG
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|out_dev
operator|=
name|stat_buf
operator|.
name|st_dev
expr_stmt|;
name|out_ino
operator|=
name|stat_buf
operator|.
name|st_ino
expr_stmt|;
block|}
else|else
name|check_redirection
operator|=
literal|0
expr_stmt|;
comment|/* Check if any of the input files are the same as the output file.  */
comment|/* Main loop.  */
name|infile
operator|=
literal|"-"
expr_stmt|;
name|argind
operator|=
name|optind
expr_stmt|;
do|do
block|{
if|if
condition|(
name|argind
operator|<
name|argc
condition|)
name|infile
operator|=
name|argv
index|[
name|argind
index|]
expr_stmt|;
if|if
condition|(
name|infile
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|infile
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|input_desc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|input_desc
operator|=
name|open
argument_list|(
name|infile
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_desc
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|fstat
argument_list|(
name|input_desc
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
name|insize
operator|=
name|ST_BLKSIZE
argument_list|(
name|stat_buf
argument_list|)
expr_stmt|;
comment|/* Compare the device and i-node numbers of this input file with 	 the corresponding values of the (output file associated with) 	 stdout, and skip this input file if they coincide.  Input 	 files cannot be redirected to themselves.  */
if|if
condition|(
name|check_redirection
operator|&&
name|stat_buf
operator|.
name|st_dev
operator|==
name|out_dev
operator|&&
name|stat_buf
operator|.
name|st_ino
operator|==
name|out_ino
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: input file is output file"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
comment|/* Select which version of `cat' to use. If any options (more than -u) 	 were specified, use `cat', otherwise use `simple_cat'.  */
if|if
condition|(
name|options
operator|==
literal|0
condition|)
block|{
name|insize
operator|=
name|max
argument_list|(
name|insize
argument_list|,
name|outsize
argument_list|)
expr_stmt|;
name|inbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|insize
argument_list|)
expr_stmt|;
name|simple_cat
argument_list|(
name|inbuf
argument_list|,
name|insize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|insize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Why are (OUTSIZE  - 1 + INSIZE * 4 + 13) bytes allocated for 	     the output buffer?  	     A test whether output needs to be written is done when the input 	     buffer empties or when a newline appears in the input.  After 	     output is written, at most (OUTSIZE - 1) bytes will remain in the 	     buffer.  Now INSIZE bytes of input is read.  Each input character 	     may grow by a factor of 4 (by the prepending of M-^).  If all 	     characters do, and no newlines appear in this block of input, we 	     will have at most (OUTSIZE - 1 + INSIZE) bytes in the buffer.  If 	     the last character in the preceeding block of input was a 	     newline, a line number may be written (according to the given 	     options) as the first thing in the output buffer. (Done after the 	     new input is read, but before processing of the input begins.)  A 	     line number requires seldom more than 13 positions.  */
name|outbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|outsize
operator|-
literal|1
operator|+
name|insize
operator|*
literal|4
operator|+
literal|13
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|inbuf
argument_list|,
name|insize
argument_list|,
name|outbuf
argument_list|,
name|outsize
argument_list|,
name|quote
argument_list|,
name|output_tabs
argument_list|,
name|numbers
argument_list|,
name|numbers_at_empty_lines
argument_list|,
name|mark_line_ends
argument_list|,
name|squeeze_empty_lines
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|contin
label|:
if|if
condition|(
name|strcmp
argument_list|(
name|infile
argument_list|,
literal|"-"
argument_list|)
operator|&&
name|close
argument_list|(
name|input_desc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|argind
operator|<
name|argc
condition|)
do|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_stat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Plain cat.  Copies the file behind `input_desc' to the file behind    `output_desc'.  */
end_comment

begin_function
name|void
name|simple_cat
parameter_list|(
name|buf
parameter_list|,
name|bufsize
parameter_list|)
comment|/* Pointer to the buffer, used by reads and writes.  */
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Number of characters preferably read or written by each read and write         call.  */
name|int
name|bufsize
decl_stmt|;
block|{
comment|/* Actual number of characters read, and therefore written.  */
name|int
name|n_read
decl_stmt|;
comment|/* Loop until the end of the file.  */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Read a block of input.  */
name|n_read
operator|=
name|read
argument_list|(
name|input_desc
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* End of this file?  */
if|if
condition|(
name|n_read
operator|==
literal|0
condition|)
break|break;
comment|/* Write this block out.  */
if|if
condition|(
name|write
argument_list|(
name|output_desc
argument_list|,
name|buf
argument_list|,
name|n_read
argument_list|)
operator|!=
name|n_read
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cat the file behind INPUT_DESC to the file behind OUTPUT_DESC.    Called if any option more than -u was specified.     A newline character is always put at the end of the buffer, to make    an explicit test for buffer end unnecessary.  */
end_comment

begin_function
name|void
name|cat
parameter_list|(
name|inbuf
parameter_list|,
name|insize
parameter_list|,
name|outbuf
parameter_list|,
name|outsize
parameter_list|,
name|quote
parameter_list|,
name|output_tabs
parameter_list|,
name|numbers
parameter_list|,
name|numbers_at_empty_lines
parameter_list|,
name|mark_line_ends
parameter_list|,
name|squeeze_empty_lines
parameter_list|)
comment|/* Pointer to the beginning of the input buffer.  */
name|unsigned
name|char
modifier|*
name|inbuf
decl_stmt|;
comment|/* Number of characters read in each read call.  */
name|int
name|insize
decl_stmt|;
comment|/* Pointer to the beginning of the output buffer.  */
name|unsigned
name|char
modifier|*
name|outbuf
decl_stmt|;
comment|/* Number of characters written by each write call.  */
name|int
name|outsize
decl_stmt|;
comment|/* Variables that have values according to the specified options.  */
name|int
name|quote
decl_stmt|;
name|int
name|output_tabs
decl_stmt|;
name|int
name|numbers
decl_stmt|;
name|int
name|numbers_at_empty_lines
decl_stmt|;
name|int
name|mark_line_ends
decl_stmt|;
name|int
name|squeeze_empty_lines
decl_stmt|;
block|{
comment|/* Last character read from the input buffer.  */
name|unsigned
name|char
name|ch
decl_stmt|;
comment|/* Pointer to the next character in the input buffer.  */
name|unsigned
name|char
modifier|*
name|bpin
decl_stmt|;
comment|/* Pointer to the first non-valid byte in the input buffer, i.e. the      current end of the buffer.  */
name|unsigned
name|char
modifier|*
name|eob
decl_stmt|;
comment|/* Pointer to the position where the next character shall be written.  */
name|unsigned
name|char
modifier|*
name|bpout
decl_stmt|;
comment|/* Number of characters read by the last read call.  */
name|int
name|n_read
decl_stmt|;
comment|/* Determines how many consequtive newlines there have been in the      input.  0 newlines makes NEWLINES -1, 1 newline makes NEWLINES 1,      etc.  Initially 0 to indicate that we are at the beginning of a      new line.  The "state" of the procedure is determined by      NEWLINES.  */
name|int
name|newlines
init|=
name|newlines2
decl_stmt|;
ifdef|#
directive|ifdef
name|FIONREAD
comment|/* If nonzero, use the FIONREAD ioctl, as an optimization.      (On Ultrix, it is not supported on NFS filesystems.)  */
name|int
name|use_fionread
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* The inbuf pointers are initialized so that BPIN> EOB, and thereby input      is read immediately.  */
name|eob
operator|=
name|inbuf
expr_stmt|;
name|bpin
operator|=
name|eob
operator|+
literal|1
expr_stmt|;
name|bpout
operator|=
name|outbuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
comment|/* Write if there are at least OUTSIZE bytes in OUTBUF.  */
if|if
condition|(
name|bpout
operator|-
name|outbuf
operator|>=
name|outsize
condition|)
block|{
name|unsigned
name|char
modifier|*
name|wp
init|=
name|outbuf
decl_stmt|;
do|do
block|{
if|if
condition|(
name|write
argument_list|(
name|output_desc
argument_list|,
name|wp
argument_list|,
name|outsize
argument_list|)
operator|!=
name|outsize
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|wp
operator|+=
name|outsize
expr_stmt|;
block|}
do|while
condition|(
name|bpout
operator|-
name|wp
operator|>=
name|outsize
condition|)
do|;
comment|/* Move the remaining bytes to the beginning of the 		 buffer.  */
name|bcopy
argument_list|(
name|wp
argument_list|,
name|outbuf
argument_list|,
name|bpout
operator|-
name|wp
argument_list|)
expr_stmt|;
name|bpout
operator|=
name|outbuf
operator|+
operator|(
name|bpout
operator|-
name|wp
operator|)
expr_stmt|;
block|}
comment|/* Is INBUF empty?  */
if|if
condition|(
name|bpin
operator|>
name|eob
condition|)
block|{
ifdef|#
directive|ifdef
name|FIONREAD
name|int
name|n_to_read
init|=
literal|0
decl_stmt|;
comment|/* Is there any input to read immediately? 		 If not, we are about to wait, 		 so write all buffered output before waiting.  */
if|if
condition|(
name|use_fionread
operator|&&
name|ioctl
argument_list|(
name|input_desc
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|n_to_read
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Ultrix returns EOPNOTSUPP on NFS; 		     HP-UX returns ENOTTY on pipes. */
if|if
condition|(
name|errno
operator|==
name|EOPNOTSUPP
operator|||
name|errno
operator|==
name|ENOTTY
condition|)
name|use_fionread
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot do ioctl on `%s'"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
name|newlines2
operator|=
name|newlines
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|n_to_read
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
name|int
name|n_write
init|=
name|bpout
operator|-
name|outbuf
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|output_desc
argument_list|,
name|outbuf
argument_list|,
name|n_write
argument_list|)
operator|!=
name|n_write
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|bpout
operator|=
name|outbuf
expr_stmt|;
block|}
comment|/* Read more input into INBUF.  */
name|n_read
operator|=
name|read
argument_list|(
name|input_desc
argument_list|,
name|inbuf
argument_list|,
name|insize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
name|newlines2
operator|=
name|newlines
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n_read
operator|==
literal|0
condition|)
block|{
name|newlines2
operator|=
name|newlines
expr_stmt|;
return|return;
block|}
comment|/* Update the pointers and insert a sentinel at the buffer 		 end.  */
name|bpin
operator|=
name|inbuf
expr_stmt|;
name|eob
operator|=
name|bpin
operator|+
name|n_read
expr_stmt|;
operator|*
name|eob
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
comment|/* It was a real (not a sentinel) newline.  */
comment|/* Was the last line empty? 		 (i.e. have two or more consecutive newlines been read?)  */
if|if
condition|(
operator|++
name|newlines
operator|>
literal|0
condition|)
block|{
comment|/* Are multiple adjacent empty lines to be substituted by 		     single ditto (-s), and this was the second empty line?  */
if|if
condition|(
name|squeeze_empty_lines
operator|&&
name|newlines
operator|>=
literal|2
condition|)
block|{
name|ch
operator|=
operator|*
name|bpin
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Are line numbers to be written at empty lines (-n)?  */
if|if
condition|(
name|numbers
operator|&&
name|numbers_at_empty_lines
condition|)
block|{
name|next_line_num
argument_list|()
expr_stmt|;
name|bpout
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|stpcpy
argument_list|(
name|bpout
argument_list|,
name|line_num_print
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output a currency symbol if requested (-e).  */
if|if
condition|(
name|mark_line_ends
condition|)
operator|*
name|bpout
operator|++
operator|=
literal|'$'
expr_stmt|;
comment|/* Output the newline.  */
operator|*
name|bpout
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
name|ch
operator|=
operator|*
name|bpin
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|==
literal|'\n'
condition|)
do|;
comment|/* Are we at the beginning of a line, and line numbers are requested?  */
if|if
condition|(
name|newlines
operator|>=
literal|0
operator|&&
name|numbers
condition|)
block|{
name|next_line_num
argument_list|()
expr_stmt|;
name|bpout
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|stpcpy
argument_list|(
name|bpout
argument_list|,
name|line_num_print
argument_list|)
expr_stmt|;
block|}
comment|/* Here CH cannot contain a newline character.  */
comment|/* The loops below continue until a newline character is found, 	 which means that the buffer is empty or that a proper newline 	 has been found.  */
comment|/* If quoting, i.e. at least one of -v, -e, or -t specified, 	 scan for chars that need conversion.  */
if|if
condition|(
name|quote
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|32
condition|)
block|{
if|if
condition|(
name|ch
operator|<
literal|127
condition|)
operator|*
name|bpout
operator|++
operator|=
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|127
condition|)
operator|*
name|bpout
operator|++
operator|=
literal|'^'
operator|,
operator|*
name|bpout
operator|++
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
operator|*
name|bpout
operator|++
operator|=
literal|'M'
operator|,
operator|*
name|bpout
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|128
operator|+
literal|32
condition|)
if|if
condition|(
name|ch
operator|<
literal|128
operator|+
literal|127
condition|)
operator|*
name|bpout
operator|++
operator|=
name|ch
operator|-
literal|128
expr_stmt|;
else|else
operator|*
name|bpout
operator|++
operator|=
literal|'^'
operator|,
operator|*
name|bpout
operator|++
operator|=
literal|'?'
expr_stmt|;
else|else
operator|*
name|bpout
operator|++
operator|=
literal|'^'
operator|,
operator|*
name|bpout
operator|++
operator|=
name|ch
operator|-
literal|128
operator|+
literal|64
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\t'
operator|&&
name|output_tabs
condition|)
operator|*
name|bpout
operator|++
operator|=
literal|'\t'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|newlines
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|bpout
operator|++
operator|=
literal|'^'
operator|,
operator|*
name|bpout
operator|++
operator|=
name|ch
operator|+
literal|64
expr_stmt|;
name|ch
operator|=
operator|*
name|bpin
operator|++
expr_stmt|;
block|}
else|else
comment|/* Not quoting, neither of -v, -e, or -t specified.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\t'
operator|&&
operator|!
name|output_tabs
condition|)
operator|*
name|bpout
operator|++
operator|=
literal|'^'
operator|,
operator|*
name|bpout
operator|++
operator|=
name|ch
operator|+
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|'\n'
condition|)
operator|*
name|bpout
operator|++
operator|=
name|ch
expr_stmt|;
else|else
block|{
name|newlines
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|ch
operator|=
operator|*
name|bpin
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the next line number.  */
end_comment

begin_function
name|void
name|next_line_num
parameter_list|()
block|{
name|char
modifier|*
name|endp
init|=
name|line_num_end
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|endp
operator|)
operator|++
operator|<
literal|'9'
condition|)
return|return;
operator|*
name|endp
operator|--
operator|=
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|endp
operator|>=
name|line_num_start
condition|)
do|;
operator|*
operator|--
name|line_num_start
operator|=
literal|'1'
expr_stmt|;
if|if
condition|(
name|line_num_start
operator|<
name|line_num_print
condition|)
name|line_num_print
operator|--
expr_stmt|;
block|}
end_function

end_unit

