begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* paste - merge lines of files    Copyright (C) 1984 by David M. Ihnat      This program is a total rewrite of the Bell Laboratories Unix(Tm)    command of the same name, as of System V.  It contains no proprietary    code, and therefore may be used without violation of any proprietary    agreements whatsoever.  However, you will notice that the program is    copyrighted by me.  This is to assure the program does *not* fall    into the public domain.  Thus, I may specify just what I am now:    This program may be freely copied and distributed, provided this notice    remains; it may not be sold for profit without express written consent of    the author.    Please note that I recreated the behavior of the Unix(Tm) 'paste' command    as faithfully as possible, with minor exceptions; however,    I haven't run a full set of regression tests.  Thus, the user of    this program accepts full responsibility for any effects or loss;    in particular, the author is not responsible for any losses,    explicit or incidental, that may be incurred through use of this program.      I ask that any bugs (and, if possible, fixes) be reported to me when    possible.  -David Ihnat (312) 784-4544 ignatz@homebru.chi.il.us     The list of valid escape sequences has been expanded over the Unix    version, to include \b, \f, \r, and \v.      POSIX changes, bug fixes, long-named options, and cleanup    by David MacKenzie<djm@ai.mit.edu>.      Options:    --serial    -s				Paste one file at a time rather than 				one line from each file.    --delimiters=delim-list    -d delim-list		Consecutively use the characters in 				DELIM-LIST instead of tab to separate 				merged lines.  When DELIM-LIST is exhausted, 				start again at its beginning.    A FILE of `-' means standard input.    If no FILEs are given, standard input is used. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_function_decl
name|char
modifier|*
name|collapse_escapes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|paste_parallel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|paste_serial
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Indicates that no delimiter should be added in the current position. */
end_comment

begin_define
define|#
directive|define
name|EMPTY_DELIM
value|'\0'
end_define

begin_comment
comment|/* Element marking a file that has reached EOF and been closed. */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|((FILE *) -1)
end_define

begin_comment
comment|/* Element marking end of list of open files. */
end_comment

begin_define
define|#
directive|define
name|ENDLIST
value|((FILE *) -2)
end_define

begin_comment
comment|/* Name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, we have read standard input at some point. */
end_comment

begin_decl_stmt
name|int
name|have_read_stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, merge subsequent lines of each file rather than    corresponding lines from each file in parallel. */
end_comment

begin_decl_stmt
name|int
name|serial_merge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The delimeters between lines of input files (used cyclically). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|delims
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the character after the end of `delims'. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|delim_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"serial"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"delimiters"
block|,
literal|1
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|optc
decl_stmt|,
name|exit_status
decl_stmt|;
name|char
name|default_delims
index|[
literal|2
index|]
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|have_read_stdin
operator|=
literal|0
expr_stmt|;
name|serial_merge
operator|=
literal|0
expr_stmt|;
name|delims
operator|=
name|default_delims
expr_stmt|;
name|strcpy
argument_list|(
name|delims
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:s"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* Delimiter character(s). */
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|optarg
operator|=
literal|"\\0"
expr_stmt|;
name|delims
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|serial_merge
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-"
expr_stmt|;
name|delim_end
operator|=
name|collapse_escapes
argument_list|(
name|delims
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|serial_merge
condition|)
name|exit_status
operator|=
name|paste_parallel
argument_list|(
name|argc
operator|-
name|optind
argument_list|,
operator|&
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
else|else
name|exit_status
operator|=
name|paste_serial
argument_list|(
name|argc
operator|-
name|optind
argument_list|,
operator|&
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_read_stdin
operator|&&
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace backslash representations of special characters in    STRPTR with their actual values.    The set of possible backslash characters has been expanded beyond    that recognized by the Unix version.     Return a pointer to the character after the new end of STRPTR. */
end_comment

begin_function
name|char
modifier|*
name|collapse_escapes
parameter_list|(
name|strptr
parameter_list|)
name|char
modifier|*
name|strptr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|strout
decl_stmt|;
name|strout
operator|=
name|strptr
expr_stmt|;
comment|/* Start at the same place, anyway. */
while|while
condition|(
operator|*
name|strptr
condition|)
block|{
if|if
condition|(
operator|*
name|strptr
operator|!=
literal|'\\'
condition|)
comment|/* Is it an escape character? */
operator|*
name|strout
operator|++
operator|=
operator|*
name|strptr
operator|++
expr_stmt|;
comment|/* No, just transfer it. */
else|else
block|{
switch|switch
condition|(
operator|*
operator|++
name|strptr
condition|)
block|{
case|case
literal|'0'
case|:
operator|*
name|strout
operator|++
operator|=
name|EMPTY_DELIM
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|strout
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|strout
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|strout
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|strout
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|strout
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|strout
operator|++
operator|=
literal|'\v'
expr_stmt|;
break|break;
default|default:
operator|*
name|strout
operator|++
operator|=
operator|*
name|strptr
expr_stmt|;
break|break;
block|}
name|strptr
operator|++
expr_stmt|;
block|}
block|}
return|return
name|strout
return|;
block|}
end_function

begin_comment
comment|/* Perform column paste on the NFILES files named in FNAMPTR.    Return 0 if no errors, 1 if one or more files could not be    opened or read. */
end_comment

begin_function
name|int
name|paste_parallel
parameter_list|(
name|nfiles
parameter_list|,
name|fnamptr
parameter_list|)
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
modifier|*
name|fnamptr
decl_stmt|;
block|{
name|int
name|errors
init|=
literal|0
decl_stmt|;
comment|/* 1 if open or read errors occur. */
comment|/* Number of files for which space is allocated in `delbuf' and `fileptr'.      Enlarged as necessary. */
name|int
name|file_list_size
init|=
literal|12
decl_stmt|;
name|int
name|chr
decl_stmt|;
comment|/* Input character. */
name|int
name|line_length
decl_stmt|;
comment|/* Number of chars in line. */
name|int
name|somedone
decl_stmt|;
comment|/* 0 if all files empty for this line. */
comment|/* If all files are just ready to be closed, or will be on this      round, the string of delimiters must be preserved.      delbuf[0] through delbuf[file_list_size]      store the delimiters for closed files. */
name|char
modifier|*
name|delbuf
decl_stmt|;
name|int
name|delims_saved
decl_stmt|;
comment|/* Number of delims saved in `delbuf'. */
specifier|register
name|char
modifier|*
name|delimptr
decl_stmt|;
comment|/* Cycling pointer into `delims'. */
name|FILE
modifier|*
modifier|*
name|fileptr
decl_stmt|;
comment|/* Streams open to the files to process. */
name|int
name|files_open
decl_stmt|;
comment|/* Number of files still open to process. */
name|int
name|i
decl_stmt|;
comment|/* Loop index. */
name|int
name|opened_stdin
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if any fopen got fd 0. */
name|delbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_list_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fileptr
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|file_list_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Attempt to open all files.  This could be expanded to an infinite      number of files, but at the (considerable) expense of remembering      each file and its current offset, then opening/reading/closing.  */
for|for
control|(
name|files_open
operator|=
literal|0
init|;
name|files_open
operator|<
name|nfiles
condition|;
operator|++
name|files_open
control|)
block|{
if|if
condition|(
name|files_open
operator|==
name|file_list_size
operator|-
literal|2
condition|)
block|{
name|file_list_size
operator|+=
literal|12
expr_stmt|;
name|delbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|delbuf
argument_list|,
name|file_list_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fileptr
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|fileptr
argument_list|,
operator|(
name|file_list_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fnamptr
index|[
name|files_open
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|fileptr
index|[
name|files_open
index|]
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|fileptr
index|[
name|files_open
index|]
operator|=
name|fopen
argument_list|(
name|fnamptr
index|[
name|files_open
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileptr
index|[
name|files_open
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|fnamptr
index|[
name|files_open
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fileno
argument_list|(
name|fileptr
index|[
name|files_open
index|]
argument_list|)
operator|==
literal|0
condition|)
name|opened_stdin
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fileptr
index|[
name|files_open
index|]
operator|=
name|ENDLIST
expr_stmt|;
if|if
condition|(
name|opened_stdin
operator|&&
name|have_read_stdin
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"standard input is closed"
argument_list|)
expr_stmt|;
comment|/* Read a line from each file and output it to stdout separated by a      delimiter, until we go through the loop without successfully      reading from any of the files. */
while|while
condition|(
name|files_open
condition|)
block|{
comment|/* Set up for the next line. */
name|somedone
operator|=
literal|0
expr_stmt|;
name|delimptr
operator|=
name|delims
expr_stmt|;
name|delims_saved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fileptr
index|[
name|i
index|]
operator|!=
name|ENDLIST
operator|&&
name|files_open
condition|;
name|i
operator|++
control|)
block|{
name|line_length
operator|=
literal|0
expr_stmt|;
comment|/* Clear so we can easily detect EOF. */
if|if
condition|(
name|fileptr
index|[
name|i
index|]
operator|!=
name|CLOSED
condition|)
block|{
name|chr
operator|=
name|getc
argument_list|(
name|fileptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|chr
operator|!=
name|EOF
operator|&&
name|delims_saved
condition|)
block|{
name|fwrite
argument_list|(
name|delbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|delims_saved
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|delims_saved
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|chr
operator|!=
name|EOF
condition|)
block|{
name|line_length
operator|++
expr_stmt|;
if|if
condition|(
name|chr
operator|==
literal|'\n'
condition|)
break|break;
name|putc
argument_list|(
name|chr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|chr
operator|=
name|getc
argument_list|(
name|fileptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|line_length
operator|==
literal|0
condition|)
block|{
comment|/* EOF, read error, or closed file. 		 If an EOF or error, close the file and mark it in the list. */
if|if
condition|(
name|fileptr
index|[
name|i
index|]
operator|!=
name|CLOSED
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fileptr
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|fnamptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fileptr
index|[
name|i
index|]
operator|==
name|stdin
condition|)
name|clearerr
argument_list|(
name|fileptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Also clear EOF. */
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|fileptr
index|[
name|i
index|]
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|fnamptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
block|}
name|fileptr
index|[
name|i
index|]
operator|=
name|CLOSED
expr_stmt|;
name|files_open
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|fileptr
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|ENDLIST
condition|)
block|{
comment|/* End of this output line. 		     Is this the end of the whole thing? */
if|if
condition|(
name|somedone
condition|)
block|{
comment|/* No.  Some files were not closed for this line. */
if|if
condition|(
name|delims_saved
condition|)
block|{
name|fwrite
argument_list|(
name|delbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|delims_saved
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|delims_saved
operator|=
literal|0
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
continue|continue;
comment|/* Next read of files, or exit. */
block|}
else|else
block|{
comment|/* Closed file; add delimiter to `delbuf'. */
if|if
condition|(
operator|*
name|delimptr
operator|!=
name|EMPTY_DELIM
condition|)
name|delbuf
index|[
name|delims_saved
operator|++
index|]
operator|=
operator|*
name|delimptr
expr_stmt|;
if|if
condition|(
operator|++
name|delimptr
operator|==
name|delim_end
condition|)
name|delimptr
operator|=
name|delims
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Some data read. */
name|somedone
operator|++
expr_stmt|;
comment|/* Except for last file, replace last newline with delim. */
if|if
condition|(
name|fileptr
index|[
name|i
operator|+
literal|1
index|]
operator|!=
name|ENDLIST
condition|)
block|{
if|if
condition|(
name|chr
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
name|chr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|delimptr
operator|!=
name|EMPTY_DELIM
condition|)
name|putc
argument_list|(
operator|*
name|delimptr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|delimptr
operator|==
name|delim_end
condition|)
name|delimptr
operator|=
name|delims
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|chr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|errors
return|;
block|}
end_function

begin_comment
comment|/* Perform serial paste on the NFILES files named in FNAMPTR.    Return 0 if no errors, 1 if one or more files could not be    opened or read. */
end_comment

begin_function
name|int
name|paste_serial
parameter_list|(
name|nfiles
parameter_list|,
name|fnamptr
parameter_list|)
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
modifier|*
name|fnamptr
decl_stmt|;
block|{
name|int
name|errors
init|=
literal|0
decl_stmt|;
comment|/* 1 if open or read errors occur. */
specifier|register
name|int
name|charnew
decl_stmt|,
name|charold
decl_stmt|;
comment|/* Current and previous char read. */
specifier|register
name|char
modifier|*
name|delimptr
decl_stmt|;
comment|/* Current delimiter char. */
specifier|register
name|FILE
modifier|*
name|fileptr
decl_stmt|;
comment|/* Open for reading current file. */
for|for
control|(
init|;
name|nfiles
condition|;
name|nfiles
operator|--
operator|,
name|fnamptr
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|fnamptr
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|have_read_stdin
operator|=
literal|1
expr_stmt|;
name|fileptr
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|fileptr
operator|=
name|fopen
argument_list|(
operator|*
name|fnamptr
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileptr
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|fnamptr
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|delimptr
operator|=
name|delims
expr_stmt|;
comment|/* Set up for delimiter string. */
name|charold
operator|=
name|getc
argument_list|(
name|fileptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|charold
operator|!=
name|EOF
condition|)
block|{
comment|/* `charold' is set up.  Hit it! 	     Keep reading characters, stashing them in `charnew'; 	     output `charold', converting to the appropriate delimiter 	     character if needed.  After the EOF, output `charold' 	     if it's a newline; otherwise, output it and then a newline. */
while|while
condition|(
operator|(
name|charnew
operator|=
name|getc
argument_list|(
name|fileptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* Process the old character. */
if|if
condition|(
name|charold
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|delimptr
operator|!=
name|EMPTY_DELIM
condition|)
name|putc
argument_list|(
operator|*
name|delimptr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|delimptr
operator|==
name|delim_end
condition|)
name|delimptr
operator|=
name|delims
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|charold
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|charold
operator|=
name|charnew
expr_stmt|;
block|}
comment|/* Hit EOF.  Process that last character. */
name|putc
argument_list|(
name|charold
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charold
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fileptr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|fnamptr
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fileptr
operator|==
name|stdin
condition|)
name|clearerr
argument_list|(
name|fileptr
argument_list|)
expr_stmt|;
comment|/* Also clear EOF. */
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|fileptr
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|fnamptr
argument_list|)
expr_stmt|;
name|errors
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|errors
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-s] [-d delim-list] [--serial] [--delimiters=delim-list]\n\        [file...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

