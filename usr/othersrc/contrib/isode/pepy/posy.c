begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* posy.c - PEPY optional structure-generator (yacc-based) */
end_comment

begin_comment
comment|/* OPEN QUESTIONS:  	How to do smarter DEFAULT determination for the other types and NULLs  	Perhaps pull-up primitive IDentifiers  	Abort a CHOICE encoding if the structure is empty   				  HEURISTICS     1. LANGUAGE SIMPLIFICATIONS:   	Pull-up uni-member SEQUENCEs/SETs/CHOICEs      2. LANGUAGE ASSUMPTIONS:  	Unique tags to avoid conflicts for internal structures (-h1 option)      3. STYLE ISSUES:  	SEQUENCE/SET OF Type should have Type be an ID for nicer naming  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/pepy/RCS/posy.c,v 7.6 91/02/22 09:35:13 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/pepy/RCS/posy.c,v 7.6 91/02/22 09:35:13 mrose Interim $  *  *  * $Log:	posy.c,v $  * Revision 7.6  91/02/22  09:35:13  mrose  * Interim 6.8  *   * Revision 7.5  90/10/17  11:51:24  mrose  * sync  *   * Revision 7.4  90/09/07  17:35:09  mrose  * touch-up  *   * Revision 7.3  90/02/23  17:50:09  mrose  * update  *   * Revision 7.2  90/02/19  13:09:35  mrose  * update  *   * Revision 7.1  90/01/11  18:37:05  mrose  * real-sync  *   * Revision 7.0  89/11/23  22:11:59  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"pepy.h"
end_include

begin_define
define|#
directive|define
name|SVAL
parameter_list|(
name|s
parameter_list|)
value|((s) ? (s) : "")
end_define

begin_define
define|#
directive|define
name|PARVAL
parameter_list|(
name|s
parameter_list|)
value|((s) ? (s) : "parm")
end_define

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Cflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* posy */
end_comment

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pepy compat ... */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bflag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  .. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|module_actions
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pepydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doexternals
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linepos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hflag
value|(options[0])
end_define

begin_define
define|#
directive|define
name|Hflag
value|(options[1])
end_define

begin_define
define|#
directive|define
name|h2flag
value|(options[2])
end_define

begin_define
define|#
directive|define
name|NOPTIONS
value|3
end_define

begin_decl_stmt
specifier|static
name|int
name|options
index|[
name|NOPTIONS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|eval
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mymodule
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OID
name|mymoduleid
init|=
name|NULLOID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|modulename
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yysection
init|=
name|YP_DECODER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencpref
init|=
literal|"encode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecpref
init|=
literal|"decode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfpref
init|=
literal|"print"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyencdflt
init|=
literal|"encode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yydecdflt
init|=
literal|"decode"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyprfdflt
init|=
literal|"print"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|classes
index|[]
init|=
block|{
literal|"UNIVERSAL "
block|,
literal|"APPLICATION "
block|,
literal|""
block|,
literal|"PRIVATE "
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tags
index|[]
init|=
block|{
literal|""
block|,
literal|"BOOLEAN"
block|,
literal|"INTEGER"
block|,
literal|"INTEGER"
block|,
literal|"BIT STRING"
block|,
literal|"BIT STRING"
block|,
literal|"OCTET STRING"
block|,
literal|"NULL"
block|,
literal|"SEQUENCE"
block|,
literal|"SEQUENCE OF"
block|,
literal|"SEQUENCE"
block|,
literal|"SET"
block|,
literal|"SET OF"
block|,
literal|"SET"
block|,
literal|"CHOICE"
block|,
literal|"ANY"
block|,
literal|"OBJECT IDENTIFIER"
block|,
literal|""
block|,
literal|"ENUMERATED"
block|,
literal|"REAL"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|autogen
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sysin
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysout
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysdef
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sysact
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fact
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fdef
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|modlist
block|{
name|char
modifier|*
name|md_module
decl_stmt|;
name|struct
name|modlist
modifier|*
name|md_next
decl_stmt|;
block|}
name|modlist
operator|,
typedef|*
name|MD
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLMD
value|((MD) 0)
end_define

begin_decl_stmt
specifier|static
name|MD
name|mymodules
init|=
name|NULLMD
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|symlist
block|{
name|char
modifier|*
name|sy_encpref
decl_stmt|;
name|char
modifier|*
name|sy_decpref
decl_stmt|;
name|char
modifier|*
name|sy_prfpref
decl_stmt|;
name|char
modifier|*
name|sy_module
decl_stmt|;
name|char
modifier|*
name|sy_name
decl_stmt|;
name|YP
name|sy_type
decl_stmt|;
name|struct
name|symlist
modifier|*
name|sy_next
decl_stmt|;
block|}
name|symlist
operator|,
typedef|*
name|SY
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLSY
value|((SY) 0)
end_define

begin_decl_stmt
specifier|static
name|SY
name|mysymbols
init|=
name|NULLSY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gensym
argument_list|()
decl_stmt|,
modifier|*
name|modsym
argument_list|()
decl_stmt|,
modifier|*
name|array
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|MD
name|lookup_module
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|SY
name|new_symbol
argument_list|()
decl_stmt|,
name|add_symbol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|double
name|val2real
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prime_default
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|YP
name|lookup_type
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|pepyversion
operator|+
name|strlen
argument_list|(
literal|"pepy "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"posy %s\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sysout
index|[
literal|0
index|]
operator|=
name|sysdef
index|[
literal|0
index|]
operator|=
name|sysact
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
name|cp
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|aflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dflag
operator|++
operator|,
name|fflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"-h"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
block|{
name|hflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|cp
operator|+
literal|2
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|1
operator|||
name|i
operator|>=
name|NOPTIONS
condition|)
goto|goto
name|usage
goto|;
name|hflag
operator|++
operator|,
name|options
index|[
name|i
index|]
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-m"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sysout
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many output files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|*
name|argv
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|)
condition|)
goto|goto
name|usage
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sysout
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sflag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sysin
condition|)
block|{
name|usage
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: posy [-a] [-d] [-f] [-Hh] [-o newmodule.py] [-s] module.py\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
name|NULL
condition|)
goto|goto
name|usage
goto|;
name|sysin
operator|=
literal|""
expr_stmt|;
block|}
name|sysin
operator|=
name|cp
expr_stmt|;
block|}
switch|switch
condition|(
name|pepydebug
operator|=
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"POSYTEST"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|?
name|atoi
argument_list|(
name|cp
argument_list|)
else|:
literal|0
condition|)
block|{
case|case
literal|2
case|:
name|yydebug
operator|++
expr_stmt|;
comment|/* fall */
case|case
literal|1
case|:
name|sflag
operator|++
expr_stmt|;
comment|/*   .. */
case|case
literal|0
case|:
break|break;
block|}
if|if
condition|(
name|sysin
operator|==
name|NULLCP
condition|)
name|sysin
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|sysin
operator|&&
name|freopen
argument_list|(
name|sysin
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to read "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysin
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sysout
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|sysout
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
operator|&&
name|freopen
argument_list|(
name|sysout
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to write "
argument_list|)
operator|,
name|perror
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|')'
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|++
init|;
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|dp
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|autogen
argument_list|,
literal|"posy %*.*s"
argument_list|,
name|cp
operator|-
name|dp
argument_list|,
name|cp
operator|-
name|dp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- automatically generated by %s, do not edit!\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
name|initoidtbl
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|yyparse
argument_list|()
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_expr_stmt
name|yyerror
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|yyerror_aux
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysdef
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysdef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysact
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysact
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|warning
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buffer2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer2
argument_list|,
literal|"Warning: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|yyerror_aux
argument_list|(
name|buffer2
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|warning
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warning
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|yyerror_aux
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"type %s: "
argument_list|,
name|eval
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %d: "
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eval
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last token read was \"%s\"\n"
argument_list|,
name|yytext
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|myyerror
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|myyerror
argument_list|(
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|myyerror
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
specifier|static
name|pyyerror
argument_list|(
argument|va_alist
argument_list|)
name|va_dcl
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|;
specifier|register
name|YP
name|yp
block|;
name|va_list
name|ap
block|;
name|va_start
argument_list|(
name|ap
argument_list|)
block|;
name|yp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|YP
argument_list|)
block|;
name|_asprintf
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|,
name|ap
argument_list|)
block|;
name|va_end
argument_list|(
name|ap
argument_list|)
block|;
name|yyerror_aux
argument_list|(
name|buffer
argument_list|)
block|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
block|;
if|if
condition|(
operator|*
name|sysout
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|sysdef
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysdef
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|*
name|sysact
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysact
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
unit|}
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
unit|static
name|pyyerror
argument_list|(
argument|yp
argument_list|,
argument|fmt
argument_list|)
end_macro

begin_decl_stmt
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pyyerror
argument_list|(
name|yp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|yywrap
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|yyprint
argument_list|(
argument|s
argument_list|,
argument|f
argument_list|,
argument|top
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|nameoutput
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|outputlinelen
init|=
literal|79
decl_stmt|;
if|if
condition|(
name|sflag
operator|||
operator|!
name|s
condition|)
return|return;
if|if
condition|(
operator|!
name|nameoutput
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
name|nameoutput
operator|=
operator|(
name|linepos
operator|=
name|strlen
argument_list|(
name|mymodule
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" types:"
argument_list|)
expr_stmt|;
name|linepos
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|top
condition|)
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|linepos
operator|!=
name|nameoutput
condition|)
if|if
condition|(
name|len
operator|+
name|linepos
operator|+
literal|1
operator|>
name|outputlinelen
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%*s"
argument_list|,
name|linepos
operator|=
name|nameoutput
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
operator|,
name|linepos
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|linepos
operator|+=
name|len
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS1 */
end_comment

begin_macro
name|pass1
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
if|if
condition|(
name|mymoduleid
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|oidprint
argument_list|(
name|mymoduleid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"DEFINITIONS ::=\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
name|pass1_type
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|,
name|yp
argument_list|)
specifier|register
name|char
operator|*
name|encpref
operator|,
operator|*
name|decpref
operator|,
operator|*
name|prfpref
operator|,
operator|*
name|mod
operator|,
operator|*
name|id
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|YP
name|yp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|lookup_type
argument_list|(
name|mod
argument_list|,
name|id
argument_list|)
condition|)
comment|/* no duplicate entries, please... */
return|return;
if|if
condition|(
name|pepydebug
condition|)
block|{
if|if
condition|(
name|linepos
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
operator|,
name|linepos
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s.%s\n"
argument_list|,
name|mod
condition|?
name|mod
else|:
name|mymodule
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"--------\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
operator|)
condition|)
name|yyprint
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sy
operator|=
name|new_symbol
argument_list|(
name|encpref
argument_list|,
name|decpref
argument_list|,
name|prfpref
argument_list|,
name|mod
argument_list|,
name|id
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|mysymbols
operator|=
name|add_symbol
argument_list|(
name|mysymbols
argument_list|,
name|sy
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|PASS2 */
end_comment

begin_macro
name|pass2
argument_list|()
end_macro

begin_block
block|{
name|int
name|first
decl_stmt|;
specifier|register
name|SY
name|sy
decl_stmt|;
specifier|register
name|YP
name|yp
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
operator|!
name|sflag
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|mymodule
argument_list|,
name|modulename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysdef
argument_list|,
literal|"%s-types.h"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdef
operator|=
name|fopen
argument_list|(
name|sysdef
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|sysdef
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"/* automatically generated by %s, do not edit! */\n\n"
argument_list|,
name|autogen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifndef\t_module_%s_defined_\n"
argument_list|,
name|modulename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t_module_%s_defined_\n\n"
argument_list|,
name|modulename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#ifndef	PEPYPATH\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include<isode/psap.h>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mymodule
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include<isode/pepy/UNIV-types.h>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#else\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include \"psap.h\"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mymodule
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include \"../pepy/UNIV-types.h\"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sysact
argument_list|,
literal|"%s-types.tmp"
argument_list|,
name|mymodule
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fact
operator|=
name|fopen
argument_list|(
name|sysact
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|myyerror
argument_list|(
literal|"unable to write %s"
argument_list|,
name|sysact
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
name|do_struct0
argument_list|(
name|yp
argument_list|,
name|eval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
operator|||
operator|(
name|fflag
operator|&&
name|ferror
argument_list|(
name|fact
argument_list|)
operator|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
name|do_struct1
argument_list|(
name|yp
argument_list|,
name|eval
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
operator|||
operator|(
name|fflag
operator|&&
name|ferror
argument_list|(
name|fact
argument_list|)
operator|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
name|do_struct2
argument_list|(
name|yp
argument_list|,
name|eval
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
operator|||
operator|(
name|fflag
operator|&&
name|ferror
argument_list|(
name|fact
argument_list|)
operator|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Cflag
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%%{\n#include<stdio.h>\n#include \"%s\"\n%%}\n"
argument_list|,
name|sysdef
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nPREFIXES %s %s %s\n"
argument_list|,
name|yyencdflt
argument_list|,
name|yydecdflt
argument_list|,
name|yyprfdflt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nBEGIN\n"
argument_list|)
expr_stmt|;
name|print_expimp
argument_list|()
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
name|printf
argument_list|(
literal|"\nENCODER %s\n"
argument_list|,
name|yyencpref
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [[P struct %s *]]"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|||
name|yp
operator|->
name|yp_type
condition|)
name|do_type0
argument_list|(
name|yp
argument_list|,
name|YP_ENCODER
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
name|do_type0
argument_list|(
name|yp
argument_list|,
name|YP_ENCODER
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|yp
operator|->
name|yp_declexp
condition|)
break|break;
name|do_type0
argument_list|(
name|yp
argument_list|,
name|YP_ENCODER
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" ::=\n"
argument_list|)
expr_stmt|;
name|do_type1
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
condition|?
literal|1
else|:
literal|2
argument_list|,
name|eval
argument_list|,
literal|"parm"
argument_list|,
name|NULLCP
argument_list|,
name|YP_ENCODER
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
operator|||
operator|(
name|fflag
operator|&&
name|ferror
argument_list|(
name|fact
argument_list|)
operator|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
name|eval
operator|=
name|sy
operator|->
name|sy_name
expr_stmt|;
name|yp
operator|=
name|sy
operator|->
name|sy_type
expr_stmt|;
if|if
condition|(
name|sy
operator|->
name|sy_module
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"no module name associated with symbol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_IMPORTED
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
name|printf
argument_list|(
literal|"\nDECODER %s\n"
argument_list|,
name|yydecpref
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [[P struct %s **]]"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|yp
operator|->
name|yp_declexp
operator|||
name|yp
operator|->
name|yp_type
condition|)
name|do_type0
argument_list|(
name|yp
argument_list|,
name|YP_DECODER
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|yp
operator|->
name|yp_declexp
condition|)
break|break;
name|do_type0
argument_list|(
name|yp
argument_list|,
name|YP_DECODER
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" ::=\n"
argument_list|)
expr_stmt|;
name|y
operator|=
name|yp
expr_stmt|;
name|again
label|:
empty_stmt|;
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|h2flag
condition|)
name|xalloc
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"parm"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
literal|"type"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
case|case
name|YP_REAL
case|:
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|hflag
operator|&&
name|y
operator|->
name|yp_type
operator|&&
operator|!
name|y
operator|->
name|yp_type
operator|->
name|yp_next
condition|)
block|{
name|y
operator|=
name|y
operator|->
name|yp_type
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* else fall */
default|default:
name|xalloc
argument_list|(
name|y
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"parm"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|sy
operator|->
name|sy_name
argument_list|,
literal|"type"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|do_type1
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
condition|?
literal|1
else|:
literal|2
argument_list|,
name|eval
argument_list|,
literal|"(*parm)"
argument_list|,
name|NULLCP
argument_list|,
name|YP_DECODER
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
operator|||
operator|(
name|fflag
operator|&&
name|ferror
argument_list|(
name|fact
argument_list|)
operator|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nEND\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fact
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fact
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%%{\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fact
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%%}\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fact
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sysact
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sysact
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fdef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|ferror
argument_list|(
name|fdef
argument_list|)
condition|)
name|myyerror
argument_list|(
literal|"write error - %s"
argument_list|,
name|sys_errname
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fdef
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_struct0
argument_list|(
name|yp
argument_list|,
name|id
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|components_pullup
argument_list|(
name|yp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
name|do_struct0
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
case|case
name|YP_SETLIST
case|:
name|choice_pullup
argument_list|(
name|yp
argument_list|,
name|yp
operator|->
name|yp_code
operator|==
name|YP_CHOICE
condition|?
name|CH_FULLY
else|:
name|CH_PARTIAL
argument_list|)
expr_stmt|;
comment|/* and fall */
case|case
name|YP_SEQLIST
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
name|do_struct0
argument_list|(
name|y
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
operator|&&
operator|!
name|lookup_module
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#include \"%s-types.h\"\n"
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|do_struct1
argument_list|(
name|yp
argument_list|,
name|id
argument_list|,
name|pullup
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|pullup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tPElement\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_BITLIST
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
operator|(
name|j
operator|=
name|val2int
argument_list|(
name|yv
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pyyerror
argument_list|(
name|yp
argument_list|,
literal|"invalid bit number in BIT STRING"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
name|i
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
condition|)
block|{
comment|/* NBBY */
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t\"\\020"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|eval
argument_list|,
literal|"bits"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%o%s"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%oBIT%d"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|modsym_aux
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_%s\t%d\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|eval
argument_list|,
literal|"bit"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fflag
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tpe_free\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tqbuf\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tqb_free\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\tOIDentifier\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\toid_free\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s\n"
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
name|do_struct1
argument_list|(
name|y
argument_list|,
name|id
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall */
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|do_struct2
argument_list|(
name|yp
argument_list|,
name|id
argument_list|,
name|pullup
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|pullup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
name|int
name|flg
init|=
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQTYPE
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_SETTYPE
operator|)
decl_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|hflag
operator|&&
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|!
name|y
operator|->
name|yp_next
condition|)
block|{
name|do_struct2
argument_list|(
name|y
argument_list|,
name|id
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall */
default|default:
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
literal|4
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"struct %s {\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%s (arg)\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"struct %s *arg;\n{\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"    struct %s *parm = arg;\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2flag
operator|&&
name|flg
condition|)
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"    int\tn_parm;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n    if (parm == NULL)\n\treturn;\n\n"
argument_list|)
expr_stmt|;
block|}
name|posy
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"parm"
argument_list|,
name|id
argument_list|,
literal|"parm"
argument_list|,
name|flg
operator|&&
name|h2flag
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"int\t%s ();\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|id
argument_list|,
literal|"free"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SEQTYPE
operator|&&
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETTYPE
condition|)
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n    free ((char *) arg);"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n}\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|type0_brackets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type0_bit
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|do_type0
argument_list|(
name|yp
argument_list|,
name|direction
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|type0_brackets
operator|=
name|type0_bit
operator|=
literal|0
expr_stmt|;
name|do_type0_aux
argument_list|(
name|yp
argument_list|,
name|direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|type0_brackets
condition|)
name|printf
argument_list|(
literal|"    %%}\n   "
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|do_type0_aux
argument_list|(
name|yp
argument_list|,
name|direction
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_declexp
condition|)
block|{
if|if
condition|(
name|type0_brackets
operator|++
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n    %%{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tstruct %s *%s%s;\n"
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|direction
operator|==
name|YP_DECODER
condition|?
literal|"*"
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|h2flag
condition|)
block|{
if|if
condition|(
name|type0_brackets
operator|++
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n    %%{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tint     n_%s = 0;\n"
argument_list|,
name|yp
operator|->
name|yp_declexp
condition|?
name|yp
operator|->
name|yp_declexp
else|:
literal|"parm"
argument_list|)
expr_stmt|;
block|}
name|do_type0_aux
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|,
name|direction
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
name|do_type0_aux
argument_list|(
name|y
argument_list|,
name|direction
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
condition|)
block|{
if|if
condition|(
name|type0_brackets
operator|++
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n    %%{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type0_bit
operator|++
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\tchar *bit_parm;\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|do_type1
argument_list|(
name|yp
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|id
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|direction
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|var
decl_stmt|,
modifier|*
name|action2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|varbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
specifier|register
name|YT
name|yt
decl_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
operator|)
condition|)
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
name|yt
operator|=
name|yp
operator|->
name|yp_tag
expr_stmt|;
name|printf
argument_list|(
literal|"[%s%d]\n"
argument_list|,
name|classes
index|[
name|yt
operator|->
name|yt_class
index|]
argument_list|,
name|val2int
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|&&
name|yp
operator|->
name|yp_varexp
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|index
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|yyerror
argument_list|(
literal|"Bug in varexp!"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|varbuf
argument_list|,
literal|"%*.*s"
argument_list|,
name|ep
operator|-
name|yp
operator|->
name|yp_varexp
argument_list|,
name|ep
operator|-
name|yp
operator|->
name|yp_varexp
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%%{ %s%s = %d; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_INT
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%%{ %s%s = %d; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%%{ %s%s = %d; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|dfl2int
argument_list|(
name|yp
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_REAL
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_OPTIONAL
operator||
name|YP_DEFAULT
operator|)
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%%{ %s%s = %g; %%}\n%*s"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2real
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_NULL
case|:
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
operator|)
operator|&&
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
operator|!
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"dummy-for-default\n%*s"
argument_list|,
operator|++
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%{ %s -> optionals |= %s; %%}\n%*s"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
operator|)
operator|==
operator|(
name|YP_TAG
operator||
name|YP_IMPLICIT
operator|)
condition|)
name|printf
argument_list|(
literal|"IMPLICIT "
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|printf
argument_list|(
literal|"%s< "
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_COMPONENTS
condition|)
name|printf
argument_list|(
literal|"COMPONENTS OF "
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ENCRYPTED
condition|)
name|printf
argument_list|(
literal|"ENCRYPTED "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
name|printf
argument_list|(
literal|"BOOLEAN"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[b %s -> %s ]]"
else|:
literal|"\n%*s[[b %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_INT
case|:
name|printf
argument_list|(
literal|"INTEGER"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[i %s -> %s ]]"
else|:
literal|"\n%*s[[i %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_ENUMLIST
condition|)
name|printf
argument_list|(
literal|"ENUMERATED"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"INTEGER"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[i %s -> %s ]]\n%*s{\n"
else|:
literal|"\n%*s[[i %s%s ]]\n%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|level
operator|++
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
name|printf
argument_list|(
literal|"%*s%s(%d)%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|,
name|yv
operator|->
name|yv_next
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_BIT
case|:
name|printf
argument_list|(
literal|"BIT STRING"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[x bit_parm = bitstr2strb (%s%s,&len) $ len]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%*s%%{\n%*sfree (bit_parm);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%%}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
name|balloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_BITLIST
case|:
name|printf
argument_list|(
literal|"BIT STRING"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[x bit_parm = bitstr2strb (%s%s,&len) $ len]]\n%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
default|default:
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|level
operator|++
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
name|printf
argument_list|(
literal|"%*s%s(%d)%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|,
name|yv
operator|->
name|yv_next
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_DECODER
case|:
name|balloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_ENCODER
case|:
name|printf
argument_list|(
literal|"\n%*s%%{\n%*sfree (bit_parm);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%%}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_OCT
case|:
name|printf
argument_list|(
literal|"OCTET STRING"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[q %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[q %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_REAL
case|:
name|printf
argument_list|(
literal|"REAL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|top
condition|?
literal|"\n%*s[[r %s -> %s ]]"
else|:
literal|"\n%*s[[r %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[a %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETTYPE
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
if|if
condition|(
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|->
name|yp_declexp
condition|)
block|{
name|printf
argument_list|(
literal|"%*s%%{ %s = %s; %%}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|SVAL
argument_list|(
name|y
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h2flag
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|printf
argument_list|(
literal|"%*s<<n_parm = 0; "
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"n_parm< parm -> nelem; n_parm++>>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%*s<<n_%s = 0;\n%*sn_%s< %s -> nelem;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sn_%s++>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|top
condition|)
name|printf
argument_list|(
literal|"%*s<<; parm; parm = parm -> next>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%*s<<%s = %s%s;\n%*s%s;\n%*s%s = %s -> next>>\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
operator|(
name|level
operator|+
literal|3
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_DECODER
case|:
if|if
condition|(
name|h2flag
condition|)
block|{
name|y
operator|=
name|yp
operator|->
name|yp_type
expr_stmt|;
name|xalloc
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|2
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|xalloc
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|top
condition|?
literal|"parm"
else|:
name|yp
operator|->
name|yp_declexp
argument_list|,
name|top
condition|?
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|eval
argument_list|,
literal|"type"
argument_list|)
else|:
name|yp
operator|->
name|yp_declexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|do_type1
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|ep
argument_list|,
literal|""
argument_list|,
name|NULLCP
argument_list|,
name|direction
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
literal|"\n%*s%%{ "
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2flag
condition|)
block|{
name|printf
argument_list|(
literal|"n_%s++;"
argument_list|,
name|top
condition|?
literal|"parm"
else|:
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yp
operator|->
name|yp_type
operator|)
operator|&&
operator|(
name|yp
operator|->
name|yp_type
operator|->
name|yp_declexp
operator|)
condition|)
name|printf
argument_list|(
literal|" %s ++;"
argument_list|,
name|yp
operator|->
name|yp_type
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|top
condition|)
name|printf
argument_list|(
literal|"parm =&((*parm) -> next);"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s =&((*%s) -> next);"
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|action2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %%}"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETLIST
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
condition|)
name|xalloc
argument_list|(
name|yp
argument_list|,
literal|1
argument_list|,
name|level
operator|+
literal|2
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
name|printf
argument_list|(
literal|"%*s%s = %s;\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
literal|"%*s%s =&(%s);\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
operator|&&
name|y
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|prime_default
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%*s%%}\n%*s{\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|||
operator|!
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|||
name|y
operator|->
name|yp_next
condition|)
block|{
name|var
operator|=
literal|""
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|do_type1
argument_list|(
name|y
argument_list|,
name|top
argument_list|,
name|level
operator|+
operator|(
operator|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_ID
operator||
name|YP_TAG
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
argument_list|,
name|ep
argument_list|,
name|var
argument_list|,
name|NULLCP
argument_list|,
name|direction
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|y
operator|->
name|yp_next
condition|?
literal|",\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_CHOICE
case|:
name|printf
argument_list|(
literal|"CHOICE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|||
operator|!
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|||
name|y
operator|->
name|yp_next
condition|)
name|var
operator|=
literal|""
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
name|i
operator|++
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
if|if
condition|(
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
name|printf
argument_list|(
literal|"%*s%s = %s;\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%%}\n%*s"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
operator|-
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|var
condition|)
name|printf
argument_list|(
literal|"<<1>>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|top
condition|)
name|printf
argument_list|(
literal|"<<parm -> offset>>"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<<%s -> offset>>"
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|i
condition|?
literal|"\n%*s{\n"
else|:
literal|" {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|xalloc
argument_list|(
name|yp
argument_list|,
literal|0
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" {\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|"(*(%s)) -> offset = "
argument_list|,
name|top
condition|?
literal|"parm"
else|:
name|yp
operator|->
name|yp_declexp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|||
operator|!
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|||
name|y
operator|->
name|yp_next
condition|)
name|top
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|top
condition|)
name|cp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|cp
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s;"
argument_list|,
name|y
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
name|do_type1
argument_list|(
name|y
argument_list|,
name|top
argument_list|,
name|level
operator|+
literal|1
argument_list|,
literal|"choice"
argument_list|,
name|var
argument_list|,
name|cp
condition|?
name|buffer
else|:
name|NULLCP
argument_list|,
name|direction
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|y
operator|->
name|yp_next
condition|?
literal|",\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*s}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OID
case|:
name|printf
argument_list|(
literal|"OBJECT IDENTIFIER"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[O %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|YP_ENCODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[p %s%s ]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_DECODER
case|:
name|printf
argument_list|(
literal|"\n%*s[[p&(%s%s)]]"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown type: %d"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action2
condition|)
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
condition|)
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|direction
operator|==
name|YP_DECODER
condition|)
break|break;
comment|/* else fall */
default|default:
name|printf
argument_list|(
literal|"\n%*s%%{ %s %%}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*sOPTIONAL"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
condition|)
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_NULL
case|:
case|case
name|YP_REAL
case|:
name|printf
argument_list|(
literal|"<<%s -> optionals& %s>>"
argument_list|,
name|varbuf
argument_list|,
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
default|default:
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
name|printf
argument_list|(
literal|"<<%s%s>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|printf
argument_list|(
literal|"\n%*sDEFAULT "
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
condition|)
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
name|printf
argument_list|(
literal|"<<%s%s%s>>"
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
name|printf
argument_list|(
literal|"<<%s%s != %d>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|dfl2int
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
name|printf
argument_list|(
literal|"<< %s%s != %g>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2real
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
default|default:
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
case|case
name|YP_OCT
case|:
case|case
name|YP_SEQ
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_ANY
case|:
case|case
name|YP_OID
case|:
case|case
name|YP_IDEFINED
case|:
name|printf
argument_list|(
literal|"<<%s%s>>"
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|direction
operator|==
name|YP_ENCODER
operator|&&
name|yp
operator|->
name|yp_varexp
operator|&&
operator|(
name|cp
operator|=
name|index
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"-> "
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"(*%s) -> %s"
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|TYPE HANDLING */
end_comment

begin_function
specifier|static
name|YP
name|lookup_type
parameter_list|(
name|mod
parameter_list|,
name|id
parameter_list|)
specifier|register
name|char
modifier|*
name|mod
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
for|for
control|(
name|sy
operator|=
name|mysymbols
init|;
name|sy
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|mod
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mod
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
name|mymodule
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_module
argument_list|,
literal|"UNIV"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sy
operator|->
name|sy_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sy
operator|->
name|sy_type
return|;
block|}
return|return
name|NULLYP
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|posy
argument_list|(
name|yp
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|id
argument_list|,
name|val
argument_list|,
name|var
argument_list|,
name|arrayflg
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|level
decl_stmt|,
name|arrayflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|val
decl_stmt|,
modifier|*
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|newid
decl_stmt|,
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*schar    %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sinteger    %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_INT
condition|)
break|break;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|modsym_aux
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_%s\t%d\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"int"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_BIT
case|:
case|case
name|YP_BITLIST
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sPE      %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sif (%s)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*spe_free (%s),\n%*s%s = NULLPE;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|YP_BITLIST
condition|)
break|break;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
operator|(
name|j
operator|=
name|val2int
argument_list|(
name|yv
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|pyyerror
argument_list|(
name|yp
argument_list|,
literal|"invalid bit number in BIT STRING"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|>
name|i
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
condition|)
block|{
comment|/* NBBY */
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t\"\\020"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"bits"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%o%s"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\\0%oBIT%d"
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
operator|+
literal|1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|modsym_aux
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s_%s\t%d\n"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"bit"
argument_list|)
argument_list|,
name|buf1
argument_list|,
name|val2int
argument_list|(
name|yv
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_REAL
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sdouble    %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_OCT
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct qbuf *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sif (%s)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sqb_free (%s),\n%*s%s = NULL;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_NULL
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*schar    %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQ
case|:
case|case
name|YP_SET
case|:
case|case
name|YP_ANY
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sPE      %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sif (%s)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*spe_free (%s),\n%*s%s = NULLPE;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETTYPE
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|buf2
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|dp
condition|)
name|cp
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|=
name|buf1
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
name|newid
operator|=
name|yp
operator|->
name|yp_ptrname
condition|?
name|yp
operator|->
name|yp_ptrname
else|:
name|id
expr_stmt|;
if|if
condition|(
name|h2flag
operator|&&
name|top
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sint\tnelem;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|id
operator|=
name|yp
operator|->
name|yp_structname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Hflag
condition|)
name|id
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2flag
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sint\tnelem;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
name|yp
operator|->
name|yp_declexp
operator|=
name|new_string
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|)
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
operator|&&
name|hflag
condition|)
block|{
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_identifier
argument_list|,
name|cp
operator|=
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|h2flag
condition|)
block|{
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"[n_%s]"
argument_list|,
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf3
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_CHOICE
case|:
case|case
name|YP_IDEFINED
case|:
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|h2flag
condition|?
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
else|:
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" -> %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
operator|!
name|top
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*s{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
if|if
condition|(
name|h2flag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sint     n_%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sstruct %s *%s = %s;\n\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|id
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sstruct %s *%s;\n\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h2flag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sfor (n_%s = 0;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sn_%s< %s -> nelem;\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sn_%s++) {\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|PARVAL
argument_list|(
name|yp
operator|->
name|yp_declexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sfor (%s = %s; %s;) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|buf1
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sstruct %s *f_%s = %s -> next;\n\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|top
condition|?
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|val
argument_list|,
literal|"type"
argument_list|)
else|:
name|id
argument_list|,
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|level
operator|++
expr_stmt|;
name|posy
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|cp
argument_list|,
name|ep
argument_list|,
name|buf2
argument_list|,
name|h2flag
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_code
operator|!=
name|YP_IDEFINED
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h2flag
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n%*sstruct %s *next;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|top
condition|?
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|val
argument_list|,
literal|"type"
argument_list|)
else|:
name|id
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
operator|!
name|h2flag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%*sif (%s)\n%*sfree ((char *) %s);"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%*s%s = f_%s;"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|h2flag
condition|)
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%*s%s = NULL;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%*s%s = NULL;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|top
condition|)
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s} *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|newid
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Hflag
condition|)
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|ep
operator|=
name|yp
operator|->
name|yp_code
operator|!=
name|YP_SETLIST
condition|?
literal|"element"
else|:
literal|"member"
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|buf2
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|dp
condition|)
name|cp
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|=
name|buf1
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
name|newid
operator|=
name|yp
operator|->
name|yp_ptrname
condition|?
name|yp
operator|->
name|yp_ptrname
else|:
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|id
operator|=
name|yp
operator|->
name|yp_structname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Hflag
condition|)
name|id
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sif (%s) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_REAL
case|:
case|case
name|YP_NULL
case|:
continue|continue;
default|default:
name|i
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|i
condition|)
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sstruct %s *%s = %s;\n\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|id
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_declexp
operator|=
name|new_string
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|,
name|i
operator|=
literal|0
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_OPTIONAL
condition|)
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
case|case
name|YP_INT
case|:
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_REAL
case|:
case|case
name|YP_NULL
case|:
block|{
name|char
name|obuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sint     optionals;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|cp
operator|=
name|buf1
argument_list|)
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%s_%s"
argument_list|,
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|top
condition|?
name|eval
else|:
name|id
argument_list|,
literal|"opt"
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s (0%08o)\n"
argument_list|,
name|obuf
argument_list|,
literal|1
operator|<<
name|i
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_optcontrol
operator|=
name|new_string
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_flags
operator||=
name|YP_OPTCONTROL
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|yyerror
argument_list|(
literal|"too many optionals in structure"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|,
name|i
operator|=
literal|1
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|cp
operator|=
name|buf1
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|gensym
argument_list|(
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" -> %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|posy
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|cp
argument_list|,
name|ep
argument_list|,
name|buf2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
operator|)
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_next
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*schar    dummy;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%*sif (%s)\n%*sfree ((char *) %s);\n%*s%s = NULL;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s} *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|newid
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Hflag
condition|)
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_CHOICE
case|:
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|buf2
argument_list|,
literal|' '
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|*
operator|++
name|dp
condition|)
name|cp
operator|=
name|dp
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dp
operator|=
name|buf1
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|cp
operator|-
name|buf2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
name|newid
operator|=
name|yp
operator|->
name|yp_ptrname
condition|?
name|yp
operator|->
name|yp_ptrname
else|:
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|id
operator|=
name|yp
operator|->
name|yp_structname
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Hflag
condition|)
name|id
operator|=
name|gensym
argument_list|(
literal|"choice"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sif (%s) {\n%*sstruct %s *%s = %s;\n\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf1
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|,
name|id
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_declexp
operator|=
name|new_string
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
argument_list|,
name|newid
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sint     offset;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sswitch (%s -> offset) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
condition|)
name|cp
operator|=
name|modsym
argument_list|(
name|mymodule
argument_list|,
name|val
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|id
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ep
operator|=
name|buf1
argument_list|,
literal|"%s_"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|strlen
argument_list|(
name|ep
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
operator|,
name|i
operator|=
literal|1
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|ep
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ep
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_offset
operator|=
name|new_string
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"#define\t%s\t%d\n"
argument_list|,
name|y
operator|->
name|yp_offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n%*sunion {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|modsym_aux
argument_list|(
name|y
operator|->
name|yp_id
argument_list|,
name|cp
operator|=
name|buf1
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|gensym
argument_list|(
literal|"choice"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*scase %s:\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" -> un.%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|posy
argument_list|(
name|y
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|cp
argument_list|,
literal|"choice"
argument_list|,
name|buf2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sbreak;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_next
condition|)
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_ID
operator|)
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|->
name|yp_next
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|level
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s}       un;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
block|{
name|level
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|=
name|buf2
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"\n%*sif (%s)\n%*sfree ((char *) %s);\n%*s%s = NULL;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s} *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|newid
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Hflag
condition|)
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_OID
case|:
if|if
condition|(
operator|!
name|top
condition|)
block|{
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sOID     %s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sif (%s)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*soid_free (%s),\n%*s%s = NULLOID;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|aflag
condition|)
name|printag
argument_list|(
name|yp
argument_list|,
name|level
operator|+
literal|4
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*sstruct %s *%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"type"
argument_list|)
argument_list|,
name|array
argument_list|(
name|id
argument_list|,
name|arrayflg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*sif (%s)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fact
argument_list|,
literal|"%*s%s (%s),\n%*s%s = NULL;\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|modsym
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|,
literal|"free"
argument_list|)
argument_list|,
name|buf2
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
name|yp
operator|->
name|yp_varexp
operator|=
name|new_string
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown type: %d"
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|printag
argument_list|(
name|yp
argument_list|,
name|level
argument_list|,
name|pullup
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pullup
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%*s/* "
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
operator|&&
name|strcmp
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|,
name|mymodule
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s."
argument_list|,
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s"
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|"%s"
argument_list|,
name|tags
index|[
name|yp
operator|->
name|yp_code
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pullup
condition|)
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|" pulled up from %s"
argument_list|,
name|pullup
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fdef
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|xalloc
argument_list|(
name|yp
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|arg
argument_list|,
name|type
argument_list|,
name|brackets
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|top
decl_stmt|,
name|level
decl_stmt|,
name|brackets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|didone
decl_stmt|;
specifier|register
name|YP
name|y
decl_stmt|;
if|if
condition|(
name|hflag
operator|&&
operator|!
name|arg
operator|&&
operator|!
name|type
condition|)
return|return;
name|didone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&&
name|type
condition|)
block|{
if|if
condition|(
name|brackets
operator|&&
operator|!
name|didone
condition|)
block|{
name|printf
argument_list|(
literal|"%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
operator|,
name|didone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|h2flag
operator|&&
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQTYPE
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_SETTYPE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%*s{\n%*sPE      xx_pe = prim2%s ($$);\n\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQTYPE
condition|?
literal|"seq"
else|:
literal|"set"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sn_%s = xx_pe -> pe_cardinal> 0 "
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"? xx_pe -> pe_cardinal : 0;\n%*s}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sif ((*(%s) = (struct %s *)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*scalloc (1 + (unsigned) n_%s, sizeof **(%s)"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")) == ((struct %s *) 0)) {\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s(*%s) -> nelem = n_%s;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sn_%s = 0;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%*sif ((*(%s) = (struct %s *)\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*scalloc (1, sizeof **(%s))) == ((struct %s *) 0)) {\n"
argument_list|,
operator|(
name|level
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|arg
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|top
condition|)
break|break;
case|case
name|YP_CHOICE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SETTYPE
case|:
if|if
condition|(
name|h2flag
operator|&&
operator|(
name|yp
operator|->
name|yp_code
operator|==
name|YP_SETLIST
operator|||
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQLIST
operator|)
condition|)
block|{
comment|/* include allocation here - no chance later */
if|if
condition|(
name|brackets
operator|&&
operator|!
name|didone
condition|)
block|{
name|printf
argument_list|(
literal|"%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
operator|,
name|didone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|->
name|yp_declexp
condition|)
name|printf
argument_list|(
literal|"%*s%s =&(%s);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
name|xalloc
argument_list|(
name|y
argument_list|,
name|top
argument_list|,
name|level
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* and continue ... */
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
if|if
condition|(
name|brackets
operator|&&
operator|!
name|didone
condition|)
block|{
name|printf
argument_list|(
literal|"%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
operator|,
name|didone
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*s%s =&(%s);\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|y
operator|->
name|yp_declexp
argument_list|,
name|y
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|brackets
operator|&&
name|didone
condition|)
block|{
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%%}\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|balloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|action2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%*sif ((%s%s = prim2bit (pe_cpy ($$))) == NULLPE) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
name|printf
argument_list|(
literal|"\n%*s%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%%}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_expr_stmt
specifier|static
name|qalloc
argument_list|(
name|yp
argument_list|,
name|var
argument_list|,
name|action2
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|action2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"\n%*s%%{\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%*sif ((%s%s = str2qb ($$, $$_len, 1)) == ((struct qbuf *) 0)) {\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sadvise (NULLCP, \"%%s\", PEPY_ERR_NOMEM);\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sreturn NOTOK;\n%*s}\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|action2
condition|)
name|printf
argument_list|(
literal|"\n%*s%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|action2
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%*s%%}"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|choice_pullup
argument_list|(
name|yp
argument_list|,
name|partial
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
modifier|*
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
modifier|*
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|z3
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|yp
operator|->
name|yp_type
init|;
name|y
operator|=
operator|*
name|x
condition|;
name|x
operator|=
operator|&
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
name|y
operator|->
name|yp_flags
operator|&
operator|(
name|YP_TAG
operator||
name|YP_BOUND
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
operator|(
name|z
operator|=
name|lookup_type
argument_list|(
name|y
operator|->
name|yp_module
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULLYP
operator|||
name|z
operator|->
name|yp_code
operator|!=
name|YP_CHOICE
condition|)
continue|continue;
name|choice_pullup
argument_list|(
name|z2
operator|=
name|copy_type
argument_list|(
name|z
argument_list|)
argument_list|,
name|CH_FULLY
argument_list|)
expr_stmt|;
goto|goto
name|patch
goto|;
case|case
name|YP_CHOICE
case|:
name|choice_pullup
argument_list|(
name|z2
operator|=
name|copy_type
argument_list|(
name|y
argument_list|)
argument_list|,
name|CH_FULLY
argument_list|)
expr_stmt|;
name|patch
label|:
empty_stmt|;
if|if
condition|(
name|partial
condition|)
block|{
operator|*
name|x
operator|=
name|z2
expr_stmt|;
name|z2
operator|->
name|yp_next
operator|=
name|y
operator|->
name|yp_next
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
continue|continue;
block|}
name|z
operator|=
name|z3
operator|=
name|z2
operator|->
name|yp_type
expr_stmt|;
for|for
control|(
name|z1
operator|=
operator|&
name|z
operator|->
name|yp_next
init|;
name|z2
operator|=
operator|*
name|z1
condition|;
name|z1
operator|=
operator|&
name|z2
operator|->
name|yp_next
control|)
name|z3
operator|=
name|z2
expr_stmt|;
operator|*
name|z1
operator|=
name|y
operator|->
name|yp_next
expr_stmt|;
operator|*
name|x
operator|=
name|z
expr_stmt|;
name|y
operator|=
name|z3
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|components_pullup
argument_list|(
name|yp
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|YP
modifier|*
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|z1
decl_stmt|,
name|z2
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|yp
operator|->
name|yp_type
init|;
name|y
operator|=
operator|*
name|x
condition|;
name|x
operator|=
operator|&
name|y
operator|->
name|yp_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|y
operator|->
name|yp_flags
operator|&
name|YP_COMPONENTS
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|y
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETLIST
case|:
name|z
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
operator|(
name|z
operator|=
name|lookup_type
argument_list|(
name|y
operator|->
name|yp_module
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
block|{
name|warning
argument_list|(
literal|"COMPONENTS OF target \"%s\" is undefined"
argument_list|,
name|y
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_code
operator|!=
name|z
operator|->
name|yp_code
condition|)
block|{
name|warning
argument_list|(
literal|"COMPONENTS OF target \"%s\" is wrong type, should be %s"
argument_list|,
name|y
operator|->
name|yp_code
operator|==
name|YP_IDEFINED
condition|?
name|y
operator|->
name|yp_identifier
else|:
name|y
operator|->
name|yp_id
condition|?
name|y
operator|->
name|yp_id
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
operator|==
name|YP_SEQLIST
condition|?
literal|"SEQUENCE"
else|:
literal|"SET"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|z
operator|->
name|yp_type
operator|==
name|NULLYP
condition|)
continue|continue;
name|components_pullup
argument_list|(
name|z
operator|=
name|copy_type
argument_list|(
name|z
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|x
operator|=
name|z2
operator|=
name|z
operator|->
name|yp_type
expr_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|z
operator|->
name|yp_type
init|;
name|z1
operator|=
operator|*
name|x
condition|;
name|x
operator|=
operator|&
name|z1
operator|->
name|yp_next
control|)
name|z2
operator|=
name|z1
expr_stmt|;
operator|*
name|x
operator|=
name|y
operator|->
name|yp_next
expr_stmt|;
name|y
operator|=
name|z2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|VALUE HANDLING */
end_comment

begin_function
specifier|static
name|int
name|val2int
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|double
name|val2real
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_REAL
case|:
return|return
name|yv
operator|->
name|yv_real
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|val2prf
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
comment|/* will this REALLY work??? */
name|do_type1
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
name|printf
argument_list|(
name|yv
operator|->
name|yv_number
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NUMBER
case|:
if|if
condition|(
name|yv
operator|->
name|yv_named
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_REAL
case|:
name|dump_real
argument_list|(
name|yv
operator|->
name|yv_real
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_module
condition|)
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|val2prf
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|y
operator|->
name|yv_next
condition|?
literal|", "
else|:
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_NULL
case|:
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|dump_real
argument_list|(
argument|r
argument_list|)
name|double
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|BSD44
specifier|extern
name|char
modifier|*
name|ecvt
parameter_list|()
function_decl|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|decpt
decl_stmt|,
name|sign
decl_stmt|;
name|cp
operator|=
name|ecvt
argument_list|(
name|r
argument_list|,
literal|20
argument_list|,
operator|&
name|decpt
argument_list|,
operator|&
name|sign
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* cp gets overwritten by printf */
name|printf
argument_list|(
literal|"{ %s%s, 10, %d }"
argument_list|,
name|sign
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|sbuf
argument_list|,
name|decpt
operator|-
name|strlen
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|char
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%.19e"
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|dp
operator|=
name|sbuf
operator|)
operator|==
literal|'-'
condition|)
name|sp
operator|=
literal|"-"
operator|,
name|dp
operator|++
expr_stmt|;
else|else
name|sp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|cp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"{ 0, 10, 0 } -- %s --"
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|++
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"{ %s%c%s, 10, %d }"
argument_list|,
name|sp
argument_list|,
operator|*
name|dp
argument_list|,
name|dp
operator|+
literal|2
argument_list|,
name|atoi
argument_list|(
name|cp
argument_list|)
operator|-
name|strlen
argument_list|(
name|dp
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dfl2int
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|,
name|y
decl_stmt|;
name|yv
operator|=
name|yp
operator|->
name|yp_default
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_BOOL
case|:
case|case
name|YV_NUMBER
case|:
return|return
name|yv
operator|->
name|yv_number
return|;
case|case
name|YV_STRING
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a string"
argument_list|)
expr_stmt|;
case|case
name|YV_REAL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not a real"
argument_list|)
expr_stmt|;
case|case
name|YV_IDEFINED
case|:
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_value
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
if|if
condition|(
name|y
operator|->
name|yv_code
operator|==
name|YV_NUMBER
operator|&&
operator|(
name|y
operator|->
name|yv_flags
operator|&
name|YV_NAMED
operator|)
operator|&&
name|strcmp
argument_list|(
name|yv
operator|->
name|yv_identifier
argument_list|,
name|y
operator|->
name|yv_named
argument_list|)
operator|==
literal|0
condition|)
return|return
name|y
operator|->
name|yv_number
return|;
comment|/* and fall */
case|case
name|YV_IDLIST
case|:
name|yyerror
argument_list|(
literal|"haven't written symbol table for values yet"
argument_list|)
expr_stmt|;
case|case
name|YV_NULL
case|:
name|yyerror
argument_list|(
literal|"need an integer, not NULL"
argument_list|)
expr_stmt|;
default|default:
name|myyerror
argument_list|(
literal|"unknown value: %d"
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|DEBUG */
end_comment

begin_expr_stmt
name|print_type
argument_list|(
name|yp
argument_list|,
name|level
argument_list|)
specifier|register
name|YP
name|yp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YP
name|y
decl_stmt|;
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s direction=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_code
argument_list|,
name|sprintb
argument_list|(
name|yp
operator|->
name|yp_flags
argument_list|,
name|YPBITS
argument_list|)
argument_list|,
name|yp
operator|->
name|yp_direction
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sintexp=\"%s\" strexp=\"%s\" prfexp=0%o declexp=\"%s\" varexp=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_intexp
argument_list|,
name|yp
operator|->
name|yp_strexp
argument_list|,
name|yp
operator|->
name|yp_prfexp
argument_list|,
name|yp
operator|->
name|yp_declexp
argument_list|,
name|yp
operator|->
name|yp_varexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sparameter type=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction0 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act0_lineno
argument_list|,
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action05
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction05 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act05_lineno
argument_list|,
name|yp
operator|->
name|yp_action05
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction1 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act1_lineno
argument_list|,
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction2 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act2_lineno
argument_list|,
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction3 at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_act3_lineno
argument_list|,
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stag class=0x%x value=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_class
argument_list|,
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_tag
operator|->
name|yt_value
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sdefault=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*soffset=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_BITLIST
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*svalue=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
for|for
control|(
name|yv
operator|=
name|yp
operator|->
name|yp_value
init|;
name|yv
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
name|yp
operator|->
name|yp_type
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yp_next
control|)
block|{
name|print_type
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YP_IDEFINED
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yp
operator|->
name|yp_module
condition|?
name|yp
operator|->
name|yp_module
else|:
literal|""
argument_list|,
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|print_value
argument_list|(
name|yv
argument_list|,
name|level
argument_list|)
specifier|register
name|YV
name|yv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*scode=0x%x flags=%s\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_code
argument_list|,
name|sprintb
argument_list|(
name|yv
operator|->
name|yv_flags
argument_list|,
name|YVBITS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*saction at line %d=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_act_lineno
argument_list|,
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sid=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snamed=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*stype=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*snumber=0x%x\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sstring=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_BOUND
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*smodule=\"%s\" identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_module
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*sbound identifier=\"%s\"\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
for|for
control|(
name|y
operator|=
name|yv
operator|->
name|yv_idlist
init|;
name|y
condition|;
name|y
operator|=
name|y
operator|->
name|yv_next
control|)
block|{
name|print_value
argument_list|(
name|y
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s----\n"
argument_list|,
operator|(
name|level
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_function
specifier|static
name|SY
name|new_symbol
parameter_list|(
name|encpref
parameter_list|,
name|decpref
parameter_list|,
name|prfpref
parameter_list|,
name|mod
parameter_list|,
name|id
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
name|encpref
decl_stmt|,
decl|*
name|decpref
decl_stmt|,
modifier|*
name|prfpref
decl_stmt|,
modifier|*
name|mod
decl_stmt|,
modifier|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|YP
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
operator|(
name|sy
operator|=
operator|(
name|SY
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|sy
argument_list|)
operator|)
operator|==
name|NULLSY
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|sy
operator|->
name|sy_encpref
operator|=
name|encpref
expr_stmt|;
name|sy
operator|->
name|sy_decpref
operator|=
name|decpref
expr_stmt|;
name|sy
operator|->
name|sy_prfpref
operator|=
name|prfpref
expr_stmt|;
name|sy
operator|->
name|sy_module
operator|=
name|mod
expr_stmt|;
name|sy
operator|->
name|sy_name
operator|=
name|id
expr_stmt|;
name|sy
operator|->
name|sy_type
operator|=
name|type
expr_stmt|;
return|return
name|sy
return|;
block|}
end_block

begin_function
specifier|static
name|SY
name|add_symbol
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|SY
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
specifier|register
name|SY
name|sy
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULLSY
condition|)
return|return
name|s2
return|;
for|for
control|(
name|sy
operator|=
name|s1
init|;
name|sy
operator|->
name|sy_next
condition|;
name|sy
operator|=
name|sy
operator|->
name|sy_next
control|)
continue|continue;
name|sy
operator|->
name|sy_next
operator|=
name|s2
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_comment
comment|/*
comment|MODULES */
end_comment

begin_function
specifier|static
name|MD
name|lookup_module
parameter_list|(
name|module
parameter_list|)
name|char
modifier|*
name|module
decl_stmt|;
block|{
specifier|register
name|MD
name|md
decl_stmt|;
for|for
control|(
name|md
operator|=
name|mymodules
init|;
name|md
condition|;
name|md
operator|=
name|md
operator|->
name|md_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|->
name|md_module
argument_list|,
name|module
argument_list|)
operator|==
literal|0
condition|)
return|return
name|md
return|;
if|if
condition|(
operator|(
name|md
operator|=
operator|(
name|MD
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|md
argument_list|)
operator|)
operator|==
name|NULLMD
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_module
operator|=
name|new_string
argument_list|(
name|module
argument_list|)
expr_stmt|;
if|if
condition|(
name|mymodules
operator|!=
name|NULLMD
condition|)
name|md
operator|->
name|md_next
operator|=
name|mymodules
expr_stmt|;
name|mymodules
operator|=
name|md
expr_stmt|;
return|return
name|NULLMD
return|;
block|}
end_function

begin_comment
comment|/*
comment|TYPES */
end_comment

begin_function
name|YP
name|new_type
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
if|if
condition|(
operator|(
name|yp
operator|=
operator|(
name|YP
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yp
argument_list|)
operator|)
operator|==
name|NULLYP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yp
operator|->
name|yp_code
operator|=
name|code
expr_stmt|;
return|return
name|yp
return|;
block|}
end_function

begin_function
name|YP
name|add_type
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YP
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YP
name|yp
decl_stmt|;
for|for
control|(
name|yp
operator|=
name|y
init|;
name|yp
operator|->
name|yp_next
condition|;
name|yp
operator|=
name|yp
operator|->
name|yp_next
control|)
continue|continue;
name|yp
operator|->
name|yp_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YP
name|copy_type
parameter_list|(
name|yp
parameter_list|)
specifier|register
name|YP
name|yp
decl_stmt|;
block|{
specifier|register
name|YP
name|y
decl_stmt|;
if|if
condition|(
name|yp
operator|==
name|NULLYP
condition|)
return|return
name|NULLYP
return|;
name|y
operator|=
name|new_type
argument_list|(
name|yp
operator|->
name|yp_code
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_direction
operator|=
name|yp
operator|->
name|yp_direction
expr_stmt|;
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_IDEFINED
case|:
if|if
condition|(
name|yp
operator|->
name|yp_module
condition|)
name|y
operator|->
name|yp_module
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_module
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_identifier
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_identifier
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_modid
operator|=
name|oid_cpy
argument_list|(
name|yp
operator|->
name|yp_modid
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_SEQTYPE
case|:
case|case
name|YP_SEQLIST
case|:
case|case
name|YP_SETTYPE
case|:
case|case
name|YP_SETLIST
case|:
case|case
name|YP_CHOICE
case|:
name|y
operator|->
name|yp_type
operator|=
name|copy_type
argument_list|(
name|yp
operator|->
name|yp_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
case|case
name|YP_BITLIST
case|:
name|y
operator|->
name|yp_value
operator|=
name|copy_value
argument_list|(
name|yp
operator|->
name|yp_value
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|y
operator|->
name|yp_intexp
operator|=
name|yp
operator|->
name|yp_intexp
expr_stmt|;
name|y
operator|->
name|yp_strexp
operator|=
name|yp
operator|->
name|yp_strexp
expr_stmt|;
name|y
operator|->
name|yp_prfexp
operator|=
name|yp
operator|->
name|yp_prfexp
expr_stmt|;
name|y
operator|->
name|yp_declexp
operator|=
name|yp
operator|->
name|yp_declexp
expr_stmt|;
name|y
operator|->
name|yp_varexp
operator|=
name|yp
operator|->
name|yp_varexp
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_structname
condition|)
name|y
operator|->
name|yp_structname
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_structname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_ptrname
condition|)
name|y
operator|->
name|yp_ptrname
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_ptrname
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_param_type
condition|)
name|y
operator|->
name|yp_param_type
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_action0
condition|)
block|{
name|y
operator|->
name|yp_action0
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action0
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act0_lineno
operator|=
name|yp
operator|->
name|yp_act0_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action05
condition|)
block|{
name|y
operator|->
name|yp_action05
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action05
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act05_lineno
operator|=
name|yp
operator|->
name|yp_act05_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action1
condition|)
block|{
name|y
operator|->
name|yp_action1
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action1
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act1_lineno
operator|=
name|yp
operator|->
name|yp_act1_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action2
condition|)
block|{
name|y
operator|->
name|yp_action2
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action2
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act2_lineno
operator|=
name|yp
operator|->
name|yp_act2_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yp
operator|->
name|yp_action3
condition|)
block|{
name|y
operator|->
name|yp_action3
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_action3
argument_list|)
expr_stmt|;
name|y
operator|->
name|yp_act3_lineno
operator|=
name|yp
operator|->
name|yp_act3_lineno
expr_stmt|;
block|}
name|y
operator|->
name|yp_flags
operator|=
name|yp
operator|->
name|yp_flags
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_DEFAULT
condition|)
name|y
operator|->
name|yp_default
operator|=
name|copy_value
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_ID
condition|)
name|y
operator|->
name|yp_id
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_TAG
condition|)
name|y
operator|->
name|yp_tag
operator|=
name|copy_tag
argument_list|(
name|yp
operator|->
name|yp_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_BOUND
condition|)
name|y
operator|->
name|yp_bound
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_PARMVAL
condition|)
name|y
operator|->
name|yp_parm
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_CONTROLLED
condition|)
name|y
operator|->
name|yp_control
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_flags
operator|&
name|YP_OPTCONTROL
condition|)
name|y
operator|->
name|yp_optcontrol
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_optcontrol
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_offset
condition|)
name|y
operator|->
name|yp_offset
operator|=
name|new_string
argument_list|(
name|yp
operator|->
name|yp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|yp
operator|->
name|yp_next
condition|)
name|y
operator|->
name|yp_next
operator|=
name|copy_type
argument_list|(
name|yp
operator|->
name|yp_next
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|VALUES */
end_comment

begin_function
name|YV
name|new_value
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
if|if
condition|(
operator|(
name|yv
operator|=
operator|(
name|YV
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yv
argument_list|)
operator|)
operator|==
name|NULLYV
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yv
operator|->
name|yv_code
operator|=
name|code
expr_stmt|;
return|return
name|yv
return|;
block|}
end_function

begin_function
name|YV
name|add_value
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
specifier|register
name|YV
name|y
decl_stmt|,
name|z
decl_stmt|;
block|{
specifier|register
name|YV
name|yv
decl_stmt|;
for|for
control|(
name|yv
operator|=
name|y
init|;
name|yv
operator|->
name|yv_next
condition|;
name|yv
operator|=
name|yv
operator|->
name|yv_next
control|)
continue|continue;
name|yv
operator|->
name|yv_next
operator|=
name|z
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YV
name|copy_value
parameter_list|(
name|yv
parameter_list|)
specifier|register
name|YV
name|yv
decl_stmt|;
block|{
specifier|register
name|YV
name|y
decl_stmt|;
if|if
condition|(
name|yv
operator|==
name|NULLYV
condition|)
return|return
name|NULLYV
return|;
name|y
operator|=
name|new_value
argument_list|(
name|yv
operator|->
name|yv_code
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_flags
operator|=
name|yv
operator|->
name|yv_flags
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_action
condition|)
block|{
name|y
operator|->
name|yv_action
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_action
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_act_lineno
operator|=
name|yv
operator|->
name|yv_act_lineno
expr_stmt|;
block|}
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_ID
condition|)
name|y
operator|->
name|yv_id
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_NAMED
condition|)
name|y
operator|->
name|yv_named
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_named
argument_list|)
expr_stmt|;
if|if
condition|(
name|yv
operator|->
name|yv_flags
operator|&
name|YV_TYPE
condition|)
name|y
operator|->
name|yv_type
operator|=
name|copy_type
argument_list|(
name|yv
operator|->
name|yv_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yv
operator|->
name|yv_code
condition|)
block|{
case|case
name|YV_NUMBER
case|:
case|case
name|YV_BOOL
case|:
name|y
operator|->
name|yv_number
operator|=
name|yv
operator|->
name|yv_number
expr_stmt|;
break|break;
case|case
name|YV_STRING
case|:
name|y
operator|->
name|yv_string
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDEFINED
case|:
if|if
condition|(
name|yv
operator|->
name|yv_module
condition|)
name|y
operator|->
name|yv_module
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_module
argument_list|)
expr_stmt|;
name|y
operator|->
name|yv_identifier
operator|=
name|new_string
argument_list|(
name|yv
operator|->
name|yv_identifier
argument_list|)
expr_stmt|;
break|break;
case|case
name|YV_IDLIST
case|:
case|case
name|YV_VALIST
case|:
name|y
operator|->
name|yv_idlist
operator|=
name|copy_value
argument_list|(
name|yv
operator|->
name|yv_idlist
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|yv
operator|->
name|yv_next
condition|)
name|y
operator|->
name|yv_next
operator|=
name|copy_value
argument_list|(
name|yv
operator|->
name|yv_next
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|TAGS */
end_comment

begin_function
name|YT
name|new_tag
parameter_list|(
name|class
parameter_list|)
name|PElementClass
name|class
decl_stmt|;
block|{
specifier|register
name|YT
name|yt
decl_stmt|;
if|if
condition|(
operator|(
name|yt
operator|=
operator|(
name|YT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|yt
argument_list|)
operator|)
operator|==
name|NULLYT
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|yt
operator|->
name|yt_class
operator|=
name|class
expr_stmt|;
return|return
name|yt
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|YT
name|copy_tag
parameter_list|(
name|yt
parameter_list|)
specifier|register
name|YT
name|yt
decl_stmt|;
block|{
specifier|register
name|YT
name|y
decl_stmt|;
if|if
condition|(
name|yt
operator|==
name|NULLYT
condition|)
return|return
name|NULLYT
return|;
name|y
operator|=
name|new_tag
argument_list|(
name|yt
operator|->
name|yt_class
argument_list|)
expr_stmt|;
name|y
operator|->
name|yt_value
operator|=
name|copy_value
argument_list|(
name|yt
operator|->
name|yt_value
argument_list|)
expr_stmt|;
return|return
name|y
return|;
block|}
end_function

begin_comment
comment|/*
comment|STRINGS */
end_comment

begin_function
name|char
modifier|*
name|new_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*
comment|SYMBOLS */
end_comment

begin_struct
specifier|static
struct|struct
name|triple
block|{
name|char
modifier|*
name|t_name
decl_stmt|;
name|PElementClass
name|t_class
decl_stmt|;
name|PElementID
name|t_id
decl_stmt|;
block|}
name|triples
index|[]
init|=
block|{
literal|"IA5String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"ISO646String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_IA5S
block|,
literal|"NumericString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_NUMS
block|,
literal|"PrintableString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_PRTS
block|,
literal|"T61String"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"TeletexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_T61S
block|,
literal|"VideotexString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VTXS
block|,
literal|"GeneralizedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"GeneralisedTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENT
block|,
literal|"UTCTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"UniversalTime"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_UTCT
block|,
literal|"GraphicString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GFXS
block|,
literal|"VisibleString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_VISS
block|,
literal|"GeneralString"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_DEFN_GENS
block|,
literal|"EXTERNAL"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_CONS_EXTN
block|,
literal|"ObjectDescriptor"
block|,
name|PE_CLASS_UNIV
block|,
name|PE_PRIM_ODE
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|modsym
parameter_list|(
name|module
parameter_list|,
name|id
parameter_list|,
name|prefix
parameter_list|)
specifier|register
name|char
modifier|*
name|module
decl_stmt|,
decl|*
name|id
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|triple
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|module
operator|==
name|NULLCP
condition|)
for|for
control|(
name|t
operator|=
name|triples
init|;
name|t
operator|->
name|t_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|t_name
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|module
operator|=
literal|"UNIV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prefix
condition|)
name|modsym_aux
argument_list|(
name|prefix
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|module
condition|?
name|module
else|:
name|mymodule
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|modsym_aux
argument_list|(
name|id
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s"
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|modsym_aux
argument_list|(
name|name
argument_list|,
name|bp
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'-'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'_'
expr_stmt|;
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gensym
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|a
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|int
name|cP
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|eP
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|mP
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'c'
case|:
name|i
operator|=
name|cP
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|i
operator|=
name|eP
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|i
operator|=
name|mP
operator|++
expr_stmt|;
break|break;
default|default:
name|myyerror
argument_list|(
literal|"unknown gensym argument \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|a
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%d[n_%s]"
argument_list|,
name|s
argument_list|,
name|modulename
argument_list|,
name|i
argument_list|,
name|a
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s_%s_%d"
argument_list|,
name|s
argument_list|,
name|modulename
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|11
argument_list|)
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_comment
comment|/* pepy compatible routines - you know how it is ... */
end_comment

begin_macro
name|init_new_file
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_macro
name|end_file
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|array
parameter_list|(
name|s
parameter_list|,
name|flg
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|flg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|flg
condition|)
return|return
name|s
return|;
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'['
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%*.*s[1]"
argument_list|,
name|p
operator|-
name|s
argument_list|,
name|p
operator|-
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prime_default
parameter_list|(
name|yp
parameter_list|,
name|level
parameter_list|)
name|YP
name|yp
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
switch|switch
condition|(
name|yp
operator|->
name|yp_code
condition|)
block|{
case|case
name|YP_BOOL
case|:
name|printf
argument_list|(
literal|"%*s%s = %d;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INT
case|:
name|printf
argument_list|(
literal|"%*s%s = %d;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2int
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_INTLIST
case|:
case|case
name|YP_ENUMLIST
case|:
name|printf
argument_list|(
literal|"%*s%s = %d;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|dfl2int
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|YP_REAL
case|:
name|printf
argument_list|(
literal|"%*s%s = %g;\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|SVAL
argument_list|(
name|yp
operator|->
name|yp_varexp
argument_list|)
argument_list|,
name|val2real
argument_list|(
name|yp
operator|->
name|yp_default
argument_list|)
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

end_unit

