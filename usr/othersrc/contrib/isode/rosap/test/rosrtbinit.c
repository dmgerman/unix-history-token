begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"generic.h"
end_include

begin_comment
comment|/* defines OPERATIONS and ERRORS */
end_comment

begin_include
include|#
directive|include
file|<isode/rtsap.h>
end_include

begin_include
include|#
directive|include
file|<isode/rosap.h>
end_include

begin_include
include|#
directive|include
file|<isode/isoservent.h>
end_include

begin_define
define|#
directive|define
name|error
value|printf
end_define

begin_comment
comment|/* e.g., "directory" */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myservice
init|=
literal|"ROSRTBTEST"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* e.g., "directory services" */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mycontext
init|=
literal|"isode chic read"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mypci
init|=
literal|"isode chic read pci"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INVOKE
value|1
end_define

begin_comment
comment|/* do a RoInvokeRequest */
end_comment

begin_define
define|#
directive|define
name|INTREQ
value|2
end_define

begin_comment
comment|/* do a RoIntrRequest */
end_comment

begin_define
define|#
directive|define
name|INVERR
value|3
end_define

begin_comment
comment|/* request an error */
end_comment

begin_define
define|#
directive|define
name|INVURJ
value|4
end_define

begin_comment
comment|/* request a user reject */
end_comment

begin_define
define|#
directive|define
name|INVPRJ
value|5
end_define

begin_comment
comment|/* request a provider reject */
end_comment

begin_define
define|#
directive|define
name|TIMEOUT
value|30
end_define

begin_comment
comment|/* seconds before RtWait times out */
end_comment

begin_function_decl
specifier|extern
name|struct
name|isoservent
modifier|*
name|getisoserventbyname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|PE
name|mkpelist
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|sd
decl_stmt|;
if|#
directive|if
literal|0
block|struct SSAPref sfs;     register struct SSAPref *sf;     register struct PSAPaddr *pa;     struct AcSAPconnect accs;     register struct AcSAPconnect   *acc =&accs;     struct AcSAPrelease acrs;     register struct AcSAPrelease   *acr =&acrs;     struct AcSAPindication  acis;     register struct AcSAPindication *aci =&acis;     register struct AcSAPabort *aca =&aci -> aci_abort;     register AEI aei;     register OID ctx, pci;     struct PSAPctxlist pcs;     register struct PSAPctxlist *pc =&pcs;
endif|#
directive|endif
name|struct
name|RtSAPaddr
name|rtas
decl_stmt|;
name|struct
name|isoservent
modifier|*
name|is
decl_stmt|;
name|struct
name|SSAPaddr
modifier|*
name|psa
decl_stmt|;
name|struct
name|RtSAPindication
name|rtis
decl_stmt|;
specifier|register
name|struct
name|RtSAPindication
modifier|*
name|rti
init|=
operator|&
name|rtis
decl_stmt|;
name|struct
name|RtSAPconnect
name|rtcs
decl_stmt|;
specifier|register
name|struct
name|RtSAPconnect
modifier|*
name|rtc
init|=
operator|&
name|rtcs
decl_stmt|;
specifier|register
name|struct
name|RtSAPabort
modifier|*
name|rta
init|=
operator|&
name|rti
operator|->
name|rti_abort
decl_stmt|;
name|struct
name|RoSAPindication
name|rois
decl_stmt|;
specifier|register
name|struct
name|RoSAPpreject
modifier|*
name|rop
init|=
operator|&
name|rois
operator|.
name|roi_preject
decl_stmt|;
if|if
condition|(
operator|(
name|is
operator|=
name|getisoserventbyname
argument_list|(
name|myservice
argument_list|,
literal|"rtsap"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't find %s/rosap"
argument_list|,
name|myservice
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rtas
operator|.
name|rta_port
operator|=
name|is
operator|->
name|is_port
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Need an arguement of a hostname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* This is an different to the manual which is wrong!       */
if|if
condition|(
operator|(
name|is
operator|=
name|getisoserventbyname
argument_list|(
literal|"rts"
argument_list|,
literal|"ssap"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't find ssap/rts"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|psa
operator|=
name|is2saddr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULLCP
argument_list|,
operator|(
expr|struct
name|isoservent
operator|*
operator|)
name|is
argument_list|)
operator|)
operator|==
name|NULLSA
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't compute address to %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|rtas
operator|.
name|rta_addr
operator|=
operator|*
name|psa
expr_stmt|;
comment|/* struct copy */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RT-OPEN.REQUEST:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RtBeginRequest
argument_list|(
operator|&
name|rtas
argument_list|,
name|RTS_TWA
argument_list|,
name|RTS_INITIATOR
argument_list|,
name|NULLPE
argument_list|,
name|rtc
argument_list|,
name|rti
argument_list|)
operator|==
name|NOTOK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RT-OPEN.REQUEST: %s"
argument_list|,
name|RtErrString
argument_list|(
name|rta
operator|->
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtc
operator|->
name|rtc_result
operator|!=
name|RTS_ACCEPT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"association rejected: %s"
argument_list|,
name|RtErrString
argument_list|(
name|rta
operator|->
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|=
name|rtc
operator|->
name|rtc_sd
expr_stmt|;
name|RTCFREE
argument_list|(
name|rtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|RoSetService
argument_list|(
name|sd
argument_list|,
name|RoRtService
argument_list|,
operator|&
name|rois
argument_list|)
operator|==
name|NOTOK
condition|)
name|error
argument_list|(
literal|"RoSetService: %s"
argument_list|,
name|RoErrString
argument_list|(
name|rop
operator|->
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
name|invoke
argument_list|(
name|sd
argument_list|,
name|INVOKE
argument_list|)
expr_stmt|;
comment|/* invoke the operations, etc. */
name|invoke
argument_list|(
name|sd
argument_list|,
name|INTREQ
argument_list|)
expr_stmt|;
comment|/* invoke the operations, etc. */
name|invoke
argument_list|(
name|sd
argument_list|,
name|INVERR
argument_list|)
expr_stmt|;
comment|/* invoke the operations, etc. */
name|invoke
argument_list|(
name|sd
argument_list|,
name|INVURJ
argument_list|)
expr_stmt|;
comment|/* invoke the operations, etc. */
name|invoke
argument_list|(
name|sd
argument_list|,
name|INVPRJ
argument_list|)
expr_stmt|;
comment|/* invoke the operations, etc. */
comment|/* All this appears to be neccessary because you need the turn to terminate      * nicely. But we don't have the turn, I presume the responder has kept it      * from when they replyed to our request      */
if|if
condition|(
name|RtPTurnRequest
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|,
operator|&
name|rtis
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SEND_PLS:RT-PLEASE-TURN.REQUEST: %s\n"
argument_list|,
name|RtErrString
argument_list|(
name|rtis
operator|.
name|rti_abort
operator|.
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RtWaitRequest
argument_list|(
name|sd
argument_list|,
name|TIMEOUT
argument_list|,
operator|&
name|rtis
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RtWaitRequest: %s\n"
argument_list|,
name|RtErrString
argument_list|(
name|rtis
operator|.
name|rti_abort
operator|.
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rtis
operator|.
name|rti_type
condition|)
block|{
case|case
name|RTI_TURN
case|:
comment|/* Okay we got it */
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected response %d\n"
argument_list|,
name|rtis
operator|.
name|rti_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/* Now we can close */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RT-CLOSE.REQUEST:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RtEndRequest
argument_list|(
name|sd
argument_list|,
operator|&
name|rtis
argument_list|)
operator|==
name|NOTOK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RT-CLOSE.REQUEST: %s\n"
argument_list|,
name|RtErrString
argument_list|(
name|rtis
operator|.
name|rti_abort
operator|.
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Test example  */
end_comment

begin_macro
name|invoke
argument_list|(
argument|sd
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* of invocation */
end_comment

begin_block
block|{
name|int
name|invoke
decl_stmt|;
name|struct
name|RoSAPindication
name|rind
decl_stmt|;
name|int
name|res
decl_stmt|;
name|PE
name|data
decl_stmt|;
name|invoke
operator|=
literal|1
expr_stmt|;
name|data
operator|=
name|mkpelist
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INVOKE
case|:
name|res
operator|=
name|RoInvokeRequest
argument_list|(
name|sd
argument_list|,
name|APDU_OP1
argument_list|,
name|ROS_SYNC
argument_list|,
name|data
argument_list|,
name|invoke
argument_list|,
name|NULLIP
argument_list|,
name|ROS_NOPRIO
argument_list|,
operator|&
name|rind
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTREQ
case|:
name|res
operator|=
name|RoIntrRequest
argument_list|(
name|sd
argument_list|,
name|APDU_OP1
argument_list|,
name|data
argument_list|,
name|invoke
argument_list|,
name|NULLIP
argument_list|,
name|ROS_NOPRIO
argument_list|,
operator|&
name|rind
argument_list|)
expr_stmt|;
break|break;
case|case
name|INVERR
case|:
name|res
operator|=
name|RoInvokeRequest
argument_list|(
name|sd
argument_list|,
name|APDU_ERR
argument_list|,
name|ROS_SYNC
argument_list|,
name|data
argument_list|,
name|invoke
argument_list|,
name|NULLIP
argument_list|,
name|ROS_NOPRIO
argument_list|,
operator|&
name|rind
argument_list|)
expr_stmt|;
break|break;
case|case
name|INVURJ
case|:
name|res
operator|=
name|RoInvokeRequest
argument_list|(
name|sd
argument_list|,
name|APDU_URJ
argument_list|,
name|ROS_SYNC
argument_list|,
name|data
argument_list|,
name|invoke
argument_list|,
name|NULLIP
argument_list|,
name|ROS_NOPRIO
argument_list|,
operator|&
name|rind
argument_list|)
expr_stmt|;
break|break;
case|case
name|INVPRJ
case|:
name|res
operator|=
name|RoInvokeRequest
argument_list|(
name|sd
argument_list|,
name|APDU_PRJ
argument_list|,
name|ROS_SYNC
argument_list|,
name|data
argument_list|,
name|invoke
argument_list|,
name|NULLIP
argument_list|,
name|ROS_NOPRIO
argument_list|,
operator|&
name|rind
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invoke called with illegal type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|NOTOK
case|:
if|if
condition|(
name|rind
operator|.
name|roi_type
operator|==
name|ROI_PREJECT
condition|)
name|error
argument_list|(
literal|"RO-INVOKE.REQUEST: %s\n"
argument_list|,
name|RoErrString
argument_list|(
name|rind
operator|.
name|roi_preject
operator|.
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"RO-INVOKE.REQUEST:failed: unexpected returned type %d\n"
argument_list|,
name|rind
operator|.
name|roi_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"RO-INVOKE.REQUEST:failed(%d): unexpected returned type %d\n"
argument_list|,
name|res
argument_list|,
name|rind
operator|.
name|roi_type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|rind
operator|.
name|roi_type
condition|)
block|{
case|case
name|ROI_RESULT
case|:
if|if
condition|(
name|rind
operator|.
name|roi_result
operator|.
name|ror_id
operator|==
name|invoke
condition|)
name|printf
argument_list|(
literal|"Result received\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Result for wrong request %d\n"
argument_list|,
name|rind
operator|.
name|roi_result
operator|.
name|ror_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_ERROR
case|:
if|if
condition|(
name|rind
operator|.
name|roi_error
operator|.
name|roe_id
operator|==
name|invoke
condition|)
name|printf
argument_list|(
literal|"Error received\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Error for wrong request %d\n"
argument_list|,
name|rind
operator|.
name|roi_error
operator|.
name|roe_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_UREJECT
case|:
if|if
condition|(
name|rind
operator|.
name|roi_ureject
operator|.
name|rou_id
operator|==
name|invoke
condition|)
name|printf
argument_list|(
literal|"User Reject received reason %d\n"
argument_list|,
name|rind
operator|.
name|roi_ureject
operator|.
name|rou_reason
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"User Reject for wrong request %d\n"
argument_list|,
name|rind
operator|.
name|roi_ureject
operator|.
name|rou_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROI_PREJECT
case|:
if|if
condition|(
name|rind
operator|.
name|roi_preject
operator|.
name|rop_id
operator|==
name|invoke
condition|)
name|printf
argument_list|(
literal|"Provider Reject received %s\n"
argument_list|,
name|RoErrString
argument_list|(
name|rind
operator|.
name|roi_preject
operator|.
name|rop_reason
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Provider Reject for wrong request %d\n"
argument_list|,
name|rind
operator|.
name|roi_preject
operator|.
name|rop_id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected reply received %d\n"
argument_list|,
name|rind
operator|.
name|roi_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|pe_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * General routines useful for supporting the tests of rtsap library routines  */
end_comment

begin_define
define|#
directive|define
name|PE_SIZE
value|3
end_define

begin_comment
comment|/* size to build pe's for testing transfer */
end_comment

begin_define
define|#
directive|define
name|MKMASK
value|0x7
end_define

begin_define
define|#
directive|define
name|MKSHIFT
value|6
end_define

begin_function_decl
specifier|extern
name|PE
name|mkpe
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Generate a randomish list of PElement s for use as ANY or SET  OF ANY ....  */
end_comment

begin_function
name|PE
name|mkpelist
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|PE
name|pe
decl_stmt|,
name|fpe
init|=
name|NULL
decl_stmt|;
name|fpe
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_PRIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|pe
operator|=
name|mkpe
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_next
operator|=
name|fpe
operator|->
name|pe_cons
expr_stmt|;
name|fpe
operator|->
name|pe_cons
operator|=
name|pe
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|fpe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate a randomish PElement  */
end_comment

begin_function
name|PE
name|mkpe
parameter_list|(
name|i
parameter_list|)
block|{
name|int
name|id
decl_stmt|,
name|class
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|id
operator|=
name|i
operator|*
name|i
operator|+
literal|1
expr_stmt|;
name|class
operator|=
name|PE_CLASS_PRIV
expr_stmt|;
switch|switch
condition|(
operator|(
name|i
operator|*
name|i
operator|>>
name|MKSHIFT
operator|)
operator|&
name|MKMASK
condition|)
block|{
case|case
literal|5
case|:
case|case
literal|0
case|:
name|pe
operator|=
name|flag2prim
argument_list|(
name|i
operator|&
literal|0x1
argument_list|,
name|class
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|1
case|:
name|pe
operator|=
name|num2prim
argument_list|(
name|i
argument_list|,
name|class
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
case|case
literal|2
case|:
name|pe
operator|=
name|str2prim
argument_list|(
literal|"mkpelist:testdata"
argument_list|,
literal|17
argument_list|,
name|class
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|pe
operator|=
name|strb2bitstr
argument_list|(
literal|"\021\0245\375\0124"
argument_list|,
literal|4
argument_list|,
name|class
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pe
operator|=
name|mkpelist
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mkpe:internal error %d case not handled\n"
argument_list|,
operator|(
name|i
operator|*
name|i
operator|>>
name|MKSHIFT
operator|)
operator|&
name|MKMASK
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump a bunch of hex digits printing out those that are printable  * Print out a given length of octets as hex (with the ASCII characters  * given if they have any  */
end_comment

begin_expr_stmt
name|fpclen
argument_list|(
name|fp
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cnt
operator|%
literal|8
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%d:"
argument_list|,
name|cnt
operator|/
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|s
operator|&
literal|0x7f
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%02x(%c)"
argument_list|,
operator|*
name|s
operator|&
literal|0xff
argument_list|,
operator|*
name|s
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%02x"
argument_list|,
operator|*
name|s
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

