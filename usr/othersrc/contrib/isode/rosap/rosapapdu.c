begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rosapapdu.c - ROPM: interpret APDU */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/rosap/RCS/rosapapdu.c,v 7.4 91/02/22 09:41:27 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/rosap/RCS/rosapapdu.c,v 7.4 91/02/22 09:41:27 mrose Interim $  *  * Based on an TCP-based implementation by George Michaelson of University  * College London.  *  *  * $Log:	rosapapdu.c,v $  * Revision 7.4  91/02/22  09:41:27  mrose  * Interim 6.8  *   * Revision 7.3  90/11/05  13:33:11  mrose  * update  *   * Revision 7.2  90/10/17  11:56:04  mrose  * sync  *   * Revision 7.1  90/07/01  21:05:58  mrose  * pepsy  *   * Revision 6.0  89/03/18  23:42:22  mrose  * Release 5.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"ROS-types.h"
end_include

begin_include
include|#
directive|include
file|"ropkt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|prob2num
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|acb2osdu
parameter_list|(
name|acb
parameter_list|,
name|invokeID
parameter_list|,
name|pe
parameter_list|,
name|roi
parameter_list|)
specifier|register
name|struct
name|assocblk
modifier|*
name|acb
decl_stmt|;
name|int
modifier|*
name|invokeID
decl_stmt|;
name|PE
name|pe
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
decl_stmt|;
block|{
name|struct
name|type_ROS_ROSEapdus
modifier|*
name|papdu
decl_stmt|;
name|struct
name|type_ROS_OPDU
modifier|*
name|popdu
decl_stmt|;
name|int
name|rosap_type
decl_stmt|;
name|int
name|result
decl_stmt|;
name|rosap_type
operator|=
name|APDU_UNKNOWN
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_ACS
operator|)
condition|?
name|decode_ROS_ROSEapdus
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|papdu
argument_list|)
else|:
name|decode_ROS_OPDU
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|popdu
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|rosapreject
argument_list|(
name|acb
argument_list|,
name|roi
argument_list|,
name|rosap_type
operator|!=
name|APDU_UNKNOWN
condition|?
name|ROS_GP_MISTYPED
else|:
name|ROS_GP_UNRECOG
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|rosap_log
operator|->
name|ll_events
operator|&
name|LLOG_PDUS
condition|)
if|if
condition|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_ACS
condition|)
name|pvpdu
argument_list|(
name|rosap_log
argument_list|,
name|print_ROS_ROSEapdus_P
argument_list|,
name|pe
argument_list|,
literal|"ROSEapdus"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|pvpdu
argument_list|(
name|rosap_log
argument_list|,
name|print_ROS_OPDU_P
argument_list|,
name|pe
argument_list|,
literal|"OPDU"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|acb
operator|->
name|acb_flags
operator|&
name|ACB_ACS
operator|)
condition|)
block|{
name|result
operator|=
name|apdu_proc
argument_list|(
name|acb
operator|->
name|acb_fd
argument_list|,
name|papdu
argument_list|,
operator|&
name|pe
argument_list|,
name|roi
argument_list|,
name|acb
argument_list|,
name|invokeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|papdu
condition|)
name|free_ROS_ROSEapdus
argument_list|(
name|papdu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|opdu_proc
argument_list|(
name|acb
operator|->
name|acb_fd
argument_list|,
name|popdu
argument_list|,
operator|&
name|pe
argument_list|,
name|roi
argument_list|,
name|acb
argument_list|,
name|invokeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|popdu
condition|)
name|free_ROS_OPDU
argument_list|(
name|popdu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * Process an APDU. This seperates out all the differences between  * the two cases. Copy all the fields of the structure into the appropriate  * RoSAPindication structure  */
end_comment

begin_function
specifier|static
name|int
name|apdu_proc
parameter_list|(
name|sd
parameter_list|,
name|papdu
parameter_list|,
name|pe
parameter_list|,
name|roi
parameter_list|,
name|acb
parameter_list|,
name|invokeID
parameter_list|)
name|int
name|sd
decl_stmt|;
name|struct
name|type_ROS_ROSEapdus
modifier|*
name|papdu
decl_stmt|;
name|PE
modifier|*
name|pe
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
decl_stmt|;
specifier|register
name|struct
name|assocblk
modifier|*
name|acb
decl_stmt|;
name|int
modifier|*
name|invokeID
decl_stmt|;
block|{
name|int
name|rosap_id
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|roi
argument_list|,
sizeof|sizeof
expr|*
name|roi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|papdu
operator|->
name|offset
condition|)
block|{
case|case
name|type_ROS_ROSEapdus_roiv__apdu
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_INVOKE
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPinvoke
modifier|*
name|rox
init|=
operator|&
name|roi
operator|->
name|roi_invoke
decl_stmt|;
specifier|register
name|struct
name|type_ROS_ROIVapdu
modifier|*
name|piv
init|=
name|papdu
operator|->
name|un
operator|.
name|roiv__apdu
decl_stmt|;
name|rosap_id
operator|=
name|rox
operator|->
name|rox_id
operator|=
name|piv
operator|->
name|invokeID
operator|->
name|parm
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rox
operator|->
name|rox_nolinked
operator|=
operator|!
operator|(
name|piv
operator|->
name|optionals
operator|&
name|opt_ROS_ROIVapdu_linked__ID
operator|)
operator|)
condition|)
name|rox
operator|->
name|rox_linkid
operator|=
name|piv
operator|->
name|linked__ID
expr_stmt|;
name|rox
operator|->
name|rox_op
operator|=
name|piv
operator|->
name|operation__value
operator|->
name|parm
expr_stmt|;
name|rox
operator|->
name|rox_args
operator|=
name|pe_expunge
argument_list|(
operator|*
name|pe
argument_list|,
name|piv
operator|->
name|argument
argument_list|)
expr_stmt|;
operator|*
name|pe
operator|=
name|NULLPE
expr_stmt|;
block|}
break|break;
case|case
name|type_ROS_ROSEapdus_rors__apdu
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_RESULT
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPresult
modifier|*
name|ror
init|=
operator|&
name|roi
operator|->
name|roi_result
decl_stmt|;
specifier|register
name|struct
name|type_ROS_RORSapdu
modifier|*
name|pres
init|=
name|papdu
operator|->
name|un
operator|.
name|rors__apdu
decl_stmt|;
name|rosap_id
operator|=
name|ror
operator|->
name|ror_id
operator|=
name|pres
operator|->
name|invokeID
operator|->
name|parm
expr_stmt|;
if|if
condition|(
name|pres
operator|->
name|element_ROS_0
condition|)
block|{
name|ror
operator|->
name|ror_op
operator|=
name|pres
operator|->
name|element_ROS_0
operator|->
name|operation__value
operator|->
name|parm
expr_stmt|;
name|ror
operator|->
name|ror_result
operator|=
name|pe_expunge
argument_list|(
operator|*
name|pe
argument_list|,
name|pres
operator|->
name|element_ROS_0
operator|->
name|result
argument_list|)
expr_stmt|;
operator|*
name|pe
operator|=
name|NULLPE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|type_ROS_ROSEapdus_roer__apdu
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_ERROR
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPerror
modifier|*
name|roe
init|=
operator|&
name|roi
operator|->
name|roi_error
decl_stmt|;
specifier|register
name|struct
name|type_ROS_ROERapdu
modifier|*
name|perr
init|=
name|papdu
operator|->
name|un
operator|.
name|roer__apdu
decl_stmt|;
name|rosap_id
operator|=
name|roe
operator|->
name|roe_id
operator|=
name|perr
operator|->
name|invokeID
operator|->
name|parm
expr_stmt|;
name|roe
operator|->
name|roe_error
operator|=
name|perr
operator|->
name|error__value
operator|->
name|parm
expr_stmt|;
name|roe
operator|->
name|roe_param
operator|=
name|pe_expunge
argument_list|(
operator|*
name|pe
argument_list|,
name|perr
operator|->
name|parameter
argument_list|)
expr_stmt|;
operator|*
name|pe
operator|=
name|NULLPE
expr_stmt|;
block|}
break|break;
case|case
name|type_ROS_ROSEapdus_rorj__apdu
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_UREJECT
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPureject
modifier|*
name|rou
init|=
operator|&
name|roi
operator|->
name|roi_ureject
decl_stmt|;
specifier|register
name|struct
name|type_ROS_RORJapdu
modifier|*
name|prej
init|=
name|papdu
operator|->
name|un
operator|.
name|rorj__apdu
decl_stmt|;
if|if
condition|(
name|prej
operator|->
name|invokeID
operator|->
name|offset
operator|==
name|choice_ROS_0_2
condition|)
name|rou
operator|->
name|rou_noid
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|rosap_id
operator|=
name|rou
operator|->
name|rou_id
operator|=
name|prej
operator|->
name|invokeID
operator|->
name|un
operator|.
name|choice_ROS_1
operator|->
name|parm
expr_stmt|;
name|rou
operator|->
name|rou_noid
operator|=
literal|0
expr_stmt|;
block|}
name|rou
operator|->
name|rou_reason
operator|=
name|prob2num
argument_list|(
name|prej
operator|->
name|problem
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|invokeID
operator|&&
operator|(
name|papdu
operator|->
name|offset
operator|==
name|type_ROS_ROSEapdus_roiv__apdu
operator|||
operator|(
name|papdu
operator|->
name|offset
operator|==
name|type_ROS_ROSEapdus_rorj__apdu
operator|&&
name|papdu
operator|->
name|un
operator|.
name|rorj__apdu
operator|->
name|invokeID
operator|->
name|offset
operator|==
name|choice_ROS_0_2
operator|)
operator|||
operator|*
name|invokeID
operator|!=
name|rosap_id
operator|)
operator|&&
name|acb
operator|->
name|acb_rosindication
condition|)
block|{
call|(
modifier|*
name|acb
operator|->
name|acb_rosindication
call|)
argument_list|(
name|sd
operator|=
name|acb
operator|->
name|acb_fd
argument_list|,
name|roi
argument_list|)
expr_stmt|;
if|if
condition|(
name|findacblk
argument_list|(
name|sd
argument_list|)
operator|!=
name|acb
condition|)
comment|/* still not perfect! */
return|return
name|rosaplose
argument_list|(
name|roi
argument_list|,
name|ROS_DONE
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
return|return
name|OK
return|;
block|}
return|return
name|DONE
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * Process an OPDU. A seperate function is used for this type of PDU to  * simpilfy matters. What is an OPDU - an Old PDU ??  */
end_comment

begin_function
specifier|static
name|int
name|opdu_proc
parameter_list|(
name|sd
parameter_list|,
name|popdu
parameter_list|,
name|pe
parameter_list|,
name|roi
parameter_list|,
name|acb
parameter_list|,
name|invokeID
parameter_list|)
name|int
name|sd
decl_stmt|;
name|struct
name|type_ROS_OPDU
modifier|*
name|popdu
decl_stmt|;
name|PE
modifier|*
name|pe
decl_stmt|;
specifier|register
name|struct
name|RoSAPindication
modifier|*
name|roi
decl_stmt|;
specifier|register
name|struct
name|assocblk
modifier|*
name|acb
decl_stmt|;
name|int
modifier|*
name|invokeID
decl_stmt|;
block|{
name|int
name|rosap_id
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|roi
argument_list|,
sizeof|sizeof
expr|*
name|roi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|popdu
operator|->
name|offset
condition|)
block|{
case|case
name|type_ROS_OPDU_1
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_INVOKE
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPinvoke
modifier|*
name|rox
init|=
operator|&
name|roi
operator|->
name|roi_invoke
decl_stmt|;
specifier|register
name|struct
name|type_ROS_Invoke
modifier|*
name|piv
init|=
name|popdu
operator|->
name|un
operator|.
name|choice_ROS_8
decl_stmt|;
name|rosap_id
operator|=
name|rox
operator|->
name|rox_id
operator|=
name|piv
operator|->
name|invokeID
expr_stmt|;
name|rox
operator|->
name|rox_op
operator|=
name|piv
operator|->
name|element_ROS_2
operator|->
name|parm
expr_stmt|;
name|rox
operator|->
name|rox_args
operator|=
name|pe_expunge
argument_list|(
operator|*
name|pe
argument_list|,
name|piv
operator|->
name|argument
argument_list|)
expr_stmt|;
operator|*
name|pe
operator|=
name|NULLPE
expr_stmt|;
block|}
break|break;
case|case
name|type_ROS_OPDU_2
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_RESULT
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPresult
modifier|*
name|ror
init|=
operator|&
name|roi
operator|->
name|roi_result
decl_stmt|;
specifier|register
name|struct
name|type_ROS_ReturnResult
modifier|*
name|piv
init|=
name|popdu
operator|->
name|un
operator|.
name|choice_ROS_9
decl_stmt|;
name|rosap_id
operator|=
name|ror
operator|->
name|ror_id
operator|=
name|piv
operator|->
name|invokeID
operator|->
name|parm
expr_stmt|;
name|ror
operator|->
name|ror_result
operator|=
name|pe_expunge
argument_list|(
operator|*
name|pe
argument_list|,
name|piv
operator|->
name|result
argument_list|)
expr_stmt|;
operator|*
name|pe
operator|=
name|NULLPE
expr_stmt|;
block|}
break|break;
case|case
name|type_ROS_OPDU_3
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_ERROR
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPerror
modifier|*
name|roe
init|=
operator|&
name|roi
operator|->
name|roi_error
decl_stmt|;
specifier|register
name|struct
name|type_ROS_ReturnError
modifier|*
name|per
init|=
name|popdu
operator|->
name|un
operator|.
name|choice_ROS_10
decl_stmt|;
name|rosap_id
operator|=
name|roe
operator|->
name|roe_id
operator|=
name|per
operator|->
name|invokeID
expr_stmt|;
empty_stmt|;
name|roe
operator|->
name|roe_error
operator|=
name|per
operator|->
name|element_ROS_3
operator|->
name|parm
expr_stmt|;
name|roe
operator|->
name|roe_param
operator|=
name|pe_expunge
argument_list|(
operator|*
name|pe
argument_list|,
name|per
operator|->
name|parameter
argument_list|)
expr_stmt|;
operator|*
name|pe
operator|=
name|NULLPE
expr_stmt|;
block|}
break|break;
case|case
name|type_ROS_OPDU_4
case|:
name|roi
operator|->
name|roi_type
operator|=
name|ROI_UREJECT
expr_stmt|;
block|{
specifier|register
name|struct
name|RoSAPureject
modifier|*
name|rou
init|=
operator|&
name|roi
operator|->
name|roi_ureject
decl_stmt|;
specifier|register
name|struct
name|type_ROS_Reject
modifier|*
name|prj
init|=
name|popdu
operator|->
name|un
operator|.
name|choice_ROS_11
decl_stmt|;
if|if
condition|(
name|prj
operator|->
name|invokeID
operator|->
name|offset
operator|==
name|choice_ROS_0_2
condition|)
name|rou
operator|->
name|rou_noid
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|rosap_id
operator|=
name|rou
operator|->
name|rou_id
operator|=
name|prj
operator|->
name|invokeID
operator|->
name|un
operator|.
name|choice_ROS_1
operator|->
name|parm
expr_stmt|;
name|rou
operator|->
name|rou_noid
operator|=
literal|0
expr_stmt|;
block|}
name|rou
operator|->
name|rou_reason
operator|=
name|prob2num
argument_list|(
name|prj
operator|->
name|problem
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|invokeID
operator|&&
operator|(
name|popdu
operator|->
name|offset
operator|==
name|type_ROS_OPDU_1
operator|||
operator|(
name|popdu
operator|->
name|offset
operator|==
name|type_ROS_OPDU_4
operator|&&
name|popdu
operator|->
name|un
operator|.
name|choice_ROS_11
operator|->
name|invokeID
operator|->
name|offset
operator|==
name|choice_ROS_0_2
operator|)
operator|||
operator|*
name|invokeID
operator|!=
name|rosap_id
operator|)
operator|&&
name|acb
operator|->
name|acb_rosindication
condition|)
block|{
call|(
modifier|*
name|acb
operator|->
name|acb_rosindication
call|)
argument_list|(
name|sd
operator|=
name|acb
operator|->
name|acb_fd
argument_list|,
name|roi
argument_list|)
expr_stmt|;
if|if
condition|(
name|findacblk
argument_list|(
name|sd
argument_list|)
operator|!=
name|acb
condition|)
comment|/* still not perfect! */
return|return
name|rosaplose
argument_list|(
name|roi
argument_list|,
name|ROS_DONE
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
return|;
return|return
name|OK
return|;
block|}
return|return
name|DONE
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Gprob
index|[]
init|=
block|{
name|ROS_GP_UNRECOG
block|,
name|ROS_GP_MISTYPED
block|,
name|ROS_GP_STRUCT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Iprob
index|[]
init|=
block|{
name|ROS_IP_DUP
block|,
name|ROS_IP_UNRECOG
block|,
name|ROS_IP_MISTYPED
block|,
name|ROS_IP_LIMIT
block|,
name|ROS_IP_RELEASE
block|,
name|ROS_IP_UNLINKED
block|,
name|ROS_IP_LINKED
block|,
name|ROS_IP_CHILD
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|RRprob
index|[]
init|=
block|{
name|ROS_RRP_UNRECOG
block|,
name|ROS_RRP_UNEXP
block|,
name|ROS_RRP_MISTYPED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|REprob
index|[]
init|=
block|{
name|ROS_REP_UNRECOG
block|,
name|ROS_REP_UNEXP
block|,
name|ROS_REP_RECERR
block|,
name|ROS_REP_UNEXPERR
block|,
name|ROS_REP_MISTYPED
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* computes the Number of entries in an array a */
end_comment

begin_define
define|#
directive|define
name|NENTRIES
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a)/sizeof (a[0]))
end_define

begin_comment
comment|/* return the ISODE code from the numbers passed in the data or NOTOK if   * it finds an illegal value  */
end_comment

begin_function
specifier|static
name|int
name|prob2num
parameter_list|(
name|prob
parameter_list|)
specifier|register
name|struct
name|choice_ROS_3
modifier|*
name|prob
decl_stmt|;
block|{
specifier|register
name|int
name|num
decl_stmt|;
switch|switch
condition|(
name|prob
operator|->
name|offset
condition|)
block|{
case|case
name|choice_ROS_3_1
case|:
if|if
condition|(
operator|(
name|num
operator|=
name|prob
operator|->
name|un
operator|.
name|choice_ROS_4
operator|->
name|parm
operator|)
operator|<
literal|0
operator|||
name|num
operator|>=
name|NENTRIES
argument_list|(
name|Gprob
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|num
operator|=
name|Gprob
index|[
name|num
index|]
expr_stmt|;
break|break;
case|case
name|choice_ROS_3_2
case|:
if|if
condition|(
operator|(
name|num
operator|=
name|prob
operator|->
name|un
operator|.
name|choice_ROS_5
operator|->
name|parm
operator|)
operator|<
literal|0
operator|||
name|num
operator|>=
name|NENTRIES
argument_list|(
name|Iprob
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|num
operator|=
name|Iprob
index|[
name|num
index|]
expr_stmt|;
break|break;
case|case
name|choice_ROS_3_3
case|:
if|if
condition|(
operator|(
name|num
operator|=
name|prob
operator|->
name|un
operator|.
name|choice_ROS_6
operator|->
name|parm
operator|)
operator|<
literal|0
operator|||
name|num
operator|>=
name|NENTRIES
argument_list|(
name|RRprob
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|num
operator|=
name|RRprob
index|[
name|num
index|]
expr_stmt|;
break|break;
case|case
name|choice_ROS_3_4
case|:
if|if
condition|(
operator|(
name|num
operator|=
name|prob
operator|->
name|un
operator|.
name|choice_ROS_7
operator|->
name|parm
operator|)
operator|<
literal|0
operator|||
name|num
operator|>=
name|NENTRIES
argument_list|(
name|REprob
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|num
operator|=
name|REprob
index|[
name|num
index|]
expr_stmt|;
break|break;
default|default:
name|out
label|:
empty_stmt|;
return|return
name|ROS_PROTOCOL
return|;
comment|/* What else can we say ?*/
block|}
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

end_unit

