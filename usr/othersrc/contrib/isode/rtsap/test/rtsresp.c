begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * this is the example use of rtsap taken from the manual  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<isode/rtsap.h>
end_include

begin_include
include|#
directive|include
file|"support.h"
end_include

begin_function_decl
name|int
name|rts_indication
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|errfp
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|result
decl_stmt|,
name|sd
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|RtSAPstart
name|rtss
decl_stmt|;
specifier|register
name|struct
name|RtSAPstart
modifier|*
name|rts
init|=
operator|&
name|rtss
decl_stmt|;
name|struct
name|RtSAPindication
name|rtis
decl_stmt|;
specifier|register
name|struct
name|RtSAPindication
modifier|*
name|rti
init|=
operator|&
name|rtis
decl_stmt|;
specifier|register
name|struct
name|AcSAPstart
modifier|*
name|acs
init|=
operator|&
name|rts
operator|->
name|rts_start
decl_stmt|;
specifier|register
name|struct
name|PSAPstart
modifier|*
name|ps
init|=
operator|&
name|acs
operator|->
name|acs_start
decl_stmt|;
specifier|register
name|struct
name|RtSAPabort
modifier|*
name|rta
init|=
operator|&
name|rti
operator|->
name|rti_abort
decl_stmt|;
name|errfp
operator|=
name|freopen
argument_list|(
literal|"/dev/console"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|errfp
argument_list|,
literal|"Got to here\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|RtInit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rts
argument_list|,
name|rti
argument_list|)
operator|==
name|NOTOK
condition|)
name|fprintf
argument_list|(
name|errfp
argument_list|,
literal|"initialisation fails: %s"
argument_list|,
name|RtErrString
argument_list|(
name|rta
operator|->
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|=
name|rts
operator|->
name|rts_sd
expr_stmt|;
name|RTSFREE
argument_list|(
name|rts
argument_list|)
expr_stmt|;
comment|/* would have read command line arguments here */
if|if
condition|(
name|RtOpenResponse
argument_list|(
name|sd
argument_list|,
name|ACS_ACCEPT
argument_list|,
name|NULLOID
argument_list|,
name|NULLAEI
argument_list|,
operator|&
name|ps
operator|->
name|ps_called
argument_list|,
name|NULLPC
argument_list|,
name|ps
operator|->
name|ps_defctxresult
argument_list|,
name|NULLPE
argument_list|,
name|rti
argument_list|)
operator|==
name|NOTOK
condition|)
name|fprintf
argument_list|(
name|errfp
argument_list|,
literal|"RT-OPEN.RESPONSE: %s"
argument_list|,
name|RtErrString
argument_list|(
name|rti
operator|->
name|rti_abort
operator|.
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_ASYNC
if|if
condition|(
name|RtSetIndications
argument_list|(
name|sd
argument_list|,
name|rts_indication
argument_list|,
name|rti
argument_list|)
operator|==
name|NOTOK
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RoSetIndications: %s"
argument_list|,
name|RtErrString
argument_list|(
name|rti
operator|->
name|rti_abort
operator|.
name|rta_reason
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
else|#
directive|else
name|oper
argument_list|(
name|sd
argument_list|,
name|SIMP_RCV
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|CPLX_RCV
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|SEND_PLS
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|RCV_GIVE
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|SIMP_SEND
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|CPLX_SEND
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|RCV_PLS
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|SEND_GIVE
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|CPLX_RCV
argument_list|)
expr_stmt|;
name|oper
argument_list|(
name|sd
argument_list|,
name|RCV_CLOSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|errfp
argument_list|,
literal|"Finished\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Request/Reply loop of ROS server. Called when data arrives like a signal  * handler routine  */
end_comment

begin_comment
unit|static int rts_indication(sd, rti) int	sd; register struct RtSAPindication	*rti; {      fprintf(errfp, "rts_indication got called\n");     switch (rti->roi_type) {     case ROI_INVOKE: 	rts_invoke(sd,&rti->roi_invoke); 	break;      case ROI_RESULT: 	rts_result(sd,&rti->roi_result); 	break;      case ROI_ERROR: 	rts_error(sd,&rti->roi_error); 	break;       case ROI_UREJECT: 	rts_ureject(sd,&rti->roi_ureject); 	break;      case ROI_PREJECT: 	rts_preject(sd,&rti->roi_preject); 	break;      case ROI_FINISH: 	rts_finish(sd,&rti->roi_finish); 	break;      default: 	fprintf(errfp, "unknown indication type=%d", rti->roi_type);     } }  extern int	OP1();
comment|/* OPERATIONS are numbered APDU_OPx, where each is a unique integer.  Further,    APDU_UNKNOWN is used as a tag different than any valid operation.     ERRORS are numbered ERROR_xyz, where each is a unique integer.    ERROR_MISTYPED is used to signal an argument fprintf to an operation.    Further, ERROR_UNKNOWN is used as a tag to indicate that the operation    succeeded.     Finally, note that rox -> rox_args is updated in place by these routines.    If the routine returns ERROR_UNKNOWN, then rox_args contains the results    of the operation.  If the routine returns ERROR_MISTYPED, then rox_args is    untouched.  Otherwise, if the routine returns any other value, then    rox_args contains the parameters of the fprintf which occurred.  Obviously,    each routine calls ROXFREE prior to setting rox_args to a new value.  */
end_comment

begin_comment
unit|static struct dispatch {     int     ds_operation;     IFP     ds_vector; }       dispatches[] = {     APDU_OP1,   OP1,     APDU_ERR,   OP1,     APDU_URJ,   OP1,
comment|/* APDU_OPn,   OPn, */
end_comment

begin_comment
unit|APDU_UNKNOWN };   static int  rts_invoke (sd, rox) int     sd; register struct RoSAPinvoke *rox; {     int     result;     register struct dispatch   *ds;     struct RoSAPindication  rois;     register struct RoSAPindication *rti =&rois;     register struct RoSAPpreject   *rop =&rti -> roi_preject;      for (ds = dispatches; ds -> ds_operation != APDU_UNKNOWN; ds++) 	if (ds -> ds_operation == rox -> rox_op) 	    break;      if (ds -> ds_operation == APDU_UNKNOWN) { 	if (RoURejectRequest (sd,&rox -> rox_id, ROS_IP_UNRECOG, 		    ROS_NOPRIO, rti) == NOTOK) 	    fprintf (errfp, "RO-U-REJECT.REQUEST: %s", RoErrString (rop -> rop_reason)); 	goto out;     }      if (rox -> rox_nolinked == 0) { 	if (RoURejectRequest (sd,&rox -> rox_id, ROS_IP_LINKED, 		    ROS_NOPRIO, rti) == NOTOK) 	    fprintf (errfp, "RO-U-REJECT.REQUEST: %s", RoErrString (rop -> rop_reason)); 	goto out;     }      switch (result = (*ds -> ds_vector) (rox)) { 	case ERROR_UNKNOWN:  	    if (RoResultRequest (sd, rox -> rox_id, rox -> rox_op, 			rox -> rox_args, ROS_NOPRIO, rti) == NOTOK) 		fprintf (errfp, "RO-RESULT.REQUEST: %s", 			RoErrString (rop -> rop_reason)); 	    break;  	default:  	    if (RoErrorRequest (sd, rox -> rox_id, result, rox -> rox_args, 			ROS_NOPRIO, rti) == NOTOK) 		fprintf (errfp, "RO-ERROR.REQUEST: %s", 			RoErrString (rop -> rop_reason)); 	    break;  	case ERROR_MISTYPED:  	    if (RoURejectRequest (sd,&rox -> rox_id, ROS_IP_MISTYPED, 			ROS_NOPRIO, rti) == NOTOK) 		fprintf (errfp, "RO-U-REJECT.REQUEST: %s", 			RoErrString (rop -> rop_reason)); 	    break;     }  out: ;     ROXFREE (rox); }   static int  rts_result (sd, ror) int     sd; register struct RoSAPresult *ror; {     struct RoSAPindication  rois;     register struct RoSAPindication *rti =&rois;     register struct RoSAPpreject   *rop =&rti -> roi_preject;      if (RoURejectRequest (sd,&ror -> ror_id, ROS_RRP_UNRECOG, ROS_NOPRIO, rti) 	    == NOTOK) 	fprintf (errfp, "RO-U-REJECT.REQUEST: %s", RoErrString (rop -> rop_reason));      RORFREE (ror); }   static int  rts_error (sd, roe) int     sd; register struct RoSAPerror *roe; {     struct RoSAPindication  rois;     register struct RoSAPindication *rti =&rois;     register struct RoSAPpreject   *rop =&rti -> roi_preject;      if (RoURejectRequest (sd,&roe -> roe_id, ROS_REP_UNRECOG, ROS_NOPRIO, rti) 	    == NOTOK) 	fprintf (errfp, "RO-U-REJECT.REQUEST: %s", RoErrString (rop -> rop_reason));      ROEFREE (roe); }   static int  rts_ureject (sd, rou) int     sd; register struct RoSAPureject *rou; {
comment|/* handle rejection here... */
end_comment

begin_comment
unit|}   static int  rts_preject (sd, rop) int     sd; register struct RoSAPpreject *rop; {     if (ROS_FATAL (rop -> rop_reason)) 	fprintf (errfp, "RO-REJECT-P.INDICATION: %s", RoErrString (rop -> rop_reason));
comment|/* handle temporary failure here... */
end_comment

begin_comment
unit|}  static int  rts_finish (sd, acf) int     sd; struct AcSAPfinish *acf; {     struct AcSAPindication  acis;     register struct AcSAPabort *aca =&acis.aci_abort;      ACFFREE (acf);      if (AcRelResponse (sd, ACS_ACCEPT, ACR_NORMAL, NULLPEP, 0,&acis) == NOTOK) 	fprintf (errfp, "A-RELEASE.RESPONSE: %s", AcErrString (aca -> aca_reason));      fprintf (errfp, "association released");      exit(0); }  OP1(rox) register struct RoSAPinvoke *rox; {     fprintf(errfp, "Invocation\nid %d", rox->rox_id);     if (!rox->rox_nolinked) 	fprintf(errfp, " linked to %d", rox->rox_linkid);     fprintf(errfp, " operation %d\n", rox->rox_op);
comment|/* print the pe */
end_comment

begin_endif
unit|switch (rox->rox_op) {     case APDU_OP1: 	return (ERROR_UNKNOWN);      case APDU_ERR: 	return (ERROR_ERROR);      case APDU_URJ: 	return (ERROR_MISTYPED);      default: 	fprintf(errfp, "\nunknown operation %d\n", rox->rox_op);     }     return (ERROR_ERROR); }
endif|#
directive|endif
end_endif

end_unit

