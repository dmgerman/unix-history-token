begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: connection.c,v 1.88 88/10/22 22:06:31 keith Exp $ */
end_comment

begin_comment
comment|/*****************************************************************  *  Stuff to create connections --- OS dependent  *  *      EstablishNewConnections, CreateWellKnownSockets, ResetWellKnownSockets,  *      CloseDownConnection, CheckConnections, AddEnabledDevice,  *	RemoveEnabledDevice, OnlyListToOneClient,  *      ListenToAllClients,  *  *      (WaitForSomething is in its own file)  *  *      In this implementation, a client socket table is not kept.  *      Instead, what would be the index into the table is just the  *      file descriptor of the socket.  This won't work for if the  *      socket ids aren't small nums (0 - 2^8)  *  *****************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_include
include|#
directive|include
file|<dbm.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"Xos.h"
end_include

begin_comment
comment|/* for strings, file, time */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TCPCONN
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|hpux
end_ifndef

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNIXCONN
end_ifdef

begin_comment
comment|/*  * sites should be careful to have separate /tmp directories for diskless nodes  */
end_comment

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|unixDomainConnection
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|"osstruct.h"
end_include

begin_include
include|#
directive|include
file|"osdep.h"
end_include

begin_include
include|#
directive|include
file|"opaque.h"
end_include

begin_include
include|#
directive|include
file|"dixstruct.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DNETCONN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_include
include|#
directive|include
file|<isode/psap.h>
end_include

begin_include
include|#
directive|include
file|<isode/tsap.h>
end_include

begin_include
include|#
directive|include
file|<isode/isoservent.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|isodetcpath
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ISODEBUG
end_ifdef

begin_comment
comment|/*  * Set to true for loads of TSAP messages...  */
end_comment

begin_decl_stmt
name|int
name|isodexbug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISODEBUG */
end_comment

begin_comment
comment|/*  * array of fd 2 family map so we can lookup right function below...  * Its initialised at connection setup...  */
end_comment

begin_decl_stmt
name|int
name|fd2family
index|[
name|MAXSOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Globals for storing functions appropos each fd/socket type  * UNIX_IO (0) map to sys calls  * ISODE_IO (1) maps to my fns...  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|accept
argument_list|()
decl_stmt|,
name|TAcceptFromClient
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|acceptfn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|accept
operator|,
function_decl|TAcceptFromClient
end_function_decl

begin_extern
unit|};
extern|extern getpeername(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|getISOpeername
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|getpeerfn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|getpeername
operator|,
function_decl|getISOpeername
end_function_decl

begin_comment
unit|};
comment|/*  * Note yuckiness here XXX  * TReadFromClient takes one more param than read - must fix...  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|read
argument_list|()
decl_stmt|,
name|TReadFromClient
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|readfn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|read
operator|,
function_decl|TReadFromClient
end_function_decl

begin_decl_stmt
unit|};
specifier|extern
name|int
name|write
argument_list|()
decl_stmt|,
name|TWriteToClient
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|writefn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|write
operator|,
function_decl|TWriteToClient
end_function_decl

begin_extern
unit|};
extern|extern writev(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|TWritevToClient
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|writevfn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|writev
operator|,
function_decl|TWritevToClient
end_function_decl

begin_decl_stmt
unit|};
specifier|extern
name|int
name|close
argument_list|()
decl_stmt|,
name|TDiscFromClient
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|closefn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|close
operator|,
function_decl|TDiscFromClient
end_function_decl

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_typedef
typedef|typedef
name|long
name|CCID
typedef|;
end_typedef

begin_comment
comment|/* mask of indices into client socket table */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|X_UNIX_PATH
end_ifndef

begin_define
define|#
directive|define
name|X_UNIX_DIR
value|"/tmp/.X11-unix"
end_define

begin_define
define|#
directive|define
name|X_UNIX_PATH
value|"/tmp/.X11-unix/X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|display
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The display number */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|char
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The display number */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|int
name|lastfdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum file descriptor */
end_comment

begin_decl_stmt
name|long
name|WellKnownConnections
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Listener mask */
end_comment

begin_decl_stmt
name|long
name|EnabledDevices
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask for input devices that are on */
end_comment

begin_decl_stmt
name|long
name|AllSockets
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* select on this */
end_comment

begin_decl_stmt
name|long
name|AllClients
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* available clients */
end_comment

begin_decl_stmt
name|long
name|LastSelectMask
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask returned from last select call */
end_comment

begin_decl_stmt
name|long
name|ClientsWithInput
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clients with FULL requests in buffer */
end_comment

begin_decl_stmt
name|long
name|ClientsWriteBlocked
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clients who cannot receive output */
end_comment

begin_decl_stmt
name|long
name|OutputPending
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clients with reply/event data ready to go */
end_comment

begin_decl_stmt
name|long
name|MaxClients
init|=
name|MAXSOCKS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|OutputBufferSize
init|=
name|BUFSIZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output buffer size (must be> 0) */
end_comment

begin_decl_stmt
name|long
name|NConnBitArrays
init|=
name|mskcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|FirstClient
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|NewOutputPending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not yet attempted to write some new output */
end_comment

begin_decl_stmt
name|Bool
name|AnyClientsWriteBlocked
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if some client blocked on write */
end_comment

begin_decl_stmt
specifier|static
name|Bool
name|debug_conns
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|whichByteIsFirst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SavedAllClients
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SavedAllSockets
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SavedClientsWithInput
index|[
name|mskcnt
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Bool
name|GrabDone
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ClientPtr
name|ConnectionTranslation
index|[
name|MAXSOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|ClientPtr
name|NextAvailableClient
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|ConnectionInput
name|inputBuffers
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swappedClients
index|[
name|MAXSOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|AutoResetServer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|GiveUp
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|UNIXCONN
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_un
name|unsock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|open_unix_socket
parameter_list|()
block|{
name|int
name|oldUmask
decl_stmt|;
name|int
name|request
decl_stmt|;
name|unsock
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|oldUmask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|X_UNIX_DIR
name|mkdir
argument_list|(
name|X_UNIX_DIR
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|unsock
operator|.
name|sun_path
argument_list|,
name|X_UNIX_PATH
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|unsock
operator|.
name|sun_path
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|unsock
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|request
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|Notice
argument_list|(
literal|"Creating Unix socket"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bind
argument_list|(
name|request
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|unsock
argument_list|,
name|strlen
argument_list|(
name|unsock
operator|.
name|sun_path
argument_list|)
operator|+
literal|2
argument_list|)
condition|)
name|Error
argument_list|(
literal|"Binding Unix socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|request
argument_list|,
literal|5
argument_list|)
condition|)
name|Error
argument_list|(
literal|"Unix Listening"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oldUmask
argument_list|)
expr_stmt|;
return|return
name|request
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*UNIXCONN */
end_comment

begin_comment
comment|/*****************  * CreateWellKnownSockets  *    At initialization, create the sockets to listen on for new clients.  *    There are potentially 4: DECnet, UNIX Domain, TCP-IP with MSB first,   *    with TCP-IP with LSB first.  *****************/
end_comment

begin_function
name|void
name|CreateWellKnownSockets
parameter_list|()
block|{
name|int
name|request
decl_stmt|,
name|i
decl_stmt|;
name|int
name|whichbyte
decl_stmt|;
comment|/* used to figure out whether this is    					 LSB or MSB */
ifdef|#
directive|ifdef
name|TCPCONN
name|struct
name|sockaddr_in
name|insock
decl_stmt|;
name|int
name|tcpportReg
decl_stmt|;
comment|/* port with same byte order as server */
ifdef|#
directive|ifdef
name|SO_LINGER
specifier|static
name|int
name|linger
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* SO_LINGER */
endif|#
directive|endif
comment|/* TCPCONN */
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|sockaddr_dn
name|dnsock
decl_stmt|;
endif|#
directive|endif
comment|/* DNETCONN */
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|struct
name|TSAPaddr
name|tas
decl_stmt|;
name|struct
name|TSAPaddr
modifier|*
name|ta
init|=
operator|&
name|tas
decl_stmt|;
name|struct
name|PSAPaddr
modifier|*
name|pa
decl_stmt|;
name|AEI
name|aei
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|int
name|retry
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
ifdef|#
directive|ifdef
name|ISODEBUG
name|isodetcpath
operator|=
name|ISODEPATH
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ISOCONN */
name|CLEARBITS
argument_list|(
name|AllSockets
argument_list|)
expr_stmt|;
name|CLEARBITS
argument_list|(
name|AllClients
argument_list|)
expr_stmt|;
name|CLEARBITS
argument_list|(
name|LastSelectMask
argument_list|)
expr_stmt|;
name|CLEARBITS
argument_list|(
name|ClientsWithInput
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSOCKS
condition|;
name|i
operator|++
control|)
name|ConnectionTranslation
index|[
name|i
index|]
operator|=
operator|(
name|ClientPtr
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|hpux
name|lastfdesc
operator|=
name|_NFILE
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|lastfdesc
operator|=
name|getdtablesize
argument_list|()
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* hpux */
if|if
condition|(
name|lastfdesc
operator|>
name|MAXSOCKS
condition|)
block|{
name|lastfdesc
operator|=
name|MAXSOCKS
expr_stmt|;
if|if
condition|(
name|debug_conns
condition|)
name|ErrorF
argument_list|(
literal|"GOT TO END OF SOCKETS %d\n"
argument_list|,
name|MAXSOCKS
argument_list|)
expr_stmt|;
block|}
name|WellKnownConnections
operator|=
literal|0
expr_stmt|;
name|whichbyte
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
operator|&
name|whichbyte
condition|)
name|whichByteIsFirst
operator|=
literal|'l'
expr_stmt|;
else|else
name|whichByteIsFirst
operator|=
literal|'B'
expr_stmt|;
ifdef|#
directive|ifdef
name|TCPCONN
name|tcpportReg
operator|=
name|atoi
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|tcpportReg
operator|+=
name|X_TCP_PORT
expr_stmt|;
if|if
condition|(
operator|(
name|request
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|Notice
argument_list|(
literal|"Creating TCP socket"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|insock
argument_list|,
sizeof|sizeof
argument_list|(
name|insock
argument_list|)
argument_list|)
expr_stmt|;
name|insock
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|insock
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|tcpportReg
argument_list|)
expr_stmt|;
name|insock
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|retry
operator|=
literal|20
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|bind
argument_list|(
name|request
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|insock
argument_list|,
sizeof|sizeof
argument_list|(
name|insock
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|hpux
comment|/* Necesary to restart the server without a reboot */
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|set_socket_option
argument_list|(
name|request
argument_list|,
name|SO_REUSEADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|retry
operator|==
literal|0
condition|)
name|Error
argument_list|(
literal|"Binding TCP socket"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|--
name|retry
operator|==
literal|0
condition|)
name|Error
argument_list|(
literal|"Binding MSB TCP socket"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hpux */
block|}
ifdef|#
directive|ifdef
name|hpux
comment|/* return the socket option to the original */
if|if
condition|(
name|errno
condition|)
name|unset_socket_option
argument_list|(
name|request
argument_list|,
name|SO_REUSEADDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hpux */
ifdef|#
directive|ifdef
name|SO_LINGER
if|if
condition|(
name|setsockopt
argument_list|(
name|request
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
name|linger
argument_list|,
sizeof|sizeof
argument_list|(
name|linger
argument_list|)
argument_list|)
condition|)
name|Notice
argument_list|(
literal|"Setting TCP SO_LINGER\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SO_LINGER */
if|if
condition|(
name|listen
argument_list|(
name|request
argument_list|,
literal|5
argument_list|)
condition|)
name|Error
argument_list|(
literal|"Reg TCP Listening"
argument_list|)
expr_stmt|;
name|WellKnownConnections
operator||=
operator|(
literal|1
operator|<<
name|request
operator|)
expr_stmt|;
name|DefineSelf
argument_list|(
name|request
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|fd2family
index|[
name|request
index|]
operator|=
name|UNIX_IO
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
endif|#
directive|endif
comment|/* TCPCONN */
ifdef|#
directive|ifdef
name|UNIXCONN
if|if
condition|(
operator|(
name|request
operator|=
name|open_unix_socket
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|WellKnownConnections
operator||=
operator|(
literal|1L
operator|<<
name|request
operator|)
expr_stmt|;
name|unixDomainConnection
operator|=
name|request
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|fd2family
index|[
name|request
index|]
operator|=
name|UNIX_IO
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
endif|#
directive|endif
comment|/*UNIXCONN */
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
operator|(
name|request
operator|=
name|socket
argument_list|(
name|AF_DECnet
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|Notice
argument_list|(
literal|"Creating DECnet socket"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dnsock
argument_list|,
sizeof|sizeof
argument_list|(
name|dnsock
argument_list|)
argument_list|)
expr_stmt|;
name|dnsock
operator|.
name|sdn_family
operator|=
name|AF_DECnet
expr_stmt|;
name|sprintf
argument_list|(
name|dnsock
operator|.
name|sdn_objname
argument_list|,
literal|"X$X%d"
argument_list|,
name|atoi
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|dnsock
operator|.
name|sdn_objnamel
operator|=
name|strlen
argument_list|(
name|dnsock
operator|.
name|sdn_objname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|request
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dnsock
argument_list|,
sizeof|sizeof
argument_list|(
name|dnsock
argument_list|)
argument_list|)
condition|)
name|Error
argument_list|(
literal|"Binding DECnet socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|request
argument_list|,
literal|5
argument_list|)
condition|)
name|Error
argument_list|(
literal|"DECnet Listening"
argument_list|)
expr_stmt|;
name|WellKnownConnections
operator||=
operator|(
literal|1
operator|<<
name|request
operator|)
expr_stmt|;
name|DefineSelf
argument_list|(
name|request
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|fd2family
index|[
name|request
index|]
operator|=
name|UNIX_IO
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
endif|#
directive|endif
comment|/* DNETCONN */
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * If display is set, its the string after the Colon:  * i.e. X0 or X1 or T0 or T1...  */
if|if
condition|(
operator|(
name|display
operator|==
name|NULLCP
operator|)
operator|||
operator|(
name|atoi
argument_list|(
name|display
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|aei
operator|=
name|str2aei
argument_list|(
name|TLocalHostName
argument_list|()
argument_list|,
name|DEFAULTTSERVICE
argument_list|)
expr_stmt|;
else|else
name|aei
operator|=
name|str2aei
argument_list|(
name|TLocalHostName
argument_list|()
argument_list|,
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|aei
operator|==
name|NULLAEI
condition|)
block|{
name|ErrorF
argument_list|(
literal|"No AEI for me:"
argument_list|)
expr_stmt|;
name|FatalError
argument_list|(
name|TLocalHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*  * This hack only works if the PSAPaddr and SSAP addrsd are null!!  */
if|if
condition|(
operator|(
name|pa
operator|=
name|aei2addr
argument_list|(
name|aei
argument_list|)
operator|)
operator|==
name|NULLPA
condition|)
name|FatalError
argument_list|(
literal|"address translation failed"
argument_list|)
expr_stmt|;
name|ta
operator|=
operator|(
expr|struct
name|TSAPaddr
operator|*
operator|)
operator|&
operator|(
name|pa
operator|->
name|pa_addr
operator|.
name|sa_addr
operator|)
expr_stmt|;
comment|/*  * Just put out a listen for now  */
if|if
condition|(
operator|(
name|request
operator|=
name|TNetListen
argument_list|(
name|ta
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|Error
argument_list|(
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
name|FatalError
argument_list|(
literal|"TNetListen"
argument_list|)
expr_stmt|;
block|}
name|WellKnownConnections
operator||=
operator|(
literal|1
operator|<<
name|request
operator|)
expr_stmt|;
name|DefineSelf
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|fd2family
index|[
name|request
index|]
operator|=
name|ISODE_IO
expr_stmt|;
endif|#
directive|endif
comment|/*  ISOCONN */
if|if
condition|(
name|WellKnownConnections
operator|==
literal|0
condition|)
name|Error
argument_list|(
literal|"No Listeners, nothing to do"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|AutoResetServer
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|GiveUp
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|GiveUp
argument_list|)
expr_stmt|;
name|FirstClient
operator|=
name|request
operator|+
literal|1
expr_stmt|;
name|AllSockets
index|[
literal|0
index|]
operator|=
name|WellKnownConnections
expr_stmt|;
name|ResetHosts
argument_list|(
name|display
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MaxClients
condition|;
name|i
operator|++
control|)
block|{
name|inputBuffers
index|[
name|i
index|]
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|inputBuffers
index|[
name|i
index|]
operator|.
name|bufptr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|inputBuffers
index|[
name|i
index|]
operator|.
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|inputBuffers
index|[
name|i
index|]
operator|.
name|lenLastReq
operator|=
literal|0
expr_stmt|;
name|inputBuffers
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ResetWellKnownSockets
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|UNIXCONN
if|if
condition|(
name|unixDomainConnection
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 	 * see if the unix domain socket has disappeared 	 */
name|struct
name|stat
name|statb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|unsock
operator|.
name|sun_path
argument_list|,
operator|&
name|statb
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFSOCK
condition|)
block|{
name|ErrorF
argument_list|(
literal|"Unix domain socket %s trashed, recreating\n"
argument_list|,
name|unsock
operator|.
name|sun_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|unsock
operator|.
name|sun_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|unixDomainConnection
argument_list|)
expr_stmt|;
name|WellKnownConnections
operator|&=
operator|~
operator|(
literal|1L
operator|<<
name|unixDomainConnection
operator|)
expr_stmt|;
name|unixDomainConnection
operator|=
name|open_unix_socket
argument_list|()
expr_stmt|;
if|if
condition|(
name|unixDomainConnection
operator|!=
operator|-
literal|1
condition|)
name|WellKnownConnections
operator||=
operator|(
literal|1L
operator|<<
name|unixDomainConnection
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* UNIXCONN */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_comment
comment|/*  * Convenience routine...  * client = transport descriptor  * data, size = buffer  * nonblock = NOTOK, blocks, OK, non blocks  */
end_comment

begin_macro
name|TReadFromClient
argument_list|(
argument|client
argument_list|,
argument|data
argument_list|,
argument|size
argument_list|,
argument|nonblock
argument_list|)
end_macro

begin_decl_stmt
name|int
name|client
decl_stmt|,
name|size
decl_stmt|,
name|nonblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|static
name|struct
name|TSAPdata
name|txs
decl_stmt|;
specifier|static
name|struct
name|TSAPdata
modifier|*
name|tx
init|=
operator|&
name|txs
decl_stmt|;
name|char
modifier|*
name|aptr
decl_stmt|;
specifier|static
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
specifier|static
name|char
modifier|*
name|qptr
decl_stmt|;
specifier|static
name|int
name|ingot
decl_stmt|,
name|qcpy
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|int
name|q2data
decl_stmt|;
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TReadFromClient %d want %d (%d buffered)\n"
argument_list|,
name|client
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ISODEBUG */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|TReadRequest
argument_list|(
name|client
argument_list|,
name|tx
argument_list|,
name|nonblock
argument_list|,
name|td
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server TReadReq: would block %s\n"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DR_FATAL
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
condition|)
name|errno
operator|=
name|EWOULDBLOCK
expr_stmt|;
else|else
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server TReadReq: %s\n"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISODEBUG */
comment|/*  * map problems here - eg TimeOut...  */
if|if
condition|(
name|td
operator|->
name|td_reason
operator|==
name|DR_TIMER
condition|)
name|errno
operator|=
name|EWOULDBLOCK
expr_stmt|;
return|return
name|ret
return|;
block|}
name|result
operator|=
name|tx
operator|->
name|tx_cc
expr_stmt|;
name|qb
operator|=
operator|&
operator|(
name|tx
operator|->
name|tx_qbuf
operator|)
expr_stmt|;
name|qptr
operator|=
name|qb
operator|->
name|qb_data
expr_stmt|;
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TReadRequest want %d got %d\n"
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ISODEBUG
else|else
block|{
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TReadFromClient want %d buffered %d\n"
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  * Buffer it  */
name|ingot
operator|=
literal|0
expr_stmt|;
name|aptr
operator|=
name|data
expr_stmt|;
for|for
control|(
name|ingot
operator|=
literal|0
operator|,
name|aptr
operator|=
name|data
operator|,
name|q2data
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|result
argument_list|)
init|;
name|ingot
operator|<
name|q2data
condition|;
name|aptr
operator|+=
name|qcpy
operator|,
name|ingot
operator|+=
name|qcpy
control|)
block|{
name|int
name|aleft
init|=
name|q2data
operator|-
name|ingot
decl_stmt|;
if|if
condition|(
name|qb
operator|->
name|qb_len
operator|>
name|aleft
condition|)
block|{
name|qcpy
operator|=
name|aleft
expr_stmt|;
name|bcopy
argument_list|(
name|qptr
argument_list|,
name|aptr
argument_list|,
name|qcpy
argument_list|)
expr_stmt|;
name|qptr
operator|+=
name|aleft
expr_stmt|;
block|}
else|else
block|{
name|qcpy
operator|=
name|qb
operator|->
name|qb_len
expr_stmt|;
name|bcopy
argument_list|(
name|qb
operator|->
name|qb_data
argument_list|,
name|aptr
argument_list|,
name|qcpy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qb
operator|=
name|qb
operator|->
name|qb_forw
operator|)
operator|==
name|NULL
condition|)
break|break;
name|qptr
operator|=
name|qb
operator|->
name|qb_data
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|result
operator|-=
name|ingot
operator|)
operator|<=
literal|0
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
name|TXFREE
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
return|return
name|ingot
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_comment
comment|/* We want to read the connection information.  If the client doesn't  * send us enough data, however, we want to time out eventually.  * The scheme is to clear a flag, set an alarm, and keep doing non-blocking  * reads until we get all the data we want. If the alarm goes  * off, the handler will clear the flag.  If we see that the flag is  * cleared, we know we've timed out and return with an error.  *  * there remains one problem with this code:  * there is a window of vulnerability in which we might get an alarm  * even though all the data has come in properly.  This is because I  * can't atomically clear the alarm.  *   * Anyone who sees how to fix this problem should do so and  * submit a fix.  */
end_comment

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|TimeOut
parameter_list|()
block|{
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Bool
name|ReadBuffer
parameter_list|(
name|conn
parameter_list|,
name|buffer
parameter_list|,
name|charsWanted
parameter_list|)
name|long
name|conn
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|charsWanted
decl_stmt|;
block|{
name|char
modifier|*
name|bptr
init|=
name|buffer
decl_stmt|;
name|int
name|got
decl_stmt|,
name|fTimeOut
decl_stmt|;
name|struct
name|itimerval
name|itv
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|TimeOut
argument_list|)
expr_stmt|;
name|fTimeOut
operator|=
name|FALSE
expr_stmt|;
comment|/* only 1 alarm, please, not 1 per minute */
name|timerclear
argument_list|(
operator|&
name|itv
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|TimeOutValue
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* It better not take a full minute to get to the read call */
while|while
condition|(
name|charsWanted
operator|&&
operator|(
name|fTimeOut
operator|=
name|setjmp
argument_list|(
name|env
argument_list|)
operator|)
operator|==
name|FALSE
condition|)
block|{
ifdef|#
directive|ifdef
name|ISOCONN
name|got
operator|=
name|SRead
argument_list|(
name|conn
argument_list|,
name|bptr
argument_list|,
name|charsWanted
argument_list|,
name|NOTOK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|got
operator|=
name|read
argument_list|(
name|conn
argument_list|,
name|bptr
argument_list|,
name|charsWanted
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|got
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|got
operator|>
literal|0
condition|)
block|{
name|charsWanted
operator|-=
name|got
expr_stmt|;
name|bptr
operator|+=
name|got
expr_stmt|;
comment|/* Ok, we got something, reset the timer */
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|TimeOutValue
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* disable the timer */
name|timerclear
argument_list|(
operator|&
name|itv
operator|.
name|it_value
argument_list|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we got here and we didn't time out, then return TRUE, because      * we must have read what we wanted. If we timed out, return FALSE */
if|if
condition|(
name|fTimeOut
operator|&&
name|debug_conns
condition|)
name|ErrorF
argument_list|(
literal|"Timed out on connection %d\n"
argument_list|,
name|conn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|fTimeOut
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_comment
comment|/*  * Who's calling us?  */
end_comment

begin_macro
name|getISOpeername
argument_list|(
argument|conn
argument_list|,
argument|from
argument_list|,
argument|alen
argument_list|)
end_macro

begin_decl_stmt
name|int
name|conn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|TSAPaddr
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|alen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|TSAPdisconnect
name|td
decl_stmt|;
if|if
condition|(
name|TGetAddresses
argument_list|(
name|conn
argument_list|,
name|from
argument_list|,
name|NULLTA
argument_list|,
operator|&
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|Error
argument_list|(
name|TErrString
argument_list|(
name|td
operator|.
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
empty_stmt|;
operator|*
name|alen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|TSAPaddr
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_comment
comment|/*****************************************************************  * ClientAuthorized  *  *    Sent by the client at connection setup:  *                typedef struct _xConnClientPrefix {  *                   CARD8	byteOrder;  *                   BYTE	pad;  *                   CARD16	majorVersion, minorVersion;  *                   CARD16	nbytesAuthProto;      *                   CARD16	nbytesAuthString;     *                 } xConnClientPrefix;  *  *     	It is hoped that eventually one protocol will be agreed upon.  In the  *        mean time, a server that implements a different protocol than the  *        client expects, or a server that only implements the host-based  *        mechanism, will simply ignore this information.  *  *****************************************************************/
end_comment

begin_function
name|int
name|ClientAuthorized
parameter_list|(
name|conn
parameter_list|,
name|pswapped
parameter_list|,
name|reason
parameter_list|)
name|long
name|conn
decl_stmt|;
name|int
modifier|*
name|pswapped
decl_stmt|;
name|char
modifier|*
modifier|*
name|reason
decl_stmt|;
comment|/* if authorization fails, put reason in here */
block|{
name|short
name|slen
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIXCONN
name|struct
name|sockaddr_un
name|un
decl_stmt|;
endif|#
directive|endif
comment|/* UNIXCONN */
ifdef|#
directive|ifdef
name|TCPCONN
name|struct
name|sockaddr_in
name|in
decl_stmt|;
endif|#
directive|endif
comment|/* TCPCONN */
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|sockaddr_dn
name|dn
decl_stmt|;
endif|#
directive|endif
comment|/* DNETCONN */
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPaddr
name|ts
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
name|from
union|;
name|int
name|fromlen
decl_stmt|;
name|xConnClientPrefix
name|xccp
decl_stmt|;
name|char
name|auth_proto
index|[
literal|100
index|]
decl_stmt|;
name|char
name|auth_string
index|[
literal|100
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * For now we always auth an ISO client!!  * should use directory etc etc  */
operator|*
name|reason
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
operator|!
name|ReadBuffer
argument_list|(
name|conn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|xccp
argument_list|,
sizeof|sizeof
argument_list|(
name|xConnClientPrefix
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If they can't even give us this much, just blow them off 	 * without an error message */
operator|*
name|reason
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|xccp
operator|.
name|byteOrder
operator|!=
name|whichByteIsFirst
condition|)
block|{
name|SwapConnClientPrefix
argument_list|(
operator|&
name|xccp
argument_list|)
expr_stmt|;
operator|*
name|pswapped
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
operator|*
name|pswapped
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|xccp
operator|.
name|majorVersion
operator|!=
name|X_PROTOCOL
operator|)
operator|||
operator|(
name|xccp
operator|.
name|minorVersion
operator|!=
name|X_PROTOCOL_REVISION
operator|)
condition|)
block|{
define|#
directive|define
name|STR
value|"Protocol version mismatch"
operator|*
name|reason
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|STR
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|reason
argument_list|,
name|STR
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_conns
condition|)
name|ErrorF
argument_list|(
literal|"%s\n"
argument_list|,
name|STR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|STR
return|return
literal|0
return|;
block|}
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
if|if
condition|(
name|SGetPeerName
argument_list|(
name|conn
argument_list|,
operator|&
operator|(
name|from
operator|.
name|ts
operator|)
argument_list|,
operator|&
name|fromlen
argument_list|)
operator|||
name|InvalidHost
argument_list|(
operator|&
operator|(
name|from
operator|.
name|ts
operator|)
argument_list|,
name|fromlen
argument_list|)
condition|)
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
name|getpeername
argument_list|(
name|conn
argument_list|,
operator|&
name|from
operator|.
name|sa
argument_list|,
operator|&
name|fromlen
argument_list|)
operator|||
name|InvalidHost
argument_list|(
operator|&
name|from
operator|.
name|sa
argument_list|,
name|fromlen
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ISOCONN */
block|{
define|#
directive|define
name|STR
value|"Server is not authorized to connect to host"
operator|*
name|reason
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|STR
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|reason
argument_list|,
name|STR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|STR
return|return
literal|0
return|;
block|}
name|slen
operator|=
operator|(
name|xccp
operator|.
name|nbytesAuthProto
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|slen
condition|)
if|if
condition|(
operator|!
name|ReadBuffer
argument_list|(
name|conn
argument_list|,
name|auth_proto
argument_list|,
name|slen
argument_list|)
condition|)
block|{
define|#
directive|define
name|STR
value|"Length error in xConnClientPrefix for protocol authorization "
operator|*
name|reason
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|STR
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|reason
argument_list|,
name|STR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|STR
block|}
name|auth_proto
index|[
name|slen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|slen
operator|=
operator|(
name|xccp
operator|.
name|nbytesAuthString
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|slen
condition|)
if|if
condition|(
operator|!
name|ReadBuffer
argument_list|(
name|conn
argument_list|,
name|auth_string
argument_list|,
name|slen
argument_list|)
condition|)
block|{
define|#
directive|define
name|STR
value|"Length error in xConnClientPrefix for protocol string"
operator|*
name|reason
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|STR
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|reason
argument_list|,
name|STR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|STR
block|}
name|auth_string
index|[
name|slen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* At this point, if the client is authorized to change the access control      * list, we should getpeername() information, and add the client to      * the selfhosts list.  It's not really the host machine, but the      * true purpose of the selfhosts list is to see who may change the      * access control list.      */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|padlength
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************  * EstablishNewConnections  *    If anyone is waiting on listened sockets, accept them.  *    Returns a mask with indices of new clients.  Updates AllClients  *    and AllSockets.  *****************/
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ISOCONN
name|EstablishNewConnections
parameter_list|(
name|newclients
parameter_list|,
name|nnew
parameter_list|,
name|vecp
parameter_list|,
name|vec
parameter_list|)
name|ClientPtr
modifier|*
name|newclients
decl_stmt|;
name|int
modifier|*
name|nnew
decl_stmt|;
name|int
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
else|#
directive|else
comment|/* ISOCONN */
function|EstablishNewConnections
parameter_list|(
name|newclients
parameter_list|,
name|nnew
parameter_list|)
name|ClientPtr
modifier|*
name|newclients
decl_stmt|;
name|int
modifier|*
name|nnew
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
block|{
name|long
name|readyconnections
decl_stmt|;
comment|/* mask of listeners that are ready */
name|long
name|curconn
decl_stmt|;
comment|/* fd of listener that's ready */
name|long
name|newconn
decl_stmt|;
comment|/* fd of new client */
name|int
name|swapped
decl_stmt|;
comment|/* set by ClientAuthorized if connection is 				 * swapped */
name|char
modifier|*
name|reason
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|udvec
name|uv
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|struct
name|TSAPstart
name|tsts
decl_stmt|;
name|struct
name|TSAPstart
modifier|*
name|tst
init|=
operator|&
name|tsts
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|char
name|p
index|[
literal|3
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_NODELAY
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIXCONN
name|struct
name|sockaddr_un
name|un
decl_stmt|;
endif|#
directive|endif
comment|/* UNIXCONN */
ifdef|#
directive|ifdef
name|TCPCONN
name|struct
name|sockaddr_in
name|in
decl_stmt|;
endif|#
directive|endif
comment|/* TCPCONN */
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|sockaddr_dn
name|dn
decl_stmt|;
endif|#
directive|endif
comment|/* DNETCONN */
block|}
name|from
union|;
name|int
name|fromlen
decl_stmt|;
endif|#
directive|endif
endif|TCP_NODELAY
operator|*
name|nnew
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|readyconnections
operator|=
operator|(
name|LastSelectMask
index|[
literal|0
index|]
operator|&
name|WellKnownConnections
operator|)
condition|)
block|{
while|while
condition|(
name|readyconnections
condition|)
block|{
name|curconn
operator|=
name|ffs
argument_list|(
name|readyconnections
argument_list|)
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
comment|/*  * At this point, a TAccept has finished with a vec> 0  * so we need to init them...  */
if|if
condition|(
operator|(
name|newconn
operator|=
name|SAccept
argument_list|(
name|curconn
argument_list|,
name|vecp
argument_list|,
name|vec
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|fd2family
index|[
name|newconn
index|]
operator|=
name|ISODE_IO
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
if|if
condition|(
operator|(
name|newconn
operator|=
name|accept
argument_list|(
name|curconn
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|fd2family
index|[
name|newconn
index|]
operator|=
name|UNIX_IO
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|newconn
operator|>=
name|lastfdesc
condition|)
block|{
if|if
condition|(
name|debug_conns
condition|)
name|ErrorF
argument_list|(
literal|"Didn't make connection: Out of file descriptors for connections\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|SClose
argument_list|(
name|newconn
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|close
argument_list|(
name|newconn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
block|}
else|else
block|{
name|ClientPtr
name|next
init|=
operator|(
name|ClientPtr
operator|)
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP_NODELAY
ifdef|#
directive|ifdef
name|ISOCONN
if|if
condition|(
name|fd2family
argument_list|(
name|newconn
argument_list|)
operator|==
name|UNIX_IO
condition|)
block|{
endif|#
directive|endif
comment|/* ISOCONN */
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getpeername
argument_list|(
name|newconn
argument_list|,
operator|&
name|from
operator|.
name|sa
argument_list|,
operator|&
name|fromlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|fromlen
operator|&&
operator|(
name|from
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
name|int
name|mi
init|=
literal|1
decl_stmt|;
name|setsockopt
argument_list|(
name|newconn
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ISOCONN
block|}
endif|#
directive|endif
comment|/* ISOCONN */
endif|#
directive|endif
comment|/* TCP_NODELAY */
if|if
condition|(
name|ClientAuthorized
argument_list|(
name|newconn
argument_list|,
operator|&
name|swapped
argument_list|,
operator|&
name|reason
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|hpux
comment|/* 			 * HPUX does not have  FNDELAY 			 */
block|{
name|int
name|arg
decl_stmt|;
name|arg
operator|=
literal|1
expr_stmt|;
name|ioctl
argument_list|(
name|newconn
argument_list|,
name|FIOSNBIO
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fcntl
argument_list|(
name|newconn
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hpux */
name|inputBuffers
index|[
name|newconn
index|]
operator|.
name|used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|inputBuffers
index|[
name|newconn
index|]
operator|.
name|size
condition|)
block|{
name|inputBuffers
index|[
name|newconn
index|]
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|BUFSIZE
argument_list|)
expr_stmt|;
name|inputBuffers
index|[
name|newconn
index|]
operator|.
name|size
operator|=
name|BUFSIZE
expr_stmt|;
name|inputBuffers
index|[
name|newconn
index|]
operator|.
name|bufptr
operator|=
name|inputBuffers
index|[
name|newconn
index|]
operator|.
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|GrabDone
condition|)
block|{
name|BITSET
argument_list|(
name|SavedAllClients
argument_list|,
name|newconn
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|SavedAllSockets
argument_list|,
name|newconn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BITSET
argument_list|(
name|AllClients
argument_list|,
name|newconn
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|AllSockets
argument_list|,
name|newconn
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|NextAvailableClient
argument_list|()
expr_stmt|;
if|if
condition|(
name|next
operator|!=
operator|(
name|ClientPtr
operator|)
name|NULL
condition|)
block|{
name|OsCommPtr
name|priv
decl_stmt|;
name|newclients
index|[
operator|(
operator|*
name|nnew
operator|)
operator|++
index|]
operator|=
name|next
expr_stmt|;
name|next
operator|->
name|swapped
operator|=
name|swapped
expr_stmt|;
name|ConnectionTranslation
index|[
name|newconn
index|]
operator|=
name|next
expr_stmt|;
name|priv
operator|=
operator|(
name|OsCommPtr
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|OsCommRec
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|fd
operator|=
name|newconn
expr_stmt|;
name|priv
operator|->
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|OutputBufferSize
argument_list|)
expr_stmt|;
name|priv
operator|->
name|bufsize
operator|=
name|OutputBufferSize
expr_stmt|;
name|priv
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|osPrivate
operator|=
operator|(
name|pointer
operator|)
name|priv
expr_stmt|;
block|}
else|else
block|{
define|#
directive|define
name|STR
value|"Maximum number of clients exceeded"
name|reason
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|STR
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|reason
argument_list|,
name|STR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|STR
block|}
block|}
if|if
condition|(
name|next
operator|==
operator|(
name|ClientPtr
operator|)
name|NULL
condition|)
block|{
name|xConnSetupPrefix
name|c
decl_stmt|;
if|if
condition|(
name|reason
condition|)
block|{
name|c
operator|.
name|success
operator|=
name|xFalse
expr_stmt|;
name|c
operator|.
name|lengthReason
operator|=
name|strlen
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|c
operator|.
name|length
operator|=
operator|(
name|c
operator|.
name|lengthReason
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
name|c
operator|.
name|majorVersion
operator|=
name|X_PROTOCOL
expr_stmt|;
name|c
operator|.
name|minorVersion
operator|=
name|X_PROTOCOL_REVISION
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
block|{
name|int
name|n
decl_stmt|;
name|swaps
argument_list|(
operator|&
name|c
operator|.
name|majorVersion
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|swaps
argument_list|(
operator|&
name|c
operator|.
name|minorVersion
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|swaps
argument_list|(
operator|&
name|c
operator|.
name|length
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISOCONN
operator|(
name|void
operator|)
name|SWrite
argument_list|(
name|newconn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|xConnSetupPrefix
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|write
argument_list|(
name|newconn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|xConnSetupPrefix
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|c
operator|.
name|lengthReason
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|reason
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|padlength
index|[
name|c
operator|.
name|lengthReason
operator|&
literal|3
index|]
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|SWritev
argument_list|(
name|newconn
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|writev
argument_list|(
name|newconn
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|debug_conns
condition|)
name|ErrorF
argument_list|(
literal|"Didn't make connection:%s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISOCONN
name|SClose
argument_list|(
name|newconn
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|close
argument_list|(
name|newconn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|xfree
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|readyconnections
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|curconn
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/************  *   CloseDownFileDescriptor:  *     Remove this file descriptor and it's inputbuffers, etc.  ************/
name|void
name|CloseDownFileDescriptor
parameter_list|(
name|connection
parameter_list|)
name|int
name|connection
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
ifdef|#
directive|ifdef
name|ISODEBUG
if|if
condition|(
name|isodexbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server: TDiscReq\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISODEBUG */
name|SClose
argument_list|(
name|connection
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|close
argument_list|(
name|connection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|size
condition|)
block|{
name|xfree
argument_list|(
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|bufptr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|lenLastReq
operator|=
literal|0
expr_stmt|;
name|inputBuffers
index|[
name|connection
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|BITCLEAR
argument_list|(
name|AllSockets
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|BITCLEAR
argument_list|(
name|AllClients
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|BITCLEAR
argument_list|(
name|ClientsWithInput
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|BITCLEAR
argument_list|(
name|ClientsWriteBlocked
argument_list|,
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ANYSET
argument_list|(
name|ClientsWriteBlocked
argument_list|)
condition|)
name|AnyClientsWriteBlocked
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*****************  * CheckConections  *    Some connection has died, go find which one and shut it down   *    The file descriptor has been closed, but is still in AllClients.  *    If would truly be wonderful if select() would put the bogus  *    file descriptors in the exception mask, but nooooo.  So we have  *    to check each and every socket individually.  *****************/
name|void
name|CheckConnections
parameter_list|()
block|{
name|long
name|mask
index|[
name|mskcnt
index|]
decl_stmt|;
name|long
name|tmask
index|[
name|mskcnt
index|]
decl_stmt|;
specifier|register
name|int
name|curclient
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|notime
decl_stmt|;
name|ClientPtr
name|bad
decl_stmt|;
name|int
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
name|int
name|vecp
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|notime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|notime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|COPYBITS
argument_list|(
name|AllClients
argument_list|,
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mskcnt
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|mask
index|[
name|i
index|]
condition|)
block|{
name|curclient
operator|=
name|ffs
argument_list|(
name|mask
index|[
name|i
index|]
argument_list|)
operator|-
literal|1
operator|+
operator|(
name|i
operator|<<
literal|5
operator|)
expr_stmt|;
name|CLEARBITS
argument_list|(
name|tmask
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|tmask
argument_list|,
name|curclient
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
name|r
operator|=
name|TNetAccept
argument_list|(
operator|&
name|vecp
argument_list|,
name|vec
argument_list|,
name|curclient
operator|+
literal|1
argument_list|,
name|tmask
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|OK
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NOTOK
condition|)
block|{
name|Error
argument_list|(
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"TNetAccept"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISOCONN */
name|r
operator|=
name|select
argument_list|(
name|curclient
operator|+
literal|1
argument_list|,
name|tmask
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|notime
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* ISOCONN */
if|if
condition|(
name|bad
operator|=
name|ConnectionTranslation
index|[
name|curclient
index|]
condition|)
name|CloseDownClient
argument_list|(
name|bad
argument_list|)
expr_stmt|;
else|else
name|CloseDownFileDescriptor
argument_list|(
name|curclient
argument_list|)
expr_stmt|;
block|}
name|BITCLEAR
argument_list|(
name|mask
argument_list|,
name|curclient
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*****************  * CloseDownConnection  *    Delete client from AllClients and free resources   *****************/
name|CloseDownConnection
argument_list|(
argument|client
argument_list|)
name|ClientPtr
name|client
decl_stmt|;
block|{
name|OsCommPtr
name|oc
init|=
operator|(
name|OsCommPtr
operator|)
name|client
operator|->
name|osPrivate
decl_stmt|;
name|ConnectionTranslation
index|[
name|oc
operator|->
name|fd
index|]
operator|=
operator|(
name|ClientPtr
operator|)
name|NULL
expr_stmt|;
name|CloseDownFileDescriptor
argument_list|(
name|oc
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|oc
operator|->
name|buf
operator|!=
name|NULL
condition|)
comment|/* an Xrealloc may have returned NULL */
name|xfree
argument_list|(
name|oc
operator|->
name|buf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|client
operator|->
name|osPrivate
argument_list|)
expr_stmt|;
block|}
name|AddEnabledDevice
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
decl_stmt|;
block|{
name|EnabledDevices
operator||=
operator|(
literal|1
operator|<<
name|fd
operator|)
expr_stmt|;
name|BITSET
argument_list|(
name|AllSockets
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|RemoveEnabledDevice
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
decl_stmt|;
block|{
name|EnabledDevices
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|fd
operator|)
expr_stmt|;
name|BITCLEAR
argument_list|(
name|AllSockets
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/*****************  * OnlyListenToOneClient:  *    Only accept requests from  one client.  Continue to handle new  *    connections, but don't take any protocol requests from the new  *    ones.  Note that if GrabDone is set, EstablishNewConnections  *    needs to put new clients into SavedAllSockets and SavedAllClients.  *    Note also that there is no timeout for this in the protocol.  *    This routine is "undone" by ListenToAllClients()  *****************/
name|OnlyListenToOneClient
argument_list|(
argument|client
argument_list|)
name|ClientPtr
name|client
decl_stmt|;
block|{
name|OsCommPtr
name|oc
init|=
operator|(
name|OsCommPtr
operator|)
name|client
operator|->
name|osPrivate
decl_stmt|;
name|int
name|connection
init|=
name|oc
operator|->
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|GrabDone
condition|)
block|{
name|COPYBITS
argument_list|(
name|ClientsWithInput
argument_list|,
name|SavedClientsWithInput
argument_list|)
expr_stmt|;
name|BITCLEAR
argument_list|(
name|SavedClientsWithInput
argument_list|,
name|connection
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETBIT
argument_list|(
name|ClientsWithInput
argument_list|,
name|connection
argument_list|)
condition|)
block|{
name|CLEARBITS
argument_list|(
name|ClientsWithInput
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|ClientsWithInput
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLEARBITS
argument_list|(
name|ClientsWithInput
argument_list|)
expr_stmt|;
block|}
name|COPYBITS
argument_list|(
name|AllSockets
argument_list|,
name|SavedAllSockets
argument_list|)
expr_stmt|;
name|COPYBITS
argument_list|(
name|AllClients
argument_list|,
name|SavedAllClients
argument_list|)
expr_stmt|;
name|UNSETBITS
argument_list|(
name|AllSockets
argument_list|,
name|AllClients
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|AllSockets
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|CLEARBITS
argument_list|(
name|AllClients
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|AllClients
argument_list|,
name|connection
argument_list|)
expr_stmt|;
name|GrabDone
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/****************  * ListenToAllClients:  *    Undoes OnlyListentToOneClient()  ****************/
name|ListenToAllClients
argument_list|()
block|{
if|if
condition|(
name|GrabDone
condition|)
block|{
name|ORBITS
argument_list|(
name|AllSockets
argument_list|,
name|AllSockets
argument_list|,
name|SavedAllSockets
argument_list|)
expr_stmt|;
name|ORBITS
argument_list|(
name|AllClients
argument_list|,
name|AllClients
argument_list|,
name|SavedAllClients
argument_list|)
expr_stmt|;
name|ORBITS
argument_list|(
name|ClientsWithInput
argument_list|,
name|ClientsWithInput
argument_list|,
name|SavedClientsWithInput
argument_list|)
expr_stmt|;
name|GrabDone
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

end_unit

