begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_xinit_c
init|=
literal|"$XConsortium: xinit.c,v 11.32 88/10/05 09:27:45 jim Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|<X11/copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1986	*/
end_comment

begin_include
include|#
directive|include
file|<X11/Xos.h>
end_include

begin_include
include|#
directive|include
file|<X11/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV
end_ifndef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|newenviron
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SHELL
end_ifndef

begin_define
define|#
directive|define
name|SHELL
value|"sh"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|macII
end_ifdef

begin_define
define|#
directive|define
name|vfork
parameter_list|()
value|fork()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* macII */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|hpux
argument_list|)
end_if

begin_define
define|#
directive|define
name|vfork
parameter_list|()
value|fork()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV and not hpux */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bindir
init|=
name|BINDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|server_names
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|vax
comment|/* Digital */
literal|"Xqvss       Digital monochrome display on Microvax II or III series"
block|,
literal|"Xqdss       Digital color display on Microvax II or III series"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sun
comment|/* Sun */
literal|"Xsun        Sun monochrome and color displays on Sun 2, 3, or 4 series"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hpux
comment|/* HP */
literal|"Xhp         HP monochrome and colors displays on 9000/300 series"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|apollo
comment|/* Apollo */
literal|"Xapollo     Apollo monochrome and color displays"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ibm
comment|/* IBM */
literal|"Xibm        IBM AED, APA, 8514a, megapel, VGA displays on PC/RT"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|macII
comment|/* MacII */
literal|"XmacII      Apple monochrome display on Macintosh II"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|M4310
comment|/* Tektronix Pegasus */
literal|"Xpeg        Tektronix Pegasus display on 4310"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* Parallax */
literal|"Xplx        Parallax color and video graphics controller"
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|XINITRC
end_ifndef

begin_define
define|#
directive|define
name|XINITRC
value|".xinitrc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|xinitrcbuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|XSERVERRC
end_ifndef

begin_define
define|#
directive|define
name|XSERVERRC
value|".xserverrc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|xserverrcbuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|OK_EXIT
value|0
end_define

begin_define
define|#
directive|define
name|ERR_EXIT
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_decl_stmt
name|char
name|displayname
index|[
literal|100
index|]
init|=
literal|":X0"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|char
name|displayname
index|[
literal|100
index|]
init|=
literal|"unix"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|char
name|client_display
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ISOCONN
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|default_server
init|=
literal|"Xsun"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|default_display
init|=
literal|":X0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* choose most efficient */
end_comment

begin_decl_stmt
name|char
modifier|*
name|default_client
index|[]
init|=
block|{
literal|"xt"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|char
modifier|*
name|default_server
init|=
literal|"X"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|default_display
init|=
literal|":0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* choose most efficient */
end_comment

begin_decl_stmt
name|char
modifier|*
name|default_client
index|[]
init|=
block|{
literal|"xterm"
block|,
literal|"-geometry"
block|,
literal|"+1+1"
block|,
literal|"-n"
block|,
literal|"login"
block|,
literal|"-display perky:X0"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISOCONN */
end_comment

begin_decl_stmt
name|char
modifier|*
name|serverargv
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|clientargv
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|server
init|=
name|serverargv
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make sure room for sh .xserverrc args */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|client
init|=
name|clientargv
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make sure room for sh .xinitrc args */
end_comment

begin_decl_stmt
name|char
modifier|*
name|displayNum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|program
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Display
modifier|*
name|xd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server connection */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV
end_ifndef

begin_decl_stmt
name|union
name|wait
name|status
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV */
end_comment

begin_decl_stmt
name|int
name|serverpid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clientpid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_macro
name|sigCatch
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"unexpected signal %d\r\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|serverpid
argument_list|,
name|clientpid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_macro
name|sigAlarm
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|sigAlarm
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV */
end_comment

begin_expr_stmt
specifier|static
name|Execute
argument_list|(
argument|vec
argument_list|)
name|char
operator|*
operator|*
name|vec
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* has room from up above */
end_comment

begin_block
block|{
name|execvp
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vec
operator|--
expr_stmt|;
comment|/* back it up to stuff shell in */
name|vec
index|[
literal|0
index|]
operator|=
name|SHELL
expr_stmt|;
name|execvp
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|sptr
init|=
name|server
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|cptr
init|=
name|client
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|i
decl_stmt|;
name|int
name|client_given
init|=
literal|0
decl_stmt|,
name|server_given
init|=
literal|0
decl_stmt|;
name|int
name|client_args_given
init|=
literal|0
decl_stmt|,
name|server_args_given
init|=
literal|0
decl_stmt|;
name|int
name|start_of_client_args
decl_stmt|,
name|start_of_server_args
decl_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|char
modifier|*
name|cd
decl_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
name|program
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
ifndef|#
directive|ifndef
name|UNIXCONN
ifdef|#
directive|ifdef
name|hpux
comment|/* Why not use gethostname()?  Well, at least on my system, I've had to 	 * make an ugly kernel patch to get a name longer than 8 characters, and 	 * uname() lets me access to the whole string (it smashes release, you 	 * see), whereas gethostname() kindly truncates it for me. 	 */
block|{
name|struct
name|utsname
name|name
decl_stmt|;
name|uname
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|displayname
argument_list|,
name|name
operator|.
name|nodename
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|gethostname
argument_list|(
name|displayname
argument_list|,
sizeof|sizeof
argument_list|(
name|displayname
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISOCONN
if|if
condition|(
operator|(
name|cd
operator|=
name|index
argument_list|(
name|displayname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cd
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* ISOCONN */
endif|#
directive|endif
endif|#
directive|endif
comment|/* UNIXCONN */
comment|/* 	 * copy the client args. 	 */
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
operator|(
operator|*
operator|*
name|argv
operator|!=
literal|'/'
operator|&&
operator|*
operator|*
name|argv
operator|!=
literal|'.'
operator|&&
operator|!
name|isalpha
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|default_client
init|;
operator|*
name|ptr
condition|;
control|)
operator|*
name|cptr
operator|++
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|client_display
argument_list|,
name|displayname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|client_display
argument_list|,
name|default_display
argument_list|)
expr_stmt|;
operator|*
name|cptr
operator|++
operator|=
name|client_display
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
comment|/*  		 * If running on a sun, and if WINDOW_PARENT isn't defined,  		 * that means SunWindows isn't running, so we should pass  		 * the -C flag to xterm so that it sets up a console. 		 */
if|if
condition|(
name|getenv
argument_list|(
literal|"WINDOW_PARENT"
argument_list|)
operator|==
name|NULL
condition|)
operator|*
name|cptr
operator|++
operator|=
literal|"-C"
expr_stmt|;
endif|#
directive|endif
comment|/* sun */
block|}
else|else
block|{
name|client_given
operator|=
literal|1
expr_stmt|;
block|}
name|start_of_client_args
operator|=
operator|(
name|cptr
operator|-
name|client
operator|)
expr_stmt|;
while|while
condition|(
name|argc
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|client_args_given
operator|++
expr_stmt|;
operator|*
name|cptr
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
operator|*
name|cptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
comment|/* 	 * Copy the server args. 	 */
if|if
condition|(
name|argc
operator|==
literal|0
operator|||
operator|(
operator|*
operator|*
name|argv
operator|!=
literal|'/'
operator|&&
operator|*
operator|*
name|argv
operator|!=
literal|'.'
operator|&&
operator|!
name|isalpha
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
operator|)
condition|)
block|{
operator|*
name|sptr
operator|++
operator|=
name|default_server
expr_stmt|;
block|}
else|else
block|{
name|server_given
operator|=
literal|1
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|isdigit
argument_list|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
name|displayNum
operator|=
operator|*
name|argv
expr_stmt|;
else|else
name|displayNum
operator|=
operator|*
name|sptr
operator|++
operator|=
name|default_display
expr_stmt|;
name|start_of_server_args
operator|=
operator|(
name|sptr
operator|-
name|server
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>=
literal|0
condition|)
block|{
name|server_args_given
operator|++
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
block|}
operator|*
name|sptr
operator|=
name|NULL
expr_stmt|;
name|strcat
argument_list|(
name|displayname
argument_list|,
name|displayNum
argument_list|)
expr_stmt|;
comment|/* 	 * if no client arguments given, check for a startup file and copy 	 * that into the argument list 	 */
if|if
condition|(
operator|!
name|client_given
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|Bool
name|required
init|=
name|False
decl_stmt|;
name|xinitrcbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"XINITRC"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|xinitrcbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|required
operator|=
name|True
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xinitrcbuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|cp
argument_list|,
name|XINITRC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xinitrcbuf
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|xinitrcbuf
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|client
operator|+=
name|start_of_client_args
operator|-
literal|1
expr_stmt|;
name|client
index|[
literal|0
index|]
operator|=
name|xinitrcbuf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|required
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  warning, no client init file \"%s\"\n"
argument_list|,
name|program
argument_list|,
name|xinitrcbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * if no server arguments given, check for a startup file and copy 	 * that into the argument list 	 */
if|if
condition|(
operator|!
name|server_given
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|Bool
name|required
init|=
name|False
decl_stmt|;
name|xserverrcbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"XSERVERRC"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|xserverrcbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|required
operator|=
name|True
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xserverrcbuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|cp
argument_list|,
name|XSERVERRC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xserverrcbuf
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|xserverrcbuf
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|server
operator|+=
name|start_of_server_args
operator|-
literal|1
expr_stmt|;
name|server
index|[
literal|0
index|]
operator|=
name|xserverrcbuf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|required
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  warning, no server init file \"%s\"\n"
argument_list|,
name|program
argument_list|,
name|xserverrcbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * put the display name into the environment 	 */
name|set_environment
argument_list|()
expr_stmt|;
comment|/* 	 * Start the server and client. 	 */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigCatch
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigCatch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigAlarm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYSV */
if|if
condition|(
operator|(
name|serverpid
operator|=
name|startServer
argument_list|(
name|server
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|(
name|clientpid
operator|=
name|startClient
argument_list|(
name|client
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|pid
operator|!=
name|clientpid
operator|&&
name|pid
operator|!=
name|serverpid
condition|)
name|pid
operator|=
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|serverpid
argument_list|,
name|clientpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|serverpid
operator|<
literal|0
operator|||
name|clientpid
operator|<
literal|0
condition|)
name|exit
argument_list|(
name|ERR_EXIT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|OK_EXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	waitforserver - wait for X server to start up  */
end_comment

begin_macro
name|waitforserver
argument_list|(
argument|serverpid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|serverpid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ncycles
init|=
literal|120
decl_stmt|;
comment|/* # of cycles to wait */
name|int
name|cycles
decl_stmt|;
comment|/* Wait cycle count */
ifdef|#
directive|ifdef
name|ISOCONN
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|cycles
operator|=
literal|0
init|;
name|cycles
operator|<
name|ncycles
condition|;
name|cycles
operator|++
control|)
block|{
if|if
condition|(
name|xd
operator|=
name|XOpenDisplay
argument_list|(
name|displayname
argument_list|)
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
define|#
directive|define
name|MSG
value|"X server to begin accepting connections"
if|if
condition|(
operator|!
name|processTimeout
argument_list|(
name|serverpid
argument_list|,
literal|1
argument_list|,
name|MSG
argument_list|)
condition|)
break|break;
undef|#
directive|undef
name|MSG
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"giving up.\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * return TRUE if we timeout waiting for pid to exit, FALSE otherwise.  */
end_comment

begin_macro
name|processTimeout
argument_list|(
argument|pid
argument_list|,
argument|timeout
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|,
name|timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|pidfound
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|char
modifier|*
name|laststring
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|SYSV
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pidfound
operator|=
name|wait
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|pid
condition|)
break|break;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYSV */
if|if
condition|(
operator|(
name|pidfound
operator|=
name|wait3
argument_list|(
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|pid
condition|)
break|break;
endif|#
directive|endif
comment|/* SYSV */
if|if
condition|(
name|timeout
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|string
operator|!=
name|laststring
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nwaiting for %s "
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
name|timeout
condition|)
break|break;
block|}
name|laststring
operator|=
name|string
expr_stmt|;
return|return
operator|(
name|pid
operator|!=
name|pidfound
operator|)
return|;
block|}
end_block

begin_macro
name|Error
argument_list|(
argument|fmt
argument_list|,
argument|x0
argument_list|,
argument|x1
argument_list|,
argument|x2
argument_list|,
argument|x3
argument_list|,
argument|x4
argument_list|,
argument|x5
argument_list|,
argument|x6
argument_list|,
argument|x7
argument_list|,
argument|x8
argument_list|,
argument|x9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  "
argument_list|,
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|>
literal|0
operator|&&
name|errno
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (errno %d):  "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|,
name|x3
argument_list|,
name|x4
argument_list|,
name|x5
argument_list|,
name|x6
argument_list|,
name|x7
argument_list|,
name|x8
argument_list|,
name|x9
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Fatal
argument_list|(
argument|fmt
argument_list|,
argument|x0
argument_list|,
argument|x1
argument_list|,
argument|x2
argument_list|,
argument|x3
argument_list|,
argument|x4
argument_list|,
argument|x5
argument_list|,
argument|x6
argument_list|,
argument|x7
argument_list|,
argument|x8
argument_list|,
argument|x9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Error
argument_list|(
name|fmt
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|,
name|x3
argument_list|,
name|x4
argument_list|,
name|x5
argument_list|,
name|x6
argument_list|,
name|x7
argument_list|,
name|x8
argument_list|,
name|x9
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERR_EXIT
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|startServer
argument_list|(
argument|server
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|server
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|serverpid
decl_stmt|;
name|serverpid
operator|=
name|vfork
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|serverpid
condition|)
block|{
case|case
literal|0
case|:
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * don't hang on read/write to control tty 		 */
ifdef|#
directive|ifdef
name|SIGTTIN
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * prevent server from getting sighup from vhangup() 		 * if client is xterm -L 		 */
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|Execute
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"no server \"%s\" in PATH\n"
argument_list|,
name|server
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUse the -- option, or make sure that %s is in your path and\n"
argument_list|,
name|bindir
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"that \"%s\" is a program or a link to the right type of server\n"
argument_list|,
name|server
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"for your display.  Possible server names include:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|server_names
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    %s\n"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|ERR_EXIT
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
break|break;
default|default:
comment|/* 		 * don't nice server 		 */
ifdef|#
directive|ifdef
name|PRIO_PROCESS
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
name|serverpid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|processTimeout
argument_list|(
name|serverpid
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|serverpid
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * kludge to avoid race with TCP, giving server time to 		 * set his socket options before we try to open it 		 */
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitforserver
argument_list|(
name|serverpid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Error
argument_list|(
literal|"unable to connect to X server\r\n"
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|serverpid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|serverpid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|serverpid
operator|)
return|;
block|}
end_block

begin_macro
name|startClient
argument_list|(
argument|client
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|client
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|clientpid
decl_stmt|;
if|if
condition|(
operator|(
name|clientpid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|environ
operator|=
name|newenviron
expr_stmt|;
name|Execute
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"no program named \"%s\" in PATH\r\n"
argument_list|,
name|client
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSpecify a program on the command line or make sure that %s\r\n"
argument_list|,
name|bindir
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"is in your path.\r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERR_EXIT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|clientpid
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|killpg
parameter_list|(
name|pgrp
parameter_list|,
name|sig
parameter_list|)
value|kill(-(pgrp), sig)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|close_env
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ignorexio
parameter_list|(
name|dpy
parameter_list|)
name|Display
modifier|*
name|dpy
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  connection to X server lost.\r\n"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|close_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_expr_stmt
specifier|static
name|shutdown
argument_list|(
argument|serverpid
argument_list|,
argument|clientpid
argument_list|)
name|int
name|serverpid
operator|,
name|clientpid
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* have kept display opened, so close it now */
if|if
condition|(
name|clientpid
operator|>
literal|0
condition|)
block|{
name|XSetIOErrorHandler
argument_list|(
name|ignorexio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|close_env
argument_list|)
condition|)
block|{
name|XCloseDisplay
argument_list|(
name|xd
argument_list|)
expr_stmt|;
block|}
comment|/* HUP all local clients to allow them to clean up */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|killpg
argument_list|(
name|clientpid
argument_list|,
name|SIGHUP
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ESRCH
operator|)
condition|)
name|Error
argument_list|(
literal|"can't send HUP to process group %d\r\n"
argument_list|,
name|clientpid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serverpid
operator|<
literal|0
condition|)
return|return;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|killpg
argument_list|(
name|serverpid
argument_list|,
name|SIGTERM
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
name|Fatal
argument_list|(
literal|"Can't kill X server\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|processTimeout
argument_list|(
name|serverpid
argument_list|,
literal|10
argument_list|,
literal|"X server to shut down"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n%s:  X server slow to shut down, sending KILL signal.\r\n"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|killpg
argument_list|(
name|serverpid
argument_list|,
name|SIGKILL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
return|return;
block|}
if|if
condition|(
name|processTimeout
argument_list|(
name|serverpid
argument_list|,
literal|3
argument_list|,
literal|"server to die"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|Fatal
argument_list|(
literal|"Can't kill server\r\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * make a new copy of environment that has room for DISPLAY  */
end_comment

begin_macro
name|set_environment
argument_list|()
end_macro

begin_block
block|{
name|int
name|nenvvars
decl_stmt|;
name|char
modifier|*
modifier|*
name|newPtr
decl_stmt|,
modifier|*
modifier|*
name|oldPtr
decl_stmt|;
specifier|static
name|char
name|displaybuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* count number of environment variables */
for|for
control|(
name|oldPtr
operator|=
name|environ
init|;
operator|*
name|oldPtr
condition|;
name|oldPtr
operator|++
control|)
empty_stmt|;
name|nenvvars
operator|=
operator|(
name|oldPtr
operator|-
name|environ
operator|)
expr_stmt|;
name|newenviron
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nenvvars
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newenviron
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  unable to allocate %d pointers for environment\n"
argument_list|,
name|program
argument_list|,
name|nenvvars
operator|+
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* put DISPLAY=displayname as first element */
name|strcpy
argument_list|(
name|displaybuf
argument_list|,
literal|"DISPLAY="
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|displaybuf
operator|+
literal|8
argument_list|,
name|displayname
argument_list|)
expr_stmt|;
name|newPtr
operator|=
name|newenviron
expr_stmt|;
operator|*
name|newPtr
operator|++
operator|=
name|displaybuf
expr_stmt|;
comment|/* copy pointers to other variables */
for|for
control|(
name|oldPtr
operator|=
name|environ
init|;
operator|*
name|oldPtr
condition|;
name|oldPtr
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|oldPtr
argument_list|,
literal|"DISPLAY="
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|newPtr
operator|++
operator|=
operator|*
name|oldPtr
expr_stmt|;
block|}
block|}
operator|*
name|newPtr
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_block

end_unit

