begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /f/osi/others/ntp/RCS/ntpsubs.c,v 7.1 91/02/22 09:34:04 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * subroutines for ntp - based on 3.4 ntp code.  *  $Log:	ntpsubs.c,v $  * Revision 7.1  91/02/22  09:34:04  mrose  * Interim 6.8  *   * Revision 7.0  90/12/10  17:21:45  mrose  * *** empty log message ***  *   * Revision 1.1  89/06/15  20:37:03  jpo  * Initial revision  *   *   */
end_comment

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/*  *  The nice thing here is that the quantity is NEVER signed.  */
end_comment

begin_function
name|double
name|ul_fixed_to_double
parameter_list|(
name|t
parameter_list|)
name|struct
name|l_fixedpt
modifier|*
name|t
decl_stmt|;
block|{
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
ifdef|#
directive|ifdef
name|GENERIC_UNS_BUG
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|fraction
argument_list|)
expr_stmt|;
name|a
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|a
operator|*=
literal|2.0
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|a
operator|+=
literal|1.0
expr_stmt|;
name|a
operator|=
name|a
operator|/
operator|(
literal|4.294967296e9
operator|)
expr_stmt|;
comment|/* shift dec point over by 32 bits */
name|i
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|int_part
argument_list|)
expr_stmt|;
name|b
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|b
operator|*=
literal|2.0
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|b
operator|+=
literal|1.0
expr_stmt|;
else|#
directive|else
comment|/* GENERIC_UNS_BUG */
name|a
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ntohl
argument_list|(
name|t
operator|->
name|fraction
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX_COMPILER_FLT_BUG
if|if
condition|(
name|a
operator|<
literal|0.0
condition|)
name|a
operator|+=
literal|4.294967296e9
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
name|a
operator|/
operator|(
literal|4.294967296e9
operator|)
expr_stmt|;
comment|/* shift dec point over by 32 bits */
name|b
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ntohl
argument_list|(
name|t
operator|->
name|int_part
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX_COMPILER_FLT_BUG
if|if
condition|(
name|b
operator|<
literal|0.0
condition|)
name|b
operator|+=
literal|4.294967296e9
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* GENERIC_UNS_BUG */
return|return
operator|(
name|a
operator|+
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Here we have to worry about the high order bit being signed  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
unit|double l_fixed_to_double(t) 	struct l_fixedpt *t; { 	double a,b;  	if (ntohl(t->int_part)& 0x80000000) { 		a = ntohl(~t->fraction);
ifdef|#
directive|ifdef
name|VAX_COMPILER_FLT_BUG
end_ifdef

begin_endif
unit|if (a< 0.0) a += 4.294967296e9;
endif|#
directive|endif
end_endif

begin_ifdef
unit|a = a / (4.294967296e9); 		b = ntohl(~t->int_part);
ifdef|#
directive|ifdef
name|VAX_COMPILER_FLT_BUG
end_ifdef

begin_endif
unit|if (b< 0.0) b += 4.294967296e9;
endif|#
directive|endif
end_endif

begin_ifdef
unit|a += b; 		a = -a; 	} else { 		a = ntohl(t->fraction);
ifdef|#
directive|ifdef
name|VAX_COMPILER_FLT_BUG
end_ifdef

begin_endif
unit|if (a< 0.0) a += 4.294967296e9;
endif|#
directive|endif
end_endif

begin_ifdef
unit|a = a / (4.294967296e9); 		b = ntohl(t->int_part);
ifdef|#
directive|ifdef
name|VAX_COMPILER_FLT_BUG
end_ifdef

begin_endif
unit|if (b< 0.0) b += 4.294967296e9;
endif|#
directive|endif
end_endif

begin_endif
unit|a += b; 	} 	return (a); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Here we have to worry about the high order bit being signed  */
end_comment

begin_function
name|double
name|s_fixed_to_double
parameter_list|(
name|t
parameter_list|)
name|struct
name|s_fixedpt
modifier|*
name|t
decl_stmt|;
block|{
name|double
name|a
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|t
operator|->
name|int_part
argument_list|)
operator|&
literal|0x8000
condition|)
block|{
name|a
operator|=
name|ntohs
argument_list|(
operator|~
name|t
operator|->
name|fraction
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|/
literal|65536.0
expr_stmt|;
comment|/* shift dec point over by 16 bits */
name|a
operator|+=
name|ntohs
argument_list|(
operator|~
name|t
operator|->
name|int_part
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
name|a
operator|=
operator|-
name|a
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|fraction
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|/
literal|65536.0
expr_stmt|;
comment|/* shift dec point over by 16 bits */
name|a
operator|+=
name|ntohs
argument_list|(
name|t
operator|->
name|int_part
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_function
name|void
name|double_to_l_fixed
parameter_list|(
name|t
parameter_list|,
name|value
parameter_list|)
name|struct
name|l_fixedpt
modifier|*
name|t
decl_stmt|;
name|double
name|value
decl_stmt|;
block|{
name|double
name|temp
decl_stmt|;
if|if
condition|(
name|value
operator|>=
operator|(
name|double
operator|)
literal|0.0
condition|)
block|{
name|t
operator|->
name|int_part
operator|=
name|value
expr_stmt|;
name|temp
operator|=
name|value
operator|-
name|t
operator|->
name|int_part
expr_stmt|;
name|temp
operator|*=
literal|4.294967296e9
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|temp
expr_stmt|;
name|t
operator|->
name|int_part
operator|=
name|htonl
argument_list|(
name|t
operator|->
name|int_part
argument_list|)
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|htonl
argument_list|(
name|t
operator|->
name|fraction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|t
operator|->
name|int_part
operator|=
name|value
expr_stmt|;
name|temp
operator|=
name|value
operator|-
name|t
operator|->
name|int_part
expr_stmt|;
name|temp
operator|*=
literal|4.294967296e9
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|temp
expr_stmt|;
name|t
operator|->
name|int_part
operator|=
name|htonl
argument_list|(
operator|~
name|t
operator|->
name|int_part
argument_list|)
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|htonl
argument_list|(
operator|~
name|t
operator|->
name|fraction
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|double_to_s_fixed
parameter_list|(
name|t
parameter_list|,
name|value
parameter_list|)
name|struct
name|s_fixedpt
modifier|*
name|t
decl_stmt|;
name|double
name|value
decl_stmt|;
block|{
name|double
name|temp
decl_stmt|;
if|if
condition|(
name|value
operator|>=
operator|(
name|double
operator|)
literal|0.0
condition|)
block|{
name|t
operator|->
name|int_part
operator|=
name|value
expr_stmt|;
name|temp
operator|=
name|value
operator|-
name|t
operator|->
name|int_part
expr_stmt|;
name|temp
operator|*=
literal|65536.0
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|temp
expr_stmt|;
name|t
operator|->
name|int_part
operator|=
name|htons
argument_list|(
name|t
operator|->
name|int_part
argument_list|)
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|htons
argument_list|(
name|t
operator|->
name|fraction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|t
operator|->
name|int_part
operator|=
name|value
expr_stmt|;
name|temp
operator|=
name|value
operator|-
name|t
operator|->
name|int_part
expr_stmt|;
name|temp
operator|*=
literal|65536.0
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|temp
expr_stmt|;
name|t
operator|->
name|int_part
operator|=
name|htons
argument_list|(
operator|~
name|t
operator|->
name|int_part
argument_list|)
expr_stmt|;
name|t
operator|->
name|fraction
operator|=
name|htons
argument_list|(
operator|~
name|t
operator|->
name|fraction
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* 	in the sun, trying to assign a float between 2^31 and 2^32 	results in the value 2^31.  Neither 4.2bsd nor VMS have this 	problem.  Reported it to Bob O'Brien of SMI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_FLT_BUG
end_ifdef

begin_function
name|void
name|tstamp
parameter_list|(
name|stampp
parameter_list|,
name|tvp
parameter_list|)
name|struct
name|l_fixedpt
modifier|*
name|stampp
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
block|{
name|int
name|tt
decl_stmt|;
name|double
name|dd
decl_stmt|;
name|stampp
operator|->
name|int_part
operator|=
name|ntohl
argument_list|(
name|JAN_1970
operator|+
name|tvp
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
name|dd
operator|=
operator|(
name|float
operator|)
name|tvp
operator|->
name|tv_usec
operator|/
literal|1000000.0
expr_stmt|;
name|tt
operator|=
name|dd
operator|*
literal|2147483648.0
expr_stmt|;
name|stampp
operator|->
name|fraction
operator|=
name|ntohl
argument_list|(
operator|(
name|tt
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|tstamp
parameter_list|(
name|stampp
parameter_list|,
name|tvp
parameter_list|)
name|struct
name|l_fixedpt
modifier|*
name|stampp
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
block|{
name|stampp
operator|->
name|int_part
operator|=
name|ntohl
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|JAN_1970
operator|+
name|tvp
operator|->
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|stampp
operator|->
name|fraction
operator|=
name|ntohl
argument_list|(
call|(
name|u_long
call|)
argument_list|(
operator|(
name|float
operator|)
name|tvp
operator|->
name|tv_usec
operator|*
literal|4294.967295
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ntoa is similar to inet_ntoa, but cycles through a set of 8 buffers  * so it can be invoked several times in a function parameter list.  */
end_comment

begin_function
name|char
modifier|*
name|ntoa
parameter_list|(
name|sin
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
block|{
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|bufs
index|[
literal|8
index|]
index|[
literal|64
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bufs
index|[
name|i
index|]
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
condition|?
literal|"INET %s/%d"
else|:
literal|"INET %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bufs
index|[
name|i
index|]
return|;
block|}
end_function

end_unit

