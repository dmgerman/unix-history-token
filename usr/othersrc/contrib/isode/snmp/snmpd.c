begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* snmpd.c - SNMP agent for 4BSD/ISODE */
end_comment

begin_comment
comment|/* Someday add sets for these objects... 	ifAdminStatus 	arptable 	ipForwarding 	route table 	clnpForwarding 	clnp route table 	clnp es-is table 	smux stuff 	exprExpr  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/snmpd.c,v 7.51 91/03/09 11:57:29 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/snmp/RCS/snmpd.c,v 7.51 91/03/09 11:57:29 mrose Exp $  *  * Contributed by NYSERNet Inc.  This work was partially supported by the  * U.S. Defense Advanced Research Projects Agency and the Rome Air Development  * Center of the U.S. Air Force Systems Command under contract number  * F30602-88-C-0016.  *  *  * $Log:	snmpd.c,v $  * Revision 7.51  91/03/09  11:57:29  mrose  * update  *   * Revision 7.49  91/02/20  17:25:55  mrose  * stuff  *  * Revision 7.48  91/01/12  11:43:24  mrose  * stuff  *  * Revision 7.47  91/01/11  15:35:10  mrose  * sets  *  * Revision 7.46  91/01/07  12:40:55  mrose  * update  *  * Revision 7.45  90/12/23  18:43:00  mrose  * update  *  * Revision 7.44  90/12/18  10:13:50  mrose  * update  *  * Revision 7.43  90/12/17  22:08:59  mrose  * split-up  *  * Revision 7.42  90/11/20  15:32:16  mrose  * update  *  * Revision 7.41  90/10/29  18:38:51  mrose  * updates  *  * Revision 7.40  90/10/23  20:36:29  mrose  * update  *  * Revision 7.39  90/09/03  12:57:40  mrose  * update  *  * Revision 7.38  90/08/30  15:11:15  mrose  * ho-hum  *  * Revision 7.37  90/08/29  12:23:44  mrose  * touch-up  *  * Revision 7.36  90/08/08  14:01:07  mrose  * stuff  *  * Revision 7.35  90/07/09  14:49:04  mrose  * sync  *  * Revision 7.34  90/07/01  21:07:26  mrose  * pepsy  *  * Revision 7.33  90/06/23  17:07:38  mrose  * loopback  *  * Revision 7.32  90/06/23  17:01:24  mrose  * update  *  * Revision 7.31  90/06/23  01:33:12  mrose  * proxy again  *  * Revision 7.30  90/06/21  21:27:14  mrose  * proxy and snmpt  *  * Revision 7.29  90/06/20  23:52:57  mrose  * again  *  * Revision 7.28  90/06/20  21:38:33  mrose  * update  *  * Revision 7.27  90/06/15  16:58:39  mrose  * update  *  * Revision 7.26  90/06/13  17:58:44  mrose  * defaultView  *  * Revision 7.25  90/06/12  05:19:03  mrose  * again  *  * Revision 7.24  90/06/12  02:21:43  mrose  * again  *  * Revision 7.23  90/06/12  02:05:33  mrose  * views ...  *  * Revision 7.22  90/06/05  20:47:10  mrose  * touch-up  *  * Revision 7.21  90/05/21  10:07:39  mrose  * bug-fix  *  * Revision 7.20  90/05/15  16:56:20  mrose  * bump COMM_RDWRITE  *  * Revision 7.19  90/05/14  19:55:48  mrose  * optimize views  *  * Revision 7.18  90/05/13  18:13:46  mrose  * update  *  * Revision 7.17  90/05/13  17:54:39  mrose  * views again  *  * Revision 7.16  90/05/13  16:18:17  mrose  * views  *  * Revision 7.15  90/04/18  08:51:53  mrose  * oid_normalize  *  * Revision 7.14  90/04/09  08:50:16  mrose  * update  *  * Revision 7.13  90/02/27  18:49:55  mrose  * unix stuff  *  * Revision 7.12  90/02/23  17:47:49  mrose  * update  *  * Revision 7.11  90/02/19  16:25:56  mrose  * typo  *  * Revision 7.10  90/02/19  15:38:50  mrose  * one more time  *  * Revision 7.9  90/02/17  17:18:48  mrose  * touch-up  *  * Revision 7.8  90/01/11  18:34:33  mrose  * real-sync  *  * Revision 7.7  89/12/19  22:01:52  mrose  * touch-up  *  * Revision 7.6  89/12/19  16:18:23  mrose  * dgram  *  * Revision 7.5  89/12/11  16:22:29  mrose  * more clts  *  * Revision 7.4  89/12/09  21:07:41  mrose  * touch-up  *  * Revision 7.3  89/12/08  14:20:27  mrose  * touch-up  *  * Revision 7.2  89/12/07  22:15:12  mrose  * touch-up  *  * Revision 7.1  89/12/01  10:42:15  mrose  * clts  *  * Revision 7.0  89/11/23  22:23:26  mrose  * Release 6.0  *  */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"mib.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"dgram.h"
end_include

begin_include
include|#
directive|include
file|"tsap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_define
define|#
directive|define
name|SMUX
end_define

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_define
define|#
directive|define
name|COTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TP4
end_ifdef

begin_include
include|#
directive|include
file|"tp4.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CLTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|COTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|COTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SNMPT
argument_list|)
operator|||
name|defined
argument_list|(
name|SNMPC
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|SMUX
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXSNMP
value|484
end_define

begin_define
define|#
directive|define
name|IDLE_TIME
value|(3 * 60)
end_define

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tooBig
init|=
name|MAXSNMP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nbits
init|=
name|FD_SETSIZE
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPT
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|rflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LLOG_XXX
value|(LLOG_PDUS | LLOG_DEBUG)
end_define

begin_decl_stmt
specifier|static
name|LLog
name|_pgm_log
init|=
block|{
ifndef|#
directive|ifndef
name|SNMPT
ifndef|#
directive|ifndef
name|SNMPC
literal|"snmpd.log"
block|,
else|#
directive|else
literal|"snmpc.log"
block|,
endif|#
directive|endif
else|#
directive|else
literal|"snmpt.log"
block|,
endif|#
directive|endif
name|NULLCP
block|,
name|NULLCP
block|,
name|LLOG_FATAL
operator||
name|LLOG_EXCEPTIONS
operator||
name|LLOG_NOTICE
block|,
name|LLOG_FATAL
block|,
operator|-
literal|1
block|,
name|LLOGCLS
operator||
name|LLOGCRT
operator||
name|LLOGZER
block|,
name|NOTOK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LLog
modifier|*
name|pgm_log
init|=
operator|&
name|_pgm_log
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPT
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPC
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
init|=
literal|"snmpd"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
init|=
literal|"snmpc"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
init|=
literal|"snmpt"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|tcpservice
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|x25service
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tp4service
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NTADDRS
value|FD_SETSIZE
end_define

begin_decl_stmt
specifier|static
name|fd_set
name|ifds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|TSAPaddr
modifier|*
name|tz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|TSAPaddr
name|tas
index|[
name|NTADDRS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COTS
end_ifdef

begin_decl_stmt
specifier|static
name|fd_set
name|cfds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|TSAPaddr
name|taddrs
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|lru
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|source
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|didhup
init|=
name|OK
decl_stmt|;
end_decl_stmt

begin_function_decl
name|SFD
name|hupser
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|adios
argument_list|()
decl_stmt|,
name|advise
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ts_advise
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
name|int
name|nd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|udp
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPT
end_ifndef

begin_decl_stmt
name|int
name|udport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|traport
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CLTS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|clts
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPT
end_ifndef

begin_decl_stmt
name|int
name|quantum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"snmp-g.h"
end_include

begin_decl_stmt
name|struct
name|snmpstat
name|snmpstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unix_netstat
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PROXY */
end_comment

begin_define
define|#
directive|define
name|NPQ
value|10
end_define

begin_struct
specifier|static
struct|struct
name|proxyque
block|{
name|integer
name|pq_quantum
decl_stmt|;
name|int
name|pq_age
decl_stmt|;
name|int
name|pq_fd
decl_stmt|;
name|IFP
name|pq_closefnx
decl_stmt|;
name|PS
name|pq_ps
decl_stmt|;
name|struct
name|qbuf
name|pq_community
decl_stmt|;
name|integer
name|pq_request
decl_stmt|;
block|}
name|pips
index|[
name|NPQ
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|pqs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proxyque
modifier|*
name|pqr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VIEWS */
end_comment

begin_include
include|#
directive|include
file|"view-g.h"
end_include

begin_decl_stmt
specifier|static
name|OID
name|viewTree
init|=
name|NULLOID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|view
name|viewque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|view
modifier|*
name|VHead
init|=
operator|&
name|viewque
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* COMMUNITIES */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|community
name|commque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|community
modifier|*
name|CHead
init|=
operator|&
name|commque
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|community
modifier|*
name|str2comm
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* TRAPS */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trap
name|trapque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|trap
modifier|*
name|UHead
init|=
operator|&
name|trapque
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|type_SNMP_Message
modifier|*
name|trap
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SMUX
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|qbuf
modifier|*
name|loopback_addr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMUX GROUP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMUX
end_ifdef

begin_include
include|#
directive|include
file|"smux-g.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|smux_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smux
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fd_set
name|sfds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|smuxPeer
name|peerque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|smuxPeer
modifier|*
name|PHead
init|=
operator|&
name|peerque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|smuxTree
name|treeque
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|smuxTree
modifier|*
name|THead
init|=
operator|&
name|treeque
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|smuxReserved
block|{
name|char
modifier|*
name|rb_text
decl_stmt|;
name|OID
name|rb_name
decl_stmt|;
block|}
name|reserved
index|[]
init|=
block|{
literal|"snmp"
block|,
name|NULLOID
block|,
literal|"view"
block|,
name|NULLOID
block|,
literal|"smux"
block|,
name|NULLOID
block|,
name|NULL
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SNMPT */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|proxy_clear
parameter_list|(
name|fd
parameter_list|)
end_define

begin_decl_stmt
specifier|static
name|PS
name|audit
init|=
name|NULLPS
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNMPT */
end_comment

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|failed
decl_stmt|,
name|listening
decl_stmt|,
name|nfds
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|arginit
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|envinit
argument_list|()
expr_stmt|;
name|failed
operator|=
name|listening
operator|=
literal|0
expr_stmt|;
name|nfds
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ifds
argument_list|)
expr_stmt|;
for|for
control|(
name|ta
operator|=
name|tas
init|;
name|ta
operator|<
name|tz
condition|;
name|ta
operator|++
control|)
block|{
if|if
condition|(
name|ta
operator|->
name|ta_naddr
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tp4service
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CLTS
goto|goto
name|do_clts
goto|;
endif|#
directive|endif
block|}
else|else
block|{
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
name|ta
operator|->
name|ta_addrs
decl_stmt|;
switch|switch
condition|(
name|na
operator|->
name|na_stack
condition|)
block|{
case|case
name|NA_TCP
case|:
if|if
condition|(
operator|!
name|tcpservice
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|TCP
block|{
name|struct
name|sockaddr_in
name|lo_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|lsock
init|=
operator|&
name|lo_socket
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lsock
argument_list|,
sizeof|sizeof
expr|*
name|lsock
argument_list|)
expr_stmt|;
name|lsock
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|lsock
operator|->
name|sin_port
operator|=
name|na
operator|->
name|na_port
expr_stmt|;
if|if
condition|(
operator|(
name|udp
operator|=
name|start_udp_server
argument_list|(
name|lsock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"start_udp_server"
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|udp
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|udp
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|udp
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|==
name|NOTOK
condition|)
name|nd
operator|=
name|udp
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"listening on UDP port %d"
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|na
operator|->
name|na_port
argument_list|)
argument_list|)
expr_stmt|;
name|listening
operator|++
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"UDP support not configured"
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
name|NA_X25
case|:
if|if
condition|(
operator|!
name|x25service
condition|)
continue|continue;
break|break;
case|case
name|NA_NSAP
case|:
if|if
condition|(
operator|!
name|tp4service
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CLTS
name|do_clts
label|:
empty_stmt|;
block|{
name|union
name|sockaddr_osi
name|lo_socket
decl_stmt|;
specifier|register
name|union
name|sockaddr_osi
modifier|*
name|lsock
init|=
operator|&
name|lo_socket
decl_stmt|;
operator|(
name|void
operator|)
name|gen2tp4
argument_list|(
name|ta
argument_list|,
name|lsock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clts
operator|=
name|start_clts_server
argument_list|(
name|lsock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"start_clts_server"
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|clts
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|clts
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|clts
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|==
name|NOTOK
condition|)
name|nd
operator|=
name|clts
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"listening on %s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
name|listening
operator|++
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
break|break;
endif|#
directive|endif
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown network type 0x%x"
argument_list|,
name|na
operator|->
name|na_stack
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
block|}
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"listening on %s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TNetListen
argument_list|(
name|ta
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"listen failed"
argument_list|)
expr_stmt|;
name|failed
operator|++
expr_stmt|;
block|}
else|else
name|listening
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|listening
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
name|failed
condition|?
literal|"no successful listens"
else|:
literal|"no network services selected"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|do_trap
argument_list|(
name|int_SNMP_generic__trap_coldStart
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SMUX
block|{
name|struct
name|sockaddr_in
name|lo_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|lsock
init|=
operator|&
name|lo_socket
decl_stmt|;
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|smuxReserved
modifier|*
name|sr
decl_stmt|;
name|OT
name|ot
decl_stmt|;
name|PHead
operator|->
name|pb_forw
operator|=
name|PHead
operator|->
name|pb_back
operator|=
name|PHead
expr_stmt|;
name|THead
operator|->
name|tb_forw
operator|=
name|THead
operator|->
name|tb_back
operator|=
name|THead
expr_stmt|;
for|for
control|(
name|sr
operator|=
name|reserved
init|;
name|sr
operator|->
name|rb_text
condition|;
name|sr
operator|++
control|)
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
name|sr
operator|->
name|rb_text
argument_list|)
condition|)
name|sr
operator|->
name|rb_name
operator|=
name|ot
operator|->
name|ot_name
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lsock
argument_list|,
sizeof|sizeof
expr|*
name|lsock
argument_list|)
expr_stmt|;
name|lsock
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|lsock
operator|->
name|sin_port
operator|=
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"smux"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|199
argument_list|)
expr_stmt|;
if|if
condition|(
name|smux_enabled
condition|)
block|{
if|if
condition|(
operator|(
name|smux
operator|=
name|start_tcp_server
argument_list|(
name|lsock
argument_list|,
name|SOMAXCONN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"start_tcp_server for SMUX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|smux
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|smux
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|smux
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
block|}
block|}
name|FD_ZERO
argument_list|(
operator|&
name|sfds
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COTS
name|FD_ZERO
argument_list|(
operator|&
name|cfds
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|fd
decl_stmt|,
name|secs
decl_stmt|;
ifdef|#
directive|ifdef
name|COTS
name|struct
name|timeval
name|tvs
decl_stmt|;
specifier|register
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|&
name|tvs
decl_stmt|;
endif|#
directive|endif
name|int
name|vecp
decl_stmt|;
name|fd_set
name|rfds
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
name|secs
operator|=
name|NOTOK
expr_stmt|;
ifdef|#
directive|ifdef
name|COTS
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|cfds
argument_list|)
condition|)
block|{
name|secs
operator|=
name|IDLE_TIME
operator|+
literal|10
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|rfds
operator|=
name|ifds
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|TNetAcceptAux
argument_list|(
operator|&
name|vecp
argument_list|,
name|vec
argument_list|,
operator|&
name|fd
argument_list|,
name|NULLTA
argument_list|,
name|nfds
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|secs
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetAccept failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|TCP
if|if
condition|(
name|udp
operator|!=
name|NOTOK
operator|&&
name|FD_ISSET
argument_list|(
name|udp
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
name|doit_udp
argument_list|(
name|udp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SMUX
if|if
condition|(
name|smux
operator|!=
name|NOTOK
operator|&&
name|FD_ISSET
argument_list|(
name|smux
argument_list|,
operator|&
name|rfds
argument_list|)
operator|&&
operator|(
name|fd
operator|=
name|start_smux
argument_list|()
operator|)
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|fd
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|sfds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|rfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|sfds
argument_list|)
condition|)
name|doit_smux
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLTS
if|if
condition|(
name|clts
operator|!=
name|NOTOK
operator|&&
name|FD_ISSET
argument_list|(
name|clts
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
name|doit_clts
argument_list|(
name|clts
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COTS
if|if
condition|(
name|vecp
operator|>
literal|0
operator|&&
operator|(
name|fd
operator|=
name|start_tsap
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|fd
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|cfds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|rfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|cfds
argument_list|)
condition|)
name|doit_cots
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|-=
operator|(
name|long
operator|)
name|IDLE_TIME
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|cfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|timercmp
argument_list|(
name|tv
argument_list|,
operator|&
name|lru
index|[
name|fd
index|]
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"clearing connection from %d: %s"
argument_list|,
name|fd
argument_list|,
name|taddr2str
argument_list|(
name|taddrs
operator|+
name|fd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|TDiscRequest
argument_list|(
name|fd
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|cfds
argument_list|)
expr_stmt|;
name|proxy_clear
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|fd
operator|=
name|nfds
operator|-
literal|1
init|;
name|fd
operator|>=
literal|0
condition|;
name|fd
operator|--
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
break|break;
name|nfds
operator|=
name|fd
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|void
name|ts_advise
parameter_list|(
name|td
parameter_list|,
name|code
parameter_list|,
name|event
parameter_list|)
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_cc
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%s] %*.*s"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_data
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%s]"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|code
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: %s"
argument_list|,
name|event
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|DOIT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_expr_stmt
specifier|static
name|doit_udp
argument_list|(
argument|pd
argument_list|)
name|int
name|pd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|sockaddr_in
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
name|struct
name|NSAPaddr
name|nas
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
operator|&
name|nas
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_udp_client
argument_list|(
name|pd
argument_list|,
name|isock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
return|return;
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"join_udp_client"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|source
argument_list|,
literal|"Internet=%s+%d+2"
argument_list|,
name|cp
operator|=
name|inet_ntoa
argument_list|(
name|isock
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|isock
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|na
argument_list|,
sizeof|sizeof
expr|*
name|na
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_stack
operator|=
name|NA_TCP
expr_stmt|;
name|na
operator|->
name|na_community
operator|=
name|ts_comm_tcp_default
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|na
operator|->
name|na_domain
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
name|na
operator|->
name|na_domain
operator|-
literal|1
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_port
operator|=
name|isock
operator|->
name|sin_port
expr_stmt|;
name|doit_aux
argument_list|(
name|fd
argument_list|,
name|na
argument_list|,
name|read_udp_socket
argument_list|,
name|write_udp_socket
argument_list|,
name|check_udp_socket
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
if|if
condition|(
name|pqr
condition|)
name|pqr
operator|->
name|pq_fd
operator|=
name|fd
operator|,
name|pqr
operator|->
name|pq_closefnx
operator|=
name|close_udp_socket
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|close_udp_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLTS
end_ifdef

begin_expr_stmt
specifier|static
name|doit_clts
argument_list|(
argument|pd
argument_list|)
name|int
name|pd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|union
name|sockaddr_osi
name|in_socket
decl_stmt|;
specifier|register
name|union
name|sockaddr_osi
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
name|struct
name|TSAPaddr
name|tas
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
init|=
operator|&
name|tas
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_clts_client
argument_list|(
name|pd
argument_list|,
name|isock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
return|return;
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"join_tcp_client"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|tp42gen
argument_list|(
name|ta
argument_list|,
name|isock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|source
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
name|doit_aux
argument_list|(
name|fd
argument_list|,
name|ta
operator|->
name|ta_addrs
argument_list|,
name|read_clts_socket
argument_list|,
name|write_clts_socket
argument_list|,
name|check_clts_socket
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
if|if
condition|(
name|pqr
condition|)
name|pqr
operator|->
name|pq_fd
operator|=
name|fd
operator|,
name|pqr
operator|->
name|pq_closefnx
operator|=
name|close_clts_socket
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|close_clts_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COTS
end_ifdef

begin_function
specifier|static
name|int
name|start_tsap
parameter_list|(
name|vecp
parameter_list|,
name|vec
parameter_list|)
name|int
name|vecp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|struct
name|TSAPstart
name|tss
decl_stmt|;
specifier|register
name|struct
name|TSAPstart
modifier|*
name|ts
init|=
operator|&
name|tss
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
if|if
condition|(
name|TInit
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|ts
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"T-CONNECT.INDICATION"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|advise
argument_list|(
name|LLOG_XXX
argument_list|,
name|NULLCP
argument_list|,
literal|"T-CONNECT.INDICATION:<%d, %s, %s, %d, %d>"
argument_list|,
name|ts
operator|->
name|ts_sd
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|ts
operator|->
name|ts_calling
argument_list|)
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|ts
operator|->
name|ts_called
argument_list|)
argument_list|,
name|ts
operator|->
name|ts_expedited
argument_list|,
name|ts
operator|->
name|ts_tsdusize
argument_list|)
expr_stmt|;
if|if
condition|(
name|TConnResponse
argument_list|(
name|ts
operator|->
name|ts_sd
argument_list|,
name|NULLTA
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|NULLQOS
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"T-CONNECT.RESPONSE"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|taddrs
index|[
name|ts
operator|->
name|ts_sd
index|]
operator|=
name|ts
operator|->
name|ts_calling
expr_stmt|;
comment|/* struct copy */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
name|lru
operator|+
name|ts
operator|->
name|ts_sd
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|ts
operator|->
name|ts_sd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|doit_cots
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|source
argument_list|,
name|taddr2str
argument_list|(
name|taddrs
operator|+
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|doit_aux
argument_list|(
name|fd
argument_list|,
operator|&
operator|(
name|taddrs
index|[
name|fd
index|]
operator|.
name|ta_addrs
index|[
literal|0
index|]
operator|)
argument_list|,
name|ts_read
argument_list|,
name|ts_write
argument_list|,
name|NULLIFP
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
if|if
condition|(
name|pqr
condition|)
name|pqr
operator|->
name|pq_fd
operator|=
name|fd
operator|,
name|pqr
operator|->
name|pq_closefnx
operator|=
name|NULLIFP
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
name|lru
operator|+
name|fd
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|doit_aux
argument_list|(
argument|fd
argument_list|,
argument|na
argument_list|,
argument|rfx
argument_list|,
argument|wfx
argument_list|,
argument|cfx
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|IFP
name|rfx
decl_stmt|,
name|wfx
decl_stmt|,
name|cfx
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|result
decl_stmt|,
name|size
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|PS
name|ps
decl_stmt|;
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|didhup
operator|=
name|NOTOK
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|NOTOK
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|pqr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|dg_open
argument_list|)
operator|)
operator|==
name|NULLPS
operator|||
name|dg_setup
argument_list|(
name|ps
argument_list|,
name|fd
argument_list|,
name|MAXSNMP
argument_list|,
name|rfx
argument_list|,
name|wfx
argument_list|,
name|cfx
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULLPS
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory (%s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"dg_setup: %s (%s)"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|size
operator|=
name|ps
operator|->
name|ps_byteno
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
ifdef|#
directive|ifdef
name|COTS
if|if
condition|(
name|rfx
operator|==
name|ts_read
condition|)
block|{
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|cfds
argument_list|)
expr_stmt|;
name|proxy_clear
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|ps_errno
operator|==
name|PS_ERR_NONE
condition|)
block|{
name|advise
argument_list|(
name|LLOG_XXX
argument_list|,
name|NULLCP
argument_list|,
literal|"T-DISCONNECT.INDICATION: %d (%s)"
argument_list|,
name|fd
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"ps2pe: %s (%s)"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|snmpstat
operator|.
name|s_inpkts
operator|++
expr_stmt|;
name|snmpstat
operator|.
name|s_asnparseerrs
operator|++
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
name|size
operator|=
name|ps
operator|->
name|ps_byteno
operator|-
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|COTS
if|if
condition|(
name|rfx
operator|==
name|ts_read
condition|)
name|advise
argument_list|(
name|LLOG_XXX
argument_list|,
name|NULLCP
argument_list|,
literal|"T-DATA.INDICATION: %d (%s)"
argument_list|,
name|fd
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|advise
argument_list|(
name|LLOG_XXX
argument_list|,
name|NULLCP
argument_list|,
literal|"packet from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|snmpstat
operator|.
name|s_inpkts
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|decode_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"decode_SNMP_Message: %s (%s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|snmpstat
operator|.
name|s_asnparseerrs
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COTS
if|if
condition|(
name|rfx
operator|==
name|ts_read
condition|)
block|{
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"clearing connection from %d: %s"
argument_list|,
name|fd
argument_list|,
name|taddr2str
argument_list|(
name|taddrs
operator|+
name|fd
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|TDiscRequest
argument_list|(
name|fd
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
operator|&
name|tds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|cfds
argument_list|)
expr_stmt|;
name|proxy_clear
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_Message
argument_list|,
name|pe
argument_list|,
literal|"Message"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|process
argument_list|(
name|ps
argument_list|,
name|msg
argument_list|,
name|na
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
comment|/* BEGIN MOBY PEPSY HACK... */
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
init|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
decl_stmt|;
name|free_SNMP_VarBindList
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
operator|=
name|NULL
expr_stmt|;
comment|/* END MOBY PEPSY HACK... */
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|OK
operator|&&
name|ps
condition|)
name|ps_free
argument_list|(
name|ps
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|hupser
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|PROCESS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPT
end_ifndef

begin_function
specifier|static
name|int
name|process
parameter_list|(
name|ps
parameter_list|,
name|msg
parameter_list|,
name|na
parameter_list|,
name|size
parameter_list|)
name|PS
name|ps
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|commname
decl_stmt|;
name|struct
name|community
modifier|*
name|comm
decl_stmt|;
name|PE
name|pe
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|version
operator|!=
name|int_SNMP_version_version__1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"badVersion: %d (%s)"
argument_list|,
name|msg
operator|->
name|version
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmpstat
operator|.
name|s_badversions
operator|++
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
operator|(
name|commname
operator|=
name|qb2str
argument_list|(
name|msg
operator|->
name|community
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"qb2str: out of memory (%s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
name|result
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
operator|(
name|comm
operator|=
name|str2comm
argument_list|(
name|commname
argument_list|,
name|na
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"badCommunity: %s (%s)"
argument_list|,
name|commname
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmpstat
operator|.
name|s_badcommunitynames
operator|++
expr_stmt|;
if|if
condition|(
name|snmpstat
operator|.
name|s_enableauthentraps
operator|==
name|TRAPS_ENABLED
condition|)
name|do_trap
argument_list|(
name|int_SNMP_generic__trap_authenticationFailure
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|result
operator|=
name|do_operation
argument_list|(
name|ps
argument_list|,
name|msg
argument_list|,
name|comm
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|DONE
condition|)
goto|goto
name|out
goto|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|msg
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_Message
argument_list|,
name|pe
argument_list|,
literal|"Message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"pe2ps: %s (%s)"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|snmpstat
operator|.
name|s_outpkts
operator|++
expr_stmt|;
block|}
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s (%s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
name|free
argument_list|(
name|commname
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|do_operation
parameter_list|(
name|ps
parameter_list|,
name|msg
parameter_list|,
name|comm
parameter_list|,
name|size
parameter_list|)
name|PS
name|ps
decl_stmt|;
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
name|struct
name|community
modifier|*
name|comm
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|view
modifier|*
name|vu
init|=
name|comm
operator|->
name|c_view
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDUs
modifier|*
name|pdu
init|=
name|msg
operator|->
name|data
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
decl_stmt|;
name|struct
name|type_SNMP_VarBindList
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_GetResponse__PDU
modifier|*
name|parm
init|=
name|pdu
operator|->
name|un
operator|.
name|get__response
decl_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|pdu
operator|->
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
name|snmpstat
operator|.
name|s_ingetrequests
operator|++
expr_stmt|;
if|if
condition|(
name|vu
operator|==
name|NULL
operator|||
operator|!
operator|(
name|comm
operator|->
name|c_permission
operator|&
name|OT_RDONLY
operator|)
condition|)
block|{
name|access_denied
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"authorizationFailure: %d (%s)"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|/* no trap for this... */
name|offset
operator|=
name|pdu
operator|->
name|offset
expr_stmt|;
name|pdu
operator|->
name|offset
operator|=
name|type_SNMP_PDUs_get__response
expr_stmt|;
name|parm
operator|->
name|error__status
operator|=
name|int_SNMP_error__status_noSuchName
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
name|snmpstat
operator|.
name|s_ingetnexts
operator|++
expr_stmt|;
if|if
condition|(
name|vu
operator|==
name|NULL
operator|||
operator|!
operator|(
name|comm
operator|->
name|c_permission
operator|&
name|OT_RDONLY
operator|)
condition|)
goto|goto
name|access_denied
goto|;
break|break;
case|case
name|type_SNMP_PDUs_set__request
case|:
name|snmpstat
operator|.
name|s_insetrequests
operator|++
expr_stmt|;
if|if
condition|(
name|vu
operator|==
name|NULL
operator|||
operator|!
operator|(
name|comm
operator|->
name|c_permission
operator|&
name|OT_WRONLY
operator|)
condition|)
goto|goto
name|access_denied
goto|;
break|break;
case|case
name|type_SNMP_PDUs_get__response
case|:
name|snmpstat
operator|.
name|s_ingetresponses
operator|++
expr_stmt|;
if|if
condition|(
name|vu
operator|==
name|NULL
condition|)
goto|goto
name|access_denied
goto|;
if|if
condition|(
operator|(
name|comm
operator|->
name|c_permission
operator|&
name|OT_YYY
operator|)
operator|&&
name|proxy2
argument_list|(
name|msg
argument_list|)
operator|!=
name|OK
condition|)
return|return
name|NOTOK
return|;
goto|goto
name|bad_operation
goto|;
case|case
name|type_SNMP_PDUs_trap
case|:
name|snmpstat
operator|.
name|s_intraps
operator|++
expr_stmt|;
if|if
condition|(
name|vu
operator|==
name|NULL
condition|)
goto|goto
name|access_denied
goto|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpectedOperation: %d (%s)"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
if|if
condition|(
name|vu
operator|==
name|NULL
condition|)
goto|goto
name|access_denied
goto|;
name|bad_operation
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"badOperation: %d (%s)"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|vu
operator|->
name|v_community
condition|)
return|return
name|proxy1
argument_list|(
name|ps
argument_list|,
name|msg
argument_list|,
name|comm
argument_list|)
return|;
name|offset
operator|=
name|pdu
operator|->
name|offset
expr_stmt|;
name|pdu
operator|->
name|offset
operator|=
name|type_SNMP_PDUs_get__response
expr_stmt|;
block|{
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
modifier|*
name|opp
decl_stmt|;
name|opp
operator|=
operator|&
name|op
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|bind
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|bind
operator|=
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bind
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
name|free_SNMP_VarBindList
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|op
operator|=
name|NULL
expr_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|parm
operator|->
name|error__status
operator|=
name|int_SNMP_error__status_genErr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|opp
operator|=
name|bind
operator|,
name|opp
operator|=
operator|&
name|bind
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|type_SNMP_VarBind
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|bind
operator|->
name|VarBind
operator|=
name|v
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|name
operator|=
name|oid_cpy
argument_list|(
name|vp
operator|->
name|VarBind
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
goto|goto
name|no_mem
goto|;
operator|(
name|v
operator|->
name|value
operator|=
name|vp
operator|->
name|VarBind
operator|->
name|value
operator|)
operator|->
name|pe_refcnt
operator|++
expr_stmt|;
block|}
block|}
name|quantum
operator|++
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
case|case
name|type_SNMP_PDUs_get__next__request
case|:
default|default:
name|idx
operator|=
name|do_pass
argument_list|(
name|msg
argument_list|,
name|offset
argument_list|,
name|vu
argument_list|)
expr_stmt|;
break|break;
case|case
name|type_SNMP_PDUs_set__request
case|:
if|if
condition|(
name|idx
operator|=
name|do_pass
argument_list|(
name|msg
argument_list|,
name|offset
argument_list|,
name|vu
argument_list|)
condition|)
block|{
name|int
name|status
init|=
name|parm
operator|->
name|error__status
decl_stmt|;
operator|(
name|void
operator|)
name|do_pass
argument_list|(
name|msg
argument_list|,
name|type_SNMP_PDUs_rollback
argument_list|,
name|vu
argument_list|)
expr_stmt|;
name|parm
operator|->
name|error__status
operator|=
name|status
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|do_pass
argument_list|(
name|msg
argument_list|,
name|type_SNMP_PDUs_commit
argument_list|,
name|vu
argument_list|)
expr_stmt|;
name|gc_set
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|out
label|:
empty_stmt|;
name|parm
operator|->
name|error__index
operator|=
name|idx
expr_stmt|;
switch|switch
condition|(
name|parm
operator|->
name|error__status
condition|)
block|{
case|case
name|int_SNMP_error__status_noError
case|:
for|for
control|(
name|vp
operator|=
name|op
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
name|size
operator|-=
name|ps_get_abs
argument_list|(
name|vp
operator|->
name|VarBind
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|size
operator|+=
name|ps_get_abs
argument_list|(
name|vp
operator|->
name|VarBind
operator|->
name|value
argument_list|)
operator|)
operator|>=
name|tooBig
condition|)
block|{
name|parm
operator|->
name|error__status
operator|=
name|int_SNMP_error__status_tooBig
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
name|idx
operator|++
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
case|case
name|type_SNMP_PDUs_get__next__request
case|:
name|snmpstat
operator|.
name|s_totalreqvars
operator|+=
name|idx
expr_stmt|;
break|break;
case|case
name|type_SNMP_PDUs_set__request
case|:
name|snmpstat
operator|.
name|s_totalsetvars
operator|+=
name|idx
expr_stmt|;
break|break;
block|}
name|free_SNMP_VarBindList
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|int_SNMP_error__status_tooBig
case|:
name|snmpstat
operator|.
name|s_toobigs
operator|++
expr_stmt|;
goto|goto
name|losing
goto|;
case|case
name|int_SNMP_error__status_readOnly
case|:
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"lurking readOnly"
argument_list|)
expr_stmt|;
comment|/* and fall... */
case|case
name|int_SNMP_error__status_noSuchName
case|:
name|snmpstat
operator|.
name|s_nosuchnames
operator|++
expr_stmt|;
goto|goto
name|losing
goto|;
case|case
name|int_SNMP_error__status_badValue
case|:
name|snmpstat
operator|.
name|s_badvalues
operator|++
expr_stmt|;
goto|goto
name|losing
goto|;
case|case
name|int_SNMP_error__status_genErr
case|:
name|snmpstat
operator|.
name|s_generrs
operator|++
expr_stmt|;
goto|goto
name|losing
goto|;
default|default:
name|losing
label|:
empty_stmt|;
if|if
condition|(
name|op
condition|)
block|{
name|free_SNMP_VarBindList
argument_list|(
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
operator|=
name|op
expr_stmt|;
block|}
break|break;
block|}
name|snmpstat
operator|.
name|s_outgetresponses
operator|++
expr_stmt|;
return|return
name|DONE
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|do_pass
parameter_list|(
name|msg
parameter_list|,
name|offset
parameter_list|,
name|vu
parameter_list|)
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|view
modifier|*
name|vu
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|,
name|status
decl_stmt|;
name|object_instance
name|ois
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDUs
modifier|*
name|pdu
init|=
name|msg
operator|->
name|data
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_GetResponse__PDU
modifier|*
name|parm
init|=
name|pdu
operator|->
name|un
operator|.
name|get__response
decl_stmt|;
name|IFP
name|method
decl_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
specifier|register
name|OI
name|oi
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
init|=
name|vp
operator|->
name|VarBind
decl_stmt|;
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|type_SNMP_PDUs_get__next__request
condition|)
block|{
if|if
condition|(
operator|(
name|oi
operator|=
name|name2inst
argument_list|(
name|v
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULLOI
operator|&&
operator|(
name|oi
operator|=
name|next2inst
argument_list|(
name|v
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULLOI
condition|)
goto|goto
name|no_name
goto|;
if|if
condition|(
operator|(
name|ot
operator|=
name|oi
operator|->
name|oi_type
operator|)
operator|->
name|ot_getfnx
operator|==
name|NULLIFP
operator|&&
name|ot
operator|->
name|ot_smux
operator|==
name|NULL
condition|)
goto|goto
name|get_next
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|oi
operator|=
name|name2inst
argument_list|(
name|v
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULLOI
condition|)
goto|goto
name|no_name
goto|;
name|ot
operator|=
name|oi
operator|->
name|oi_type
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|==
name|type_SNMP_PDUs_get__request
condition|?
name|ot
operator|->
name|ot_getfnx
else|:
name|ot
operator|->
name|ot_setfnx
operator|)
operator|==
name|NULLIFP
operator|&&
name|ot
operator|->
name|ot_smux
operator|==
name|NULL
condition|)
block|{
name|no_name
label|:
empty_stmt|;
name|parm
operator|->
name|error__status
operator|=
name|int_SNMP_error__status_noSuchName
expr_stmt|;
return|return
name|idx
return|;
block|}
block|}
name|try_again
label|:
empty_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
if|if
condition|(
operator|!
operator|(
name|vu
operator|->
name|v_mask
operator|&
name|ot
operator|->
name|ot_views
operator|)
condition|)
block|{
name|losing_name
label|:
empty_stmt|;
name|snmpstat
operator|.
name|s_badcommunityuses
operator|++
expr_stmt|;
goto|goto
name|no_name
goto|;
block|}
name|method
operator|=
name|ot
operator|->
name|ot_getfnx
expr_stmt|;
break|break;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
if|if
condition|(
operator|!
operator|(
name|vu
operator|->
name|v_mask
operator|&
name|ot
operator|->
name|ot_views
operator|)
condition|)
goto|goto
name|get_next
goto|;
name|method
operator|=
name|ot
operator|->
name|ot_getfnx
expr_stmt|;
break|break;
case|case
name|type_SNMP_PDUs_set__request
case|:
case|case
name|type_SNMP_PDUs_commit
case|:
case|case
name|type_SNMP_PDUs_rollback
case|:
if|if
condition|(
operator|!
operator|(
name|vu
operator|->
name|v_mask
operator|&
name|ot
operator|->
name|ot_views
operator|)
condition|)
goto|goto
name|losing_name
goto|;
name|method
operator|=
name|ot
operator|->
name|ot_setfnx
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SMUX
if|if
condition|(
name|ot
operator|->
name|ot_smux
condition|)
name|status
operator|=
name|smux_method
argument_list|(
name|pdu
argument_list|,
name|ot
argument_list|,
operator|(
operator|(
expr|struct
name|smuxTree
operator|*
operator|)
name|ot
operator|->
name|ot_smux
operator|)
operator|->
name|tb_peer
argument_list|,
name|v
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|status
operator|=
call|(
modifier|*
name|method
call|)
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|NOTOK
case|:
comment|/* get-next wants a bump */
ifdef|#
directive|ifdef
name|SMUX
comment|/* If current object is being handled by a SMUX sub-agent, then 		   step over the entire subtree before proceeding with the 		   'get-next' search.  This is needed to avoid descending into 		   the portion of the object tree that the SMUX sub-agent has 		   'mounted over'. (EJP) */
if|if
condition|(
name|ot
operator|->
name|ot_smux
condition|)
block|{
name|int
name|level
init|=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
decl_stmt|;
while|while
condition|(
name|ot
operator|->
name|ot_next
operator|&&
name|ot
operator|->
name|ot_next
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|>
name|level
condition|)
name|ot
operator|=
name|ot
operator|->
name|ot_next
expr_stmt|;
block|}
endif|#
directive|endif
name|get_next
label|:
empty_stmt|;
name|oi
operator|=
operator|&
name|ois
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|ot
operator|=
name|ot
operator|->
name|ot_next
operator|)
operator|==
name|NULLOT
condition|)
block|{
name|parm
operator|->
name|error__status
operator|=
name|int_SNMP_error__status_noSuchName
expr_stmt|;
return|return
name|idx
return|;
block|}
name|oi
operator|->
name|oi_name
operator|=
operator|(
name|oi
operator|->
name|oi_type
operator|=
name|ot
operator|)
operator|->
name|ot_name
expr_stmt|;
if|if
condition|(
name|ot
operator|->
name|ot_getfnx
operator|||
name|ot
operator|->
name|ot_smux
condition|)
goto|goto
name|try_again
goto|;
block|}
case|case
name|int_SNMP_error__status_noError
case|:
break|break;
default|default:
name|parm
operator|->
name|error__status
operator|=
name|status
expr_stmt|;
return|return
name|idx
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|gc_set
argument_list|()
block|{
ifdef|#
directive|ifdef
name|SMUX
specifier|register
expr|struct
name|smuxPeer
operator|*
name|pb
block|,
operator|*
name|qb
block|;
specifier|register
expr|struct
name|smuxTree
operator|*
name|tb
block|,
operator|*
name|ub
block|;
for|for
control|(
name|pb
operator|=
name|PHead
operator|->
name|pb_forw
init|;
name|pb
operator|!=
name|PHead
condition|;
name|pb
operator|=
name|qb
control|)
block|{
name|qb
operator|=
name|pb
operator|->
name|pb_forw
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|pb_invalid
condition|)
name|pb_free
argument_list|(
name|pb
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_for
for|for
control|(
name|tb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|tb
operator|!=
name|THead
condition|;
name|tb
operator|=
name|ub
control|)
block|{
name|ub
operator|=
name|tb
operator|->
name|tb_forw
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_invalid
condition|)
name|tb_free
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/*
comment|PROXY */
end_comment

begin_function
unit|static
name|int
name|proxy1
parameter_list|(
name|psp
parameter_list|,
name|msg
parameter_list|,
name|comm
parameter_list|)
name|PS
name|psp
decl_stmt|;
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
name|struct
name|community
modifier|*
name|comm
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|v
init|=
name|comm
operator|->
name|c_view
decl_stmt|;
specifier|register
name|struct
name|proxyque
modifier|*
name|pq
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|PS
name|ps
decl_stmt|;
if|if
condition|(
name|qb_pullup
argument_list|(
name|msg
operator|->
name|community
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"qb_pullup: out of memory (proxy %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|pqs
operator|>=
name|NPQ
condition|)
block|{
specifier|register
name|struct
name|proxyque
modifier|*
name|qp
decl_stmt|;
for|for
control|(
name|qp
operator|=
operator|(
name|pq
operator|=
name|pips
operator|)
operator|+
name|NPQ
init|;
name|pq
operator|<
name|qp
condition|;
name|pq
operator|++
control|)
if|if
condition|(
name|pq
operator|->
name|pq_age
operator|<
name|quantum
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"proxy flush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|pq_closefnx
condition|)
block|{
name|ps_free
argument_list|(
name|pq
operator|->
name|pq_ps
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|pq
operator|->
name|pq_closefnx
argument_list|)
argument_list|(
name|pq
operator|->
name|pq_fd
argument_list|)
expr_stmt|;
block|}
name|QBFREE
argument_list|(
operator|&
name|pq
operator|->
name|pq_community
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pq
operator|>=
name|qp
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"proxy for view %s, but no proxyque slots available (%s)"
argument_list|,
name|oid2ode
argument_list|(
name|v
operator|->
name|v_name
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
else|else
name|pq
operator|=
name|pips
operator|+
name|pqs
operator|++
expr_stmt|;
name|pq
operator|->
name|pq_quantum
operator|=
name|quantum
expr_stmt|;
name|pq
operator|->
name|pq_age
operator|=
name|quantum
operator|+
literal|20
expr_stmt|;
comment|/* who knows what a good value is?!? */
name|pq
operator|->
name|pq_ps
operator|=
name|psp
expr_stmt|;
name|pq
operator|->
name|pq_community
operator|.
name|qb_forw
operator|=
name|pq
operator|->
name|pq_community
operator|.
name|qb_back
operator|=
operator|&
name|pq
operator|->
name|pq_community
expr_stmt|;
name|insque
argument_list|(
name|msg
operator|->
name|community
operator|->
name|qb_forw
argument_list|,
operator|&
name|pq
operator|->
name|pq_community
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
operator|->
name|community
argument_list|)
expr_stmt|;
name|pq
operator|->
name|pq_request
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
expr_stmt|;
name|msg
operator|->
name|community
operator|=
name|v
operator|->
name|v_community
expr_stmt|;
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
operator|=
name|pq
operator|->
name|pq_quantum
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s (proxy %s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_Message
argument_list|,
name|pe
argument_list|,
literal|"Message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|dg_open
argument_list|)
operator|)
operator|==
name|NULLPS
operator|||
name|dg_setup
argument_list|(
name|ps
argument_list|,
name|udp
argument_list|,
name|MAXSNMP
argument_list|,
name|read_udp_socket
argument_list|,
name|write_udp_socket
argument_list|,
name|check_udp_socket
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULLPS
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory (proxy %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"dg_setup: %s (proxy %s)"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hack_dgram_socket
argument_list|(
name|udp
argument_list|,
operator|&
name|v
operator|->
name|v_sa
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"hack_dgram_socket(1) (proxy %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"pe2ps: %s (proxy %s)"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|=
name|OK
expr_stmt|;
if|if
condition|(
name|hack_dgram_socket
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"hack_dgram_socket(2) (proxy %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
name|ps_free
argument_list|(
name|ps
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
name|msg
operator|->
name|community
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
specifier|register
name|struct
name|proxyque
modifier|*
name|qp
init|=
name|pips
operator|+
operator|--
name|pqs
decl_stmt|;
if|if
condition|(
name|pq
operator|->
name|pq_closefnx
condition|)
block|{
name|ps_free
argument_list|(
name|pq
operator|->
name|pq_ps
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|pq
operator|->
name|pq_closefnx
argument_list|)
argument_list|(
name|pq
operator|->
name|pq_fd
argument_list|)
expr_stmt|;
block|}
name|QBFREE
argument_list|(
operator|&
name|pq
operator|->
name|pq_community
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|!=
name|qp
condition|)
operator|*
name|pq
operator|=
operator|*
name|qp
expr_stmt|;
comment|/* struct copy */
block|}
else|else
name|pqr
operator|=
name|pq
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|proxy2
parameter_list|(
name|msg
parameter_list|)
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
block|{
name|integer
name|request
decl_stmt|;
specifier|register
name|struct
name|proxyque
modifier|*
name|pq
decl_stmt|,
modifier|*
name|qp
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|request
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
expr_stmt|;
for|for
control|(
name|qp
operator|=
operator|(
name|pq
operator|=
name|pips
operator|)
operator|+
name|pqs
init|;
name|pq
operator|<
name|qp
condition|;
name|pq
operator|++
control|)
if|if
condition|(
name|pq
operator|->
name|pq_quantum
operator|==
name|request
condition|)
break|break;
if|if
condition|(
name|pq
operator|>=
name|qp
condition|)
return|return
name|OK
return|;
name|qb_free
argument_list|(
name|msg
operator|->
name|community
argument_list|)
expr_stmt|;
name|msg
operator|->
name|community
operator|=
operator|&
name|pq
operator|->
name|pq_community
expr_stmt|;
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
operator|=
name|pq
operator|->
name|pq_request
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s (proxy %s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_Message
argument_list|,
name|pe
argument_list|,
literal|"Message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|pq
operator|->
name|pq_ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"pe2ps: %s (proxy %s)"
argument_list|,
name|ps_error
argument_list|(
name|pq
operator|->
name|pq_ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|snmpstat
operator|.
name|s_outgetresponses
operator|++
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
name|msg
operator|->
name|community
operator|=
name|NULL
expr_stmt|;
name|qp
operator|=
name|pips
operator|+
operator|--
name|pqs
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|pq_closefnx
condition|)
block|{
name|ps_free
argument_list|(
name|pq
operator|->
name|pq_ps
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|pq
operator|->
name|pq_closefnx
argument_list|)
argument_list|(
name|pq
operator|->
name|pq_fd
argument_list|)
expr_stmt|;
block|}
name|QBFREE
argument_list|(
operator|&
name|pq
operator|->
name|pq_community
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|!=
name|qp
condition|)
operator|*
name|pq
operator|=
operator|*
name|qp
expr_stmt|;
comment|/* struct copy */
return|return
name|DONE
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COTS
end_ifdef

begin_expr_stmt
specifier|static
name|proxy_clear
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|proxyque
modifier|*
name|pq
decl_stmt|,
modifier|*
name|qp
decl_stmt|;
name|again
label|:
empty_stmt|;
for|for
control|(
name|qp
operator|=
operator|(
name|pq
operator|=
name|pips
operator|)
operator|+
name|pqs
init|;
name|pq
operator|<
name|qp
condition|;
name|pq
operator|++
control|)
if|if
condition|(
name|pq
operator|->
name|pq_fd
operator|==
name|fd
condition|)
block|{
name|qp
operator|=
name|pips
operator|+
operator|--
name|pqs
expr_stmt|;
if|if
condition|(
name|pq
operator|->
name|pq_closefnx
condition|)
block|{
name|ps_free
argument_list|(
name|pq
operator|->
name|pq_ps
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|pq
operator|->
name|pq_closefnx
argument_list|)
argument_list|(
name|pq
operator|->
name|pq_fd
argument_list|)
expr_stmt|;
block|}
name|QBFREE
argument_list|(
operator|&
name|pq
operator|->
name|pq_community
argument_list|)
expr_stmt|;
if|if
condition|(
name|pq
operator|!=
name|qp
condition|)
operator|*
name|pq
operator|=
operator|*
name|qp
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|SMUX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMUX
end_ifdef

begin_include
include|#
directive|include
file|"smux.h"
end_include

begin_function
specifier|static
name|int
name|start_smux
parameter_list|()
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|sockaddr_in
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|smuxPeer
modifier|*
name|pb
decl_stmt|,
modifier|*
name|qb
decl_stmt|;
specifier|static
name|int
name|smux_peerno
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|join_tcp_client
argument_list|(
name|smux
argument_list|,
name|isock
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
return|return
name|NOTOK
return|;
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"join_tcp_client"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pb
operator|=
operator|(
expr|struct
name|smuxPeer
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|pb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"doit_smux: out of memory"
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|pb
operator|->
name|pb_address
operator|=
operator|*
name|isock
expr_stmt|;
comment|/* struct copy */
comment|/* Format sockets consistantly with other places in this program,        with a plus sign between the internet address and port number.  (EJP) */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pb
operator|->
name|pb_source
argument_list|,
literal|"%s+%d"
argument_list|,
name|inet_ntoa
argument_list|(
name|pb
operator|->
name|pb_address
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|pb
operator|->
name|pb_address
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|source
argument_list|,
name|pb
operator|->
name|pb_source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pb
operator|->
name|pb_ps
operator|=
name|ps_alloc
argument_list|(
name|fdx_open
argument_list|)
operator|)
operator|==
name|NULLPS
operator|||
name|fdx_setup
argument_list|(
name|pb
operator|->
name|pb_ps
argument_list|,
name|fd
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|pb_ps
operator|==
name|NULLPS
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory (SMUX %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"fdx_setup: %s (SMUX %s)"
argument_list|,
name|ps_error
argument_list|(
name|pb
operator|->
name|pb_ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|pb_free
argument_list|(
name|pb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Insert new smuxPeer structure at the end of the doubly-linked        list anchored at PHead and assign it the next sequential index        number for use as smuxPindex in o_smuxPeer() and smuxTindex in        o_smuxTree().  (EJP) */
name|insque
argument_list|(
name|pb
argument_list|,
name|PHead
operator|->
name|pb_back
argument_list|)
expr_stmt|;
name|pb
operator|->
name|pb_index
operator|=
operator|++
name|smux_peerno
expr_stmt|;
return|return
operator|(
name|pb
operator|->
name|pb_fd
operator|=
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|doit_smux
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|PE
name|pe
decl_stmt|;
specifier|register
name|struct
name|smuxPeer
modifier|*
name|pb
decl_stmt|;
name|struct
name|type_SNMP_SMUX__PDUs
modifier|*
name|pdu
decl_stmt|;
for|for
control|(
name|pb
operator|=
name|PHead
operator|->
name|pb_forw
init|;
name|pb
operator|!=
name|PHead
condition|;
name|pb
operator|=
name|pb
operator|->
name|pb_forw
control|)
if|if
condition|(
name|pb
operator|->
name|pb_fd
operator|==
name|fd
condition|)
break|break;
if|if
condition|(
name|pb
operator|==
name|PHead
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"lost smuxPeer block for %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|fd
argument_list|,
operator|&
name|sfds
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|source
argument_list|,
name|pb
operator|->
name|pb_source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|pb
operator|->
name|pb_ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"ps2pe: %s (SMUX %s)"
argument_list|,
name|ps_error
argument_list|(
name|pb
operator|->
name|pb_ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|pb_free
argument_list|(
name|pb
argument_list|)
expr_stmt|;
return|return;
block|}
name|advise
argument_list|(
name|LLOG_XXX
argument_list|,
name|NULLCP
argument_list|,
literal|"SMUX packet from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|pdu
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|decode_SNMP_SMUX__PDUs
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|pdu
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"decode_SNMP_SMUX__PDUs: %s (SMUX %s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_SMUX__PDUs
argument_list|,
name|pe
argument_list|,
literal|"SMUX Message"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|smux_process
argument_list|(
name|pb
argument_list|,
name|pdu
argument_list|)
operator|==
name|NOTOK
condition|)
name|pb_free
argument_list|(
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdu
condition|)
name|free_SNMP_SMUX__PDUs
argument_list|(
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|smux_process
argument_list|(
name|pb
argument_list|,
name|pdu
argument_list|)
specifier|register
expr|struct
name|smuxPeer
operator|*
name|pb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|type_SNMP_SMUX__PDUs
modifier|*
name|pdu
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|result
init|=
name|OK
decl_stmt|;
switch|switch
condition|(
name|pdu
operator|->
name|offset
condition|)
block|{
case|case
name|type_SNMP_SMUX__PDUs_simple
case|:
if|if
condition|(
name|pb
operator|->
name|pb_identity
condition|)
goto|goto
name|unexpected
goto|;
block|{
specifier|register
name|struct
name|type_SNMP_SimpleOpen
modifier|*
name|simple
init|=
name|pdu
operator|->
name|un
operator|.
name|simple
decl_stmt|;
specifier|register
name|struct
name|smuxEntry
modifier|*
name|se
decl_stmt|;
if|if
condition|(
name|simple
operator|->
name|version
operator|!=
name|int_SNMP_version_version__1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"badVersion: %d (SMUX %s)"
argument_list|,
name|simple
operator|->
name|version
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|pb
operator|->
name|pb_identity
operator|=
name|simple
operator|->
name|identity
expr_stmt|;
name|simple
operator|->
name|identity
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pb
operator|->
name|pb_description
operator|=
name|qb2str
argument_list|(
name|simple
operator|->
name|description
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"qb2str: out of memory (SMUX %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|qb_pullup
argument_list|(
name|simple
operator|->
name|password
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"qb_pullup: out of memory (SMUX %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|se
operator|=
name|getsmuxEntrybyidentity
argument_list|(
name|pb
operator|->
name|pb_identity
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|se
operator|->
name|se_password
argument_list|,
name|simple
operator|->
name|password
operator|->
name|qb_forw
operator|->
name|qb_data
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: %s (SMUX %s)"
argument_list|,
name|se
condition|?
literal|"badPassword"
else|:
literal|"badIdentity"
argument_list|,
name|oid2ode
argument_list|(
name|simple
operator|->
name|identity
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmpstat
operator|.
name|s_enableauthentraps
operator|==
name|TRAPS_ENABLED
condition|)
name|do_trap
argument_list|(
name|int_SNMP_generic__trap_authenticationFailure
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|pb
operator|->
name|pb_priority
operator|=
name|se
operator|->
name|se_priority
operator|)
operator|<
literal|0
condition|)
name|pb
operator|->
name|pb_priority
operator|=
literal|0
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"SMUX open: %d %s \"%s\" (%d/ %s)"
argument_list|,
name|pb
operator|->
name|pb_index
argument_list|,
name|oid2ode
argument_list|(
name|pb
operator|->
name|pb_identity
argument_list|)
argument_list|,
name|pb
operator|->
name|pb_description
argument_list|,
name|pb
operator|->
name|pb_fd
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|type_SNMP_SMUX__PDUs_close
case|:
if|if
condition|(
operator|!
name|pb
operator|->
name|pb_identity
condition|)
goto|goto
name|unexpected
goto|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"SMUX close: %s (%s)"
argument_list|,
name|smux_error
argument_list|(
name|pdu
operator|->
name|un
operator|.
name|close
operator|->
name|parm
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|type_SNMP_SMUX__PDUs_registerRequest
case|:
if|if
condition|(
operator|!
name|pb
operator|->
name|pb_identity
condition|)
goto|goto
name|unexpected
goto|;
block|{
specifier|register
name|struct
name|type_SNMP_RReqPDU
modifier|*
name|rreq
init|=
name|pdu
operator|->
name|un
operator|.
name|registerRequest
decl_stmt|;
name|struct
name|type_SNMP_RRspPDU
name|rrsp
decl_stmt|;
name|struct
name|type_SNMP_SMUX__PDUs
name|rsp
decl_stmt|;
specifier|register
name|struct
name|smuxReserved
modifier|*
name|sr
decl_stmt|;
specifier|register
name|struct
name|smuxTree
modifier|*
name|tb
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|smuxTree
modifier|*
name|qb
decl_stmt|;
specifier|register
name|OID
name|oid
init|=
name|rreq
operator|->
name|subtree
decl_stmt|;
name|OT
name|ot
init|=
name|NULLOT
decl_stmt|;
name|PE
name|pe
decl_stmt|;
for|for
control|(
name|sr
operator|=
name|reserved
init|;
name|sr
operator|->
name|rb_text
condition|;
name|sr
operator|++
control|)
if|if
condition|(
name|sr
operator|->
name|rb_name
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sr
operator|->
name|rb_name
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|oid
operator|->
name|oid_elements
argument_list|,
operator|(
name|sr
operator|->
name|rb_name
operator|->
name|oid_nelem
operator|<=
name|oid
operator|->
name|oid_nelem
condition|?
name|sr
operator|->
name|rb_name
operator|->
name|oid_nelem
else|:
name|oid
operator|->
name|oid_nelem
operator|)
operator|*
sizeof|sizeof
name|oid
operator|->
name|oid_elements
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"reservedSubTree: %s %s %s (SMUX %s)"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|,
name|sr
operator|->
name|rb_name
operator|->
name|oid_nelem
operator|<=
name|oid
operator|->
name|oid_nelem
condition|?
literal|"under"
else|:
literal|"contains"
argument_list|,
name|sr
operator|->
name|rb_text
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|no_dice
goto|;
block|}
if|if
condition|(
operator|(
name|ot
operator|=
name|name2obj
argument_list|(
name|oid
argument_list|)
operator|)
operator|==
name|NULLOT
condition|)
block|{
if|if
condition|(
name|rreq
operator|->
name|operation
operator|==
name|int_SNMP_operation_delete
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"noSuchSubTree: %s (SMUX %s)"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|no_dice
goto|;
block|}
if|if
condition|(
operator|(
name|ot
operator|=
operator|(
name|OT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ot
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ot
operator|->
name|ot_text
operator|=
name|ot
operator|->
name|ot_id
operator|=
name|strdup
argument_list|(
name|sprintoid
argument_list|(
name|oid
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory (SMUX %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|ot
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ot
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ot
operator|->
name|ot_name
operator|=
name|rreq
operator|->
name|subtree
expr_stmt|;
name|rreq
operator|->
name|subtree
operator|=
name|NULL
expr_stmt|;
name|ot
operator|->
name|ot_access
operator|=
name|rreq
operator|->
name|operation
expr_stmt|;
name|ot
operator|->
name|ot_status
operator|=
name|OT_OPTIONAL
expr_stmt|;
name|export_view
argument_list|(
name|ot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_objects
argument_list|(
name|ot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rreq
operator|->
name|operation
operator|==
name|int_SNMP_operation_delete
condition|)
block|{
for|for
control|(
name|tb
operator|=
operator|(
expr|struct
name|smuxTree
operator|*
operator|)
name|ot
operator|->
name|ot_smux
init|;
name|tb
condition|;
name|tb
operator|=
name|tb
operator|->
name|tb_next
control|)
if|if
condition|(
name|tb
operator|->
name|tb_peer
operator|==
name|pb
operator|&&
operator|(
name|rreq
operator|->
name|priority
operator|<
literal|0
operator|||
name|rreq
operator|->
name|priority
operator|==
name|tb
operator|->
name|tb_priority
operator|)
condition|)
break|break;
if|if
condition|(
name|tb
condition|)
name|tb_free
argument_list|(
name|tb
argument_list|)
expr_stmt|;
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"noSuchRegistration: %s (SMUX %s)"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|ot
operator|=
name|NULLOT
expr_stmt|;
block|}
goto|goto
name|no_dice
goto|;
block|}
if|if
condition|(
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|>
name|oid
operator|->
name|oid_nelem
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"badSubTree: %s (SMUX %s)"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|ot
operator|=
name|NULL
expr_stmt|;
goto|goto
name|no_dice
goto|;
block|}
name|export_view
argument_list|(
name|ot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tb
operator|=
operator|(
expr|struct
name|smuxTree
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|tb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory (SMUX %s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|tb
operator|->
name|tb_priority
operator|=
name|rreq
operator|->
name|priority
operator|)
operator|<
name|pb
operator|->
name|pb_priority
condition|)
name|tb
operator|->
name|tb_priority
operator|=
name|pb
operator|->
name|pb_priority
expr_stmt|;
for|for
control|(
name|qb
operator|=
operator|(
expr|struct
name|smuxTree
operator|*
operator|)
name|ot
operator|->
name|ot_smux
init|;
name|qb
condition|;
name|qb
operator|=
name|qb
operator|->
name|tb_next
control|)
if|if
condition|(
name|qb
operator|->
name|tb_priority
operator|>
name|tb
operator|->
name|tb_priority
condition|)
break|break;
elseif|else
if|if
condition|(
name|qb
operator|->
name|tb_priority
operator|==
name|tb
operator|->
name|tb_priority
condition|)
name|tb
operator|->
name|tb_priority
operator|++
expr_stmt|;
name|tb
operator|->
name|tb_peer
operator|=
name|pb
expr_stmt|;
name|no_dice
label|:
empty_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rsp
argument_list|,
sizeof|sizeof
name|rsp
argument_list|)
expr_stmt|;
name|rsp
operator|.
name|offset
operator|=
name|type_SNMP_SMUX__PDUs_registerResponse
expr_stmt|;
name|rsp
operator|.
name|un
operator|.
name|registerResponse
operator|=
operator|&
name|rrsp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rrsp
argument_list|,
sizeof|sizeof
name|rrsp
argument_list|)
expr_stmt|;
name|rrsp
operator|.
name|parm
operator|=
name|tb
condition|?
name|tb
operator|->
name|tb_priority
else|:
name|int_SNMP_RRspPDU_failure
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_SNMP_SMUX__PDUs
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
operator|&
name|rsp
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_SMUX__PDUs
argument_list|,
name|pe
argument_list|,
literal|"SMUX Message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|pb
operator|->
name|pb_ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"pe2ps: %s (SMUX %s)"
argument_list|,
name|ps_error
argument_list|(
name|pb
operator|->
name|pb_ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ot
condition|)
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"SMUX register: %s %s in=%d out=%d (%s)"
argument_list|,
name|rreq
operator|->
name|operation
operator|==
name|int_SNMP_operation_delete
condition|?
literal|"delete"
else|:
name|rreq
operator|->
name|operation
operator|==
name|int_SNMP_operation_readOnly
condition|?
literal|"readOnly"
else|:
literal|"readWrite"
argument_list|,
name|oid2ode
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
argument_list|,
name|rreq
operator|->
name|priority
argument_list|,
name|tb
condition|?
name|tb
operator|->
name|tb_priority
else|:
operator|-
literal|1
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|&&
name|rreq
operator|->
name|operation
operator|!=
name|int_SNMP_operation_delete
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
specifier|register
name|struct
name|smuxTree
modifier|*
modifier|*
name|qpp
decl_stmt|;
name|tb
operator|->
name|tb_subtree
operator|=
name|ot
expr_stmt|;
comment|/* Insert the new element into the single-linked chain 		       of smuxTree structures for this object type that is 		       anchored in the object tree.  Elements are chained 		       in order of increasing priority.  (EJP) */
for|for
control|(
name|qpp
operator|=
operator|(
expr|struct
name|smuxTree
operator|*
operator|*
operator|)
operator|&
name|ot
operator|->
name|ot_smux
init|;
name|qb
operator|=
operator|*
name|qpp
condition|;
name|qpp
operator|=
operator|&
name|qb
operator|->
name|tb_next
control|)
if|if
condition|(
name|qb
operator|->
name|tb_priority
operator|>
name|tb
operator|->
name|tb_priority
condition|)
break|break;
name|tb
operator|->
name|tb_next
operator|=
name|qb
expr_stmt|;
operator|*
name|qpp
operator|=
name|tb
expr_stmt|;
comment|/* Fill in the tb_instance field of the new element 		       with the concatenation of the size of the object name 		       followed by the object name itself followed by 		       its priority.  (EJP) */
name|ip
operator|=
name|tb
operator|->
name|tb_instance
expr_stmt|;
name|jp
operator|=
name|ot
operator|->
name|ot_name
operator|->
name|oid_elements
expr_stmt|;
operator|*
name|ip
operator|++
operator|=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|ip
operator|++
operator|=
operator|*
name|jp
operator|++
expr_stmt|;
operator|*
name|ip
operator|++
operator|=
name|tb
operator|->
name|tb_priority
expr_stmt|;
name|tb
operator|->
name|tb_insize
operator|=
name|ip
operator|-
name|tb
operator|->
name|tb_instance
expr_stmt|;
comment|/* Insert the new element into the doubly-linked chain 		       of all smuxTree structures that is anchored in THead. 		       Elements are chained in lexicographic order of 		       tb_instance so that the get_tbent() function will 		       work correctly for 'get next' operations.  (EJP) */
for|for
control|(
name|qb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|qb
operator|!=
name|THead
condition|;
name|qb
operator|=
name|qb
operator|->
name|tb_forw
control|)
if|if
condition|(
name|elem_cmp
argument_list|(
name|tb
operator|->
name|tb_instance
argument_list|,
name|tb
operator|->
name|tb_insize
argument_list|,
name|qb
operator|->
name|tb_instance
argument_list|,
name|qb
operator|->
name|tb_insize
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|insque
argument_list|(
name|tb
argument_list|,
name|qb
operator|->
name|tb_back
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_SMUX__PDUs: %s (SMUX %s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
block|}
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|type_SNMP_SMUX__PDUs_trap
case|:
if|if
condition|(
operator|!
name|pb
operator|->
name|pb_identity
condition|)
goto|goto
name|unexpected
goto|;
block|{
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
name|struct
name|type_SNMP_Message
name|msgs
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_Message
modifier|*
name|msg
init|=
operator|&
name|msgs
decl_stmt|;
name|struct
name|type_SNMP_PDUs
name|datas
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDUs
modifier|*
name|data
init|=
operator|&
name|datas
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_Trap__PDU
modifier|*
name|parm
init|=
name|pdu
operator|->
name|un
operator|.
name|trap
decl_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"SMUX trap: %d %d (%s)"
argument_list|,
name|parm
operator|->
name|generic__trap
argument_list|,
name|parm
operator|->
name|specific__trap
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
sizeof|sizeof
expr|*
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|->
name|version
operator|=
name|int_SNMP_version_version__1
expr_stmt|;
name|msg
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
expr|*
name|data
argument_list|)
expr_stmt|;
name|data
operator|->
name|offset
operator|=
name|type_SNMP_PDUs_trap
expr_stmt|;
name|data
operator|->
name|un
operator|.
name|trap
operator|=
name|parm
expr_stmt|;
if|if
condition|(
name|loopback_addr
operator|&&
name|qb_pullup
argument_list|(
name|qb
operator|=
name|parm
operator|->
name|agent__addr
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|qb
operator|->
name|qb_len
operator|==
name|loopback_addr
operator|->
name|qb_len
operator|&&
name|bcmp
argument_list|(
name|qb
operator|->
name|qb_forw
operator|->
name|qb_data
argument_list|,
name|loopback_addr
operator|->
name|qb_forw
operator|->
name|qb_data
argument_list|,
name|qb
operator|->
name|qb_len
argument_list|)
operator|==
literal|0
condition|)
name|parm
operator|->
name|agent__addr
operator|=
name|trap
operator|->
name|data
operator|->
name|un
operator|.
name|trap
operator|->
name|agent__addr
expr_stmt|;
name|do_traps
argument_list|(
name|msg
argument_list|,
name|parm
operator|->
name|generic__trap
argument_list|,
name|parm
operator|->
name|specific__trap
argument_list|)
expr_stmt|;
name|parm
operator|->
name|agent__addr
operator|=
name|qb
expr_stmt|;
block|}
break|break;
case|case
name|type_SNMP_SMUX__PDUs_registerResponse
case|:
case|case
name|type_SNMP_SMUX__PDUs_get__request
case|:
case|case
name|type_SNMP_SMUX__PDUs_get__next__request
case|:
case|case
name|type_SNMP_SMUX__PDUs_get__response
case|:
case|case
name|type_SNMP_SMUX__PDUs_set__request
case|:
name|unexpected
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpectedOperation: %d (SMUX %s)"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
default|default:
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"badOperation: %d (SMUX %s)"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|smux_method
parameter_list|(
name|pdu
parameter_list|,
name|ot
parameter_list|,
name|pb
parameter_list|,
name|v
parameter_list|,
name|offset
parameter_list|)
name|struct
name|type_SNMP_PDUs
modifier|*
name|pdu
decl_stmt|;
name|OT
name|ot
decl_stmt|;
specifier|register
name|struct
name|smuxPeer
modifier|*
name|pb
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|orig_id
decl_stmt|;
name|struct
name|type_SNMP_VarBindList
modifier|*
name|orig_bindings
decl_stmt|,
name|vps
decl_stmt|;
name|struct
name|type_SNMP_SMUX__PDUs
name|req
decl_stmt|,
modifier|*
name|rsp
decl_stmt|;
name|struct
name|type_SNMP_SOutPDU
name|cor
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_GetResponse__PDU
modifier|*
name|get
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|status
operator|=
name|int_SNMP_error__status_noError
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
name|req
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
name|req
operator|.
name|offset
operator|=
name|type_SNMP_SMUX__PDUs_get__request
expr_stmt|;
goto|goto
name|stuff_pdu
goto|;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
name|req
operator|.
name|offset
operator|=
name|type_SNMP_SMUX__PDUs_get__next__request
expr_stmt|;
goto|goto
name|stuff_pdu
goto|;
case|case
name|type_SNMP_PDUs_set__request
case|:
name|req
operator|.
name|offset
operator|=
name|type_SNMP_SMUX__PDUs_set__request
expr_stmt|;
name|stuff_pdu
label|:
empty_stmt|;
name|orig_id
operator|=
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
expr_stmt|;
name|orig_bindings
operator|=
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
expr_stmt|;
name|req
operator|.
name|un
operator|.
name|get__request
operator|=
name|pdu
operator|->
name|un
operator|.
name|get__request
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|vps
argument_list|,
sizeof|sizeof
name|vps
argument_list|)
expr_stmt|;
name|vps
operator|.
name|VarBind
operator|=
name|v
expr_stmt|;
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
operator|=
name|quantum
expr_stmt|;
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
operator|=
operator|&
name|vps
expr_stmt|;
break|break;
case|case
name|type_SNMP_PDUs_commit
case|:
name|cor
operator|.
name|parm
operator|=
name|int_SNMP_SOutPDU_commit
expr_stmt|;
goto|goto
name|stuff_cor
goto|;
case|case
name|type_SNMP_PDUs_rollback
case|:
name|cor
operator|.
name|parm
operator|=
name|int_SNMP_SOutPDU_rollback
expr_stmt|;
name|stuff_cor
label|:
empty_stmt|;
name|req
operator|.
name|offset
operator|=
name|type_SNMP_SMUX__PDUs_commitOrRollback
expr_stmt|;
name|req
operator|.
name|un
operator|.
name|commitOrRollback
operator|=
operator|&
name|cor
expr_stmt|;
break|break;
block|}
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_SNMP_SMUX__PDUs
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
operator|&
name|req
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_SMUX__PDUs
argument_list|,
name|pe
argument_list|,
literal|"SMUX Message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|pb
operator|->
name|pb_ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"pe2ps: %s (%s, SMUX %s)"
argument_list|,
name|ps_error
argument_list|(
name|pb
operator|->
name|pb_ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|,
name|pb
operator|->
name|pb_source
argument_list|)
expr_stmt|;
name|lost_peer
label|:
empty_stmt|;
name|pb_free
argument_list|(
name|pb
argument_list|)
expr_stmt|;
name|status
operator|=
name|int_SNMP_error__status_genErr
expr_stmt|;
block|}
block|}
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_SMUX__PDUs: %s (%s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|status
operator|=
name|int_SNMP_error__status_genErr
expr_stmt|;
block|}
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
case|case
name|type_SNMP_PDUs_get__next__request
case|:
case|case
name|type_SNMP_PDUs_set__request
case|:
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
operator|=
name|orig_id
expr_stmt|;
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|->
name|variable__bindings
operator|=
name|orig_bindings
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|status
operator|!=
name|int_SNMP_error__status_noError
operator|||
name|offset
operator|==
name|type_SNMP_PDUs_rollback
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|pb
operator|->
name|pb_ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"ps2pe: %s (%s, SMUX %s)"
argument_list|,
name|ps_error
argument_list|(
name|pb
operator|->
name|pb_ps
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|,
name|pb
operator|->
name|pb_source
argument_list|)
expr_stmt|;
goto|goto
name|lost_peer
goto|;
block|}
name|rsp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|decode_SNMP_SMUX__PDUs
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|rsp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"decode_SNMP_SMUX__PDUs: %s (%s, SMUX %s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|,
name|pb
operator|->
name|pb_source
argument_list|)
expr_stmt|;
name|lost_peer_again
label|:
empty_stmt|;
name|pb_free
argument_list|(
name|pb
argument_list|)
expr_stmt|;
name|status
operator|=
name|int_SNMP_error__status_genErr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_SMUX__PDUs
argument_list|,
name|pe
argument_list|,
literal|"SMUX Message"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|offset
operator|!=
name|type_SNMP_SMUX__PDUs_get__response
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpectedOperation: %d (%s, SMUX %s)"
argument_list|,
name|rsp
operator|->
name|offset
argument_list|,
name|source
argument_list|,
name|pb
operator|->
name|pb_source
argument_list|)
expr_stmt|;
goto|goto
name|lost_peer_again
goto|;
block|}
name|get
operator|=
name|rsp
operator|->
name|un
operator|.
name|get__response
expr_stmt|;
switch|switch
condition|(
name|status
operator|=
name|get
operator|->
name|error__status
condition|)
block|{
case|case
name|int_SNMP_error__status_noError
case|:
block|{
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v2
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|get
operator|->
name|variable__bindings
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"missing variable in get response (%s, SMUX %s)"
argument_list|,
name|source
argument_list|,
name|pb
operator|->
name|pb_source
argument_list|)
expr_stmt|;
goto|goto
name|lost_peer_again
goto|;
block|}
name|v2
operator|=
name|vp
operator|->
name|VarBind
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|type_SNMP_PDUs_get__next__request
operator|&&
operator|(
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|>
name|v2
operator|->
name|name
operator|->
name|oid_nelem
operator|||
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ot
operator|->
name|ot_name
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v2
operator|->
name|name
operator|->
name|oid_elements
argument_list|,
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
name|ot
operator|->
name|ot_name
operator|->
name|oid_elements
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|status
operator|=
name|NOTOK
expr_stmt|;
break|break;
block|}
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|v2
operator|->
name|name
expr_stmt|;
name|v2
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|free_SNMP_ObjectSyntax
argument_list|(
name|v
operator|->
name|value
argument_list|)
expr_stmt|;
name|v
operator|->
name|value
operator|=
name|v2
operator|->
name|value
expr_stmt|;
name|v2
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|int_SNMP_error__status_noSuchName
case|:
if|if
condition|(
name|offset
operator|==
name|type_SNMP_PDUs_get__next__request
condition|)
block|{
name|status
operator|=
name|NOTOK
expr_stmt|;
break|break;
block|}
comment|/* else fall */
default|default:
break|break;
block|}
name|out
label|:
empty_stmt|;
if|if
condition|(
name|rsp
condition|)
name|free_SNMP_SMUX__PDUs
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|pb_free
argument_list|(
name|pb
argument_list|)
specifier|register
expr|struct
name|smuxPeer
operator|*
name|pb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|smuxTree
modifier|*
name|tb
decl_stmt|,
modifier|*
name|ub
decl_stmt|;
if|if
condition|(
name|pb
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|tb
operator|=
name|THead
operator|->
name|tb_forw
init|;
name|tb
operator|!=
name|THead
condition|;
name|tb
operator|=
name|ub
control|)
block|{
name|ub
operator|=
name|tb
operator|->
name|tb_forw
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tb_peer
operator|==
name|pb
condition|)
name|tb_free
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pb
operator|->
name|pb_ps
condition|)
name|ps_free
argument_list|(
name|pb
operator|->
name|pb_ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|pb_fd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close_tcp_socket
argument_list|(
name|pb
operator|->
name|pb_fd
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|pb
operator|->
name|pb_fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_CLR
argument_list|(
name|pb
operator|->
name|pb_fd
argument_list|,
operator|&
name|sfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pb
operator|->
name|pb_identity
condition|)
name|oid_free
argument_list|(
name|pb
operator|->
name|pb_identity
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|pb_description
condition|)
name|free
argument_list|(
name|pb
operator|->
name|pb_description
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|pb
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|tb_free
argument_list|(
name|tb
argument_list|)
specifier|register
expr|struct
name|smuxTree
operator|*
name|tb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|smuxTree
modifier|*
name|tp
decl_stmt|,
modifier|*
modifier|*
name|tpp
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|tpp
operator|=
operator|(
expr|struct
name|smuxTree
operator|*
operator|*
operator|)
operator|&
name|tb
operator|->
name|tb_subtree
operator|->
name|ot_smux
init|;
name|tp
operator|=
operator|*
name|tpp
condition|;
name|tpp
operator|=
operator|&
name|tp
operator|->
name|tb_next
control|)
if|if
condition|(
name|tp
operator|==
name|tb
condition|)
block|{
operator|*
name|tpp
operator|=
name|tb
operator|->
name|tb_next
expr_stmt|;
break|break;
block|}
name|remque
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tb
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMUX */
end_comment

begin_comment
comment|/*
comment|VIEWS */
end_comment

begin_expr_stmt
specifier|static
name|start_view
argument_list|()
block|{
specifier|register
name|OT
name|ot
block|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"view"
argument_list|)
condition|)
name|viewTree
operator|=
name|ot
operator|->
name|ot_name
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Initialize the view mask of all objects in the tree, not just        the leaves.  This is necessary so that do_pass() will allow        SMUX sub-agents to mount their subtrees over interior objects.  (EJP) */
end_comment

begin_for
for|for
control|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"ccitt"
argument_list|)
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
name|export_view
argument_list|(
name|ot
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_expr_stmt
unit|static
name|export_view
argument_list|(
name|ot
argument_list|)
specifier|register
name|OT
name|ot
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|subtree
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|view
modifier|*
name|v
decl_stmt|;
name|OID
name|name
init|=
name|ot
operator|->
name|ot_name
decl_stmt|;
name|ot
operator|->
name|ot_views
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
name|VHead
operator|->
name|v_forw
init|;
name|v
operator|!=
name|VHead
condition|;
name|v
operator|=
name|v
operator|->
name|v_forw
control|)
if|if
condition|(
operator|(
name|s
operator|=
name|v
operator|->
name|v_subtree
operator|.
name|s_forw
operator|)
operator|!=
operator|&
name|v
operator|->
name|v_subtree
condition|)
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|&
name|v
operator|->
name|v_subtree
condition|;
name|s
operator|=
name|s
operator|->
name|s_forw
control|)
if|if
condition|(
name|inSubtree
argument_list|(
name|s
operator|->
name|s_subtree
argument_list|,
name|name
argument_list|)
condition|)
goto|goto
name|mark_it
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|viewTree
operator|||
operator|!
name|inSubtree
argument_list|(
name|viewTree
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|mark_it
label|:
empty_stmt|;
name|ot
operator|->
name|ot_views
operator||=
name|v
operator|->
name|v_mask
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|COMMUNITIES */
end_comment

begin_function
specifier|static
name|struct
name|community
modifier|*
name|str2comm
parameter_list|(
name|name
parameter_list|,
name|na
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
block|{
specifier|register
name|struct
name|community
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|c
operator|=
name|CHead
operator|->
name|c_forw
init|;
name|c
operator|!=
name|CHead
condition|;
name|c
operator|=
name|c
operator|->
name|c_forw
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|c_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|c_addr
operator|.
name|na_stack
operator|==
name|NA_TCP
operator|&&
name|strcmp
argument_list|(
name|c
operator|->
name|c_addr
operator|.
name|na_domain
argument_list|,
literal|"0.0.0.0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|d
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|c_addr
operator|.
name|na_stack
operator|!=
name|na
operator|->
name|na_stack
condition|)
continue|continue;
switch|switch
condition|(
name|na
operator|->
name|na_stack
condition|)
block|{
case|case
name|NA_TCP
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|c
operator|->
name|c_addr
operator|.
name|na_domain
argument_list|,
name|na
operator|->
name|na_domain
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|NA_X25
case|:
if|if
condition|(
name|c
operator|->
name|c_addr
operator|.
name|na_dtelen
operator|!=
name|na
operator|->
name|na_dtelen
operator|||
name|bcmp
argument_list|(
name|c
operator|->
name|c_addr
operator|.
name|na_dte
argument_list|,
name|na
operator|->
name|na_dte
argument_list|,
name|na
operator|->
name|na_dtelen
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|NA_NSAP
case|:
if|if
condition|(
name|c
operator|->
name|c_addr
operator|.
name|na_addrlen
operator|!=
name|na
operator|->
name|na_addrlen
operator|||
name|bcmp
argument_list|(
name|c
operator|->
name|c_addr
operator|.
name|na_address
argument_list|,
name|na
operator|->
name|na_address
argument_list|,
name|na
operator|->
name|na_addrlen
argument_list|)
condition|)
continue|continue;
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown network type (0x%x) for community \"%s\""
argument_list|,
name|na
operator|->
name|na_stack
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|d
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|d
condition|)
block|{
name|remque
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|d
argument_list|,
name|CHead
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*
comment|TRAPS */
end_comment

begin_expr_stmt
specifier|static
name|start_trap
argument_list|()
block|{
ifdef|#
directive|ifdef
name|TCP
name|char
name|myhost
index|[
name|BUFSIZ
index|]
block|;
specifier|register
expr|struct
name|hostent
operator|*
name|hp
block|;     struct
name|type_SNMP_Message
operator|*
name|msg
block|;
specifier|register
expr|struct
name|type_SNMP_PDUs
operator|*
name|pdu
block|;
specifier|register
expr|struct
name|type_SNMP_Trap__PDU
operator|*
name|parm
block|;
if|if
condition|(
operator|(
name|msg
operator|=
operator|(
expr|struct
name|type_SNMP_Message
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to initialize trap structure: out of memory"
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|msg
condition|)
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|msg
operator|->
name|version
operator|=
name|int_SNMP_version_version__1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|pdu
operator|=
operator|(
expr|struct
name|type_SNMP_PDUs
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|pdu
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
end_if

begin_expr_stmt
name|msg
operator|->
name|data
operator|=
name|pdu
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pdu
operator|->
name|offset
operator|=
name|type_SNMP_PDUs_trap
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|parm
operator|=
operator|(
expr|struct
name|type_SNMP_Trap__PDU
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|parm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
end_if

begin_expr_stmt
name|pdu
operator|->
name|un
operator|.
name|trap
operator|=
name|parm
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myhost
argument_list|,
name|TLocalHostName
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|myhost
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
operator|&
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parm
operator|->
name|agent__addr
operator|=
name|str2qb
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: unknown host, so no traps"
argument_list|,
name|myhost
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|parm
operator|->
name|time__stamp
operator|=
operator|(
expr|struct
name|type_SNMP_TimeTicks
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|parm
operator|->
name|time__stamp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
end_if

begin_expr_stmt
name|trap
operator|=
name|msg
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMUX
end_ifdef

begin_if
if|if
condition|(
name|hp
operator|=
name|gethostbystring
argument_list|(
literal|"localhost"
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
operator|&
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|loopback_addr
operator|=
name|str2qb
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to initialize loopback address: out of memory"
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TCP
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_macro
unit|static
name|do_trap
argument_list|(
argument|generic
argument_list|,
argument|specific
argument_list|,
argument|bindings
argument_list|)
end_macro

begin_decl_stmt
name|int
name|generic
decl_stmt|,
name|specific
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type_SNMP_VarBindList
modifier|*
name|bindings
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|TCP
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_Trap__PDU
modifier|*
name|parm
decl_stmt|;
name|OT
name|ot
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|trap
operator|)
operator|==
name|NULL
condition|)
return|return;
name|parm
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|trap
expr_stmt|;
if|if
condition|(
operator|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"sysObjectID"
argument_list|)
operator|)
operator|==
name|NULLOT
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to send trap: no such object: \"%s\""
argument_list|,
literal|"sysObjectID"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|parm
operator|->
name|enterprise
operator|=
operator|(
name|OID
operator|)
name|ot
operator|->
name|ot_info
operator|)
operator|==
name|NULLOID
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unable to send trap: no value defined for object \"%s\""
argument_list|,
literal|"sysObjectID"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parm
operator|->
name|generic__trap
operator|=
name|generic
expr_stmt|;
name|parm
operator|->
name|specific__trap
operator|=
name|specific
expr_stmt|;
block|{
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"gettimeofday"
argument_list|)
expr_stmt|;
return|return;
block|}
name|parm
operator|->
name|time__stamp
operator|->
name|parm
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|my_boottime
operator|.
name|tv_sec
operator|)
operator|*
literal|100
operator|+
operator|(
operator|(
name|now
operator|.
name|tv_usec
operator|-
name|my_boottime
operator|.
name|tv_usec
operator|)
operator|/
literal|10000
operator|)
expr_stmt|;
block|}
name|parm
operator|->
name|variable__bindings
operator|=
name|bindings
expr_stmt|;
name|do_traps
argument_list|(
name|msg
argument_list|,
operator|(
name|integer
operator|)
name|generic
argument_list|,
operator|(
name|integer
operator|)
name|specific
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_expr_stmt
specifier|static
name|do_traps
argument_list|(
name|msg
argument_list|,
name|generic
argument_list|,
name|specific
argument_list|)
specifier|register
expr|struct
name|type_SNMP_Message
operator|*
name|msg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|integer
name|generic
decl_stmt|,
name|specific
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|mask
init|=
literal|1
operator|<<
literal|7
operator|-
name|generic
decl_stmt|;
specifier|register
name|struct
name|trap
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|UHead
operator|->
name|t_forw
init|;
name|t
operator|!=
name|UHead
condition|;
name|t
operator|=
name|t
operator|->
name|t_forw
control|)
block|{
specifier|register
name|struct
name|view
modifier|*
name|v
init|=
name|t
operator|->
name|t_view
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|PS
name|ps
decl_stmt|;
if|if
condition|(
name|specific
operator|==
literal|0
operator|&&
operator|!
operator|(
name|t
operator|->
name|t_generics
operator|&
name|mask
operator|)
condition|)
continue|continue;
name|msg
operator|->
name|community
operator|=
name|v
operator|->
name|v_community
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_Message
argument_list|,
name|pe
argument_list|,
literal|"Message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|dg_open
argument_list|)
operator|)
operator|==
name|NULLPS
operator|||
name|dg_setup
argument_list|(
name|ps
argument_list|,
name|udp
argument_list|,
name|MAXSNMP
argument_list|,
name|read_udp_socket
argument_list|,
name|write_udp_socket
argument_list|,
name|check_udp_socket
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULLPS
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory"
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"dg_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hack_dgram_socket
argument_list|(
name|udp
argument_list|,
operator|&
name|v
operator|->
name|v_sa
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"hack_dgram_socket(1)"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|snmpstat
operator|.
name|s_outpkts
operator|++
operator|,
name|snmpstat
operator|.
name|s_outtraps
operator|++
expr_stmt|;
block|}
comment|/* This function should always be called, regardless of whether 		   pe2ps() succeeds or fails.  (EJP) */
if|if
condition|(
name|hack_dgram_socket
argument_list|(
name|udp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"hack_dgram_socket(2)"
argument_list|)
expr_stmt|;
block|}
block|}
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
condition|)
name|ps_free
argument_list|(
name|ps
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SNMPT */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|process
parameter_list|(
name|ps
parameter_list|,
name|msg
parameter_list|,
name|na
parameter_list|,
name|size
parameter_list|)
name|PS
name|ps
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|na
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|now
decl_stmt|;
name|PE
name|pe
decl_stmt|,
name|p
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDUs
modifier|*
name|pdu
init|=
name|msg
operator|->
name|data
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|struct
name|UTCtime
name|uts
decl_stmt|;
specifier|register
name|struct
name|UTCtime
modifier|*
name|ut
init|=
operator|&
name|uts
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_Audit
modifier|*
name|au
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|version
operator|!=
name|int_SNMP_version_version__1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"badVersion: %d (%s)"
argument_list|,
name|msg
operator|->
name|version
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|pdu
operator|->
name|offset
operator|!=
name|type_SNMP_PDUs_trap
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unexpectedOperation: %d (%s)"
argument_list|,
name|pdu
operator|->
name|offset
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|pe
operator|=
name|p
operator|=
name|NULLPE
expr_stmt|;
name|au
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|p
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s (%s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|au
operator|=
operator|(
expr|struct
name|type_SNMP_Audit
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|au
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|au
operator|->
name|sizeOfEncodingWhichFollows
operator|=
name|ps_get_abs
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|au
operator|->
name|source
operator|=
name|str2qb
argument_list|(
name|source
argument_list|,
name|strlen
argument_list|(
name|source
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory for audit (%s)"
argument_list|,
name|source
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
condition|)
name|tm2ut
argument_list|(
name|tm
argument_list|,
name|ut
argument_list|)
expr_stmt|;
else|else
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"gmtime failed"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ut
argument_list|,
sizeof|sizeof
expr|*
name|ut
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|gent2str
argument_list|(
name|ut
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|au
operator|->
name|dateAndTime
operator|=
name|str2qb
argument_list|(
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|encode_SNMP_Audit
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|au
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_Audit
argument_list|,
name|pe
argument_list|,
literal|"Audit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|SNMP_Message
argument_list|,
name|p
argument_list|,
literal|"Message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|audit
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
operator|||
name|pe2ps
argument_list|(
name|audit
argument_list|,
name|p
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"pe2ps: %s (%s)"
argument_list|,
name|ps_error
argument_list|(
name|audit
operator|->
name|ps_errno
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ps_flush
argument_list|(
name|audit
argument_list|)
expr_stmt|;
block|}
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_SNMP_Audit: %s (%s)"
argument_list|,
name|PY_pepy
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|au
condition|)
name|free_SNMP_Audit
argument_list|(
name|au
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|pe_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNMPT */
end_comment

begin_comment
comment|/*
comment|MISCELLANY */
end_comment

begin_expr_stmt
specifier|static
name|arginit
argument_list|(
argument|vec
argument_list|)
name|char
operator|*
operator|*
name|vec
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|SNMPT
name|char
modifier|*
name|file
init|=
literal|"snmp.traps"
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCP
name|int
name|port
decl_stmt|;
name|struct
name|NSAPaddr
modifier|*
name|tcp_na
decl_stmt|;
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|X25
name|struct
name|NSAPaddr
modifier|*
name|x25_na
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|myname
operator|=
name|rindex
argument_list|(
operator|*
name|vec
argument_list|,
literal|'/'
argument_list|)
condition|)
name|myname
operator|++
expr_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|||
operator|*
name|myname
operator|==
name|NULL
condition|)
name|myname
operator|=
operator|*
name|vec
expr_stmt|;
name|isodetailor
argument_list|(
name|myname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tas
argument_list|,
sizeof|sizeof
name|tas
argument_list|)
expr_stmt|;
name|tz
operator|=
name|tas
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_TCP
operator|)
condition|)
name|tcpservice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"snmp"
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"udp/snmp: unknown service"
argument_list|)
expr_stmt|;
name|tcp_na
operator|=
name|tz
operator|->
name|ta_addrs
expr_stmt|;
name|tcp_na
operator|->
name|na_stack
operator|=
name|NA_TCP
expr_stmt|;
name|tcp_na
operator|->
name|na_community
operator|=
name|ts_comm_tcp_default
expr_stmt|;
name|tcp_na
operator|->
name|na_domain
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|tcp_na
operator|->
name|na_port
operator|=
name|sp
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|161
argument_list|)
expr_stmt|;
name|udport
operator|=
name|tcp_na
operator|->
name|na_port
expr_stmt|;
endif|#
directive|endif
name|tz
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|tz
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"snmp-trap"
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"udp/snmp-trap: unknown service"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|traport
operator|=
name|sp
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|162
argument_list|)
expr_stmt|;
else|#
directive|else
name|tcp_na
operator|->
name|na_port
operator|=
name|sp
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|162
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COTS
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|taddrs
argument_list|,
sizeof|sizeof
name|taddrs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lru
argument_list|,
sizeof|sizeof
name|lru
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|X25
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_X25
operator|)
condition|)
name|x25service
operator|=
literal|0
expr_stmt|;
name|x25_na
operator|=
name|tz
operator|->
name|ta_addrs
expr_stmt|;
name|x25_na
operator|->
name|na_stack
operator|=
name|NA_X25
expr_stmt|;
name|x25_na
operator|->
name|na_community
operator|=
name|ts_comm_x25_default
expr_stmt|;
if|if
condition|(
name|x25_local_dte
operator|&&
operator|*
name|x25_local_dte
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|x25_na
operator|->
name|na_dte
argument_list|,
name|x25_local_dte
argument_list|)
expr_stmt|;
name|x25_na
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|x25_na
operator|->
name|na_dte
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SNMPT
name|x25_na
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
literal|"03018200"
argument_list|,
operator|-
literal|1
argument_list|,
name|x25_na
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|x25_na
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
literal|"03019000"
argument_list|,
operator|-
literal|1
argument_list|,
name|x25_na
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tz
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
name|tz
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TP4
if|if
condition|(
operator|!
operator|(
name|ts_stacks
operator|&
name|TS_TP4
operator|)
condition|)
name|tp4service
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SNMPT
name|bcopy
argument_list|(
literal|"snmp"
argument_list|,
name|tz
operator|->
name|ta_selector
argument_list|,
name|tz
operator|->
name|ta_selectlen
operator|=
sizeof|sizeof
expr|"snmp"
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|bcopy
argument_list|(
literal|"snmp-trap"
argument_list|,
name|tz
operator|->
name|ta_selector
argument_list|,
name|tz
operator|->
name|ta_selectlen
operator|=
sizeof|sizeof
expr|"snmp-trap"
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tz
operator|->
name|ta_naddr
operator|=
literal|0
expr_stmt|;
name|tz
operator|++
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|vec
operator|++
init|;
name|ap
operator|=
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|ap
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
operator|||
operator|(
name|tooBig
operator|=
name|atoi
argument_list|(
name|ap
argument_list|)
operator|)
operator|<=
literal|128
comment|/* MAXSNMP */
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -b size"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
continue|continue;
ifndef|#
directive|ifndef
name|SNMPT
case|case
literal|'s'
case|:
ifdef|#
directive|ifdef
name|SMUX
name|smux_enabled
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
continue|continue;
endif|#
directive|endif
case|case
literal|'t'
case|:
name|ts_stacks
operator|=
name|TS_TCP
expr_stmt|;
name|tcpservice
operator|=
literal|1
expr_stmt|;
name|x25service
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|ts_stacks
operator|=
name|TS_X25
expr_stmt|;
name|x25service
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|tp4service
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|ts_stacks
operator|=
name|TS_TP4
expr_stmt|;
name|tp4service
operator|=
literal|1
expr_stmt|;
name|tcpservice
operator|=
name|x25service
operator|=
literal|0
expr_stmt|;
continue|continue;
ifndef|#
directive|ifndef
name|SNMPT
case|case
literal|'r'
case|:
name|rflag
operator|=
literal|1
expr_stmt|;
continue|continue;
else|#
directive|else
case|case
literal|'f'
case|:
if|if
condition|(
operator|(
name|file
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|file
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -f audit-file"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TCP
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
operator|||
operator|(
name|port
operator|=
name|atoi
argument_list|(
name|ap
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -p portno"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|tcp_na
operator|->
name|na_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|X25
comment|/* This permits listening on a specific subaddress. */
case|case
literal|'a'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -a x121address"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|x25_na
operator|->
name|na_dte
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|x25_na
operator|->
name|na_dtelen
operator|=
name|strlen
argument_list|(
name|ap
argument_list|)
expr_stmt|;
continue|continue;
comment|/* This permits listening on a specific protocol id. 		   In fact, SunLink X.25 lets you listen on a protocol 		   id mask, but let's keep it simple. */
case|case
literal|'i'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -i pid"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|x25_na
operator|->
name|na_pidlen
operator|=
name|str2sel
argument_list|(
name|ap
argument_list|,
operator|-
literal|1
argument_list|,
name|x25_na
operator|->
name|na_pid
argument_list|,
name|NPSIZE
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s: unknown switch"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [switches]"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
name|ps_len_strategy
operator|=
name|PS_LEN_LONG
expr_stmt|;
ifdef|#
directive|ifdef
name|SNMPT
name|file
operator|=
name|_isodefile
argument_list|(
name|isodelogpath
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to append to"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|audit
operator|=
name|ps_alloc
argument_list|(
name|std_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc(std_open): you lose"
argument_list|)
expr_stmt|;
if|if
condition|(
name|std_setup
argument_list|(
name|audit
argument_list|,
name|fp
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"std_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|audit
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|envinit
argument_list|()
block|{
name|int
name|i
block|,
name|sd
block|;
ifndef|#
directive|ifndef
name|SNMPT
name|char
operator|*
name|cp
block|;
endif|#
directive|endif
name|char
name|file
index|[
name|BUFSIZ
index|]
block|;
name|FILE
operator|*
name|fp
block|;
name|nbits
operator|=
name|getdtablesize
argument_list|()
block|;
if|if
condition|(
name|debug
operator|==
literal|0
operator|&&
operator|!
operator|(
name|debug
operator|=
name|isatty
argument_list|(
literal|2
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OK
case|:
break|break;
default|default:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
unit|}  	(
name|void
end_expr_stmt

begin_expr_stmt
unit|)
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sd
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|)
operator|,
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SETSID
end_ifdef

begin_if
if|if
condition|(
name|setsid
argument_list|()
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"setsid"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCNOTTY
end_ifdef

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|sd
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}     else
name|ll_dbinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_comment
comment|/* damn YP... */
end_comment

begin_for
for|for
control|(
name|sd
operator|=
literal|3
init|;
name|sd
operator|<
name|nbits
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|pgm_log
operator|->
name|ll_fd
operator|!=
name|sd
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|myname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPT
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPC
end_ifndef

begin_expr_stmt
name|cp
operator|=
literal|"snmpd.defs"
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|cp
operator|=
literal|"snmpc.defs"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|readobjects
argument_list|(
name|cp
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"readobjects: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|init_mib
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPC
end_ifndef

begin_expr_stmt
name|init_system
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Internet-standard MIB */
end_comment

begin_expr_stmt
name|init_interfaces
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_ip
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_icmp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_tcp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_udp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_clns
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* experimental CLNS group */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|init_snmp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init_view
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMUX
end_ifdef

begin_expr_stmt
name|init_smux
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|init_eval
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|readconfig
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fin_view
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fin_mib
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|start_trap
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|start_view
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|o_advise
operator|=
operator|(
name|IFP
operator|)
name|advise
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"/etc/%s.pid"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"starting"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hupser
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
unit|static
name|SFD
name|hupser
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|PE
name|p
decl_stmt|;
if|if
condition|(
name|didhup
operator|==
name|NOTOK
condition|)
block|{
name|didhup
operator|=
name|OK
expr_stmt|;
return|return;
block|}
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"sbrk=0x%x allocs=%d frees=%d most=%d"
argument_list|,
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pe_allocs
argument_list|,
name|pe_frees
argument_list|,
name|pe_most
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pe_active
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pe_link
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"active PE 0x%x (refcnt %d)"
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|p
operator|->
name|pe_refcnt
argument_list|)
expr_stmt|;
name|_vpdu
argument_list|(
name|pgm_log
argument_list|,
name|vunknown
argument_list|,
name|p
argument_list|,
name|buffer
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|CONFIG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SNMPT
end_ifndef

begin_decl_stmt
name|int
name|f_community
argument_list|()
decl_stmt|,
name|f_logging
argument_list|()
decl_stmt|,
name|f_proxy
argument_list|()
decl_stmt|,
name|f_trap
argument_list|()
decl_stmt|,
name|f_variable
argument_list|()
decl_stmt|,
name|f_view
argument_list|()
decl_stmt|,
name|f_expression
argument_list|()
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|pair
block|{
name|char
modifier|*
name|p_name
decl_stmt|;
comment|/* runcom directive */
name|IFP
name|p_handler
decl_stmt|;
comment|/* dispatch */
block|}
name|pairs
index|[]
init|=
block|{
literal|"community"
block|,
name|f_community
block|,
literal|"logging"
block|,
name|f_logging
block|,
literal|"proxy"
block|,
name|f_proxy
block|,
literal|"trap"
block|,
name|f_trap
block|,
literal|"variable"
block|,
name|f_variable
block|,
literal|"view"
block|,
name|f_view
block|,
literal|"expression"
block|,
name|f_expression
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|readconfig
argument_list|()
block|{
specifier|register
name|char
operator|*
name|cp
block|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|,
name|line
index|[
name|BUFSIZ
index|]
block|,
operator|*
name|vec
index|[
name|NVEC
operator|+
name|NSLACK
operator|+
literal|1
index|]
block|;
specifier|register
expr|struct
name|pair
operator|*
name|p
block|;     struct
name|stat
name|st
block|;
name|FILE
operator|*
name|fp
block|;
ifndef|#
directive|ifndef
name|SNMPC
name|cp
operator|=
literal|"snmpd.rc"
block|;
else|#
directive|else
name|cp
operator|=
literal|"snmpc.rc"
block|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cp
operator|=
name|isodefile
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|cp
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|rflag
operator|&&
name|getuid
argument_list|()
operator|==
literal|0
operator|&&
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|st
operator|.
name|st_uid
operator|!=
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s not owned by root"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
end_if

begin_while
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vec
argument_list|,
sizeof|sizeof
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|pairs
init|;
name|p
operator|->
name|p_name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|lexequ
argument_list|(
name|p
operator|->
name|p_name
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|p
operator|->
name|p_handler
call|)
argument_list|(
name|vec
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"malformed directive: \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|p_name
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown directive: \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_function
unit|static
name|int
name|f_logging
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|vp
decl_stmt|;
for|for
control|(
name|vp
operator|=
operator|++
name|vec
init|;
operator|*
name|vp
condition|;
name|vp
operator|++
control|)
continue|continue;
name|log_tai
argument_list|(
name|pgm_log
argument_list|,
name|vec
argument_list|,
name|vp
operator|-
name|vec
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_variable
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
ifndef|#
directive|ifndef
name|SNMPC
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"interface"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
for|for
control|(
name|vec
operator|++
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
if|if
condition|(
name|index
argument_list|(
operator|*
name|vec
argument_list|,
literal|'='
argument_list|)
condition|)
name|set_interface
argument_list|(
name|name
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
else|else
return|return
name|NOTOK
return|;
return|return
name|OK
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"snmpEnableAuthenTraps"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|vec
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"enabled"
argument_list|)
operator|==
literal|0
condition|)
name|snmpstat
operator|.
name|s_enableauthentraps
operator|=
name|TRAPS_ENABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|lexequ
argument_list|(
operator|*
name|vec
argument_list|,
literal|"disabled"
argument_list|)
operator|==
literal|0
condition|)
name|snmpstat
operator|.
name|s_enableauthentraps
operator|=
name|TRAPS_DISABLED
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|!
name|vec
index|[
literal|0
index|]
operator|||
operator|!
name|vec
index|[
literal|1
index|]
operator|||
name|vec
index|[
literal|2
index|]
condition|)
return|return
name|NOTOK
return|;
name|set_variable
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SNMPT */
end_comment

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|adios
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_FATAL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

