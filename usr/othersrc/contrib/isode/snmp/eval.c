begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* eval.c - MIB realization of the EVAL group */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/eval.c,v 7.7 91/02/22 09:43:13 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/snmp/RCS/eval.c,v 7.7 91/02/22 09:43:13 mrose Interim $  *  *  * $Log:	eval.c,v $  * Revision 7.7  91/02/22  09:43:13  mrose  * Interim 6.8  *   * Revision 7.6  91/01/13  11:05:42  mrose  * update  *   * Revision 7.5  91/01/12  21:38:32  mrose  * typo  *   * Revision 7.4  91/01/12  21:25:41  mrose  * again  *   * Revision 7.3  91/01/12  21:22:49  mrose  * update  *   * Revision 7.2  90/12/18  10:13:19  mrose  * update  *   * Revision 7.1  90/11/20  15:31:59  mrose  * update  *   * Revision 7.0  90/11/18  09:30:47  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"mib.h"
end_include

begin_comment
comment|/*
comment|FUNCTION MIB */
end_comment

begin_define
define|#
directive|define
name|NSTACK
value|10
end_define

begin_decl_stmt
specifier|static
name|integer
modifier|*
name|tos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|integer
modifier|*
name|roof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|integer
name|fstack
index|[
name|NSTACK
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXPR
value|10
end_define

begin_struct
struct|struct
name|expr
block|{
name|PStream
name|e_ps
decl_stmt|;
name|int
name|e_eval
decl_stmt|;
comment|/* exprEval */
name|char
modifier|*
name|e_expr
decl_stmt|;
comment|/* exprExpr */
name|int
name|e_size
decl_stmt|;
name|int
name|e_status
decl_stmt|;
comment|/* exprStatus */
define|#
directive|define
name|E_noError
value|0
define|#
directive|define
name|E_divide
value|1
define|#
directive|define
name|E_overflow
value|2
define|#
directive|define
name|E_underflow
value|3
define|#
directive|define
name|E_noSuchName
value|4
define|#
directive|define
name|E_notAnInteger
value|5
define|#
directive|define
name|E_other
value|6
comment|/* exprHints */
name|char
name|e_hints
index|[
literal|255
operator|+
literal|1
index|]
decl_stmt|;
struct|struct
block|{
name|char
modifier|*
name|expr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
name|e_save
struct|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|integer
name|exprNumber
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
name|exprs
index|[
name|NEXPR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|curexpr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|roofexpr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|functAdd
value|0
end_define

begin_define
define|#
directive|define
name|functSub
value|1
end_define

begin_define
define|#
directive|define
name|functMul
value|2
end_define

begin_define
define|#
directive|define
name|functDiv
value|3
end_define

begin_define
define|#
directive|define
name|functMod
value|4
end_define

begin_define
define|#
directive|define
name|functNeg
value|5
end_define

begin_define
define|#
directive|define
name|functXch
value|6
end_define

begin_define
define|#
directive|define
name|functClr
value|7
end_define

begin_define
define|#
directive|define
name|functDup
value|8
end_define

begin_define
define|#
directive|define
name|functPop
value|9
end_define

begin_define
define|#
directive|define
name|functAbs
value|10
end_define

begin_define
define|#
directive|define
name|functSgn
value|11
end_define

begin_define
define|#
directive|define
name|functMin
value|12
end_define

begin_define
define|#
directive|define
name|functAnd
value|13
end_define

begin_define
define|#
directive|define
name|functOr
value|14
end_define

begin_define
define|#
directive|define
name|functNot
value|15
end_define

begin_function
specifier|static
name|int
name|o_funct
parameter_list|(
name|oi
parameter_list|,
name|v
parameter_list|,
name|offset
parameter_list|)
name|OI
name|oi
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|ifvar
decl_stmt|;
name|integer
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
specifier|register
name|OT
name|ot
init|=
name|oi
operator|->
name|oi_type
decl_stmt|;
name|ifvar
operator|=
operator|(
name|int
operator|)
name|ot
operator|->
name|ot_info
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
if|if
condition|(
name|curexpr
operator|==
name|NULL
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
break|break;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
if|if
condition|(
name|curexpr
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
break|break;
default|default:
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
define|#
directive|define
name|get_arg
parameter_list|(
name|a
parameter_list|)
define|\
value|if (tos<= fstack + 1) { \ 	curexpr -> e_status = E_underflow; \ 	(void) strcpy (curexpr -> e_hints, "stack underflow"); \ 	return NOTOK; \     } \     (a) = *--tos;
switch|switch
condition|(
name|ifvar
condition|)
block|{
case|case
name|functAdd
case|:
case|case
name|functSub
case|:
case|case
name|functMul
case|:
case|case
name|functDiv
case|:
case|case
name|functMod
case|:
case|case
name|functXch
case|:
case|case
name|functDup
case|:
case|case
name|functMin
case|:
case|case
name|functAnd
case|:
case|case
name|functOr
case|:
name|get_arg
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|get_arg
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|functNeg
case|:
case|case
name|functPop
case|:
case|case
name|functAbs
case|:
case|case
name|functSgn
case|:
case|case
name|functNot
case|:
name|get_arg
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|functClr
case|:
name|arg1
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
undef|#
directive|undef
name|get_arg
switch|switch
condition|(
name|ifvar
condition|)
block|{
case|case
name|functAdd
case|:
name|arg1
operator|+=
name|arg2
expr_stmt|;
break|break;
case|case
name|functSub
case|:
name|arg1
operator|-=
name|arg2
expr_stmt|;
break|break;
case|case
name|functMul
case|:
name|arg1
operator|*=
name|arg2
expr_stmt|;
break|break;
case|case
name|functDiv
case|:
if|if
condition|(
name|arg2
operator|==
literal|0
condition|)
block|{
name|curexpr
operator|->
name|e_status
operator|=
name|E_divide
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|curexpr
operator|->
name|e_hints
argument_list|,
literal|"division by zero"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|arg1
operator|/=
name|arg2
expr_stmt|;
break|break;
case|case
name|functMod
case|:
if|if
condition|(
name|arg2
operator|==
literal|0
condition|)
block|{
name|curexpr
operator|->
name|e_status
operator|=
name|E_divide
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|curexpr
operator|->
name|e_hints
argument_list|,
literal|"modulus by zero"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|arg1
operator|%=
name|arg2
expr_stmt|;
break|break;
case|case
name|functNeg
case|:
name|arg1
operator|=
operator|-
name|arg1
expr_stmt|;
break|break;
case|case
name|functXch
case|:
operator|*
name|tos
operator|++
operator|=
name|arg2
expr_stmt|;
break|break;
case|case
name|functClr
case|:
name|tos
operator|=
name|fstack
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|functDup
case|:
operator|*
name|tos
operator|++
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|functPop
case|:
name|arg1
operator|=
name|tos
operator|<=
name|fstack
condition|?
literal|0
else|:
operator|*
operator|--
name|tos
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|functAbs
case|:
if|if
condition|(
name|arg1
operator|<
literal|0
condition|)
name|arg1
operator|=
operator|-
name|arg1
expr_stmt|;
break|break;
case|case
name|functSgn
case|:
name|arg1
operator|=
name|arg1
operator|>
literal|0
condition|?
literal|1
else|:
name|arg1
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|functMin
case|:
if|if
condition|(
name|arg2
operator|<
name|arg1
condition|)
name|arg1
operator|=
name|arg2
expr_stmt|;
break|break;
case|case
name|functAnd
case|:
name|arg1
operator|&=
name|arg2
expr_stmt|;
break|break;
case|case
name|functOr
case|:
name|arg1
operator||=
name|arg2
expr_stmt|;
break|break;
case|case
name|functNot
case|:
name|arg1
operator|=
operator|!
name|arg1
expr_stmt|;
break|break;
default|default:
return|return
name|int_SNMP_error__status_noSuchName
return|;
block|}
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|arg1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* assumes that exprEval occurs first in variable-bindings of get... */
end_comment

begin_define
define|#
directive|define
name|exprIndex
value|0
end_define

begin_define
define|#
directive|define
name|exprEval
value|1
end_define

begin_define
define|#
directive|define
name|exprExpr
value|2
end_define

begin_define
define|#
directive|define
name|exprStatus
value|3
end_define

begin_define
define|#
directive|define
name|exprHints
value|4
end_define

begin_function
specifier|static
name|int
name|o_expressions
parameter_list|(
name|oi
parameter_list|,
name|v
parameter_list|,
name|offset
parameter_list|)
name|OI
name|oi
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|ifnum
decl_stmt|,
name|ifvar
decl_stmt|;
specifier|register
name|OID
name|oid
init|=
name|oi
operator|->
name|oi_name
decl_stmt|;
specifier|register
name|OT
name|ot
init|=
name|oi
operator|->
name|oi_type
decl_stmt|;
specifier|register
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|ifvar
operator|=
operator|(
name|int
operator|)
name|ot
operator|->
name|ot_info
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_get__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|!=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|+
literal|1
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
if|if
condition|(
operator|(
name|ifnum
operator|=
name|oid
operator|->
name|oid_elements
index|[
name|oid
operator|->
name|oid_nelem
operator|-
literal|1
index|]
operator|)
operator|==
literal|0
operator|||
name|ifnum
operator|>
name|exprNumber
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
if|if
condition|(
operator|(
name|e
operator|=
name|exprs
operator|+
name|ifnum
operator|-
literal|1
operator|)
operator|->
name|e_expr
operator|==
name|NULL
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
break|break;
case|case
name|type_SNMP_PDUs_get__next__request
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|==
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
condition|)
block|{
name|OID
name|new
decl_stmt|;
for|for
control|(
name|e
operator|=
name|exprs
init|;
name|e
operator|<
name|roofexpr
condition|;
name|e
operator|++
control|)
if|if
condition|(
name|e
operator|->
name|e_expr
condition|)
break|break;
if|if
condition|(
name|e
operator|>=
name|roofexpr
condition|)
return|return
name|NOTOK
return|;
name|ifnum
operator|=
operator|(
name|e
operator|-
name|exprs
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|oid_extend
argument_list|(
name|oid
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
return|return
name|NOTOK
return|;
name|new
operator|->
name|oid_elements
index|[
name|new
operator|->
name|oid_nelem
operator|-
literal|1
index|]
operator|=
name|ifnum
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|name
condition|)
name|free_SNMP_ObjectName
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
decl_stmt|;
if|if
condition|(
operator|(
name|ifnum
operator|=
name|oid
operator|->
name|oid_elements
index|[
name|i
index|]
operator|)
operator|>=
name|NEXPR
condition|)
return|return
name|NOTOK
return|;
for|for
control|(
name|e
operator|=
name|exprs
operator|+
name|ifnum
init|;
name|e
operator|<
name|roofexpr
condition|;
name|e
operator|++
control|)
if|if
condition|(
name|e
operator|->
name|e_expr
condition|)
break|break;
if|if
condition|(
name|e
operator|>=
name|roofexpr
condition|)
return|return
name|NOTOK
return|;
name|ifnum
operator|=
operator|(
name|e
operator|-
name|exprs
operator|)
operator|+
literal|1
expr_stmt|;
name|oid
operator|->
name|oid_elements
index|[
name|i
index|]
operator|=
name|ifnum
expr_stmt|;
name|oid
operator|->
name|oid_nelem
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
switch|switch
condition|(
name|ifvar
condition|)
block|{
case|case
name|exprIndex
case|:
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|ifnum
argument_list|)
return|;
case|case
name|exprEval
case|:
name|e
operator|->
name|e_eval
operator|=
literal|0
operator|,
name|e
operator|->
name|e_status
operator|=
name|E_noError
operator|,
name|e
operator|->
name|e_hints
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|eval_expr
argument_list|(
name|curexpr
operator|=
name|e
argument_list|)
expr_stmt|;
name|curexpr
operator|=
name|NULL
expr_stmt|;
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|e
operator|->
name|e_eval
argument_list|)
return|;
case|case
name|exprExpr
case|:
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|e
operator|->
name|e_expr
argument_list|,
name|e
operator|->
name|e_size
argument_list|)
return|;
case|case
name|exprStatus
case|:
return|return
name|o_integer
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|e
operator|->
name|e_status
argument_list|)
return|;
case|case
name|exprHints
case|:
return|return
name|o_string
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|e
operator|->
name|e_hints
argument_list|,
name|strlen
argument_list|(
name|e
operator|->
name|e_hints
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|int_SNMP_error__status_noSuchName
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|eval_expr
parameter_list|(
name|e
parameter_list|)
specifier|register
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
block|{
name|PElementClass
name|class
decl_stmt|;
name|PElementForm
name|form
decl_stmt|;
name|PElementID
name|id
decl_stmt|;
name|PElementLen
name|len
decl_stmt|;
name|PS
name|ps
init|=
operator|&
name|e
operator|->
name|e_ps
decl_stmt|;
name|roof
operator|=
operator|(
name|tos
operator|=
name|fstack
operator|)
operator|+
operator|(
sizeof|sizeof
name|fstack
operator|/
sizeof|sizeof
name|fstack
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|tos
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ps
argument_list|,
sizeof|sizeof
expr|*
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_open
argument_list|(
name|ps
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"str_open failed"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|str_setup
argument_list|(
name|ps
argument_list|,
name|e
operator|->
name|e_expr
argument_list|,
name|e
operator|->
name|e_size
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"str_setup failed: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|read_tl
argument_list|(
name|e
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|form
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|PE_ID
argument_list|(
name|class
argument_list|,
name|id
argument_list|)
operator|!=
name|PE_ID
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_CONS_SEQ
argument_list|)
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"unexpected TAG: %d/%d"
argument_list|,
name|class
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
while|while
condition|(
name|ps
operator|->
name|ps_cnt
operator|>
literal|0
condition|)
block|{
name|integer
name|i
decl_stmt|;
name|OID
name|oid
decl_stmt|;
if|if
condition|(
name|read_tl
argument_list|(
name|e
argument_list|,
operator|&
name|class
argument_list|,
operator|&
name|form
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
switch|switch
condition|(
name|PE_ID
argument_list|(
name|class
argument_list|,
name|id
argument_list|)
condition|)
block|{
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_PRIM_INT
argument_list|)
case|:
if|if
condition|(
name|read_long
argument_list|(
name|e
argument_list|,
name|ps
operator|->
name|ps_ptr
argument_list|,
name|len
argument_list|,
name|form
argument_list|,
operator|&
name|i
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
break|break;
case|case
name|PE_ID
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_PRIM_OID
argument_list|)
case|:
if|if
condition|(
name|read_oid
argument_list|(
name|e
argument_list|,
name|ps
operator|->
name|ps_ptr
argument_list|,
name|len
argument_list|,
name|form
argument_list|,
operator|&
name|oid
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|get_var_value
argument_list|(
name|e
argument_list|,
name|oid
argument_list|,
operator|&
name|i
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
break|break;
default|default:
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"unexpected TAG: %d/%d"
argument_list|,
name|class
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ps
operator|->
name|ps_ptr
operator|+=
name|len
operator|,
name|ps
operator|->
name|ps_cnt
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|tos
operator|<
name|roof
condition|)
operator|*
name|tos
operator|++
operator|=
name|i
expr_stmt|;
else|else
block|{
name|e
operator|->
name|e_status
operator|=
name|E_overflow
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"stack overflow"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
if|if
condition|(
name|tos
operator|<=
name|fstack
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_underflow
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"stack underflow"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|e
operator|->
name|e_eval
operator|=
operator|*
operator|--
name|tos
expr_stmt|;
if|if
condition|(
name|tos
operator|>
name|fstack
operator|+
literal|1
operator|&&
name|e
operator|->
name|e_hints
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"%d items left on stack after evaluating expression"
argument_list|,
name|tos
operator|-
name|fstack
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_tl
parameter_list|(
name|e
parameter_list|,
name|class
parameter_list|,
name|form
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|PElementClass
modifier|*
name|class
decl_stmt|;
name|PElementForm
modifier|*
name|form
decl_stmt|;
name|PElementID
modifier|*
name|id
decl_stmt|;
name|PElementLen
modifier|*
name|len
decl_stmt|;
block|{
name|PS
name|ps
init|=
operator|&
name|e
operator|->
name|e_ps
decl_stmt|;
if|if
condition|(
name|ps_read_id
argument_list|(
name|ps
argument_list|,
literal|0
argument_list|,
name|class
argument_list|,
name|form
argument_list|,
name|id
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"error reading TAG info: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|ps_read_len
argument_list|(
name|ps
argument_list|,
name|len
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"error reading LEN info: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_long
parameter_list|(
name|e
parameter_list|,
name|base
parameter_list|,
name|len
parameter_list|,
name|form
parameter_list|,
name|result
parameter_list|)
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|len
decl_stmt|;
name|PElementForm
name|form
decl_stmt|;
name|integer
modifier|*
name|result
decl_stmt|;
block|{
specifier|register
name|integer
name|i
decl_stmt|;
specifier|register
name|PElementData
name|dp
decl_stmt|,
name|ep
decl_stmt|;
if|if
condition|(
name|form
operator|!=
name|PE_FORM_PRIM
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"integer: %s"
argument_list|,
name|pe_error
argument_list|(
name|PE_ERR_PRIM
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"integer: %s"
argument_list|,
name|pe_error
argument_list|(
name|PE_ERR_OVER
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|i
operator|=
operator|(
operator|*
operator|(
name|dp
operator|=
operator|(
name|PElementData
operator|)
name|base
operator|)
operator|&
literal|0x80
operator|)
condition|?
operator|(
operator|-
literal|1
operator|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|dp
operator|+
name|len
init|;
name|dp
operator|<
name|ep
condition|;
control|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
name|dp
operator|++
operator|&
literal|0xff
operator|)
expr_stmt|;
operator|*
name|result
operator|=
name|i
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_oid
parameter_list|(
name|e
parameter_list|,
name|base
parameter_list|,
name|len
parameter_list|,
name|form
parameter_list|,
name|ox
parameter_list|)
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|len
decl_stmt|;
name|PElementForm
name|form
decl_stmt|;
name|OID
modifier|*
name|ox
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
specifier|register
name|PElementData
name|dp
decl_stmt|,
name|ep
decl_stmt|;
specifier|static
name|OIDentifier
name|oid
decl_stmt|;
specifier|register
name|OID
name|o
init|=
operator|&
name|oid
decl_stmt|;
if|if
condition|(
name|form
operator|!=
name|PE_FORM_PRIM
operator|||
operator|(
name|dp
operator|=
operator|(
name|PElementData
operator|)
name|base
operator|)
operator|==
name|NULLPED
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"oid: %s"
argument_list|,
name|pe_error
argument_list|(
name|PE_ERR_PRIM
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ep
operator|=
name|dp
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|oid_elements
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|o
operator|->
name|oid_elements
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|dp
operator|<
name|ep
condition|;
name|i
operator|++
control|)
block|{
comment|/* another whacko OSI encoding... */
if|if
condition|(
operator|*
name|dp
operator|==
literal|0x80
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"oid: %s"
argument_list|,
name|pe_error
argument_list|(
name|PE_ERR_OID
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
while|while
condition|(
operator|*
name|dp
operator|++
operator|&
literal|0x80
condition|)
if|if
condition|(
name|dp
operator|>
name|ep
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"oid: %s"
argument_list|,
name|pe_error
argument_list|(
name|PE_ERR_OID
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
if|if
condition|(
operator|(
name|ip
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|ip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"oid: %s"
argument_list|,
name|pe_error
argument_list|(
name|PE_ERR_NMEM
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|o
operator|->
name|oid_elements
operator|=
name|ip
operator|,
name|o
operator|->
name|oid_nelem
operator|=
name|i
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|(
name|PElementData
operator|)
name|base
init|;
name|dp
operator|<
name|ep
condition|;
control|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|i
operator|<<=
literal|7
expr_stmt|;
name|i
operator||=
operator|*
name|dp
operator|&
literal|0x7f
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|dp
operator|++
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
name|ip
operator|!=
name|o
operator|->
name|oid_elements
condition|)
operator|*
name|ip
operator|++
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|40
condition|)
operator|*
name|ip
operator|++
operator|=
literal|0
operator|,
operator|*
name|ip
operator|++
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|80
condition|)
operator|*
name|ip
operator|++
operator|=
literal|1
operator|,
operator|*
name|ip
operator|++
operator|=
name|i
operator|-
literal|40
expr_stmt|;
else|else
operator|*
name|ip
operator|++
operator|=
literal|2
operator|,
operator|*
name|ip
operator|++
operator|=
name|i
operator|-
literal|80
expr_stmt|;
block|}
operator|*
name|ox
operator|=
name|o
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|get_var_value
parameter_list|(
name|e
parameter_list|,
name|oid
parameter_list|,
name|i
parameter_list|)
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|OID
name|oid
decl_stmt|;
name|integer
modifier|*
name|i
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|integer
modifier|*
name|result
decl_stmt|;
name|OI
name|oi
decl_stmt|;
name|OS
name|os
decl_stmt|;
name|OT
name|ot
decl_stmt|;
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|oi
operator|=
name|name2inst
argument_list|(
name|oid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_noSuchName
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"variable %s unknown"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|ot
operator|=
name|oi
operator|->
name|oi_type
operator|)
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_noSuchName
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"no object type for variable %s"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|os
operator|=
name|ot
operator|->
name|ot_syntax
operator|)
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_noSuchName
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"no object syntax for variable %s"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|!
name|os
operator|->
name|os_data2
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_notAnInteger
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"variable %s is not integer-valued"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|ot
operator|->
name|ot_getfnx
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_noSuchName
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"no get method for variable %s"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|type_SNMP_VarBind
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|v
operator|->
name|name
operator|=
name|oid_cpy
argument_list|(
name|oid
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|v
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|v
condition|)
name|free_SNMP_VarBind
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
call|(
modifier|*
name|ot
operator|->
name|ot_getfnx
call|)
argument_list|(
name|oi
argument_list|,
name|v
argument_list|,
name|type_SNMP_PDUs_get__request
argument_list|)
operator|)
operator|!=
name|int_SNMP_error__status_noError
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_hints
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"%s: %d"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|losing
label|:
empty_stmt|;
name|free_SNMP_VarBind
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
call|(
modifier|*
name|os
operator|->
name|os_decode
call|)
argument_list|(
operator|&
name|result
argument_list|,
name|v
operator|->
name|value
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
name|E_other
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|e
operator|->
name|e_hints
argument_list|,
literal|"%s: decoding error!"
argument_list|,
name|oid2ode
argument_list|(
name|oid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|losing
goto|;
block|}
operator|*
name|i
operator|=
operator|*
name|result
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
argument_list|)
expr_stmt|;
name|free_SNMP_VarBind
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|s_expressions
parameter_list|(
name|oi
parameter_list|,
name|v
parameter_list|,
name|offset
parameter_list|)
name|OI
name|oi
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|ifnum
ifndef|#
directive|ifndef
name|lint
decl_stmt|,
name|ifvar
endif|#
directive|endif
decl_stmt|;
specifier|register
name|OID
name|oid
init|=
name|oi
operator|->
name|oi_name
decl_stmt|;
specifier|register
name|OT
name|ot
init|=
name|oi
operator|->
name|oi_type
decl_stmt|;
specifier|register
name|OS
name|os
init|=
name|ot
operator|->
name|ot_syntax
decl_stmt|;
specifier|register
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|struct
name|qbuf
modifier|*
name|qb
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|ifvar
operator|=
operator|(
name|int
operator|)
name|ot
operator|->
name|ot_info
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_set__request
case|:
case|case
name|type_SNMP_PDUs_commit
case|:
case|case
name|type_SNMP_PDUs_rollback
case|:
if|if
condition|(
name|oid
operator|->
name|oid_nelem
operator|!=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|+
literal|1
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
if|if
condition|(
operator|(
name|ifnum
operator|=
name|oid
operator|->
name|oid_elements
index|[
name|oid
operator|->
name|oid_nelem
operator|-
literal|1
index|]
operator|)
operator|==
literal|0
operator|||
name|ifnum
operator|>
name|exprNumber
operator|+
literal|1
condition|)
return|return
name|int_SNMP_error__status_noSuchName
return|;
name|e
operator|=
name|exprs
operator|+
name|ifnum
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
if|if
condition|(
name|os
operator|==
name|NULLOS
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"no syntax defined for object \"%s\""
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|)
expr_stmt|;
return|return
name|int_SNMP_error__status_genErr
return|;
block|}
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
name|type_SNMP_PDUs_set__request
case|:
if|if
condition|(
name|e
operator|->
name|e_save
operator|.
name|expr
condition|)
name|free
argument_list|(
name|e
operator|->
name|e_save
operator|.
name|expr
argument_list|)
operator|,
name|e
operator|->
name|e_save
operator|.
name|expr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|os
operator|->
name|os_decode
call|)
argument_list|(
operator|(
name|caddr_t
operator|*
operator|)
operator|&
name|qb
argument_list|,
name|v
operator|->
name|value
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|int_SNMP_error__status_badValue
return|;
name|e
operator|->
name|e_save
operator|.
name|expr
operator|=
name|qb2str
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_save
operator|.
name|size
operator|=
name|qb
operator|->
name|qb_len
expr_stmt|;
call|(
modifier|*
name|os
operator|->
name|os_free
call|)
argument_list|(
name|qb
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_save
operator|.
name|expr
operator|==
name|NULL
condition|)
return|return
name|int_SNMP_error__status_genErr
return|;
if|if
condition|(
name|e
operator|->
name|e_save
operator|.
name|size
operator|==
literal|0
condition|)
name|free
argument_list|(
name|e
operator|->
name|e_save
operator|.
name|expr
argument_list|)
operator|,
name|e
operator|->
name|e_save
operator|.
name|expr
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|type_SNMP_PDUs_commit
case|:
if|if
condition|(
name|e
operator|->
name|e_expr
condition|)
name|free
argument_list|(
name|e
operator|->
name|e_expr
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_expr
operator|=
name|e
operator|->
name|e_save
operator|.
name|expr
operator|,
name|e
operator|->
name|e_save
operator|.
name|expr
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_size
operator|=
name|e
operator|->
name|e_save
operator|.
name|size
expr_stmt|;
for|for
control|(
name|e
operator|=
name|exprs
operator|+
name|NEXPR
operator|-
literal|1
init|;
name|e
operator|>=
name|exprs
condition|;
name|e
operator|--
control|)
if|if
condition|(
name|e
operator|->
name|e_expr
condition|)
break|break;
name|exprNumber
operator|=
operator|(
name|e
operator|-
name|exprs
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|type_SNMP_PDUs_rollback
case|:
if|if
condition|(
name|e
operator|->
name|e_save
operator|.
name|expr
condition|)
name|free
argument_list|(
name|e
operator|->
name|e_save
operator|.
name|expr
argument_list|)
operator|,
name|e
operator|->
name|e_save
operator|.
name|expr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
return|return
name|int_SNMP_error__status_noError
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|init_eval
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|OT
name|ot
decl_stmt|;
name|roof
operator|=
operator|(
name|tos
operator|=
name|fstack
operator|)
operator|+
operator|(
sizeof|sizeof
name|fstack
operator|/
sizeof|sizeof
name|fstack
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|roofexpr
operator|=
name|exprs
operator|+
name|NEXPR
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|exprs
argument_list|,
sizeof|sizeof
name|exprs
argument_list|)
expr_stmt|;
block|{
name|OS
name|os
decl_stmt|;
if|if
condition|(
name|os
operator|=
name|text2syn
argument_list|(
literal|"INTEGER"
argument_list|)
condition|)
name|os
operator|->
name|os_data2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|os
operator|=
name|text2syn
argument_list|(
literal|"Counter"
argument_list|)
condition|)
name|os
operator|->
name|os_data2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|os
operator|=
name|text2syn
argument_list|(
literal|"Gauge"
argument_list|)
condition|)
name|os
operator|->
name|os_data2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|os
operator|=
name|text2syn
argument_list|(
literal|"TimeTicks"
argument_list|)
condition|)
name|os
operator|->
name|os_data2
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functAdd"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functAdd
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functSub"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functSub
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functMul"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functMul
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functDiv"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functDiv
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functMod"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functMod
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functNeg"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functNeg
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functXch"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functXch
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functClr"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functClr
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functDup"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functDup
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functPop"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functPop
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functAbs"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functAbs
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functSgn"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functSgn
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functMin"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functMin
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functAnd"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functAnd
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functOr"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functOr
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"functNot"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_funct
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|functNot
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"exprNumber"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_generic
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|exprNumber
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"exprIndex"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_expressions
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|exprIndex
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"exprEval"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_expressions
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|exprEval
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"exprExpr"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_expressions
operator|,
name|ot
operator|->
name|ot_setfnx
operator|=
name|s_expressions
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|exprExpr
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"exprStatus"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_expressions
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|exprStatus
expr_stmt|;
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"exprHints"
argument_list|)
condition|)
name|ot
operator|->
name|ot_getfnx
operator|=
name|o_expressions
operator|,
name|ot
operator|->
name|ot_info
operator|=
operator|(
name|caddr_t
operator|)
name|exprHints
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_expression
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|PS
name|ps
decl_stmt|;
name|vec
operator|++
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|*
name|vec
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|invalid
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"invalid expression index: %s"
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
name|NEXPR
condition|)
goto|goto
name|invalid
goto|;
name|vec
operator|++
expr_stmt|;
name|e
operator|=
name|exprs
operator|+
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_expr
condition|)
name|free
argument_list|(
name|e
operator|->
name|e_expr
argument_list|)
operator|,
name|e
operator|->
name|e_expr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_CONS
argument_list|,
name|PE_CONS_SEQ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"pe_alloc: out of memory"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|vec
operator|++
condition|)
block|{
name|OID
name|oid
decl_stmt|;
name|PE
name|p
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"bad integer-value: %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p
operator|=
name|num2prim
argument_list|(
operator|(
name|integer
operator|)
name|i
argument_list|,
name|PE_CLASS_UNIV
argument_list|,
name|PE_PRIM_INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|oid
operator|=
name|text2oid
argument_list|(
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"unknown variable: %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p
operator|=
name|obj2prim
argument_list|(
name|oid
argument_list|,
name|PE_CLASS_UNIV
argument_list|,
name|PE_PRIM_OID
argument_list|)
expr_stmt|;
name|oid_free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seq_add
argument_list|(
name|pe
argument_list|,
name|p
argument_list|,
name|NOTOK
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"seq_add: out of memory"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|str_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc: failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_setup
argument_list|(
name|ps
argument_list|,
name|NULLCP
argument_list|,
name|BUFSIZ
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"std_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_size
operator|=
name|ps
operator|->
name|ps_ptr
operator|-
operator|(
name|e
operator|->
name|e_expr
operator|=
name|ps
operator|->
name|ps_base
operator|)
expr_stmt|;
name|ps
operator|->
name|ps_base
operator|=
name|NULL
operator|,
name|ps
operator|->
name|ps_cnt
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|ps_ptr
operator|=
name|NULL
operator|,
name|ps
operator|->
name|ps_bufsiz
operator|=
literal|0
expr_stmt|;
name|ps_free
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|vunknown
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|exprNumber
condition|)
name|exprNumber
operator|=
name|i
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

end_unit

