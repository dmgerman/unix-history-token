begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* snmpi.c - really minimal SNMP initiator */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/snmp/RCS/snmpi.c,v 7.28 91/03/09 11:57:50 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/snmp/RCS/snmpi.c,v 7.28 91/03/09 11:57:50 mrose Exp $  *  * Contributed by NYSERNet Inc.  This work was partially supported by the  * U.S. Defense Advanced Research Projects Agency and the Rome Air Development  * Center of the U.S. Air Force Systems Command under contract number  * F30602-88-C-0016.  *  *  * $Log:	snmpi.c,v $  * Revision 7.28  91/03/09  11:57:50  mrose  * update  *   * Revision 7.27  91/02/22  09:44:34  mrose  * Interim 6.8  *   * Revision 7.26  91/01/11  15:35:28  mrose  * sets  *   * Revision 7.25  91/01/07  12:41:08  mrose  * update  *   * Revision 7.24  90/10/23  20:37:09  mrose  * update  *   * Revision 7.23  90/09/26  19:23:02  mrose  * new-mibs  *   * Revision 7.22  90/09/26  18:47:18  mrose  * more-compile  *   * Revision 7.21  90/09/26  14:57:48  mrose  * compile -f  *   * Revision 7.20  90/09/07  11:11:39  mrose  * update  *   * Revision 7.19  90/09/03  12:58:04  mrose  * update  *   * Revision 7.18  90/08/30  15:11:11  mrose  * ho-hum  *   * Revision 7.17  90/08/30  01:32:05  mrose  * update  *   * Revision 7.16  90/08/20  21:25:52  mrose  * touch-up  *   * Revision 7.15  90/08/16  17:01:13  mrose  * touch-up  *   * Revision 7.14  90/08/08  14:01:31  mrose  * stuff  *   * Revision 7.13  90/07/09  14:49:34  mrose  * sync  *   * Revision 7.12  90/06/23  18:25:14  mrose  * now  *   * Revision 7.11  90/06/23  17:01:55  mrose  * update  *   * Revision 7.10  90/05/12  17:02:09  mrose  * sync  *   * Revision 7.9  90/02/23  17:47:59  mrose  * update  *   * Revision 7.8  90/02/19  19:17:05  mrose  * again  *   * Revision 7.7  90/01/27  08:22:04  mrose  * touch-up  *   * Revision 7.6  90/01/11  18:34:43  mrose  * real-sync  *   * Revision 7.5  89/12/19  17:57:56  mrose  * touch-up  *   * Revision 7.4  89/12/19  16:18:26  mrose  * dgram  *   * Revision 7.3  89/12/12  16:13:47  mrose  * touch-up  *   * Revision 7.2  89/12/11  16:22:33  mrose  * more clts  *   * Revision 7.1  89/12/01  10:42:18  mrose  * clts  *   * Revision 7.0  89/11/23  22:23:30  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"SNMP-types.h"
end_include

begin_include
include|#
directive|include
file|"objects.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"dgram.h"
end_include

begin_include
include|#
directive|include
file|"tsap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP
end_ifdef

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|X25
end_ifdef

begin_include
include|#
directive|include
file|"x25.h"
end_include

begin_define
define|#
directive|define
name|COTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TP4
end_ifdef

begin_include
include|#
directive|include
file|"tp4.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CLTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|COTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|COTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|DATA */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|watch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
init|=
literal|"snmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|op
init|=
name|NULLVP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ontty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|armed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|intrenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interrupted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SFP
name|istat
decl_stmt|;
end_decl_stmt

begin_function_decl
name|SFD
name|intrser
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|defs
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PS
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|community
init|=
literal|"public"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|TSAPaddr
name|snmp_ta
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|snmp_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|type_SNMP_Message
modifier|*
name|new_message
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|adios
argument_list|()
decl_stmt|,
name|advise
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|dispatch
block|{
name|char
modifier|*
name|ds_name
decl_stmt|;
comment|/* command name */
name|IFP
name|ds_fnx
decl_stmt|;
comment|/* dispatch */
name|char
modifier|*
name|ds_help
decl_stmt|;
comment|/* help string */
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|dispatch
modifier|*
name|getds
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|f_audit
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_function_decl
name|int
name|f_bulk
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|f_compile
argument_list|()
decl_stmt|,
name|f_dump
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f_get
argument_list|()
decl_stmt|,
name|f_get_next
argument_list|()
decl_stmt|,
name|f_set
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f_help
argument_list|()
decl_stmt|,
name|f_quit
argument_list|()
decl_stmt|,
name|f_status
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dispatch
name|dispatches
index|[]
init|=
block|{
literal|"audit"
block|,
name|f_audit
block|,
literal|"audit traps"
block|,
ifdef|#
directive|ifdef
name|BSD42
literal|"bulk"
block|,
name|f_bulk
block|,
literal|"bulk retrieve colums from a table"
block|,
endif|#
directive|endif
literal|"compile"
block|,
name|f_compile
block|,
literal|"write compiled objects file"
block|,
literal|"dump"
block|,
name|f_dump
block|,
literal|"dump a portion of the MIB"
block|,
literal|"get"
block|,
name|f_get
block|,
literal|"perform get operation"
block|,
literal|"help"
block|,
name|f_help
block|,
literal|"print help information"
block|,
literal|"next"
block|,
name|f_get_next
block|,
literal|"perform powerful get-next operation"
block|,
literal|"quit"
block|,
name|f_quit
block|,
literal|"terminate program"
block|,
literal|"set"
block|,
name|f_set
block|,
literal|"perform set operation"
block|,
literal|"status"
block|,
name|f_status
block|,
literal|"report status"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|helpwidth
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SYS5
end_ifndef

begin_function_decl
name|long
name|random
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|eof
decl_stmt|,
name|status
decl_stmt|,
name|vecp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|NVEC
operator|+
literal|1
index|]
decl_stmt|;
name|arginit
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
condition|)
block|{
name|vecp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|op
condition|)
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
operator|*
name|op
operator|++
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|snmploop
argument_list|(
name|vec
argument_list|,
name|NOTOK
argument_list|)
operator|==
name|NOTOK
condition|)
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|were_out_of_here
goto|;
block|}
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
name|eof
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|interrupted
operator|=
literal|0
init|;
condition|;
name|interrupted
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"%s> "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|eof
condition|)
break|break;
name|eof
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|eof
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vec
argument_list|,
sizeof|sizeof
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vecp
operator|=
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|)
operator|<
literal|1
condition|)
continue|continue;
switch|switch
condition|(
name|snmploop
argument_list|(
name|vec
argument_list|,
name|OK
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|status
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OK
case|:
default|default:
continue|continue;
case|case
name|DONE
case|:
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|were_out_of_here
label|:
empty_stmt|;
ifdef|#
directive|ifdef
name|COTS
if|if
condition|(
name|snmp_ta
operator|.
name|ta_addrs
operator|->
name|na_stack
operator|!=
name|NA_TCP
condition|)
block|{
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
ifdef|#
directive|ifdef
name|CLTS
if|if
condition|(
name|snmp_ta
operator|.
name|ta_addrs
operator|->
name|na_stack
operator|!=
name|NA_NSAP
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|TDiscRequest
argument_list|(
name|sd
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
operator|&
name|tds
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|snmploop
parameter_list|(
name|vec
parameter_list|,
name|error
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
name|int
name|error
decl_stmt|;
block|{
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
name|getds
argument_list|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
condition|?
operator|*
name|vec
else|:
literal|"help"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|error
return|;
switch|switch
condition|(
call|(
modifier|*
name|ds
operator|->
name|ds_fnx
call|)
argument_list|(
name|vec
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|error
return|;
case|case
name|OK
case|:
default|default:
return|return
name|OK
return|;
case|case
name|DONE
case|:
return|return
name|DONE
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|dispatch
modifier|*
name|getds
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|longest
decl_stmt|,
name|nmatches
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|p
operator|=
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|name
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
return|return
name|ds
return|;
if|if
condition|(
operator|*
name|q
operator|==
name|NULL
condition|)
if|if
condition|(
name|q
operator|-
name|name
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|name
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|fs
operator|=
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|name
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|nmatches
condition|)
block|{
case|case
literal|0
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown operation \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|1
case|:
return|return
name|fs
return|;
default|default:
for|for
control|(
name|ds
operator|=
name|dispatches
operator|,
name|p
operator|=
name|buffer
init|;
name|q
operator|=
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|name
argument_list|,
name|longest
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s \"%s\""
argument_list|,
name|p
operator|!=
name|buffer
condition|?
literal|","
else|:
literal|""
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ambiguous operation, it could be one of:%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|OPERATIONS */
end_comment

begin_function
specifier|static
name|int
name|f_audit
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|follow
decl_stmt|,
name|forever
decl_stmt|,
name|i
decl_stmt|;
name|long
name|longtimeago
decl_stmt|,
name|now
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|PE
name|pe
decl_stmt|,
name|p
decl_stmt|;
name|PS
name|ps2
decl_stmt|;
name|struct
name|type_SNMP_Audit
modifier|*
name|au
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|file
operator|=
literal|"snmp.traps"
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"audit [-f | -N | +N] [file]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    audit trap sink\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        -f:   endless loop\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        -N:   last N traps\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        +N:   first N traps\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        file: trap file (default %s)\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|follow
operator|=
name|forever
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|cp
operator|=
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
name|forever
operator|++
operator|,
name|follow
operator|=
literal|0
expr_stmt|;
else|else
name|follow
operator|=
operator|-
name|atoi
argument_list|(
operator|++
name|cp
argument_list|)
operator|,
name|forever
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|follow
operator|=
name|atoi
argument_list|(
operator|++
name|cp
argument_list|)
operator|,
name|forever
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|file
operator|=
name|cp
expr_stmt|;
break|break;
block|}
name|file
operator|=
name|_isodefile
argument_list|(
name|isodelogpath
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|file
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|pe
operator|=
name|p
operator|=
name|NULLPE
operator|,
name|au
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ps2
operator|=
name|ps_alloc
argument_list|(
name|std_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc(std_open): you lose"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|std_setup
argument_list|(
name|ps2
argument_list|,
name|fp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"std_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps2
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|longtimeago
operator|=
name|now
operator|-
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
expr_stmt|;
if|if
condition|(
name|follow
operator|<
literal|0
condition|)
block|{
specifier|register
name|long
name|offset
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|long
modifier|*
name|opp
decl_stmt|;
name|follow
operator|=
operator|-
name|follow
expr_stmt|;
if|if
condition|(
operator|(
name|opp
operator|=
operator|(
name|long
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|follow
argument_list|,
sizeof|sizeof
expr|*
name|opp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|lp
operator|=
name|opp
operator|)
operator|+
name|follow
init|;
name|lp
operator|<
name|ep
condition|;
name|lp
operator|++
control|)
operator|*
name|lp
operator|=
name|offset
expr_stmt|;
name|lp
operator|=
name|opp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps2
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
break|break;
if|if
condition|(
name|decode_SNMP_Audit
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|au
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|bad_audit
goto|;
name|fseek
argument_list|(
name|fp
argument_list|,
operator|(
name|long
operator|)
name|au
operator|->
name|sizeOfEncodingWhichFollows
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_SNMP_Audit
argument_list|(
name|au
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|lp
operator|>=
name|ep
condition|)
name|lp
operator|=
name|opp
expr_stmt|;
name|offset
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fp
argument_list|,
operator|*
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opp
argument_list|)
expr_stmt|;
name|follow
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|long
name|mtime
decl_stmt|;
name|UTC
name|ut
decl_stmt|;
if|if
condition|(
name|follow
operator|>
literal|0
operator|&&
name|i
operator|>
name|follow
condition|)
break|break;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps2
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
if|if
condition|(
name|ps2
operator|->
name|ps_errno
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ps2pe: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps2
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|forever
condition|)
block|{
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ps2
operator|->
name|ps_errno
operator|=
name|PS_ERR_NONE
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|decode_SNMP_Audit
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|au
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|bad_audit
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"decode_SNMP_Audit: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|qb2str
argument_list|(
name|au
operator|->
name|dateAndTime
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"qb2str: out of memory"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ut
operator|=
name|str2gent
argument_list|(
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ut
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"str2gent: you lose"
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtime
operator|=
name|gtime
argument_list|(
name|ut2tm
argument_list|(
name|ut
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|forever
condition|)
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|<
name|longtimeago
operator|||
name|mtime
operator|>
name|now
condition|)
name|printf
argument_list|(
literal|"%-7.7s %-4.4s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-12.12s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|qb2str
argument_list|(
name|au
operator|->
name|source
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|ps2pe
argument_list|(
name|ps2
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
if|if
condition|(
name|ps2
operator|->
name|ps_errno
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ps2pe: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps2
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|print_SNMP_Message
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
operator|==
name|NOTOK
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free_SNMP_Audit
argument_list|(
name|au
argument_list|)
operator|,
name|au
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps2
condition|)
name|ps_free
argument_list|(
name|ps2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|pe_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|au
condition|)
name|free_SNMP_Audit
argument_list|(
name|au
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_decl_stmt
name|int
name|bulk1
argument_list|()
decl_stmt|,
name|bulk2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|f_bulk
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|IFP
name|fnx
init|=
name|bulk1
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
modifier|*
name|vp
decl_stmt|;
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vb
decl_stmt|;
name|OT
name|et
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bulk [-alg1 | -alg2] columns...\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    with arguments, bulk retrieves columns from a table\n"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
while|while
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-alg1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnx
operator|=
name|bulk1
expr_stmt|;
name|vec
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-alg2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnx
operator|=
name|bulk2
expr_stmt|;
name|vec
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|vec
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
ifdef|#
directive|ifdef
name|COTS
if|if
condition|(
name|snmp_ta
operator|.
name|ta_addrs
operator|->
name|na_stack
operator|!=
name|NA_TCP
condition|)
block|{
ifdef|#
directive|ifdef
name|CLTS
if|if
condition|(
name|snmp_ta
operator|.
name|ta_addrs
operator|->
name|na_stack
operator|!=
name|NA_NSAP
condition|)
block|{
endif|#
directive|endif
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"bulk requires CL-mode transport!"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|CLTS
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
name|vp
operator|=
operator|&
name|vb
operator|,
name|vb
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|result
operator|=
name|NOTOK
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|bind
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|OT
name|ot
decl_stmt|;
if|if
condition|(
operator|(
name|ot
operator|=
name|text2obj
argument_list|(
operator|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown object \"%s\""
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|et
condition|)
block|{
specifier|register
name|OID
name|eid
init|=
name|et
operator|->
name|ot_name
decl_stmt|,
name|oid
init|=
name|ot
operator|->
name|ot_name
decl_stmt|;
if|if
condition|(
name|eid
operator|->
name|oid_nelem
operator|!=
name|oid
operator|->
name|oid_nelem
operator|-
literal|1
operator|||
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eid
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|oid
operator|->
name|oid_elements
argument_list|,
name|eid
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
argument_list|(
name|eid
operator|->
name|oid_elements
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s not in same table as previous arguments"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/*	    int	    i; */
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|--
expr_stmt|;
name|et
operator|=
name|name2obj
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
expr_stmt|;
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
operator|++
expr_stmt|;
if|if
condition|(
name|et
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to find row object for %s"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|et
operator|->
name|ot_syntax
comment|/* || (i = strlen (et -> ot_text))<= 5 		    || strcmp (et -> ot_text + i - 5, "Entry")*/
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s is not a column object"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|bind
operator|=
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bind
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|bind
operator|,
name|vp
operator|=
operator|&
name|bind
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|type_SNMP_VarBind
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bind
operator|->
name|VarBind
operator|=
name|v
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|name
operator|=
name|oid_cpy
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
operator|)
operator|==
name|NULLOID
operator|||
operator|(
name|v
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|fnx
call|)
argument_list|(
name|ps
argument_list|,
name|sd
argument_list|,
name|vb
argument_list|,
name|community
argument_list|)
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
name|out
label|:
empty_stmt|;
name|free_SNMP_VarBindList
argument_list|(
name|vb
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|access_t
index|[]
init|=
block|{
literal|"not-accessible"
block|,
literal|"read-only"
block|,
literal|"write-only"
block|,
literal|"read-write"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|status_t
index|[]
init|=
block|{
literal|"obsolete"
block|,
literal|"mandatory"
block|,
literal|"optional"
block|,
literal|"deprecated"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|f_compile
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fast
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|file
decl_stmt|;
specifier|register
name|OS
name|os
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fast
operator|=
literal|0
expr_stmt|;
name|file
operator|=
name|defs
condition|?
name|defs
else|:
literal|"./objects.defs"
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"compile [-f] [file]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    -f:   brief output (default to stdout)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    file: output file (default %s)\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
while|while
condition|(
name|cp
operator|=
operator|*
name|vec
operator|++
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fast
operator|=
literal|1
operator|,
name|file
operator|=
name|NULLCP
expr_stmt|;
continue|continue;
block|}
name|file
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|file
argument_list|,
literal|"unable to write"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|!
name|fast
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|i
operator|=
name|j
operator|=
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"ccitt"
argument_list|)
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
block|{
name|i
operator|++
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|ot
operator|->
name|ot_text
argument_list|)
operator|+
name|strlen
argument_list|(
name|sprintoid
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|+=
name|ot
operator|->
name|ot_name
operator|->
name|oid_nelem
expr_stmt|;
block|}
name|j
operator|+=
name|i
operator|<<
literal|1
operator|,
name|k
operator|+=
name|i
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"--* compiled %d %d %d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
for|for
control|(
name|ot
operator|=
name|text2obj
argument_list|(
literal|"ccitt"
argument_list|)
init|;
name|ot
condition|;
name|ot
operator|=
name|ot
operator|->
name|ot_next
control|)
block|{
if|if
condition|(
name|fast
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s=%s\n"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|,
name|sprintoid
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-20s %-20s"
argument_list|,
name|ot
operator|->
name|ot_text
argument_list|,
name|sprintoid
argument_list|(
name|ot
operator|->
name|ot_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|os
operator|=
name|ot
operator|->
name|ot_syntax
operator|)
operator|||
name|ot
operator|->
name|ot_status
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-15s %-15s %s"
argument_list|,
name|os
condition|?
name|os
operator|->
name|os_name
else|:
literal|"Aggregate"
argument_list|,
name|access_t
index|[
name|ot
operator|->
name|ot_access
operator|&
name|OT_RDWRITE
index|]
argument_list|,
name|status_t
index|[
name|ot
operator|->
name|ot_status
operator|&
name|OT_DEPRECATED
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fast
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%d objects written to %s"
argument_list|,
name|i
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_dump
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|request_id
decl_stmt|,
name|rows
decl_stmt|,
name|timing
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|nvec
index|[
literal|3
index|]
decl_stmt|;
name|OID
name|oid
decl_stmt|;
name|PE
name|pe
decl_stmt|;
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDU
modifier|*
name|parm
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
decl_stmt|;
name|struct
name|timeval
name|tvs
decl_stmt|,
name|now
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dump [object]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    with no arguments, dump entire MIB\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    with an argument, dump a portion of the MIB\n"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|*
name|vec
operator|&&
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-time"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|timing
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tvs
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
name|nvec
index|[
literal|0
index|]
operator|=
literal|"dump"
expr_stmt|;
name|nvec
index|[
literal|1
index|]
operator|=
operator|*
name|vec
condition|?
operator|*
name|vec
else|:
literal|"0.0"
expr_stmt|;
name|nvec
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
name|new_message
argument_list|(
name|type_SNMP_PDUs_get__next__request
argument_list|,
name|nvec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
name|request_id
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|->
name|request__id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|vec
condition|)
block|{
if|if
condition|(
operator|(
name|oid
operator|=
name|oid_cpy
argument_list|(
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__next__request
operator|->
name|variable__bindings
operator|->
name|VarBind
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
else|else
name|oid
operator|=
name|NULLOID
expr_stmt|;
name|rows
operator|=
literal|0
expr_stmt|;
name|again
label|:
empty_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|msg
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|watch
condition|)
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|try_again
label|:
empty_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ps2pe: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|decode_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"decode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|watch
condition|)
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|data
operator|->
name|offset
operator|!=
name|type_SNMP_PDUs_get__response
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unexpected message type %d"
argument_list|,
name|msg
operator|->
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|parm
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|)
operator|->
name|request__id
operator|!=
name|request_id
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"request-id mismatch (got %d, wanted %d)\n"
argument_list|,
name|parm
operator|->
name|request__id
argument_list|,
name|request_id
argument_list|)
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
if|if
condition|(
name|parm
operator|->
name|error__status
operator|!=
name|int_SNMP_error__status_noError
condition|)
block|{
if|if
condition|(
name|parm
operator|->
name|error__status
operator|!=
name|int_SNMP_error__status_noSuchName
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s at position %d\n"
argument_list|,
name|snmp_error
argument_list|(
name|parm
operator|->
name|error__status
argument_list|)
argument_list|,
name|parm
operator|->
name|error__index
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|vp
operator|=
name|parm
operator|->
name|variable__bindings
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
name|caddr_t
name|value
decl_stmt|;
specifier|register
name|OI
name|oi
decl_stmt|;
specifier|register
name|OS
name|os
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
init|=
name|vp
operator|->
name|VarBind
decl_stmt|;
if|if
condition|(
name|oid
operator|&&
operator|(
name|oid
operator|->
name|oid_nelem
operator|>
name|v
operator|->
name|name
operator|->
name|oid_nelem
operator|||
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oid
operator|->
name|oid_elements
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
operator|->
name|name
operator|->
name|oid_elements
argument_list|,
name|oid
operator|->
name|oid_nelem
operator|*
sizeof|sizeof
name|oid
operator|->
name|oid_elements
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|timing
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|oid2ode
argument_list|(
name|vp
operator|->
name|VarBind
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oi
operator|=
name|name2inst
argument_list|(
name|v
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|os
operator|=
name|oi
operator|->
name|oi_type
operator|->
name|ot_syntax
operator|)
operator|==
name|NULL
operator|||
call|(
modifier|*
name|os
operator|->
name|os_decode
call|)
argument_list|(
operator|&
name|value
argument_list|,
name|v
operator|->
name|value
argument_list|)
operator|==
name|NOTOK
condition|)
name|vunknown
argument_list|(
name|v
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|os
operator|->
name|os_print
call|)
argument_list|(
name|value
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|os
operator|->
name|os_free
call|)
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|rows
operator|++
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
operator|->
name|offset
operator|=
name|type_SNMP_PDUs_get__next__request
expr_stmt|;
name|request_id
operator|=
operator|++
name|parm
operator|->
name|request__id
expr_stmt|;
goto|goto
name|again
goto|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|oid
condition|)
name|oid_free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|timing
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|now
operator|.
name|tv_sec
operator|-=
name|tvs
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|.
name|tv_usec
operator|-=
name|tvs
operator|.
name|tv_usec
operator|)
operator|<
literal|0
condition|)
name|now
operator|.
name|tv_sec
operator|--
operator|,
name|now
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%d entr%s retrieved in %d.%06d seconds"
argument_list|,
name|rows
argument_list|,
name|rows
operator|!=
literal|1
condition|?
literal|"ies"
else|:
literal|"y"
argument_list|,
name|now
operator|.
name|tv_sec
argument_list|,
name|now
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_get
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|process
argument_list|(
name|new_message
argument_list|(
name|type_SNMP_PDUs_get__request
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_get_next
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|process
argument_list|(
name|new_message
argument_list|(
name|type_SNMP_PDUs_get__next__request
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_set
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|process
argument_list|(
name|new_message
argument_list|(
name|type_SNMP_PDUs_set__request
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errors
index|[]
init|=
block|{
literal|"noError"
block|,
literal|"tooBig"
block|,
literal|"noSuchName"
block|,
literal|"badValue"
block|,
literal|"readOnly"
block|,
literal|"genErr"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|snmp_error
parameter_list|(
name|i
parameter_list|)
name|integer
name|i
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|i
operator|&&
name|i
operator|<
sizeof|sizeof
name|errors
operator|/
sizeof|sizeof
name|errors
index|[
literal|0
index|]
condition|)
return|return
name|errors
index|[
name|i
index|]
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"error %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|type_SNMP_Message
modifier|*
name|new_message
parameter_list|(
name|offset
parameter_list|,
name|vec
parameter_list|)
name|int
name|offset
decl_stmt|;
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDUs
modifier|*
name|pdu
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDU
modifier|*
name|parm
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|=
operator|(
expr|struct
name|type_SNMP_Message
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|version
operator|=
name|int_SNMP_version_version__1
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|community
operator|=
name|str2qb
argument_list|(
name|community
argument_list|,
name|strlen
argument_list|(
name|community
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pdu
operator|=
operator|(
expr|struct
name|type_SNMP_PDUs
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|pdu
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
operator|=
name|pdu
expr_stmt|;
name|pdu
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* for now, always a PDU... */
if|if
condition|(
operator|(
name|parm
operator|=
operator|(
expr|struct
name|type_SNMP_PDU
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|parm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|pdu
operator|->
name|un
operator|.
name|get__request
operator|=
name|parm
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
name|parm
operator|->
name|request__id
operator|=
operator|(
operator|(
name|int
operator|)
name|random
argument_list|()
operator|)
operator|&
literal|0x7fffffff
expr_stmt|;
else|#
directive|else
name|parm
operator|->
name|request__id
operator|=
operator|(
operator|(
name|int
operator|)
name|rand
argument_list|()
operator|)
operator|&
literal|0x7fffffff
expr_stmt|;
endif|#
directive|endif
name|vp
operator|=
operator|&
name|parm
operator|->
name|variable__bindings
expr_stmt|;
for|for
control|(
name|vec
operator|++
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|bind
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|bind
operator|=
operator|(
expr|struct
name|type_SNMP_VarBindList
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|bind
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|bind
operator|,
name|vp
operator|=
operator|&
name|bind
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
operator|(
expr|struct
name|type_SNMP_VarBind
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bind
operator|->
name|VarBind
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|get_ava
argument_list|(
name|v
argument_list|,
operator|*
name|vec
argument_list|,
name|offset
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|msg
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|get_ava
parameter_list|(
name|v
parameter_list|,
name|ava
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|ava
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|caddr_t
name|value
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|OI
name|oi
decl_stmt|;
specifier|register
name|OT
name|ot
decl_stmt|;
specifier|register
name|OS
name|os
decl_stmt|;
name|OID
name|oid
decl_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|ava
argument_list|,
literal|'='
argument_list|)
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
name|type_SNMP_PDUs_set__request
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"value unnecessary for get operation"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
name|type_SNMP_PDUs_set__request
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"need variable=value for set operation"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|oi
operator|=
name|text2inst
argument_list|(
name|ava
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|||
operator|(
name|oid
operator|=
name|text2oid
argument_list|(
name|ava
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown variable \"%s\""
argument_list|,
name|ava
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ot
operator|=
name|NULLOT
expr_stmt|;
block|}
else|else
name|ot
operator|=
name|oi
operator|->
name|oi_type
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|->
name|name
operator|=
name|oid_cpy
argument_list|(
name|oi
condition|?
name|oi
operator|->
name|oi_name
else|:
name|oid
argument_list|)
operator|)
operator|==
name|NULLOID
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|value
operator|=
name|pe_alloc
argument_list|(
name|PE_CLASS_UNIV
argument_list|,
name|PE_FORM_PRIM
argument_list|,
name|PE_PRIM_NULL
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|os
operator|=
name|ot
operator|->
name|ot_syntax
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no syntax defined for object \"%s\""
argument_list|,
name|ava
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
call|(
modifier|*
name|os
operator|->
name|os_parse
call|)
argument_list|(
operator|&
name|value
argument_list|,
name|cp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid value for variable \"%s\": \"%s\""
argument_list|,
name|ava
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|result
operator|=
call|(
modifier|*
name|os
operator|->
name|os_encode
call|)
argument_list|(
name|value
argument_list|,
operator|&
name|v
operator|->
name|value
argument_list|)
expr_stmt|;
call|(
modifier|*
name|os
operator|->
name|os_free
call|)
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"encoding error for variable \"%s\""
argument_list|,
name|ava
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
if|if
condition|(
name|oi
operator|==
name|NULL
condition|)
name|oid_free
argument_list|(
name|oid
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|process
parameter_list|(
name|msg
parameter_list|)
name|struct
name|type_SNMP_Message
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|request_id
decl_stmt|;
name|PE
name|pe
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_PDU
modifier|*
name|parm
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBindList
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
name|request_id
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__request
operator|->
name|request__id
expr_stmt|;
if|if
condition|(
name|encode_SNMP_Message
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
name|msg
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|watch
condition|)
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"encode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|try_again
label|:
empty_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"ps2pe: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|decode_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|msg
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"decode_SNMP_Message: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|watch
condition|)
operator|(
name|void
operator|)
name|print_SNMP_Message
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|data
operator|->
name|offset
operator|!=
name|type_SNMP_PDUs_get__response
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unexpected message type %d"
argument_list|,
name|msg
operator|->
name|data
operator|->
name|offset
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|parm
operator|=
name|msg
operator|->
name|data
operator|->
name|un
operator|.
name|get__response
operator|)
operator|->
name|request__id
operator|!=
name|request_id
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"request-id mismatch (got %d, wanted %d)\n"
argument_list|,
name|parm
operator|->
name|request__id
argument_list|,
name|request_id
argument_list|)
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
if|if
condition|(
name|parm
operator|->
name|error__status
operator|!=
name|int_SNMP_error__status_noError
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s at position %d\n"
argument_list|,
name|snmp_error
argument_list|(
name|parm
operator|->
name|error__status
argument_list|)
argument_list|,
name|parm
operator|->
name|error__index
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|vp
operator|=
name|parm
operator|->
name|variable__bindings
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|next
control|)
block|{
name|caddr_t
name|value
decl_stmt|;
specifier|register
name|OI
name|oi
decl_stmt|;
specifier|register
name|OS
name|os
decl_stmt|;
specifier|register
name|struct
name|type_SNMP_VarBind
modifier|*
name|v
init|=
name|vp
operator|->
name|VarBind
decl_stmt|;
if|if
condition|(
operator|(
name|oi
operator|=
name|name2inst
argument_list|(
name|v
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown variable \"%s\""
argument_list|,
name|oid2ode
argument_list|(
name|v
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|no_dice
label|:
empty_stmt|;
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|oid2ode
argument_list|(
name|v
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|vunknown
argument_list|(
name|v
operator|->
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|os
operator|=
name|oi
operator|->
name|oi_type
operator|->
name|ot_syntax
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown syntax for object \"%s\""
argument_list|,
name|oi
operator|->
name|oi_type
operator|->
name|ot_text
argument_list|)
expr_stmt|;
goto|goto
name|no_dice
goto|;
block|}
if|if
condition|(
call|(
modifier|*
name|os
operator|->
name|os_decode
call|)
argument_list|(
operator|&
name|value
argument_list|,
name|v
operator|->
name|value
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"decode error for variable \"%s\""
argument_list|,
name|oid2ode
argument_list|(
name|v
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|no_dice
goto|;
block|}
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|oid2ode
argument_list|(
name|v
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|os
operator|->
name|os_print
call|)
argument_list|(
name|value
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|os
operator|->
name|os_free
call|)
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|out
label|:
empty_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|free_SNMP_Message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_help
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|w
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|width
decl_stmt|,
name|lines
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|,
modifier|*
name|es
decl_stmt|;
for|for
control|(
name|es
operator|=
name|dispatches
init|;
name|es
operator|->
name|ds_name
condition|;
name|es
operator|++
control|)
continue|continue;
name|width
operator|=
name|helpwidth
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|columns
operator|=
name|ncols
argument_list|(
name|stdout
argument_list|)
operator|/
operator|(
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
operator|)
operator|)
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
operator|(
operator|(
name|es
operator|-
name|dispatches
operator|)
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
name|printf
argument_list|(
literal|"Operations:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|ds
operator|=
name|dispatches
operator|+
name|j
operator|*
name|lines
operator|+
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|+
name|lines
operator|>=
name|es
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|w
operator|=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_name
argument_list|)
init|;
name|w
operator|<
name|width
condition|;
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"help [commands ...]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    with no arguments, lists operations which may be invoked\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    otherwise prints help for each operation given\n"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
for|for
control|(
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
name|printf
argument_list|(
literal|"%-*s\t- %s\n"
argument_list|,
name|width
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|,
name|ds
operator|->
name|ds_help
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ds
operator|=
name|getds
argument_list|(
operator|*
name|vec
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%-*s\t- %s\n"
argument_list|,
name|width
argument_list|,
name|ds
operator|->
name|ds_name
argument_list|,
name|ds
operator|->
name|ds_help
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_quit
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
name|vec
operator|&&
operator|*
operator|++
name|vec
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"quit\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    terminate fred\n"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
return|return
name|DONE
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|f_status
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|++
name|vec
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|vec
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"status\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    report status\n"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|printf
argument_list|(
literal|"Connected to %s using community \"%s\"\n"
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|snmp_ta
argument_list|)
argument_list|,
name|community
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|SYNTAX */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ifType
index|[]
init|=
block|{
literal|"other"
block|,
literal|"regular1822"
block|,
literal|"hdh1822"
block|,
literal|"ddn-x25"
block|,
literal|"rfc877-x25"
block|,
literal|"ethernet-csmacd"
block|,
literal|"iso88023-csmacd"
block|,
literal|"iso88024-tokenBus"
block|,
literal|"iso88025-tokenRing"
block|,
literal|"iso88026-man"
block|,
literal|"starLan"
block|,
literal|"proteon-10Mbit"
block|,
literal|"proteon-80Mbit"
block|,
literal|"hyperchannel"
block|,
literal|"fddi"
block|,
literal|"lapb"
block|,
literal|"sdlc"
block|,
literal|"t1-carrier"
block|,
literal|"cept"
block|,
literal|"basicISDN"
block|,
literal|"primaryISDN"
block|,
literal|"propPointToPointSerial"
block|,
literal|"ppp"
block|,
literal|"softwareLoopback"
block|,
literal|"eon"
block|,
literal|"ethernet-3Mbit"
block|,
literal|"nsip"
block|,
literal|"slip"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ifStatus
index|[]
init|=
block|{
literal|"up"
block|,
literal|"down"
block|,
literal|"testing"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ipForwarding
index|[]
init|=
block|{
literal|"gateway"
block|,
literal|"host"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|routeType
index|[]
init|=
block|{
literal|"other"
block|,
literal|"invalid"
block|,
literal|"direct"
block|,
literal|"remote"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ipRouteProto
index|[]
init|=
block|{
literal|"other"
block|,
literal|"local"
block|,
literal|"netmgmt"
block|,
literal|"icmp"
block|,
literal|"egp"
block|,
literal|"ggp"
block|,
literal|"hello"
block|,
literal|"rip"
block|,
literal|"is-is"
block|,
literal|"es-is"
block|,
literal|"ciscoIgrp"
block|,
literal|"bbnSpfIgp"
block|,
literal|"ospf"
block|,
literal|"bgp"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|netToMediaType
index|[]
init|=
block|{
literal|"other"
block|,
literal|"invalid"
block|,
literal|"dynamic"
block|,
literal|"static"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tcpRtoAlgorithm
index|[]
init|=
block|{
literal|"other"
block|,
literal|"constant"
block|,
literal|"rsre"
block|,
literal|"vanj"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tcpConnState
index|[]
init|=
block|{
literal|"closed"
block|,
literal|"listen"
block|,
literal|"synSent"
block|,
literal|"synReceived"
block|,
literal|"established"
block|,
literal|"finWait1"
block|,
literal|"finWait2"
block|,
literal|"closeWait"
block|,
literal|"lastAck"
block|,
literal|"closing"
block|,
literal|"timewait"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|egpNeighState
index|[]
init|=
block|{
literal|"idle"
block|,
literal|"acquisition"
block|,
literal|"down"
block|,
literal|"up"
block|,
literal|"cease"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|egpNeighMode
index|[]
init|=
block|{
literal|"active"
block|,
literal|"passive"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|egpNeighEventTrigger
index|[]
init|=
block|{
literal|"start"
block|,
literal|"stop"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|enabled
index|[]
init|=
block|{
literal|"enabled"
block|,
literal|"disabled"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|status
index|[]
init|=
block|{
literal|"valid"
block|,
literal|"invalid"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|smuxPstatus
index|[]
init|=
block|{
literal|"valid"
block|,
literal|"invalid"
block|,
literal|"connecting"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|ivar
block|{
name|char
modifier|*
name|iv_object
decl_stmt|;
name|char
modifier|*
modifier|*
name|iv_values
decl_stmt|;
name|int
name|iv_nvalue
decl_stmt|;
block|}
name|ivars
index|[]
init|=
block|{
literal|"ifType"
block|,
name|ifType
block|,
sizeof|sizeof
name|ifType
operator|/
sizeof|sizeof
name|ifType
index|[
literal|0
index|]
block|,
literal|"ifAdminStatus"
block|,
name|ifStatus
block|,
sizeof|sizeof
name|ifStatus
operator|/
sizeof|sizeof
name|ifStatus
index|[
literal|0
index|]
block|,
literal|"ifOperStatus"
block|,
name|ifStatus
block|,
sizeof|sizeof
name|ifStatus
operator|/
sizeof|sizeof
name|ifStatus
index|[
literal|0
index|]
block|,
literal|"ipForwarding"
block|,
name|ipForwarding
block|,
sizeof|sizeof
name|ipForwarding
operator|/
sizeof|sizeof
name|ipForwarding
index|[
literal|0
index|]
block|,
literal|"ipRouteType"
block|,
name|routeType
block|,
sizeof|sizeof
name|routeType
operator|/
sizeof|sizeof
name|routeType
index|[
literal|0
index|]
block|,
literal|"ipRouteProto"
block|,
name|ipRouteProto
block|,
sizeof|sizeof
name|ipRouteProto
operator|/
sizeof|sizeof
name|ipRouteProto
index|[
literal|0
index|]
block|,
literal|"ipNetToMediaType"
block|,
name|netToMediaType
block|,
sizeof|sizeof
name|netToMediaType
operator|/
sizeof|sizeof
name|netToMediaType
index|[
literal|0
index|]
block|,
literal|"tcpRtoAlgorithm"
block|,
name|tcpRtoAlgorithm
block|,
sizeof|sizeof
name|tcpRtoAlgorithm
operator|/
sizeof|sizeof
name|tcpRtoAlgorithm
index|[
literal|0
index|]
block|,
literal|"tcpConnState"
block|,
name|tcpConnState
block|,
sizeof|sizeof
name|tcpConnState
operator|/
sizeof|sizeof
name|tcpConnState
index|[
literal|0
index|]
block|,
literal|"egpNeighState"
block|,
name|egpNeighState
block|,
sizeof|sizeof
name|egpNeighState
operator|/
sizeof|sizeof
name|egpNeighState
index|[
literal|0
index|]
block|,
literal|"egpNeighMode"
block|,
name|egpNeighMode
block|,
sizeof|sizeof
name|egpNeighMode
operator|/
sizeof|sizeof
name|egpNeighMode
index|[
literal|0
index|]
block|,
literal|"egpNeighEventTrigger"
block|,
name|egpNeighEventTrigger
block|,
sizeof|sizeof
name|egpNeighEventTrigger
operator|/
sizeof|sizeof
name|egpNeighEventTrigger
index|[
literal|0
index|]
block|,
literal|"snmpEnableAuthenTraps"
block|,
name|enabled
block|,
sizeof|sizeof
name|enabled
operator|/
sizeof|sizeof
name|enabled
index|[
literal|0
index|]
block|,
literal|"smuxPstatus"
block|,
name|smuxPstatus
block|,
sizeof|sizeof
name|smuxPstatus
operator|/
sizeof|sizeof
name|smuxPstatus
index|[
literal|0
index|]
block|,
literal|"smuxTstatus"
block|,
name|status
block|,
sizeof|sizeof
name|status
operator|/
sizeof|sizeof
name|status
index|[
literal|0
index|]
block|,
literal|"unixNetstat"
block|,
name|enabled
block|,
sizeof|sizeof
name|enabled
operator|/
sizeof|sizeof
name|enabled
index|[
literal|0
index|]
block|,
name|NULL
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|enum_print
parameter_list|(
name|x
parameter_list|,
name|os
parameter_list|)
name|integer
modifier|*
name|x
decl_stmt|;
name|OS
name|os
decl_stmt|;
block|{
name|int
name|i
init|=
operator|*
name|x
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
name|os
operator|->
name|os_data2
condition|)
name|printf
argument_list|(
literal|"unknown(%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s(%d)"
argument_list|,
name|os
operator|->
name|os_data1
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|moresyntax
argument_list|()
block|{
specifier|register
expr|struct
name|ivar
operator|*
name|iv
block|;
specifier|register
name|OT
name|ot
block|;
specifier|register
name|OS
name|os
block|;
for|for
control|(
name|iv
operator|=
name|ivars
init|;
name|iv
operator|->
name|iv_object
condition|;
name|iv
operator|++
control|)
if|if
condition|(
name|ot
operator|=
name|text2obj
argument_list|(
name|iv
operator|->
name|iv_object
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|os
operator|=
name|ot
operator|->
name|ot_syntax
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no syntax defined for object \"%s\""
argument_list|,
name|iv
operator|->
name|iv_object
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|os
operator|->
name|os_name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|add_syntax
argument_list|(
name|iv
operator|->
name|iv_object
argument_list|,
name|os
operator|->
name|os_encode
argument_list|,
name|os
operator|->
name|os_decode
argument_list|,
name|os
operator|->
name|os_free
argument_list|,
name|os
operator|->
name|os_parse
argument_list|,
name|enum_print
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|os
operator|=
name|text2syn
argument_list|(
name|iv
operator|->
name|iv_object
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"lost syntax for object \"%s\""
argument_list|,
name|iv
operator|->
name|iv_object
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|ot
operator|->
name|ot_syntax
operator|=
name|os
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|os
operator|->
name|os_name
operator|=
name|name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|os
operator|->
name|os_data1
operator|=
name|iv
operator|->
name|iv_values
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|os
operator|->
name|os_data2
operator|=
name|iv
operator|->
name|iv_nvalue
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 	else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no \"%s\" object"
argument_list|,
name|iv
operator|->
name|iv_object
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|MISCELLANY */
end_comment

begin_macro
unit|static
name|arginit
argument_list|(
argument|vec
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|dispatch
modifier|*
name|ds
decl_stmt|;
ifdef|#
directive|ifdef
name|TCP
name|int
name|port
decl_stmt|;
name|struct
name|sockaddr_in
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|isock
init|=
operator|&
name|in_socket
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
init|=
operator|&
name|snmp_ta
decl_stmt|,
modifier|*
name|tz
decl_stmt|;
specifier|register
name|struct
name|NSAPaddr
modifier|*
name|na
init|=
name|ta
operator|->
name|ta_addrs
decl_stmt|;
if|if
condition|(
name|myname
operator|=
name|rindex
argument_list|(
operator|*
name|vec
argument_list|,
literal|'/'
argument_list|)
condition|)
name|myname
operator|++
expr_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|||
operator|*
name|myname
operator|==
name|NULL
condition|)
name|myname
operator|=
operator|*
name|vec
expr_stmt|;
name|isodetailor
argument_list|(
name|myname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ontty
operator|=
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|verbose
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"snmp"
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"udp/snmp: unknown service"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ta
argument_list|,
sizeof|sizeof
expr|*
name|ta
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP
name|na
operator|->
name|na_stack
operator|=
name|NA_TCP
expr_stmt|;
name|na
operator|->
name|na_community
operator|=
name|ts_comm_tcp_default
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|na
operator|->
name|na_domain
argument_list|,
name|getlocalhost
argument_list|()
argument_list|,
sizeof|sizeof
name|na
operator|->
name|na_domain
operator|-
literal|1
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_port
operator|=
name|sp
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|161
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_tset
operator|=
name|NA_TSET_UDP
expr_stmt|;
name|ta
operator|->
name|ta_naddr
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|vec
operator|++
init|;
name|ap
operator|=
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|ap
condition|)
switch|switch
condition|(
operator|*
name|ap
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* e.g., NS+0504030201 */
if|if
condition|(
operator|(
name|pp
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|pp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -a agent"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP
if|if
condition|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|pp
argument_list|)
condition|)
block|{
if|if
condition|(
name|na
operator|->
name|na_stack
operator|!=
name|NA_TCP
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"use -a at most once..."
argument_list|)
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|isock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|na
operator|->
name|na_domain
argument_list|,
name|inet_ntoa
argument_list|(
name|isock
operator|->
name|sin_addr
argument_list|)
argument_list|,
sizeof|sizeof
name|na
operator|->
name|na_domain
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|tz
operator|=
name|str2taddr
argument_list|(
name|pp
argument_list|)
operator|)
operator|&&
name|tz
operator|->
name|ta_naddr
operator|>
literal|0
condition|)
block|{
operator|*
name|ta
operator|=
operator|*
name|tz
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|na
operator|->
name|na_stack
operator|==
name|NA_TCP
condition|)
block|{
if|if
condition|(
name|na
operator|->
name|na_port
operator|==
literal|0
condition|)
name|na
operator|->
name|na_port
operator|=
name|sp
condition|?
name|sp
operator|->
name|s_port
else|:
name|htons
argument_list|(
operator|(
name|u_short
operator|)
literal|161
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_tset
operator|=
name|NA_TSET_UDP
expr_stmt|;
block|}
block|}
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: unknown host"
argument_list|,
name|pp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TCP
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|pp
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|pp
operator|==
literal|'-'
operator|||
operator|(
name|port
operator|=
name|atoi
argument_list|(
name|pp
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -p portno"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|na_stack
operator|!=
name|NA_TCP
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-p not allowed with %s"
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|->
name|na_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|pp
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|pp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -c community"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|community
operator|=
name|pp
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|watch
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|(
name|pp
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|pp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -f file"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|defs
operator|=
name|pp
expr_stmt|;
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown switch -%c"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
block|{
name|op
operator|=
name|vec
expr_stmt|;
break|break;
block|}
block|}
name|helpwidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ds
operator|=
name|dispatches
init|;
name|ds
operator|->
name|ds_name
condition|;
name|ds
operator|++
control|)
if|if
condition|(
operator|(
name|w
operator|=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_name
argument_list|)
operator|)
operator|>
name|helpwidth
condition|)
name|helpwidth
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|ta_naddr
operator|==
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -a string"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|na
operator|->
name|na_stack
condition|)
block|{
case|case
name|NA_TCP
case|:
ifdef|#
directive|ifdef
name|TCP
block|{
name|struct
name|sockaddr_in
name|lo_socket
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|lsock
init|=
operator|&
name|lo_socket
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lsock
argument_list|,
sizeof|sizeof
expr|*
name|lsock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|pp
operator|=
name|getlocalhost
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: unknown host"
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|lsock
operator|->
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|lsock
argument_list|)
expr_stmt|;
comment|/* If the request is being sent out on the loopback interface, 		   make sure it appears to have originated from the loopback 		   interface, rather than the interface used as the default 		   hostname.  If the interface used as the default hostname 		   is a serial link, responses to requests with this origin 		   may be undeliverable.  (EJP) */
define|#
directive|define
name|LOOPBACK
value|((127<< 24) + 1)
if|if
condition|(
name|isock
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|LOOPBACK
condition|)
name|lsock
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|LOOPBACK
expr_stmt|;
undef|#
directive|undef
name|LOOPBACK
if|if
condition|(
operator|(
name|sd
operator|=
name|start_udp_client
argument_list|(
name|lsock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"start_udp_client"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isock
argument_list|,
sizeof|sizeof
expr|*
name|isock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbystring
argument_list|(
name|na
operator|->
name|na_domain
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s: unknown host"
argument_list|,
name|na
operator|->
name|na_domain
argument_list|)
expr_stmt|;
name|isock
operator|->
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|isock
operator|->
name|sin_port
operator|=
name|na
operator|->
name|na_port
expr_stmt|;
name|inaddr_copy
argument_list|(
name|hp
argument_list|,
name|isock
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_udp_server
argument_list|(
name|sd
argument_list|,
name|isock
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"join_udp_server"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|dg_open
argument_list|)
operator|)
operator|==
name|NULLPS
operator|||
name|dg_setup
argument_list|(
name|ps
argument_list|,
name|sd
argument_list|,
name|MAXDGRAM
argument_list|,
name|read_udp_socket
argument_list|,
name|write_udp_socket
argument_list|,
name|check_udp_socket
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory"
argument_list|)
expr_stmt|;
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"dg_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
else|#
directive|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"UDP support not configured"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|NA_X25
case|:
ifdef|#
directive|ifdef
name|X25
goto|goto
name|cots
goto|;
else|#
directive|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"X.25 support not configured"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|NA_NSAP
case|:
ifdef|#
directive|ifdef
name|CLTS
block|{
name|union
name|sockaddr_osi
name|lo_socket
decl_stmt|;
specifier|register
name|union
name|sockaddr_osi
modifier|*
name|lsock
init|=
operator|&
name|lo_socket
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lsock
argument_list|,
sizeof|sizeof
expr|*
name|lsock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|start_clts_client
argument_list|(
name|lsock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"start_clts_client"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gen2tp4
argument_list|(
name|ta
argument_list|,
name|lsock
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_clts_server
argument_list|(
name|sd
argument_list|,
name|lsock
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"join_udp_server"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|dg_open
argument_list|)
operator|)
operator|==
name|NULLPS
operator|||
name|dg_setup
argument_list|(
name|ps
argument_list|,
name|sd
argument_list|,
name|MAXDGRAM
argument_list|,
name|read_clts_socket
argument_list|,
name|write_clts_socket
argument_list|,
name|check_clts_socket
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory"
argument_list|)
expr_stmt|;
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"dg_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
else|#
directive|else
ifdef|#
directive|ifdef
name|TP4
goto|goto
name|cots
goto|;
else|#
directive|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"TP4 support not configured"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown network type 0x%x"
argument_list|,
name|na
operator|->
name|na_stack
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
ifdef|#
directive|ifdef
name|COTS
name|cots
label|:
empty_stmt|;
block|{
name|struct
name|TSAPconnect
name|tcs
decl_stmt|;
specifier|register
name|struct
name|TSAPconnect
modifier|*
name|tc
init|=
operator|&
name|tcs
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s... "
argument_list|,
name|taddr2str
argument_list|(
name|ta
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TConnRequest
argument_list|(
name|NULLTA
argument_list|,
name|ta
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|NULLQOS
argument_list|,
name|tc
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" failed\n"
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
name|td
operator|->
name|td_cc
operator|>
literal|0
condition|?
literal|"T-CONNECT.REQUEST: [%s] %*.*s"
else|:
literal|"T-CONNECT.REQUEST: [%s]"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_data
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"connected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|dg_open
argument_list|)
operator|)
operator|==
name|NULLPS
operator|||
name|dg_setup
argument_list|(
name|ps
argument_list|,
name|sd
operator|=
name|tc
operator|->
name|tc_sd
argument_list|,
name|MAXDGRAM
argument_list|,
name|ts_read
argument_list|,
name|ts_write
argument_list|,
name|NULLIFP
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|ps
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory"
argument_list|)
expr_stmt|;
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"dg_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SYS5
operator|(
name|void
operator|)
name|srand
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|srandom
argument_list|(
operator|(
name|int
operator|)
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ps_len_strategy
operator|=
name|PS_LEN_LONG
expr_stmt|;
if|if
condition|(
name|readobjects
argument_list|(
name|defs
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"readobjects: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|moresyntax
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|INTERACTIVE */
end_comment

begin_function
specifier|static
name|int
name|getline
parameter_list|(
name|prompt
parameter_list|,
name|buffer
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
specifier|static
name|int
name|sticky
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|interrupted
condition|)
block|{
name|interrupted
operator|=
literal|0
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|sticky
condition|)
block|{
name|sticky
operator|=
literal|0
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
switch|switch
condition|(
name|setjmp
argument_list|(
name|intrenv
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
name|armed
operator|++
expr_stmt|;
break|break;
case|case
name|NOTOK
case|:
if|if
condition|(
name|ontty
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* and fall */
default|default:
name|armed
operator|=
literal|0
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|ontty
condition|)
block|{
name|printf
argument_list|(
name|prompt
argument_list|,
name|myname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|buffer
operator|)
operator|+
name|BUFSIZ
operator|-
literal|1
init|;
operator|(
name|i
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ontty
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buffer
condition|)
name|longjmp
argument_list|(
name|intrenv
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
name|sticky
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|i
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|armed
operator|=
literal|0
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SFD
name|intrser
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSDSIGS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|armed
condition|)
name|longjmp
argument_list|(
name|intrenv
argument_list|,
name|NOTOK
argument_list|)
expr_stmt|;
name|interrupted
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TIOCGWINSZ
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ncols
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|int
name|i
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ws
argument_list|)
operator|!=
name|NOTOK
operator|&&
operator|(
name|i
operator|=
name|ws
operator|.
name|ws_col
operator|)
operator|>
literal|0
condition|)
return|return
name|i
return|;
endif|#
directive|endif
return|return
literal|80
return|;
block|}
end_function

begin_comment
comment|/*
comment|ERRORS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function_decl
name|void
name|_advise
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|adios
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_advise
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_advise
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_advise
parameter_list|(
name|ap
parameter_list|)
name|va_list
name|ap
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|asprintf
argument_list|(
name|buffer
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|myname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|advise
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|advise
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

