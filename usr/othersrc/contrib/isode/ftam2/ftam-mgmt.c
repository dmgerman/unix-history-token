begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftam-mgmt.c - interactive initiator FTAM -- file management */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/ftam2/RCS/ftam-mgmt.c,v 7.2 91/02/22 09:23:46 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/ftam2/RCS/ftam-mgmt.c,v 7.2 91/02/22 09:23:46 mrose Interim $  *  *  * $Log:	ftam-mgmt.c,v $  * Revision 7.2  91/02/22  09:23:46  mrose  * Interim 6.8  *   * Revision 7.1  90/11/21  11:30:30  mrose  * sun  *   * Revision 7.0  89/11/23  21:54:23  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ftamuser.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_mv
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BRIDGE
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
else|#
directive|else
name|int
name|sglobbed
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|gp
decl_stmt|,
modifier|*
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|freedst
init|=
name|NULL
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|NOTOK
return|;
else|#
directive|else
if|if
condition|(
name|getline
argument_list|(
literal|"source: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
name|dst
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|BRIDGE
name|src
operator|=
operator|*
name|vec
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
name|dst
operator|=
operator|*
name|vec
expr_stmt|;
else|#
directive|else
else|else
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|vec
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
continue|continue;
if|if
condition|(
operator|--
name|ap
operator|!=
name|vec
condition|)
name|dst
operator|=
operator|*
name|ap
operator|,
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
else|else
name|dst
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
if|if
condition|(
operator|!
operator|(
name|src
operator|=
name|xglob
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|OK
return|;
name|sglobbed
operator|=
name|xglobbed
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"destination: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|blkfree
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
switch|switch
condition|(
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
name|dst
operator|=
literal|"."
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"need a destination"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
literal|1
case|:
name|dst
operator|=
operator|*
name|vec
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"too many destinations"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|dst
operator|=
name|freedst
operator|=
name|xglob1val
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|src
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|interrupted
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|isdir
argument_list|(
name|dst
argument_list|,
name|NULLCP
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
break|break;
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
name|dst
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|src
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|src
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|buffer
expr_stmt|;
switch|switch
condition|(
name|ask
argument_list|(
literal|"mv %s %s"
argument_list|,
operator|*
name|src
argument_list|,
name|dst
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
goto|goto
name|out
goto|;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
break|break;
block|}
operator|(
name|void
operator|)
name|mv
argument_list|(
operator|*
name|src
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNKNOWN
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|rs_unknown
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|RFS_UNIX
case|:
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
operator|*
name|dst
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|rs_support
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|isdir
argument_list|(
name|dst
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|gp
operator|=
name|src
init|;
operator|*
name|gp
condition|;
name|gp
operator|++
control|)
block|{
switch|switch
condition|(
name|realstore
condition|)
block|{
case|case
name|RFS_UNIX
case|:
if|if
condition|(
name|dst
operator|=
name|rindex
argument_list|(
operator|*
name|gp
argument_list|,
literal|'/'
argument_list|)
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
name|dst
operator|==
name|NULL
operator|||
operator|*
name|dst
operator|==
name|NULL
condition|)
name|dst
operator|=
operator|*
name|gp
expr_stmt|;
break|break;
default|default:
name|dst
operator|=
operator|*
name|gp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|str2file
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sglobbed
condition|)
block|{
if|if
condition|(
name|query
condition|)
switch|switch
condition|(
name|ask
argument_list|(
literal|"mv %s %s"
argument_list|,
operator|*
name|gp
argument_list|,
name|dst
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
continue|continue;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"mv %s %s"
argument_list|,
operator|*
name|gp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mv
argument_list|(
operator|*
name|gp
argument_list|,
name|dst
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
condition|)
break|break;
block|}
else|#
directive|else
return|return
name|mv
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BRIDGE
name|out
label|:
empty_stmt|;
name|blkfree
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|freedst
condition|)
name|free
argument_list|(
name|freedst
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|mv
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|multi
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|multi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|src
expr_stmt|;
name|ftse
operator|->
name|ftse_access
operator|=
name|FA_PERM_CHNGATTR
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CHATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftca
operator|->
name|ftca_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|dst
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FManageRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-MANAGE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
if|if
condition|(
name|multi
operator|&&
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftse
operator|->
name|ftse_diags
argument_list|,
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
literal|1
argument_list|,
name|ftse
operator|->
name|ftse_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CHATTR
condition|)
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftca
operator|->
name|ftca_diags
argument_list|,
name|ftca
operator|->
name|ftca_ndiag
argument_list|,
literal|1
argument_list|,
name|ftca
operator|->
name|ftca_action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftde
operator|->
name|ftde_diags
argument_list|,
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
literal|1
argument_list|,
name|ftde
operator|->
name|ftde_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|)
expr_stmt|;
block|}
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_rm
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|int
name|multi
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|NOTOK
return|;
else|#
directive|else
if|if
condition|(
name|getline
argument_list|(
literal|"file: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|rm
argument_list|(
operator|*
name|vec
argument_list|,
literal|0
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|vec
operator|=
name|xglob
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|gp
decl_stmt|;
name|multi
operator|=
name|vec
index|[
literal|1
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|vec
init|;
operator|*
name|gp
operator|&&
operator|!
name|interrupted
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|xglobbed
operator|&&
name|query
condition|)
switch|switch
condition|(
name|ask
argument_list|(
literal|"rm %s"
argument_list|,
operator|*
name|gp
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
continue|continue;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|rm
argument_list|(
operator|*
name|gp
argument_list|,
name|multi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
condition|)
break|break;
block|}
name|out
label|:
empty_stmt|;
name|blkfree
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|rm
parameter_list|(
name|file
parameter_list|,
name|multi
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|multi
decl_stmt|;
block|{
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|file
expr_stmt|;
name|ftse
operator|->
name|ftse_access
operator|=
name|FA_PERM_DELETE
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DELETE
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FManageRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-MANAGE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
if|if
condition|(
name|multi
operator|&&
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftse
operator|->
name|ftse_diags
argument_list|,
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
literal|1
argument_list|,
name|ftse
operator|->
name|ftse_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DELETE
condition|)
block|{
specifier|register
name|struct
name|FTAMdelete
modifier|*
name|ftxe
init|=
operator|&
name|ftg
operator|->
name|ftg_delete
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftxe
operator|->
name|ftxe_diags
argument_list|,
name|ftxe
operator|->
name|ftxe_ndiag
argument_list|,
literal|1
argument_list|,
name|ftxe
operator|->
name|ftxe_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftxe
operator|->
name|ftxe_charges
argument_list|)
expr_stmt|;
block|}
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE
end_ifndef

begin_function
name|int
name|f_chgrp
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|multi
decl_stmt|;
name|char
name|group
index|[
literal|8
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|attrs
operator|&
name|FATTR_STORAGE
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no support for storage attributes"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"group: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|group
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|getline
argument_list|(
literal|"file: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
block|}
if|if
condition|(
name|vec
operator|=
name|xglob
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|gp
decl_stmt|;
name|multi
operator|=
name|vec
index|[
literal|1
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|vec
init|;
operator|*
name|gp
operator|&&
operator|!
name|interrupted
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|xglobbed
operator|&&
name|query
condition|)
switch|switch
condition|(
name|ask
argument_list|(
literal|"chgrp %s %s"
argument_list|,
name|group
argument_list|,
operator|*
name|gp
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
continue|continue;
case|case
name|OK
case|:
default|default:
break|break;
case|case
name|DONE
case|:
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|chgrp
argument_list|(
name|group
argument_list|,
operator|*
name|gp
argument_list|,
name|multi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftamfd
operator|==
name|NOTOK
condition|)
break|break;
block|}
name|out
label|:
empty_stmt|;
name|blkfree
argument_list|(
name|vec
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|chgrp
parameter_list|(
name|group
parameter_list|,
name|file
parameter_list|,
name|multi
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|multi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_SELECT
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftse
operator|->
name|ftse_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|file
expr_stmt|;
name|ftse
operator|->
name|ftse_access
operator|=
name|FA_PERM_CHNGATTR
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftse
operator|->
name|ftse_conctl
argument_list|)
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CHATTR
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftca
operator|->
name|ftca_attrs
decl_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_ACCOUNT
expr_stmt|;
name|fa
operator|->
name|fa_account
operator|=
name|group
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FManageRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-MANAGE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_SELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMselect
modifier|*
name|ftse
init|=
operator|&
name|ftg
operator|->
name|ftg_select
decl_stmt|;
if|if
condition|(
name|multi
operator|&&
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftse
operator|->
name|ftse_diags
argument_list|,
name|ftse
operator|->
name|ftse_ndiag
argument_list|,
literal|1
argument_list|,
name|ftse
operator|->
name|ftse_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftse
operator|->
name|ftse_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CHATTR
condition|)
block|{
specifier|register
name|struct
name|FTAMchngattr
modifier|*
name|ftca
init|=
operator|&
name|ftg
operator|->
name|ftg_chngattr
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftca
operator|->
name|ftca_diags
argument_list|,
name|ftca
operator|->
name|ftca_ndiag
argument_list|,
literal|1
argument_list|,
name|ftca
operator|->
name|ftca_action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftde
operator|->
name|ftde_diags
argument_list|,
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
literal|1
argument_list|,
name|ftde
operator|->
name|ftde_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|)
expr_stmt|;
block|}
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|f_mkdir
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BRIDGE
name|int
name|multi
decl_stmt|;
specifier|register
name|char
modifier|*
name|dir
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
operator|++
name|vec
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|NOTOK
return|;
else|#
directive|else
if|if
condition|(
name|getline
argument_list|(
literal|"directory: "
argument_list|,
name|buffer
argument_list|)
operator|==
name|NOTOK
operator|||
name|str2vec
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
return|return
name|OK
return|;
operator|(
name|void
operator|)
name|makedir
argument_list|(
name|str2file
argument_list|(
operator|*
name|vec
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|BRIDGE
return|return
name|makedir
argument_list|(
name|str2file
argument_list|(
operator|*
name|vec
argument_list|)
argument_list|)
return|;
else|#
directive|else
else|else
block|{
name|multi
operator|=
name|vec
index|[
literal|1
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
while|while
condition|(
name|dir
operator|=
operator|*
name|vec
operator|++
condition|)
operator|(
name|void
operator|)
name|makedir
argument_list|(
name|str2file
argument_list|(
name|dir
argument_list|)
argument_list|,
name|multi
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|makedir
parameter_list|(
name|dir
parameter_list|,
name|multi
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|multi
decl_stmt|;
block|{
name|struct
name|FTAMgroup
name|ftgs
decl_stmt|;
specifier|register
name|struct
name|FTAMgroup
modifier|*
name|ftg
init|=
operator|&
name|ftgs
decl_stmt|;
name|struct
name|FTAMindication
name|ftis
decl_stmt|;
specifier|register
name|struct
name|FTAMindication
modifier|*
name|fti
init|=
operator|&
name|ftis
decl_stmt|;
name|struct
name|vfsmap
modifier|*
name|vf
init|=
operator|&
name|vfs
index|[
name|VFS_FDF
index|]
decl_stmt|;
if|if
condition|(
name|vf
operator|->
name|vf_oid
operator|==
name|NULLOID
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no support for %ss"
argument_list|,
name|vf
operator|->
name|vf_text
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ftg
argument_list|,
sizeof|sizeof
expr|*
name|ftg
argument_list|)
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_BEGIN
operator||
name|FTG_END
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|=
literal|0
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_CREATE
expr_stmt|;
block|{
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftg
operator|->
name|ftg_create
decl_stmt|;
specifier|register
name|struct
name|FTAMattributes
modifier|*
name|fa
init|=
operator|&
name|ftce
operator|->
name|ftce_attrs
decl_stmt|;
name|ftce
operator|->
name|ftce_override
operator|=
name|FOVER_FAIL
expr_stmt|;
name|fa
operator|->
name|fa_present
operator|=
name|FA_FILENAME
expr_stmt|;
name|fa
operator|->
name|fa_nfile
operator|=
literal|0
expr_stmt|;
name|fa
operator|->
name|fa_files
index|[
name|fa
operator|->
name|fa_nfile
operator|++
index|]
operator|=
name|dir
expr_stmt|;
name|fa
operator|->
name|fa_present
operator||=
name|FA_ACTIONS
expr_stmt|;
comment|/*for NBS Phase 2 creation of directories is not		*/
comment|/*allowed; so the access mode and the permitted actions */
comment|/*below which includes "EXTEND" will have to be checked */
comment|/*once creation of NSB-9 dir. file type is defined      */
name|fa
operator|->
name|fa_permitted
operator|=
name|FA_PERM_READ
operator||
name|FA_PERM_EXTEND
operator||
name|FA_PERM_READATTR
operator||
name|FA_PERM_CHNGATTR
operator||
name|FA_PERM_DELETE
operator||
name|FA_PERM_TRAV
expr_stmt|;
name|fa
operator|->
name|fa_present
operator||=
name|FA_CONTENTS
expr_stmt|;
name|fa
operator|->
name|fa_contents
operator|=
name|vf
operator|->
name|vf_oid
expr_stmt|;
name|ftce
operator|->
name|ftce_access
operator|=
name|FA_PERM_EXTEND
expr_stmt|;
name|FCINIT
argument_list|(
operator|&
name|ftce
operator|->
name|ftce_conctl
argument_list|)
expr_stmt|;
block|}
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
name|ftg
operator|->
name|ftg_flags
operator||=
name|FTG_DESELECT
expr_stmt|;
name|ftg
operator|->
name|ftg_threshold
operator|++
expr_stmt|;
if|if
condition|(
name|FManageRequest
argument_list|(
name|ftamfd
argument_list|,
name|ftg
argument_list|,
name|fti
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ftam_advise
argument_list|(
operator|&
name|fti
operator|->
name|fti_abort
argument_list|,
literal|"F-MANAGE.REQUEST"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ftg
operator|=
operator|&
name|fti
operator|->
name|fti_group
expr_stmt|;
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_CREATE
condition|)
block|{
specifier|register
name|struct
name|FTAMcreate
modifier|*
name|ftce
init|=
operator|&
name|ftg
operator|->
name|ftg_create
decl_stmt|;
if|if
condition|(
name|multi
operator|&&
name|ftce
operator|->
name|ftce_state
operator|!=
name|FSTATE_SUCCESS
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|ftam_diag
argument_list|(
name|ftce
operator|->
name|ftce_diags
argument_list|,
name|ftce
operator|->
name|ftce_ndiag
argument_list|,
literal|1
argument_list|,
name|ftce
operator|->
name|ftce_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftce
operator|->
name|ftce_state
operator|!=
name|FSTATE_SUCCESS
condition|)
goto|goto
name|you_lose
goto|;
block|}
if|if
condition|(
name|ftg
operator|->
name|ftg_flags
operator|&
name|FTG_DESELECT
condition|)
block|{
specifier|register
name|struct
name|FTAMdeselect
modifier|*
name|ftde
init|=
operator|&
name|ftg
operator|->
name|ftg_deselect
decl_stmt|;
name|ftam_diag
argument_list|(
name|ftde
operator|->
name|ftde_diags
argument_list|,
name|ftde
operator|->
name|ftde_ndiag
argument_list|,
literal|1
argument_list|,
name|ftde
operator|->
name|ftde_action
argument_list|)
expr_stmt|;
name|ftam_chrg
argument_list|(
operator|&
name|ftde
operator|->
name|ftde_charges
argument_list|)
expr_stmt|;
block|}
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
name|you_lose
label|:
empty_stmt|;
name|FTGFREE
argument_list|(
name|ftg
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

end_unit

