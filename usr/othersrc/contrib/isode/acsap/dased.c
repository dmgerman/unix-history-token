begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dased.c - stand-alone DASE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/acsap/RCS/dased.c,v 7.9 91/02/22 09:14:33 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/acsap/RCS/dased.c,v 7.9 91/02/22 09:14:33 mrose Interim $  *  *  * $Log:	dased.c,v $  * Revision 7.9  91/02/22  09:14:33  mrose  * Interim 6.8  *   * Revision 7.8  91/01/07  12:39:44  mrose  * update  *   * Revision 7.7  90/12/23  18:39:06  mrose  * update  *   * Revision 7.6  90/12/17  22:12:53  mrose  * -call  *   * Revision 7.5  90/12/11  10:52:08  mrose  * lock-and-load  *   * Revision 7.4  90/11/04  19:14:45  mrose  * update  *   * Revision 7.3  90/10/29  18:37:57  mrose  * updates  *   * Revision 7.2  90/07/27  08:41:41  mrose  * update  *   * Revision 7.1  90/07/09  14:30:57  mrose  * sync  *   * Revision 7.0  90/07/07  16:11:31  mrose  * *** empty log message ***  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"DASE-types.h"
end_include

begin_include
include|#
directive|include
file|"psap.h"
end_include

begin_include
include|#
directive|include
file|"tsap.h"
end_include

begin_include
include|#
directive|include
file|"dgram.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"quipu/ufn.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/read.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dua.h"
end_include

begin_include
include|#
directive|include
file|"quipu/bind.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|STATS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nbits
init|=
name|FD_SETSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LLog
name|_pgm_log
init|=
block|{
literal|"dased.log"
block|,
name|NULLCP
block|,
name|NULLCP
block|,
name|LLOG_FATAL
operator||
name|LLOG_EXCEPTIONS
operator||
name|LLOG_NOTICE
block|,
name|LLOG_FATAL
block|,
operator|-
literal|1
block|,
name|LLOGCLS
operator||
name|LLOGCRT
operator||
name|LLOGZER
block|,
name|NOTOK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LLog
modifier|*
name|pgm_log
init|=
operator|&
name|_pgm_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pgmname
init|=
literal|"dased"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|TSAPaddr
name|tas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isbound
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prebind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dsap_ad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DN
name|userdn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|passwd
index|[
name|DBA_MAX_PASSWD_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PS
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PS
name|nps
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|dns_compar
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|DNS
name|dase_interact
argument_list|()
decl_stmt|,
name|just_say_no
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|PE
name|name2psap
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|adios
argument_list|()
decl_stmt|,
name|advise
argument_list|()
decl_stmt|,
name|ts_adios
argument_list|()
decl_stmt|,
name|ts_advise
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|dn2str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PE
name|grab_pe
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|vecp
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
name|arginit
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|envinit
argument_list|()
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"listening on %s"
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|tas
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TNetListen
argument_list|(
operator|&
name|tas
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
name|ts_adios
argument_list|(
name|td
argument_list|,
literal|"TNetListen failed"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nfds
decl_stmt|,
name|secs
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|,
modifier|*
name|rfds
decl_stmt|;
if|if
condition|(
operator|!
name|isbound
operator|&&
name|prebind
condition|)
operator|(
name|void
operator|)
name|bind_to_dsa
argument_list|()
expr_stmt|;
if|if
condition|(
name|isbound
condition|)
block|{
name|rfds
operator|=
operator|&
name|ifds
expr_stmt|;
name|nfds
operator|=
name|dsap_ad
operator|+
literal|1
expr_stmt|;
name|FD_ZERO
argument_list|(
name|rfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|dsap_ad
argument_list|,
name|rfds
argument_list|)
expr_stmt|;
name|secs
operator|=
name|NOTOK
expr_stmt|;
block|}
else|else
name|nfds
operator|=
literal|0
operator|,
name|rfds
operator|=
name|NULLFD
operator|,
name|secs
operator|=
name|prebind
condition|?
literal|5
operator|*
literal|60L
else|:
name|NOTOK
expr_stmt|;
if|if
condition|(
name|TNetAcceptAux
argument_list|(
operator|&
name|vecp
argument_list|,
name|vec
argument_list|,
name|NULLIP
argument_list|,
name|NULLTA
argument_list|,
name|nfds
argument_list|,
name|rfds
argument_list|,
name|NULLFD
argument_list|,
name|NULLFD
argument_list|,
name|secs
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetAccept failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rfds
operator|&&
name|FD_ISSET
argument_list|(
name|dsap_ad
argument_list|,
name|rfds
argument_list|)
condition|)
block|{
comment|/* DSA timed us out... */
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"unbound from directory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ds_unbind
argument_list|()
expr_stmt|;
name|isbound
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vecp
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|debug
condition|)
break|break;
switch|switch
condition|(
name|TNetFork
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|td
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTOK
case|:
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"TNetFork failed"
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|isbound
condition|)
block|{
if|if
condition|(
name|dsap_ad
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|dsap_ad
argument_list|)
operator|,
name|dsap_ad
operator|=
name|NOTOK
expr_stmt|;
name|isbound
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
block|}
name|dased
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|DASE */
end_comment

begin_expr_stmt
specifier|static
name|dased
argument_list|(
argument|vecp
argument_list|,
argument|vec
argument_list|)
name|int
name|vecp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sd
decl_stmt|;
name|struct
name|TSAPstart
name|tss
decl_stmt|;
specifier|register
name|struct
name|TSAPstart
modifier|*
name|ts
init|=
operator|&
name|tss
decl_stmt|;
name|struct
name|TSAPdisconnect
name|tds
decl_stmt|;
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
init|=
operator|&
name|tds
decl_stmt|;
if|if
condition|(
name|TInit
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|ts
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
name|ts_adios
argument_list|(
name|td
argument_list|,
literal|"T-CONNECT.INDICATION failed"
argument_list|)
expr_stmt|;
name|sd
operator|=
name|ts
operator|->
name|ts_sd
expr_stmt|;
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"T-CONNECT.INDICATION:<%d, %s, %s, %d, %d>"
argument_list|,
name|ts
operator|->
name|ts_sd
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|ts
operator|->
name|ts_calling
argument_list|)
argument_list|,
name|taddr2str
argument_list|(
operator|&
name|ts
operator|->
name|ts_called
argument_list|)
argument_list|,
name|ts
operator|->
name|ts_expedited
argument_list|,
name|ts
operator|->
name|ts_tsdusize
argument_list|)
expr_stmt|;
if|if
condition|(
name|TConnResponse
argument_list|(
name|sd
argument_list|,
name|NULLTA
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|NULLQOS
argument_list|,
name|td
argument_list|)
operator|==
name|NOTOK
condition|)
name|ts_adios
argument_list|(
name|td
argument_list|,
literal|"T-CONNECT.RESPONSE failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ps
operator|=
name|ps_alloc
argument_list|(
name|dg_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dg_setup
argument_list|(
name|ps
argument_list|,
name|sd
argument_list|,
name|MAXDGRAM
argument_list|,
name|ts_read
argument_list|,
name|ts_write
argument_list|,
name|NULLIFP
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"dg_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|type_DASE_Query__REQ
modifier|*
name|req
decl_stmt|;
name|PE
name|pe
decl_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
block|{
if|if
condition|(
name|ps
operator|->
name|ps_errno
operator|==
name|PS_ERR_NONE
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"T-DISCONNECT.INDICATION"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps2pe: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decode_DASE_Query__REQ
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|req
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"decode_DASE_Query__REQ: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|DASE_Message
argument_list|,
name|pe
argument_list|,
literal|"message"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dase_aux
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|free_DASE_Query__REQ
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isbound
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"unbound from directory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ds_unbind
argument_list|()
expr_stmt|;
name|isbound
operator|=
literal|0
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|dase_aux
argument_list|(
name|req
argument_list|)
specifier|register
expr|struct
name|type_DASE_Query__REQ
operator|*
name|req
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|vecp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|context
decl_stmt|,
modifier|*
modifier|*
name|vec
decl_stmt|;
specifier|register
name|struct
name|type_DASE_Query__RSP
modifier|*
name|rsp
decl_stmt|;
specifier|register
name|struct
name|element_DASE_0
modifier|*
name|d0
decl_stmt|;
specifier|register
name|struct
name|element_DASE_1
modifier|*
name|d1
decl_stmt|;
name|envlist
name|el
decl_stmt|;
specifier|register
name|envlist
name|en
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|DN
modifier|*
name|dn
decl_stmt|;
name|DNS
name|dns
decl_stmt|;
name|PE
name|pe
decl_stmt|;
if|if
condition|(
operator|(
name|rsp
operator|=
operator|(
expr|struct
name|type_DASE_Query__RSP
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|rsp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
name|vec
operator|=
name|NULL
operator|,
name|el
operator|=
name|NULL
operator|,
name|context
operator|=
name|NULL
operator|,
name|dns
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|d0
operator|=
name|req
operator|->
name|name
init|;
name|d0
condition|;
name|d0
operator|=
name|d0
operator|->
name|next
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|vec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|,
sizeof|sizeof
expr|*
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
for|for
control|(
name|vp
operator|=
name|vec
operator|,
name|d0
operator|=
name|req
operator|->
name|name
init|;
name|d0
condition|;
name|vp
operator|++
operator|,
name|d0
operator|=
name|d0
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|vp
operator|=
name|qb2str
argument_list|(
name|d0
operator|->
name|IA5String
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
ifdef|#
directive|ifdef
name|STATS
else|else
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"lookup: %s"
argument_list|,
operator|*
name|vp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vecp
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|el
operator|=
name|NULL
operator|,
name|ep
operator|=
operator|&
name|el
expr_stmt|;
for|for
control|(
name|d1
operator|=
name|req
operator|->
name|envlist
init|;
name|d1
condition|;
name|d1
operator|=
name|d1
operator|->
name|next
control|)
block|{
name|struct
name|type_DASE_Environment
modifier|*
name|ev
init|=
name|d1
operator|->
name|Environment
decl_stmt|;
specifier|register
name|struct
name|element_DASE_2
modifier|*
name|d2
decl_stmt|;
specifier|register
name|struct
name|dn_seq
modifier|*
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|en
operator|=
operator|(
name|envlist
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|en
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
operator|*
name|ep
operator|=
name|en
operator|,
name|ep
operator|=
operator|&
name|en
operator|->
name|Next
expr_stmt|;
name|en
operator|->
name|Upper
operator|=
name|ev
operator|->
name|upper
expr_stmt|;
name|en
operator|->
name|Lower
operator|=
name|ev
operator|->
name|lower
expr_stmt|;
name|dp
operator|=
operator|&
name|en
operator|->
name|Dns
expr_stmt|;
for|for
control|(
name|d2
operator|=
name|ev
operator|->
name|path
init|;
name|d2
condition|;
name|d2
operator|=
name|d2
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|dn_seq
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
operator|(
expr|struct
name|dn_seq
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ds
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
operator|*
name|dp
operator|=
name|ds
operator|,
name|dp
operator|=
operator|&
name|ds
operator|->
name|dns_next
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|qb2str
argument_list|(
name|d2
operator|->
name|IA5String
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'-'
condition|)
name|ds
operator|->
name|dns_dn
operator|=
name|str2dn
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'-'
operator|&&
name|ds
operator|->
name|dns_dn
operator|==
name|NULLDN
condition|)
block|{
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"bad DN in environment (%s)"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|send_rsp
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|context
operator|=
name|qb2str
argument_list|(
name|req
operator|->
name|context
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
ifdef|#
directive|ifdef
name|STATS
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"context: %s"
argument_list|,
name|context
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|req
operator|->
name|userdn
condition|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|DN
name|newdn
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|qb2str
argument_list|(
name|req
operator|->
name|userdn
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
ifdef|#
directive|ifdef
name|STATS
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"userdn: %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|newdn
operator|=
name|str2dn
argument_list|(
operator|*
name|cp
operator|!=
literal|'@'
condition|?
name|cp
else|:
name|cp
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"bad DN for userdn (%s)"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|send_rsp
goto|;
block|}
if|if
condition|(
operator|!
name|userdn
operator|||
name|dn_cmp
argument_list|(
name|userdn
argument_list|,
name|newdn
argument_list|)
condition|)
name|changed
operator|++
expr_stmt|;
if|if
condition|(
name|userdn
condition|)
name|dn_free
argument_list|(
name|userdn
argument_list|)
expr_stmt|;
name|userdn
operator|=
name|newdn
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|passwd
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|qb2str
argument_list|(
name|req
operator|->
name|passwd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|passwd
argument_list|,
name|cp
argument_list|)
condition|)
name|changed
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|passwd
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|passwd
index|[
literal|0
index|]
condition|)
name|changed
operator|++
expr_stmt|;
name|passwd
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|isbound
operator|&&
name|changed
condition|)
block|{
operator|(
name|void
operator|)
name|ds_unbind
argument_list|()
expr_stmt|;
name|isbound
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isbound
operator|&&
name|bind_to_dsa
argument_list|()
operator|==
name|NOTOK
condition|)
goto|goto
name|send_rsp
goto|;
name|PY_pepy
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|pe
operator|=
name|NULLPE
expr_stmt|;
if|if
condition|(
name|vecp
operator|==
literal|1
operator|&&
operator|*
name|vec
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
specifier|static
name|DN
name|dnstat
decl_stmt|;
if|if
condition|(
operator|(
name|dnstat
operator|=
name|str2dn
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid name"
argument_list|)
expr_stmt|;
goto|goto
name|send_rsp
goto|;
block|}
name|rsp
operator|->
name|value
operator|=
name|name2psap
argument_list|(
operator|*
operator|(
name|dn
operator|=
operator|&
name|dnstat
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|all_done
goto|;
block|}
if|if
condition|(
operator|!
name|aet_match
argument_list|(
name|vecp
argument_list|,
name|vec
argument_list|,
name|req
operator|->
name|interactive
condition|?
name|dase_interact
else|:
name|just_say_no
argument_list|,
operator|&
name|dns
argument_list|,
name|el
argument_list|,
name|context
argument_list|)
condition|)
block|{
if|if
condition|(
name|PY_pepy
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to resolve name"
argument_list|)
expr_stmt|;
goto|goto
name|send_rsp
goto|;
block|}
if|if
condition|(
name|dns
operator|==
name|NULL
condition|)
block|{
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"search failed to find anything"
argument_list|)
expr_stmt|;
goto|goto
name|send_rsp
goto|;
block|}
name|dn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dns
operator|->
name|dns_next
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|interactive
condition|)
operator|(
name|void
operator|)
name|dnSelect
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
operator|&
name|dns
argument_list|,
name|dase_interact
argument_list|,
name|el
operator|->
name|Dns
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dns
condition|;
name|dns
operator|=
name|dns
operator|->
name|dns_next
control|)
block|{
name|dn
operator|=
operator|&
name|dns
operator|->
name|dns_dn
expr_stmt|;
if|if
condition|(
name|rsp
operator|->
name|value
operator|=
name|name2psap
argument_list|(
operator|*
name|dn
argument_list|)
condition|)
break|break;
block|}
block|}
else|else
block|{
name|dn
operator|=
operator|&
name|dns
operator|->
name|dns_dn
expr_stmt|;
name|rsp
operator|->
name|value
operator|=
name|name2psap
argument_list|(
operator|*
name|dn
argument_list|)
expr_stmt|;
block|}
name|all_done
label|:
empty_stmt|;
if|if
condition|(
name|dn
condition|)
block|{
operator|(
name|void
operator|)
name|encode_IF_DistinguishedName
argument_list|(
operator|&
name|rsp
operator|->
name|name
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
operator|*
name|dn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"answer: %s"
argument_list|,
name|dn2str
argument_list|(
operator|*
name|dn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ufn_dn_print_aux
argument_list|(
name|nps
argument_list|,
operator|*
name|dn
argument_list|,
name|NULLDN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|nps
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|*
operator|--
name|nps
operator|->
name|ps_ptr
operator|=
name|NULL
operator|,
name|nps
operator|->
name|ps_cnt
operator|++
expr_stmt|;
name|rsp
operator|->
name|friendly
operator|=
name|str2qb
argument_list|(
name|nps
operator|->
name|ps_base
argument_list|,
name|strlen
argument_list|(
name|nps
operator|->
name|ps_base
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nps
operator|->
name|ps_ptr
operator|=
name|nps
operator|->
name|ps_base
operator|,
name|nps
operator|->
name|ps_cnt
operator|=
name|nps
operator|->
name|ps_bufsiz
expr_stmt|;
name|dn_free
argument_list|(
operator|*
name|dn
argument_list|)
expr_stmt|;
operator|*
name|dn
operator|=
name|NULLDN
expr_stmt|;
block|}
name|send_rsp
label|:
empty_stmt|;
if|if
condition|(
name|PY_pepy
index|[
literal|0
index|]
condition|)
block|{
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"diagnostic: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rsp
operator|->
name|diagnostic
operator|=
name|str2qb
argument_list|(
name|PY_pepy
argument_list|,
name|strlen
argument_list|(
name|PY_pepy
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
if|if
condition|(
name|encode_DASE_Query__RSP
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
name|rsp
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"encode_DASE_Query__RSP: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|DASE_Message
argument_list|,
name|pe
argument_list|,
literal|"message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_DASE_Query__RSP
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
name|vec
condition|)
block|{
for|for
control|(
name|vp
operator|=
name|vec
init|;
operator|*
name|vp
condition|;
name|vp
operator|++
control|)
name|free
argument_list|(
operator|*
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vec
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|el
condition|;
name|el
operator|=
name|en
control|)
block|{
name|en
operator|=
name|el
operator|->
name|Next
expr_stmt|;
name|dn_seq_free
argument_list|(
name|el
operator|->
name|Dns
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|el
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
condition|)
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns
condition|)
name|dn_seq_free
argument_list|(
name|dns
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|bind_to_dsa
argument_list|()
block|{     struct
name|ds_bind_arg
name|ba
block|;     struct
name|ds_bind_arg
name|br
block|;     struct
name|ds_bind_error
name|be
block|;
specifier|static
name|int
name|very_first_time
operator|=
literal|1
block|;
if|if
condition|(
name|isbound
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"unbound from directory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ds_unbind
argument_list|()
expr_stmt|;
name|isbound
operator|=
literal|0
expr_stmt|;
block|}
name|make_bind_args
argument_list|(
operator|&
name|ba
argument_list|,
operator|&
name|br
argument_list|,
operator|&
name|be
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ds_bind
argument_list|(
operator|&
name|ba
argument_list|,
operator|&
name|be
argument_list|,
operator|&
name|br
argument_list|)
operator|==
name|DS_OK
condition|)
block|{
name|isbound
operator|=
literal|1
expr_stmt|;
name|very_first_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|advise
argument_list|(
name|LLOG_DEBUG
argument_list|,
name|NULLCP
argument_list|,
literal|"bound to directory"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_if

begin_expr_stmt
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to bind to directory (%s)"
argument_list|,
name|be
operator|.
name|dbe_type
operator|==
name|DBE_TYPE_SECURITY
condition|?
literal|"security error"
else|:
literal|"DSA unavailable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|prebind
operator|&&
name|very_first_time
condition|)
name|very_first_time
operator|=
literal|0
expr_stmt|;
else|else
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|NOTOK
return|;
end_return

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_function
unit|static
name|int
name|make_bind_args
parameter_list|(
name|ba
parameter_list|,
name|br
parameter_list|,
name|be
parameter_list|)
specifier|register
name|struct
name|ds_bind_arg
modifier|*
name|ba
decl_stmt|,
decl|*
name|br
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|struct
name|ds_bind_error
modifier|*
name|be
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ba
argument_list|,
sizeof|sizeof
expr|*
name|ba
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|br
argument_list|,
sizeof|sizeof
expr|*
name|br
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|be
argument_list|,
sizeof|sizeof
expr|*
name|be
argument_list|)
expr_stmt|;
name|ba
operator|->
name|dba_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
if|if
condition|(
name|ba
operator|->
name|dba_dn
operator|=
name|userdn
condition|)
name|ba
operator|->
name|dba_auth_type
operator|=
name|DBA_AUTH_SIMPLE
expr_stmt|;
if|if
condition|(
name|ba
operator|->
name|dba_passwd_len
operator|=
name|strlen
argument_list|(
name|passwd
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ba
operator|->
name|dba_passwd
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|DNS
name|dase_interact
parameter_list|(
name|dns
parameter_list|,
name|dn
parameter_list|,
name|s
parameter_list|)
name|DNS
name|dns
decl_stmt|;
name|DN
name|dn
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|type_DASE_Callback__REQ
modifier|*
name|req
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|element_DASE_3
modifier|*
modifier|*
name|dp
decl_stmt|;
name|struct
name|type_DASE_Callback__RSP
modifier|*
name|rsp
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|type_DASE_Callback__RSP
modifier|*
name|rp
decl_stmt|;
name|DNS
name|ds
decl_stmt|,
modifier|*
name|dq
decl_stmt|;
name|PE
name|pe
init|=
name|NULLPE
decl_stmt|;
if|if
condition|(
name|dns
operator|==
name|NULLDNS
condition|)
return|return
name|NULL
return|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ds
operator|=
name|dns
init|;
name|ds
condition|;
name|ds
operator|=
name|ds
operator|->
name|dns_next
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|struct
name|dn_seq
modifier|*
modifier|*
name|base
decl_stmt|,
modifier|*
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|base
operator|=
operator|(
expr|struct
name|dn_seq
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|*
sizeof|sizeof
expr|*
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|ep
operator|=
name|base
expr_stmt|;
for|for
control|(
name|ds
operator|=
name|dns
init|;
name|ds
condition|;
name|ds
operator|=
name|ds
operator|->
name|dns_next
control|)
operator|*
name|ep
operator|++
operator|=
name|ds
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|i
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|,
name|dns_compar
argument_list|)
expr_stmt|;
name|bp
operator|=
name|base
expr_stmt|;
name|ds
operator|=
name|dns
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
name|ds
operator|->
name|dns_next
operator|=
operator|*
name|bp
expr_stmt|;
name|ds
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
name|ds
operator|->
name|dns_next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|req
operator|=
operator|(
expr|struct
name|type_DASE_Callback__REQ
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|req
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
empty_stmt|;
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|req
condition|)
name|free_DASE_Callback__REQ
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
condition|)
name|free_DASE_Callback__RSP
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
condition|)
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
name|dn_seq_free
argument_list|(
name|dns
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|req
operator|->
name|string
operator|=
name|str2qb
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|dp
operator|=
operator|&
name|req
operator|->
name|choices
expr_stmt|;
for|for
control|(
init|;
name|dns
condition|;
name|dns
operator|=
name|ds
control|)
block|{
specifier|register
name|struct
name|element_DASE_3
modifier|*
name|d3
decl_stmt|;
specifier|register
name|struct
name|type_DASE_Pair
modifier|*
name|pair
decl_stmt|;
if|if
condition|(
operator|(
name|d3
operator|=
operator|(
expr|struct
name|element_DASE_3
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|d3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
operator|*
name|dp
operator|=
name|d3
operator|,
name|dp
operator|=
operator|&
name|d3
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|pair
operator|=
operator|(
expr|struct
name|type_DASE_Pair
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|pair
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|d3
operator|->
name|Pair
operator|=
name|pair
expr_stmt|;
name|dn_print
argument_list|(
name|nps
argument_list|,
name|dns
operator|->
name|dns_dn
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|nps
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|*
operator|--
name|nps
operator|->
name|ps_ptr
operator|=
name|NULL
operator|,
name|nps
operator|->
name|ps_cnt
operator|++
expr_stmt|;
name|pair
operator|->
name|complete
operator|=
name|str2qb
argument_list|(
name|nps
operator|->
name|ps_base
argument_list|,
name|strlen
argument_list|(
name|nps
operator|->
name|ps_base
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nps
operator|->
name|ps_ptr
operator|=
name|nps
operator|->
name|ps_base
operator|,
name|nps
operator|->
name|ps_cnt
operator|=
name|nps
operator|->
name|ps_bufsiz
expr_stmt|;
name|ufn_dn_print_aux
argument_list|(
name|nps
argument_list|,
name|dns
operator|->
name|dns_dn
argument_list|,
name|dn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|nps
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|*
operator|--
name|nps
operator|->
name|ps_ptr
operator|=
name|NULL
operator|,
name|nps
operator|->
name|ps_cnt
operator|++
expr_stmt|;
name|pair
operator|->
name|friendly
operator|=
name|str2qb
argument_list|(
name|nps
operator|->
name|ps_base
argument_list|,
name|strlen
argument_list|(
name|nps
operator|->
name|ps_base
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nps
operator|->
name|ps_ptr
operator|=
name|nps
operator|->
name|ps_base
operator|,
name|nps
operator|->
name|ps_cnt
operator|=
name|nps
operator|->
name|ps_bufsiz
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|complete
operator|==
name|NULL
operator|||
name|pair
operator|->
name|friendly
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|ds
operator|=
name|dns
operator|->
name|dns_next
expr_stmt|;
name|dn_free
argument_list|(
name|dns
operator|->
name|dns_dn
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dns
argument_list|)
expr_stmt|;
block|}
name|dns
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|encode_DASE_Callback__REQ
argument_list|(
operator|&
name|pe
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULLCP
argument_list|,
name|req
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"encode_DASE_Callback__REQ: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|pe2ps
argument_list|(
name|ps
argument_list|,
name|pe
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"pe2ps: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|DASE_Message
argument_list|,
name|pe
argument_list|,
literal|"message"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_DASE_Callback__REQ
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|req
operator|=
name|NULL
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|ps2pe
argument_list|(
name|ps
argument_list|)
operator|)
operator|==
name|NULLPE
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps2pe: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode_DASE_Callback__RSP
argument_list|(
name|pe
argument_list|,
literal|1
argument_list|,
name|NULLIP
argument_list|,
name|NULLVP
argument_list|,
operator|&
name|rsp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
name|NULLCP
argument_list|,
literal|"decode_DASE_Callback__RSP: %s"
argument_list|,
name|PY_pepy
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PLOGP
argument_list|(
name|pgm_log
argument_list|,
name|DASE_Message
argument_list|,
name|pe
argument_list|,
literal|"message"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dq
operator|=
operator|&
name|dns
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|rsp
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
operator|(
expr|struct
name|dn_seq
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ds
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
operator|*
name|dq
operator|=
name|ds
operator|,
name|dq
operator|=
operator|&
name|ds
operator|->
name|dns_next
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|qb2str
argument_list|(
name|rp
operator|->
name|IA5String
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|ds
operator|->
name|dns_dn
operator|=
name|str2dn
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|free_DASE_Callback__RSP
argument_list|(
name|rsp
argument_list|)
expr_stmt|;
name|pe_free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
return|return
name|dns
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dns_compar
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|dn_seq
modifier|*
modifier|*
name|a
decl_stmt|,
decl|*
modifier|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|DN
name|adn
decl_stmt|,
name|bdn
decl_stmt|;
for|for
control|(
name|adn
operator|=
operator|(
operator|*
name|a
operator|)
operator|->
name|dns_dn
init|;
name|adn
operator|->
name|dn_parent
condition|;
name|adn
operator|=
name|adn
operator|->
name|dn_parent
control|)
continue|continue;
for|for
control|(
name|bdn
operator|=
operator|(
operator|*
name|b
operator|)
operator|->
name|dns_dn
init|;
name|bdn
operator|->
name|dn_parent
condition|;
name|bdn
operator|=
name|bdn
operator|->
name|dn_parent
control|)
continue|continue;
name|i
operator|=
name|rdn_cmp
argument_list|(
name|adn
operator|->
name|dn_rdn
argument_list|,
name|bdn
operator|->
name|dn_rdn
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|==
operator|(
operator|-
literal|1
operator|)
operator|||
name|i
operator|==
literal|1
condition|?
name|i
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|DNS
name|just_say_no
parameter_list|(
name|dns
parameter_list|,
name|dn
parameter_list|,
name|s
parameter_list|)
name|DNS
name|dns
decl_stmt|;
name|DN
name|dn
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|dn_seq_free
argument_list|(
name|dns
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|PE
name|name2psap
parameter_list|(
name|dn
parameter_list|)
name|DN
name|dn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|AttributeType
name|at
decl_stmt|;
name|PE
name|pe
decl_stmt|;
specifier|static
name|struct
name|ds_read_arg
name|read_arg
init|=
block|{
name|default_common_args
block|,
name|NULLDN
block|,
comment|/* read_arg DN */
block|{
comment|/* entry info selection */
name|FALSE
block|,
name|NULLATTR
block|,
name|EIS_ATTRIBUTESANDVALUES
block|}
block|}
decl_stmt|;
name|struct
name|DSError
name|error
decl_stmt|;
name|struct
name|ds_read_result
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|AttrT_new
argument_list|(
name|DSAADDRESS_OID
argument_list|)
operator|)
operator|==
name|NULLAttrT
condition|)
block|{
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"build of attribute failed (%s)"
argument_list|,
name|DSAADDRESS_OID
argument_list|)
expr_stmt|;
return|return
name|NULLPE
return|;
block|}
name|read_arg
operator|.
name|rda_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_prio
operator|=
name|SVC_PRIO_HIGH
expr_stmt|;
name|read_arg
operator|.
name|rda_object
operator|=
name|dn
expr_stmt|;
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_select
operator|=
name|as_comp_new
argument_list|(
name|AttrT_cpy
argument_list|(
name|at
argument_list|)
argument_list|,
name|NULLAV
argument_list|,
name|NULLACL_INFO
argument_list|)
expr_stmt|;
name|i
operator|=
name|ds_read
argument_list|(
operator|&
name|read_arg
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|AttrT_free
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|as_free
argument_list|(
name|read_arg
operator|.
name|rda_eis
operator|.
name|eis_select
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|DS_OK
condition|)
block|{
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"DAP lookup failed (%s)"
argument_list|,
name|dn2str
argument_list|(
name|dn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULLPE
return|;
block|}
if|if
condition|(
name|result
operator|.
name|rdr_entry
operator|.
name|ent_attr
operator|==
name|NULLATTR
condition|)
block|{
name|PY_advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no '%s' attribute in entry '%s'"
argument_list|,
name|DSAADDRESS_OID
argument_list|,
name|dn2str
argument_list|(
name|dn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULLPE
return|;
block|}
name|pe
operator|=
name|grab_pe
argument_list|(
operator|&
name|result
operator|.
name|rdr_entry
operator|.
name|ent_attr
operator|->
name|attr_value
operator|->
name|avseq_av
argument_list|)
expr_stmt|;
name|as_free
argument_list|(
name|result
operator|.
name|rdr_entry
operator|.
name|ent_attr
argument_list|)
expr_stmt|;
return|return
name|pe
return|;
block|}
end_function

begin_comment
comment|/*
comment|INIT */
end_comment

begin_expr_stmt
specifier|static
name|arginit
argument_list|(
argument|vec
argument_list|)
name|char
operator|*
operator|*
name|vec
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|argp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
modifier|*
name|argptr
decl_stmt|,
modifier|*
name|args
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|struct
name|TSAPaddr
modifier|*
name|ta
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pgmname
operator|=
name|rindex
argument_list|(
operator|*
name|vec
argument_list|,
literal|'/'
argument_list|)
condition|)
name|pgmname
operator|++
expr_stmt|;
if|if
condition|(
name|pgmname
operator|==
name|NULL
operator|||
operator|*
name|pgmname
operator|==
name|NULL
condition|)
name|pgmname
operator|=
operator|*
name|vec
expr_stmt|;
name|isodetailor
argument_list|(
name|pgmname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
name|quipu_syntaxes
argument_list|()
expr_stmt|;
name|argp
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|argp
operator|++
index|]
operator|=
name|pgmname
expr_stmt|;
for|for
control|(
name|argptr
operator|=
name|vec
operator|,
name|argptr
operator|++
init|;
name|ap
operator|=
operator|*
name|argptr
condition|;
name|argptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|ap
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'u'
case|:
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|argptr
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
break|break;
continue|continue;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|argptr
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
break|break;
name|args
index|[
name|argp
operator|++
index|]
operator|=
literal|"-c"
expr_stmt|;
name|args
index|[
name|argp
operator|++
index|]
operator|=
name|ap
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
break|break;
block|}
name|args
index|[
name|argp
index|]
operator|=
name|NULLCP
expr_stmt|;
name|dsap_init
argument_list|(
operator|&
name|argp
argument_list|,
operator|(
name|argptr
operator|=
name|args
operator|,
operator|&
name|argptr
operator|)
argument_list|)
expr_stmt|;
name|userdn
operator|=
name|NULLDN
operator|,
name|passwd
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vec
operator|++
init|;
name|ap
operator|=
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|ap
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -a address"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ta
operator|=
name|str2taddr
argument_list|(
name|ap
argument_list|)
operator|)
operator|==
name|NULLTA
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad address \"%s\""
argument_list|,
name|ap
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
name|prebind
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -c DSA-name-or-address"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -u username"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|userdn
operator|=
name|str2dn
argument_list|(
operator|*
name|ap
operator|!=
literal|'@'
condition|?
name|ap
else|:
name|ap
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid DN for username: %s"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
name|strlen
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|vec
operator|)
operator|==
name|NULL
operator|||
operator|*
name|ap
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s -p passwd"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|passwd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
name|strlen
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown switch -%s"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [switches]"
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ta
operator|==
name|NULL
operator|&&
operator|(
name|ta
operator|=
name|str2taddr
argument_list|(
name|ns_address
argument_list|)
operator|)
operator|==
name|NULLTA
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad default address \"%s\""
argument_list|,
name|ns_address
argument_list|)
expr_stmt|;
name|tas
operator|=
operator|*
name|ta
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
operator|(
name|nps
operator|=
name|ps_alloc
argument_list|(
name|str_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"ps_alloc: out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_setup
argument_list|(
name|nps
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"str_setup: %s"
argument_list|,
name|ps_error
argument_list|(
name|ps
operator|->
name|ps_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|envinit
argument_list|()
block|{
name|int
name|i
block|,
name|sd
block|;
name|nbits
operator|=
name|getdtablesize
argument_list|()
block|;
if|if
condition|(
name|debug
operator|==
literal|0
operator|&&
operator|!
operator|(
name|debug
operator|=
name|isatty
argument_list|(
literal|2
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OK
case|:
break|break;
default|default:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
unit|}  	(
name|void
end_expr_stmt

begin_expr_stmt
unit|)
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|sd
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|)
operator|,
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SETSID
end_ifdef

begin_if
if|if
condition|(
name|setsid
argument_list|()
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|LLOG_EXCEPTIONS
argument_list|,
literal|"failed"
argument_list|,
literal|"setsid"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCNOTTY
end_ifdef

begin_if
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|sd
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|}     else
name|ll_dbinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_comment
comment|/* damn YP... */
end_comment

begin_for
for|for
control|(
name|sd
operator|=
literal|3
init|;
name|sd
operator|<
name|nbits
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|pgm_log
operator|->
name|ll_fd
operator|!=
name|sd
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ll_hdinit
argument_list|(
name|pgm_log
argument_list|,
name|pgmname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|advise
argument_list|(
name|LLOG_NOTICE
argument_list|,
name|NULLCP
argument_list|,
literal|"starting"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*
comment|ERRORS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
unit|static
name|void
name|adios
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|LLOG_FATAL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|adios
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_function
specifier|static
name|void
name|advise
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|code
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|_ll_log
argument_list|(
name|pgm_log
argument_list|,
name|code
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|advise
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|advise
argument_list|(
name|code
argument_list|,
name|what
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|void
name|ts_adios
parameter_list|(
name|td
parameter_list|,
name|event
parameter_list|)
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
block|{
name|ts_advise
argument_list|(
name|td
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|void
name|ts_advise
parameter_list|(
name|td
parameter_list|,
name|code
parameter_list|,
name|event
parameter_list|)
specifier|register
name|struct
name|TSAPdisconnect
modifier|*
name|td
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_cc
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%s] %*.*s"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_cc
argument_list|,
name|td
operator|->
name|td_data
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"[%s]"
argument_list|,
name|TErrString
argument_list|(
name|td
operator|->
name|td_reason
argument_list|)
argument_list|)
expr_stmt|;
name|advise
argument_list|(
name|code
argument_list|,
name|NULLCP
argument_list|,
literal|"%s: %s"
argument_list|,
name|event
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

