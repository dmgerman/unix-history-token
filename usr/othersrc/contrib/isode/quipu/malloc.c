begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* malloc.c - Quipu DSA specific memory management */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/malloc.c,v 7.3 91/02/22 09:39:28 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/quipu/RCS/malloc.c,v 7.3 91/02/22 09:39:28 mrose Interim $  *  *  * $Log:	malloc.c,v $  * Revision 7.3  91/02/22  09:39:28  mrose  * Interim 6.8  *   * Revision 7.2  90/10/17  11:54:25  mrose  * sync  *   * Revision 7.1  90/07/09  14:46:17  mrose  * sync  *   * Revision 7.0  89/11/23  22:20:55  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|"quipu/malloc.h"
end_include

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|malloc_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|QUIPU_MALLOC
end_ifdef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|SFD
name|attempt_restart
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOCDEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|sun3
end_ifdef

begin_define
define|#
directive|define
name|MALLOCSTACK
end_define

begin_include
include|#
directive|include
file|<frame.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sun4
end_ifdef

begin_define
define|#
directive|define
name|MALLOCSTACK
end_define

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOCDEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOCSTACK
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOCTRACE
end_ifndef

begin_define
define|#
directive|define
name|MALLOCTRACE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MALLOCSTACK */
end_comment

begin_define
define|#
directive|define
name|write_stack
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOCSTACK */
end_comment

begin_define
define|#
directive|define
name|MAXHEAP
value|100
end_define

begin_comment
comment|/* Number of heaps */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD42
end_ifndef

begin_define
define|#
directive|define
name|PAGESIZE
value|0x2000
end_define

begin_comment
comment|/* The systems memory page size */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PAGESIZE
value|pagesize
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ALIGN
parameter_list|(
name|x
parameter_list|)
value|(((x) + (sizeof(char *) - 1))& ~(sizeof(char *) - 1))
end_define

begin_define
define|#
directive|define
name|PAGEALIGN
parameter_list|(
name|x
parameter_list|)
value|(((x) + (PAGESIZE-1))& ~(PAGESIZE-1))
end_define

begin_define
define|#
directive|define
name|SMALLMAX
value|(65535 - PAGESIZE)
end_define

begin_comment
comment|/* largest block a short can reference */
end_comment

begin_struct
struct|struct
name|header
block|{
union|union
block|{
struct|struct
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|size
decl_stmt|;
block|}
name|small
struct|;
name|unsigned
name|int
name|big
decl_stmt|;
block|}
name|un
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|bigsize
value|un.big
end_define

begin_define
define|#
directive|define
name|smallsize
value|un.small.size
end_define

begin_define
define|#
directive|define
name|use
value|un.small.control
end_define

begin_define
define|#
directive|define
name|INUSE
value|0x1000
end_define

begin_define
define|#
directive|define
name|USED
parameter_list|(
name|x
parameter_list|)
value|(x->use& INUSE)
end_define

begin_comment
comment|/* sizes chosen for anticipated QUIPU behaviour */
end_comment

begin_define
define|#
directive|define
name|BUCKETS
value|8
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|sizes
index|[
name|BUCKETS
index|]
init|=
block|{
literal|0
block|,
literal|12
block|,
literal|24
block|,
literal|68
block|,
literal|512
block|,
literal|1028
block|,
literal|8204
block|,
name|MAXINT
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|freelist
block|{
name|struct
name|header
modifier|*
name|block
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|struct
name|freelist
modifier|*
name|next
decl_stmt|;
name|struct
name|freelist
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|freehead
block|{
name|struct
name|header
name|head
decl_stmt|;
name|struct
name|freelist
modifier|*
name|flist
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|freelist
name|heaps
index|[
name|MAXHEAP
index|]
index|[
name|BUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|freelist
modifier|*
name|heapptr
index|[
name|MAXHEAP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|freelist
name|bigmem
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|&
name|bigmem
block|,
operator|&
name|bigmem
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|freelist
modifier|*
name|bigfree
init|=
operator|&
name|bigmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|freelist
name|freemem
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|&
name|freemem
block|,
operator|&
name|freemem
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|freelist
modifier|*
name|listfree
init|=
operator|&
name|freemem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|first_malloc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|top_mem
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pagesize
init|=
literal|0x2000
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|caddr_t
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOCTRACE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|malloc_started
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|malloc_fname
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOCTRACE
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUIPU_MALLOC */
end_comment

begin_macro
name|start_malloc_trace
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"TRACE_MEMORY"
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
operator|||
operator|(
operator|*
name|env
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|malloc_started
condition|)
block|{
if|if
condition|(
name|f
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|malloc_fname
operator|=
literal|"memory.out"
expr_stmt|;
else|else
name|malloc_fname
operator|=
name|f
expr_stmt|;
name|malloc_file
operator|=
name|creat
argument_list|(
name|malloc_fname
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
name|malloc_started
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|malloc_file
operator|=
name|open
argument_list|(
name|malloc_fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|malloc_file
argument_list|,
literal|0l
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|malloc_file
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|stop_malloc_trace
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|MALLOCTRACE
if|if
condition|(
name|malloc_file
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|malloc_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|malloc_file
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|QUIPU_MALLOC
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOCTRACE
end_ifdef

begin_expr_stmt
specifier|static
name|write_string
argument_list|(
argument|p
argument_list|)
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|malloc_file
condition|)
return|return;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|++
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|malloc_file
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|write_addr
argument_list|(
argument|addr
argument_list|)
name|char
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|malloc_file
condition|)
return|return;
name|x
operator|=
operator|(
name|int
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|malloc_file
argument_list|,
literal|"0 "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
condition|)
operator|*
name|ptr
operator|++
operator|=
name|hex
index|[
name|x
operator|%
literal|16
index|]
operator|,
name|x
operator|/=
literal|16
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|buf
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|malloc_file
argument_list|,
operator|--
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|malloc_file
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|write_int
argument_list|(
argument|x
argument_list|)
name|unsigned
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|dec
index|[]
init|=
literal|"0123456789"
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|malloc_file
condition|)
return|return;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|malloc_file
argument_list|,
literal|"0 "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|x
operator|>
literal|0
condition|)
operator|*
name|ptr
operator|++
operator|=
name|dec
index|[
name|x
operator|%
literal|10
index|]
operator|,
name|x
operator|/=
literal|10
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|buf
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|malloc_file
argument_list|,
operator|--
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|malloc_file
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|log_realloc
argument_list|(
argument|oldlen
argument_list|,
argument|newlen
argument_list|,
argument|bsize
argument_list|,
argument|addr
argument_list|)
name|unsigned
name|oldlen
operator|,
name|newlen
operator|,
name|bsize
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|write_string
argument_list|(
literal|"realloc of "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|oldlen
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"at "
argument_list|)
expr_stmt|;
name|write_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"realloc-to of "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"gets "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"at "
argument_list|)
expr_stmt|;
name|write_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|print_free_list
argument_list|(
argument|heap
argument_list|)
name|unsigned
name|heap
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|freelist
modifier|*
name|top
decl_stmt|;
name|struct
name|freelist
modifier|*
name|ptr
decl_stmt|;
name|write_string
argument_list|(
literal|"free list for heap "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|heap
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
control|)
block|{
name|top
operator|=
operator|&
name|heaps
index|[
name|heap
index|]
index|[
name|i
index|]
expr_stmt|;
name|write_int
argument_list|(
name|sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|top
operator|->
name|next
init|;
name|ptr
operator|!=
name|top
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|write_int
argument_list|(
name|ptr
operator|->
name|size
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOCSTACK
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|sun4
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|write_stack
argument_list|(
argument|x
argument_list|)
name|char
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|frame
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|malloc_file
condition|)
return|return;
ifdef|#
directive|ifdef
name|sun3
for|for
control|(
name|fp
operator|=
operator|(
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|x
operator|-
literal|2
operator|)
operator|)
operator|->
name|next
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|fr_savfp
control|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sun4
for|for
control|(
name|fp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
init|;
name|fp
operator|->
name|fr_savfp
condition|;
name|fp
operator|=
name|fp
operator|->
name|fr_savfp
control|)
endif|#
directive|endif
block|{
name|write_string
argument_list|(
literal|"C "
argument_list|)
expr_stmt|;
name|write_addr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|fr_savpc
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOCSTACK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOCTRACE */
end_comment

begin_define
define|#
directive|define
name|return_freelist
parameter_list|(
name|z
parameter_list|)
value|{ \ 	z->next = listfree->next; \ 	z->prev = listfree; \ 	listfree->next->prev = z; \ 	listfree->next = z; }
end_define

begin_function
specifier|static
name|struct
name|freelist
modifier|*
name|new_freelist
parameter_list|()
block|{
name|struct
name|freelist
modifier|*
name|flist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|freelist
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|flist
operator|=
operator|(
expr|struct
name|freelist
operator|*
operator|)
name|sbrk
argument_list|(
name|PAGESIZE
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|freelist
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* there are 100s of places where Quipu would choke on a naff malloc */
name|attempt_restart
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|freelist
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|top_mem
operator|=
operator|(
name|char
operator|*
operator|)
name|flist
operator|+
name|PAGESIZE
expr_stmt|;
name|next
operator|=
operator|(
expr|struct
name|freelist
operator|*
operator|)
name|flist
expr_stmt|;
name|next
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|freelist
argument_list|)
init|;
name|i
operator|<
name|PAGESIZE
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|freelist
argument_list|)
control|)
block|{
name|return_freelist
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|flist
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|big_malloc
parameter_list|(
name|realsize
parameter_list|)
comment|/* used for mallocs of> MAXSMALL */
name|unsigned
name|realsize
decl_stmt|;
block|{
name|unsigned
name|blocksize
decl_stmt|;
name|struct
name|freelist
modifier|*
name|flist
decl_stmt|;
name|struct
name|header
modifier|*
name|head
init|=
operator|(
expr|struct
name|header
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
for|for
control|(
name|flist
operator|=
name|bigfree
operator|->
name|next
init|;
name|flist
operator|!=
name|bigfree
condition|;
name|flist
operator|=
name|flist
operator|->
name|next
control|)
block|{
if|if
condition|(
name|flist
operator|->
name|size
operator|>=
name|realsize
condition|)
block|{
name|head
operator|=
name|flist
operator|->
name|block
expr_stmt|;
name|flist
operator|->
name|prev
operator|->
name|next
operator|=
name|flist
operator|->
name|next
expr_stmt|;
name|flist
operator|->
name|next
operator|->
name|prev
operator|=
name|flist
operator|->
name|prev
expr_stmt|;
name|return_freelist
argument_list|(
name|flist
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|head
operator|==
operator|(
expr|struct
name|header
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* go and get on then !!! */
name|blocksize
operator|=
name|PAGEALIGN
argument_list|(
name|realsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|head
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
name|sbrk
argument_list|(
operator|(
name|int
operator|)
name|blocksize
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|header
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* there are 100s of places where Quipu would choke on a naff malloc */
name|attempt_restart
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|top_mem
operator|=
operator|(
name|char
operator|*
operator|)
name|head
operator|+
name|blocksize
expr_stmt|;
name|head
operator|->
name|bigsize
operator|=
name|blocksize
operator||
literal|0x01
expr_stmt|;
block|}
else|else
name|head
operator|->
name|bigsize
operator||=
literal|0x01
expr_stmt|;
name|mem
operator|=
operator|(
name|char
operator|*
operator|)
name|head
operator|+
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_string
argument_list|(
literal|"gets "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|head
operator|->
name|bigsize
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"at "
argument_list|)
expr_stmt|;
name|write_addr
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|big_free
argument_list|(
argument|ptr
argument_list|)
expr|struct
name|header
operator|*
name|ptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|freelist
modifier|*
name|next
decl_stmt|;
name|struct
name|freehead
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|listfree
operator|->
name|next
operator|==
name|listfree
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|new_freelist
argument_list|()
operator|)
operator|==
operator|(
expr|struct
name|freelist
operator|*
operator|)
literal|0
condition|)
return|return;
block|}
else|else
block|{
name|next
operator|=
name|listfree
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|->
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|->
name|prev
operator|=
name|next
operator|->
name|prev
expr_stmt|;
block|}
name|ptr
operator|->
name|bigsize
operator|&=
operator|~
literal|1
expr_stmt|;
name|next
operator|->
name|size
operator|=
name|ptr
operator|->
name|bigsize
expr_stmt|;
name|next
operator|->
name|block
operator|=
name|ptr
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|bigfree
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|bigfree
expr_stmt|;
name|bigfree
operator|->
name|next
operator|->
name|prev
operator|=
name|next
expr_stmt|;
name|bigfree
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|x
operator|=
operator|(
expr|struct
name|freehead
operator|*
operator|)
name|ptr
expr_stmt|;
name|x
operator|->
name|flist
operator|=
name|next
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|add_free
argument_list|(
argument|x
argument_list|)
expr|struct
name|header
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|freelist
modifier|*
name|next
decl_stmt|,
modifier|*
name|c
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|p
init|=
name|sizes
decl_stmt|;
name|x
operator|->
name|use
operator|&=
operator|~
name|INUSE
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|heapptr
index|[
name|x
operator|->
name|use
index|]
operator|)
operator|==
operator|(
expr|struct
name|freelist
operator|*
operator|)
literal|0
condition|)
name|c
operator|=
name|heapptr
index|[
name|x
operator|->
name|use
index|]
operator|=
name|heaps
index|[
name|x
operator|->
name|use
index|]
expr_stmt|;
while|while
condition|(
name|x
operator|->
name|smallsize
operator|>
operator|*
name|p
operator|++
condition|)
empty_stmt|;
name|c
operator|=
operator|&
name|c
index|[
operator|(
name|p
operator|-
literal|1
operator|)
operator|-
name|sizes
index|]
expr_stmt|;
if|if
condition|(
name|listfree
operator|->
name|next
operator|==
name|listfree
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|new_freelist
argument_list|()
operator|)
operator|==
operator|(
expr|struct
name|freelist
operator|*
operator|)
literal|0
condition|)
return|return;
block|}
else|else
block|{
name|next
operator|=
name|listfree
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|->
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|->
name|prev
operator|=
name|next
operator|->
name|prev
expr_stmt|;
block|}
name|next
operator|->
name|size
operator|=
name|x
operator|->
name|smallsize
expr_stmt|;
name|next
operator|->
name|block
operator|=
name|x
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|c
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|next
operator|->
name|prev
operator|=
name|next
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|next
expr_stmt|;
operator|(
operator|(
expr|struct
name|freehead
operator|*
operator|)
name|x
operator|)
operator|->
name|flist
operator|=
name|next
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|remove_free
parameter_list|(
name|a
parameter_list|)
value|{ \ 	a->block->use |= INUSE;	\ 	a->prev->next = a->next; \ 	a->next->prev = a->prev; \ 	return_freelist(a); }
end_define

begin_function
specifier|static
name|struct
name|header
modifier|*
name|next_free_block
parameter_list|(
name|ptr
parameter_list|)
specifier|register
name|struct
name|header
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|struct
name|header
modifier|*
name|next
decl_stmt|;
name|next
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|ptr
operator|->
name|smallsize
operator|)
expr_stmt|;
if|if
condition|(
name|PAGEALIGN
argument_list|(
operator|(
name|int
operator|)
name|ptr
argument_list|)
operator|!=
name|PAGEALIGN
argument_list|(
operator|(
name|int
operator|)
name|next
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
expr|struct
name|header
operator|*
operator|)
literal|0
return|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|next
operator|<
name|top_mem
operator|)
operator|&&
operator|(
name|next
operator|->
name|use
operator|==
operator|(
name|ptr
operator|->
name|use
operator|&
operator|~
name|INUSE
operator|)
operator|)
condition|)
return|return
operator|(
name|next
operator|)
return|;
return|return
operator|(
expr|struct
name|header
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|use_block
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|if ((ptr->smallsize != size)&& (ptr->smallsize>= size + sizeof (struct freehead))) { \ 	register struct header *unext; \ 	unext = (struct header *)((char *)ptr + size); \ 	unext->smallsize = ptr->smallsize - size; \ 	unext->use = ptr->use& ~INUSE; \ 	ptr->smallsize = size; \ 	ptr->use |= INUSE; \ 	add_free (unext); }
end_define

begin_function
name|char
modifier|*
name|malloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|mem
decl_stmt|;
name|struct
name|header
modifier|*
name|head
decl_stmt|;
name|unsigned
name|realsize
decl_stmt|,
name|blocksize
decl_stmt|;
name|struct
name|freelist
modifier|*
name|top
decl_stmt|;
specifier|register
name|struct
name|freelist
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|p
init|=
name|sizes
decl_stmt|;
if|if
condition|(
name|mem_heap
operator|>=
name|MAXHEAP
condition|)
name|mem_heap
operator|=
name|MAXHEAP
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|freelist
operator|*
argument_list|)
condition|)
comment|/* memory will be used when freed for freelist !!! */
name|realsize
operator|=
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|freehead
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|realsize
operator|=
name|ALIGN
argument_list|(
name|size
argument_list|)
operator|+
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|realsize
operator|>=
name|SMALLMAX
condition|)
block|{
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_string
argument_list|(
literal|"malloc of "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|big_malloc
argument_list|(
name|realsize
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|first_malloc
condition|)
block|{
comment|/* set up freelist */
name|unsigned
name|x
decl_stmt|;
name|int
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD42
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXHEAP
condition|;
name|i
operator|++
control|)
block|{
name|heapptr
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|freelist
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BUCKETS
condition|;
name|j
operator|++
control|)
block|{
name|heaps
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|prev
operator|=
operator|&
name|heaps
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|heaps
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|next
operator|=
operator|&
name|heaps
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|heaps
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* align first sbrk to page boundary */
name|x
operator|=
operator|(
name|unsigned
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|PAGEALIGN
argument_list|(
name|x
argument_list|)
operator|-
name|x
expr_stmt|;
name|blocksize
operator|=
name|PAGEALIGN
argument_list|(
name|realsize
argument_list|)
operator|+
name|x
expr_stmt|;
if|if
condition|(
operator|(
name|head
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
name|sbrk
argument_list|(
operator|(
name|int
operator|)
name|blocksize
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|header
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* there are 100s of places where Quipu would choke on a naff malloc */
name|attempt_restart
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|head
operator|->
name|smallsize
operator|=
name|blocksize
expr_stmt|;
name|top_mem
operator|=
operator|(
name|char
operator|*
operator|)
name|head
operator|+
name|blocksize
expr_stmt|;
name|first_malloc
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|use
operator|=
name|INUSE
operator||
name|mem_heap
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|top
operator|=
name|heapptr
index|[
name|mem_heap
index|]
operator|)
operator|==
operator|(
expr|struct
name|freelist
operator|*
operator|)
literal|0
condition|)
goto|goto
name|allocate_more
goto|;
while|while
condition|(
name|size
operator|>
operator|*
name|p
operator|++
condition|)
empty_stmt|;
name|top
operator|=
operator|&
name|top
index|[
name|i
operator|=
operator|(
operator|(
name|p
operator|-
literal|1
operator|)
operator|-
name|sizes
operator|)
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|BUCKETS
condition|;
name|i
operator|++
operator|,
name|top
operator|++
control|)
block|{
for|for
control|(
name|ptr
operator|=
name|top
operator|->
name|next
init|;
name|ptr
operator|!=
name|top
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|size
operator|>=
name|realsize
condition|)
block|{
name|remove_free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|head
operator|=
name|ptr
operator|->
name|block
expr_stmt|;
goto|goto
name|return_memory
goto|;
block|}
block|}
block|}
name|allocate_more
label|:
empty_stmt|;
name|blocksize
operator|=
name|PAGEALIGN
argument_list|(
name|realsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|head
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
name|sbrk
argument_list|(
operator|(
name|int
operator|)
name|blocksize
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|header
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* there are 100s of places where Quipu would choke on a naff malloc */
name|attempt_restart
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|head
operator|->
name|smallsize
operator|=
name|blocksize
expr_stmt|;
name|top_mem
operator|=
operator|(
name|char
operator|*
operator|)
name|head
operator|+
name|blocksize
expr_stmt|;
name|head
operator|->
name|use
operator|=
name|INUSE
operator||
name|mem_heap
expr_stmt|;
block|}
name|return_memory
label|:
empty_stmt|;
name|use_block
argument_list|(
name|head
argument_list|,
name|realsize
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
name|char
operator|*
operator|)
name|head
operator|+
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_string
argument_list|(
literal|"malloc of "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"gets "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|head
operator|->
name|smallsize
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"at "
argument_list|)
expr_stmt|;
name|write_addr
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"heap "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|mem_heap
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_macro
name|free
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|header
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|struct
name|header
modifier|*
name|next
decl_stmt|;
name|ptr
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
operator|(
name|s
operator|-
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|smallsize
operator|&
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_string
argument_list|(
literal|"free of "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|ptr
operator|->
name|bigsize
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"at "
argument_list|)
expr_stmt|;
name|write_addr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"heap (big)\n"
argument_list|)
expr_stmt|;
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|big_free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_string
argument_list|(
literal|"free of "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|ptr
operator|->
name|smallsize
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"at "
argument_list|)
expr_stmt|;
name|write_addr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"heap "
argument_list|)
expr_stmt|;
name|write_int
argument_list|(
name|ptr
operator|->
name|use
operator|&
operator|~
name|INUSE
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|USED
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"freeing problem"
operator|)
argument_list|)
expr_stmt|;
return|return;
comment|/* already freed !!! */
block|}
comment|/* join forward free block in loop to catch previous back blocks ! */
while|while
condition|(
operator|(
name|next
operator|=
name|next_free_block
argument_list|(
name|ptr
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|header
operator|*
operator|)
literal|0
condition|)
block|{
name|ptr
operator|->
name|smallsize
operator|+=
name|next
operator|->
name|smallsize
expr_stmt|;
name|remove_free
argument_list|(
operator|(
operator|(
expr|struct
name|freehead
operator|*
operator|)
name|next
operator|)
operator|->
name|flist
argument_list|)
expr_stmt|;
block|}
name|add_free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|char
modifier|*
name|realloc
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|unsigned
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|mem
decl_stmt|;
specifier|register
name|unsigned
name|realsize
decl_stmt|;
name|struct
name|header
modifier|*
name|ptr
decl_stmt|;
name|struct
name|header
modifier|*
name|next
decl_stmt|;
name|unsigned
name|copysize
decl_stmt|;
name|ptr
operator|=
operator|(
expr|struct
name|header
operator|*
operator|)
operator|(
name|s
operator|-
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|smallsize
operator|&
literal|1
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"re-alloc of big block"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|copysize
operator|=
name|ptr
operator|->
name|bigsize
operator|&
operator|~
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|copysize
operator|=
name|ptr
operator|->
name|smallsize
expr_stmt|;
if|if
condition|(
operator|!
name|USED
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"re-alloc problem"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
name|realsize
operator|=
name|ALIGN
argument_list|(
name|n
argument_list|)
operator|+
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|realsize
operator|>=
name|SMALLMAX
condition|)
block|{
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"re-alloc in to big block"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|write_stack
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ptr
operator|->
name|smallsize
operator|>=
name|realsize
condition|)
block|{
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|log_realloc
argument_list|(
name|ptr
operator|->
name|smallsize
argument_list|,
name|realsize
argument_list|,
name|ptr
operator|->
name|smallsize
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|s
operator|)
return|;
block|}
comment|/* see if next block is free */
if|if
condition|(
operator|(
name|next
operator|=
name|next_free_block
argument_list|(
name|ptr
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|header
operator|*
operator|)
literal|0
condition|)
block|{
name|struct
name|header
modifier|*
name|top
decl_stmt|;
name|top
operator|=
name|next
expr_stmt|;
comment|/* join with other free blocks */
while|while
condition|(
operator|(
name|next
operator|=
name|next_free_block
argument_list|(
name|top
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|header
operator|*
operator|)
literal|0
condition|)
block|{
name|top
operator|->
name|smallsize
operator|+=
name|next
operator|->
name|smallsize
expr_stmt|;
name|remove_free
argument_list|(
operator|(
operator|(
expr|struct
name|freehead
operator|*
operator|)
name|next
operator|)
operator|->
name|flist
argument_list|)
expr_stmt|;
block|}
name|remove_free
argument_list|(
operator|(
operator|(
expr|struct
name|freehead
operator|*
operator|)
name|top
operator|)
operator|->
name|flist
argument_list|)
expr_stmt|;
comment|/* is it big enough ? */
if|if
condition|(
name|ptr
operator|->
name|smallsize
operator|+
name|top
operator|->
name|smallsize
operator|>=
name|realsize
condition|)
block|{
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|unsigned
name|savesize
decl_stmt|;
name|savesize
operator|=
name|ptr
operator|->
name|smallsize
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|->
name|smallsize
operator|+=
name|top
operator|->
name|smallsize
expr_stmt|;
name|use_block
argument_list|(
name|ptr
argument_list|,
name|realsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOCTRACE
name|log_realloc
argument_list|(
name|savesize
argument_list|,
name|realsize
argument_list|,
name|ptr
operator|->
name|smallsize
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|s
operator|)
return|;
block|}
else|else
comment|/* return to free list */
name|add_free
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
name|out
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|mem
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
name|copysize
operator|-=
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|copysize
operator|=
name|MIN
argument_list|(
name|copysize
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|mem
argument_list|,
operator|(
name|int
operator|)
name|copysize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|calloc
parameter_list|(
name|n
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|n
decl_stmt|,
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|mem
decl_stmt|;
name|unsigned
name|x
decl_stmt|;
name|x
operator|=
name|n
operator|*
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|mem
operator|=
name|malloc
argument_list|(
name|x
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|mem
argument_list|,
operator|(
name|int
operator|)
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfree
parameter_list|(
name|mem
parameter_list|)
name|char
modifier|*
name|mem
decl_stmt|;
block|{
name|free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUIPUMALLOC */
end_comment

end_unit

