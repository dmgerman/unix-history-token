begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* get_dsa_info.c - Get DSA info given its distinguished name */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/quipu/RCS/get_dsa_info.c,v 7.5 91/03/09 11:56:59 mrose Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * $Header: /f/osi/quipu/RCS/get_dsa_info.c,v 7.5 91/03/09 11:56:59 mrose Exp $  *  *  * $Log:	get_dsa_info.c,v $  * Revision 7.5  91/03/09  11:56:59  mrose  * update  *   * Revision 7.4  91/02/22  09:39:25  mrose  * Interim 6.8  *   * Revision 7.3  90/10/17  11:54:22  mrose  * sync  *   * Revision 7.2  89/12/19  16:20:36  mrose  * sync  *   * Revision 7.1  89/11/24  16:21:59  mrose  * sync  *   * Revision 7.0  89/11/23  22:17:42  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *                                NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/read.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dua.h"
end_include

begin_include
include|#
directive|include
file|"quipu/bind.h"
end_include

begin_include
include|#
directive|include
file|"quipu/connection.h"
end_include

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DN
name|mydsadn
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|dn_print
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|oper_act
modifier|*
name|oper_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|di_block
modifier|*
name|di_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|oper_act
modifier|*
name|make_get_dsa_info_op
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Attr_Sequence
name|entry_find_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* *  This routine is used to read the info (including presentation address) *  for a dsa given its distinguished name. *  This is called during the DSA initialisation, to find the name THIS dsa. */
end_comment

begin_function
name|int
name|get_dsa_info
parameter_list|(
name|dn
parameter_list|,
name|dn_stack
parameter_list|,
name|err
parameter_list|,
name|di_p
parameter_list|)
name|DN
name|dn
decl_stmt|;
name|struct
name|dn_seq
modifier|*
name|dn_stack
decl_stmt|;
name|struct
name|DSError
modifier|*
name|err
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
block|{
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di_lookup
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|on
init|=
name|NULLOPER
decl_stmt|;
name|int
name|res
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"get_dsa_info()"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_in_dnseq
argument_list|(
name|dn
argument_list|,
name|dn_stack
argument_list|)
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"get_dsa_info - loop detected"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|dse_un
operator|.
name|dse_un_service
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_LOOPDETECT
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
comment|/* if asking about me, use my cached entry */
if|if
condition|(
name|dn_cmp
argument_list|(
name|dn
argument_list|,
name|mydsadn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"get_dsa_info - referring to self :-)"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|dse_un
operator|.
name|dse_un_service
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_DITERROR
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
operator|(
operator|*
name|di_p
operator|)
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_type
operator|=
name|DI_TASK
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_dn
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_target
operator|=
name|NULLDN
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_reftype
operator|=
name|RT_SUBORDINATE
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_rdn_resolved
operator|=
name|CR_RDNRESOLVED_NOTDEFINED
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_aliasedRDNs
operator|=
name|CR_NOALIASEDRDNS
expr_stmt|;
comment|/*     *  Check for a GetDSAInfo operation already in the pipeline.     */
for|for
control|(
name|di_tmp
operator|=
name|deferred_dis
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
if|if
condition|(
name|dn_cmp
argument_list|(
name|dn
argument_list|,
name|di_tmp
operator|->
name|di_dn
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_state
operator|=
name|DI_DEFERRED
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
operator|=
name|NULLENTRY
expr_stmt|;
comment|/* link to the performing operation */
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_perform
operator|=
name|di_tmp
operator|->
name|di_perform
expr_stmt|;
comment|/* Add to wake list leaving global block first to be woken */
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_wake_next
operator|=
name|di_tmp
operator|->
name|di_wake_next
expr_stmt|;
name|di_tmp
operator|->
name|di_wake_next
operator|=
operator|(
operator|*
name|di_p
operator|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"Found global deferred di_block:"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|(
operator|*
name|di_p
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DS_CONTINUE
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|res
operator|=
name|really_find_entry
argument_list|(
name|dn
argument_list|,
name|TRUE
argument_list|,
name|dn_stack
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
operator|)
argument_list|,
name|err
argument_list|,
operator|&
operator|(
name|di_lookup
operator|)
argument_list|)
operator|)
operator|==
name|DS_OK
condition|)
comment|/* is it really OK ??? */
if|if
condition|(
operator|(
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
operator|->
name|e_data
operator|==
name|E_TYPE_CONSTRUCTOR
operator|)
operator|||
operator|(
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
operator|->
name|e_dsainfo
operator|->
name|dsa_addr
operator|==
name|NULLPA
operator|)
condition|)
block|{
name|DN
name|dn_found
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"rfe returned a constructor"
operator|)
argument_list|)
expr_stmt|;
name|dn_found
operator|=
name|get_copy_dn
argument_list|(
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
argument_list|)
expr_stmt|;
name|res
operator|=
name|constructor_dsa_info
argument_list|(
name|dn_found
argument_list|,
name|dn_stack
argument_list|,
name|FALSE
argument_list|,
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
argument_list|,
name|err
argument_list|,
operator|&
operator|(
name|di_lookup
operator|)
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn_found
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_entry
operator|->
name|e_refcount
operator|++
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|DS_OK
case|:
comment|/* really_find_entry has found the entry and placed it in di_entry */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"get_dsa_info - really_fe returns DS_OK"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_state
operator|=
name|DI_COMPLETE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|(
operator|*
name|di_p
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DS_OK
operator|)
return|;
case|case
name|DS_CONTINUE
case|:
comment|/* 	*  A list of di_blocks (di_lookup) has been generated by get_dsa_info. 	*  These should be used to chain the get_dsa_info operation. 	*  Attempt to generate an operation using the di_blocks returned 	*  and if successful, defer the current di_block to it. 	*/
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"gdi rfe returned DS_CONT:"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
name|di_lookup
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|on
operator|=
name|make_get_dsa_info_op
argument_list|(
name|dn
argument_list|,
name|di_lookup
argument_list|)
operator|)
operator|==
name|NULLOPER
condition|)
block|{
comment|/* Flake out screaming */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"make_get_dsa_info_op failed for get_dsa_info"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|di_p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_UNABLETOPROCEED
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|!=
name|OK
condition|)
block|{
comment|/* Flake out screaming */
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"send_op failed for get_dsa_info"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|di_p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_UNABLETOPROCEED
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
name|di_tmp
operator|=
name|di_alloc
argument_list|()
expr_stmt|;
name|di_tmp
operator|->
name|di_dn
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"get_dsa_info allocates di_block with dn[%x]"
operator|,
name|di_tmp
operator|->
name|di_dn
operator|)
argument_list|)
expr_stmt|;
name|di_tmp
operator|->
name|di_state
operator|=
name|DI_DEFERRED
expr_stmt|;
name|di_tmp
operator|->
name|di_type
operator|=
name|DI_GLOBAL
expr_stmt|;
name|di_tmp
operator|->
name|di_perform
operator|=
name|on
expr_stmt|;
name|on
operator|->
name|on_wake_list
operator|=
name|di_tmp
expr_stmt|;
comment|/* wake globals first */
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_state
operator|=
name|DI_DEFERRED
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_perform
operator|=
name|on
expr_stmt|;
comment|/* Add to wake list leaving global block first to be woken */
operator|(
operator|*
name|di_p
operator|)
operator|->
name|di_wake_next
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
name|di_tmp
operator|->
name|di_wake_next
operator|=
operator|(
operator|*
name|di_p
operator|)
expr_stmt|;
name|di_tmp
operator|->
name|di_next
operator|=
name|deferred_dis
expr_stmt|;
name|deferred_dis
operator|=
name|di_tmp
expr_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"gdi DS_CONT: generated:"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|di_list_log
argument_list|(
operator|(
operator|*
name|di_p
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|DS_CONTINUE
operator|)
return|;
case|case
name|DS_X500_ERROR
case|:
comment|/* something wrong with the request - err should be filled out */
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"gdi X500_ERROR"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|di_p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Unexpected return from read_dsa_info"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|di_p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|di_p
operator|)
operator|=
name|NULL_DI_BLOCK
expr_stmt|;
name|err
operator|->
name|dse_type
operator|=
name|DSE_SERVICEERROR
expr_stmt|;
name|err
operator|->
name|ERR_SERVICE
operator|.
name|DSE_sv_problem
operator|=
name|DSE_SV_UNABLETOPROCEED
expr_stmt|;
return|return
operator|(
name|DS_X500_ERROR
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|dsa_info_result_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|EntryInfo
modifier|*
name|ent_res
decl_stmt|;
name|Entry
name|di_ent
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
name|struct
name|di_block
modifier|*
name|next_di
decl_stmt|;
name|struct
name|di_block
modifier|*
modifier|*
name|di_p
decl_stmt|;
name|Entry
name|cache_dsp_entry
parameter_list|()
function_decl|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"dsa_info_result_wakeup()"
operator|)
argument_list|)
expr_stmt|;
comment|/*     *  Cache the entry returned, flake out if it is not unravellable,     *  otherwise grab a reference to the unravelled entry.     */
name|ent_res
operator|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_result
operator|.
name|dr_res
operator|.
name|dcr_dsres
operator|.
name|res_rd
operator|.
name|rdr_entry
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|di_ent
operator|=
name|cache_dsp_entry
argument_list|(
name|ent_res
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"dsa_info_result_wakeup - cache_dsp_entry failure"
operator|)
argument_list|)
expr_stmt|;
comment|/* This could mean the cached entry was a SLAVE - if so why were we  	 * doing a get dsa info ?          */
name|dsa_info_error_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
return|return;
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"dsa_info_result_wakeup - cached dsa_info"
operator|)
argument_list|)
expr_stmt|;
comment|/*     *  First block on the wake up list should be the global marker.     *  Verify this and remove it.     */
if|if
condition|(
name|on
operator|->
name|on_wake_list
operator|->
name|di_type
operator|!=
name|DI_GLOBAL
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"First di_block to wake not global"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di_p
operator|=
operator|&
operator|(
name|deferred_dis
operator|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|deferred_dis
init|;
name|di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di
operator|=
operator|(
operator|*
name|di_p
operator|)
control|)
block|{
if|if
condition|(
name|di
operator|==
name|on
operator|->
name|on_wake_list
condition|)
break|break;
name|di_p
operator|=
operator|&
operator|(
name|di
operator|->
name|di_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|di
operator|==
name|NULL_DI_BLOCK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Global di_block wasn't on global list"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|di_p
operator|)
operator|=
name|di
operator|->
name|di_next
expr_stmt|;
block|}
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"dsa_info_result_wakeup - dealt with global block"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|di
operator|=
name|on
operator|->
name|on_wake_list
operator|->
name|di_wake_next
init|;
name|di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di
operator|=
name|next_di
control|)
block|{
name|next_di
operator|=
name|di
operator|->
name|di_wake_next
expr_stmt|;
name|di
operator|->
name|di_state
operator|=
name|DI_COMPLETE
expr_stmt|;
name|di
operator|->
name|di_entry
operator|=
name|di_ent
expr_stmt|;
name|di_ent
operator|->
name|e_refcount
operator|++
expr_stmt|;
switch|switch
condition|(
name|di
operator|->
name|di_type
condition|)
block|{
case|case
name|DI_OPERATION
case|:
if|if
condition|(
name|di
operator|->
name|di_oper
operator|==
name|NULLOPER
condition|)
block|{
name|di_free
argument_list|(
name|di
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|di
operator|->
name|di_oper
operator|->
name|on_state
operator|==
name|ON_DEFERRED
condition|)
block|{
if|if
condition|(
name|oper_chain
argument_list|(
name|di
operator|->
name|di_oper
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"oper_chain failed in dsa_info_wakeup"
operator|)
argument_list|)
expr_stmt|;
name|di_free
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DI_TASK
case|:
name|task_dsa_info_wakeup
argument_list|(
name|di
argument_list|)
expr_stmt|;
name|di_free
argument_list|(
name|di
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"get_dsa_info_aux - unknown di-type %d"
operator|,
name|di
operator|->
name|di_type
operator|)
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"dsa_info_result_wakeup - woke all blocks"
operator|)
argument_list|)
expr_stmt|;
comment|/*     *  Everthing should have been woken up by now so the di_blocks on     *  the wake list and the operation itself can be extracted.     */
name|di_free
argument_list|(
name|on
operator|->
name|on_wake_list
argument_list|)
expr_stmt|;
name|oper_extract
argument_list|(
name|on
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dsa_info_error_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|DSError
modifier|*
name|err
init|=
operator|&
operator|(
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
operator|)
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
comment|/*     *  Error can fall into 3 categories:     *    1) Problem with remote DSA performing operation - try another;     *    2) A referral error - follow the referral;     *    3) An error with the operation itself;     */
switch|switch
condition|(
name|err
operator|->
name|dse_type
condition|)
block|{
case|case
name|DSE_NOERROR
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"dsa_info_error_wakeup - No Error!"
operator|)
argument_list|)
expr_stmt|;
name|dsa_info_fail_wakeup
argument_list|(
name|on
argument_list|)
expr_stmt|;
return|return;
case|case
name|DSE_REFERRAL
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_NOTICE
argument_list|,
operator|(
literal|"dsa_info_error_wakeup - DAP Referral!"
operator|)
argument_list|)
expr_stmt|;
case|case
name|DSE_DSAREFERRAL
case|:
if|if
condition|(
name|oper_rechain
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
return|return;
comment|/* Fall through */
default|default:
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_DEBUG
argument_list|,
operator|(
literal|"dsa_info_error_wakeup - Assuming all non-referral errors are to be propogated"
operator|)
argument_list|)
expr_stmt|;
comment|/* Lose the di_block */
for|for
control|(
name|di
operator|=
name|on
operator|->
name|on_wake_list
init|;
name|di
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di
operator|=
name|di
operator|->
name|di_wake_next
control|)
block|{
switch|switch
condition|(
name|di
operator|->
name|di_type
condition|)
block|{
case|case
name|DI_OPERATION
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Should wake oper"
operator|)
argument_list|)
expr_stmt|;
name|oper_log
argument_list|(
name|di
operator|->
name|di_oper
argument_list|)
expr_stmt|;
break|break;
case|case
name|DI_TASK
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Should wake task"
operator|)
argument_list|)
expr_stmt|;
name|task_log
argument_list|(
name|di
operator|->
name|di_task
argument_list|)
expr_stmt|;
break|break;
case|case
name|DI_GLOBAL
case|:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Should wake global"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"dsa_info_error_wakeup - invalid di_type"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
block|}
end_block

begin_macro
name|dsa_info_fail_wakeup
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|oper_act
modifier|*
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*     *  Last attempt to get dsa info failed somehow.     *  If there are any more "di_block"s to attempt it must be     *  worth a go (perhaps this depends on the failure which     *  has occurrred).     */
if|if
condition|(
name|on
operator|->
name|on_resp
operator|.
name|di_type
operator|==
name|DI_ERROR
condition|)
block|{
name|pslog
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|"Remote dsainfo error"
argument_list|,
name|dn_print
argument_list|,
operator|(
name|caddr_t
operator|)
name|on
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_rd
operator|.
name|rda_object
argument_list|)
expr_stmt|;
name|log_ds_error
argument_list|(
operator|&
name|on
operator|->
name|on_resp
operator|.
name|di_error
operator|.
name|de_err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|on
operator|->
name|on_dsas
condition|)
block|{
if|if
condition|(
name|oper_chain
argument_list|(
name|on
argument_list|)
operator|==
name|OK
condition|)
return|return;
block|}
if|if
condition|(
name|on
operator|->
name|on_dsas
condition|)
block|{
comment|/* oper_chain must be awaiting deferred di_blocks */
return|return;
block|}
comment|/*     *  There is nowhere left to chain this operation to so no way to get     *  the dsa info required. Walk through the wake up list extracting,     *  waking things up and tidying up afterwords.     */
block|}
end_block

begin_function
name|char
modifier|*
name|get_entry_passwd
parameter_list|(
name|as
parameter_list|)
name|Attr_Sequence
name|as
decl_stmt|;
block|{
specifier|extern
name|AttributeType
name|at_password
decl_stmt|;
name|Attr_Sequence
name|at
decl_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|as_find_type
argument_list|(
name|as
argument_list|,
name|at_password
argument_list|)
operator|)
operator|==
name|NULLATTR
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
if|if
condition|(
name|at
operator|->
name|attr_value
operator|==
name|NULLAV
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
if|if
condition|(
name|at
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULLCP
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|at
operator|->
name|attr_value
operator|->
name|avseq_av
operator|.
name|av_struct
operator|)
return|;
block|}
end_function

begin_macro
name|make_dsa_bind_arg
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ds_bind_arg
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NEXT_VERSION
name|Entry
name|my_entry
decl_stmt|;
name|char
modifier|*
name|passwd
decl_stmt|;
name|arg
operator|->
name|dba_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|arg
operator|->
name|dba_auth_type
operator|=
name|DBA_AUTH_SIMPLE
expr_stmt|;
name|arg
operator|->
name|dba_time1
operator|=
name|NULLCP
expr_stmt|;
name|arg
operator|->
name|dba_time2
operator|=
name|NULLCP
expr_stmt|;
if|if
condition|(
operator|(
name|my_entry
operator|=
name|local_find_entry
argument_list|(
name|mydsadn
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULLENTRY
condition|)
block|{
name|arg
operator|->
name|dba_dn
operator|=
name|NULLDN
expr_stmt|;
name|arg
operator|->
name|dba_auth_type
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
name|arg
operator|->
name|dba_passwd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|dba_passwd_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|dba_dn
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|passwd
operator|=
name|get_entry_passwd
argument_list|(
name|my_entry
operator|->
name|e_attributes
argument_list|)
operator|)
operator|!=
name|NULLCP
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|arg
operator|->
name|dba_passwd
argument_list|,
name|passwd
argument_list|,
name|DBA_MAX_PASSWD_LEN
argument_list|)
expr_stmt|;
name|arg
operator|->
name|dba_passwd_len
operator|=
name|strlen
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|dba_auth_type
operator|=
name|DBA_AUTH_NONE
expr_stmt|;
name|arg
operator|->
name|dba_passwd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|dba_passwd_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
name|arg
operator|->
name|dba_version
operator|=
name|DBA_VERSION_V1988
expr_stmt|;
name|arg
operator|->
name|dba_auth_type
operator|=
name|DBA_AUTH_SIMPLE
expr_stmt|;
name|arg
operator|->
name|dba_time1
operator|=
name|NULLCP
expr_stmt|;
name|arg
operator|->
name|dba_time2
operator|=
name|NULLCP
expr_stmt|;
name|arg
operator|->
name|dba_passwd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|dba_passwd_len
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|dba_dn
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|struct
name|oper_act
modifier|*
name|make_get_dsa_info_op
parameter_list|(
name|dn
parameter_list|,
name|di
parameter_list|)
name|DN
name|dn
decl_stmt|;
name|struct
name|di_block
modifier|*
name|di
decl_stmt|;
block|{
name|struct
name|di_block
modifier|*
name|di_tmp
decl_stmt|;
name|struct
name|oper_act
modifier|*
name|on_tmp
decl_stmt|;
name|struct
name|ds_read_arg
modifier|*
name|arg
decl_stmt|;
name|DLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_TRACE
argument_list|,
operator|(
literal|"make_get_dsa_info_op"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|on_tmp
operator|=
name|oper_alloc
argument_list|()
operator|)
operator|==
name|NULLOPER
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"make_get_dsa_info_op - out of memory"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLOPER
operator|)
return|;
block|}
name|on_tmp
operator|->
name|on_type
operator|=
name|ON_TYPE_GET_DSA_INFO
expr_stmt|;
name|on_tmp
operator|->
name|on_arg
operator|=
operator|&
operator|(
name|on_tmp
operator|->
name|on_req
operator|)
expr_stmt|;
name|set_my_chain_args
argument_list|(
operator|&
operator|(
name|on_tmp
operator|->
name|on_req
operator|.
name|dca_charg
operator|)
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|on_tmp
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_type
operator|=
name|OP_READ
expr_stmt|;
name|arg
operator|=
operator|&
operator|(
name|on_tmp
operator|->
name|on_req
operator|.
name|dca_dsarg
operator|.
name|arg_rd
operator|)
expr_stmt|;
name|set_my_common_args
argument_list|(
operator|&
operator|(
name|arg
operator|->
name|rda_common
operator|)
argument_list|)
expr_stmt|;
name|arg
operator|->
name|rda_common
operator|.
name|ca_servicecontrol
operator|.
name|svc_prio
operator|=
name|SVC_PRIO_HIGH
expr_stmt|;
name|arg
operator|->
name|rda_object
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
comment|/* The important bit */
name|arg
operator|->
name|rda_eis
operator|.
name|eis_allattributes
operator|=
name|TRUE
expr_stmt|;
name|arg
operator|->
name|rda_eis
operator|.
name|eis_select
operator|=
name|NULLATTR
expr_stmt|;
name|arg
operator|->
name|rda_eis
operator|.
name|eis_infotypes
operator|=
name|EIS_ATTRIBUTESANDVALUES
expr_stmt|;
name|on_tmp
operator|->
name|on_dsas
operator|=
name|di
expr_stmt|;
for|for
control|(
name|di_tmp
operator|=
name|di
init|;
name|di_tmp
operator|!=
name|NULL_DI_BLOCK
condition|;
name|di_tmp
operator|=
name|di_tmp
operator|->
name|di_next
control|)
block|{
name|di_tmp
operator|->
name|di_type
operator|=
name|DI_OPERATION
expr_stmt|;
name|di_tmp
operator|->
name|di_oper
operator|=
name|on_tmp
expr_stmt|;
block|}
return|return
operator|(
name|on_tmp
operator|)
return|;
block|}
end_function

begin_macro
name|set_my_chain_args
argument_list|(
argument|cha
argument_list|,
argument|dn
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|chain_arg
modifier|*
name|cha
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DN
name|dn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cha
operator|->
name|cha_originator
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
name|cha
operator|->
name|cha_target
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|cha
operator|->
name|cha_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_NOTSTARTED
expr_stmt|;
name|cha
operator|->
name|cha_progress
operator|.
name|op_nextrdntoberesolved
operator|=
name|OP_PHASE_NOTDEFINED
expr_stmt|;
name|cha
operator|->
name|cha_trace
operator|=
name|NULLTRACEINFO
expr_stmt|;
name|cha
operator|->
name|cha_aliasderef
operator|=
literal|0
expr_stmt|;
name|cha
operator|->
name|cha_aliasedrdns
operator|=
literal|0
expr_stmt|;
name|cha
operator|->
name|cha_returnrefs
operator|=
name|FALSE
expr_stmt|;
name|cha
operator|->
name|cha_reftype
operator|=
name|RT_SUBORDINATE
expr_stmt|;
name|cha
operator|->
name|cha_domaininfo
operator|=
name|NULLPE
expr_stmt|;
name|cha
operator|->
name|cha_timelimit
operator|=
name|NULLCP
expr_stmt|;
block|}
end_block

begin_macro
name|set_my_common_args
argument_list|(
argument|ca
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|common_args
modifier|*
name|ca
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_options
operator|=
name|SVC_OPT_PREFERCHAIN
expr_stmt|;
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_prio
operator|=
name|SVC_PRIO_HIGH
expr_stmt|;
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_timelimit
operator|=
name|SVC_NOTIMELIMIT
expr_stmt|;
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_sizelimit
operator|=
name|SVC_NOSIZELIMIT
expr_stmt|;
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_scopeofreferral
operator|=
name|SVC_REFSCOPE_NONE
expr_stmt|;
name|ca
operator|->
name|ca_requestor
operator|=
name|dn_cpy
argument_list|(
name|mydsadn
argument_list|)
expr_stmt|;
name|ca
operator|->
name|ca_progress
operator|.
name|op_resolution_phase
operator|=
name|OP_PHASE_NOTSTARTED
expr_stmt|;
name|ca
operator|->
name|ca_progress
operator|.
name|op_nextrdntoberesolved
operator|=
name|OP_PHASE_NOTDEFINED
expr_stmt|;
name|ca
operator|->
name|ca_aliased_rdns
operator|=
name|CA_NO_ALIASDEREFERENCED
expr_stmt|;
name|ca
operator|->
name|ca_security
operator|=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
name|NULL
expr_stmt|;
name|ca
operator|->
name|ca_sig
operator|=
operator|(
expr|struct
name|signature
operator|*
operator|)
name|NULL
expr_stmt|;
name|ca
operator|->
name|ca_extensions
operator|=
operator|(
expr|struct
name|extension
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|quipu_ctx_supported
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|AV_Sequence
name|avs
decl_stmt|;
name|Attr_Sequence
name|as
decl_stmt|;
specifier|extern
name|OID
name|quipu_dsa_oid
decl_stmt|;
specifier|extern
name|AttributeType
name|at_applctx
decl_stmt|;
name|char
name|dap_only
init|=
name|TRUE
decl_stmt|;
name|char
name|res
init|=
literal|1
decl_stmt|;
specifier|static
name|OID
name|dsp
init|=
name|NULLOID
decl_stmt|;
specifier|static
name|OID
name|quipu_dsp
init|=
name|NULLOID
decl_stmt|;
comment|/* return 0 if "ptr" is not a quipu DSA */
comment|/* return 1 if "ptr" represents a quipu_dsa (by objectclass) */
comment|/* return 2 if "ptr" represents a quipu_dsa with quipu context */
comment|/* return -1 if "ptr" represents a DAP only DSA */
comment|/* Should we use QuipuDSP to a non-Quipu DSA, if is claims 	 * to support it - currently implemented as "NO" ?          */
if|if
condition|(
operator|!
name|check_in_oc
argument_list|(
name|quipu_dsa_oid
argument_list|,
name|ptr
operator|->
name|e_oc
argument_list|)
condition|)
name|res
operator|=
literal|0
expr_stmt|;
comment|/* not a Quipu DSA */
if|if
condition|(
operator|(
name|as
operator|=
name|entry_find_type
argument_list|(
name|ptr
argument_list|,
name|at_applctx
argument_list|)
operator|)
operator|==
name|NULLATTR
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dsp
operator|==
name|NULLOID
condition|)
block|{
comment|/* will both be null first time around... */
name|dsp
operator|=
name|oid_cpy
argument_list|(
name|DIR_SYSTEM_AC
argument_list|)
expr_stmt|;
name|quipu_dsp
operator|=
name|oid_cpy
argument_list|(
name|DIR_QUIPU_AC
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|avs
operator|=
name|as
operator|->
name|attr_value
init|;
name|avs
operator|!=
name|NULLAV
condition|;
name|avs
operator|=
name|avs
operator|->
name|avseq_next
control|)
block|{
if|if
condition|(
operator|(
name|res
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|oid_cmp
argument_list|(
operator|(
name|OID
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|,
name|quipu_dsp
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|oid_cmp
argument_list|(
operator|(
name|OID
operator|)
name|avs
operator|->
name|avseq_av
operator|.
name|av_struct
argument_list|,
name|dsp
argument_list|)
operator|==
literal|0
condition|)
name|dap_only
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|dap_only
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|res
return|;
block|}
end_block

begin_macro
name|quipu_version_7
argument_list|(
argument|eptr
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|eptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|res
decl_stmt|,
name|vrsn
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
comment|/* return true is the string suggests quipu version 6.8 or more */
comment|/* Format of string is typically... 	 * quipu 6.8 #69 (trellis) of Thu Nov 15 15:58:24 GMT 1990 	 */
if|if
condition|(
operator|!
name|eptr
operator|||
operator|!
name|eptr
operator|->
name|e_dsainfo
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
operator|(
name|v
operator|=
name|eptr
operator|->
name|e_dsainfo
operator|->
name|dsa_version
operator|)
operator|==
name|NULLCP
operator|)
operator|||
operator|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|v
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULLCP
operator|)
operator|||
operator|(
operator|(
name|t
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULLCP
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|t
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULLCP
condition|)
operator|*
name|s
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|0
expr_stmt|;
name|vrsn
operator|=
operator|(
name|atoi
argument_list|(
name|p
argument_list|)
operator|*
literal|10
operator|)
operator|+
name|atoi
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"quipu"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|vrsn
operator|>=
literal|68
operator|)
condition|)
name|res
operator|=
name|TRUE
expr_stmt|;
else|else
name|res
operator|=
name|FALSE
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|' '
expr_stmt|;
operator|*
operator|--
name|t
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|s
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

end_unit

