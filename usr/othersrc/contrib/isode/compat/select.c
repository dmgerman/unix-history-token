begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* select.c - select() abstractions */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/compat/RCS/select.c,v 7.6 91/02/22 09:15:45 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/compat/RCS/select.c,v 7.6 91/02/22 09:15:45 mrose Interim $  *  *  * $Log:	select.c,v $  * Revision 7.6  91/02/22  09:15:45  mrose  * Interim 6.8  *   * Revision 7.5  91/01/07  12:39:56  mrose  * update  *   * Revision 7.4  90/11/21  11:35:31  mrose  * update  *   * Revision 7.3  90/05/22  19:33:29  mrose  * update  *   * Revision 7.2  89/12/05  22:04:41  mrose  * touch-up  *   * Revision 7.1  89/11/30  23:53:31  mrose  * touch-up  *   * Revision 7.0  89/11/23  21:23:24  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"manifest.h"
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xselect_blocking_on_intr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SOCKETS
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* Synchronous multiplexing:< 0 :	block indefinately 	= 0 :	poll> 0 :	wait  */
end_comment

begin_function
name|int
name|selsocket
parameter_list|(
name|nfds
parameter_list|,
name|rfds
parameter_list|,
name|wfds
parameter_list|,
name|efds
parameter_list|,
name|secs
parameter_list|)
name|int
name|nfds
decl_stmt|;
name|fd_set
modifier|*
name|rfds
decl_stmt|,
decl|*
name|wfds
decl_stmt|,
modifier|*
name|efds
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|secs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|,
name|ofds
decl_stmt|,
name|xfds
decl_stmt|;
name|struct
name|timeval
name|tvs
decl_stmt|;
specifier|register
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|&
name|tvs
decl_stmt|;
if|if
condition|(
name|secs
operator|!=
name|NOTOK
condition|)
name|tv
operator|->
name|tv_sec
operator|=
name|secs
operator|,
name|tv
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
name|tv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rfds
condition|)
name|ifds
operator|=
operator|*
name|rfds
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
name|ofds
operator|=
operator|*
name|wfds
expr_stmt|;
if|if
condition|(
name|efds
condition|)
name|xfds
operator|=
operator|*
name|efds
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|n
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
name|rfds
argument_list|,
name|wfds
argument_list|,
name|efds
argument_list|,
name|tv
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
if|if
condition|(
name|secs
operator|==
name|NOTOK
condition|)
break|break;
return|return
name|OK
return|;
case|case
name|NOTOK
case|:
if|if
condition|(
name|xselect_blocking_on_intr
operator|&&
name|errno
operator|==
name|EINTR
operator|&&
name|secs
operator|==
name|NOTOK
condition|)
continue|continue;
comment|/* else fall... */
default|default:
return|return
name|n
return|;
block|}
if|if
condition|(
name|rfds
condition|)
operator|*
name|rfds
operator|=
name|ifds
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
operator|*
name|wfds
operator|=
name|ofds
expr_stmt|;
if|if
condition|(
name|efds
condition|)
operator|*
name|efds
operator|=
name|xfds
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXOS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_comment
comment|/* There seems to be a bug in the SYS5 EXOS select() routine when a socket can    be read immediately (don't know about write).  The bug is that select()    returns ZERO, and the mask is zero'd as well.  The code below explicitly    checks for this case. */
end_comment

begin_include
include|#
directive|include
file|"sys/soioctl.h"
end_include

begin_function
name|int
name|selsocket
parameter_list|(
name|nfds
parameter_list|,
name|rfds
parameter_list|,
name|wfds
parameter_list|,
name|efds
parameter_list|,
name|secs
parameter_list|)
name|int
name|nfds
decl_stmt|;
name|fd_set
modifier|*
name|rfds
decl_stmt|,
decl|*
name|wfds
decl_stmt|,
modifier|*
name|efds
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|secs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|n
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|,
name|ofds
decl_stmt|;
name|long
name|nbytes
decl_stmt|,
name|usecs
decl_stmt|;
if|if
condition|(
name|secs
operator|!=
name|NOTOK
condition|)
name|usecs
operator|=
name|secs
operator|*
literal|1000
expr_stmt|;
else|else
name|usecs
operator|=
literal|0xffff
expr_stmt|;
comment|/* used to be ~(1L<< (8 * sizeof usecs - 1)) */
if|if
condition|(
name|rfds
condition|)
name|ifds
operator|=
operator|*
name|rfds
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
name|ofds
operator|=
operator|*
name|wfds
expr_stmt|;
if|if
condition|(
name|efds
condition|)
name|FD_ZERO
argument_list|(
name|efds
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|n
operator|=
name|select
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
name|rfds
argument_list|,
name|wfds
argument_list|,
name|usecs
argument_list|)
condition|)
block|{
comment|/* +1 for UNISYS */
case|case
name|OK
case|:
if|if
condition|(
name|rfds
condition|)
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
operator|&&
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|)
operator|!=
name|NOTOK
operator|&&
name|nbytes
operator|>
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|rfds
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|secs
operator|==
name|NOTOK
condition|)
break|break;
return|return
name|n
return|;
case|case
name|NOTOK
case|:
default|default:
return|return
name|n
return|;
block|}
if|if
condition|(
name|rfds
condition|)
operator|*
name|rfds
operator|=
name|ifds
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
operator|*
name|wfds
operator|=
name|ofds
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* This routine used to be used for devices that didn't support real select.    Those devices are no longer supported.     Instead the routine is used to check if an I/O abstraction has some data    buffered in user-space for reading...  */
end_comment

begin_decl_stmt
specifier|static
name|IFP
name|sfnx
index|[
name|FD_SETSIZE
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|sdata
index|[
name|FD_SETSIZE
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|IFP
name|set_check_fd
parameter_list|(
name|fd
parameter_list|,
name|fnx
parameter_list|,
name|data
parameter_list|)
name|int
name|fd
decl_stmt|;
name|IFP
name|fnx
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|IFP
name|ofnx
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fd
operator|>=
name|FD_SETSIZE
condition|)
return|return
name|NULLIFP
return|;
name|ofnx
operator|=
name|sfnx
index|[
name|fd
index|]
expr_stmt|;
name|sfnx
index|[
name|fd
index|]
operator|=
name|fnx
operator|,
name|sdata
index|[
name|fd
index|]
operator|=
name|data
expr_stmt|;
return|return
name|ofnx
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|xselect
parameter_list|(
name|nfds
parameter_list|,
name|rfds
parameter_list|,
name|wfds
parameter_list|,
name|efds
parameter_list|,
name|secs
parameter_list|)
name|int
name|nfds
decl_stmt|;
name|fd_set
modifier|*
name|rfds
decl_stmt|,
decl|*
name|wfds
decl_stmt|,
modifier|*
name|efds
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|secs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|n
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|,
name|ofds
decl_stmt|,
name|xfds
decl_stmt|;
specifier|static
name|int
name|nsysfds
init|=
name|NOTOK
decl_stmt|;
if|if
condition|(
name|nsysfds
operator|==
name|NOTOK
condition|)
name|nsysfds
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfds
operator|>
name|FD_SETSIZE
condition|)
name|nfds
operator|=
name|FD_SETSIZE
expr_stmt|;
if|if
condition|(
name|nfds
operator|>
name|nsysfds
operator|+
literal|1
condition|)
name|nfds
operator|=
name|nsysfds
operator|+
literal|1
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
name|sfnx
index|[
name|fd
index|]
operator|!=
name|NULLIFP
operator|&&
name|rfds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
name|rfds
argument_list|)
operator|&&
call|(
modifier|*
name|sfnx
index|[
name|fd
index|]
call|)
argument_list|(
name|fd
argument_list|,
name|sdata
index|[
name|fd
index|]
argument_list|)
operator|==
name|DONE
condition|)
block|{
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|*
name|rfds
operator|=
name|ifds
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|wfds
condition|)
name|FD_ZERO
argument_list|(
name|wfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
condition|)
name|FD_ZERO
argument_list|(
name|efds
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
if|if
condition|(
name|rfds
condition|)
name|ifds
operator|=
operator|*
name|rfds
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|wfds
condition|)
name|ofds
operator|=
operator|*
name|wfds
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
name|efds
condition|)
name|xfds
operator|=
operator|*
name|efds
expr_stmt|;
comment|/* struct copy */
if|if
condition|(
operator|(
name|n
operator|=
name|selsocket
argument_list|(
name|nfds
argument_list|,
name|rfds
argument_list|,
name|wfds
argument_list|,
name|efds
argument_list|,
name|secs
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
return|return
name|n
return|;
if|if
condition|(
name|errno
operator|==
name|EBADF
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|rfds
condition|)
name|FD_ZERO
argument_list|(
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfds
condition|)
name|FD_ZERO
argument_list|(
name|wfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
condition|)
name|FD_ZERO
argument_list|(
name|efds
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|nfds
condition|;
name|fd
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|rfds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
operator|)
operator|||
operator|(
name|wfds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ofds
argument_list|)
operator|)
operator|||
operator|(
name|efds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|xfds
argument_list|)
operator|)
operator|)
operator|&&
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|rfds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ifds
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|ofds
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|wfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|efds
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|xfds
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|efds
argument_list|)
expr_stmt|;
name|SLOG
argument_list|(
name|compat_log
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
literal|""
argument_list|,
operator|(
literal|"fd %d has gone bad"
operator|,
name|fd
operator|)
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
name|errno
operator|=
name|EBADF
expr_stmt|;
block|}
return|return
name|NOTOK
return|;
block|}
end_block

end_unit

