begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* service.c - */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/dsap/common/RCS/service.c,v 7.3 91/02/22 09:20:15 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/dsap/common/RCS/service.c,v 7.3 91/02/22 09:20:15 mrose Interim $  *  *  * $Log:	service.c,v $  * Revision 7.3  91/02/22  09:20:15  mrose  * Interim 6.8  *   * Revision 7.2  90/10/17  11:42:50  mrose  * sync  *   * Revision 7.1  90/03/15  11:19:10  mrose  * quipu-sync  *   * Revision 7.0  89/11/23  22:18:06  mrose  * Release 6.0  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|"quipu/util.h"
end_include

begin_include
include|#
directive|include
file|"quipu/commonarg.h"
end_include

begin_include
include|#
directive|include
file|"quipu/dua.h"
end_include

begin_include
include|#
directive|include
file|"quipu/sequence.h"
end_include

begin_define
define|#
directive|define
name|MAXSERV
value|20
end_define

begin_decl_stmt
specifier|static
name|char
name|default_service
index|[
name|BUFSIZ
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|serv_vec
index|[
name|MAXSERV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|serv_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_serv_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DN
name|user_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|chase_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|do_shuffle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|copy_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|certificate
modifier|*
name|my_certificate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|result_sequence
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dua_sequence
modifier|*
name|current_sequence
init|=
name|NULL_DS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dua_sequence
modifier|*
name|top_sequence
init|=
name|NULL_DS
decl_stmt|;
end_decl_stmt

begin_macro
name|set_default_service
argument_list|(
argument|opt
argument_list|)
end_macro

begin_decl_stmt
name|PS
name|opt
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|default_service
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|serv_argc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|serv_argc
operator|=
name|sstr2arg
argument_list|(
name|default_service
argument_list|,
name|MAXSERV
argument_list|,
name|serv_vec
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ps_print
argument_list|(
name|opt
argument_list|,
literal|"Invalid default service controls"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
else|else
block|{
name|default_serv_set
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
block|}
end_block

begin_function
name|int
name|get_default_service
parameter_list|(
name|ca
parameter_list|)
name|CommonArgs
modifier|*
name|ca
decl_stmt|;
block|{
name|PS
name|opt
decl_stmt|;
name|char
name|buffer
index|[
name|LINESIZE
index|]
decl_stmt|;
specifier|extern
name|int
name|sizelimit
decl_stmt|;
specifier|extern
name|int
name|timelimit
decl_stmt|;
specifier|static
name|CommonArgs
name|sca
init|=
name|default_common_args
decl_stmt|;
operator|*
name|ca
operator|=
name|sca
expr_stmt|;
comment|/* struct copy */
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_sizelimit
operator|=
name|sizelimit
expr_stmt|;
name|ca
operator|->
name|ca_servicecontrol
operator|.
name|svc_timelimit
operator|=
name|timelimit
expr_stmt|;
if|if
condition|(
operator|(
name|opt
operator|=
name|ps_alloc
argument_list|(
name|str_open
argument_list|)
operator|)
operator|==
name|NULLPS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ps_alloc error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|str_setup
argument_list|(
name|opt
argument_list|,
name|buffer
argument_list|,
name|LINESIZE
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ps_setup error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|default_serv_set
condition|)
if|if
condition|(
name|set_default_service
argument_list|(
name|opt
argument_list|)
operator|!=
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error (1) - %s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ps_free
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|do_shuffle
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|do_service_control
argument_list|(
name|opt
argument_list|,
name|serv_argc
argument_list|,
name|serv_vec
argument_list|,
name|ca
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error (2) - %s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ps_free
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|ps_free
argument_list|(
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|service_control
parameter_list|(
name|opt
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|ca
parameter_list|)
name|PS
name|opt
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|CommonArgs
modifier|*
name|ca
decl_stmt|;
block|{
if|if
condition|(
name|get_default_service
argument_list|(
name|ca
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ps_print
argument_list|(
name|opt
argument_list|,
literal|"default service error - check quipurc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|do_shuffle
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|do_service_control
argument_list|(
name|opt
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|ca
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|do_service_control
parameter_list|(
name|opt
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|ca
parameter_list|)
name|PS
name|opt
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|CommonArgs
modifier|*
name|ca
decl_stmt|;
block|{
name|ServiceControl
modifier|*
name|sc
decl_stmt|;
name|int
name|shuffle_up
parameter_list|()
function_decl|;
name|int
name|x
decl_stmt|;
name|char
name|shuffle
decl_stmt|;
name|sc
operator|=
operator|&
operator|(
name|ca
operator|->
name|ca_servicecontrol
operator|)
expr_stmt|;
name|copy_flag
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|argc
condition|;
name|x
operator|++
control|)
block|{
name|shuffle
operator|=
name|do_shuffle
expr_stmt|;
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-preferchain"
argument_list|,
literal|3
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator||=
name|SVC_OPT_PREFERCHAIN
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-nopreferchain"
argument_list|,
literal|5
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator|&=
operator|~
name|SVC_OPT_PREFERCHAIN
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-localscope"
argument_list|,
literal|3
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator||=
name|SVC_OPT_LOCALSCOPE
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-nolocalscope"
argument_list|,
literal|3
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator|&=
operator|(
operator|~
name|SVC_OPT_LOCALSCOPE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-dontusecopy"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|copy_flag
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|svc_options
operator||=
name|SVC_OPT_DONTUSECOPY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-usecopy"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|copy_flag
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|svc_options
operator|&=
operator|(
operator|~
name|SVC_OPT_DONTUSECOPY
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-dontdereferencealias"
argument_list|,
literal|5
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator||=
name|SVC_OPT_DONTDEREFERENCEALIAS
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-dereferencealias"
argument_list|,
literal|3
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator|&=
operator|(
operator|~
name|SVC_OPT_DONTDEREFERENCEALIAS
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-low"
argument_list|,
literal|3
argument_list|)
condition|)
name|sc
operator|->
name|svc_prio
operator|=
name|SVC_PRIO_LOW
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-medium"
argument_list|,
literal|2
argument_list|)
condition|)
name|sc
operator|->
name|svc_prio
operator|=
name|SVC_PRIO_MED
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-high"
argument_list|,
literal|1
argument_list|)
condition|)
name|sc
operator|->
name|svc_prio
operator|=
name|SVC_PRIO_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-timelimit"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|x
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"We need a number for timelimit.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|shuffle
condition|)
name|shuffle_up
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|svc_timelimit
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|)
operator|)
operator|<
operator|-
literal|1
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"We need a posative number for timelimit.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-notimelimit"
argument_list|,
literal|4
argument_list|)
condition|)
name|sc
operator|->
name|svc_timelimit
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-sizelimit"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|x
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"We need a number for sizelimit.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|shuffle
condition|)
name|shuffle_up
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|svc_sizelimit
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|)
operator|)
operator|<
operator|-
literal|1
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"We need a posative number for sizelimit.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-nosizelimit"
argument_list|,
literal|4
argument_list|)
condition|)
name|sc
operator|->
name|svc_sizelimit
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-nochaining"
argument_list|,
literal|4
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator||=
name|SVC_OPT_CHAININGPROHIBIT
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-chaining"
argument_list|,
literal|3
argument_list|)
condition|)
name|sc
operator|->
name|svc_options
operator|&=
operator|(
operator|~
name|SVC_OPT_CHAININGPROHIBIT
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-norefer"
argument_list|,
literal|5
argument_list|)
condition|)
name|chase_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-refer"
argument_list|,
literal|3
argument_list|)
condition|)
name|chase_flag
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-strong"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|char
modifier|*
name|new_version
parameter_list|()
function_decl|;
name|struct
name|certificate
modifier|*
name|cert_cpy
parameter_list|()
function_decl|;
name|ca
operator|->
name|ca_security
operator|=
operator|(
expr|struct
name|security_parms
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|security_parms
argument_list|)
argument_list|)
expr_stmt|;
name|ca
operator|->
name|ca_security
operator|->
name|sp_name
operator|=
name|NULLDN
expr_stmt|;
name|ca
operator|->
name|ca_security
operator|->
name|sp_time
operator|=
name|new_version
argument_list|()
expr_stmt|;
name|ca
operator|->
name|ca_security
operator|->
name|sp_target
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|my_certificate
operator|!=
operator|(
expr|struct
name|certificate
operator|*
operator|)
literal|0
condition|)
block|{
name|ca
operator|->
name|ca_security
operator|->
name|sp_path
operator|=
operator|(
expr|struct
name|certificate_list
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|certificate_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|ca_security
operator|->
name|sp_path
operator|!=
operator|(
expr|struct
name|certificate_list
operator|*
operator|)
literal|0
condition|)
block|{
name|ca
operator|->
name|ca_security
operator|->
name|sp_path
operator|->
name|next
operator|=
operator|(
expr|struct
name|certificate_list
operator|*
operator|)
literal|0
expr_stmt|;
name|ca
operator|->
name|ca_security
operator|->
name|sp_path
operator|->
name|superior
operator|=
operator|(
expr|struct
name|certificate_list
operator|*
operator|)
literal|0
expr_stmt|;
name|ca
operator|->
name|ca_security
operator|->
name|sp_path
operator|->
name|cert
operator|=
name|cert_cpy
argument_list|(
name|my_certificate
argument_list|)
expr_stmt|;
name|ca
operator|->
name|ca_security
operator|->
name|sp_path
operator|->
name|reverse
operator|=
operator|(
expr|struct
name|certificate
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-sequence"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|x
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"We need a sequence name.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|shuffle
condition|)
name|shuffle_up
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|++
expr_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"result"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"We need a result sequence name.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|shuffle
condition|)
name|shuffle_up
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|++
expr_stmt|;
name|result_sequence
operator|=
name|strdup
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|set_sequence
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|test_arg
argument_list|(
name|argv
index|[
name|x
index|]
argument_list|,
literal|"-nosequence"
argument_list|,
literal|5
argument_list|)
condition|)
name|unset_sequence
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|do_shuffle
condition|)
name|shuffle
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|ps_printf
argument_list|(
name|opt
argument_list|,
literal|"unknown service option %s\n"
argument_list|,
name|argv
index|[
name|x
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|shuffle
condition|)
name|shuffle_up
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
argument_list|,
name|x
operator|--
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|argc
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|shuffle_up
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|start
argument_list|)
specifier|register
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|start
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|start
init|;
name|x
operator|<
name|argc
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|x
operator|==
name|argc
operator|-
literal|1
condition|)
comment|/* if it is the last one, then stick 					 * a 0 in */
name|argv
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
else|else
comment|/* oterwise put the next one in it's place. */
name|argv
index|[
name|x
index|]
operator|=
name|argv
index|[
name|x
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|new_service
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|default_service
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|default_service
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|default_service
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|set_sequence
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dua_sequence
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|lexequ
argument_list|(
name|str
argument_list|,
literal|"reset"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current_sequence
operator|==
name|NULL_DS
condition|)
return|return;
name|current_sequence
operator|->
name|ds_data
operator|=
name|NULL_DE
expr_stmt|;
name|current_sequence
operator|->
name|ds_last
operator|=
name|NULL_DE
expr_stmt|;
return|return;
block|}
for|for
control|(
name|ptr
operator|=
name|top_sequence
init|;
name|ptr
operator|!=
name|NULL_DS
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|ds_next
control|)
if|if
condition|(
name|lexequ
argument_list|(
name|ptr
operator|->
name|ds_name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_sequence
operator|=
name|ptr
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|ds_alloc
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|ds_name
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|ds_data
operator|=
name|NULL_DE
expr_stmt|;
name|ptr
operator|->
name|ds_last
operator|=
name|NULL_DE
expr_stmt|;
name|ptr
operator|->
name|ds_next
operator|=
name|top_sequence
expr_stmt|;
name|top_sequence
operator|=
name|ptr
expr_stmt|;
name|current_sequence
operator|=
name|ptr
expr_stmt|;
block|}
end_block

begin_macro
name|unset_sequence
argument_list|()
end_macro

begin_block
block|{
name|current_sequence
operator|=
name|NULL_DS
expr_stmt|;
block|}
end_block

begin_macro
name|add_sequence
argument_list|(
argument|adn
argument_list|)
end_macro

begin_decl_stmt
name|DN
name|adn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dua_seq_entry
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|x
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|current_sequence
operator|==
name|NULL_DS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|ptr
operator|=
name|current_sequence
operator|->
name|ds_data
init|;
name|ptr
operator|!=
name|NULL_DE
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|de_next
operator|,
name|x
operator|++
control|)
if|if
condition|(
name|dn_cmp
argument_list|(
name|adn
argument_list|,
name|ptr
operator|->
name|de_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|ptr
operator|=
name|de_alloc
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|de_name
operator|=
name|dn_cpy
argument_list|(
name|adn
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|de_next
operator|=
name|NULL_DE
expr_stmt|;
if|if
condition|(
name|current_sequence
operator|->
name|ds_data
operator|==
name|NULL_DE
condition|)
name|current_sequence
operator|->
name|ds_data
operator|=
name|ptr
expr_stmt|;
else|else
name|current_sequence
operator|->
name|ds_last
operator|->
name|de_next
operator|=
name|ptr
expr_stmt|;
name|current_sequence
operator|->
name|ds_last
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_function
name|DN
name|sequence_dn
parameter_list|(
name|y
parameter_list|)
name|int
name|y
decl_stmt|;
block|{
name|struct
name|dua_seq_entry
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|x
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|current_sequence
operator|==
name|NULL_DS
condition|)
return|return
operator|(
name|NULLDN
operator|)
return|;
for|for
control|(
name|ptr
operator|=
name|current_sequence
operator|->
name|ds_data
init|;
operator|(
name|ptr
operator|!=
name|NULL_DE
operator|)
operator|&&
operator|(
name|x
operator|<
name|y
operator|)
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|de_next
operator|,
name|x
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL_DE
condition|)
return|return
operator|(
name|NULLDN
operator|)
return|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
operator|(
name|ptr
operator|->
name|de_name
operator|)
return|;
return|return
operator|(
name|NULLDN
operator|)
return|;
block|}
end_function

begin_macro
name|show_sequence
argument_list|(
argument|RPS
argument_list|,
argument|str
argument_list|,
argument|ufn
argument_list|)
end_macro

begin_decl_stmt
name|PS
name|RPS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ufn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dua_seq_entry
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|x
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULLCP
condition|)
name|set_sequence
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sequence
operator|==
name|NULL_DS
condition|)
block|{
name|ps_print
argument_list|(
name|RPS
argument_list|,
literal|"No sequence set!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|current_sequence
operator|->
name|ds_name
argument_list|,
literal|"default"
argument_list|)
condition|)
name|ps_printf
argument_list|(
name|RPS
argument_list|,
literal|"Sequence %s contains:-\n"
argument_list|,
name|current_sequence
operator|->
name|ds_name
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|current_sequence
operator|->
name|ds_data
init|;
name|ptr
operator|!=
name|NULL_DE
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|de_next
operator|,
name|x
operator|++
control|)
block|{
name|ps_printf
argument_list|(
name|RPS
argument_list|,
literal|"%-3d%s"
argument_list|,
name|x
argument_list|,
name|ufn
condition|?
literal|" "
else|:
literal|" @"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ufn
condition|)
operator|(
name|void
operator|)
name|ufn_dn_print_aux
argument_list|(
name|RPS
argument_list|,
name|ptr
operator|->
name|de_name
argument_list|,
name|NULLDN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dn_print
argument_list|(
name|RPS
argument_list|,
name|ptr
operator|->
name|de_name
argument_list|,
name|EDBOUT
argument_list|)
expr_stmt|;
name|ps_print
argument_list|(
name|RPS
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

