begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* turbo_index.c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /f/osi/dsap/common/RCS/turbo_index.c,v 7.1 91/02/22 09:20:38 mrose Interim $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * $Header: /f/osi/dsap/common/RCS/turbo_index.c,v 7.1 91/02/22 09:20:38 mrose Interim $  *  *  * $Log:	turbo_index.c,v $  * Revision 7.1  91/02/22  09:20:38  mrose  * Interim 6.8  *   */
end_comment

begin_comment
comment|/*  *				  NOTICE  *  *    Acquisition, use, and distribution of this module and related  *    materials are subject to the restrictions of a license agreement.  *    Consult the Preface in the User's Manual for the full terms of  *    this agreement.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"quipu/config.h"
end_include

begin_include
include|#
directive|include
file|"quipu/attr.h"
end_include

begin_include
include|#
directive|include
file|"quipu/entry.h"
end_include

begin_include
include|#
directive|include
file|"quipu/turbo.h"
end_include

begin_include
include|#
directive|include
file|"logger.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TURBO_INDEX
end_ifdef

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|log_dsap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AttributeType
modifier|*
name|turbo_index_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of attributes to optimize */
end_comment

begin_decl_stmt
name|int
name|turbo_index_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of attributes to optimize */
end_comment

begin_decl_stmt
name|Avlnode
modifier|*
name|subtree_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of subtree indexes */
end_comment

begin_decl_stmt
name|Avlnode
modifier|*
name|sibling_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of sibling indexes */
end_comment

begin_decl_stmt
name|int
name|optimized_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only allow indexed searches */
end_comment

begin_expr_stmt
specifier|static
name|index_cmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
name|Index_node
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|AttrV_cmp
argument_list|(
operator|(
name|AttributeValue
operator|)
name|a
operator|->
name|in_value
argument_list|,
operator|(
name|AttributeValue
operator|)
name|b
operator|->
name|in_value
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sindex_cmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
name|Index_node
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|in_value
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|in_value
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|index_soundex_cmp
argument_list|(
argument|code
argument_list|,
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|code
argument_list|,
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|in_value
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|index_soundex_prefix
argument_list|(
argument|code
argument_list|,
argument|node
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|strncmp
argument_list|(
name|code
argument_list|,
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|in_value
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|substring_prefix_cmp
argument_list|(
argument|val
argument_list|,
argument|node
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|AttributeValue
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val
operator|->
name|av_struct
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|AttributeValue
operator|)
name|node
operator|->
name|in_value
operator|)
operator|->
name|av_struct
operator|)
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|substring_prefix_case_cmp
argument_list|(
argument|val
argument_list|,
argument|node
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|AttributeValue
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|lexnequ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val
operator|->
name|av_struct
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|AttributeValue
operator|)
name|node
operator|->
name|in_value
operator|)
operator|->
name|av_struct
operator|)
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|indexav_cmp
argument_list|(
argument|av
argument_list|,
argument|node
argument_list|)
end_macro

begin_decl_stmt
name|AttributeValue
name|av
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|AttrV_cmp
argument_list|(
name|av
argument_list|,
operator|(
name|AttributeValue
operator|)
name|node
operator|->
name|in_value
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|index_dup
argument_list|(
argument|node
argument_list|,
argument|dup
argument_list|)
name|Index_node
operator|*
name|node
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Index_node
modifier|*
name|dup
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Entry
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* check for duplicates */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|in_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|in_entries
index|[
name|i
index|]
operator|==
name|dup
operator|->
name|in_entries
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|node
operator|->
name|in_entries
index|[
name|i
index|]
operator|>
name|dup
operator|->
name|in_entries
index|[
literal|0
index|]
condition|)
break|break;
block|}
name|node
operator|->
name|in_entries
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|in_entries
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
operator|*
operator|(
name|node
operator|->
name|in_num
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|in_num
operator|++
expr_stmt|;
name|tmp1
operator|=
name|dup
operator|->
name|in_entries
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|node
operator|->
name|in_num
condition|;
name|j
operator|++
control|)
block|{
name|tmp2
operator|=
name|node
operator|->
name|in_entries
index|[
name|j
index|]
expr_stmt|;
name|node
operator|->
name|in_entries
index|[
name|j
index|]
operator|=
name|tmp1
expr_stmt|;
name|tmp1
operator|=
name|tmp2
expr_stmt|;
block|}
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|indexav_free
argument_list|(
argument|node
argument_list|)
name|Index_node
operator|*
name|node
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|AttrV_free
argument_list|(
operator|(
name|AttributeValue
operator|)
name|node
operator|->
name|in_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|in_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|soundex_free
argument_list|(
argument|node
argument_list|)
name|Index_node
operator|*
name|node
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|in_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|in_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|index_free
argument_list|(
argument|pindex
argument_list|)
name|Index
operator|*
name|pindex
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|dn_free
argument_list|(
name|pindex
operator|->
name|i_dn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|avl_free
argument_list|(
name|pindex
operator|->
name|i_root
argument_list|,
name|indexav_free
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|avl_free
argument_list|(
name|pindex
operator|->
name|i_sroot
argument_list|,
name|soundex_free
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pindex
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|i_dup
argument_list|(
argument|a
argument_list|)
name|Index
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|i_cmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
name|Index
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Index
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|dn_order_cmp
argument_list|(
name|a
operator|->
name|i_dn
argument_list|,
name|b
operator|->
name|i_dn
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|idn_cmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|DN
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Index
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|dn_order_cmp
argument_list|(
name|a
argument_list|,
name|b
operator|->
name|i_dn
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * siblings - return 1 if a and b are siblings, 0 otherwise  */
end_comment

begin_expr_stmt
specifier|static
name|siblings
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
name|DN
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DN
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|a
operator|&&
name|b
condition|;
name|a
operator|=
name|a
operator|->
name|dn_parent
operator|,
name|b
operator|=
name|b
operator|->
name|dn_parent
control|)
block|{
if|if
condition|(
name|dn_cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|dn_parent
operator|==
name|NULLDN
operator|&&
name|b
operator|->
name|dn_parent
operator|==
name|NULLDN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|a
operator|!=
name|NULLDN
operator|||
name|b
operator|!=
name|NULLDN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * prefix - returns the following:  *      -1      =>      a is a prefix of b  *      0       =>      a and b are equal  *      1       =>      b is a prefix of a  *      2       =>      neither a nor b is a prefix of the other  */
end_comment

begin_expr_stmt
specifier|static
name|prefix
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
name|DN
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DN
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|a
operator|&&
name|b
condition|;
name|a
operator|=
name|a
operator|->
name|dn_parent
operator|,
name|b
operator|=
name|b
operator|->
name|dn_parent
control|)
if|if
condition|(
name|dn_comp_cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* neither is prefix */
if|if
condition|(
name|a
operator|==
name|NULLDN
operator|&&
name|b
operator|==
name|NULLDN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* they are equal */
elseif|else
if|if
condition|(
name|a
operator|==
name|NULLDN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* a is a prefix of b */
else|else
return|return
operator|(
literal|1
operator|)
return|;
comment|/* b is a prefix of a */
block|}
end_block

begin_function
specifier|static
name|Index
modifier|*
name|new_index
parameter_list|(
name|dn
parameter_list|)
name|DN
name|dn
decl_stmt|;
block|{
name|Index
modifier|*
name|pindex
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pindex
operator|=
operator|(
name|Index
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|Index
argument_list|)
operator|*
name|turbo_index_num
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|turbo_index_num
condition|;
name|i
operator|++
control|)
block|{
name|pindex
index|[
name|i
index|]
operator|.
name|i_attr
operator|=
name|turbo_index_types
index|[
name|i
index|]
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_count
operator|=
literal|0
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_scount
operator|=
literal|0
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_root
operator|=
name|NULLAVL
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_sroot
operator|=
name|NULLAVL
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_nonleafkids
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_nonlocalaliases
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_dn
operator|=
name|dn_cpy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pindex
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_expr_stmt
specifier|static
name|print_soundex_node
argument_list|(
argument|n
argument_list|,
argument|ps
argument_list|)
name|Index_node
operator|*
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t(%s)\n"
argument_list|,
name|n
operator|->
name|in_value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|->
name|in_num
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%s\n"
argument_list|,
name|n
operator|->
name|in_entries
index|[
name|i
index|]
operator|->
name|e_name
operator|->
name|rdn_av
operator|.
name|av_struct
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_comment
comment|/*  * add_nonlocalalias - add entry e to the list of nonlocal aliases  * kept with index index.  */
end_comment

begin_expr_stmt
specifier|static
name|add_nonlocalalias
argument_list|(
argument|e
argument_list|,
argument|pindex
argument_list|)
name|Index
operator|*
name|pindex
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|entry
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|entry
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pindex
operator|==
name|NULLINDEX
condition|)
return|return;
if|if
condition|(
name|pindex
operator|->
name|i_nonlocalaliases
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
literal|0
condition|)
block|{
name|pindex
operator|->
name|i_nonlocalaliases
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pindex
operator|->
name|i_nonlocalaliases
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* first, check for duplicates */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp
operator|=
name|pindex
operator|->
name|i_nonlocalaliases
init|;
operator|*
name|tmp
operator|!=
operator|(
expr|struct
name|entry
operator|*
operator|)
literal|0
condition|;
name|tmp
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|tmp
operator|==
name|e
condition|)
return|return;
block|}
name|pindex
operator|->
name|i_nonlocalaliases
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pindex
operator|->
name|i_nonlocalaliases
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|pindex
operator|->
name|i_nonlocalaliases
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
name|pindex
operator|->
name|i_nonlocalaliases
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULLENTRY
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * addnonleafkids - add entry e to the list of nonlocal kids kept  * in index index.  */
end_comment

begin_expr_stmt
specifier|static
name|add_nonleafkid
argument_list|(
argument|e
argument_list|,
argument|pindex
argument_list|)
name|Index
operator|*
name|pindex
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|entry
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|entry
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pindex
operator|==
name|NULLINDEX
condition|)
return|return;
if|if
condition|(
name|pindex
operator|->
name|i_nonleafkids
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
literal|0
condition|)
block|{
name|pindex
operator|->
name|i_nonleafkids
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Entry
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pindex
operator|->
name|i_nonleafkids
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* first, check for duplicates */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp
operator|=
name|pindex
operator|->
name|i_nonleafkids
init|;
operator|*
name|tmp
operator|!=
operator|(
expr|struct
name|entry
operator|*
operator|)
literal|0
condition|;
name|tmp
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|tmp
operator|==
name|e
condition|)
return|return;
block|}
name|pindex
operator|->
name|i_nonleafkids
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pindex
operator|->
name|i_nonleafkids
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|pindex
operator|->
name|i_nonleafkids
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
name|pindex
operator|->
name|i_nonleafkids
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULLENTRY
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * delete_nonleafkid - delete a reference to nonleaf child entry e  * in index index.  */
end_comment

begin_expr_stmt
specifier|static
name|delete_nonleafkid
argument_list|(
argument|e
argument_list|,
argument|pindex
argument_list|)
expr|struct
name|entry
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Index
modifier|*
name|pindex
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|entry
modifier|*
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|pindex
operator|->
name|i_nonleafkids
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Index has no non-leaf entries"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp
operator|=
name|pindex
operator|->
name|i_nonleafkids
init|;
operator|*
name|tmp
condition|;
name|tmp
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|tmp
operator|==
name|e
condition|)
break|break;
if|if
condition|(
operator|*
name|tmp
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|)
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Cannot find non-leaf entry"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|pindex
operator|->
name|i_nonleafkids
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|pindex
operator|->
name|i_nonleafkids
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|pindex
operator|->
name|i_nonleafkids
index|[
name|j
index|]
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * delete_nonlocalalias - delete a reference to nonlocal alias entry e  * in index index.  */
end_comment

begin_expr_stmt
specifier|static
name|delete_nonlocalalias
argument_list|(
argument|e
argument_list|,
argument|pindex
argument_list|)
expr|struct
name|entry
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Index
modifier|*
name|pindex
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|entry
modifier|*
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|pindex
operator|->
name|i_nonlocalaliases
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"index has no non-local aliases"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp
operator|=
name|pindex
operator|->
name|i_nonlocalaliases
init|;
operator|*
name|tmp
condition|;
name|tmp
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|tmp
operator|==
name|e
condition|)
break|break;
if|if
condition|(
operator|*
name|tmp
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|)
literal|0
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Cannot find non-local alias"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|pindex
operator|->
name|i_nonlocalaliases
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|pindex
operator|->
name|i_nonlocalaliases
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|pindex
operator|->
name|i_nonlocalaliases
index|[
name|j
index|]
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * turbo_attr_insert -- mark entry e as having attribute value val in  * index for attribute type attr.  */
end_comment

begin_expr_stmt
specifier|static
name|turbo_attr_insert
argument_list|(
argument|pindex
argument_list|,
argument|e
argument_list|,
argument|attr
argument_list|,
argument|values
argument_list|)
name|Index
operator|*
name|pindex
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Entry
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AttributeType
name|attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AV_Sequence
name|values
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|AV_Sequence
name|av
decl_stmt|;
name|Index_node
modifier|*
name|imem
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|,
modifier|*
name|code
decl_stmt|;
name|char
modifier|*
name|next_word
parameter_list|()
function_decl|;
name|IFP
name|approxfn
parameter_list|()
function_decl|;
name|int
name|soundex_match
parameter_list|()
function_decl|;
comment|/* find the appropriate index */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|turbo_index_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|pindex
index|[
name|i
index|]
operator|.
name|i_attr
argument_list|,
name|attr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|turbo_index_num
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"turbo_attr_insert: cannot find optimized attribute"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* insert all values */
for|for
control|(
name|av
operator|=
name|values
init|;
name|av
operator|!=
name|NULLAV
condition|;
name|av
operator|=
name|av
operator|->
name|avseq_next
control|)
block|{
name|imem
operator|=
operator|(
name|Index_node
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Index_node
argument_list|)
argument_list|)
expr_stmt|;
name|imem
operator|->
name|in_value
operator|=
operator|(
name|caddr_t
operator|)
name|AttrV_cpy
argument_list|(
operator|&
name|av
operator|->
name|avseq_av
argument_list|)
expr_stmt|;
name|imem
operator|->
name|in_entries
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|imem
operator|->
name|in_entries
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|e
expr_stmt|;
name|imem
operator|->
name|in_num
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Now we insert the entry into the appropriate index. 		 * If the attribute has a soundex approximate matching 		 * function, we insert the entry into the appropriate 		 * soundex index for that attribute. 		 */
comment|/* a return of OK means it was the first one inserted */
if|if
condition|(
name|avl_insert
argument_list|(
operator|&
name|pindex
index|[
name|i
index|]
operator|.
name|i_root
argument_list|,
operator|(
name|caddr_t
operator|)
name|imem
argument_list|,
name|index_cmp
argument_list|,
name|index_dup
argument_list|)
operator|==
name|OK
condition|)
block|{
name|pindex
index|[
name|i
index|]
operator|.
name|i_count
operator|++
expr_stmt|;
name|imem
operator|=
name|NULLINDEXNODE
expr_stmt|;
block|}
else|else
block|{
name|AttrV_free
argument_list|(
operator|(
name|AttributeValue
operator|)
name|imem
operator|->
name|in_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
operator|->
name|in_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|approxfn
argument_list|(
name|attr
operator|->
name|oa_syntax
argument_list|)
operator|!=
name|soundex_match
condition|)
continue|continue;
for|for
control|(
name|word
operator|=
operator|(
name|char
operator|*
operator|)
name|av
operator|->
name|avseq_av
operator|.
name|av_struct
init|;
name|word
condition|;
name|word
operator|=
name|next_word
argument_list|(
name|word
argument_list|)
control|)
block|{
name|code
operator|=
name|NULL
expr_stmt|;
name|soundex
argument_list|(
name|word
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|imem
operator|=
operator|(
name|Index_node
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Index_node
argument_list|)
argument_list|)
expr_stmt|;
name|imem
operator|->
name|in_value
operator|=
operator|(
name|caddr_t
operator|)
name|code
expr_stmt|;
name|imem
operator|->
name|in_entries
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|imem
operator|->
name|in_entries
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|e
expr_stmt|;
name|imem
operator|->
name|in_num
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|avl_insert
argument_list|(
operator|&
name|pindex
index|[
name|i
index|]
operator|.
name|i_sroot
argument_list|,
operator|(
name|caddr_t
operator|)
name|imem
argument_list|,
name|sindex_cmp
argument_list|,
name|index_dup
argument_list|)
operator|==
name|OK
condition|)
block|{
name|pindex
index|[
name|i
index|]
operator|.
name|i_scount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
operator|->
name|in_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
operator|->
name|in_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * turbo_add2index -- search through the given entry's attribute list for  * attrs to optimize. if an attr to optimize is found, we add that attribute   * along with a pointer to the corresponding entry to the appropriate   * attribute index.  */
end_comment

begin_macro
name|turbo_add2index
argument_list|(
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|e
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the entry these attrs belong to */
end_comment

begin_block
block|{
name|Entry
name|parent
decl_stmt|,
name|tmp
decl_stmt|;
name|Attr_Sequence
name|as
decl_stmt|,
name|entry_find_type
argument_list|()
decl_stmt|;
name|DN
name|pdn
decl_stmt|,
name|dn
decl_stmt|,
name|tmpdn
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|pcmp
decl_stmt|,
name|nonleaf
decl_stmt|;
name|Index
modifier|*
name|subindex
decl_stmt|;
name|Index
modifier|*
name|sibindex
decl_stmt|;
specifier|extern
name|AttributeType
name|at_masterdsa
decl_stmt|,
name|at_slavedsa
decl_stmt|;
if|if
condition|(
name|sibling_index
operator|==
operator|(
name|Avlnode
operator|*
operator|)
literal|0
operator|&&
name|subtree_index
operator|==
operator|(
name|Avlnode
operator|*
operator|)
literal|0
condition|)
return|return;
name|nonleaf
operator|=
operator|(
name|entry_find_type
argument_list|(
name|e
argument_list|,
name|at_masterdsa
argument_list|)
operator|!=
name|NULLATTR
operator|||
name|entry_find_type
argument_list|(
name|e
argument_list|,
name|at_slavedsa
argument_list|)
operator|!=
name|NULLATTR
operator|)
expr_stmt|;
name|parent
operator|=
name|e
operator|->
name|e_parent
expr_stmt|;
name|pdn
operator|=
name|get_copy_dn
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|dn
operator|=
name|get_copy_dn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sibindex
operator|=
name|get_sibling_index
argument_list|(
name|pdn
argument_list|)
expr_stmt|;
comment|/* for each attribute in the entry... */
for|for
control|(
name|as
operator|=
name|e
operator|->
name|e_attributes
init|;
name|as
operator|!=
name|NULLATTR
condition|;
name|as
operator|=
name|as
operator|->
name|attr_link
control|)
block|{
name|opt
operator|=
name|turbo_isoptimized
argument_list|(
name|as
operator|->
name|attr_type
argument_list|)
expr_stmt|;
comment|/* sibling index */
if|if
condition|(
name|sibindex
operator|&&
name|opt
condition|)
block|{
operator|(
name|void
operator|)
name|turbo_attr_insert
argument_list|(
name|sibindex
argument_list|,
name|e
argument_list|,
name|as
operator|->
name|attr_type
argument_list|,
name|as
operator|->
name|attr_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_alias
operator|&&
operator|(
operator|!
name|siblings
argument_list|(
name|dn
argument_list|,
name|sibindex
operator|->
name|i_dn
argument_list|)
operator|)
condition|)
name|add_nonlocalalias
argument_list|(
name|e
argument_list|,
name|sibindex
argument_list|)
expr_stmt|;
block|}
comment|/* could be a subtree index with all parents& this node */
for|for
control|(
name|tmp
operator|=
name|e
init|;
name|tmp
operator|->
name|e_parent
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|e_parent
control|)
block|{
name|tmpdn
operator|=
name|get_copy_dn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|subindex
operator|=
name|get_subtree_index
argument_list|(
name|tmpdn
argument_list|)
condition|)
block|{
if|if
condition|(
name|opt
condition|)
block|{
operator|(
name|void
operator|)
name|turbo_attr_insert
argument_list|(
name|subindex
argument_list|,
name|e
argument_list|,
name|as
operator|->
name|attr_type
argument_list|,
name|as
operator|->
name|attr_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_alias
condition|)
block|{
name|pcmp
operator|=
name|prefix
argument_list|(
name|subindex
operator|->
name|i_dn
argument_list|,
name|e
operator|->
name|e_alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmp
operator|!=
literal|0
operator|&&
name|pcmp
operator|!=
operator|-
literal|1
condition|)
block|{
name|add_nonlocalalias
argument_list|(
name|e
argument_list|,
name|subindex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nonleaf
condition|)
block|{
name|add_nonleafkid
argument_list|(
name|e
argument_list|,
name|subindex
argument_list|)
expr_stmt|;
name|nonleaf
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|dn_free
argument_list|(
name|tmpdn
argument_list|)
expr_stmt|;
block|}
block|}
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|pdn
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * turbo_attr_delete -- delete entry e from index for values of attribute  * attr.  */
end_comment

begin_expr_stmt
specifier|static
name|turbo_attr_delete
argument_list|(
argument|pindex
argument_list|,
argument|e
argument_list|,
argument|attr
argument_list|,
argument|values
argument_list|)
name|Index
operator|*
name|pindex
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Entry
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AttributeType
name|attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AV_Sequence
name|values
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|AV_Sequence
name|av
decl_stmt|;
name|Index_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|imem
decl_stmt|;
name|struct
name|entry
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|code
decl_stmt|,
modifier|*
name|word
decl_stmt|;
name|char
modifier|*
name|next_word
parameter_list|()
function_decl|;
comment|/* find the appropriate index */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|turbo_index_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|pindex
index|[
name|i
index|]
operator|.
name|i_attr
argument_list|,
name|attr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|turbo_index_num
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"turbo_attr_delete: cannot find optimized attribute"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* delete all values */
for|for
control|(
name|av
operator|=
name|values
init|;
name|av
operator|!=
name|NULLAV
condition|;
name|av
operator|=
name|av
operator|->
name|avseq_next
control|)
block|{
name|node
operator|=
operator|(
name|Index_node
operator|*
operator|)
name|avl_find
argument_list|(
name|pindex
index|[
name|i
index|]
operator|.
name|i_root
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|av
operator|->
name|avseq_av
argument_list|,
operator|(
name|IFP
operator|)
name|indexav_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULLINDEXNODE
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Optimized attribute value not found!\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* find the entry we want to delete */
name|p
operator|=
name|node
operator|->
name|in_entries
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|node
operator|->
name|in_num
condition|;
name|j
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|)
name|e
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|node
operator|->
name|in_num
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Optimized av entry not found"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|--
operator|(
name|node
operator|->
name|in_num
operator|)
operator|==
literal|0
condition|)
block|{
name|imem
operator|=
operator|(
name|Index_node
operator|*
operator|)
name|avl_delete
argument_list|(
operator|&
name|pindex
index|[
name|i
index|]
operator|.
name|i_root
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|av
operator|->
name|avseq_av
argument_list|,
name|indexav_cmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|AttrV_free
argument_list|(
operator|(
name|AttributeValue
operator|)
name|imem
operator|->
name|in_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
operator|->
name|in_entries
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
argument_list|)
expr_stmt|;
name|pindex
index|[
name|i
index|]
operator|.
name|i_count
operator|--
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<
name|node
operator|->
name|in_num
condition|;
name|k
operator|++
control|)
name|node
operator|->
name|in_entries
index|[
name|k
index|]
operator|=
name|node
operator|->
name|in_entries
index|[
name|k
operator|+
literal|1
index|]
expr_stmt|;
name|node
operator|->
name|in_entries
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|node
operator|->
name|in_entries
argument_list|,
operator|(
name|unsigned
operator|)
name|node
operator|->
name|in_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if there's a soundex index, delete from that too */
if|if
condition|(
name|pindex
index|[
name|i
index|]
operator|.
name|i_sroot
operator|==
name|NULLAVL
condition|)
continue|continue;
for|for
control|(
name|word
operator|=
name|av
operator|->
name|avseq_av
operator|.
name|av_struct
init|;
name|word
operator|!=
name|NULL
condition|;
name|word
operator|=
name|next_word
argument_list|(
name|word
argument_list|)
control|)
block|{
name|code
operator|=
name|NULL
expr_stmt|;
name|soundex
argument_list|(
name|word
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
comment|/* 			 * not finding the node is ok if the entry happens 			 * to be the only one with this code and was deleted 			 * on a previous pass through this loop.  we hope. 			 */
if|if
condition|(
operator|(
name|imem
operator|=
operator|(
name|Index_node
operator|*
operator|)
name|avl_find
argument_list|(
name|pindex
index|[
name|i
index|]
operator|.
name|i_sroot
argument_list|,
name|code
argument_list|,
name|index_soundex_cmp
argument_list|)
operator|)
operator|==
name|NULLINDEXNODE
condition|)
block|{
name|free
argument_list|(
name|code
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* find the entry */
name|p
operator|=
name|imem
operator|->
name|in_entries
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|imem
operator|->
name|in_num
condition|;
name|j
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
operator|(
expr|struct
name|entry
operator|*
operator|)
name|e
condition|)
break|break;
comment|/* 			 * not finding the entry is this is ok for the soundex 			 * index since an entry can appear more than once and 			 * might have already been deleted on a previous pass 			 */
if|if
condition|(
name|j
operator|==
name|imem
operator|->
name|in_num
condition|)
continue|continue;
if|if
condition|(
operator|--
operator|(
name|imem
operator|->
name|in_num
operator|)
operator|==
literal|0
condition|)
block|{
name|imem
operator|=
operator|(
name|Index_node
operator|*
operator|)
name|avl_delete
argument_list|(
operator|&
name|pindex
index|[
name|i
index|]
operator|.
name|i_sroot
argument_list|,
operator|(
name|caddr_t
operator|)
name|code
argument_list|,
name|index_soundex_cmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
operator|->
name|in_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
operator|->
name|in_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<
name|imem
operator|->
name|in_num
condition|;
name|k
operator|++
control|)
name|imem
operator|->
name|in_entries
index|[
name|k
index|]
operator|=
name|imem
operator|->
name|in_entries
index|[
name|k
operator|+
literal|1
index|]
expr_stmt|;
name|imem
operator|->
name|in_entries
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imem
operator|->
name|in_entries
argument_list|,
operator|(
name|unsigned
operator|)
name|imem
operator|->
name|in_num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * turbo_index_delete -- delete attribute index entries for the given  * entry from the attribute index associated with the entry's parent  * node.  */
end_comment

begin_macro
name|turbo_index_delete
argument_list|(
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|Entry
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Entry
name|parent
decl_stmt|,
name|tmp
decl_stmt|;
name|Attr_Sequence
name|as
decl_stmt|;
name|DN
name|pdn
decl_stmt|,
name|dn
decl_stmt|,
name|tmpdn
decl_stmt|;
name|Index
modifier|*
name|subindex
decl_stmt|;
name|Index
modifier|*
name|sibindex
decl_stmt|;
name|int
name|pcmp
decl_stmt|,
name|nonleaf
decl_stmt|;
if|if
condition|(
name|subtree_index
operator|==
name|NULLAVL
operator|&&
name|sibling_index
operator|==
name|NULLAVL
condition|)
return|return;
name|nonleaf
operator|=
operator|(
operator|!
name|isleaf
argument_list|(
name|e
argument_list|)
operator|)
expr_stmt|;
name|parent
operator|=
name|e
operator|->
name|e_parent
expr_stmt|;
name|pdn
operator|=
name|get_copy_dn
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|dn
operator|=
name|get_copy_dn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sibindex
operator|=
name|get_sibling_index
argument_list|(
name|pdn
argument_list|)
expr_stmt|;
comment|/* for each attribute in the entry... */
for|for
control|(
name|as
operator|=
name|e
operator|->
name|e_attributes
init|;
name|as
operator|!=
name|NULLATTR
condition|;
name|as
operator|=
name|as
operator|->
name|attr_link
control|)
block|{
if|if
condition|(
name|turbo_isoptimized
argument_list|(
name|as
operator|->
name|attr_type
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* sibling index */
if|if
condition|(
name|sibindex
condition|)
block|{
operator|(
name|void
operator|)
name|turbo_attr_delete
argument_list|(
name|sibindex
argument_list|,
name|e
argument_list|,
name|as
operator|->
name|attr_type
argument_list|,
name|as
operator|->
name|attr_value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
name|e
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|e_parent
control|)
block|{
name|tmpdn
operator|=
name|get_copy_dn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|subindex
operator|=
name|get_subtree_index
argument_list|(
name|tmpdn
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|turbo_attr_delete
argument_list|(
name|subindex
argument_list|,
name|e
argument_list|,
name|as
operator|->
name|attr_type
argument_list|,
name|as
operator|->
name|attr_value
argument_list|)
expr_stmt|;
block|}
name|dn_free
argument_list|(
name|tmpdn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now delete references in nonleafkids and nonlocalaliases... */
if|if
condition|(
name|sibindex
operator|&&
name|e
operator|->
name|e_alias
operator|&&
operator|(
operator|!
name|siblings
argument_list|(
name|dn
argument_list|,
name|sibindex
operator|->
name|i_dn
argument_list|)
operator|)
condition|)
name|delete_nonlocalalias
argument_list|(
name|e
argument_list|,
name|sibindex
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|pdn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonleaf
operator|==
literal|0
operator|&&
name|e
operator|->
name|e_alias
operator|==
name|NULLDN
condition|)
return|return;
for|for
control|(
name|tmp
operator|=
name|e
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|e_parent
control|)
block|{
name|tmpdn
operator|=
name|get_copy_dn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|subindex
operator|=
name|get_subtree_index
argument_list|(
name|tmpdn
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_alias
condition|)
block|{
name|pcmp
operator|=
name|prefix
argument_list|(
name|subindex
operator|->
name|i_dn
argument_list|,
name|e
operator|->
name|e_alias
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmp
operator|!=
literal|0
operator|&&
name|pcmp
operator|!=
operator|-
literal|1
condition|)
name|delete_nonlocalalias
argument_list|(
name|e
argument_list|,
name|subindex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonleaf
condition|)
name|delete_nonleafkid
argument_list|(
name|e
argument_list|,
name|subindex
argument_list|)
expr_stmt|;
block|}
name|dn_free
argument_list|(
name|tmpdn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * turbo_isoptimized -- return TRUE if attr is to be optimized, FALSE  * otherwise.  */
end_comment

begin_macro
name|turbo_isoptimized
argument_list|(
argument|attr
argument_list|)
end_macro

begin_decl_stmt
name|AttributeType
name|attr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|turbo_index_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|AttrT_cmp
argument_list|(
name|attr
argument_list|,
name|turbo_index_types
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * turbo_optimize -- add attribute attr to the list of attributes to be   * optimized this routine creates an empty index and arranges for the   * attribute to be optimized during loading.  */
end_comment

begin_macro
name|turbo_optimize
argument_list|(
argument|attr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|attr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|AttributeType
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|str2AttrT
argument_list|(
name|attr
argument_list|)
operator|)
operator|==
name|NULLAttrT
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Bad attribute type (%s)"
operator|,
name|attr
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|subtree_index
operator|||
name|sibling_index
condition|)
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"WARNING: optimized attributes MUST be specified before subtree or sibling index"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|turbo_index_types
operator|==
operator|(
name|AttributeType
operator|*
operator|)
literal|0
condition|)
name|turbo_index_types
operator|=
operator|(
name|AttributeType
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|AttributeType
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|turbo_index_types
operator|=
operator|(
name|AttributeType
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|turbo_index_types
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|turbo_index_num
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|AttributeType
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|turbo_index_types
operator|==
operator|(
name|AttributeType
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|66
argument_list|,
literal|"turbo_optimize: malloc failed!\n"
argument_list|)
expr_stmt|;
name|turbo_index_types
index|[
name|turbo_index_num
index|]
operator|=
name|AttrT_cpy
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|turbo_index_num
operator|++
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * index_subtree - arrange for the subtree starting at tree to be indexed.  */
end_comment

begin_macro
name|index_subtree
argument_list|(
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DN
name|dn
decl_stmt|,
name|str2dn
argument_list|()
decl_stmt|;
name|Index
modifier|*
name|pindex
decl_stmt|;
if|if
condition|(
operator|(
name|dn
operator|=
name|str2dn
argument_list|(
name|tree
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid subtree (%s)\n"
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pindex
operator|=
name|new_index
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_insert
argument_list|(
operator|&
name|subtree_index
argument_list|,
operator|(
name|caddr_t
operator|)
name|pindex
argument_list|,
name|i_cmp
argument_list|,
name|i_dup
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Subtree index for %s already exists\n"
operator|,
name|tree
operator|)
argument_list|)
expr_stmt|;
name|index_free
argument_list|(
name|pindex
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * index_siblings - arrange for the children of parent to be indexed.  */
end_comment

begin_macro
name|index_siblings
argument_list|(
argument|parent
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|parent
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DN
name|dn
decl_stmt|,
name|str2dn
argument_list|()
decl_stmt|;
name|Index
modifier|*
name|pindex
decl_stmt|;
if|if
condition|(
operator|(
name|dn
operator|=
name|str2dn
argument_list|(
name|parent
argument_list|)
operator|)
operator|==
name|NULLDN
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Invalid parent (%s)\n"
operator|,
name|parent
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pindex
operator|=
name|new_index
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn_free
argument_list|(
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_insert
argument_list|(
operator|&
name|sibling_index
argument_list|,
operator|(
name|caddr_t
operator|)
name|pindex
argument_list|,
name|i_cmp
argument_list|,
name|i_dup
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|LLOG
argument_list|(
name|log_dsap
argument_list|,
name|LLOG_EXCEPTIONS
argument_list|,
operator|(
literal|"Sibling index for %s already exists\n"
operator|,
name|parent
operator|)
argument_list|)
expr_stmt|;
name|index_free
argument_list|(
name|pindex
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* turbo_index */
end_comment

end_unit

