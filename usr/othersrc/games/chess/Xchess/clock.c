begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.4 $ on $Date: 86/11/26 12:09:47 $  *           $Source: /users/faustus/xchess/RCS/clock.c,v $  * Copyright (c) 1986 Wayne A. Christopher, U. C. Berkeley CAD Group  *	Permission is granted to do anything with this code except sell it  *	or remove this message.  *  * Do stuff with the clocks.  The way things work is as follows.  We call  * clock_init to draw the clocks initially, but they don't actually start  * running until we call clock_switch for the first time.  */
end_comment

begin_include
include|#
directive|include
file|"xchess.h"
end_include

begin_decl_stmt
name|int
name|movesperunit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeunit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|clock_started
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|whiteseconds
decl_stmt|,
name|blackseconds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|white_running
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|lastwhite
decl_stmt|,
name|lastblack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|firstmove
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|dohands
argument_list|()
decl_stmt|,
name|hilight
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PI
value|3.1415926535897932384
end_define

begin_function
name|void
name|clock_draw
parameter_list|(
name|win
parameter_list|,
name|col
parameter_list|)
name|windata
modifier|*
name|win
decl_stmt|;
name|color
name|col
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|int
name|x
init|=
name|CLOCK_WIDTH
operator|/
literal|2
decl_stmt|,
name|y
init|=
name|CLOCK_WIDTH
operator|/
literal|2
decl_stmt|;
name|int
name|xp
decl_stmt|,
name|yp
decl_stmt|;
name|int
name|rad
init|=
name|CLOCK_WIDTH
operator|/
literal|2
operator|-
literal|10
decl_stmt|;
name|Window
name|w
init|=
operator|(
operator|(
name|col
operator|==
name|WHITE
operator|)
condition|?
name|win
operator|->
name|wclockwin
else|:
name|win
operator|->
name|bclockwin
operator|)
decl_stmt|;
comment|/* Draw a clock face and the hands. */
name|XCircle
argument_list|(
name|w
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|rad
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|rad
operator|-=
literal|8
expr_stmt|;
name|XSetFont
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|small
operator|->
name|fid
argument_list|)
expr_stmt|;
name|XSetForeground
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|XSetBackground
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|xp
operator|=
name|x
operator|+
name|rad
operator|*
name|cos
argument_list|(
name|PI
operator|*
literal|3
operator|/
literal|2
operator|+
name|i
operator|*
name|PI
operator|/
literal|6
argument_list|)
operator|-
literal|4
expr_stmt|;
name|yp
operator|=
name|y
operator|+
name|rad
operator|*
name|sin
argument_list|(
name|PI
operator|*
literal|3
operator|/
literal|2
operator|+
name|i
operator|*
name|PI
operator|/
literal|6
argument_list|)
operator|-
literal|5
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XDrawString
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|w
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xp
argument_list|,
name|yp
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dohands
argument_list|(
name|win
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|white_running
condition|)
block|{
name|hilight
argument_list|(
name|win
argument_list|,
name|WHITE
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win
argument_list|,
name|BLACK
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hilight
argument_list|(
name|win
argument_list|,
name|WHITE
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win
argument_list|,
name|BLACK
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|clock_init
parameter_list|(
name|win
parameter_list|,
name|col
parameter_list|)
name|windata
modifier|*
name|win
decl_stmt|;
name|color
name|col
decl_stmt|;
block|{
name|whiteseconds
operator|=
name|blackseconds
operator|=
literal|0
expr_stmt|;
name|clock_started
operator|=
name|false
expr_stmt|;
name|firstmove
operator|=
name|true
expr_stmt|;
name|clock_draw
argument_list|(
name|win
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|clock_update
parameter_list|()
block|{
name|int
name|now
init|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|clock_started
condition|)
block|{
name|lastwhite
operator|=
name|lastblack
operator|=
name|now
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|white_running
condition|)
block|{
name|whiteseconds
operator|+=
name|now
operator|-
name|lastwhite
expr_stmt|;
name|lastwhite
operator|=
name|now
expr_stmt|;
name|dohands
argument_list|(
name|win1
argument_list|,
name|WHITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
name|dohands
argument_list|(
name|win2
argument_list|,
name|WHITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeunit
condition|)
block|{
name|i
operator|=
name|whiteseconds
operator|/
name|timeunit
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|whiteseconds
operator|>
name|i
operator|*
name|timeunit
operator|)
operator|&&
operator|(
name|whiteseconds
operator|<
name|i
operator|*
name|timeunit
operator|+
literal|10
operator|)
operator|&&
operator|(
name|movesperunit
operator|*
name|i
operator|>
name|movenum
operator|)
condition|)
block|{
name|message_add
argument_list|(
name|win1
argument_list|,
literal|"White has exceeded his time limit\n"
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|message_add
argument_list|(
name|win2
argument_list|,
literal|"White has exceeded his time limit\n"
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|timeunit
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|blackseconds
operator|+=
name|now
operator|-
name|lastblack
expr_stmt|;
name|lastblack
operator|=
name|now
expr_stmt|;
name|dohands
argument_list|(
name|win1
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
name|dohands
argument_list|(
name|win2
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeunit
condition|)
block|{
name|i
operator|=
name|blackseconds
operator|/
name|timeunit
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|blackseconds
operator|>
name|i
operator|*
name|timeunit
operator|)
operator|&&
operator|(
name|blackseconds
operator|<
name|i
operator|*
name|timeunit
operator|+
literal|10
operator|)
operator|&&
operator|(
name|movesperunit
operator|*
name|i
operator|>
name|movenum
operator|)
condition|)
block|{
name|message_add
argument_list|(
name|win1
argument_list|,
literal|"Black has exceeded his time limit\n"
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|message_add
argument_list|(
name|win2
argument_list|,
literal|"Black has exceeded his time limit\n"
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|timeunit
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|clock_switch
parameter_list|()
block|{
if|if
condition|(
name|firstmove
condition|)
block|{
name|clock_started
operator|=
name|true
expr_stmt|;
name|firstmove
operator|=
name|false
expr_stmt|;
name|lastwhite
operator|=
name|lastblack
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|white_running
condition|)
block|{
name|white_running
operator|=
name|false
expr_stmt|;
name|lastblack
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win1
argument_list|,
name|WHITE
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win1
argument_list|,
name|BLACK
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|hilight
argument_list|(
name|win2
argument_list|,
name|WHITE
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win2
argument_list|,
name|BLACK
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|white_running
operator|=
name|true
expr_stmt|;
name|lastwhite
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win1
argument_list|,
name|WHITE
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win1
argument_list|,
name|BLACK
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|hilight
argument_list|(
name|win2
argument_list|,
name|WHITE
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|hilight
argument_list|(
name|win2
argument_list|,
name|BLACK
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dohands
parameter_list|(
name|win
parameter_list|,
name|col
parameter_list|)
name|windata
modifier|*
name|win
decl_stmt|;
name|color
name|col
decl_stmt|;
block|{
name|int
name|cx
init|=
name|CLOCK_WIDTH
operator|/
literal|2
decl_stmt|,
name|cy
init|=
name|CLOCK_WIDTH
operator|/
literal|2
decl_stmt|;
name|double
modifier|*
name|h
init|=
operator|(
name|col
operator|==
name|WHITE
operator|)
condition|?
name|win
operator|->
name|whitehands
else|:
name|win
operator|->
name|blackhands
decl_stmt|;
name|Window
name|w
init|=
operator|(
name|col
operator|==
name|WHITE
operator|)
condition|?
name|win
operator|->
name|wclockwin
else|:
name|win
operator|->
name|bclockwin
decl_stmt|;
name|long
name|secs
init|=
operator|(
name|col
operator|==
name|WHITE
operator|)
condition|?
name|whiteseconds
else|:
name|blackseconds
decl_stmt|;
name|int
name|rad
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|;
comment|/* First erase the old hands. */
name|XSetState
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|rad
operator|=
name|CLOCK_WIDTH
operator|/
literal|2
operator|-
literal|30
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|cx
operator|+
name|rad
operator|*
name|sin
argument_list|(
name|PI
operator|-
name|h
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|cy
operator|+
name|rad
operator|*
name|cos
argument_list|(
name|PI
operator|-
name|h
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XSetLineAttributes
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|LineSolid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XDrawLine
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|w
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|rad
operator|-=
literal|8
expr_stmt|;
block|}
name|h
index|[
literal|0
index|]
operator|=
operator|(
name|secs
operator|%
literal|60
operator|)
operator|*
literal|2
operator|*
name|PI
operator|/
literal|60
expr_stmt|;
name|h
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|secs
operator|/
literal|60
operator|)
operator|%
literal|60
operator|)
operator|*
literal|2
operator|*
name|PI
operator|/
literal|60
expr_stmt|;
name|h
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|secs
operator|/
literal|3600
operator|)
operator|%
literal|12
operator|)
operator|*
literal|2
operator|*
name|PI
operator|/
literal|12
expr_stmt|;
comment|/* Now draw the new ones. */
name|XSetState
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|rad
operator|=
name|CLOCK_WIDTH
operator|/
literal|2
operator|-
literal|30
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|cx
operator|+
name|rad
operator|*
name|sin
argument_list|(
name|PI
operator|-
name|h
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|cy
operator|+
name|rad
operator|*
name|cos
argument_list|(
name|PI
operator|-
name|h
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|XSetLineAttributes
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|LineSolid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XDrawLine
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|w
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|rad
operator|-=
literal|8
expr_stmt|;
block|}
name|XFlush
argument_list|(
name|win
operator|->
name|display
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hilight
parameter_list|(
name|win
parameter_list|,
name|col
parameter_list|,
name|on
parameter_list|)
name|windata
modifier|*
name|win
decl_stmt|;
name|color
name|col
decl_stmt|;
name|bool
name|on
decl_stmt|;
block|{
name|Window
name|w
init|=
operator|(
name|col
operator|==
name|WHITE
operator|)
condition|?
name|win
operator|->
name|wclockwin
else|:
name|win
operator|->
name|bclockwin
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|col
operator|==
name|WHITE
operator|)
condition|?
literal|" WHITE "
else|:
literal|" BLACK "
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
name|XTextWidth
argument_list|(
name|win
operator|->
name|large
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|XSetState
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
else|else
name|XSetState
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XSetLineAttributes
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BORDER_WIDTH
argument_list|,
name|LineSolid
argument_list|,
name|CapButt
argument_list|,
name|JoinMiter
argument_list|)
expr_stmt|;
name|XSetFont
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|large
operator|->
name|fid
argument_list|)
expr_stmt|;
name|XDrawLine
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|w
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|CLOCK_HEIGHT
operator|-
literal|26
argument_list|,
name|CLOCK_WIDTH
argument_list|,
name|CLOCK_HEIGHT
operator|-
literal|26
argument_list|)
expr_stmt|;
name|XDrawImageString
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|w
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|CLOCK_WIDTH
operator|-
name|x
operator|)
operator|/
literal|2
argument_list|,
name|CLOCK_HEIGHT
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|XSetState
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|DefaultGC
argument_list|(
name|win
operator|->
name|display
argument_list|,
literal|0
argument_list|)
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

