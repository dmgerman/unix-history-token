begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.3 $ on $Date: 86/11/23 17:18:35 $  *           $Source: /users/faustus/xchess/RCS/valid.c,v $  * Copyright (c) 1986 Wayne A. Christopher, U. C. Berkeley CAD Group  *	Permission is granted to do anything with this code except sell it  *	or remove this message.  *  * Validate a move.  */
end_comment

begin_include
include|#
directive|include
file|"xchess.h"
end_include

begin_decl_stmt
specifier|extern
name|bool
name|ischeck
argument_list|()
decl_stmt|,
name|couldmove
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|valid_move
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
name|move
modifier|*
name|m
decl_stmt|;
name|board
modifier|*
name|b
decl_stmt|;
block|{
name|board
name|tb
decl_stmt|;
comment|/* First check that the piece can make the move at all... */
if|if
condition|(
operator|!
name|couldmove
argument_list|(
name|m
argument_list|,
name|b
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Now see if the king is in check now. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|board
argument_list|)
argument_list|)
expr_stmt|;
name|board_move
argument_list|(
operator|&
name|tb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ischeck
argument_list|(
operator|&
name|tb
argument_list|,
name|m
operator|->
name|piece
operator|.
name|color
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|ischeck
argument_list|(
operator|&
name|tb
argument_list|,
operator|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
condition|?
name|BLACK
else|:
name|WHITE
operator|)
argument_list|)
condition|)
name|m
operator|->
name|check
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|couldmove
parameter_list|(
name|m
parameter_list|,
name|b
parameter_list|)
name|move
modifier|*
name|m
decl_stmt|;
name|board
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
switch|switch
condition|(
name|m
operator|->
name|type
condition|)
block|{
case|case
name|KCASTLE
case|:
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
operator|&&
operator|(
name|b
operator|->
name|white_cant_castle_k
operator|)
operator|||
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|BLACK
operator|)
operator|&&
operator|(
name|b
operator|->
name|black_cant_castle_k
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
literal|5
index|]
operator|.
name|color
operator|!=
name|NONE
operator|)
operator|||
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
literal|6
index|]
operator|.
name|color
operator|!=
name|NONE
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|ischeck
argument_list|(
name|b
argument_list|,
name|m
operator|->
name|piece
operator|.
name|color
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
case|case
name|QCASTLE
case|:
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
operator|&&
operator|(
name|b
operator|->
name|white_cant_castle_q
operator|)
operator|||
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|BLACK
operator|)
operator|&&
operator|(
name|b
operator|->
name|black_cant_castle_q
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
literal|1
index|]
operator|.
name|color
operator|!=
name|NONE
operator|)
operator|||
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
literal|2
index|]
operator|.
name|color
operator|!=
name|NONE
operator|)
operator|||
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
literal|3
index|]
operator|.
name|color
operator|!=
name|NONE
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|ischeck
argument_list|(
name|b
argument_list|,
name|m
operator|->
name|piece
operator|.
name|color
argument_list|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
case|case
name|MOVE
case|:
case|case
name|CAPTURE
case|:
comment|/* There is one special case here, that of taking a pawn 		 * en passant.  In this case we change the move field to 		 * CAPTURE if it's ok. 		 */
switch|switch
condition|(
name|m
operator|->
name|piece
operator|.
name|type
condition|)
block|{
case|case
name|PAWN
case|:
if|if
condition|(
operator|(
name|m
operator|->
name|type
operator|==
name|MOVE
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromx
operator|==
name|m
operator|->
name|tox
operator|)
condition|)
block|{
comment|/* A normal move. */
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
operator|+
literal|1
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
literal|6
operator|)
operator|&&
operator|(
name|m
operator|->
name|toy
operator|==
literal|4
operator|)
operator|&&
operator|(
name|b
operator|->
name|square
index|[
literal|5
index|]
index|[
name|m
operator|->
name|fromx
index|]
operator|.
name|color
operator|==
name|NONE
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|BLACK
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
operator|-
literal|1
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|BLACK
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
literal|1
operator|)
operator|&&
operator|(
name|m
operator|->
name|toy
operator|==
literal|3
operator|)
operator|&&
operator|(
name|b
operator|->
name|square
index|[
literal|2
index|]
index|[
name|m
operator|->
name|fromx
index|]
operator|.
name|color
operator|==
name|NONE
operator|)
condition|)
break|break;
return|return
operator|(
name|false
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|type
operator|==
name|CAPTURE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
operator|+
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|BLACK
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|fromx
operator|==
name|m
operator|->
name|tox
operator|+
literal|1
operator|)
operator|||
operator|(
name|m
operator|->
name|fromx
operator|==
name|m
operator|->
name|tox
operator|-
literal|1
operator|)
operator|)
condition|)
break|break;
comment|/* Now maybe it's enpassant...  We've already 				 * checked for some of these things in the 				 * calling routine. 				 */
if|if
condition|(
name|m
operator|->
name|enpassant
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|square
index|[
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
condition|?
literal|3
else|:
literal|4
index|]
index|[
name|m
operator|->
name|tox
index|]
operator|.
name|color
operator|==
operator|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
condition|?
name|BLACK
else|:
name|WHITE
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
case|case
name|ROOK
case|:
if|if
condition|(
name|m
operator|->
name|fromx
operator|==
name|m
operator|->
name|tox
condition|)
block|{
for|for
control|(
name|y
operator|=
name|m
operator|->
name|fromy
operator|+
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
init|;
name|y
operator|!=
name|m
operator|->
name|toy
condition|;
name|y
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
control|)
if|if
condition|(
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|m
operator|->
name|tox
index|]
operator|.
name|color
operator|!=
name|NONE
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
condition|)
block|{
for|for
control|(
name|x
operator|=
name|m
operator|->
name|fromx
operator|+
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
init|;
name|x
operator|!=
name|m
operator|->
name|tox
condition|;
name|x
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
control|)
if|if
condition|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|toy
index|]
index|[
name|x
index|]
operator|.
name|color
operator|!=
name|NONE
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|false
operator|)
return|;
case|case
name|KNIGHT
case|:
name|x
operator|=
name|m
operator|->
name|fromx
operator|-
name|m
operator|->
name|tox
expr_stmt|;
name|y
operator|=
name|m
operator|->
name|fromy
operator|-
name|m
operator|->
name|toy
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|x
operator|==
literal|2
operator|)
operator|||
operator|(
name|x
operator|==
operator|-
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|y
operator|==
literal|1
operator|)
operator|||
operator|(
name|y
operator|==
operator|-
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|x
operator|==
literal|1
operator|)
operator|||
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|y
operator|==
literal|2
operator|)
operator|||
operator|(
name|y
operator|==
operator|-
literal|2
operator|)
operator|)
operator|)
condition|)
break|break;
return|return
operator|(
name|false
operator|)
return|;
case|case
name|BISHOP
case|:
name|x
operator|=
name|m
operator|->
name|fromx
operator|-
name|m
operator|->
name|tox
expr_stmt|;
name|y
operator|=
name|m
operator|->
name|fromy
operator|-
name|m
operator|->
name|toy
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|!=
name|y
operator|)
operator|&&
operator|(
name|x
operator|!=
operator|-
name|y
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
for|for
control|(
name|x
operator|=
name|m
operator|->
name|fromx
operator|+
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|,
name|y
operator|=
name|m
operator|->
name|fromy
operator|+
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
init|;
name|x
operator|!=
name|m
operator|->
name|tox
condition|;
name|x
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|,
name|y
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
control|)
if|if
condition|(
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|x
index|]
operator|.
name|color
operator|!=
name|NONE
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
case|case
name|QUEEN
case|:
if|if
condition|(
name|m
operator|->
name|fromx
operator|==
name|m
operator|->
name|tox
condition|)
block|{
for|for
control|(
name|y
operator|=
name|m
operator|->
name|fromy
operator|+
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
init|;
name|y
operator|!=
name|m
operator|->
name|toy
condition|;
name|y
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
control|)
if|if
condition|(
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|m
operator|->
name|tox
index|]
operator|.
name|color
operator|!=
name|NONE
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
condition|)
block|{
for|for
control|(
name|x
operator|=
name|m
operator|->
name|fromx
operator|+
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
init|;
name|x
operator|!=
name|m
operator|->
name|tox
condition|;
name|x
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
control|)
if|if
condition|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|toy
index|]
index|[
name|x
index|]
operator|.
name|color
operator|!=
name|NONE
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
block|}
name|x
operator|=
name|m
operator|->
name|fromx
operator|-
name|m
operator|->
name|tox
expr_stmt|;
name|y
operator|=
name|m
operator|->
name|fromy
operator|-
name|m
operator|->
name|toy
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|!=
name|y
operator|)
operator|&&
operator|(
name|x
operator|!=
operator|-
name|y
operator|)
condition|)
return|return
operator|(
name|false
operator|)
return|;
for|for
control|(
name|x
operator|=
name|m
operator|->
name|fromx
operator|+
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|,
name|y
operator|=
name|m
operator|->
name|fromy
operator|+
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
init|;
name|x
operator|!=
name|m
operator|->
name|tox
condition|;
name|x
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromx
operator|>
name|m
operator|->
name|tox
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
operator|,
name|y
operator|+=
operator|(
operator|(
name|m
operator|->
name|fromy
operator|>
name|m
operator|->
name|toy
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
control|)
if|if
condition|(
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|x
index|]
operator|.
name|color
operator|!=
name|NONE
condition|)
return|return
operator|(
name|false
operator|)
return|;
break|break;
case|case
name|KING
case|:
name|x
operator|=
name|m
operator|->
name|fromx
operator|-
name|m
operator|->
name|tox
expr_stmt|;
name|y
operator|=
name|m
operator|->
name|fromy
operator|-
name|m
operator|->
name|toy
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|>=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|x
operator|<=
literal|1
operator|)
operator|&&
operator|(
name|y
operator|>=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|y
operator|<=
literal|1
operator|)
condition|)
break|break;
return|return
operator|(
name|false
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Say whether either king is in check...  If move is non-NULL, say whether he  * in in check after the move takes place.  We do this in a rather stupid way.  */
end_comment

begin_function
specifier|static
name|bool
name|ischeck
parameter_list|(
name|b
parameter_list|,
name|col
parameter_list|)
name|board
modifier|*
name|b
decl_stmt|;
name|color
name|col
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|kx
decl_stmt|,
name|ky
decl_stmt|;
name|move
name|ch
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SIZE
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|SIZE
condition|;
name|y
operator|++
control|)
if|if
condition|(
operator|(
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|x
index|]
operator|.
name|color
operator|==
name|col
operator|)
operator|&&
operator|(
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|x
index|]
operator|.
name|type
operator|==
name|KING
operator|)
condition|)
block|{
name|kx
operator|=
name|x
expr_stmt|;
name|ky
operator|=
name|y
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|SIZE
condition|;
name|x
operator|++
control|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|SIZE
condition|;
name|y
operator|++
control|)
if|if
condition|(
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|x
index|]
operator|.
name|color
operator|==
operator|(
operator|(
name|col
operator|==
name|WHITE
operator|)
condition|?
name|BLACK
else|:
name|WHITE
operator|)
condition|)
block|{
name|ch
operator|.
name|type
operator|=
name|CAPTURE
expr_stmt|;
name|ch
operator|.
name|piece
operator|.
name|color
operator|=
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|x
index|]
operator|.
name|color
expr_stmt|;
name|ch
operator|.
name|piece
operator|.
name|type
operator|=
name|b
operator|->
name|square
index|[
name|y
index|]
index|[
name|x
index|]
operator|.
name|type
expr_stmt|;
name|ch
operator|.
name|fromx
operator|=
name|x
expr_stmt|;
name|ch
operator|.
name|fromy
operator|=
name|y
expr_stmt|;
name|ch
operator|.
name|tox
operator|=
name|kx
expr_stmt|;
name|ch
operator|.
name|toy
operator|=
name|ky
expr_stmt|;
name|ch
operator|.
name|enpassant
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|couldmove
argument_list|(
operator|&
name|ch
argument_list|,
name|b
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

end_unit

