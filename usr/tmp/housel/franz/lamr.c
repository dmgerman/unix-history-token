begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: lamr.c,v 1.6 84/04/06 23:14:05 layer Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 13:09:59 1983 by jkf]-  * 	lamr.c				$Locker:  $  * lambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_comment
comment|/*  *  *  Lalloc  *  *  This lambda allows allocation of pages from lisp.  The first  *  argument is the name of a space, n pages of which are allocated,  *  if possible.  Returns the number of pages allocated.  */
end_comment

begin_function
name|lispval
name|Lalloc
parameter_list|()
block|{
name|long
name|n
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|&&
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|!=
name|nil
condition|)
name|error
argument_list|(
literal|"2nd argument to allocate must be an integer"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|!=
name|nil
condition|)
name|n
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|alloc
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|,
name|n
argument_list|)
operator|)
return|;
comment|/*  call alloc to do the work  */
block|}
end_function

begin_function
name|lispval
name|Lsizeof
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"sizeof"
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|csizeof
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsegment
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"segment"
argument_list|)
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"LENGTH ARG TO SEGMENT MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
operator|<
literal|0
condition|)
block|{
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"LENGTH ARG TO SEGMENT MUST BE POSITIVE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
name|csegment
argument_list|(
name|typenum
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
argument_list|)
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Lforget  *************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  This function removes an atom from the hash table.			*/
end_comment

begin_function
name|lispval
name|Lforget
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|atom
modifier|*
name|buckpt
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"forget"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"remob: non-atom argument"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|pname
expr_stmt|;
name|hash
operator|=
name|hashfcn
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*  We have found the hash bucket for the atom, now we remove it  */
if|if
condition|(
name|hasht
index|[
name|hash
index|]
operator|==
operator|(
expr|struct
name|atom
operator|*
operator|)
name|lbot
operator|->
name|val
condition|)
block|{
name|hasht
index|[
name|hash
index|]
operator|=
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|hshlnk
expr_stmt|;
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|hshlnk
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
block|}
name|buckpt
operator|=
name|hasht
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|buckpt
operator|!=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
condition|)
block|{
if|if
condition|(
name|buckpt
operator|->
name|hshlnk
operator|==
operator|(
expr|struct
name|atom
operator|*
operator|)
name|lbot
operator|->
name|val
condition|)
block|{
name|buckpt
operator|->
name|hshlnk
operator|=
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|hshlnk
expr_stmt|;
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|hshlnk
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
block|}
name|buckpt
operator|=
name|buckpt
operator|->
name|hshlnk
expr_stmt|;
block|}
comment|/*  Whoops!  Guess it wasn't in the hash table after all.  */
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetl
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getlength"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO GETLENGTH MUST BE AN ARRAY"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|ar
operator|.
name|length
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputl
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putlength"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO PUTLENGTH MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"ARRAY LENGTH MUST BE AN INTEGER"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
operator|<=
literal|0
condition|)
block|{
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"ARRAY LENGTH MUST BE POSITIVE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|ar
operator|.
name|length
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetdel
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getdelta"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO GETDELTA MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|ar
operator|.
name|delta
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputdel
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putdelta"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO PUTDELTA MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"ARRAY LENGTH MUST BE AN INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
operator|<=
literal|0
condition|)
block|{
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"Array delta must be positive"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|ar
operator|.
name|delta
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetaux
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getaux"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"Arg to getaux must be an array"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|ar
operator|.
name|aux
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputaux
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putaux"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"1st Arg to putaux must be array"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|ar
operator|.
name|aux
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetdata
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getdata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"Arg to getdata must be an array"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|lbot
operator|->
name|val
operator|->
name|ar
operator|.
name|data
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputdata
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putdata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"1st Arg to putaux must be array"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgeta
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getaccess"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO GETACCESS MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|ar
operator|.
name|accfun
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputa
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putaccess"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO PUTACCESS MUST BE ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|ar
operator|.
name|accfun
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lmarray
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|5
argument_list|,
literal|"marray"
argument_list|)
expr_stmt|;
operator|(
name|handy
operator|=
name|newarray
argument_list|()
operator|)
expr_stmt|;
comment|/*  get a new array cell  */
name|handy
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|lbot
operator|->
name|val
expr_stmt|;
comment|/*  insert data address  */
name|handy
operator|->
name|ar
operator|.
name|accfun
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
comment|/*  insert access function  */
name|handy
operator|->
name|ar
operator|.
name|aux
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
comment|/*  insert aux data  */
name|handy
operator|->
name|ar
operator|.
name|length
operator|=
name|lbot
index|[
literal|3
index|]
operator|.
name|val
expr_stmt|;
comment|/*  insert length  */
name|handy
operator|->
name|ar
operator|.
name|delta
operator|=
name|lbot
index|[
literal|4
index|]
operator|.
name|val
expr_stmt|;
comment|/*  push delta arg  */
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgtentry
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getentry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARG TO GETENTRY MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|bcd
operator|.
name|start
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetlang
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getlang"
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"ARG TO GETLANG MUST BE FUNCTION DESCRIPTOR"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|bcd
operator|.
name|language
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputlang
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putlang"
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"FIRST ARG TO PUTLANG MUST BE FUNCTION DESCRIPTOR"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|bcd
operator|.
name|language
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
return|return
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetparams
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getparams"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARG TO GETPARAMS MUST BE A FUNCTION DESCRIPTOR"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|bcd
operator|.
name|params
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputparams
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putparams"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"1st ARG TO PUTPARAMS MUST BE FUNCTION DESCRIPTOR"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|bcd
operator|.
name|params
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetdisc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getdisc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARGUMENT OF GETDISC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|bcd
operator|.
name|discipline
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputdisc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putdisc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARGUMENT OF PUTDISC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetloc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARGUMENT TO GETLOC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|bcd
operator|.
name|loctab
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputloc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"putloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
empty_stmt|;
name|error
argument_list|(
literal|"FIRST ARGUMENT TO PUTLOC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|bcd
operator|.
name|loctab
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lmfunction
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"mfunction"
argument_list|)
expr_stmt|;
name|handy
operator|=
operator|(
name|newfunct
argument_list|()
operator|)
expr_stmt|;
comment|/*  get a new function cell  */
name|handy
operator|->
name|bcd
operator|.
name|start
operator|=
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|)
expr_stmt|;
comment|/* insert entry point */
name|handy
operator|->
name|bcd
operator|.
name|discipline
operator|=
operator|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|)
expr_stmt|;
comment|/*  insert discipline  */
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Lreplace ************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Destructively modifies almost any kind of data.		 	*/
end_comment

begin_function
name|lispval
name|Lreplace
parameter_list|()
block|{
specifier|register
name|lispval
name|a1
decl_stmt|,
name|a2
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"replace"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|TYPE
argument_list|(
name|a1
operator|=
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|TYPE
argument_list|(
name|a2
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"REPLACE ARGS MUST BE SAME TYPE"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|VALUE
case|:
name|a1
operator|->
name|l
operator|=
name|a2
operator|->
name|l
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|INT
case|:
name|a1
operator|->
name|i
operator|=
name|a2
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|ARRAY
case|:
name|a1
operator|->
name|ar
operator|.
name|data
operator|=
name|a2
operator|->
name|ar
operator|.
name|data
expr_stmt|;
name|a1
operator|->
name|ar
operator|.
name|accfun
operator|=
name|a2
operator|->
name|ar
operator|.
name|accfun
expr_stmt|;
name|a1
operator|->
name|ar
operator|.
name|length
operator|=
name|a2
operator|->
name|ar
operator|.
name|length
expr_stmt|;
name|a1
operator|->
name|ar
operator|.
name|delta
operator|=
name|a2
operator|->
name|ar
operator|.
name|delta
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|DOUB
case|:
name|a1
operator|->
name|r
operator|=
name|a2
operator|->
name|r
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|SDOT
case|:
case|case
name|DTPR
case|:
name|a1
operator|->
name|d
operator|.
name|car
operator|=
name|a2
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|a1
operator|->
name|d
operator|.
name|cdr
operator|=
name|a2
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|BCD
case|:
name|a1
operator|->
name|bcd
operator|.
name|start
operator|=
name|a2
operator|->
name|bcd
operator|.
name|start
expr_stmt|;
name|a1
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|a2
operator|->
name|bcd
operator|.
name|discipline
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Replace: cannot handle the type of this arg"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|a1
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* Lvaluep */
end_comment

begin_function
name|lispval
name|Lvaluep
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"valuep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|VALUE
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_macro
name|CNTTYP
argument_list|()
end_macro

begin_block
block|{
return|return;
comment|/* HI! COUNT ONE TYPE CALL! */
block|}
end_block

begin_function
name|lispval
name|Lod
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"od"
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"2nd ARG TO OD MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|val
operator|->
name|i
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
name|copval
argument_list|(
name|odform
argument_list|,
name|CNIL
argument_list|)
operator|->
name|a
operator|.
name|pname
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|np
index|[
operator|-
literal|2
index|]
operator|.
name|val
operator|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|poport
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfake
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"fake"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"ARG TO FAKE MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this used to be Lwhat, but was changed to Lmaknum for maclisp 	   compatiblity 	*/
end_comment

begin_function
name|lispval
name|Lmaknum
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"maknum"
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lderef
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"deref"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"arg to deref must be integer"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lpname
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"pname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"ARG TO PNAME MUST BE AN ATOM"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|pname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Larayref
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"arrayref"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"FIRST ARG TO ARRAYREF MUST BE ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vtemp
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|vtemp
argument_list|)
operator|!=
name|INT
condition|)
name|vtemp
operator|=
name|error
argument_list|(
literal|"SECOND ARG TO ARRAYREF MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtemp
operator|->
name|i
operator|<
literal|0
condition|)
block|{
name|vtemp
operator|=
name|error
argument_list|(
literal|"NEGATIVE ARRAY OFFSET"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
if|if
condition|(
name|vtemp
operator|->
name|i
operator|>=
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|ar
operator|.
name|length
operator|->
name|i
condition|)
block|{
name|vtemp
operator|=
name|error
argument_list|(
literal|"ARRAY OFFSET TOO LARGE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
name|vtemp
operator|=
call|(
name|lispval
call|)
argument_list|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|ar
operator|.
name|data
operator|+
operator|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|ar
operator|.
name|delta
operator|->
name|i
operator|)
operator|*
operator|(
name|vtemp
operator|->
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/*  compute address of desired item  */
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lptr
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"ptr"
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewval
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llctrace
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"lctrace"
argument_list|)
expr_stmt|;
name|lctrace
operator|=
call|(
name|int
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|lctrace
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lslevel
parameter_list|()
block|{
return|return
operator|(
name|inewint
argument_list|(
name|np
operator|-
name|orgnp
operator|-
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsimpld
parameter_list|()
block|{
specifier|register
name|lispval
name|pt
decl_stmt|;
specifier|register
name|char
modifier|*
name|cpt
init|=
name|strbuf
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"simpld"
argument_list|)
expr_stmt|;
for|for
control|(
name|atmlen
operator|=
literal|1
operator|,
name|pt
operator|=
name|np
operator|->
name|val
init|;
name|NOTNIL
argument_list|(
name|pt
argument_list|)
condition|;
operator|++
name|atmlen
operator|,
name|pt
operator|=
name|pt
operator|->
name|d
operator|.
name|cdr
control|)
empty_stmt|;
if|if
condition|(
name|atmlen
operator|>
name|STRBLEN
condition|)
block|{
name|error
argument_list|(
literal|"LCODE WAS TOO LONG"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|pt
operator|=
name|np
operator|->
name|val
init|;
name|NOTNIL
argument_list|(
name|pt
argument_list|)
condition|;
name|pt
operator|=
name|pt
operator|->
name|d
operator|.
name|cdr
control|)
operator|*
operator|(
name|cpt
operator|++
operator|)
operator|=
name|pt
operator|->
name|d
operator|.
name|car
operator|->
name|i
expr_stmt|;
operator|*
name|cpt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|newstr
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Lopval  *************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Routine which allows system registers and options to be examined	*/
end_comment

begin_comment
comment|/*  and modified.  Calls copval, the routine which is called by c code	*/
end_comment

begin_comment
comment|/*  to do the same thing from inside the system.			*/
end_comment

begin_function
name|lispval
name|Lopval
parameter_list|()
block|{
name|lispval
name|quant
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
return|return
operator|(
name|error
argument_list|(
literal|"bad call to opval"
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
name|quant
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/*  get name of sys variable  */
while|while
condition|(
name|TYPE
argument_list|(
name|quant
argument_list|)
operator|!=
name|ATOM
condition|)
name|quant
operator|=
name|error
argument_list|(
literal|"first arg to opval must be an atom"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|>
name|lbot
operator|+
literal|1
condition|)
name|vtemp
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
else|else
name|vtemp
operator|=
name|CNIL
expr_stmt|;
return|return
operator|(
name|copval
argument_list|(
name|quant
argument_list|,
name|vtemp
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

