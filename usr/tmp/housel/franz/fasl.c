begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: fasl.c,v 1.11 87/12/14 16:49:06 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Thu Jun  2 21:44:26 1983 by jkf]-  * 	fasl.c				$Locker:  $  * compiled lisp loader  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"lispo.h"
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* fasl  -  fast loader				j.k.foderaro  * this loader is tuned for the lisp fast loading application  * any changes in the system loading procedure will require changes  * to this file  *  *  The format of the object file we read as input:  *  text segment:  *    1) program text - this comes first.  *    2) binder table - one word entries, see struct bindage  *			begins with symbol:  bind_org  *    3) litterals - exploded lisp objects.   *			begins with symbol:  lit_org  *		        ends with symbol:    lit_end  * data segment:  *	not used  *  *  *  these segments are created permanently in memory:  *	code segment - contains machine codes to evaluate lisp functions.  *	linker segment - a list of pointers to lispvals.  This allows the  *			compiled code to reference constant lisp objects.  *		  	The first word of the linker segment is a gc link  *			pointer and does not point to a literal.  The  *			symbol binder is assumed to point to the second  *			longword in this segment.  The last word in the  *			table is -1 as a sentinal to the gc marker.  *			The number of real entries in the linker segment   *			is given as the value of the linker_size symbol.    *			Taking into account the 2 words required for the  *			gc, there are 4*linker_size + 8 bytes in this segment.  *	transfer segment - this is a transfer table block.  It is used to  *			allow compiled code to call other functions   *			quickly.  The number of entries in the transfer table is  *			given as the value of the trans_size symbol.  *  *  the following segments are set up in memory temporarily then flushed  *	binder segment -  a list of struct bindage entries.  They describe  *			what to do with the literals read from the literal  *			table.  The binder segment begins in the file  *			following the bindorg symbol.  *	literal segment - a list of characters which _Lread will read to   *			create the lisp objects.  The order of the literals  *			is:  *		         linker literals - used to fill the linker segment.  *			 transfer table literals - used to fill the   *			   transfer segment  *			 binder literals - these include names of functions  *			   to bind interspersed with forms to evaluate.  *			   The meanings of the binder literals is given by  *			   the values in the binder segment.  * 	string segment - this is the string table from the file.  We have  *			 to allocate space for it in core to speed up  *			 symbol referencing.  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* external functions called or referenced */
end_comment

begin_decl_stmt
name|lispval
name|qcons
argument_list|()
decl_stmt|,
name|qlinker
argument_list|()
decl_stmt|,
name|qget
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_qf0
argument_list|()
decl_stmt|,
name|_qf1
argument_list|()
decl_stmt|,
name|_qf2
argument_list|()
decl_stmt|,
name|_qf3
argument_list|()
decl_stmt|,
name|_qf4
argument_list|()
decl_stmt|,
name|_qfuncl
argument_list|()
decl_stmt|,
name|svkludg
argument_list|()
decl_stmt|,
name|qnewint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qnewdoub
argument_list|()
decl_stmt|,
name|qoneplus
argument_list|()
decl_stmt|,
name|qoneminus
argument_list|()
decl_stmt|,
name|wnaerr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|Lread
argument_list|()
decl_stmt|,
name|Lcons
argument_list|()
decl_stmt|,
name|Lminus
argument_list|()
decl_stmt|,
name|Ladd1
argument_list|()
decl_stmt|,
name|Lsub1
argument_list|()
decl_stmt|,
name|Lplist
argument_list|()
decl_stmt|,
name|Lputprop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|Lprint
argument_list|()
decl_stmt|,
name|Lpatom
argument_list|()
decl_stmt|,
name|Lconcat
argument_list|()
decl_stmt|,
name|Lget
argument_list|()
decl_stmt|,
name|Lmapc
argument_list|()
decl_stmt|,
name|Lmapcan
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|Llist
argument_list|()
decl_stmt|,
name|Ladd
argument_list|()
decl_stmt|,
name|Lgreaterp
argument_list|()
decl_stmt|,
name|Lequal
argument_list|()
decl_stmt|,
name|Ltimes
argument_list|()
decl_stmt|,
name|Lsub
argument_list|()
decl_stmt|,
name|Ipurcopy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|Lncons
argument_list|()
decl_stmt|,
name|Ibindvars
argument_list|()
decl_stmt|,
name|Iunbindvars
argument_list|()
decl_stmt|,
name|error
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|Inonlocalgo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|lispval
name|Istsrch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|mcount
argument_list|()
decl_stmt|,
name|qpushframe
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|mcnts
index|[]
decl_stmt|,
name|mcntp
decl_stmt|,
name|doprof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lispval
modifier|*
name|tynames
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|frame
modifier|*
name|errp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_erthrow
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* when TRUE, inhibits gc */
end_comment

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* stack space allocator */
end_comment

begin_comment
comment|/* mini symbol table, contains the only external symbols compiled code    is allowed to reference  */
end_comment

begin_struct
struct|struct
name|ssym
block|{
name|char
modifier|*
name|fnam
decl_stmt|;
comment|/* pointer to string containing name */
name|int
name|floc
decl_stmt|;
comment|/* address of symbol */
name|int
name|ord
decl_stmt|;
comment|/* ordinal number within cur sym tab */
block|}
name|Symbtb
index|[]
init|=
block|{
literal|"trantb"
block|,
literal|0
block|,
operator|-
literal|1
block|,
comment|/* must be first */
literal|"linker"
block|,
literal|0
block|,
operator|-
literal|1
block|,
comment|/* must be second */
literal|"mcount"
block|,
operator|(
name|int
operator|)
name|mcount
block|,
operator|-
literal|1
block|,
literal|"mcnts"
block|,
operator|(
name|int
operator|)
name|mcnts
block|,
operator|-
literal|1
block|,
literal|"_wnaerr"
block|,
operator|(
name|int
operator|)
name|wnaerr
block|,
operator|-
literal|1
block|,
literal|"_qnewint"
block|,
operator|(
name|int
operator|)
name|qnewint
block|,
operator|-
literal|1
block|,
literal|"_qnewdoub"
block|,
operator|(
name|int
operator|)
name|qnewdoub
block|,
operator|-
literal|1
block|,
literal|"_qcons"
block|,
operator|(
name|int
operator|)
name|qcons
block|,
operator|-
literal|1
block|,
literal|"_qoneplus"
block|,
operator|(
name|int
operator|)
name|qoneplus
block|,
operator|-
literal|1
block|,
literal|"_qoneminus"
block|,
operator|(
name|int
operator|)
name|qoneminus
block|,
operator|-
literal|1
block|,
literal|"_typetable"
block|,
operator|(
name|int
operator|)
name|typetable
block|,
operator|-
literal|1
block|,
literal|"_tynames"
block|,
operator|(
name|int
operator|)
name|tynames
block|,
operator|-
literal|1
block|,
literal|"_qget"
block|,
operator|(
name|int
operator|)
name|qget
block|,
operator|-
literal|1
block|,
literal|"_errp"
block|,
operator|(
name|int
operator|)
operator|&
name|errp
block|,
operator|-
literal|1
block|,
literal|"_Inonlocalgo"
block|,
operator|(
name|int
operator|)
name|Inonlocalgo
block|,
operator|-
literal|1
block|,
literal|"__erthrow"
block|,
operator|(
name|int
operator|)
name|_erthrow
block|,
operator|-
literal|1
block|,
literal|"_error"
block|,
operator|(
name|int
operator|)
name|error
block|,
operator|-
literal|1
block|,
literal|"_qpushframe"
block|,
operator|(
name|int
operator|)
name|qpushframe
block|,
operator|-
literal|1
block|,
literal|"_retval"
block|,
operator|(
name|int
operator|)
operator|&
name|retval
block|,
operator|-
literal|1
block|,
literal|"_lispretval"
block|,
operator|(
name|int
operator|)
operator|&
name|lispretval
block|,
operator|-
literal|1
block|,
ifndef|#
directive|ifndef
name|NPINREG
literal|"_np"
block|,
operator|(
name|int
operator|)
operator|&
name|np
block|,
operator|-
literal|1
block|,
literal|"_lbot"
block|,
operator|(
name|int
operator|)
operator|&
name|lbot
block|,
operator|-
literal|1
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NILIS0
literal|"_nilatom"
block|,
operator|(
name|int
operator|)
operator|&
name|nilatom
block|,
operator|-
literal|1
block|,
endif|#
directive|endif
literal|"_bnp"
block|,
operator|(
name|int
operator|)
operator|&
name|bnp
block|,
operator|-
literal|1
block|,
literal|"_Ibindvars"
block|,
operator|(
name|int
operator|)
name|Ibindvars
block|,
operator|-
literal|1
block|,
literal|"_Iunbindvars"
block|,
operator|(
name|int
operator|)
name|Iunbindvars
block|,
operator|-
literal|1
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SYMMAX
value|((sizeof Symbtb) / (sizeof (struct ssym)))
end_define

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|x
parameter_list|)
value|(char *)(((int)x + 3)& ~3)
end_define

begin_comment
comment|/* round to longword boundary */
end_comment

begin_decl_stmt
name|struct
name|nlist
name|syml
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to read a.out symb tab */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|bind_lists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gc binding lists 	  */
end_comment

begin_comment
comment|/* bindage structure:  *  the bindage structure describes the linkages of functions and name,  *  and tells which functions should be evaluated.  It is mainly used   *  for the non-fasl'ing of files, we only use one of the fields in fasl  */
end_comment

begin_struct
struct|struct
name|bindage
block|{
name|int
name|b_type
decl_stmt|;
comment|/* type code, as described below */
block|}
struct|;
end_struct

begin_comment
comment|/* the possible values of b_type  * -1 - this is the end of the bindage entries  * 0  - this is a lambda function  * 1  - this is a nlambda function  * 2  - this is a macro function  * 99 - evaluate the string  *  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|trtab
modifier|*
name|trhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of list of transfer tables	    */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|trent
modifier|*
name|trcur
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry to allocate		    */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|trleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of entries left in this transfer table */
end_comment

begin_function_decl
name|struct
name|trent
modifier|*
name|gettran
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* function to allocate entries */
end_comment

begin_comment
comment|/* maximum number of functions */
end_comment

begin_define
define|#
directive|define
name|MAXFNS
value|2000
end_define

begin_escape
end_escape

begin_function
name|lispval
name|Lfasl
parameter_list|()
block|{
specifier|extern
name|int
name|holend
decl_stmt|,
name|usehole
decl_stmt|;
specifier|extern
name|int
name|uctolc
decl_stmt|;
specifier|extern
name|char
modifier|*
name|curhbeg
decl_stmt|;
name|struct
name|argent
modifier|*
name|svnp
decl_stmt|;
name|struct
name|exec
name|exblk
decl_stmt|;
comment|/* stores a.out header */
name|FILE
modifier|*
name|filp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|map
decl_stmt|,
modifier|*
name|fstopen
argument_list|()
decl_stmt|;
comment|/* file pointer */
name|int
name|domap
decl_stmt|,
name|note_redef
decl_stmt|;
name|lispval
name|handy
decl_stmt|,
name|debugmode
decl_stmt|;
name|struct
name|relocation_info
name|reloc
decl_stmt|;
name|struct
name|trent
modifier|*
name|tranloc
decl_stmt|;
name|int
name|trsize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|times
decl_stmt|,
modifier|*
name|iptr
decl_stmt|;
name|int
name|funloc
index|[
name|MAXFNS
index|]
decl_stmt|;
comment|/* addresses of functions rel to txt org */
name|int
name|funcnt
init|=
literal|0
decl_stmt|;
comment|/* symbols whose values are taken from symbol table of .o file */
name|int
name|bind_org
init|=
literal|0
decl_stmt|;
comment|/* beginning of bind table */
name|int
name|lit_org
init|=
literal|0
decl_stmt|;
comment|/* beginning of literal table */
name|int
name|lit_end
decl_stmt|;
comment|/* end of literal table  */
name|int
name|trans_size
init|=
literal|0
decl_stmt|;
comment|/* size in entries of transfer table */
name|int
name|linker_size
decl_stmt|;
comment|/* size in bytes   of linker table  					(not counting gc ptr) */
comment|/* symbols which hold the locations of the segments in core and  	* in the file 	*/
name|char
modifier|*
name|code_core_org
decl_stmt|,
comment|/* beginning of code segment */
modifier|*
name|lc_org
decl_stmt|,
comment|/* beginning of linker segment */
modifier|*
name|lc_end
decl_stmt|,
comment|/* last word in linker segment */
modifier|*
name|literal_core_org
decl_stmt|,
comment|/* beginning of literal table   */
modifier|*
name|binder_core_org
decl_stmt|,
comment|/* beginning of binder table   */
modifier|*
name|string_core_org
decl_stmt|;
name|int
comment|/*string_file_org,	/* location of string table in file */
name|string_size
decl_stmt|,
comment|/* number of chars in string table */
name|segsiz
decl_stmt|;
comment|/* size of permanent incore segment */
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|struct
name|bindage
modifier|*
name|curbind
decl_stmt|;
name|lispval
name|rdform
decl_stmt|,
modifier|*
name|linktab
decl_stmt|;
name|int
name|ouctolc
decl_stmt|;
name|int
name|debug
init|=
literal|0
decl_stmt|;
name|lispval
name|currtab
decl_stmt|,
name|curibase
decl_stmt|;
name|char
name|ch
decl_stmt|,
modifier|*
name|filnm
decl_stmt|,
modifier|*
name|nfilnm
decl_stmt|;
name|char
name|tempfilbf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|strcat
parameter_list|()
function_decl|;
name|long
name|lseek
parameter_list|()
function_decl|;
name|Keepxs
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|0
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
break|break;
default|default:
name|argerr
argument_list|(
literal|"fasl"
argument_list|)
expr_stmt|;
block|}
name|filnm
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
literal|"fasl: non atom arg"
argument_list|)
expr_stmt|;
name|domap
operator|=
name|FALSE
expr_stmt|;
comment|/* debugging */
name|debugmode
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"debugging"
argument_list|)
argument_list|)
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|debugmode
operator|!=
name|nil
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
comment|/* end debugging */
comment|/* insure that the given file name ends in .o 	   if it doesnt, copy to a new buffer and add a .o 	   but Allow non .o file names (5mar80 jkf) 	*/
name|tempfilbf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nfilnm
operator|=
name|filnm
expr_stmt|;
comment|/* same file name for now */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|filnm
argument_list|)
operator|)
operator|<
literal|2
operator|||
name|strcmp
argument_list|(
name|filnm
operator|+
name|i
operator|-
literal|2
argument_list|,
literal|".o"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strncat
argument_list|(
name|tempfilbf
argument_list|,
name|filnm
argument_list|,
literal|96
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempfilbf
argument_list|,
literal|".o"
argument_list|)
expr_stmt|;
name|nfilnm
operator|=
name|tempfilbf
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|filp
operator|=
name|fopen
argument_list|(
name|nfilnm
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|filnm
operator|==
name|nfilnm
operator|)
operator|||
operator|(
operator|(
name|filp
operator|=
name|fopen
argument_list|(
name|filnm
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Can't open file"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|9797
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|handy
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|)
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|ATOM
operator|)
operator|||
operator|(
name|map
operator|=
name|fopen
argument_list|(
name|handy
operator|->
name|a
operator|.
name|pname
argument_list|,
operator|(
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"appendmap"
argument_list|)
argument_list|)
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|?
literal|"w"
else|:
literal|"a"
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"fasl: can't open map file"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|domap
operator|=
name|TRUE
expr_stmt|;
comment|/* fprintf(map,"Map of file %s\n",lbot->val->a.pname); */
block|}
block|}
comment|/* set the note redefinition flag */
if|if
condition|(
operator|(
name|lbot
operator|+
literal|2
operator|)
operator|->
name|val
operator|!=
name|nil
condition|)
name|note_redef
operator|=
name|TRUE
expr_stmt|;
else|else
name|note_redef
operator|=
name|FALSE
expr_stmt|;
comment|/* if nil don't print fasl message */
if|if
condition|(
name|Vldprt
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"[fasl %s]"
argument_list|,
name|filnm
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|svnp
operator|=
name|np
expr_stmt|;
comment|/* clear the ords in the symbol table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMMAX
condition|;
name|i
operator|++
control|)
name|Symbtb
index|[
name|i
index|]
operator|.
name|ord
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|filp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|exblk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
condition|)
name|error
argument_list|(
literal|"fasl: header read failed"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* check that the magic number is valid	*/
if|if
condition|(
name|exblk
operator|.
name|a_magic
operator|!=
literal|0407
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"fasl: file is not a lisp object file (bad magic number): "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* read in string table */
name|lseek
argument_list|(
name|fileno
argument_list|(
name|filp
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
comment|/*string_file_org =*/
name|N_STROFF
argument_list|(
name|exblk
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|filp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|string_size
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
name|error
argument_list|(
literal|"fasl: string table read error, probably old fasl format"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
comment|/* set up base for later calls */
comment|/* allocate space for string table on the stack */
name|string_core_org
operator|=
name|alloca
argument_list|(
name|string_size
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|filp
argument_list|)
argument_list|,
name|string_core_org
argument_list|,
name|string_size
operator|-
literal|4
argument_list|)
operator|!=
name|string_size
operator|-
literal|4
condition|)
name|error
argument_list|(
literal|"fasl: string table read error "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* read in symbol table and set the ordinal values */
name|fseek
argument_list|(
name|filp
argument_list|,
call|(
name|long
call|)
argument_list|(
name|N_SYMOFF
argument_list|(
name|exblk
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|times
operator|=
name|exblk
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|" %d symbols in symbol table\n"
argument_list|,
name|times
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|times
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|syml
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filp
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"fasl: Symb tab read error"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|syml
operator|.
name|n_un
operator|.
name|n_strx
operator|-
literal|4
operator|+
name|string_core_org
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"symbol %s\n read\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|syml
operator|.
name|n_type
operator|==
name|N_EXT
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SYMMAX
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Symbtb
index|[
name|j
index|]
operator|.
name|ord
operator|<
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|Symbtb
index|[
name|j
index|]
operator|.
name|fnam
argument_list|,
name|symbol_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Symbtb
index|[
name|j
index|]
operator|.
name|ord
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"symbol %s ord is %d\n"
argument_list|,
name|symbol_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|j
operator|>=
name|SYMMAX
condition|)
name|printf
argument_list|(
literal|"Unknown symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ch
operator|=
name|symbol_name
index|[
literal|0
index|]
operator|)
operator|==
literal|'s'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'L'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'.'
operator|)
condition|)
empty_stmt|;
comment|/* skip this */
elseif|else
if|if
condition|(
name|symbol_name
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
block|{
if|if
condition|(
name|funcnt
operator|>=
name|MAXFNS
condition|)
name|error
argument_list|(
literal|"fasl: too many function in file"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|funloc
index|[
name|funcnt
operator|++
index|]
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
comment|/* seeing function */
block|}
elseif|else
if|if
condition|(
operator|!
name|bind_org
operator|&&
operator|(
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"bind_org"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|bind_org
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"lit_org"
argument_list|)
operator|==
literal|0
condition|)
name|lit_org
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"lit_end"
argument_list|)
operator|==
literal|0
condition|)
name|lit_end
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"trans_size"
argument_list|)
operator|==
literal|0
condition|)
name|trans_size
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"linker_size"
argument_list|)
operator|==
literal|0
condition|)
name|linker_size
operator|=
name|syml
operator|.
name|n_value
expr_stmt|;
block|}
if|#
directive|if
name|m_68k
comment|/* 68k only, on the vax the symbols appear in the correct order */
block|{
name|int
name|compar
parameter_list|()
function_decl|;
name|qsort
argument_list|(
name|funloc
argument_list|,
name|funcnt
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|compar
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"lit_org %x,  lit_end %x, bind_org %x, linker_size %x\n"
argument_list|,
name|lit_org
argument_list|,
name|lit_end
argument_list|,
name|bind_org
argument_list|,
name|linker_size
argument_list|)
expr_stmt|;
comment|/* check to make sure we are working with the right format */
if|if
condition|(
operator|(
name|lit_org
operator|==
literal|0
operator|)
operator|||
operator|(
name|lit_end
operator|==
literal|0
operator|)
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"File not in new fasl format"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/*----------------*/
comment|/* read in text segment  up to beginning of binder table */
name|segsiz
operator|=
name|bind_org
operator|+
literal|4
operator|*
name|linker_size
operator|+
literal|8
operator|+
literal|3
expr_stmt|;
comment|/* size is core segment size 						 * plus linker table size 						 * plus 2 for gc list 						 * plus 3 to round up to word 						 */
name|lseek
argument_list|(
name|fileno
argument_list|(
name|filp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code_core_org
operator|=
operator|(
name|char
operator|*
operator|)
name|csegment
argument_list|(
name|OTHER
argument_list|,
name|segsiz
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|filp
argument_list|)
argument_list|,
name|code_core_org
argument_list|,
name|bind_org
argument_list|)
operator|!=
name|bind_org
condition|)
name|error
argument_list|(
literal|"Read error in text "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Read %d bytes of text into 0x%x\n"
argument_list|,
name|bind_org
argument_list|,
name|code_core_org
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" incore segment size: %d (0x%x)\n"
argument_list|,
name|segsiz
argument_list|,
name|segsiz
argument_list|)
expr_stmt|;
block|}
comment|/* linker table is 2 entries (8 bytes) larger than the number of 	 * entries given by linker_size .  There must be a gc word at 	 * the beginning and a -1 at the end 	 */
name|lc_org
operator|=
name|roundup
argument_list|(
name|code_core_org
operator|+
name|bind_org
argument_list|)
expr_stmt|;
name|lc_end
operator|=
name|lc_org
operator|+
literal|4
operator|*
name|linker_size
operator|+
literal|4
expr_stmt|;
comment|/* address of gc sentinal last */
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"lin_cor_org: %x, link_cor_end %x\n"
argument_list|,
name|lc_org
argument_list|,
name|lc_end
argument_list|)
expr_stmt|;
name|Symbtb
index|[
literal|1
index|]
operator|.
name|floc
operator|=
call|(
name|int
call|)
argument_list|(
name|lc_org
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* set the linker table to all -1's so we can put in the gc table */
for|for
control|(
name|iptr
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|lc_org
operator|+
literal|4
operator|)
init|;
name|iptr
operator|<=
operator|(
name|int
operator|*
operator|)
operator|(
name|lc_end
operator|)
condition|;
name|iptr
operator|++
control|)
operator|*
name|iptr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* link our table into the gc tables */
comment|/* only do so if we will not purcopy these tables */
if|if
condition|(
name|Vpurcopylits
operator|->
name|a
operator|.
name|clb
operator|==
name|nil
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|lc_org
operator|=
operator|(
name|int
operator|)
name|bind_lists
expr_stmt|;
comment|/* point to current */
name|bind_lists
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|lc_org
operator|+
literal|4
operator|)
expr_stmt|;
comment|/* point to first 	    							item */
block|}
comment|/* read the binder table and literals onto the stack */
name|binder_core_org
operator|=
name|alloca
argument_list|(
name|lit_end
operator|-
name|bind_org
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fileno
argument_list|(
name|filp
argument_list|)
argument_list|,
name|binder_core_org
argument_list|,
name|lit_end
operator|-
name|bind_org
argument_list|)
expr_stmt|;
name|literal_core_org
operator|=
name|binder_core_org
operator|+
name|lit_org
operator|-
name|bind_org
expr_stmt|;
comment|/* check if there is a transfer table required for this 	 * file, and if so allocate one of the necessary size 	 */
if|if
condition|(
name|trans_size
operator|>
literal|0
condition|)
block|{
name|tranloc
operator|=
name|gettran
argument_list|(
name|trans_size
argument_list|)
expr_stmt|;
name|Symbtb
index|[
literal|0
index|]
operator|.
name|floc
operator|=
operator|(
name|int
operator|)
name|tranloc
expr_stmt|;
block|}
comment|/* now relocate the necessary symbols in the text segment */
name|fseek
argument_list|(
name|filp
argument_list|,
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
operator|+
name|exblk
operator|.
name|a_text
operator|+
name|exblk
operator|.
name|a_data
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|times
operator|=
operator|(
name|exblk
operator|.
name|a_trsize
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
comment|/* the only symbols we will relocate are references to   		external symbols.  They are recognized by  		extern and pcrel set. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|times
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reloc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filp
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Bad text reloc read"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|.
name|r_extern
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SYMMAX
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|Symbtb
index|[
name|j
index|]
operator|.
name|ord
operator|==
name|reloc
operator|.
name|r_symbolnum
condition|)
comment|/* look for this sym */
block|{
define|#
directive|define
name|offset
parameter_list|(
name|p
parameter_list|)
value|(((p).r_pcrel) ? ((int) code_core_org): 0)
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Relocating %d (ord %d) at %x\n"
argument_list|,
name|j
argument_list|,
name|Symbtb
index|[
name|j
index|]
operator|.
name|ord
argument_list|,
name|reloc
operator|.
name|r_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|Symbtb
index|[
name|j
index|]
operator|.
name|floc
operator|==
operator|(
name|int
operator|)
name|mcnts
condition|)
block|{
name|add_offset
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|code_core_org
operator|+
name|reloc
operator|.
name|r_address
operator|)
argument_list|,
name|mcntp
operator|-
name|offset
argument_list|(
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprof
condition|)
block|{
if|if
condition|(
name|mcntp
operator|==
operator|(
name|int
operator|)
operator|&
name|mcnts
index|[
name|NMCOUNT
operator|-
literal|2
index|]
condition|)
name|printf
argument_list|(
literal|"Ran out of counters; increas NMCOUNT in fasl.c\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcntp
operator|<
operator|(
name|int
operator|)
operator|&
name|mcnts
index|[
name|NMCOUNT
operator|-
literal|1
index|]
condition|)
name|mcntp
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
name|add_offset
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|(
name|code_core_org
operator|+
name|reloc
operator|.
name|r_address
operator|)
argument_list|,
name|Symbtb
index|[
name|j
index|]
operator|.
name|floc
operator|-
name|offset
argument_list|(
name|reloc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
empty_stmt|;
if|if
condition|(
name|j
operator|>=
name|SYMMAX
condition|)
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Couldnt find ord # %d\n"
argument_list|,
name|reloc
operator|.
name|r_symbolnum
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Vldprt
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* set up a fake port so we can read from core */
comment|/* first find a free port 	 	       */
name|p
operator|=
name|fstopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|literal_core_org
argument_list|,
name|lit_end
operator|-
name|lit_org
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"lit_org %d, charstrt  %d\n"
argument_list|,
name|lit_org
argument_list|,
name|p
operator|->
name|_base
argument_list|)
expr_stmt|;
comment|/* the first forms we wish to read are those literals in the  	 * literal table, that is those forms referenced by an offset 	 * from r8 in  compiled code 	 */
comment|/* to read in the forms correctly, we must set up the read table 	 */
name|currtab
operator|=
name|Vreadtable
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|Vreadtable
operator|->
name|a
operator|.
name|clb
operator|=
name|strtab
expr_stmt|;
comment|/* standard read table */
name|curibase
operator|=
name|ibase
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|ibase
operator|->
name|a
operator|.
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* read in decimal */
name|ouctolc
operator|=
name|uctolc
expr_stmt|;
comment|/* remember value of uctolc flag */
name|PUSHDOWN
argument_list|(
name|gcdis
argument_list|,
name|tatom
argument_list|)
expr_stmt|;
comment|/* turn off gc */
name|i
operator|=
literal|1
expr_stmt|;
name|linktab
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|(
name|lc_org
operator|+
literal|4
operator|)
expr_stmt|;
while|while
condition|(
name|linktab
operator|<
operator|(
name|lispval
operator|*
operator|)
name|lc_end
condition|)
block|{
name|np
operator|=
name|svnp
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|uctolc
operator|=
name|FALSE
expr_stmt|;
name|handy
operator|=
operator|(
name|lispval
operator|)
name|Lread
argument_list|()
expr_stmt|;
if|if
condition|(
name|Vpurcopylits
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
name|handy
operator|=
name|Ipurcopy
argument_list|(
name|handy
argument_list|)
expr_stmt|;
block|}
name|uctolc
operator|=
name|ouctolc
expr_stmt|;
name|getc
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* eat trailing blank */
if|if
condition|(
name|debugmode
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"form %d read: "
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|handy
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|*
name|linktab
operator|++
operator|=
name|handy
expr_stmt|;
block|}
comment|/* process the transfer table if one is used		*/
name|trsize
operator|=
name|trans_size
expr_stmt|;
while|while
condition|(
name|trsize
operator|--
condition|)
block|{
name|np
operator|=
name|svnp
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|uctolc
operator|=
name|FALSE
expr_stmt|;
name|handy
operator|=
name|Lread
argument_list|()
expr_stmt|;
comment|/* get function name */
name|uctolc
operator|=
name|ouctolc
expr_stmt|;
name|getc
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tranloc
operator|->
name|name
operator|=
name|handy
expr_stmt|;
name|tranloc
operator|->
name|fcn
operator|=
name|qlinker
expr_stmt|;
comment|/* initially go to qlinker */
name|tranloc
operator|++
expr_stmt|;
block|}
comment|/* now process the binder table, which contains pointers to  	   functions to link in and forms to evaluate. 	*/
name|funcnt
operator|=
literal|0
expr_stmt|;
name|curbind
operator|=
operator|(
expr|struct
name|bindage
operator|*
operator|)
name|binder_core_org
expr_stmt|;
for|for
control|(
init|;
name|curbind
operator|->
name|b_type
operator|!=
operator|-
literal|1
condition|;
name|curbind
operator|++
control|)
block|{
name|np
operator|=
name|svnp
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|uctolc
operator|=
name|FALSE
expr_stmt|;
comment|/* inhibit uctolc conversion */
name|rdform
operator|=
name|Lread
argument_list|()
expr_stmt|;
comment|/* debugging */
if|if
condition|(
name|debugmode
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"link form read: "
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|rdform
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ,type: %d\n"
argument_list|,
name|curbind
operator|->
name|b_type
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* end debugging */
name|uctolc
operator|=
name|ouctolc
expr_stmt|;
comment|/* restore previous state */
name|getc
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* eat trailing null */
name|protect
argument_list|(
name|rdform
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbind
operator|->
name|b_type
operator|<=
literal|2
condition|)
comment|/* if function type */
block|{
name|handy
operator|=
name|newfunct
argument_list|()
expr_stmt|;
if|if
condition|(
name|note_redef
operator|&&
operator|(
name|rdform
operator|->
name|a
operator|.
name|fnbnd
operator|!=
name|nil
operator|)
condition|)
block|{
name|printr
argument_list|(
name|rdform
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" redefined\n"
argument_list|)
expr_stmt|;
block|}
name|rdform
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|handy
expr_stmt|;
name|handy
operator|->
name|bcd
operator|.
name|start
operator|=
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|code_core_org
operator|+
name|funloc
index|[
name|funcnt
operator|++
index|]
operator|)
expr_stmt|;
name|handy
operator|->
name|bcd
operator|.
name|discipline
operator|=
operator|(
name|curbind
operator|->
name|b_type
operator|==
literal|0
condition|?
name|lambda
else|:
name|curbind
operator|->
name|b_type
operator|==
literal|1
condition|?
name|nlambda
else|:
name|macro
operator|)
expr_stmt|;
if|if
condition|(
name|domap
condition|)
block|{
name|fprintf
argument_list|(
name|map
argument_list|,
literal|"%s\n%x\n"
argument_list|,
name|rdform
operator|->
name|a
operator|.
name|pname
argument_list|,
name|handy
operator|->
name|bcd
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Vreadtable
operator|->
name|a
operator|.
name|clb
operator|=
name|currtab
expr_stmt|;
name|ibase
operator|->
name|a
operator|.
name|clb
operator|=
name|curibase
expr_stmt|;
comment|/* debugging */
if|if
condition|(
name|debugmode
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"Eval: "
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|rdform
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* end debugging */
name|eval
argument_list|(
name|rdform
argument_list|)
expr_stmt|;
comment|/* otherwise eval it */
if|if
condition|(
name|uctolc
condition|)
name|ouctolc
operator|=
name|TRUE
expr_stmt|;
comment|/* if changed by eval, remember */
name|curibase
operator|=
name|ibase
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|ibase
operator|->
name|a
operator|.
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|Vreadtable
operator|->
name|a
operator|.
name|clb
operator|=
name|strtab
expr_stmt|;
block|}
block|}
empty_stmt|;
name|fclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* give up file descriptor */
name|POP
expr_stmt|;
comment|/* restore state of gcdisable variable */
name|Vreadtable
operator|->
name|a
operator|.
name|clb
operator|=
name|currtab
expr_stmt|;
name|chkrtab
argument_list|(
name|currtab
argument_list|)
expr_stmt|;
name|ibase
operator|->
name|a
operator|.
name|clb
operator|=
name|curibase
expr_stmt|;
name|fclose
argument_list|(
name|filp
argument_list|)
expr_stmt|;
if|if
condition|(
name|domap
condition|)
name|fclose
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|Freexs
argument_list|()
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|m_68k
end_if

begin_comment
comment|/* function used in qsort for 68k version only */
end_comment

begin_macro
name|compar
argument_list|(
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|arg1
operator|<
operator|*
name|arg2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|arg1
operator|==
operator|*
name|arg2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* gettran :: allocate a segment of transfer table of the given size	*/
end_comment

begin_function
name|struct
name|trent
modifier|*
name|gettran
parameter_list|(
name|size
parameter_list|)
block|{
name|struct
name|trtab
modifier|*
name|trp
decl_stmt|;
name|struct
name|trent
modifier|*
name|retv
decl_stmt|;
name|int
name|ousehole
decl_stmt|;
specifier|extern
name|int
name|usehole
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|TRENTS
condition|)
name|error
argument_list|(
literal|"transfer table too large"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|trleft
condition|)
block|{
comment|/* allocate a new transfer table */
comment|/* must not allocate in the hole or we cant modify it */
name|ousehole
operator|=
name|usehole
expr_stmt|;
comment|/* remember old value */
name|usehole
operator|=
name|FALSE
expr_stmt|;
name|trp
operator|=
operator|(
expr|struct
name|trtab
operator|*
operator|)
name|csegment
argument_list|(
name|OTHER
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trtab
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|usehole
operator|=
name|ousehole
expr_stmt|;
name|trp
operator|->
name|sentinal
operator|=
literal|0
expr_stmt|;
comment|/* make sure the sentinal is 0 */
name|trp
operator|->
name|nxtt
operator|=
name|trhead
expr_stmt|;
comment|/* link at beginning of table  */
name|trhead
operator|=
name|trp
expr_stmt|;
name|trcur
operator|=
operator|&
operator|(
name|trp
operator|->
name|trentrs
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* begin allocating here	*/
name|trleft
operator|=
name|TRENTS
expr_stmt|;
block|}
name|trleft
operator|=
name|trleft
operator|-
name|size
expr_stmt|;
name|retv
operator|=
name|trcur
expr_stmt|;
name|trcur
operator|=
name|trcur
operator|+
name|size
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* clrtt :: clear transfer tables, or link them all up;  * this has two totally opposite functions:  * 1) all transfer tables are reset so that all function calls will go  * through qlinker  * 2) as many transfer tables are set up to point to bcd functions  *    as possible  */
end_comment

begin_macro
name|clrtt
argument_list|(
argument|flag
argument_list|)
end_macro

begin_block
block|{
comment|/*  flag = 0 :: set to qlinker 	 *  flag = 1 :: set to function bcd binding if possible 	 */
specifier|register
name|struct
name|trtab
modifier|*
name|temptt
decl_stmt|;
specifier|register
name|struct
name|trent
modifier|*
name|tement
decl_stmt|;
specifier|register
name|lispval
name|fnb
decl_stmt|;
for|for
control|(
name|temptt
operator|=
name|trhead
init|;
name|temptt
operator|!=
literal|0
condition|;
name|temptt
operator|=
name|temptt
operator|->
name|nxtt
control|)
block|{
for|for
control|(
name|tement
operator|=
operator|&
name|temptt
operator|->
name|trentrs
index|[
literal|0
index|]
init|;
name|tement
operator|->
name|fcn
operator|!=
literal|0
condition|;
name|tement
operator|++
control|)
block|{
if|if
condition|(
name|flag
operator|==
literal|0
operator|||
name|TYPE
argument_list|(
name|fnb
operator|=
name|tement
operator|->
name|name
operator|->
name|a
operator|.
name|fnbnd
argument_list|)
operator|!=
name|BCD
operator|||
name|TYPE
argument_list|(
name|fnb
operator|->
name|bcd
operator|.
name|discipline
argument_list|)
operator|==
name|STRNG
condition|)
name|tement
operator|->
name|fcn
operator|=
name|qlinker
expr_stmt|;
else|else
name|tement
operator|->
name|fcn
operator|=
name|fnb
operator|->
name|bcd
operator|.
name|start
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* chktt - builds a list of transfer table entries which don't yet have   a function associated with them, i.e if this transfer table entry   were used, an undefined function error would result  */
end_comment

begin_function
name|lispval
name|chktt
parameter_list|()
block|{
specifier|register
name|struct
name|trtab
modifier|*
name|temptt
decl_stmt|;
specifier|register
name|struct
name|trent
modifier|*
name|tement
decl_stmt|;
specifier|register
name|lispval
name|retlst
decl_stmt|,
name|curv
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|retlst
operator|=
name|newdot
argument_list|()
expr_stmt|;
comment|/* build list of undef functions */
name|protect
argument_list|(
name|retlst
argument_list|)
expr_stmt|;
for|for
control|(
name|temptt
operator|=
name|trhead
init|;
name|temptt
operator|!=
literal|0
condition|;
name|temptt
operator|=
name|temptt
operator|->
name|nxtt
control|)
block|{
for|for
control|(
name|tement
operator|=
operator|&
name|temptt
operator|->
name|trentrs
index|[
literal|0
index|]
init|;
name|tement
operator|->
name|fcn
operator|!=
literal|0
condition|;
name|tement
operator|++
control|)
block|{
if|if
condition|(
name|tement
operator|->
name|name
operator|->
name|a
operator|.
name|fnbnd
operator|==
name|nil
condition|)
block|{
name|curv
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|curv
operator|->
name|d
operator|.
name|car
operator|=
name|tement
operator|->
name|name
expr_stmt|;
name|curv
operator|->
name|d
operator|.
name|cdr
operator|=
name|retlst
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|retlst
operator|->
name|d
operator|.
name|cdr
operator|=
name|curv
expr_stmt|;
block|}
block|}
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|retlst
operator|->
name|d
operator|.
name|cdr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* since the tahoe machine is picky about word/longword alignment ** when it is doing data access but not when doing instruction fetches, ** we have to add the relocation offset in a slightly different manner. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_expr_stmt
name|add_offset
argument_list|(
name|addr
argument_list|,
name|relocoffset
argument_list|)
specifier|register
name|int
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|r11
decl_stmt|,
name|r10
decl_stmt|,
name|r9
decl_stmt|,
name|r8
decl_stmt|;
asm|asm("	cvtbl	(r12), r0");
asm|asm("	cvtbl	8(fp), r1");
asm|asm("	cvtbl	1(r12), r8");
asm|asm("	cvtbl	9(fp), r9");
asm|asm("	cvtbl	2(r12), r10");
asm|asm("	cvtbl	10(fp), r11");
asm|asm("	addb2	11(fp), 3(r12)");
comment|/* add least sig. bytes */
asm|asm("	adwc	r11, r10");
asm|asm("	adwc	r9, r8");
asm|asm("	adwc	r1, r0");
asm|asm("	cvtlb	r10, 2(r12)");
asm|asm("	cvtlb	r8, 1(r12)");
asm|asm("	cvtlb	r0,(r12)");
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|add_offset
argument_list|(
name|addr
argument_list|,
name|relocoffset
argument_list|)
specifier|register
name|int
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|addr
operator|+=
name|relocoffset
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

