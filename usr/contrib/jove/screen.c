begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"temp.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|BufSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OkayAbort
decl_stmt|,
name|tabstop
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
argument_list|(
operator|*
name|TTins_line
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|TTdel_line
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scrimage
modifier|*
name|DesiredScreen
init|=
literal|0
decl_stmt|,
modifier|*
name|PhysScreen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|screenline
modifier|*
name|Screen
init|=
literal|0
decl_stmt|,
comment|/* the screen (a bunch of screenline) */
modifier|*
name|Savelines
init|=
literal|0
decl_stmt|,
comment|/* another bunch (LI of them) */
modifier|*
name|Curline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cursor
decl_stmt|,
comment|/* offset into current Line */
modifier|*
name|cursend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CapCol
decl_stmt|,
name|CapLine
decl_stmt|,
name|i_line
decl_stmt|,
name|i_col
decl_stmt|;
end_decl_stmt

begin_macro
name|make_scr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|ns
decl_stmt|;
specifier|register
name|char
modifier|*
name|nsp
decl_stmt|;
ifdef|#
directive|ifdef
name|RESHAPING
comment|/* In case we are RESHAPING the window! */
if|if
condition|(
name|DesiredScreen
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DesiredScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|PhysScreen
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PhysScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|Savelines
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Savelines
argument_list|)
expr_stmt|;
if|if
condition|(
name|Screen
condition|)
block|{
name|ns
operator|=
name|Screen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|ns
operator|++
operator|)
operator|->
name|s_line
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Screen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|RESHAPING
name|DesiredScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|PhysScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|Savelines
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|Screen
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|nsp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|CO
operator|*
name|LI
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n\rCannot malloc screen!\n"
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
control|)
block|{
name|ns
operator|->
name|s_line
operator|=
name|nsp
expr_stmt|;
name|nsp
operator|+=
name|CO
expr_stmt|;
name|ns
operator|->
name|s_length
operator|=
name|nsp
operator|-
literal|1
expr_stmt|;
comment|/* End of Line */
name|ns
operator|++
expr_stmt|;
block|}
name|cl_scr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|clrline
argument_list|(
name|cp1
argument_list|,
name|cp2
argument_list|)
specifier|register
name|char
operator|*
name|cp1
operator|,
operator|*
name|cp2
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|cp1
operator|<=
name|cp2
condition|)
operator|*
name|cp1
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|((*cursor != (char) (c)) ? dosputc(c) : (cursor++, i_col++))
end_define

begin_define
define|#
directive|define
name|soutputc
parameter_list|(
name|c
parameter_list|)
value|if (--n<= 0) break; else sputc(c)
end_define

begin_macro
name|cl_eol
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cursor
operator|>
name|cursend
condition|)
return|return;
if|if
condition|(
name|cursor
operator|<
name|Curline
operator|->
name|s_length
condition|)
block|{
if|if
condition|(
name|CE
condition|)
block|{
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clrline
argument_list|(
name|cursor
argument_list|,
name|Curline
operator|->
name|s_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ugh.  The slow way for dumb terminals. */
specifier|register
name|char
modifier|*
name|savecp
init|=
name|cursor
decl_stmt|;
while|while
condition|(
name|cursor
operator|<=
name|Curline
operator|->
name|s_length
condition|)
name|sputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|savecp
expr_stmt|;
block|}
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cl_scr
argument_list|(
argument|doit
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|sp
init|=
name|Screen
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
name|clrline
argument_list|(
name|sp
operator|->
name|s_line
argument_list|,
name|sp
operator|->
name|s_length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_length
operator|=
name|sp
operator|->
name|s_line
expr_stmt|;
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doit
condition|)
block|{
name|putpad
argument_list|(
name|CL
argument_list|,
name|LI
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|UpdMesg
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|ID_CHAR
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|IN_INSmode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output one character (if necessary) at the current position */
end_comment

begin_expr_stmt
name|dosputc
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|cursor
operator|!=
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i_line
operator|!=
name|CapLine
operator|||
name|i_col
operator|!=
name|CapCol
condition|)
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
if|if
condition|(
name|UL
operator|&&
operator|(
name|c
operator|&
literal|0177
operator|)
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|cursor
operator|&
literal|0177
operator|)
operator|!=
literal|' '
condition|)
name|putstr
argument_list|(
literal|" \b"
argument_list|)
expr_stmt|;
comment|/* Erase so '_' looks right. */
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
name|putchar
argument_list|(
name|c
operator|&
literal|0177
argument_list|)
expr_stmt|;
name|CapCol
operator|++
expr_stmt|;
name|i_col
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|++
expr_stmt|;
name|i_col
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Write `line' at the current position of `cursor'.  Stop when we    reach the end of the screen.  Aborts if there is a character    waiting.  */
end_comment

begin_expr_stmt
name|swrite
argument_list|(
name|line
argument_list|,
name|inversep
argument_list|,
name|abortable
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|abortable
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
name|i_col
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|;
name|int
name|or_byte
init|=
name|inversep
condition|?
literal|0200
else|:
literal|0
decl_stmt|,
name|thebyte
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
name|OkayAbort
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|line
operator|++
condition|)
block|{
if|if
condition|(
name|abortable
operator|&&
name|OkayAbort
condition|)
block|{
name|OkayAbort
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|InputPending
operator|=
name|charp
argument_list|()
condition|)
block|{
name|aborted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
decl_stmt|;
name|nchars
operator|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
name|thebyte
operator|=
operator|(
literal|' '
operator||
name|or_byte
operator|)
expr_stmt|;
while|while
condition|(
name|nchars
operator|--
condition|)
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|thebyte
operator|=
operator|(
literal|'^'
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
name|thebyte
operator|=
operator|(
operator|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
operator|)
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|thebyte
operator|=
operator|(
name|c
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|thebyte
operator|=
operator|(
literal|'!'
operator||
name|or_byte
operator|)
expr_stmt|;
name|sputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
return|return
operator|!
name|aborted
return|;
block|}
end_block

begin_comment
comment|/* This is for writing a buffer line to the screen.  This is to    minimize the amount of copying from one buffer to another buffer.    This gets the info directly from the disk buffers. */
end_comment

begin_macro
name|BufSwrite
argument_list|(
argument|linenum
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|,
name|col
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
name|int
name|StartCol
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
decl_stmt|,
name|visspace
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_window
operator|->
name|w_visspace
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|lcontents
argument_list|(
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_lp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|col
operator|>=
name|StartCol
condition|)
block|{
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
operator|=
name|col
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|col
operator|+=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|col
operator|+=
literal|2
expr_stmt|;
else|else
name|col
operator|++
expr_stmt|;
block|}
name|OkayAbort
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|(
operator|*
name|bp
operator|++
operator|&
literal|0177
operator|)
condition|)
block|{
if|if
condition|(
name|OkayAbort
condition|)
block|{
name|OkayAbort
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|InputPending
operator|=
name|charp
argument_list|()
condition|)
block|{
name|aborted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
init|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
decl_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
if|if
condition|(
name|visspace
condition|)
block|{
name|soutputc
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|nchars
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|soutputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|soutputc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|soutputc
argument_list|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|visspace
operator|&&
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|sputc
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
return|return
operator|!
name|aborted
return|;
comment|/* Didn't abort */
block|}
end_block

begin_expr_stmt
name|i_set
argument_list|(
name|nline
argument_list|,
name|ncol
argument_list|)
specifier|register
name|int
name|nline
operator|,
name|ncol
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Curline
operator|=
operator|&
name|Screen
index|[
name|nline
index|]
expr_stmt|;
name|cursor
operator|=
name|Curline
operator|->
name|s_line
operator|+
name|ncol
expr_stmt|;
name|cursend
operator|=
operator|&
name|Curline
operator|->
name|s_line
index|[
name|CO
operator|-
literal|1
index|]
expr_stmt|;
name|i_line
operator|=
name|nline
expr_stmt|;
name|i_col
operator|=
name|ncol
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert `num' lines a top, but leave all the lines BELOW `bottom'    alone (at least they won't look any different when we are done).    This changes the screen array AND does the physical changes. */
end_comment

begin_macro
name|v_ins_line
argument_list|(
argument|num
argument_list|,
argument|top
argument_list|,
argument|bottom
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Save the screen pointers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
expr_stmt|;
comment|/* Num number of bottom lines will be lost. 	   Copy everything down num number of times. */
for|for
control|(
name|i
operator|=
name|bottom
init|;
name|i
operator|>
name|top
operator|&&
name|i
operator|-
name|num
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|-
name|num
index|]
expr_stmt|;
comment|/* Restore the saved ones, making them blank. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
expr_stmt|;
block|}
call|(
modifier|*
name|TTins_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Delete `num' lines starting at `top' leaving the lines below `bottom'    alone.  This updates the internal image as well as the physical image.  */
end_comment

begin_macro
name|v_del_line
argument_list|(
argument|num
argument_list|,
argument|top
argument_list|,
argument|bottom
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|bot
decl_stmt|;
name|bot
operator|=
name|bottom
expr_stmt|;
comment|/* Save the lost lines. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
expr_stmt|;
comment|/* Copy everything up num number of lines. */
for|for
control|(
name|i
operator|=
name|top
init|;
name|num
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|+
name|num
index|]
expr_stmt|;
comment|/* Restore the lost ones, clearing them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
expr_stmt|;
name|bot
operator|--
expr_stmt|;
block|}
call|(
modifier|*
name|TTdel_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The cursor optimization happens here.  You may decide that this    is going too far with cursor optimization, or perhaps it should    limit the amount of checking to when the output speed is slow.    What ever turns you on ...   */
end_comment

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|cursaddr
block|{
name|int
name|c_numchars
decl_stmt|,
argument_list|(
operator|*
name|c_proc
argument_list|)
argument_list|()
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|char
modifier|*
name|Cmstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
modifier|*
name|HorMin
decl_stmt|,
modifier|*
name|VertMin
decl_stmt|,
modifier|*
name|DirectMin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|ForMotion
argument_list|()
decl_stmt|,
name|ForTab
argument_list|()
decl_stmt|,
name|BackMotion
argument_list|()
decl_stmt|,
name|RetTab
argument_list|()
decl_stmt|,
name|DownMotion
argument_list|()
decl_stmt|,
name|UpMotion
argument_list|()
decl_stmt|,
name|GoDirect
argument_list|()
decl_stmt|,
name|HomeGo
argument_list|()
decl_stmt|,
name|BottomUp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
name|WarpHor
index|[]
init|=
block|{
literal|0
block|,
name|ForMotion
block|,
literal|0
block|,
name|ForTab
block|,
literal|0
block|,
name|BackMotion
block|,
literal|0
block|,
name|RetTab
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
name|WarpVert
index|[]
init|=
block|{
literal|0
block|,
name|DownMotion
block|,
literal|0
block|,
name|UpMotion
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|cursaddr
name|WarpDirect
index|[]
init|=
block|{
literal|0
block|,
name|GoDirect
block|,
literal|0
block|,
name|HomeGo
block|,
literal|0
block|,
name|BottomUp
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|FORWARD
end_undef

begin_define
define|#
directive|define
name|FORWARD
value|0
end_define

begin_comment
comment|/* Move forward */
end_comment

begin_define
define|#
directive|define
name|FORTAB
value|1
end_define

begin_comment
comment|/* Forward using tabs */
end_comment

begin_undef
undef|#
directive|undef
name|BACKWARD
end_undef

begin_define
define|#
directive|define
name|BACKWARD
value|2
end_define

begin_comment
comment|/* Move backward */
end_comment

begin_define
define|#
directive|define
name|RETFORWARD
value|3
end_define

begin_comment
comment|/* Beginning of line and then tabs */
end_comment

begin_define
define|#
directive|define
name|NUMHOR
value|4
end_define

begin_define
define|#
directive|define
name|DOWN
value|0
end_define

begin_comment
comment|/* Move down */
end_comment

begin_define
define|#
directive|define
name|UPMOVE
value|1
end_define

begin_comment
comment|/* Move up */
end_comment

begin_define
define|#
directive|define
name|NUMVERT
value|2
end_define

begin_define
define|#
directive|define
name|DIRECT
value|0
end_define

begin_comment
comment|/* Using CM */
end_comment

begin_define
define|#
directive|define
name|HOME
value|1
end_define

begin_comment
comment|/* HOME	*/
end_comment

begin_define
define|#
directive|define
name|LOWER
value|2
end_define

begin_comment
comment|/* Lower Line */
end_comment

begin_define
define|#
directive|define
name|NUMDIRECT
value|3
end_define

begin_define
define|#
directive|define
name|home
parameter_list|()
value|Placur(0, 0)
end_define

begin_define
define|#
directive|define
name|LowLine
parameter_list|()
value|putpad(LL, 1), CapLine = ILI, CapCol = 0
end_define

begin_define
define|#
directive|define
name|PrintHo
parameter_list|()
value|putpad(HO, 1), CapLine = CapCol = 0
end_define

begin_decl_stmt
name|int
name|phystab
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|GoDirect
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|putpad
argument_list|(
name|Cmstr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|CapCol
operator|=
name|col
expr_stmt|;
block|}
end_function

begin_function
name|private
name|RetTab
parameter_list|(
name|col
parameter_list|)
specifier|register
name|int
name|col
decl_stmt|;
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
literal|0
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|HomeGo
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
block|{
name|PrintHo
argument_list|()
expr_stmt|;
name|DownMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|BottomUp
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|LowLine
argument_list|()
expr_stmt|;
name|UpMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tries to move forward using tabs (if possible).  It tabs to the    closest tabstop which means it may go past 'destcol' and backspace    to it. */
end_comment

begin_function
name|private
name|ForTab
parameter_list|(
name|destcol
parameter_list|)
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|ntabs
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|destcol
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
comment|/* Don't tab to last place or else it is likely to screw up. */
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|ntabs
operator|=
operator|(
name|tabgoal
operator|/
name|tabstp
operator|)
operator|-
operator|(
name|CapCol
operator|/
name|tabstp
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|ntabs
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|tabgoal
expr_stmt|;
block|}
if|if
condition|(
name|CapCol
operator|>
name|destcol
condition|)
name|BackMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CapCol
operator|<
name|destcol
condition|)
name|ForMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|ForMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|destcol
operator|-
name|CapCol
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
operator|&
name|Screen
index|[
name|CapLine
index|]
operator|.
name|s_line
index|[
name|CapCol
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
operator|*
name|cp
operator|++
operator|&
literal|0177
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
end_function

begin_function
name|private
name|BackMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapCol
operator|-
name|destcol
decl_stmt|;
if|if
condition|(
name|BC
condition|)
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
end_function

begin_function
name|private
name|DownMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nlines
init|=
name|destline
operator|-
name|CapLine
decl_stmt|;
while|while
condition|(
operator|--
name|nlines
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
end_function

begin_function
name|private
name|UpMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapLine
operator|-
name|destline
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|UP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ID_CHAR
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|EIlen
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|IMlen
decl_stmt|;
end_decl_stmt

begin_macro
name|InitCM
argument_list|()
end_macro

begin_block
block|{
name|HOlen
operator|=
name|HO
condition|?
name|strlen
argument_list|(
name|HO
argument_list|)
else|:
literal|1000
expr_stmt|;
name|LLlen
operator|=
name|LL
condition|?
name|strlen
argument_list|(
name|LL
argument_list|)
else|:
literal|1000
expr_stmt|;
name|UPlen
operator|=
name|UP
condition|?
name|strlen
argument_list|(
name|UP
argument_list|)
else|:
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|EI
condition|)
name|EIlen
operator|=
name|strlen
argument_list|(
name|EI
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|Placur
argument_list|(
argument|line
argument_list|,
argument|col
argument_list|)
end_macro

begin_block
block|{
name|int
name|dline
decl_stmt|,
comment|/* Number of lines to move */
name|dcol
decl_stmt|;
comment|/* Number of columns to move */
specifier|register
name|int
name|best
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|cursaddr
modifier|*
name|cp
decl_stmt|;
name|int
name|xtracost
init|=
literal|0
decl_stmt|;
comment|/* Misc addition to cost. */
define|#
directive|define
name|CursMin
parameter_list|(
name|which
parameter_list|,
name|addrs
parameter_list|,
name|max
parameter_list|)
define|\
value|for (best = 0, cp =&addrs[1], i = 1; i< max; i++, cp++) \ 		if (cp->c_numchars< addrs[best].c_numchars) \ 			best = i; \ 	which =&addrs[best];
if|if
condition|(
name|line
operator|==
name|CapLine
operator|&&
name|col
operator|==
name|CapCol
condition|)
return|return;
comment|/* We are already there. */
name|dline
operator|=
name|line
operator|-
name|CapLine
expr_stmt|;
name|dcol
operator|=
name|col
operator|-
name|CapCol
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
name|MI
condition|)
name|xtracost
operator|=
name|EIlen
operator|+
name|IMlen
expr_stmt|;
comment|/* If we're already in insert mode, it is likely that we will 	   want to be in insert mode again, after the insert. */
endif|#
directive|endif
comment|/* Number of characters to move horizontally for each case. 	   1: Just move forward by typing the right character on the screen. 	   2: Print the correct number of back spaces. 	   3: Try tabbing to the correct place. 	   4: Try going to the beginning of the line, and then tab. */
if|if
condition|(
name|dcol
operator|==
literal|1
operator|||
name|dcol
operator|==
literal|0
condition|)
block|{
comment|/* Most common case. */
name|HorMin
operator|=
operator|&
name|WarpHor
index|[
name|FORWARD
index|]
expr_stmt|;
name|HorMin
operator|->
name|c_numchars
operator|=
name|dcol
operator|+
name|xtracost
expr_stmt|;
block|}
else|else
block|{
name|WarpHor
index|[
name|FORWARD
index|]
operator|.
name|c_numchars
operator|=
name|dcol
operator|>=
literal|0
condition|?
name|dcol
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|BACKWARD
index|]
operator|.
name|c_numchars
operator|=
name|dcol
operator|<
literal|0
condition|?
operator|-
operator|(
name|dcol
operator|+
name|xtracost
operator|)
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|FORTAB
index|]
operator|.
name|c_numchars
operator|=
name|dcol
operator|>=
literal|0
operator|&&
name|TABS
condition|?
name|ForNum
argument_list|(
name|CapCol
argument_list|,
name|col
argument_list|)
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|c_numchars
operator|=
operator|(
name|xtracost
operator|+
literal|1
operator|+
operator|(
name|TABS
condition|?
name|ForNum
argument_list|(
literal|0
argument_list|,
name|col
argument_list|)
else|:
name|col
operator|)
operator|)
expr_stmt|;
comment|/* Which is the shortest of the bunch */
name|CursMin
argument_list|(
name|HorMin
argument_list|,
name|WarpHor
argument_list|,
name|NUMHOR
argument_list|)
expr_stmt|;
block|}
comment|/* Moving vertically is more simple. */
name|WarpVert
index|[
name|DOWN
index|]
operator|.
name|c_numchars
operator|=
name|dline
operator|>=
literal|0
condition|?
name|dline
else|:
literal|1000
expr_stmt|;
name|WarpVert
index|[
name|UPMOVE
index|]
operator|.
name|c_numchars
operator|=
name|dline
operator|<
literal|0
condition|?
operator|(
operator|(
operator|-
name|dline
operator|)
operator|*
name|UPlen
operator|)
else|:
literal|1000
expr_stmt|;
comment|/* Which of these is simpler */
name|CursMin
argument_list|(
name|VertMin
argument_list|,
name|WarpVert
argument_list|,
name|NUMVERT
argument_list|)
expr_stmt|;
comment|/* Homing first and lowering first are considered  	   direct motions. 	   Homing first's total is the sum of the cost of homing 	   and the sum of tabbing (if possible) to the right. */
if|if
condition|(
name|VertMin
operator|->
name|c_numchars
operator|+
name|HorMin
operator|->
name|c_numchars
operator|<=
literal|3
condition|)
block|{
name|DirectMin
operator|=
operator|&
name|WarpDirect
index|[
name|DIRECT
index|]
expr_stmt|;
comment|/* A dummy ... */
name|DirectMin
operator|->
name|c_numchars
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|WarpDirect
index|[
name|DIRECT
index|]
operator|.
name|c_numchars
operator|=
name|CM
condition|?
name|strlen
argument_list|(
name|Cmstr
operator|=
name|tgoto
argument_list|(
name|CM
argument_list|,
name|col
argument_list|,
name|line
argument_list|)
argument_list|)
else|:
literal|1000
expr_stmt|;
name|WarpDirect
index|[
name|HOME
index|]
operator|.
name|c_numchars
operator|=
name|HOlen
operator|+
name|line
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|c_numchars
expr_stmt|;
name|WarpDirect
index|[
name|LOWER
index|]
operator|.
name|c_numchars
operator|=
name|LLlen
operator|+
operator|(
operator|(
name|ILI
operator|-
name|line
operator|)
operator|*
name|UPlen
operator|)
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|c_numchars
expr_stmt|;
name|CursMin
argument_list|(
name|DirectMin
argument_list|,
name|WarpDirect
argument_list|,
name|NUMDIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HorMin
operator|->
name|c_numchars
operator|+
name|VertMin
operator|->
name|c_numchars
operator|<
name|DirectMin
operator|->
name|c_numchars
condition|)
block|{
if|if
condition|(
name|line
operator|!=
name|CapLine
condition|)
call|(
modifier|*
name|VertMin
operator|->
name|c_proc
call|)
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|!=
name|CapCol
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
comment|/* We may use real characters ... */
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|HorMin
operator|->
name|c_proc
call|)
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
operator|!
name|MI
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|DirectMin
operator|->
name|c_proc
call|)
argument_list|(
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0 ? (x) : -(x))
end_define

begin_expr_stmt
name|ForNum
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|int
name|from
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
name|int
name|numchars
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from
operator|>=
name|to
condition|)
return|return
name|from
operator|-
name|to
return|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|to
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|numchars
operator|=
operator|(
name|tabgoal
operator|/
name|tabstop
operator|)
operator|-
operator|(
name|from
operator|/
name|tabstp
operator|)
expr_stmt|;
name|from
operator|=
name|tabgoal
expr_stmt|;
block|}
return|return
name|numchars
operator|+
name|abs
argument_list|(
name|from
operator|-
name|to
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|WIRED_TERMS
end_ifdef

begin_macro
name|BGi_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"\033[%d;%dr\033[%dL\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SUNi_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|C100i_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENi_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|WIRED_TERMS
end_endif

begin_macro
name|GENi_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|printf
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SR
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_DL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_AL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|WIRED_TERMS
end_ifdef

begin_macro
name|BGd_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"\033[%d;%dr\033[%dM\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SUNd_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|C100d_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENd_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|WIRED_TERMS
end_endif

begin_macro
name|GENd_lines
argument_list|(
argument|top
argument_list|,
argument|bottom
argument_list|,
argument|num
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|printf
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|bottom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SF
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_DL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_AL
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_struct
struct|struct
name|ID_lookup
block|{
name|char
modifier|*
name|ID_name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|I_proc
function_decl|)
parameter_list|()
function_decl|;
comment|/* proc to insert lines */
name|int
function_decl|(
modifier|*
name|D_proc
function_decl|)
parameter_list|()
function_decl|;
comment|/* proc to delete lines */
block|}
name|ID_trms
index|[]
init|=
block|{
literal|"generic"
block|,
name|GENi_lines
block|,
name|GENd_lines
block|,
comment|/* This should stay here */
ifdef|#
directive|ifdef
name|WIRED_TERMS
literal|"sun"
block|,
name|SUNi_lines
block|,
name|SUNd_lines
block|,
literal|"bg"
block|,
name|BGi_lines
block|,
name|BGd_lines
block|,
literal|"c1"
block|,
name|C100i_lines
block|,
name|C100d_lines
block|,
endif|#
directive|endif
endif|WIRED_TERMS
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_macro
name|IDline_setup
argument_list|(
argument|tname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ID_lookup
modifier|*
name|idp
decl_stmt|;
for|for
control|(
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|1
index|]
init|;
name|idp
operator|->
name|ID_name
condition|;
name|idp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|,
name|tname
argument_list|,
name|strlen
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|idp
operator|->
name|ID_name
operator|==
literal|0
condition|)
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|0
index|]
expr_stmt|;
name|TTins_line
operator|=
name|idp
operator|->
name|I_proc
expr_stmt|;
name|TTdel_line
operator|=
name|idp
operator|->
name|D_proc
expr_stmt|;
block|}
end_block

end_unit

