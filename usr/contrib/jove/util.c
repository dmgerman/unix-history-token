begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|struct
name|cmd
modifier|*
name|FindCmd
argument_list|(
name|proc
argument_list|)
decl|register
name|int
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|commands
init|;
name|cp
operator|->
name|Name
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|cp
operator|->
name|c_proc
operator|==
name|proc
condition|)
return|return
name|cp
return|;
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
name|int
name|Interactive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when we invoke with the command handler? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ProcFmt
init|=
literal|": %f "
decl_stmt|;
end_decl_stmt

begin_macro
name|ExecCmd
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|data_obj
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|LastCmd
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|Type
operator|&
name|MAJOR_MODE
condition|)
name|SetMajor
argument_list|(
operator|(
name|cp
operator|->
name|Type
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|Type
operator|&
name|MINOR_MODE
condition|)
name|TogMinor
argument_list|(
operator|(
name|cp
operator|->
name|Type
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|cp
operator|->
name|Type
operator|&
name|TYPEMASK
condition|)
block|{
case|case
name|MACRO
case|:
name|do_macro
argument_list|(
operator|(
expr|struct
name|macro
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION
case|:
block|{
name|struct
name|cmd
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cp
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_proc
condition|)
call|(
modifier|*
name|cmd
operator|->
name|c_proc
call|)
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|Line
modifier|*
name|lastline
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
block|{
while|while
condition|(
name|lp
operator|->
name|l_next
condition|)
name|lp
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_expr_stmt
name|Upper
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|islower
argument_list|(
name|c
argument_list|)
condition|?
name|toupper
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|alarmed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|key_strokes
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|key_p
init|=
name|key_strokes
decl_stmt|;
end_decl_stmt

begin_macro
name|init_strokes
argument_list|()
end_macro

begin_block
block|{
name|key_strokes
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key_p
operator|=
name|key_strokes
expr_stmt|;
block|}
end_block

begin_macro
name|add_stroke
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|key_p
operator|+
literal|5
operator|>
operator|&
name|key_strokes
index|[
operator|(
sizeof|sizeof
name|key_strokes
operator|)
operator|-
literal|1
index|]
condition|)
name|key_p
operator|=
name|key_strokes
expr_stmt|;
name|sprintf
argument_list|(
name|key_p
argument_list|,
literal|"%p "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|key_p
operator|+=
name|strlen
argument_list|(
name|key_p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|slowpoke
argument_list|()
end_macro

begin_block
block|{
name|alarmed
operator|++
expr_stmt|;
name|f_mess
argument_list|(
name|key_strokes
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_define
define|#
directive|define
name|N_SEC
value|1
end_define

begin_comment
comment|/* will be precisely 1 second on 4.2 */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|N_SEC
value|2
end_define

begin_comment
comment|/* but from 0 to 2 seconds otherwise */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|waitchar
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|EUNICE
return|return
name|getch
argument_list|()
return|;
endif|#
directive|endif
name|unsigned
name|int
name|old_time
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
function_decl|(
modifier|*
name|oldproc
function_decl|)
parameter_list|()
function_decl|;
name|alarmed
operator|=
literal|0
expr_stmt|;
name|oldproc
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|slowpoke
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_time
operator|=
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|N_SEC
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|old_time
operator|=
name|UpdFreq
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|old_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|oldproc
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/* dir> 0 means forward; else means backward. */
end_comment

begin_function
name|char
modifier|*
name|StrIndex
parameter_list|(
name|dir
parameter_list|,
name|buf
parameter_list|,
name|charpos
parameter_list|,
name|what
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|,
name|what
decl_stmt|;
block|{
name|char
modifier|*
name|cp
init|=
operator|&
name|buf
index|[
name|charpos
index|]
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
if|if
condition|(
name|c
operator|==
name|what
condition|)
return|return
operator|(
name|cp
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|cp
operator|>=
name|buf
operator|&&
operator|(
name|c
operator|=
operator|*
name|cp
operator|--
operator|)
condition|)
if|if
condition|(
name|c
operator|==
name|what
condition|)
return|return
operator|(
name|cp
operator|+
literal|1
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|blnkp
argument_list|(
name|buf
argument_list|)
specifier|register
name|char
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|buf
operator|++
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
return|return
name|c
operator|==
literal|0
return|;
comment|/* It's zero if we got to the end of the Line */
block|}
end_block

begin_function
name|Line
modifier|*
name|next_line
parameter_list|(
name|line
parameter_list|,
name|num
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return
name|prev_line
argument_list|(
name|line
argument_list|,
operator|-
name|num
argument_list|)
return|;
if|if
condition|(
name|line
condition|)
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
operator|&&
name|line
operator|->
name|l_next
operator|!=
literal|0
condition|)
name|line
operator|=
name|line
operator|->
name|l_next
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|Line
modifier|*
name|prev_line
parameter_list|(
name|line
parameter_list|,
name|num
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return
name|next_line
argument_list|(
name|line
argument_list|,
operator|-
name|num
argument_list|)
return|;
if|if
condition|(
name|line
condition|)
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
operator|&&
name|line
operator|->
name|l_prev
operator|!=
literal|0
condition|)
name|line
operator|=
name|line
operator|->
name|l_prev
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_macro
name|DotTo
argument_list|(
argument|line
argument_list|,
argument|col
argument_list|)
end_macro

begin_decl_stmt
name|Line
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Bufpos
name|bp
decl_stmt|;
name|bp
operator|.
name|p_line
operator|=
name|line
expr_stmt|;
name|bp
operator|.
name|p_char
operator|=
name|col
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If bp->p_line is != current line, then save current line.  Then set dot    to bp->p_line, and if they weren't equal get that line into linebuf.  */
end_comment

begin_expr_stmt
name|SetDot
argument_list|(
name|bp
argument_list|)
specifier|register
name|Bufpos
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|notequal
decl_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
return|return;
name|notequal
operator|=
name|bp
operator|->
name|p_line
operator|!=
name|curline
expr_stmt|;
if|if
condition|(
name|notequal
condition|)
name|lsave
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|p_line
condition|)
name|curline
operator|=
name|bp
operator|->
name|p_line
expr_stmt|;
name|curchar
operator|=
name|bp
operator|->
name|p_char
expr_stmt|;
if|if
condition|(
name|notequal
condition|)
name|getDOT
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ToLast
argument_list|()
end_macro

begin_block
block|{
name|SetLine
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|MarkThresh
init|=
literal|22
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Average screen size ... */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_diff
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LineDist
argument_list|(
name|nextp
argument_list|,
name|endp
argument_list|)
specifier|register
name|Line
operator|*
name|nextp
operator|,
operator|*
name|endp
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|inorder
argument_list|(
name|nextp
argument_list|,
literal|0
argument_list|,
name|endp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|line_diff
return|;
block|}
end_block

begin_expr_stmt
name|inorder
argument_list|(
name|nextp
argument_list|,
name|char1
argument_list|,
name|endp
argument_list|,
name|char2
argument_list|)
specifier|register
name|Line
operator|*
name|nextp
operator|,
operator|*
name|endp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|Line
modifier|*
name|prevp
init|=
name|nextp
decl_stmt|;
name|line_diff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nextp
operator|==
name|endp
condition|)
return|return
name|char1
operator|<
name|char2
return|;
while|while
condition|(
name|nextp
operator|||
name|prevp
condition|)
block|{
if|if
condition|(
name|nextp
operator|==
name|endp
operator|||
name|prevp
operator|==
name|endp
condition|)
break|break;
if|if
condition|(
name|nextp
condition|)
name|nextp
operator|=
name|nextp
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|prevp
condition|)
name|prevp
operator|=
name|prevp
operator|->
name|l_prev
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nextp
operator|==
literal|0
operator|&&
name|prevp
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|line_diff
operator|=
name|count
expr_stmt|;
return|return
name|nextp
operator|==
name|endp
return|;
block|}
end_block

begin_expr_stmt
name|PushPntp
argument_list|(
name|line
argument_list|)
specifier|register
name|Line
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|exp_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LineDist
argument_list|(
name|curline
argument_list|,
name|line
argument_list|)
operator|>=
name|MarkThresh
condition|)
name|SetMark
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ToFirst
argument_list|()
end_macro

begin_block
block|{
name|SetLine
argument_list|(
name|curbuf
operator|->
name|b_first
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|length
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|Line
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|strlen
argument_list|(
name|lcontents
argument_list|(
name|line
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|to_word
argument_list|(
name|dir
argument_list|)
specifier|register
name|int
name|dir
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|linebuf
index|[
name|curchar
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|isword
argument_list|(
name|c
argument_list|)
condition|)
name|curchar
operator|++
expr_stmt|;
if|if
condition|(
name|eolp
argument_list|()
condition|)
block|{
if|if
condition|(
name|curline
operator|->
name|l_next
operator|==
literal|0
condition|)
return|return;
name|SetLine
argument_list|(
name|curline
operator|->
name|l_next
argument_list|)
expr_stmt|;
name|to_word
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|!
name|bolp
argument_list|()
operator|&&
operator|(
name|c
operator|=
name|linebuf
index|[
name|curchar
operator|-
literal|1
index|]
operator|,
operator|!
name|isword
argument_list|(
name|c
argument_list|)
operator|)
condition|)
operator|--
name|curchar
expr_stmt|;
if|if
condition|(
name|bolp
argument_list|()
condition|)
block|{
if|if
condition|(
name|curline
operator|->
name|l_prev
operator|==
literal|0
condition|)
return|return;
name|SetLine
argument_list|(
name|curline
operator|->
name|l_prev
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|to_word
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Are there any modified buffers?  Allp means include B_PROCESS and    B_IPROCESS buffers in the check, but never scratch buffers. */
end_comment

begin_macro
name|ModBufs
argument_list|(
argument|allp
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|b
operator|->
name|b_type
operator|==
name|B_SCRATCH
condition|)
continue|continue;
if|if
condition|(
operator|(
name|b
operator|->
name|b_type
operator|==
name|B_FILE
operator|||
name|allp
operator|)
operator|&&
name|IsModified
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|filename
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
return|return
name|b
operator|->
name|b_fname
condition|?
name|pr_name
argument_list|(
name|b
operator|->
name|b_fname
argument_list|)
else|:
literal|"[No file]"
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|itoa
parameter_list|(
name|num
parameter_list|)
specifier|register
name|int
name|num
decl_stmt|;
block|{
specifier|static
name|char
name|line
index|[
literal|15
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_expr_stmt
name|min
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|int
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
condition|?
name|a
else|:
name|b
return|;
block|}
end_block

begin_expr_stmt
name|max
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|int
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|a
operator|>
name|b
operator|)
condition|?
name|a
else|:
name|b
return|;
block|}
end_block

begin_expr_stmt
name|tiewind
argument_list|(
name|wp
argument_list|,
name|bp
argument_list|)
specifier|register
name|Window
operator|*
name|wp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|UpdModLine
operator|++
expr_stmt|;
comment|/* Kludge ... but speeds things up considerably */
name|wp
operator|->
name|w_line
operator|=
name|bp
operator|->
name|b_dot
expr_stmt|;
name|wp
operator|->
name|w_char
operator|=
name|bp
operator|->
name|b_char
expr_stmt|;
name|wp
operator|->
name|w_bufp
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|Jr_Len
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|lcontents
parameter_list|(
name|line
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
block|{
if|if
condition|(
name|line
operator|==
name|curline
condition|)
return|return
name|linebuf
return|;
else|else
return|return
name|lbptr
argument_list|(
name|line
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ltobuf
parameter_list|(
name|line
parameter_list|,
name|buf
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|line
operator|==
name|curline
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|linebuf
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|Jr_Len
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|getline
argument_list|(
name|line
operator|->
name|l_dline
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return none-zero if we had to rearrange the order. */
end_comment

begin_expr_stmt
name|fixorder
argument_list|(
name|line1
argument_list|,
name|char1
argument_list|,
name|line2
argument_list|,
name|char2
argument_list|)
specifier|register
name|Line
operator|*
operator|*
name|line1
operator|,
operator|*
operator|*
name|line2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|char1
decl_stmt|,
modifier|*
name|char2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Line
modifier|*
name|tline
decl_stmt|;
name|int
name|tchar
decl_stmt|;
if|if
condition|(
name|inorder
argument_list|(
operator|*
name|line1
argument_list|,
operator|*
name|char1
argument_list|,
operator|*
name|line2
argument_list|,
operator|*
name|char2
argument_list|)
condition|)
return|return
literal|0
return|;
name|tline
operator|=
operator|*
name|line1
expr_stmt|;
name|tchar
operator|=
operator|*
name|char1
expr_stmt|;
operator|*
name|line1
operator|=
operator|*
name|line2
expr_stmt|;
operator|*
name|char1
operator|=
operator|*
name|char2
expr_stmt|;
operator|*
name|line2
operator|=
name|tline
expr_stmt|;
operator|*
name|char2
operator|=
name|tchar
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_expr_stmt
name|inlist
argument_list|(
name|first
argument_list|,
name|what
argument_list|)
specifier|register
name|Line
operator|*
name|first
operator|,
operator|*
name|what
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|first
operator|==
name|what
condition|)
return|return
literal|1
return|;
name|first
operator|=
name|first
operator|->
name|l_next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Make `buf' modified and tell the redisplay code to update the modeline    if it will need to be changed. */
end_comment

begin_decl_stmt
name|int
name|ModCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|modify
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|DOLsave
decl_stmt|;
if|if
condition|(
operator|!
name|curbuf
operator|->
name|b_modified
condition|)
name|UpdModLine
operator|++
expr_stmt|;
name|curbuf
operator|->
name|b_modified
operator|++
expr_stmt|;
name|DOLsave
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|Asking
condition|)
name|ModCount
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|unmodify
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|curbuf
operator|->
name|b_modified
condition|)
name|UpdModLine
operator|++
expr_stmt|;
name|curbuf
operator|->
name|b_modified
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|numcomp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|!=
literal|0
operator|&&
operator|*
name|s1
operator|++
operator|==
operator|*
name|s2
operator|++
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|copystr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|val
init|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|val
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|byte_copy
end_ifndef

begin_expr_stmt
name|byte_copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|count
argument_list|)
specifier|register
name|char
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|len_error
argument_list|(
argument|flag
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|mesg
init|=
literal|"[line too long]"
decl_stmt|;
operator|(
name|flag
operator|==
name|COMPLAIN
operator|)
condition|?
name|complain
argument_list|(
name|mesg
argument_list|)
else|:
name|error
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert num number of c's at offset atchar in a linebuf of LBSIZE */
end_comment

begin_macro
name|ins_c
argument_list|(
argument|c
argument_list|,
argument|buf
argument_list|,
argument|atchar
argument_list|,
argument|num
argument_list|,
argument|max
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|pp1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|numchars
decl_stmt|;
comment|/* Number of characters to copy forward */
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
name|len
operator|=
name|atchar
operator|+
name|strlen
argument_list|(
operator|&
name|buf
index|[
name|atchar
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|num
operator|>=
name|max
condition|)
name|len_error
argument_list|(
name|COMPLAIN
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|buf
index|[
name|len
operator|+
literal|1
index|]
expr_stmt|;
comment|/* + 1 so we can --pp (not pp--) */
name|pp1
operator|=
operator|&
name|buf
index|[
name|len
operator|+
name|num
operator|+
literal|1
index|]
expr_stmt|;
name|numchars
operator|=
name|len
operator|-
name|atchar
expr_stmt|;
while|while
condition|(
name|numchars
operator|--
operator|>=
literal|0
condition|)
operator|*
operator|--
name|pp1
operator|=
operator|*
operator|--
name|pp
expr_stmt|;
name|pp
operator|=
operator|&
name|buf
index|[
name|atchar
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
operator|*
name|pp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_macro
name|TwoBlank
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Line
modifier|*
name|next
init|=
name|curline
operator|->
name|l_next
decl_stmt|;
return|return
operator|(
operator|(
name|next
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
operator|(
name|lcontents
argument_list|(
name|next
argument_list|)
operator|)
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|next
operator|->
name|l_next
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
operator|(
name|lcontents
argument_list|(
name|next
operator|->
name|l_next
argument_list|)
operator|)
operator|==
literal|'\0'
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|linecopy
argument_list|(
name|onto
argument_list|,
name|atchar
argument_list|,
name|from
argument_list|)
specifier|register
name|char
operator|*
name|onto
operator|,
operator|*
name|from
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|endp
init|=
operator|&
name|onto
index|[
name|LBSIZE
operator|-
literal|2
index|]
decl_stmt|;
name|onto
operator|+=
name|atchar
expr_stmt|;
while|while
condition|(
operator|*
name|onto
operator|=
operator|*
name|from
operator|++
condition|)
if|if
condition|(
name|onto
operator|++
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|IOerr
parameter_list|(
name|err
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|err
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
return|return
name|sprint
argument_list|(
literal|"Couldn't %s \"%s\"."
argument_list|,
name|err
argument_list|,
name|file
argument_list|)
return|;
block|}
end_block

begin_macro
name|pclose
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dopipe
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|p
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|complain
argument_list|(
literal|"[Pipe failed]"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* NOSTRICT */
end_comment

begin_function
name|char
modifier|*
name|emalloc
parameter_list|(
name|size
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
condition|)
return|return
name|ptr
return|;
comment|/* Try garbage collecting lines */
name|GCchunks
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
condition|)
return|return
name|ptr
return|;
comment|/* Uh ... Oh screw it! */
name|error
argument_list|(
literal|"[Out of memory] "
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* Return the basename of file F. */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|f
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
name|cp
operator|+
literal|1
return|;
else|else
return|return
name|f
return|;
block|}
end_function

begin_macro
name|push_env
argument_list|(
argument|savejmp
argument_list|)
end_macro

begin_decl_stmt
name|jmp_buf
name|savejmp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|byte_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mainjmp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|savejmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pop_env
argument_list|(
argument|savejmp
argument_list|)
end_macro

begin_decl_stmt
name|jmp_buf
name|savejmp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|byte_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|savejmp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mainjmp
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|LOAD_AV
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|PURDUE_EE
end_ifdef

begin_macro
name|get_la
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|double
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|dp
operator|=
operator|(
name|double
operator|)
name|loadav
argument_list|(
literal|0
argument_list|)
operator|/
literal|100.0
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
else|PURDUE_EE
end_else

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_avenrun"
block|}
block|,
define|#
directive|define
name|X_AVENRUN
value|0
block|{
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|get_la
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|double
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|avenrun
index|[
literal|3
index|]
decl_stmt|;
specifier|static
name|int
name|kmem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kmem
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|dp
operator|=
literal|4.0
expr_stmt|;
comment|/* So shell commands will say "Chugging" */
return|return;
block|}
elseif|else
if|if
condition|(
name|kmem
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|f_mess
argument_list|(
literal|"Can't open kmem for load average."
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
literal|4.0
expr_stmt|;
return|return;
block|}
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_AVENRUN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
name|avenrun
index|[
literal|0
index|]
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PURDUE_EE
end_endif

begin_else
else|#
directive|else
else|BSD4_2
end_else

begin_macro
name|get_la
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|double
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|avg
index|[
literal|3
index|]
decl_stmt|;
name|gldav
argument_list|(
name|avg
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
operator|(
name|double
operator|)
name|avg
index|[
literal|0
index|]
operator|/
literal|256
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|BSD4_2
end_endif

begin_endif
endif|#
directive|endif
endif|LOAD_AV
end_endif

begin_comment
comment|/* get the time buf, designated by *timep, from FROM to TO. */
end_comment

begin_function
name|char
modifier|*
name|get_time
parameter_list|(
name|timep
parameter_list|,
name|buf
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|time_t
modifier|*
name|timep
decl_stmt|;
block|{
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
if|if
condition|(
name|timep
operator|!=
literal|0
condition|)
name|now
operator|=
operator|*
name|timep
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
operator|+
name|from
expr_stmt|;
if|if
condition|(
name|to
operator|==
operator|-
literal|1
condition|)
name|cp
index|[
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get rid of \n */
else|else
name|cp
index|[
name|to
operator|-
name|from
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
else|else
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/* Return length of null terminated string. */
end_comment

begin_expr_stmt
name|strlen
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|base
init|=
name|s
operator|+
literal|1
decl_stmt|;
comment|/* Can you say kludge? */
while|while
condition|(
operator|*
name|s
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|s
operator|-
name|base
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|index
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|c1
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
while|while
condition|(
name|c1
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|c
operator|==
name|c1
condition|)
return|return
name|s
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|s1
operator|||
operator|!
name|s2
condition|)
return|return
literal|1
return|;
comment|/* Which is not zero ... */
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|*
name|s1
operator|-
operator|*
operator|--
name|s2
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|casecmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|s1
operator|||
operator|!
name|s2
condition|)
return|return
literal|1
return|;
comment|/* Which is not zero ... */
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
operator|||
name|Upper
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|Upper
argument_list|(
name|s2
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|*
name|s1
operator|-
operator|*
operator|--
name|s2
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|casencmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|s1
operator|||
operator|!
name|s2
condition|)
return|return
literal|1
return|;
comment|/* Which is not zero ... */
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
operator|||
name|Upper
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|Upper
argument_list|(
name|s2
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|*
name|s1
operator|-
operator|*
operator|--
name|s2
operator|)
return|;
block|}
end_block

begin_macro
name|null_ncpy
argument_list|(
argument|to
argument_list|,
argument|from
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|to
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|strcpy
argument_list|(
name|t
argument_list|,
name|f
argument_list|)
specifier|register
name|char
operator|*
name|t
operator|,
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
condition|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/* Tries to pause for delay/10 seconds OR until a character is typed    at the keyboard.  This works well on BSD4_2 and not so well on the    rest.  Returns 1 if it returned because of keyboard input, or 0    otherwise. */
end_comment

begin_macro
name|SitFor
argument_list|(
argument|delay
argument_list|)
end_macro

begin_decl_stmt
name|int
name|delay
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD4_2
include|#
directive|include
file|<sys/time.h>
name|struct
name|timeval
name|timer
decl_stmt|;
name|int
name|readfds
init|=
literal|1
decl_stmt|,
name|writefds
init|=
literal|0
decl_stmt|,
name|exceptfds
init|=
literal|0
decl_stmt|;
name|timer
operator|.
name|tv_sec
operator|=
operator|(
name|delay
operator|/
literal|10
operator|)
expr_stmt|;
name|timer
operator|.
name|tv_usec
operator|=
operator|(
name|delay
operator|%
literal|10
operator|)
operator|*
literal|100000
expr_stmt|;
if|if
condition|(
name|charp
argument_list|()
condition|)
return|return
literal|1
return|;
comment|/* gross that I had to snarf this from getch() */
if|if
condition|(
operator|!
name|UpdMesg
operator|&&
operator|!
name|Asking
condition|)
block|{
comment|/* Don't erase if we are asking */
if|if
condition|(
name|mesgbuf
index|[
literal|0
index|]
operator|&&
operator|!
name|errormsg
condition|)
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
block|}
name|redisplay
argument_list|()
expr_stmt|;
return|return
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|&
name|timer
argument_list|)
return|;
else|#
directive|else
specifier|static
name|float
name|cps
index|[]
init|=
block|{
literal|0.0
block|,
literal|5.0
block|,
literal|7.5
block|,
literal|11.0
block|,
literal|13.4
block|,
literal|15.0
block|,
literal|20.0
block|,
literal|30.0
block|,
literal|60.0
block|,
literal|120.0
block|,
literal|180.0
block|,
literal|240.0
block|,
literal|480.0
block|,
literal|960.0
block|,
literal|1920.0
block|,
literal|1920.0
block|, 	}
decl_stmt|;
name|float
name|nsecs
decl_stmt|;
specifier|register
name|int
name|nchars
decl_stmt|;
if|if
condition|(
name|charp
argument_list|()
condition|)
return|return
literal|1
return|;
name|nsecs
operator|=
operator|(
name|float
operator|)
name|delay
operator|/
literal|10
expr_stmt|;
name|nchars
operator|=
call|(
name|int
call|)
argument_list|(
name|nsecs
operator|*
name|cps
index|[
name|ospeed
index|]
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|nchars
operator|>
literal|0
operator|)
operator|&&
operator|!
name|InputPending
condition|)
block|{
name|putchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OkayAbort
condition|)
block|{
name|OkayAbort
operator|=
literal|0
expr_stmt|;
name|InputPending
operator|=
name|charp
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|InputPending
return|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|sindex
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|)
specifier|register
name|char
operator|*
name|pattern
operator|,
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
operator|*
name|string
operator|&&
name|strncmp
argument_list|(
name|pattern
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|string
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

end_unit

