begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|JOB_CONTROL
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_decl_stmt
name|int
name|InJoverc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|getch
argument_list|()
decl_stmt|,
name|getchar
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Auto execute code */
end_comment

begin_define
define|#
directive|define
name|NEXECS
value|20
end_define

begin_macro
name|private
end_macro

begin_struct
struct|struct
block|{
name|char
modifier|*
name|a_pattern
decl_stmt|;
name|data_obj
modifier|*
name|a_cmd
decl_stmt|;
block|}
name|AutoExecs
index|[
name|NEXECS
index|]
init|=
block|{
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|int
name|ExecIndex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command auto-execute. */
end_comment

begin_macro
name|CAutoExec
argument_list|()
end_macro

begin_block
block|{
name|DefAutoExec
argument_list|(
name|findcom
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Macro auto-execute. */
end_comment

begin_macro
name|MAutoExec
argument_list|()
end_macro

begin_block
block|{
name|DefAutoExec
argument_list|(
name|findmac
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS0 */
end_comment

begin_macro
name|DefAutoExec
argument_list|(
argument|proc
argument_list|)
end_macro

begin_function_decl
name|data_obj
modifier|*
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ExecIndex
operator|>=
name|NEXECS
condition|)
name|complain
argument_list|(
literal|"Too many auto-executes, max %d."
argument_list|,
name|NEXECS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
call|(
modifier|*
name|proc
call|)
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|pattern
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|": %f %s "
argument_list|,
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ExecIndex
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_cmd
operator|==
name|d
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pattern
argument_list|,
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_pattern
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* Eliminate duplicates. */
name|AutoExecs
index|[
name|ExecIndex
index|]
operator|.
name|a_pattern
operator|=
name|copystr
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|AutoExecs
index|[
name|ExecIndex
index|]
operator|.
name|a_cmd
operator|=
name|d
expr_stmt|;
name|ExecIndex
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* DoAutoExec: NEW and OLD are file names, and if NEW and OLD aren't the    same kind of file (i.e., match the same pattern) or OLD is 0 and it    matches, we execute the command associated with that kind of file. */
end_comment

begin_expr_stmt
name|DoAutoExec
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
specifier|register
name|char
operator|*
name|new
operator|,
operator|*
name|old
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|exp_p
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
comment|/* So minor modes don't toggle.  We always want 			   them on. */
if|if
condition|(
name|new
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ExecIndex
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|LookingAt
argument_list|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_pattern
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|old
operator|==
literal|0
operator|||
operator|!
name|LookingAt
argument_list|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_pattern
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|ExecCmd
argument_list|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_cmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|BindAKey
argument_list|()
end_macro

begin_block
block|{
name|BindSomething
argument_list|(
name|findcom
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|BindMac
argument_list|()
end_macro

begin_block
block|{
name|BindSomething
argument_list|(
name|findmac
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|EscPrefix
argument_list|()
decl_stmt|,
name|CtlxPrefix
argument_list|()
decl_stmt|,
name|MiscPrefix
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|data_obj
modifier|*
modifier|*
name|IsPrefix
parameter_list|(
name|cp
parameter_list|)
name|data_obj
modifier|*
name|cp
decl_stmt|;
block|{
name|int
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|cp
operator|==
literal|0
operator|||
operator|(
name|cp
operator|->
name|Type
operator|&
name|TYPEMASK
operator|)
operator|!=
name|FUNCTION
condition|)
return|return
literal|0
return|;
name|proc
operator|=
operator|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|cp
operator|)
operator|->
name|c_proc
expr_stmt|;
if|if
condition|(
name|proc
operator|==
name|EscPrefix
condition|)
return|return
name|pref1map
return|;
if|if
condition|(
name|proc
operator|==
name|CtlxPrefix
condition|)
return|return
name|pref2map
return|;
if|if
condition|(
name|proc
operator|==
name|MiscPrefix
condition|)
return|return
name|miscmap
return|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|unbind_aux
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|c
operator|==
name|CR
operator|||
name|c
operator|==
name|LF
condition|)
return|return
name|FALSE
return|;
comment|/* tells do_ask to return */
name|Insert
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|!
name|FALSE
return|;
block|}
end_block

begin_macro
name|UnbindC
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|data_obj
modifier|*
modifier|*
name|map
init|=
name|mainmap
decl_stmt|;
name|keys
operator|=
name|do_ask
argument_list|(
literal|"\r\n\01\02\03\04\05\06\010\011\013\014\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"
argument_list|,
name|unbind_aux
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|keys
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|(
name|map
operator|=
name|IsPrefix
argument_list|(
name|map
index|[
operator|*
name|keys
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|keys
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|keys
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|complain
argument_list|(
literal|"That's not a legitimate key sequence."
argument_list|)
expr_stmt|;
name|map
index|[
name|keys
index|[
literal|0
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|addgetc
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|InJoverc
condition|)
name|Asking
operator|=
name|strlen
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|InJoverc
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|EOF
return|;
comment|/* this isn't part of the sequence */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
name|LF
condition|)
name|complain
argument_list|(
literal|"[Premature end of line]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|'?'
condition|)
name|c
operator|=
name|RUBOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|index
argument_list|(
literal|"[\\]^_"
argument_list|,
name|c
argument_list|)
condition|)
name|c
operator|=
name|c
operator|-
literal|'@'
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"[Unknown control character]"
argument_list|)
expr_stmt|;
block|}
block|}
name|Asking
operator|=
literal|0
expr_stmt|;
name|add_mess
argument_list|(
literal|"%p "
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_macro
name|BindWMap
argument_list|(
argument|map
argument_list|,
argument|lastkey
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|data_obj
modifier|*
modifier|*
name|map
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|data_obj
modifier|*
modifier|*
name|nextmap
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|addgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|lastkey
operator|==
name|EOF
condition|)
name|complain
argument_list|(
literal|"[Empty key sequence]"
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[Premature end of key sequence]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nextmap
operator|=
name|IsPrefix
argument_list|(
name|map
index|[
name|c
index|]
argument_list|)
condition|)
name|BindWMap
argument_list|(
name|nextmap
argument_list|,
name|c
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|map
index|[
name|c
index|]
operator|=
name|cmd
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* VARARGS0 */
end_comment

begin_macro
name|BindSomething
argument_list|(
argument|proc
argument_list|)
end_macro

begin_function_decl
name|data_obj
modifier|*
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
call|(
modifier|*
name|proc
call|)
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|s_mess
argument_list|(
literal|": %f %s "
argument_list|,
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
name|BindWMap
argument_list|(
name|mainmap
argument_list|,
name|EOF
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Describe key */
end_comment

begin_macro
name|DescWMap
argument_list|(
argument|map
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|data_obj
modifier|*
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|data_obj
modifier|*
name|cp
init|=
name|map
index|[
name|key
index|]
decl_stmt|,
modifier|*
modifier|*
name|prefp
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|add_mess
argument_list|(
literal|"is unbound."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefp
operator|=
name|IsPrefix
argument_list|(
name|cp
argument_list|)
condition|)
name|DescWMap
argument_list|(
name|prefp
argument_list|,
name|addgetc
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|add_mess
argument_list|(
literal|"is bound to %s."
argument_list|,
name|cp
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|KeyDesc
argument_list|()
end_macro

begin_block
block|{
name|s_mess
argument_list|(
name|ProcFmt
argument_list|)
expr_stmt|;
name|DescWMap
argument_list|(
name|mainmap
argument_list|,
name|addgetc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DescCom
argument_list|()
end_macro

begin_block
block|{
name|data_obj
modifier|*
name|dp
decl_stmt|;
name|char
name|pattern
index|[
literal|100
index|]
decl_stmt|,
name|doc_type
index|[
literal|40
index|]
decl_stmt|,
modifier|*
name|file
init|=
name|CMD_DB
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|LastCmd
operator|->
name|Name
argument_list|,
literal|"describe-variable"
argument_list|)
condition|)
name|dp
operator|=
operator|(
name|data_obj
operator|*
operator|)
name|findvar
argument_list|(
name|ProcFmt
argument_list|)
expr_stmt|;
else|else
name|dp
operator|=
operator|(
name|data_obj
operator|*
operator|)
name|findcom
argument_list|(
name|ProcFmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_READ
argument_list|,
name|COMPLAIN
argument_list|,
name|QUIET
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|pattern
argument_list|,
literal|"^:entry \"%s\" \"\\([^\"]*\\)\""
argument_list|,
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Help"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
name|LBSIZE
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|Typeout
argument_list|(
literal|"There is no documentation for \"%s\"."
argument_list|,
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
goto|goto
name|outahere
goto|;
block|}
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|genbuf
argument_list|,
literal|":entry"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|LookingAt
argument_list|(
name|pattern
argument_list|,
name|genbuf
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
comment|/* found it ... let's print it */
name|putmatch
argument_list|(
literal|1
argument_list|,
name|doc_type
argument_list|,
sizeof|sizeof
name|doc_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"Variable"
argument_list|,
name|doc_type
argument_list|)
operator|==
literal|0
condition|)
name|Typeout
argument_list|(
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"Command"
argument_list|,
name|doc_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|binding
index|[
literal|128
index|]
decl_stmt|;
name|find_binds
argument_list|(
operator|(
expr|struct
name|cmd
operator|*
operator|)
name|dp
argument_list|,
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|blnkp
argument_list|(
name|binding
argument_list|)
condition|)
name|Typeout
argument_list|(
literal|"To invoke %s, type \"ESC X %s<cr>\"."
argument_list|,
name|dp
operator|->
name|Name
argument_list|,
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|"Type \"%s\" to invoke %s."
argument_list|,
name|binding
argument_list|,
name|dp
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
name|Typeout
argument_list|(
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
name|LBSIZE
argument_list|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|genbuf
argument_list|,
literal|":entry"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|outahere
goto|;
else|else
name|Typeout
argument_list|(
literal|"%s"
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
name|outahere
label|:
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|DescBindings
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|Typeout
parameter_list|()
function_decl|;
name|TOstart
argument_list|(
literal|"Key Bindings"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|DescMap
argument_list|(
name|mainmap
argument_list|,
name|NullStr
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|DescMap
argument_list|(
argument|map
argument_list|,
argument|pref
argument_list|)
end_macro

begin_decl_stmt
name|data_obj
modifier|*
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pref
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
init|=
literal|0
decl_stmt|,
name|numbetween
decl_stmt|;
name|char
name|keydescbuf
index|[
literal|40
index|]
decl_stmt|;
name|data_obj
modifier|*
modifier|*
name|prefp
decl_stmt|;
for|for
control|(
name|c1
operator|=
literal|0
init|;
name|c1
operator|<
literal|0200
operator|&&
name|c2
operator|<
literal|0200
condition|;
name|c1
operator|=
name|c2
operator|+
literal|1
control|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|map
index|[
name|c1
index|]
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
operator|++
name|c2
operator|<
literal|0200
operator|&&
name|map
index|[
name|c1
index|]
operator|==
name|map
index|[
name|c2
index|]
condition|)
empty_stmt|;
name|c2
operator|--
expr_stmt|;
name|numbetween
operator|=
name|c2
operator|-
name|c1
expr_stmt|;
if|if
condition|(
name|numbetween
operator|==
literal|1
condition|)
name|sprintf
argument_list|(
name|keydescbuf
argument_list|,
literal|"%s {%p,%p}"
argument_list|,
name|pref
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numbetween
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|keydescbuf
argument_list|,
literal|"%s %p"
argument_list|,
name|pref
argument_list|,
name|c1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|keydescbuf
argument_list|,
literal|"%s [%p-%p]"
argument_list|,
name|pref
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefp
operator|=
name|IsPrefix
argument_list|(
name|map
index|[
name|c1
index|]
argument_list|)
condition|)
name|DescMap
argument_list|(
name|prefp
argument_list|,
name|keydescbuf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|"%-14s%s"
argument_list|,
name|keydescbuf
argument_list|,
name|map
index|[
name|c1
index|]
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|private
name|find_binds
parameter_list|(
name|cp
parameter_list|,
name|buf
parameter_list|)
name|struct
name|cmd
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fb_aux
argument_list|(
name|cp
argument_list|,
name|mainmap
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|endp
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|endp
operator|>
name|buf
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|endp
argument_list|,
literal|", "
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|private
name|fb_aux
parameter_list|(
name|cp
parameter_list|,
name|map
parameter_list|,
name|prefix
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|data_obj
modifier|*
name|cp
decl_stmt|,
decl|*
modifier|*
name|map
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|,
name|prefbuf
index|[
literal|20
index|]
decl_stmt|;
name|data_obj
modifier|*
modifier|*
name|prefp
decl_stmt|;
for|for
control|(
name|c1
operator|=
name|c2
operator|=
literal|0
init|;
name|c1
operator|<
literal|0200
operator|&&
name|c2
operator|<
literal|0200
condition|;
name|c1
operator|=
name|c2
operator|+
literal|1
control|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|map
index|[
name|c1
index|]
operator|==
name|cp
condition|)
block|{
while|while
condition|(
operator|++
name|c2
operator|<
literal|0200
operator|&&
name|map
index|[
name|c1
index|]
operator|==
name|map
index|[
name|c2
index|]
condition|)
empty_stmt|;
name|c2
operator|--
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"%s "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c2
operator|-
name|c1
condition|)
block|{
case|case
literal|0
case|:
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"%p, "
argument_list|,
name|c1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"{%p,%p}, "
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"[%p-%p], "
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|prefp
operator|=
name|IsPrefix
argument_list|(
name|map
index|[
name|c1
index|]
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|prefbuf
argument_list|,
literal|"%p"
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|fb_aux
argument_list|(
name|cp
argument_list|,
name|prefp
argument_list|,
name|prefbuf
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
block|}
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|Apropos
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|cmd
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|variable
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|ans
decl_stmt|;
name|int
name|anyfs
init|=
literal|0
decl_stmt|,
name|anyvs
init|=
literal|0
decl_stmt|,
name|anyms
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|ans
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|": %f (keyword) "
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Help"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|commands
init|;
name|cp
operator|->
name|Name
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|sindex
argument_list|(
name|ans
argument_list|,
name|cp
operator|->
name|Name
argument_list|)
condition|)
block|{
if|if
condition|(
name|anyfs
operator|==
literal|0
condition|)
block|{
name|Typeout
argument_list|(
literal|"Commands"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"--------"
argument_list|)
expr_stmt|;
block|}
name|find_binds
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|Typeout
argument_list|(
literal|": %-30s(%s)"
argument_list|,
name|cp
operator|->
name|Name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|": %s"
argument_list|,
name|cp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|anyfs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|anyfs
condition|)
name|Typeout
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|variables
init|;
name|v
operator|->
name|Name
operator|!=
literal|0
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|sindex
argument_list|(
name|ans
argument_list|,
name|v
operator|->
name|Name
argument_list|)
condition|)
block|{
if|if
condition|(
name|anyvs
operator|==
literal|0
condition|)
block|{
name|Typeout
argument_list|(
literal|"Variables"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"---------"
argument_list|)
expr_stmt|;
block|}
name|anyvs
operator|++
expr_stmt|;
name|vpr_aux
argument_list|(
name|v
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|": set %-26s%s"
argument_list|,
name|v
operator|->
name|Name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|anyvs
condition|)
name|Typeout
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|macros
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextm
control|)
if|if
condition|(
name|sindex
argument_list|(
name|ans
argument_list|,
name|m
operator|->
name|Name
argument_list|)
condition|)
block|{
if|if
condition|(
name|anyms
operator|==
literal|0
condition|)
block|{
name|Typeout
argument_list|(
literal|"Macros"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"------"
argument_list|)
expr_stmt|;
block|}
name|anyms
operator|++
expr_stmt|;
name|find_binds
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|m
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|Typeout
argument_list|(
literal|": %-30s(%s)"
argument_list|,
name|m
operator|->
name|Name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|": %-30s%s"
argument_list|,
literal|"execute-macro"
argument_list|,
name|m
operator|->
name|Name
argument_list|)
expr_stmt|;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|Extend
argument_list|()
end_macro

begin_block
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|d
operator|=
name|findcom
argument_list|(
literal|": "
argument_list|)
condition|)
name|ExecCmd
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read a positive integer from CP.  It must be in base BASE, and    complains if it isn't.  If allints is nonzero, all the characters    in the string must be integers or we return -1; otherwise we stop    reading at the first nondigit. */
end_comment

begin_expr_stmt
name|chr_to_int
argument_list|(
name|cp
argument_list|,
name|base
argument_list|,
name|allints
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|allints
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
name|c
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|base
condition|)
name|complain
argument_list|(
literal|"You must specify in base %d."
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|value
operator|=
name|value
operator|*
name|base
operator|+
name|c
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_block

begin_macro
name|ask_int
argument_list|(
argument|prompt
argument_list|,
argument|base
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|base
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|val
init|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|chr_to_int
argument_list|(
name|val
argument_list|,
name|base
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"That's not a number!"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_function
name|private
name|vpr_aux
parameter_list|(
name|vp
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
condition|)
block|{
case|case
name|V_BASE10
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_BASE8
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%o"
argument_list|,
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_BOOL
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_STRING
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_CHAR
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%p"
argument_list|,
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_macro
name|PrVar
argument_list|()
end_macro

begin_block
block|{
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|char
name|prbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
operator|(
expr|struct
name|variable
operator|*
operator|)
name|findvar
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|vpr_aux
argument_list|(
name|vp
argument_list|,
name|prbuf
argument_list|)
expr_stmt|;
name|s_mess
argument_list|(
literal|": %f %s => %s"
argument_list|,
name|vp
operator|->
name|Name
argument_list|,
name|prbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SetVar
argument_list|()
end_macro

begin_block
block|{
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
operator|(
expr|struct
name|variable
operator|*
operator|)
name|findvar
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|prompt
operator|=
name|sprint
argument_list|(
literal|": %f %s "
argument_list|,
name|vp
operator|->
name|Name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
condition|)
block|{
case|case
name|V_BASE10
case|:
case|case
name|V_BASE8
case|:
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|ask_int
argument_list|(
name|prompt
argument_list|,
operator|(
operator|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
operator|)
operator|==
name|V_BASE10
operator|)
condition|?
literal|10
else|:
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
name|value
expr_stmt|;
break|break;
block|}
case|case
name|V_BOOL
case|:
block|{
name|char
modifier|*
name|def
init|=
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
condition|?
literal|"off"
else|:
literal|"on"
decl_stmt|,
modifier|*
name|on_off
decl_stmt|;
name|int
name|value
decl_stmt|;
name|on_off
operator|=
name|ask
argument_list|(
name|def
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|casecmp
argument_list|(
name|on_off
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|ON
expr_stmt|;
elseif|else
if|if
condition|(
name|casecmp
argument_list|(
name|on_off
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|OFF
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"Boolean variables must be ON or OFF."
argument_list|)
expr_stmt|;
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
name|value
expr_stmt|;
name|s_mess
argument_list|(
literal|"%s%s"
argument_list|,
name|prompt
argument_list|,
name|value
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|V_STRING
case|:
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Do_ask() so if you want you can set string to 		   "" if you so desire. */
name|str
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
name|str
operator|=
name|NullStr
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* ... and hope there is enough room. */
break|break;
block|}
case|case
name|V_CHAR
case|:
name|f_mess
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
operator|*
operator|(
name|vp
operator|->
name|v_value
operator|)
operator|=
name|addgetc
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_MODELINE
condition|)
name|UpdModLine
operator|++
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_CLRSCREEN
condition|)
name|ClAndRedraw
argument_list|()
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TTY_RESET
condition|)
name|tty_reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Command completion - possible is an array of strings, prompt is    the prompt to use, and flags are ... well read jove.h.     If flags are RET_STATE, and the user hits<return> what they typed    so far is in the Minibuf string. */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
modifier|*
name|Possible
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|comp_value
decl_stmt|,
name|comp_flags
decl_stmt|;
end_decl_stmt

begin_macro
name|aux_complete
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|int
name|command
decl_stmt|,
name|length
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|comp_value
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|command
operator|=
name|match
argument_list|(
name|Possible
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|>=
literal|0
condition|)
block|{
name|comp_value
operator|=
name|command
expr_stmt|;
return|return
literal|0
return|;
comment|/* tells ask to stop */
block|}
if|if
condition|(
name|eolp
argument_list|()
operator|&&
name|bolp
argument_list|()
condition|)
block|{
name|comp_value
operator|=
name|NULLSTRING
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|comp_flags
operator|==
name|RET_STATE
condition|)
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|UNIQUE
case|:
case|case
name|ORIGINAL
case|:
case|case
name|NULLSTRING
case|:
name|comp_value
operator|=
name|command
expr_stmt|;
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|InJoverc
condition|)
name|complain
argument_list|(
literal|"[\"%s\" unknown]"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
block|{
name|int
name|minmatch
init|=
literal|1000
decl_stmt|,
name|maxmatch
init|=
literal|0
decl_stmt|,
name|numfound
init|=
literal|0
decl_stmt|,
name|lastmatch
init|=
operator|-
literal|1
decl_stmt|,
name|length
init|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Possible
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_len
decl_stmt|;
name|this_len
operator|=
name|numcomp
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|maxmatch
operator|=
name|max
argument_list|(
name|maxmatch
argument_list|,
name|this_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_len
operator|>=
name|length
condition|)
block|{
if|if
condition|(
name|numfound
condition|)
name|minmatch
operator|=
name|min
argument_list|(
name|minmatch
argument_list|,
name|numcomp
argument_list|(
name|Possible
index|[
name|lastmatch
index|]
argument_list|,
name|Possible
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|minmatch
operator|=
name|strlen
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|numfound
operator|++
expr_stmt|;
name|lastmatch
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
name|Possible
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|numfound
operator|==
literal|0
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
if|if
condition|(
name|InJoverc
condition|)
name|complain
argument_list|(
literal|"[\"%s\" unknown]"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
comment|/* If we're not in the .joverc then 			   let's do something helpful for the 			   user. */
if|if
condition|(
name|maxmatch
operator|<
name|length
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|linebuf
operator|+
name|maxmatch
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\t'
operator|&&
name|numfound
operator|==
literal|1
condition|)
block|{
name|comp_value
operator|=
name|lastmatch
expr_stmt|;
return|return
literal|0
return|;
block|}
name|null_ncpy
argument_list|(
name|linebuf
argument_list|,
name|Possible
index|[
name|lastmatch
index|]
argument_list|,
name|minmatch
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|minmatch
operator|==
name|length
condition|)
comment|/* No difference */
name|rbell
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|'?'
case|:
if|if
condition|(
name|InJoverc
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* kludge: in case we're using UseBuffers, in which case 		   linebuf gets written all over */
name|strcpy
argument_list|(
name|Minibuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|Minibuf
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Completion"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* for now ... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Possible
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|numcomp
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|,
name|Minibuf
argument_list|)
operator|>=
name|length
condition|)
block|{
name|Typeout
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOabort
operator|!=
literal|0
condition|)
break|break;
block|}
name|TOstop
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|!
name|FALSE
return|;
block|}
end_block

begin_expr_stmt
name|complete
argument_list|(
name|possible
argument_list|,
name|prompt
argument_list|,
name|flags
argument_list|)
specifier|register
name|char
operator|*
name|possible
index|[]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Possible
operator|=
name|possible
expr_stmt|;
name|comp_flags
operator|=
name|flags
expr_stmt|;
operator|(
name|void
operator|)
name|do_ask
argument_list|(
literal|"\r\n \t?"
argument_list|,
name|aux_complete
argument_list|,
name|NullStr
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
return|return
name|comp_value
return|;
block|}
end_block

begin_expr_stmt
name|match
argument_list|(
name|choices
argument_list|,
name|what
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|choices
operator|,
operator|*
name|what
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|,
name|save
decl_stmt|,
name|exactmatch
init|=
operator|-
literal|1
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULLSTRING
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|choices
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|what
argument_list|,
name|choices
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
name|choices
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|exactmatch
operator|=
name|i
expr_stmt|;
name|save
operator|=
name|i
expr_stmt|;
name|found
operator|++
expr_stmt|;
comment|/* Found one. */
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|save
operator|=
name|ORIGINAL
expr_stmt|;
elseif|else
if|if
condition|(
name|found
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|exactmatch
operator|!=
operator|-
literal|1
condition|)
name|save
operator|=
name|exactmatch
expr_stmt|;
else|else
name|save
operator|=
name|AMBIGUOUS
expr_stmt|;
block|}
return|return
name|save
return|;
block|}
end_block

begin_macro
name|Source
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|com
decl_stmt|,
name|buf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/.joverc"
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
name|com
operator|=
name|ask_file
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|joverc
argument_list|(
name|buf
argument_list|)
operator|==
name|NIL
condition|)
name|complain
argument_list|(
name|IOerr
argument_list|(
literal|"read"
argument_list|,
name|com
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|BufPos
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Line
modifier|*
name|lp
init|=
name|curbuf
operator|->
name|b_first
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|dotline
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lp
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
if|if
condition|(
name|lp
operator|==
name|curline
condition|)
name|dotline
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|s_mess
argument_list|(
literal|"\"%s\" line %d of %d --%d%%--, column %d of %d."
argument_list|,
name|filename
argument_list|(
name|curbuf
argument_list|)
argument_list|,
name|dotline
argument_list|,
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|dotline
operator|*
literal|100
operator|)
operator|/
name|i
argument_list|)
argument_list|,
literal|1
operator|+
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
argument_list|,
literal|1
operator|+
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|strlen
argument_list|(
name|linebuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|IF_UNBOUND
value|-1
end_define

begin_define
define|#
directive|define
name|IF_TRUE
value|1
end_define

begin_define
define|#
directive|define
name|IF_FALSE
value|!IF_TRUE
end_define

begin_macro
name|do_if
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|complain
argument_list|(
literal|"[Fork failed: if]"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
block|{
name|char
modifier|*
name|args
index|[
literal|12
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|cmd
decl_stmt|,
modifier|*
modifier|*
name|ap
init|=
name|args
decl_stmt|;
operator|*
name|ap
operator|++
operator|=
name|cmd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|cp
expr_stmt|;
block|}
operator|*
name|ap
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*	we want reads to fail */
comment|/* close(1);	 but not writes or ioctl's 		close(2);    */
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|10
argument_list|)
expr_stmt|;
comment|/* signals exec error (see below) */
block|}
block|}
ifdef|#
directive|ifdef
name|IPROCS
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dowait
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
operator|-
literal|10
condition|)
name|complain
argument_list|(
literal|"[Exec failed]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"[Exit %d]"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
literal|0
operator|)
return|;
comment|/* 0 means successful */
block|}
end_block

begin_macro
name|joverc
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|lbuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|lnum
init|=
literal|0
decl_stmt|,
name|eof
init|=
name|FALSE
decl_stmt|;
name|jmp_buf
name|savejmp
decl_stmt|;
name|int
name|IfStatus
init|=
name|IF_UNBOUND
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|F_READ
argument_list|,
operator|!
name|COMPLAIN
argument_list|,
name|QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
return|return
name|NIL
return|;
comment|/* Catch any errors, here, and do the right thing with them, 	   and then restore the error handle to whoever did a setjmp 	   last. */
name|push_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
block|{
name|Buffer
modifier|*
name|savebuf
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
literal|"RC errors"
argument_list|)
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|sprint
argument_list|(
literal|"%s:%d:%s\t%s\n"
argument_list|,
name|pr_name
argument_list|(
name|file
argument_list|)
argument_list|,
name|lnum
argument_list|,
name|lbuf
argument_list|,
name|mesgbuf
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|unmodify
argument_list|()
expr_stmt|;
name|SetBuf
argument_list|(
name|savebuf
argument_list|)
expr_stmt|;
name|Asking
operator|=
literal|0
expr_stmt|;
block|}
name|InJoverc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
do|do
block|{
name|eof
operator|=
operator|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
operator|==
name|EOF
operator|)
expr_stmt|;
name|lnum
operator|++
expr_stmt|;
if|if
condition|(
name|casencmp
argument_list|(
name|lbuf
argument_list|,
literal|"if"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|cmd
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|IfStatus
operator|!=
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Cannot have nested if's]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LookingAt
argument_list|(
literal|"if[ \t]*\\(.*\\)$"
argument_list|,
name|lbuf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[If syntax error]"
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|1
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|IfStatus
operator|=
name|do_if
argument_list|(
name|cmd
argument_list|)
condition|?
name|IF_TRUE
else|:
name|IF_FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|casencmp
argument_list|(
name|lbuf
argument_list|,
literal|"else"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IfStatus
operator|==
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Unexpected `else']"
argument_list|)
expr_stmt|;
name|IfStatus
operator|=
operator|!
name|IfStatus
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|casencmp
argument_list|(
name|lbuf
argument_list|,
literal|"endif"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IfStatus
operator|==
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Unexpected `endif']"
argument_list|)
expr_stmt|;
name|IfStatus
operator|=
name|IF_UNBOUND
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|IfStatus
operator|==
name|IF_FALSE
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lbuf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|Inputp
operator|=
name|lbuf
expr_stmt|;
while|while
condition|(
operator|*
name|Inputp
operator|==
literal|' '
operator|||
operator|*
name|Inputp
operator|==
literal|'\t'
condition|)
name|Inputp
operator|++
expr_stmt|;
comment|/* skip white space */
name|Extend
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|pop_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|Inputp
operator|=
literal|0
expr_stmt|;
name|Asking
operator|=
literal|0
expr_stmt|;
name|InJoverc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IfStatus
operator|!=
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Missing endif]"
argument_list|)
expr_stmt|;
return|return
operator|!
name|NIL
return|;
block|}
end_block

end_unit

