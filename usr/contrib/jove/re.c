begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_comment
comment|/* Search package. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_define
define|#
directive|define
name|NALTS
value|10
end_define

begin_comment
comment|/* number of alternate search strings */
end_comment

begin_decl_stmt
name|char
name|searchstr
index|[
literal|128
index|]
decl_stmt|,
name|compbuf
index|[
literal|128
index|]
decl_stmt|,
comment|/* global default compbuf */
name|rep_search
index|[
literal|128
index|]
decl_stmt|,
comment|/* replace search string */
name|rep_str
index|[
literal|128
index|]
decl_stmt|,
comment|/* contains replacement string */
modifier|*
name|cur_compb
decl_stmt|,
comment|/* usually points at compbuf */
name|REbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
comment|/* points at line we're scanning */
modifier|*
name|alternates
index|[
name|NALTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|REdirection
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CaseIgnore
init|=
literal|0
decl_stmt|,
name|WrapScan
init|=
literal|0
decl_stmt|,
name|UseRE
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cind_cmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(Upper(a) == Upper(b))
end_define

begin_decl_stmt
name|private
name|int
name|REpeekc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|REptr
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|REgetc
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|REpeekc
operator|)
operator|!=
operator|-
literal|1
condition|)
name|REpeekc
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|REptr
condition|)
name|c
operator|=
operator|*
name|REptr
operator|++
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|STAR
value|01
end_define

begin_comment
comment|/* Match any number of last RE. */
end_comment

begin_define
define|#
directive|define
name|AT_BOL
value|2
end_define

begin_comment
comment|/* ^ */
end_comment

begin_define
define|#
directive|define
name|AT_EOL
value|4
end_define

begin_comment
comment|/* $ */
end_comment

begin_define
define|#
directive|define
name|AT_BOW
value|6
end_define

begin_comment
comment|/* \< */
end_comment

begin_define
define|#
directive|define
name|AT_EOW
value|8
end_define

begin_comment
comment|/* \> */
end_comment

begin_define
define|#
directive|define
name|OPENP
value|10
end_define

begin_comment
comment|/* \( */
end_comment

begin_define
define|#
directive|define
name|CLOSEP
value|12
end_define

begin_comment
comment|/* \) */
end_comment

begin_define
define|#
directive|define
name|CURLYB
value|14
end_define

begin_comment
comment|/* \{ */
end_comment

begin_define
define|#
directive|define
name|NOSTR
value|14
end_define

begin_comment
comment|/* Codes<= NOSTR can't be *'d. */
end_comment

begin_define
define|#
directive|define
name|ANYC
value|NOSTR+2
end_define

begin_comment
comment|/* . */
end_comment

begin_define
define|#
directive|define
name|NORMC
value|ANYC+2
end_define

begin_comment
comment|/* normal character */
end_comment

begin_define
define|#
directive|define
name|CINDC
value|NORMC+2
end_define

begin_comment
comment|/* case independent character */
end_comment

begin_define
define|#
directive|define
name|ONE_OF
value|CINDC+2
end_define

begin_comment
comment|/* [xxx] */
end_comment

begin_define
define|#
directive|define
name|NONE_OF
value|ONE_OF+2
end_define

begin_comment
comment|/* [^xxx] */
end_comment

begin_define
define|#
directive|define
name|BACKREF
value|NONE_OF+2
end_define

begin_comment
comment|/* \# */
end_comment

begin_define
define|#
directive|define
name|EOP
value|BACKREF+2
end_define

begin_comment
comment|/* end of pattern */
end_comment

begin_define
define|#
directive|define
name|NPAR
value|9
end_define

begin_comment
comment|/* [1-9] */
end_comment

begin_decl_stmt
name|private
name|int
name|nparens
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|comp_p
decl_stmt|,
modifier|*
modifier|*
name|alt_p
decl_stmt|,
modifier|*
modifier|*
name|alt_endp
decl_stmt|;
end_decl_stmt

begin_macro
name|REcompile
argument_list|(
argument|pattern
argument_list|,
argument|re
argument_list|,
argument|into_buf
argument_list|,
argument|alt_bufp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|into_buf
decl_stmt|,
modifier|*
modifier|*
name|alt_bufp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REptr
operator|=
name|pattern
expr_stmt|;
name|REpeekc
operator|=
operator|-
literal|1
expr_stmt|;
name|comp_p
operator|=
name|cur_compb
operator|=
name|into_buf
expr_stmt|;
name|alt_p
operator|=
name|alt_bufp
expr_stmt|;
name|alt_endp
operator|=
name|alt_p
operator|+
name|NALTS
expr_stmt|;
operator|*
name|alt_p
operator|++
operator|=
name|comp_p
expr_stmt|;
name|nparens
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|do_comp
argument_list|(
name|re
condition|?
name|OKAY_RE
else|:
name|NORM
argument_list|)
expr_stmt|;
operator|*
name|alt_p
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compile the pattern into an internal code. */
end_comment

begin_function
name|private
name|do_comp
parameter_list|(
name|kind
parameter_list|)
block|{
name|char
modifier|*
name|last_p
decl_stmt|;
name|int
name|parens
index|[
name|NPAR
index|]
decl_stmt|,
modifier|*
name|parenp
decl_stmt|,
name|c
decl_stmt|,
name|ret_code
decl_stmt|;
name|parenp
operator|=
name|parens
expr_stmt|;
name|last_p
operator|=
literal|0
expr_stmt|;
name|ret_code
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|REgetc
argument_list|()
condition|)
block|{
if|if
condition|(
name|comp_p
operator|>
operator|&
name|cur_compb
index|[
operator|(
sizeof|sizeof
name|compbuf
operator|)
operator|-
literal|4
index|]
condition|)
name|complain
argument_list|(
literal|"Search string too long."
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|last_p
operator|=
name|comp_p
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|NORM
operator|&&
name|index
argument_list|(
literal|".[*"
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|defchar
goto|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
name|REgetc
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|complain
argument_list|(
literal|"Premature end of pattern."
argument_list|)
expr_stmt|;
case|case
literal|'{'
case|:
block|{
name|char
modifier|*
name|wcntp
decl_stmt|;
comment|/* Word count. */
operator|*
name|comp_p
operator|++
operator|=
name|CURLYB
expr_stmt|;
name|wcntp
operator|=
name|comp_p
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|comp_val
decl_stmt|;
name|char
modifier|*
name|comp_len
decl_stmt|;
name|comp_len
operator|=
name|comp_p
operator|++
expr_stmt|;
name|comp_val
operator|=
name|do_comp
argument_list|(
name|IN_CB
argument_list|)
expr_stmt|;
operator|*
name|comp_len
operator|=
name|comp_p
operator|-
name|comp_len
expr_stmt|;
operator|(
operator|*
name|wcntp
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|comp_val
operator|==
literal|0
condition|)
break|break;
block|}
continue|continue;
block|}
case|case
literal|'}'
case|:
if|if
condition|(
name|kind
operator|!=
name|IN_CB
condition|)
name|complain
argument_list|(
literal|"Unexpected \}."
argument_list|)
expr_stmt|;
name|ret_code
operator|=
literal|0
expr_stmt|;
goto|goto
name|outahere
goto|;
case|case
literal|'('
case|:
if|if
condition|(
name|nparens
operator|>=
name|NPAR
condition|)
name|complain
argument_list|(
literal|"Too many ('s; max is %d."
argument_list|,
name|NPAR
argument_list|)
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|OPENP
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|nparens
expr_stmt|;
operator|*
name|parenp
operator|++
operator|=
name|nparens
operator|++
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
if|if
condition|(
name|parenp
operator|==
name|parens
condition|)
name|complain
argument_list|(
literal|"Too many )'s."
argument_list|)
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|CLOSEP
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
operator|*
operator|--
name|parenp
expr_stmt|;
continue|continue;
case|case
literal|'|'
case|:
if|if
condition|(
name|alt_p
operator|>=
name|alt_endp
condition|)
name|complain
argument_list|(
literal|"Too many alternates; max %d."
argument_list|,
name|NALTS
argument_list|)
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|EOP
expr_stmt|;
operator|*
name|alt_p
operator|++
operator|=
name|comp_p
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|*
name|comp_p
operator|++
operator|=
name|BACKREF
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|c
operator|-
literal|'1'
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
operator|*
name|comp_p
operator|++
operator|=
name|AT_BOW
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
operator|*
name|comp_p
operator|++
operator|=
name|AT_EOW
expr_stmt|;
continue|continue;
default|default:
goto|goto
name|defchar
goto|;
block|}
case|case
literal|','
case|:
if|if
condition|(
name|kind
operator|!=
name|IN_CB
condition|)
goto|goto
name|defchar
goto|;
goto|goto
name|outahere
goto|;
case|case
literal|'.'
case|:
operator|*
name|comp_p
operator|++
operator|=
name|ANYC
expr_stmt|;
continue|continue;
case|case
literal|'^'
case|:
if|if
condition|(
name|comp_p
operator|==
name|cur_compb
operator|||
name|comp_p
index|[
operator|-
literal|1
index|]
operator|==
name|EOP
condition|)
block|{
operator|*
name|comp_p
operator|++
operator|=
name|AT_BOL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|defchar
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|(
name|REpeekc
operator|=
name|REgetc
argument_list|()
operator|)
operator|!=
literal|0
operator|&&
name|REpeekc
operator|!=
literal|'\\'
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|comp_p
operator|++
operator|=
name|AT_EOL
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
block|{
name|int
name|chrcnt
decl_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|ONE_OF
expr_stmt|;
name|bzero
argument_list|(
name|comp_p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|REpeekc
operator|=
name|REgetc
argument_list|()
operator|)
operator|==
literal|'^'
condition|)
block|{
operator|*
name|last_p
operator|=
name|NONE_OF
expr_stmt|;
comment|/* Get it for real this time. */
operator|(
name|void
operator|)
name|REgetc
argument_list|()
expr_stmt|;
block|}
name|chrcnt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|REgetc
argument_list|()
operator|)
operator|!=
literal|']'
operator|&&
name|c
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|REgetc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|REpeekc
operator|=
name|REgetc
argument_list|()
operator|)
operator|==
literal|'-'
condition|)
block|{
name|int
name|c2
decl_stmt|;
operator|(
name|void
operator|)
name|REgetc
argument_list|()
expr_stmt|;
comment|/* read '-' */
name|c2
operator|=
name|REgetc
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|c2
condition|)
block|{
name|comp_p
index|[
name|c
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
name|comp_p
index|[
name|c
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|chrcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"Missing ]."
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrcnt
operator|==
literal|1
condition|)
name|complain
argument_list|(
literal|"Empty []."
argument_list|)
expr_stmt|;
name|comp_p
operator|+=
literal|16
expr_stmt|;
continue|continue;
block|}
case|case
literal|'*'
case|:
if|if
condition|(
name|last_p
operator|==
literal|0
operator|||
operator|*
name|last_p
operator|<=
name|NOSTR
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|last_p
operator||=
name|STAR
expr_stmt|;
continue|continue;
default|default:
name|defchar
label|:
operator|*
name|comp_p
operator|++
operator|=
operator|(
name|CaseIgnore
operator|)
condition|?
name|CINDC
else|:
name|NORMC
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
name|outahere
label|:
comment|/* End of pattern, let's do some error checking. */
if|if
condition|(
name|parenp
operator|!=
name|parens
condition|)
name|complain
argument_list|(
literal|"Unmatched ()'s."
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|IN_CB
operator|&&
name|c
operator|==
literal|0
condition|)
comment|/* End of pattern with \}. */
name|complain
argument_list|(
literal|"Missing \}."
argument_list|)
expr_stmt|;
operator|*
name|comp_p
operator|++
operator|=
name|EOP
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_decl_stmt
name|private
name|char
modifier|*
name|pstrtlst
index|[
name|NPAR
index|]
decl_stmt|,
comment|/* index into REbuf */
modifier|*
name|pendlst
index|[
name|NPAR
index|]
decl_stmt|,
modifier|*
name|REbolp
decl_stmt|,
modifier|*
name|locs
decl_stmt|,
modifier|*
name|loc1
decl_stmt|,
modifier|*
name|loc2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|REbom
decl_stmt|,
name|REeom
decl_stmt|,
comment|/* beginning and end of match */
name|REalt_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if alternatives, which one matched? */
end_comment

begin_function
name|private
name|backref
parameter_list|(
name|n
parameter_list|,
name|linep
parameter_list|)
specifier|register
name|char
modifier|*
name|linep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|backsp
decl_stmt|,
modifier|*
name|backep
decl_stmt|;
name|backsp
operator|=
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
name|backep
operator|=
name|pendlst
index|[
name|n
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|backsp
operator|++
operator|==
operator|*
name|linep
operator|++
condition|)
if|if
condition|(
name|backsp
operator|>=
name|backep
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|member
parameter_list|(
name|comp_p
parameter_list|,
name|c
parameter_list|,
name|af
parameter_list|)
specifier|register
name|char
modifier|*
name|comp_p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* try to match EOL always fails */
if|if
condition|(
name|comp_p
index|[
name|c
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
literal|8
operator|)
operator|)
condition|)
return|return
name|af
return|;
return|return
operator|!
name|af
return|;
block|}
end_function

begin_function
name|private
name|REmatch
parameter_list|(
name|linep
parameter_list|,
name|comp_p
parameter_list|)
specifier|register
name|char
modifier|*
name|linep
decl_stmt|,
decl|*
name|comp_p
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|first_p
init|=
name|linep
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|comp_p
operator|++
condition|)
block|{
case|case
name|NORMC
case|:
if|if
condition|(
operator|*
name|linep
operator|++
operator|==
operator|*
name|comp_p
operator|++
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|CINDC
case|:
comment|/* case independent comparison */
if|if
condition|(
name|cind_cmp
argument_list|(
operator|*
name|linep
operator|++
argument_list|,
operator|*
name|comp_p
operator|++
argument_list|)
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|EOP
case|:
name|loc2
operator|=
name|linep
expr_stmt|;
name|REeom
operator|=
operator|(
name|loc2
operator|-
name|REbolp
operator|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* Success! */
case|case
name|AT_BOL
case|:
if|if
condition|(
name|linep
operator|==
name|REbolp
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|AT_EOL
case|:
if|if
condition|(
operator|*
name|linep
operator|==
literal|0
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|ANYC
case|:
if|if
condition|(
operator|*
name|linep
operator|++
operator|!=
literal|0
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|AT_BOW
case|:
if|if
condition|(
name|ismword
argument_list|(
operator|*
name|linep
argument_list|)
operator|&&
operator|(
name|linep
operator|==
name|REbolp
operator|||
operator|!
name|ismword
argument_list|(
name|linep
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|AT_EOW
case|:
if|if
condition|(
operator|(
operator|*
name|linep
operator|==
literal|0
operator|||
operator|!
name|ismword
argument_list|(
operator|*
name|linep
argument_list|)
operator|)
operator|&&
operator|(
name|linep
operator|!=
name|REbolp
operator|&&
name|ismword
argument_list|(
name|linep
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
continue|continue;
return|return
literal|0
return|;
case|case
name|ONE_OF
case|:
case|case
name|NONE_OF
case|:
if|if
condition|(
name|member
argument_list|(
name|comp_p
argument_list|,
operator|*
name|linep
operator|++
argument_list|,
name|comp_p
index|[
operator|-
literal|1
index|]
operator|==
name|ONE_OF
argument_list|)
condition|)
block|{
name|comp_p
operator|+=
literal|16
expr_stmt|;
continue|continue;
block|}
return|return
literal|0
return|;
case|case
name|OPENP
case|:
name|pstrtlst
index|[
operator|*
name|comp_p
operator|++
index|]
operator|=
name|linep
expr_stmt|;
continue|continue;
case|case
name|CLOSEP
case|:
name|pendlst
index|[
operator|*
name|comp_p
operator|++
index|]
operator|=
name|linep
expr_stmt|;
continue|continue;
case|case
name|BACKREF
case|:
if|if
condition|(
name|pstrtlst
index|[
name|n
operator|=
operator|*
name|comp_p
operator|++
index|]
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"\\%d was not specified."
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|backref
argument_list|(
name|n
argument_list|,
name|linep
argument_list|)
condition|)
block|{
name|linep
operator|+=
name|pendlst
index|[
name|n
index|]
operator|-
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
continue|continue;
block|}
return|return
literal|0
return|;
case|case
name|CURLYB
case|:
block|{
name|int
name|wcnt
decl_stmt|,
name|any
decl_stmt|;
name|wcnt
operator|=
operator|*
name|comp_p
operator|++
expr_stmt|;
name|any
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|wcnt
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|any
operator|==
literal|0
condition|)
name|any
operator|=
name|REmatch
argument_list|(
name|linep
argument_list|,
name|comp_p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|comp_p
operator|+=
operator|*
name|comp_p
expr_stmt|;
block|}
if|if
condition|(
name|any
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|linep
operator|=
name|loc2
expr_stmt|;
continue|continue;
block|}
case|case
name|ANYC
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
operator|*
name|linep
operator|++
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|NORMC
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
operator|*
name|comp_p
operator|==
operator|*
name|linep
operator|++
condition|)
empty_stmt|;
name|comp_p
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CINDC
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
name|cind_cmp
argument_list|(
operator|*
name|comp_p
argument_list|,
operator|*
name|linep
operator|++
argument_list|)
condition|)
empty_stmt|;
name|comp_p
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|ONE_OF
operator||
name|STAR
case|:
case|case
name|NONE_OF
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
name|member
argument_list|(
name|comp_p
argument_list|,
operator|*
name|linep
operator|++
argument_list|,
name|comp_p
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|ONE_OF
operator||
name|STAR
operator|)
argument_list|)
condition|)
empty_stmt|;
name|comp_p
operator|+=
literal|16
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|BACKREF
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
name|n
operator|=
operator|*
name|comp_p
operator|++
expr_stmt|;
while|while
condition|(
name|backref
argument_list|(
name|n
argument_list|,
name|linep
argument_list|)
condition|)
name|linep
operator|+=
name|pendlst
index|[
name|n
index|]
operator|-
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
while|while
condition|(
name|linep
operator|>=
name|first_p
condition|)
block|{
if|if
condition|(
name|REmatch
argument_list|(
name|linep
argument_list|,
name|comp_p
argument_list|)
condition|)
return|return
literal|1
return|;
name|linep
operator|-=
name|pendlst
index|[
name|n
index|]
operator|-
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
block|}
continue|continue;
name|star
label|:
do|do
block|{
name|linep
operator|--
expr_stmt|;
if|if
condition|(
name|linep
operator|<
name|locs
condition|)
break|break;
if|if
condition|(
name|REmatch
argument_list|(
name|linep
argument_list|,
name|comp_p
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
name|linep
operator|>
name|first_p
condition|)
do|;
return|return
literal|0
return|;
default|default:
name|complain
argument_list|(
literal|"RE error match (%d)."
argument_list|,
name|comp_p
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED. */
block|}
end_block

begin_function
name|private
name|REreset
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPAR
condition|;
name|i
operator|++
control|)
name|pstrtlst
index|[
name|i
index|]
operator|=
name|pendlst
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Index LINE at OFFSET, the compiled EXPR, with alternates ALTS.  If    lbuf_okay is nonzero it's okay to use linebuf if LINE is the current    line.  This should save lots of time in things like paren matching in    LISP mode.  Saves all that copying from linebuf to REbuf.  substitute()    is the guy who calls re_lindex with lbuf_okay as 0, since the substitution    gets placed in linebuf ... doesn't work too well when the source and    destination strings are the same.  I hate all these arguments! */
end_comment

begin_macro
name|re_lindex
argument_list|(
argument|line
argument_list|,
argument|offset
argument_list|,
argument|expr
argument_list|,
argument|alts
argument_list|,
argument|lbuf_okay
argument_list|)
end_macro

begin_decl_stmt
name|Line
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|expr
decl_stmt|,
modifier|*
modifier|*
name|alts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|isquick
decl_stmt|;
specifier|register
name|int
name|firstc
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|resp
decl_stmt|;
name|REreset
argument_list|()
expr_stmt|;
if|if
condition|(
name|lbuf_okay
condition|)
block|{
name|REbolp
operator|=
name|lbptr
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
name|offset
operator|=
name|strlen
argument_list|(
name|REbolp
argument_list|)
expr_stmt|;
comment|/* arg! */
block|}
else|else
block|{
name|REbolp
operator|=
name|ltobuf
argument_list|(
name|line
argument_list|,
name|REbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Reverse search, find end of line. */
specifier|extern
name|int
name|Jr_Len
decl_stmt|;
name|offset
operator|=
name|Jr_Len
expr_stmt|;
comment|/* Just Read Len. */
block|}
block|}
name|resp
operator|=
name|REbolp
expr_stmt|;
name|isquick
operator|=
operator|(
name|expr
index|[
literal|0
index|]
operator|==
name|NORMC
operator|&&
name|alternates
index|[
literal|1
index|]
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|isquick
condition|)
name|firstc
operator|=
name|expr
index|[
literal|1
index|]
expr_stmt|;
name|locs
operator|=
name|REbolp
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|REdirection
operator|==
name|FORWARD
condition|)
block|{
do|do
block|{
name|char
modifier|*
modifier|*
name|altp
init|=
name|alts
decl_stmt|;
if|if
condition|(
name|isquick
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|locs
operator|++
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|firstc
condition|)
empty_stmt|;
if|if
condition|(
operator|*
operator|--
name|locs
operator|==
literal|0
condition|)
break|break;
block|}
name|REalt_num
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|altp
condition|)
block|{
if|if
condition|(
name|REmatch
argument_list|(
name|locs
argument_list|,
operator|*
name|altp
operator|++
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|locs
expr_stmt|;
name|REbom
operator|=
name|loc1
operator|-
name|REbolp
expr_stmt|;
return|return
literal|1
return|;
block|}
name|REalt_num
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|locs
operator|++
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|char
modifier|*
modifier|*
name|altp
init|=
name|alts
decl_stmt|;
if|if
condition|(
name|isquick
condition|)
block|{
while|while
condition|(
name|locs
operator|>=
name|REbolp
operator|&&
operator|*
name|locs
operator|--
operator|!=
name|firstc
condition|)
empty_stmt|;
if|if
condition|(
operator|*
operator|++
name|locs
operator|!=
name|firstc
condition|)
break|break;
block|}
name|REalt_num
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|altp
condition|)
block|{
if|if
condition|(
name|REmatch
argument_list|(
name|locs
argument_list|,
operator|*
name|altp
operator|++
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|locs
expr_stmt|;
name|REbom
operator|=
name|loc1
operator|-
name|REbolp
expr_stmt|;
return|return
literal|1
return|;
block|}
name|REalt_num
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|locs
operator|>=
name|resp
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
name|int
name|okay_wrap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a wrap search ... not when we're 			   parsing errors ... */
end_comment

begin_function
name|Bufpos
modifier|*
name|dosearch
parameter_list|(
name|pattern
parameter_list|,
name|dir
parameter_list|,
name|re
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|Bufpos
modifier|*
name|pos
decl_stmt|;
if|if
condition|(
name|bobp
argument_list|()
operator|&&
name|eobp
argument_list|()
condition|)
comment|/* Can't match!  There's no buffer. */
return|return
literal|0
return|;
name|REcompile
argument_list|(
name|pattern
argument_list|,
name|re
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|)
expr_stmt|;
name|okay_wrap
operator|++
expr_stmt|;
name|pos
operator|=
name|docompiled
argument_list|(
name|dir
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|)
expr_stmt|;
name|okay_wrap
operator|=
literal|0
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
name|Bufpos
modifier|*
name|docompiled
parameter_list|(
name|dir
parameter_list|,
name|expr
parameter_list|,
name|alts
parameter_list|)
name|char
modifier|*
name|expr
decl_stmt|,
decl|*
modifier|*
name|alts
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|Bufpos
name|ret
decl_stmt|;
name|Bufpos
name|push_dot
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
name|int
name|we_wrapped
init|=
literal|0
decl_stmt|;
name|lsave
argument_list|()
expr_stmt|;
comment|/* Search now lsave()'s so it doesn't make any assumptions on 	   whether the the contents of curline/curchar are in linebuf. 	   Nowhere does search write all over linebuf.  However, we have to 	   be careful about what calls we make here, because many of them 	   assume (and rightly so) that curline is in linebuf. */
name|REdirection
operator|=
name|dir
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|push_dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|BACKWARD
condition|)
block|{
if|if
condition|(
name|bobp
argument_list|()
condition|)
block|{
if|if
condition|(
name|okay_wrap
operator|&&
name|WrapScan
condition|)
block|{
name|lp
operator|=
name|curline
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
return|return
literal|0
return|;
block|}
comment|/* here we simulate BackChar() */
if|if
condition|(
name|bolp
argument_list|()
condition|)
block|{
name|curline
operator|=
name|curline
operator|->
name|l_prev
expr_stmt|;
name|curchar
operator|=
name|strlen
argument_list|(
name|lbptr
argument_list|(
name|curline
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|--
name|curchar
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|==
name|FORWARD
operator|&&
operator|(
name|lbptr
argument_list|(
name|curline
argument_list|)
index|[
name|curchar
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|!
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|curline
operator|=
name|curline
operator|->
name|l_next
expr_stmt|;
name|curchar
operator|=
literal|0
expr_stmt|;
block|}
name|lp
operator|=
name|curline
expr_stmt|;
name|offset
operator|=
name|curchar
expr_stmt|;
do|do
block|{
if|if
condition|(
name|re_lindex
argument_list|(
name|lp
argument_list|,
name|offset
argument_list|,
name|expr
argument_list|,
name|alts
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|doit
label|:
name|lp
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|lp
operator|->
name|l_next
else|:
name|lp
operator|->
name|l_prev
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|okay_wrap
operator|&&
name|WrapScan
condition|)
block|{
name|lp
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|curbuf
operator|->
name|b_first
else|:
name|curbuf
operator|->
name|b_last
expr_stmt|;
name|we_wrapped
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Signals re_lindex ... */
block|}
do|while
condition|(
name|lp
operator|!=
name|push_dot
operator|.
name|p_line
condition|)
do|;
if|if
condition|(
name|lp
operator|==
name|push_dot
operator|.
name|p_line
operator|&&
name|we_wrapped
condition|)
name|lp
operator|=
literal|0
expr_stmt|;
name|curline
operator|=
name|push_dot
operator|.
name|p_line
expr_stmt|;
name|curchar
operator|=
name|push_dot
operator|.
name|p_char
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|.
name|p_line
operator|=
name|lp
expr_stmt|;
name|ret
operator|.
name|p_char
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|REeom
else|:
name|REbom
expr_stmt|;
return|return
operator|&
name|ret
return|;
block|}
end_block

begin_function
name|private
name|char
modifier|*
name|insert
parameter_list|(
name|off
parameter_list|,
name|endp
parameter_list|,
name|which
parameter_list|)
name|char
modifier|*
name|off
decl_stmt|,
decl|*
name|endp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|pendlst
index|[
name|which
index|]
operator|-
name|pstrtlst
index|[
name|which
index|]
expr_stmt|;
name|pp
operator|=
name|pstrtlst
index|[
name|which
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
name|off
operator|++
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|off
return|;
block|}
end_block

begin_comment
comment|/* Perform the substitution.  If DELP is nonzero the matched string is    deleted, i.e., the substitution string is not inserted. */
end_comment

begin_macro
name|re_dosub
argument_list|(
argument|tobuf
argument_list|,
argument|delp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tobuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|rp
decl_stmt|,
modifier|*
name|repp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|tp
operator|=
name|tobuf
expr_stmt|;
name|endp
operator|=
name|tp
operator|+
name|LBSIZE
expr_stmt|;
name|rp
operator|=
name|REbuf
expr_stmt|;
name|repp
operator|=
name|rep_str
expr_stmt|;
while|while
condition|(
name|rp
operator|<
name|loc1
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|delp
condition|)
while|while
condition|(
name|c
operator|=
operator|*
name|repp
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|c
operator|=
operator|*
name|repp
operator|++
operator|)
operator|>=
literal|'1'
operator|&&
name|c
operator|<=
name|nparens
operator|+
literal|'1'
condition|)
block|{
name|tp
operator|=
name|insert
argument_list|(
name|tp
argument_list|,
name|endp
argument_list|,
name|c
operator|-
literal|'1'
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tp
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
name|rp
operator|=
name|loc2
expr_stmt|;
name|loc2
operator|=
name|REbuf
operator|+
name|max
argument_list|(
literal|1
argument_list|,
name|tp
operator|-
name|tobuf
argument_list|)
expr_stmt|;
name|REeom
operator|=
name|loc2
operator|-
name|REbuf
expr_stmt|;
comment|/* At least one character past the match, to prevent an infinite 	   number of replacements in the same position, e.g., 	   replace "^" with "". */
while|while
condition|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|rp
operator|++
condition|)
if|if
condition|(
name|tp
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putmatch
argument_list|(
argument|which
argument_list|,
argument|buf
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
operator|(
name|insert
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|size
argument_list|,
name|which
operator|-
literal|1
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|setsearch
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strcpy
argument_list|(
name|searchstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|getsearch
parameter_list|()
block|{
return|return
name|searchstr
return|;
block|}
end_function

begin_macro
name|RErecur
argument_list|()
end_macro

begin_block
block|{
name|char
name|sbuf
index|[
sizeof|sizeof
name|searchstr
index|]
decl_stmt|,
name|cbuf
index|[
sizeof|sizeof
name|compbuf
index|]
decl_stmt|,
name|repbuf
index|[
sizeof|sizeof
name|rep_str
index|]
decl_stmt|,
modifier|*
name|altbuf
index|[
name|NALTS
index|]
decl_stmt|;
name|int
name|npars
decl_stmt|;
name|Mark
modifier|*
name|m
init|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|REbom
argument_list|,
name|FLOATER
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"Type C-X C-C to continue with query replace."
argument_list|)
expr_stmt|;
name|npars
operator|=
name|nparens
expr_stmt|;
name|byte_copy
argument_list|(
name|compbuf
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
name|compbuf
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
name|searchstr
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
name|searchstr
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
name|rep_str
argument_list|,
name|repbuf
argument_list|,
sizeof|sizeof
name|rep_str
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|alternates
argument_list|,
operator|(
name|char
operator|*
operator|)
name|altbuf
argument_list|,
sizeof|sizeof
name|alternates
argument_list|)
expr_stmt|;
name|Recur
argument_list|()
expr_stmt|;
name|nparens
operator|=
name|npars
expr_stmt|;
name|byte_copy
argument_list|(
name|cbuf
argument_list|,
name|compbuf
argument_list|,
sizeof|sizeof
name|compbuf
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
name|sbuf
argument_list|,
name|searchstr
argument_list|,
sizeof|sizeof
name|searchstr
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
name|repbuf
argument_list|,
name|rep_str
argument_list|,
sizeof|sizeof
name|rep_str
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|altbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|alternates
argument_list|,
sizeof|sizeof
name|alternates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp_p
condition|)
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ForSearch
argument_list|()
end_macro

begin_block
block|{
name|search
argument_list|(
name|FORWARD
argument_list|,
name|UseRE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|RevSearch
argument_list|()
end_macro

begin_block
block|{
name|search
argument_list|(
name|BACKWARD
argument_list|,
name|UseRE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|search
parameter_list|(
name|dir
parameter_list|,
name|re
parameter_list|)
block|{
name|Bufpos
modifier|*
name|newdot
decl_stmt|;
name|setsearch
argument_list|(
name|ask
argument_list|(
name|searchstr
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newdot
operator|=
name|dosearch
argument_list|(
name|searchstr
argument_list|,
name|dir
argument_list|,
name|re
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|WrapScan
condition|)
name|complain
argument_list|(
literal|"No \"%s\" in buffer."
argument_list|,
name|searchstr
argument_list|)
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"No \"%s\" found to %s."
argument_list|,
name|searchstr
argument_list|,
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
literal|"bottom"
else|:
literal|"top"
argument_list|)
expr_stmt|;
block|}
name|PushPntp
argument_list|(
name|newdot
operator|->
name|p_line
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|newdot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do we match PATTERN at OFFSET in BUF? */
end_comment

begin_macro
name|LookingAt
argument_list|(
argument|pattern
argument_list|,
argument|buf
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|alt
init|=
name|alternates
decl_stmt|;
name|REcompile
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|)
expr_stmt|;
name|REreset
argument_list|()
expr_stmt|;
name|locs
operator|=
name|buf
operator|+
name|offset
expr_stmt|;
name|REbolp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|alt
condition|)
if|if
condition|(
name|REmatch
argument_list|(
name|locs
argument_list|,
operator|*
name|alt
operator|++
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|look_at
argument_list|(
argument|expr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|expr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REcompile
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|)
expr_stmt|;
name|REreset
argument_list|()
expr_stmt|;
name|locs
operator|=
name|linebuf
operator|+
name|curchar
expr_stmt|;
name|REbolp
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|REmatch
argument_list|(
name|locs
argument_list|,
name|alternates
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

end_unit

