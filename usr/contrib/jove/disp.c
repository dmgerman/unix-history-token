begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* Kludge windows gets called by the routines that delete lines from the    buffer.  If the w->w_line or w->w_top are deleted and this procedure    is not called, the redisplay routine will barf. */
end_comment

begin_macro
name|ChkWindows
argument_list|(
argument|line1
argument_list|,
argument|line2
argument_list|)
end_macro

begin_decl_stmt
name|Line
modifier|*
name|line1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Line
modifier|*
name|line2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
do|do
block|{
for|for
control|(
name|lp
operator|=
name|line1
operator|->
name|l_next
init|;
name|lp
operator|!=
name|line2
operator|->
name|l_next
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_top
condition|)
name|w
operator|->
name|w_flags
operator||=
name|TOPGONE
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_line
condition|)
name|w
operator|->
name|w_flags
operator||=
name|CURGONE
expr_stmt|;
block|}
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|RingBell
decl_stmt|;
end_decl_stmt

begin_macro
name|redisplay
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
name|int
name|lineno
decl_stmt|,
name|done_ID
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
decl_stmt|,
modifier|*
name|phys_p
decl_stmt|;
name|curwind
operator|->
name|w_line
operator|=
name|curwind
operator|->
name|w_bufp
operator|->
name|b_dot
expr_stmt|;
name|curwind
operator|->
name|w_char
operator|=
name|curwind
operator|->
name|w_bufp
operator|->
name|b_char
expr_stmt|;
if|if
condition|(
name|InputPending
operator|=
name|charp
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|JOB_CONTROL
if|if
condition|(
name|UpdFreq
condition|)
name|sighold
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|RingBell
condition|)
block|{
name|dobell
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|RingBell
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|UpdMesg
condition|)
name|DrawMesg
argument_list|(
name|YES
argument_list|)
expr_stmt|;
for|for
control|(
name|lineno
operator|=
literal|0
operator|,
name|w
operator|=
name|fwind
init|;
name|lineno
operator|<
name|ILI
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
block|{
name|UpdWindow
argument_list|(
name|w
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|lineno
operator|+=
name|w
operator|->
name|w_height
expr_stmt|;
block|}
name|des_p
operator|=
name|DesiredScreen
expr_stmt|;
name|phys_p
operator|=
name|PhysScreen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ILI
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|done_ID
operator|&&
operator|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
condition|)
block|{
name|DoIDline
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|done_ID
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|des_p
operator|->
name|s_flags
operator|&
operator|(
name|DIRTY
operator||
name|L_MOD
operator|)
operator|)
operator|||
operator|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
operator|||
operator|(
name|des_p
operator|->
name|s_vln
operator|!=
name|phys_p
operator|->
name|s_vln
operator|)
operator|||
operator|(
name|des_p
operator|->
name|s_offset
operator|!=
name|phys_p
operator|->
name|s_offset
operator|)
condition|)
name|UpdLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|InputPending
condition|)
goto|goto
name|ret
goto|;
block|}
name|UpdModLine
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Asking
condition|)
block|{
name|Placur
argument_list|(
name|LI
operator|-
literal|1
argument_list|,
name|min
argument_list|(
name|CO
operator|-
literal|2
argument_list|,
name|calc_pos
argument_list|(
name|mesgbuf
argument_list|,
name|Asking
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Nice kludge */
name|flusho
argument_list|()
expr_stmt|;
block|}
else|else
name|GotoDot
argument_list|()
expr_stmt|;
name|ret
label|:
ifdef|#
directive|ifdef
name|JOB_CONTROL
if|if
condition|(
name|UpdFreq
condition|)
name|sigrelse
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
else|#
directive|else
empty_stmt|;
comment|/* yuck */
endif|#
directive|endif
block|}
end_block

begin_macro
name|dobell
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|VisBell
operator|&&
name|VB
condition|)
name|putstr
argument_list|(
name|VB
argument_list|)
expr_stmt|;
else|else
name|putpad
argument_list|(
literal|"20\007"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|flusho
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* find_pos() returns the position on the line, that c_char represents    in line. */
end_comment

begin_macro
name|find_pos
argument_list|(
argument|line
argument_list|,
argument|c_char
argument_list|)
end_macro

begin_decl_stmt
name|Line
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|calc_pos
argument_list|(
name|lcontents
argument_list|(
name|line
argument_list|)
argument_list|,
name|c_char
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|calc_pos
argument_list|(
name|lp
argument_list|,
name|c_char
argument_list|)
specifier|register
name|char
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|c_char
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|pos
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
operator|--
name|c_char
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|&
literal|0177
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|pos
operator|+=
operator|(
name|tabstop
operator|-
operator|(
name|pos
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|pos
operator|+=
literal|2
expr_stmt|;
else|else
name|pos
operator|++
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
end_block

begin_decl_stmt
name|int
name|UpdModLine
init|=
literal|0
decl_stmt|,
name|UpdMesg
init|=
literal|0
decl_stmt|,
name|CanScroll
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|DoIDline
argument_list|(
argument|start
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
init|=
operator|&
name|DesiredScreen
index|[
name|start
index|]
decl_stmt|;
name|struct
name|scrimage
modifier|*
name|phys_p
init|=
operator|&
name|PhysScreen
index|[
name|start
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Some changes have been made.  Try for insert or delete lines. 	   If either case has happened, Addlines and/or DelLines will do 	   necessary scrolling, also CONVERTING PhysScreen to account for the 	   physical changes.  The comparison continues from where the 	   insertion/deletion takes place; this doesn't happen very often, 	   usually it happens with more than one window with the same 	   buffer. */
if|if
condition|(
operator|!
name|CanScroll
condition|)
return|return;
comment|/* We should never have been called! */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|ILI
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
control|)
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
condition|)
break|break;
for|for
control|(
init|;
name|i
operator|<
name|ILI
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ILI
condition|;
name|j
operator|++
control|)
block|{
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|j
index|]
expr_stmt|;
name|phys_p
operator|=
operator|&
name|PhysScreen
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|!=
literal|0
operator|&&
name|des_p
operator|->
name|s_id
operator|==
name|phys_p
operator|->
name|s_id
condition|)
break|break;
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|==
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
condition|)
block|{
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|AddLines
argument_list|(
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
condition|)
block|{
name|DoIDline
argument_list|(
name|j
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|i
index|]
operator|)
operator|->
name|s_id
operator|==
name|phys_p
operator|->
name|s_id
condition|)
block|{
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|DelLines
argument_list|(
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
condition|)
block|{
name|DoIDline
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Make DesiredScreen reflect what the screen should look like when we are done    with the redisplay.  This deals with horizontal scrolling.  Also makes    sure the current line of the Window is in the window. */
end_comment

begin_expr_stmt
name|UpdWindow
argument_list|(
name|w
argument_list|,
name|start
argument_list|)
specifier|register
name|Window
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Line
modifier|*
name|lp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|DotIsHere
init|=
literal|0
decl_stmt|,
name|upper
decl_stmt|,
comment|/* Top of window */
name|lower
decl_stmt|,
comment|/* Bottom of window */
name|ntries
init|=
literal|0
decl_stmt|;
comment|/* # of tries at updating window. */
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
decl_stmt|,
modifier|*
name|phys_p
decl_stmt|;
name|Buffer
modifier|*
name|bp
init|=
name|w
operator|->
name|w_bufp
decl_stmt|;
name|retry
label|:
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|CURGONE
condition|)
block|{
name|w
operator|->
name|w_line
operator|=
name|bp
operator|->
name|b_dot
expr_stmt|;
name|w
operator|->
name|w_char
operator|=
name|bp
operator|->
name|b_char
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|TOPGONE
condition|)
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* Reset topline of screen */
name|w
operator|->
name|w_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|w
operator|->
name|w_height
operator|,
name|lp
operator|=
name|w
operator|->
name|w_top
init|;
operator|--
name|i
operator|>
literal|0
operator|&&
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_line
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|lp
operator|==
literal|0
condition|)
block|{
comment|/* Current line not in window */
name|ntries
operator|++
expr_stmt|;
if|if
condition|(
name|ntries
operator|==
literal|1
condition|)
block|{
name|CalcWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|ntries
operator|==
literal|2
condition|)
block|{
name|w
operator|->
name|w_top
operator|=
name|w
operator|->
name|w_line
operator|=
name|w
operator|->
name|w_bufp
operator|->
name|b_first
expr_stmt|;
name|f_mess
argument_list|(
literal|"ERROR in redisplay: I got hopelessly lost!"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|ntries
operator|==
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\rOops, still lost, quitting ...\r\n"
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|upper
operator|=
name|start
expr_stmt|;
name|lower
operator|=
name|upper
operator|+
name|w
operator|->
name|w_height
operator|-
literal|1
expr_stmt|;
comment|/* Don't include modeline */
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|upper
index|]
expr_stmt|;
name|phys_p
operator|=
operator|&
name|PhysScreen
index|[
name|upper
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|upper
operator|,
name|lp
operator|=
name|w
operator|->
name|w_top
init|;
name|lp
operator|!=
literal|0
operator|&&
name|i
operator|<
name|lower
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
name|des_p
operator|->
name|s_window
operator|=
name|w
expr_stmt|;
name|des_p
operator|->
name|s_lp
operator|=
name|lp
expr_stmt|;
name|des_p
operator|->
name|s_id
operator|=
name|lp
operator|->
name|l_dline
operator|&
operator|~
name|DIRTY
expr_stmt|;
name|des_p
operator|->
name|s_flags
operator|=
name|isdirty
argument_list|(
name|lp
argument_list|)
condition|?
name|L_MOD
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_numlines
condition|)
name|des_p
operator|->
name|s_vln
operator|=
name|w
operator|->
name|w_topnum
operator|+
operator|(
name|i
operator|-
name|upper
operator|)
expr_stmt|;
else|else
name|des_p
operator|->
name|s_vln
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_line
condition|)
block|{
name|int
name|diff
init|=
name|w
operator|->
name|w_numlines
condition|?
literal|8
else|:
literal|0
decl_stmt|,
name|strt_col
init|=
name|phys_p
operator|->
name|s_offset
decl_stmt|,
name|end_col
init|=
name|strt_col
operator|+
operator|(
name|CO
operator|-
literal|2
operator|)
operator|-
name|diff
decl_stmt|;
comment|/* Right now we are displaying from strt_col to 			   end_col of the buffer line.  These are PRINT 			   colums, not actual characters. */
name|w
operator|->
name|w_dotline
operator|=
name|i
expr_stmt|;
name|w
operator|->
name|w_dotcol
operator|=
name|find_pos
argument_list|(
name|lp
argument_list|,
name|w
operator|->
name|w_char
argument_list|)
expr_stmt|;
comment|/* if the new dotcol is out of range, reselect 			   a horizontal window */
if|if
condition|(
name|w
operator|->
name|w_dotcol
operator|<
name|strt_col
operator|||
name|w
operator|->
name|w_dotcol
operator|>=
name|end_col
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|w_dotcol
operator|<
operator|(
operator|(
name|CO
operator|-
literal|2
operator|)
operator|-
name|diff
operator|)
condition|)
name|strt_col
operator|=
literal|0
expr_stmt|;
else|else
name|strt_col
operator|=
name|w
operator|->
name|w_dotcol
operator|-
operator|(
name|CO
operator|/
literal|2
operator|)
expr_stmt|;
block|}
name|w
operator|->
name|w_dotcol
operator|+=
name|diff
expr_stmt|;
name|des_p
operator|->
name|s_offset
operator|=
name|strt_col
expr_stmt|;
name|DotIsHere
operator|++
expr_stmt|;
block|}
else|else
name|des_p
operator|->
name|s_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DotIsHere
condition|)
block|{
name|f_mess
argument_list|(
literal|"DotNotHere is impossible!"
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Is structure assignment faster than copy each field seperately */
if|if
condition|(
name|i
operator|<
name|lower
condition|)
block|{
specifier|static
name|struct
name|scrimage
name|dirty_plate
init|=
block|{
literal|0
block|,
name|DIRTY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|clean_plate
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|lower
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
control|)
if|if
condition|(
name|phys_p
operator|->
name|s_id
operator|!=
literal|0
condition|)
operator|*
name|des_p
operator|=
name|dirty_plate
expr_stmt|;
else|else
operator|*
name|des_p
operator|=
name|clean_plate
expr_stmt|;
block|}
name|des_p
operator|->
name|s_window
operator|=
name|w
expr_stmt|;
name|des_p
operator|->
name|s_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|des_p
operator|->
name|s_id
operator|=
operator|(
name|int
operator|)
name|w
operator|->
name|w_bufp
operator|)
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
operator|||
name|UpdModLine
condition|)
name|des_p
operator|->
name|s_flags
operator|=
name|MODELINE
operator||
name|DIRTY
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write whatever is in mesgbuf (maybe we are Asking, or just printed    a message).  Turns off the UpdateMesg line flag. */
end_comment

begin_macro
name|DrawMesg
argument_list|(
argument|abortable
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|charp
argument_list|()
condition|)
return|return;
name|i_set
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|swrite
argument_list|(
name|mesgbuf
argument_list|,
name|NIL
argument_list|,
name|abortable
argument_list|)
condition|)
block|{
name|cl_eol
argument_list|()
expr_stmt|;
name|UpdMesg
operator|=
literal|0
expr_stmt|;
block|}
name|flusho
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Goto the current position in the current window.  Presumably redisplay()    has already been called, and curwind->{w_dotline,w_dotcol} have been set    correctly. */
end_comment

begin_macro
name|GotoDot
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|InputPending
condition|)
return|return;
name|Placur
argument_list|(
name|curwind
operator|->
name|w_dotline
argument_list|,
name|curwind
operator|->
name|w_dotcol
operator|-
name|PhysScreen
index|[
name|curwind
operator|->
name|w_dotline
index|]
operator|.
name|s_offset
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|private
name|UntilEqual
parameter_list|(
name|start
parameter_list|)
specifier|register
name|int
name|start
decl_stmt|;
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
init|=
operator|&
name|DesiredScreen
index|[
name|start
index|]
decl_stmt|,
modifier|*
name|phys_p
init|=
operator|&
name|PhysScreen
index|[
name|start
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|start
operator|<
name|ILI
operator|)
operator|&&
operator|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
condition|)
block|{
name|des_p
operator|++
expr_stmt|;
name|phys_p
operator|++
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Calls the routine to do the physical changes, and changes PhysScreen to    reflect those changes. */
end_comment

begin_expr_stmt
name|AddLines
argument_list|(
name|at
argument_list|,
name|num
argument_list|)
specifier|register
name|int
name|at
operator|,
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|bottom
init|=
name|UntilEqual
argument_list|(
name|at
operator|+
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|num
operator|>=
operator|(
operator|(
name|bottom
operator|-
literal|1
operator|)
operator|-
name|at
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We did nothing */
name|v_ins_line
argument_list|(
name|num
argument_list|,
name|at
argument_list|,
name|bottom
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Now change PhysScreen to account for the physical change. */
for|for
control|(
name|i
operator|=
name|bottom
operator|-
literal|1
init|;
name|i
operator|-
name|num
operator|>=
name|at
condition|;
name|i
operator|--
control|)
name|PhysScreen
index|[
name|i
index|]
operator|=
name|PhysScreen
index|[
name|i
operator|-
name|num
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|at
operator|+
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* We did something. */
block|}
end_block

begin_expr_stmt
name|DelLines
argument_list|(
name|at
argument_list|,
name|num
argument_list|)
specifier|register
name|int
name|at
operator|,
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|bottom
init|=
name|UntilEqual
argument_list|(
name|at
operator|+
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|num
operator|>=
operator|(
operator|(
name|bottom
operator|-
literal|1
operator|)
operator|-
name|at
operator|)
condition|)
return|return
literal|0
return|;
name|v_del_line
argument_list|(
name|num
argument_list|,
name|at
argument_list|,
name|bottom
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|at
init|;
name|num
operator|+
name|i
operator|<
name|bottom
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|i
index|]
operator|=
name|PhysScreen
index|[
name|num
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bottom
operator|-
name|num
init|;
name|i
operator|<
name|bottom
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Update line linenum in window w.  Only set PhysScreen to DesiredScreen    if the swrite or cl_eol works, that is nothing is interupted by     characters typed. */
end_comment

begin_expr_stmt
name|UpdLine
argument_list|(
name|linenum
argument_list|)
specifier|register
name|int
name|linenum
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
init|=
operator|&
name|DesiredScreen
index|[
name|linenum
index|]
decl_stmt|;
specifier|register
name|Window
modifier|*
name|w
init|=
name|des_p
operator|->
name|s_window
decl_stmt|;
name|i_set
argument_list|(
name|linenum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|des_p
operator|->
name|s_flags
operator|&
name|MODELINE
condition|)
name|ModeLine
argument_list|(
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|des_p
operator|->
name|s_id
condition|)
block|{
name|des_p
operator|->
name|s_lp
operator|->
name|l_dline
operator|&=
operator|~
name|DIRTY
expr_stmt|;
name|des_p
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|DIRTY
operator||
name|L_MOD
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
operator|!
name|UseIC
operator|&&
name|w
operator|->
name|w_numlines
condition|)
else|#
directive|else
if|if
condition|(
name|w
operator|->
name|w_numlines
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|swrite
argument_list|(
name|sprint
argument_list|(
literal|"%6d  "
argument_list|,
name|des_p
operator|->
name|s_vln
argument_list|)
argument_list|,
name|NIL
argument_list|,
name|YES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|UseIC
condition|)
block|{
name|char
name|outbuf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|lptr
decl_stmt|;
name|int
name|fromcol
init|=
name|w
operator|->
name|w_numlines
condition|?
literal|8
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|w_numlines
condition|)
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"%6d  "
argument_list|,
name|des_p
operator|->
name|s_vln
argument_list|)
expr_stmt|;
name|lptr
operator|=
name|lcontents
argument_list|(
name|des_p
operator|->
name|s_lp
argument_list|)
expr_stmt|;
name|DeTab
argument_list|(
name|des_p
operator|->
name|s_offset
argument_list|,
name|lptr
argument_list|,
name|outbuf
operator|+
name|fromcol
argument_list|,
operator|(
sizeof|sizeof
name|outbuf
operator|)
operator|-
literal|1
operator|-
name|fromcol
argument_list|,
name|des_p
operator|->
name|s_window
operator|->
name|w_visspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDchar
argument_list|(
name|outbuf
argument_list|,
name|linenum
argument_list|,
literal|0
argument_list|)
condition|)
name|PhysScreen
index|[
name|linenum
index|]
operator|=
operator|*
name|des_p
expr_stmt|;
elseif|else
if|if
condition|(
name|i_set
argument_list|(
name|linenum
argument_list|,
literal|0
argument_list|)
operator|,
name|swrite
argument_list|(
name|outbuf
argument_list|,
name|NIL
argument_list|,
name|YES
argument_list|)
condition|)
name|do_cl_eol
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
else|else
name|PhysScreen
index|[
name|linenum
index|]
operator|.
name|s_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
endif|ID_CHAR
if|if
condition|(
name|BufSwrite
argument_list|(
name|linenum
argument_list|)
condition|)
name|do_cl_eol
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
else|else
name|PhysScreen
index|[
name|linenum
index|]
operator|.
name|s_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PhysScreen
index|[
name|linenum
index|]
operator|.
name|s_id
condition|)
comment|/* Not the same ... make sure */
name|do_cl_eol
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|do_cl_eol
argument_list|(
name|linenum
argument_list|)
specifier|register
name|int
name|linenum
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cl_eol
argument_list|()
expr_stmt|;
name|PhysScreen
index|[
name|linenum
index|]
operator|=
name|DesiredScreen
index|[
name|linenum
index|]
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|ID_CHAR
end_ifdef

begin_comment
comment|/* From here to the end of the file is code that tries to utilize the    insert/delete character feature on some terminals.  It is very confusing    and not so well written code, AND there is a lot of it.  You may want    to use the space for something else. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|screenline
modifier|*
name|Screen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|IN_INSmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|UseIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DClen
decl_stmt|,
name|MDClen
decl_stmt|,
name|IClen
decl_stmt|,
name|MIClen
decl_stmt|,
name|IMlen
decl_stmt|,
name|CElen
decl_stmt|;
end_decl_stmt

begin_macro
name|disp_opt_init
argument_list|()
end_macro

begin_block
block|{
name|DClen
operator|=
name|DC
condition|?
name|strlen
argument_list|(
name|DC
argument_list|)
else|:
literal|0
expr_stmt|;
name|MDClen
operator|=
name|M_DC
condition|?
name|strlen
argument_list|(
name|M_DC
argument_list|)
else|:
literal|9999
expr_stmt|;
name|IClen
operator|=
name|IC
condition|?
name|strlen
argument_list|(
name|IC
argument_list|)
else|:
literal|0
expr_stmt|;
name|MIClen
operator|=
name|M_IC
condition|?
name|strlen
argument_list|(
name|M_IC
argument_list|)
else|:
literal|9999
expr_stmt|;
name|IMlen
operator|=
name|IM
condition|?
name|strlen
argument_list|(
name|IM
argument_list|)
else|:
literal|0
expr_stmt|;
name|CElen
operator|=
name|CE
condition|?
name|strlen
argument_list|(
name|CE
argument_list|)
else|:
literal|0
expr_stmt|;
name|UseIC
operator|=
operator|(
name|IC
operator|||
name|IM
operator|||
name|M_IC
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|INSmode
argument_list|(
argument|on
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|on
operator|&&
operator|!
name|IN_INSmode
condition|)
block|{
name|putpad
argument_list|(
name|IM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IN_INSmode
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
name|IN_INSmode
condition|)
block|{
name|putpad
argument_list|(
name|EI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IN_INSmode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
name|private
name|DeTab
parameter_list|(
name|s_offset
parameter_list|,
name|buf
parameter_list|,
name|outbuf
parameter_list|,
name|limit
parameter_list|,
name|visspace
parameter_list|)
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|outbuf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|phys_p
init|=
name|outbuf
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|limitp
init|=
operator|&
name|outbuf
index|[
name|limit
index|]
decl_stmt|;
define|#
directive|define
name|OkayOut
parameter_list|(
name|ch
parameter_list|)
value|if ((pos++>= s_offset)&& (phys_p< limitp))\ 				*phys_p++ = ch;\ 			else
while|while
condition|(
name|c
operator|=
operator|*
name|buf
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
init|=
operator|(
name|tabstop
operator|-
operator|(
name|pos
operator|%
name|tabstop
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|visspace
condition|)
block|{
name|OkayOut
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
operator|--
name|nchars
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|OkayOut
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|OkayOut
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|OkayOut
argument_list|(
name|c
operator|==
literal|0177
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|visspace
operator|&&
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
name|OkayOut
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|-
name|s_offset
operator|>=
name|CO
condition|)
block|{
name|phys_p
operator|=
operator|&
name|outbuf
index|[
name|CO
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|phys_p
operator|++
operator|=
literal|'!'
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|phys_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ID character routines full of special cases and other fun stuff like that.    It actually works though ...     	Returns Non-Zero if you are finished (no differences left). */
end_comment

begin_function
name|private
name|IDchar
parameter_list|(
name|new
parameter_list|,
name|lineno
parameter_list|,
name|col
parameter_list|)
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|oldlen
decl_stmt|,
name|NumSaved
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|sline
init|=
operator|&
name|Screen
index|[
name|lineno
index|]
decl_stmt|;
name|oldlen
operator|=
name|sline
operator|->
name|s_length
operator|-
name|sline
operator|->
name|s_line
expr_stmt|;
for|for
control|(
name|i
operator|=
name|col
init|;
name|i
operator|<
name|oldlen
operator|&&
name|new
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sline
operator|->
name|s_line
index|[
name|i
index|]
operator|!=
name|new
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|new
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|i
operator|==
name|oldlen
condition|)
return|return
operator|(
name|new
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|i
operator|==
name|oldlen
operator|)
return|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|oldlen
operator|&&
name|new
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|new
index|[
name|j
index|]
operator|==
name|sline
operator|->
name|s_line
index|[
name|i
index|]
condition|)
block|{
name|NumSaved
operator|=
name|IDcomp
argument_list|(
name|new
operator|+
name|j
argument_list|,
name|sline
operator|->
name|s_line
operator|+
name|i
argument_list|,
name|strlen
argument_list|(
name|new
argument_list|)
argument_list|)
operator|+
name|NumSimilar
argument_list|(
name|new
operator|+
name|i
argument_list|,
name|sline
operator|->
name|s_line
operator|+
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|OkayInsert
argument_list|(
name|NumSaved
argument_list|,
name|j
operator|-
name|i
argument_list|)
condition|)
block|{
name|InsChar
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|IDchar
argument_list|(
name|new
argument_list|,
name|lineno
argument_list|,
name|j
argument_list|)
operator|)
return|;
block|}
block|}
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|oldlen
operator|&&
name|new
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|new
index|[
name|i
index|]
operator|==
name|sline
operator|->
name|s_line
index|[
name|j
index|]
condition|)
block|{
name|NumSaved
operator|=
name|IDcomp
argument_list|(
name|new
operator|+
name|i
argument_list|,
name|sline
operator|->
name|s_line
operator|+
name|j
argument_list|,
name|oldlen
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|OkayDelete
argument_list|(
name|NumSaved
argument_list|,
name|j
operator|-
name|i
argument_list|,
name|new
index|[
name|oldlen
index|]
operator|==
literal|0
argument_list|)
condition|)
block|{
name|DelChar
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|IDchar
argument_list|(
name|new
argument_list|,
name|lineno
argument_list|,
name|j
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|NumSimilar
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|t
operator|++
condition|)
name|num
operator|++
expr_stmt|;
return|return
name|num
return|;
block|}
end_block

begin_function
name|private
name|IDcomp
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|nonspace
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
operator|*
name|t
operator|++
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
name|nonspace
operator|++
expr_stmt|;
if|if
condition|(
name|nonspace
condition|)
name|num
operator|++
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_block

begin_function
name|private
name|OkayDelete
parameter_list|(
name|Saved
parameter_list|,
name|num
parameter_list|,
name|samelength
parameter_list|)
block|{
comment|/* If the old and the new are the same length, then we don't 	 * have to clear to end of line.  We take that into consideration. 	 */
return|return
operator|(
operator|(
name|Saved
operator|+
operator|(
operator|!
name|samelength
condition|?
name|CElen
else|:
literal|0
operator|)
operator|)
operator|>
name|min
argument_list|(
name|MDClen
argument_list|,
name|DClen
operator|*
name|num
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|private
name|OkayInsert
parameter_list|(
name|Saved
parameter_list|,
name|num
parameter_list|)
block|{
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IC
condition|)
comment|/* Per character prefixes */
name|n
operator|=
name|min
argument_list|(
name|num
operator|*
name|IClen
argument_list|,
name|MIClen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IM
operator|&&
operator|!
name|IN_INSmode
condition|)
block|{
comment|/* Good terminal.  Fewer characters in this case */
name|n
operator|+=
name|IMlen
expr_stmt|;
block|}
name|n
operator|+=
name|num
expr_stmt|;
comment|/* The characters themselves */
return|return
name|Saved
operator|>
name|n
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|CapCol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cursend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|screenline
modifier|*
name|Curline
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|DelChar
parameter_list|(
name|lineno
parameter_list|,
name|col
parameter_list|,
name|num
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|screenline
modifier|*
name|sp
init|=
operator|(
operator|&
name|Screen
index|[
name|lineno
index|]
operator|)
decl_stmt|;
name|Placur
argument_list|(
name|lineno
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DC
operator|&&
name|num
operator|>
literal|1
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_DC
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|num
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|putpad
argument_list|(
name|DC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|sp
operator|->
name|s_line
operator|+
name|col
expr_stmt|;
name|from
operator|=
name|to
operator|+
name|num
expr_stmt|;
name|byte_copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|sp
operator|->
name|s_length
operator|-
name|from
operator|+
literal|1
argument_list|)
expr_stmt|;
name|clrline
argument_list|(
name|sp
operator|->
name|s_length
operator|-
name|num
argument_list|,
name|sp
operator|->
name|s_length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_length
operator|-=
name|num
expr_stmt|;
block|}
end_function

begin_function
name|private
name|InsChar
parameter_list|(
name|lineno
parameter_list|,
name|col
parameter_list|,
name|num
parameter_list|,
name|new
parameter_list|)
name|char
modifier|*
name|new
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|sp2
decl_stmt|,
comment|/* To push over the array. */
modifier|*
name|sp3
decl_stmt|;
comment|/* Last character to push over. */
name|int
name|i
decl_stmt|;
name|i_set
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sp2
operator|=
name|Curline
operator|->
name|s_length
operator|+
name|num
expr_stmt|;
if|if
condition|(
name|sp2
operator|>=
name|cursend
condition|)
block|{
name|i_set
argument_list|(
name|lineno
argument_list|,
name|CO
operator|-
name|num
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cl_eol
argument_list|()
expr_stmt|;
name|sp2
operator|=
name|cursend
operator|-
literal|1
expr_stmt|;
block|}
name|Curline
operator|->
name|s_length
operator|=
name|sp2
expr_stmt|;
name|sp1
operator|=
name|sp2
operator|-
name|num
expr_stmt|;
name|sp3
operator|=
name|Curline
operator|->
name|s_line
operator|+
name|col
expr_stmt|;
while|while
condition|(
name|sp1
operator|>=
name|sp3
condition|)
operator|*
name|sp2
operator|--
operator|=
operator|*
name|sp1
operator|--
expr_stmt|;
name|new
operator|+=
name|col
expr_stmt|;
name|byte_copy
argument_list|(
name|new
argument_list|,
name|sp3
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* The internal screen is correct, and now we have to do 	   the physical stuff. */
name|Placur
argument_list|(
name|lineno
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|IM
condition|)
block|{
if|if
condition|(
operator|!
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|M_IC
operator|&&
name|num
operator|>
literal|1
condition|)
block|{
name|char
name|minibuf
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|minibuf
argument_list|,
name|M_IC
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|minibuf
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|IC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|putchar
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_INSmode
condition|)
name|putpad
argument_list|(
name|IP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|CapCol
operator|+=
name|num
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ID_CHAR
end_endif

begin_comment
comment|/* chkmail() returns nonzero if there is new mail since the    last time we checked. */
end_comment

begin_decl_stmt
name|char
name|Mailbox
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialized in main */
end_comment

begin_decl_stmt
name|int
name|MailInt
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check no more often than 60 seconds */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIFF
end_ifdef

begin_decl_stmt
name|int
name|BiffChk
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether or not to turn off biff while in JOVE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|chkmail
argument_list|(
argument|force
argument_list|)
end_macro

begin_block
block|{
name|time_t
name|now
decl_stmt|;
specifier|static
name|time_t
name|last_chk
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|value
init|=
name|FALSE
decl_stmt|;
specifier|static
name|off_t
name|last_size
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|int
name|last_val
decl_stmt|;
specifier|extern
name|time_t
name|time0
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|now
operator|<
name|last_chk
operator|+
name|MailInt
operator|)
condition|)
return|return
name|value
return|;
if|if
condition|(
name|stat
argument_list|(
name|Mailbox
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|last_val
operator|=
name|value
expr_stmt|;
name|value
operator|=
operator|(
operator|(
name|stbuf
operator|.
name|st_mtime
operator|>
name|time0
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_size
operator|>
name|last_size
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_mtime
operator|+
literal|5
operator|>
name|stbuf
operator|.
name|st_atime
operator|)
operator|)
expr_stmt|;
name|last_chk
operator|=
name|now
expr_stmt|;
name|last_size
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|TRUE
operator|&&
name|value
operator|!=
name|last_val
condition|)
name|dobell
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_comment
comment|/* Print the mode line. */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|mode_p
decl_stmt|,
modifier|*
name|mend_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BriteMode
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modeline should standout */
end_comment

begin_function
name|private
name|mode_app
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|mode_p
operator|>=
name|mend_p
condition|)
return|return;
while|while
condition|(
operator|(
name|mode_p
operator|<
name|mend_p
operator|)
operator|&&
operator|(
operator|*
name|mode_p
operator|++
operator|=
operator|*
name|str
operator|++
operator|)
condition|)
empty_stmt|;
name|mode_p
operator|--
expr_stmt|;
comment|/* back over the null */
block|}
end_function

begin_decl_stmt
name|char
name|ModeFmt
index|[
literal|120
index|]
init|=
literal|"%3c %[%sJOVE (%M)   Buffer: %b  \"%f\" %]%s%m %((%t)%s%)%e"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ModeLine
argument_list|(
name|w
argument_list|)
specifier|register
name|Window
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|i_line
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ign_some
init|=
literal|0
decl_stmt|;
name|char
name|line
index|[
literal|132
index|]
decl_stmt|,
modifier|*
name|fmt
init|=
name|ModeFmt
decl_stmt|,
name|tmp
index|[
literal|16
index|]
decl_stmt|,
name|fillc
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|thisbuf
init|=
name|w
operator|->
name|w_bufp
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
name|mode_p
operator|=
name|line
expr_stmt|;
name|mend_p
operator|=
operator|&
name|line
index|[
operator|(
sizeof|sizeof
name|line
operator|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|BriteMode
operator|!=
literal|0
operator|&&
name|SO
operator|==
literal|0
condition|)
name|BriteMode
operator|=
literal|0
expr_stmt|;
name|fillc
operator|=
name|BriteMode
condition|?
literal|' '
else|:
literal|'-'
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|fmt
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
operator|!
name|ign_some
condition|)
operator|*
name|mode_p
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
comment|/* Character after the percent! */
if|if
condition|(
name|ign_some
operator|&&
name|c
operator|!=
literal|')'
condition|)
continue|continue;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|w
operator|->
name|w_next
operator|!=
name|fwind
condition|)
comment|/* Not bottom window. */
name|ign_some
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|ign_some
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|mode_p
operator|++
operator|=
name|fillc
expr_stmt|;
break|break;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
block|{
name|char
modifier|*
name|strs
init|=
operator|(
name|c
operator|==
literal|'['
operator|)
condition|?
literal|"[[[[[[[[[["
else|:
literal|"]]]]]]]]]]"
decl_stmt|;
name|mode_app
argument_list|(
name|strs
operator|+
literal|10
operator|-
name|RecDepth
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
if|if
condition|(
name|mode_p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
continue|continue;
operator|*
name|mode_p
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
block|{
specifier|static
name|char
modifier|*
name|mmodes
index|[]
init|=
block|{
literal|"Fundamental "
block|,
literal|"Text "
block|,
literal|"C "
block|,
ifdef|#
directive|ifdef
name|LISP
literal|"Lisp "
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
name|mode_app
argument_list|(
name|mmodes
index|[
name|thisbuf
operator|->
name|b_major
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|Fill
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"Fill "
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|Abbrev
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"Abbrev "
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|OverWrite
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"OvrWt "
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|Indent
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"AI "
argument_list|)
expr_stmt|;
if|if
condition|(
name|KeyMacro
operator|.
name|m_flags
operator|&
name|DEFINE
condition|)
name|mode_app
argument_list|(
literal|"Def "
argument_list|)
expr_stmt|;
name|mode_p
operator|--
expr_stmt|;
comment|/* Back over the extra space. */
break|break;
block|}
case|case
literal|'b'
case|:
name|mode_app
argument_list|(
name|thisbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|thisbuf
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|mode_app
argument_list|(
literal|"[No file]"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|mode_app
argument_list|(
name|pr_name
argument_list|(
name|thisbuf
operator|->
name|b_fname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mode_app
argument_list|(
name|basename
argument_list|(
name|thisbuf
operator|->
name|b_fname
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
for|for
control|(
name|bp
operator|=
name|world
operator|,
name|n
operator|=
literal|1
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
operator|,
name|n
operator|++
control|)
if|if
condition|(
name|bp
operator|==
name|thisbuf
condition|)
break|break;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mode_app
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|IsModified
argument_list|(
name|w
operator|->
name|w_bufp
argument_list|)
condition|)
operator|*
name|mode_p
operator|++
operator|=
literal|'*'
expr_stmt|;
else|else
operator|*
name|mode_p
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
name|char
name|timestr
index|[
literal|12
index|]
decl_stmt|;
name|mode_app
argument_list|(
name|get_time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|,
name|timestr
argument_list|,
literal|11
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|LOAD_AV
case|case
literal|'l'
case|:
block|{
name|double
name|theavg
decl_stmt|;
name|char
name|minibuf
index|[
literal|10
index|]
decl_stmt|;
name|get_la
argument_list|(
operator|&
name|theavg
argument_list|)
expr_stmt|;
name|theavg
operator|+=
literal|.005
expr_stmt|;
comment|/* round to nearest .01 */
name|sprintf
argument_list|(
name|minibuf
argument_list|,
literal|"%d.%02d"
argument_list|,
operator|(
name|int
operator|)
name|theavg
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|theavg
operator|-
operator|(
name|int
operator|)
name|theavg
operator|)
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|mode_app
argument_list|(
name|minibuf
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
literal|'C'
case|:
comment|/* check mail here */
if|if
condition|(
name|chkmail
argument_list|(
name|NO
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"[New mail]"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CHDIR
case|case
literal|'d'
case|:
comment|/* print working directory */
name|mode_app
argument_list|(
name|pr_name
argument_list|(
name|pwd
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'e'
case|:
block|{
comment|/* 2 space pad pluss padding for magic cookies */
name|char
modifier|*
name|last_p
init|=
operator|&
name|line
index|[
name|CO
operator|-
literal|2
operator|-
operator|(
literal|2
operator|*
name|SG
operator|)
index|]
decl_stmt|;
while|while
condition|(
name|mode_p
operator|<
name|last_p
condition|)
operator|*
name|mode_p
operator|++
operator|=
name|fillc
expr_stmt|;
goto|goto
name|outahere
goto|;
comment|/* %e means we're done! */
block|}
block|}
block|}
name|outahere
label|:
operator|*
name|mode_p
operator|=
literal|0
expr_stmt|;
comment|/* Highlight mode line. */
if|if
condition|(
name|BriteMode
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putpad
argument_list|(
name|SO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|swrite
argument_list|(
name|line
argument_list|,
name|BriteMode
argument_list|,
name|YES
argument_list|)
condition|)
name|do_cl_eol
argument_list|(
name|i_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|BriteMode
condition|)
name|putpad
argument_list|(
name|SE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|RedrawDisplay
argument_list|()
end_macro

begin_block
block|{
name|Line
modifier|*
name|newtop
init|=
name|prev_line
argument_list|(
operator|(
name|curwind
operator|->
name|w_line
operator|=
name|curline
operator|)
argument_list|,
name|exp_p
condition|?
name|exp
else|:
name|HALF
argument_list|(
name|curwind
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newtop
operator|==
name|curwind
operator|->
name|w_top
condition|)
name|v_clear
argument_list|(
name|FLine
argument_list|(
name|curwind
argument_list|)
argument_list|,
name|FLine
argument_list|(
name|curwind
argument_list|)
operator|+
name|SIZE
argument_list|(
name|curwind
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|newtop
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|v_clear
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|)
specifier|register
name|int
name|line1
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|phys_p
decl_stmt|,
modifier|*
name|des_p
decl_stmt|;
name|phys_p
operator|=
operator|&
name|PhysScreen
index|[
name|line1
index|]
expr_stmt|;
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|line1
index|]
expr_stmt|;
while|while
condition|(
name|line1
operator|<=
name|line2
condition|)
block|{
name|i_set
argument_list|(
name|line1
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cl_eol
argument_list|()
expr_stmt|;
name|phys_p
operator|->
name|s_id
operator|=
name|des_p
operator|->
name|s_id
operator|=
literal|0
expr_stmt|;
name|phys_p
operator|++
operator|,
name|des_p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ClAndRedraw
argument_list|()
end_macro

begin_block
block|{
name|cl_scr
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NextPage
argument_list|()
end_macro

begin_block
block|{
name|Line
modifier|*
name|newline
decl_stmt|;
if|if
condition|(
name|Asking
condition|)
return|return;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
block|{
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
name|PrevPage
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp_p
condition|)
name|UpScroll
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|in_window
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_bufp
operator|->
name|b_last
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|newline
operator|=
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|max
argument_list|(
literal|1
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_line
operator|=
name|newline
argument_list|)
expr_stmt|;
if|if
condition|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
condition|)
name|SetLine
argument_list|(
name|newline
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|PrevPage
argument_list|()
end_macro

begin_block
block|{
name|Line
modifier|*
name|newline
decl_stmt|;
if|if
condition|(
name|Asking
condition|)
return|return;
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
block|{
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
name|NextPage
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exp_p
condition|)
name|DownScroll
argument_list|()
expr_stmt|;
else|else
block|{
name|newline
operator|=
name|prev_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|max
argument_list|(
literal|1
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_line
operator|=
name|newline
argument_list|)
expr_stmt|;
if|if
condition|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
condition|)
name|SetLine
argument_list|(
name|newline
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|UpScroll
argument_list|()
end_macro

begin_block
block|{
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
operator|)
operator|&&
operator|(
name|in_window
argument_list|(
name|curwind
argument_list|,
name|curline
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
name|SetLine
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DownScroll
argument_list|()
end_macro

begin_block
block|{
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|prev_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
operator|)
operator|&&
operator|(
name|in_window
argument_list|(
name|curwind
argument_list|,
name|curline
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
name|SetLine
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|VisBell
init|=
literal|0
decl_stmt|,
name|RingBell
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* So if we have a lot of errors ... 			   ring the bell only ONCE */
end_comment

begin_macro
name|rbell
argument_list|()
end_macro

begin_block
block|{
name|RingBell
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Message prints the null terminated string onto the bottom line of the    terminal. */
end_comment

begin_macro
name|message
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|InJoverc
condition|)
return|return;
name|UpdMesg
operator|++
expr_stmt|;
name|errormsg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|mesgbuf
condition|)
name|null_ncpy
argument_list|(
name|mesgbuf
argument_list|,
name|str
argument_list|,
operator|(
sizeof|sizeof
name|mesgbuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* End of Window */
end_comment

begin_macro
name|Eow
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Asking
condition|)
return|return;
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
operator|-
name|min
argument_list|(
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|,
name|exp
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp_p
condition|)
name|Eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Beginning of Window */
end_comment

begin_macro
name|Bow
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Asking
condition|)
return|return;
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|min
argument_list|(
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|,
name|exp
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|private
name|int
name|LineNo
decl_stmt|,
name|last_col
decl_stmt|,
name|DoAutoNL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Window
modifier|*
name|old_wind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save the window we were in BEFORE 				   before we were called, if UseBuffers 				   is nonzero */
end_comment

begin_decl_stmt
name|int
name|UseBuffers
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TOabort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This initializes the typeout.  If send-typeout-to-buffers is set    the buffer NAME is created (emptied if it already exists) and output    goes to the buffer.  Otherwise output is drawn on the screen and    erased by TOstop() */
end_comment

begin_macro
name|TOstart
argument_list|(
argument|name
argument_list|,
argument|auto_newline
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|UseBuffers
condition|)
block|{
name|old_wind
operator|=
name|curwind
expr_stmt|;
name|pop_wind
argument_list|(
name|name
argument_list|,
name|YES
argument_list|,
name|B_SCRATCH
argument_list|)
expr_stmt|;
block|}
name|TOabort
operator|=
name|LineNo
operator|=
name|last_col
operator|=
literal|0
expr_stmt|;
name|DoAutoNL
operator|=
name|auto_newline
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|Typeout
argument_list|(
argument|fmt
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_block
block|{
if|if
condition|(
name|TOabort
condition|)
return|return;
if|if
condition|(
operator|!
name|UseBuffers
operator|&&
operator|(
name|LineNo
operator|==
name|ILI
operator|-
literal|1
operator|)
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|LineNo
operator|=
literal|0
expr_stmt|;
name|last_col
operator|=
literal|0
expr_stmt|;
name|f_mess
argument_list|(
literal|"--more--"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|' '
condition|)
block|{
name|TOabort
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|CTL
argument_list|(
name|G
argument_list|)
operator|&&
name|c
operator|!=
name|RUBOUT
condition|)
name|Ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_mess
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmt
condition|)
block|{
specifier|extern
name|int
name|i_col
decl_stmt|;
name|char
name|string
index|[
literal|132
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|UseBuffers
condition|)
name|ins_str
argument_list|(
name|string
argument_list|,
name|NO
argument_list|)
expr_stmt|;
else|else
block|{
name|i_set
argument_list|(
name|LineNo
argument_list|,
name|last_col
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|swrite
argument_list|(
name|string
argument_list|,
name|NIL
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|last_col
operator|=
name|i_col
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|UseBuffers
condition|)
block|{
name|PhysScreen
index|[
name|LineNo
index|]
operator|.
name|s_id
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
literal|0
operator|||
name|DoAutoNL
operator|!=
literal|0
condition|)
block|{
name|cl_eol
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|LineNo
operator|++
expr_stmt|;
name|last_col
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
literal|0
operator|||
name|DoAutoNL
operator|!=
literal|0
condition|)
name|ins_str
argument_list|(
literal|"\n"
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|TOstop
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|UseBuffers
condition|)
block|{
name|ToFirst
argument_list|()
expr_stmt|;
name|SetWind
argument_list|(
name|old_wind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TOabort
condition|)
return|return;
if|if
condition|(
name|last_col
operator|!=
literal|0
condition|)
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"----------"
argument_list|)
expr_stmt|;
name|cl_eol
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
name|Ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

