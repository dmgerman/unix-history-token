begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|MAXFILES
value|20
end_define

begin_comment
comment|/* good enough for my purposes */
end_comment

begin_decl_stmt
specifier|static
name|File
name|_openfiles
index|[
name|MAXFILES
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|File
modifier|*
name|f_alloc
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|buf_size
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_openfiles
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXFILES
condition|;
name|i
operator|++
operator|,
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXFILES
condition|)
name|complain
argument_list|(
literal|"[Too many open files!]"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_bufsize
operator|=
name|buf_size
expr_stmt|;
name|fp
operator|->
name|f_cnt
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_fd
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
name|emalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_MYBUF
expr_stmt|;
block|}
name|fp
operator|->
name|f_base
operator|=
name|fp
operator|->
name|f_ptr
operator|=
name|buffer
expr_stmt|;
name|fp
operator|->
name|f_name
operator|=
name|copystr
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_macro
name|gc_openfiles
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_openfiles
init|;
name|fp
operator|<
operator|&
name|_openfiles
index|[
name|MAXFILES
index|]
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|!=
literal|0
operator|&&
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|F_LOCK
operator|)
operator|==
literal|0
condition|)
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|File
modifier|*
name|fd_open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|bsize
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
return|return
name|f_alloc
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|buffer
argument_list|,
name|bsize
argument_list|)
return|;
block|}
end_function

begin_function
name|File
modifier|*
name|f_open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|buffer
parameter_list|,
name|buf_size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|mode
init|=
name|F_MODE
argument_list|(
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|F_READ
condition|)
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|F_APPEND
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|mode
operator|=
name|F_WRITE
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|F_WRITE
condition|)
name|fd
operator|=
name|creat
argument_list|(
name|name
argument_list|,
name|CreatMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
name|NIL
return|;
return|return
name|f_alloc
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|buffer
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_block

begin_macro
name|f_close
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|File
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_WRITE
operator||
name|F_APPEND
operator|)
condition|)
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_MYBUF
condition|)
name|free
argument_list|(
name|fp
operator|->
name|f_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|f_name
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* indicates that we're available */
block|}
end_block

begin_macro
name|filbuf
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|File
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_EOF
operator||
name|F_ERR
operator|)
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|f_ptr
operator|=
name|fp
operator|->
name|f_base
expr_stmt|;
name|fp
operator|->
name|f_cnt
operator|=
name|read
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
name|fp
operator|->
name|f_base
argument_list|,
name|fp
operator|->
name|f_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_cnt
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[Read error %d]"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_ERR
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_cnt
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|F_EOF
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|io_chars
operator|+=
name|fp
operator|->
name|f_cnt
expr_stmt|;
return|return
name|getc
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|putstr
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|fputnchar
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|fp
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|putc
argument_list|(
operator|*
name|s
operator|++
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|putnchar
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputnchar
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|flusho
argument_list|()
end_macro

begin_block
block|{
name|_flush
argument_list|(
name|EOF
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|flush
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|File
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|_flush
argument_list|(
name|EOF
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|_flush
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
specifier|register
name|File
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|F_READ
operator|)
operator|||
operator|(
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|F_STRING
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|(
name|n
operator|=
operator|(
name|fp
operator|->
name|f_ptr
operator|-
name|fp
operator|->
name|f_base
operator|)
operator|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|write
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
name|fp
operator|->
name|f_base
argument_list|,
name|n
argument_list|)
operator|!=
name|n
operator|)
operator|&&
operator|(
name|fp
operator|!=
name|stdout
operator|)
condition|)
name|error
argument_list|(
literal|"[I/O error(%d); file = %s, fd = %d]"
argument_list|,
name|errno
argument_list|,
name|fp
operator|->
name|f_name
argument_list|,
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|stdout
condition|)
name|OkayAbort
operator|=
name|YES
expr_stmt|;
name|fp
operator|->
name|f_cnt
operator|=
name|fp
operator|->
name|f_bufsize
expr_stmt|;
name|fp
operator|->
name|f_ptr
operator|=
name|fp
operator|->
name|f_base
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|f_gets
argument_list|(
name|fp
argument_list|,
name|buf
argument_list|,
name|max
argument_list|)
specifier|register
name|File
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|endp
init|=
name|buf
operator|+
name|max
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_EOF
condition|)
return|return
name|EOF
return|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
comment|/* sorry we don't read nulls */
if|if
condition|(
name|cp
operator|>=
name|endp
condition|)
block|{
name|add_mess
argument_list|(
literal|" [Line too long]"
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
return|return
name|EOF
return|;
block|}
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
name|add_mess
argument_list|(
literal|" [Incomplete last line]"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_EOF
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|io_lines
operator|++
expr_stmt|;
return|return
name|NIL
return|;
comment|/* this means okay */
block|}
end_block

begin_comment
comment|/* Deals with output to the terminal, setting up the amount of characters    to be buffered depending on the output baud rate.  Why it's in a     separate file I don't know ... */
end_comment

begin_decl_stmt
specifier|static
name|char
name|one_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BufSize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|File
name|_stdout
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|F_WRITE
block|,
operator|&
name|one_buf
block|,
operator|&
name|one_buf
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|File
modifier|*
name|stdout
init|=
operator|&
name|_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* put a string with padding */
end_comment

begin_macro
name|tputc
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_comment
comment|/* for files which forget to include io.h, 			   here's a real putchar procedure. */
end_comment

begin_macro
name|putchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putpad
argument_list|(
argument|str
argument_list|,
argument|lines
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|str
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
name|lines
argument_list|,
name|tputc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Determine the number of characters to buffer at each baud rate.  The    lower the number, the quicker the response when new input arrives.  Of    course the lower the number, the more prone the program is to stop in    output.  Decide what matters most to you. This sets BufSize to the right    number or chars, and initiaizes `stdout'.  */
end_comment

begin_macro
name|settout
argument_list|(
argument|ttbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ttbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|speeds
index|[]
init|=
block|{
literal|1
block|,
comment|/* 0	*/
literal|1
block|,
comment|/* 50	*/
literal|1
block|,
comment|/* 75	*/
literal|1
block|,
comment|/* 110	*/
literal|1
block|,
comment|/* 134	*/
literal|1
block|,
comment|/* 150	*/
literal|1
block|,
comment|/* 200	*/
literal|2
block|,
comment|/* 300	*/
literal|4
block|,
comment|/* 600	*/
literal|8
block|,
comment|/* 1200 */
literal|16
block|,
comment|/* 1800	*/
literal|32
block|,
comment|/* 2400	*/
literal|128
block|,
comment|/* 4800	*/
literal|256
block|,
comment|/* 9600	*/
literal|512
block|,
comment|/* EXTA	*/
literal|512
comment|/* EXT	*/
block|}
decl_stmt|;
name|BufSize
operator|=
name|min
argument_list|(
literal|512
argument_list|,
operator|(
name|speeds
index|[
name|ospeed
index|]
operator|*
name|max
argument_list|(
name|LI
operator|/
literal|24
argument_list|,
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|stdout
operator|=
name|fd_open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|F_WRITE
operator||
name|F_LOCK
argument_list|,
literal|1
argument_list|,
name|ttbuf
argument_list|,
name|BufSize
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

