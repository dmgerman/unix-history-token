begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_comment
comment|/* This creates/deletes/divides/grows/shrinks windows.  */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|onlyone
index|[]
init|=
literal|"You only have one window!"
decl_stmt|,
name|toosmall
index|[]
init|=
literal|"Resulting window would be too small."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
modifier|*
name|curwind
decl_stmt|,
modifier|*
name|fwind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line in a Window */
end_comment

begin_expr_stmt
name|FLine
argument_list|(
name|w
argument_list|)
specifier|register
name|Window
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Window
modifier|*
name|wp
init|=
name|fwind
decl_stmt|;
specifier|register
name|int
name|lineno
init|=
operator|-
literal|1
decl_stmt|;
do|do
block|{
if|if
condition|(
name|wp
operator|==
name|w
condition|)
return|return
name|lineno
operator|+
literal|1
return|;
name|lineno
operator|+=
name|wp
operator|->
name|w_height
expr_stmt|;
name|wp
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|wp
operator|!=
name|fwind
condition|)
do|;
name|complain
argument_list|(
literal|"window?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/* Delete `wp' from the screen.  If it is the only window left    on the screen, then complain.  It gives its body    to the next window if there is one, otherwise the previous    window gets the body.  */
end_comment

begin_expr_stmt
name|del_wind
argument_list|(
name|wp
argument_list|)
specifier|register
name|Window
operator|*
name|wp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Window
modifier|*
name|prev
init|=
name|wp
operator|->
name|w_prev
decl_stmt|;
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|wp
operator|->
name|w_prev
operator|->
name|w_next
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
name|wp
operator|->
name|w_next
operator|->
name|w_prev
operator|=
name|wp
operator|->
name|w_prev
expr_stmt|;
if|if
condition|(
name|fwind
operator|==
name|wp
condition|)
block|{
name|fwind
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
name|fwind
operator|->
name|w_height
operator|+=
name|wp
operator|->
name|w_height
expr_stmt|;
comment|/* Here try to do something intelligent for redisplay() */
name|SetTop
argument_list|(
name|fwind
argument_list|,
name|prev_line
argument_list|(
name|fwind
operator|->
name|w_top
argument_list|,
name|wp
operator|->
name|w_height
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curwind
operator|==
name|wp
condition|)
name|SetWind
argument_list|(
name|fwind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|w_height
operator|+=
name|wp
operator|->
name|w_height
expr_stmt|;
if|if
condition|(
name|curwind
operator|==
name|wp
condition|)
name|SetWind
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Divide the window WP N times, or at least once.  Complains if WP is too    small to be split into that many pieces.  It returns the new window. */
end_comment

begin_function
name|Window
modifier|*
name|div_wind
parameter_list|(
name|wp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|Window
modifier|*
name|wp
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|new
decl_stmt|;
name|int
name|amt
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|amt
operator|=
name|wp
operator|->
name|w_height
operator|/
operator|(
name|n
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|amt
operator|<
literal|2
condition|)
name|complain
argument_list|(
name|toosmall
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|new
operator|=
operator|(
name|Window
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Window
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|w_visspace
operator|=
name|new
operator|->
name|w_numlines
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|w_height
operator|=
name|amt
expr_stmt|;
name|wp
operator|->
name|w_height
operator|-=
name|amt
expr_stmt|;
comment|/* set the lines such that w_line is the center in 		   each Window */
name|new
operator|->
name|w_line
operator|=
name|wp
operator|->
name|w_line
expr_stmt|;
name|new
operator|->
name|w_char
operator|=
name|wp
operator|->
name|w_char
expr_stmt|;
name|new
operator|->
name|w_bufp
operator|=
name|wp
operator|->
name|w_bufp
expr_stmt|;
name|new
operator|->
name|w_top
operator|=
name|prev_line
argument_list|(
name|new
operator|->
name|w_line
argument_list|,
name|HALF
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Link the new window into the list */
name|new
operator|->
name|w_prev
operator|=
name|wp
expr_stmt|;
name|new
operator|->
name|w_next
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
name|new
operator|->
name|w_next
operator|->
name|w_prev
operator|=
name|new
expr_stmt|;
name|wp
operator|->
name|w_next
operator|=
name|new
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Initialze the first window setting the bounds to the size of the    screen.  There is no buffer with this window.  See parse for the    setting of this window. */
end_comment

begin_macro
name|winit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
name|w
operator|=
name|curwind
operator|=
name|fwind
operator|=
operator|(
name|Window
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Window
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_line
operator|=
name|w
operator|->
name|w_top
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_visspace
operator|=
name|w
operator|->
name|w_numlines
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_char
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_next
operator|=
name|w
operator|->
name|w_prev
operator|=
name|fwind
expr_stmt|;
name|w
operator|->
name|w_height
operator|=
name|ILI
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Change to previous window. */
end_comment

begin_macro
name|PrevWindow
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Window
modifier|*
name|new
init|=
name|curwind
operator|->
name|w_prev
decl_stmt|;
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make NEW the current Window */
end_comment

begin_expr_stmt
name|SetWind
argument_list|(
name|new
argument_list|)
specifier|register
name|Window
operator|*
name|new
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|Asking
condition|)
block|{
comment|/* can you say kludge? */
name|curwind
operator|->
name|w_line
operator|=
name|curline
expr_stmt|;
name|curwind
operator|->
name|w_char
operator|=
name|curchar
expr_stmt|;
name|curwind
operator|->
name|w_bufp
operator|=
name|curbuf
expr_stmt|;
block|}
if|if
condition|(
name|new
operator|==
name|curwind
condition|)
return|return;
name|SetBuf
argument_list|(
name|new
operator|->
name|w_bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inlist
argument_list|(
name|new
operator|->
name|w_bufp
operator|->
name|b_first
argument_list|,
name|new
operator|->
name|w_line
argument_list|)
condition|)
block|{
name|new
operator|->
name|w_line
operator|=
name|curline
expr_stmt|;
name|new
operator|->
name|w_char
operator|=
name|curchar
expr_stmt|;
block|}
name|DotTo
argument_list|(
name|new
operator|->
name|w_line
argument_list|,
name|new
operator|->
name|w_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
operator|>
name|strlen
argument_list|(
name|linebuf
argument_list|)
condition|)
name|new
operator|->
name|w_char
operator|=
name|curchar
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|curwind
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Delete the current window if it isn't the only one left */
end_comment

begin_macro
name|DelCurWindow
argument_list|()
end_macro

begin_block
block|{
name|del_wind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Put the current line of `w' in the middle of the window */
end_comment

begin_expr_stmt
name|CentWind
argument_list|(
name|w
argument_list|)
specifier|register
name|Window
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|SetTop
argument_list|(
name|w
argument_list|,
name|prev_line
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
name|HALF
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|ScrollStep
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Full scrolling */
end_comment

begin_comment
comment|/* Calculate the new topline of the screen.  If ScrollStep == 0    it means we should center the current line in the window. */
end_comment

begin_expr_stmt
name|CalcWind
argument_list|(
name|w
argument_list|)
specifier|register
name|Window
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|up
decl_stmt|;
name|Line
modifier|*
name|newtop
decl_stmt|;
if|if
condition|(
name|ScrollStep
operator|==
literal|0
condition|)
comment|/* Means just center it */
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
block|{
name|up
operator|=
name|inorder
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
literal|0
argument_list|,
name|w
operator|->
name|w_top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|==
operator|-
literal|1
condition|)
block|{
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|up
condition|)
comment|/* Dot is above the screen */
name|newtop
operator|=
name|prev_line
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
name|min
argument_list|(
name|ScrollStep
operator|-
literal|1
argument_list|,
name|HALF
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|newtop
operator|=
name|prev_line
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
operator|(
name|SIZE
argument_list|(
name|w
argument_list|)
operator|-
literal|1
operator|)
operator|-
name|min
argument_list|(
name|ScrollStep
operator|-
literal|1
argument_list|,
name|HALF
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LineDist
argument_list|(
name|newtop
argument_list|,
name|w
operator|->
name|w_top
argument_list|)
operator|>=
name|SIZE
argument_list|(
name|w
argument_list|)
operator|-
literal|1
condition|)
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|SetTop
argument_list|(
name|w
argument_list|,
name|newtop
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|WindFind
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Buffer
modifier|*
name|savebuf
init|=
name|curbuf
decl_stmt|;
name|Bufpos
name|savedot
decl_stmt|;
specifier|extern
name|int
name|FindTag
argument_list|()
decl_stmt|,
name|BufSelect
argument_list|()
decl_stmt|,
name|FindFile
argument_list|()
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|waitchar
argument_list|()
condition|)
block|{
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|FindCmd
argument_list|(
name|FindTag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|FindCmd
argument_list|(
name|BufSelect
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|FindCmd
argument_list|(
name|FindFile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
literal|"T: find-tag, F: find-file, B: select-buffer."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|one_windp
argument_list|()
condition|)
operator|(
name|void
operator|)
name|div_wind
argument_list|(
name|curwind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tiewind
argument_list|(
name|curwind
operator|->
name|w_next
argument_list|,
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|savebuf
argument_list|)
expr_stmt|;
comment|/* Back to original buffer */
name|SetDot
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
comment|/* in original position */
name|tiewind
argument_list|(
name|curwind
argument_list|,
name|curbuf
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|curwind
operator|->
name|w_next
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Go into one window mode by deleting all the other windows */
end_comment

begin_macro
name|OneWindow
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|curwind
operator|->
name|w_next
operator|!=
name|curwind
condition|)
name|del_wind
argument_list|(
name|curwind
operator|->
name|w_next
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Window
modifier|*
name|windbp
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|wp
init|=
name|fwind
decl_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
do|do
block|{
if|if
condition|(
name|wp
operator|->
name|w_bufp
operator|==
name|bp
condition|)
return|return
name|wp
return|;
name|wp
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|wp
operator|!=
name|fwind
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for a window containing a buffer whose name is `name' */
end_comment

begin_function
name|Window
modifier|*
name|windlook
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|windbp
argument_list|(
name|buf_exists
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Change window into the next window.  Curwind becomes the new window. */
end_comment

begin_macro
name|NextWindow
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Window
modifier|*
name|new
init|=
name|curwind
operator|->
name|w_next
decl_stmt|;
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Scroll the next Window */
end_comment

begin_macro
name|PageNWind
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|NextWindow
argument_list|()
expr_stmt|;
name|NextPage
argument_list|()
expr_stmt|;
name|PrevWindow
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|Window
modifier|*
name|w_nam_typ
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf_exists
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|w
operator|=
name|fwind
expr_stmt|;
if|if
condition|(
name|b
condition|)
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_bufp
operator|==
name|b
condition|)
return|return
name|w
return|;
block|}
do|while
condition|(
operator|(
name|w
operator|=
name|w
operator|->
name|w_next
operator|)
operator|!=
name|fwind
condition|)
do|;
name|w
operator|=
name|fwind
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_bufp
operator|->
name|b_type
operator|==
name|type
condition|)
return|return
name|w
return|;
block|}
do|while
condition|(
operator|(
name|w
operator|=
name|w
operator|->
name|w_next
operator|)
operator|!=
name|fwind
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Put a window with the buffer `name' in it.  Erase the buffer if    `clobber' is non-zero. */
end_comment

begin_expr_stmt
name|pop_wind
argument_list|(
name|name
argument_list|,
name|clobber
argument_list|,
name|btype
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Window
modifier|*
name|wp
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|newb
decl_stmt|;
if|if
condition|(
operator|(
name|wp
operator|=
name|w_nam_typ
argument_list|(
name|name
argument_list|,
name|btype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|SetWind
argument_list|(
name|div_wind
argument_list|(
name|curwind
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PrevWindow
argument_list|()
expr_stmt|;
block|}
else|else
name|SetWind
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|newb
operator|=
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber
condition|)
name|initlist
argument_list|(
name|newb
argument_list|)
expr_stmt|;
name|tiewind
argument_list|(
name|curwind
argument_list|,
name|newb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
if|if
condition|(
name|newb
operator|->
name|b_type
operator|!=
name|B_IPROCESS
operator|&&
name|btype
operator|!=
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|btype
operator|!=
operator|-
literal|1
condition|)
endif|#
directive|endif
name|newb
operator|->
name|b_type
operator|=
name|btype
expr_stmt|;
name|SetBuf
argument_list|(
name|newb
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|GrowWindow
argument_list|()
end_macro

begin_block
block|{
name|WindSize
argument_list|(
name|curwind
argument_list|,
name|abs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ShrWindow
argument_list|()
end_macro

begin_block
block|{
name|WindSize
argument_list|(
name|curwind
argument_list|,
operator|-
name|abs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Change the size of the window by inc.  First arg is the window,    second is the increment. */
end_comment

begin_expr_stmt
name|WindSize
argument_list|(
name|w
argument_list|,
name|inc
argument_list|)
specifier|register
name|Window
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|inc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|inc
operator|<
literal|0
condition|)
block|{
comment|/* Shrinking this Window. */
if|if
condition|(
name|w
operator|->
name|w_height
operator|+
name|inc
operator|<
literal|2
condition|)
name|complain
argument_list|(
name|toosmall
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_height
operator|+=
name|inc
expr_stmt|;
name|w
operator|->
name|w_prev
operator|->
name|w_height
operator|-=
name|inc
expr_stmt|;
block|}
else|else
comment|/* Growing the window. */
name|WindSize
argument_list|(
name|w
operator|->
name|w_next
argument_list|,
operator|-
name|inc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Set the topline of the window, calculating its number in the buffer.    This is for numbering the lines only. */
end_comment

begin_macro
name|SetTop
argument_list|(
argument|w
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|Window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Line
modifier|*
name|lp
init|=
name|w
operator|->
name|w_bufp
operator|->
name|b_first
decl_stmt|;
specifier|register
name|int
name|num
init|=
literal|0
decl_stmt|;
name|w
operator|->
name|w_top
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_numlines
condition|)
block|{
while|while
condition|(
name|lp
condition|)
block|{
name|num
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|lp
condition|)
break|break;
name|lp
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
block|}
name|w
operator|->
name|w_topnum
operator|=
name|num
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|WNumLines
argument_list|()
end_macro

begin_block
block|{
name|curwind
operator|->
name|w_numlines
operator|=
operator|!
name|curwind
operator|->
name|w_numlines
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_top
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|WVisSpace
argument_list|()
end_macro

begin_block
block|{
name|curwind
operator|->
name|w_visspace
operator|=
operator|!
name|curwind
operator|->
name|w_visspace
expr_stmt|;
name|ClAndRedraw
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the line number that `line' occupies in `windes' */
end_comment

begin_expr_stmt
name|in_window
argument_list|(
name|windes
argument_list|,
name|line
argument_list|)
specifier|register
name|Window
operator|*
name|windes
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Line
modifier|*
name|top
init|=
name|windes
operator|->
name|w_top
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|top
operator|&&
name|i
operator|<
name|windes
operator|->
name|w_height
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|top
operator|=
name|top
operator|->
name|l_next
control|)
if|if
condition|(
name|top
operator|==
name|line
condition|)
return|return
name|FLine
argument_list|(
name|windes
argument_list|)
operator|+
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|SplitWind
argument_list|()
end_macro

begin_block
block|{
name|SetWind
argument_list|(
name|div_wind
argument_list|(
name|curwind
argument_list|,
name|exp_p
condition|?
operator|(
name|exp
operator|-
literal|1
operator|)
else|:
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

