begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*************************************************************************  * This program is copyright (C) 1985, 1986 by Jonathan Payne.  It is    *  * provided to you without charge for use only on a licensed Unix        *  * system.  You may copy JOVE provided that this notice is included with *  * the copy.  You may not sell copies of this program or versions        *  * modified for use on microcomputer systems, unless the copies are      *  * included with a Unix system distribution and the source is provided.  *  *************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|private
name|char
modifier|*
name|errfmt
init|=
literal|"^\\{\",\\}\\([^:\"( \t]*\\)\\{\"\\, line ,:,(\\} *\\([0-9][0-9]*\\)[:)]"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|error
block|{
name|Buffer
modifier|*
name|er_buf
decl_stmt|;
comment|/* Buffer error is in */
name|Line
modifier|*
name|er_mess
decl_stmt|,
comment|/* Actual error message */
modifier|*
name|er_text
decl_stmt|;
comment|/* Actual error */
name|int
name|er_char
decl_stmt|;
comment|/* char pos of error */
name|struct
name|error
modifier|*
name|er_prev
decl_stmt|,
comment|/* List of errors */
modifier|*
name|er_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|error
modifier|*
name|cur_error
init|=
literal|0
decl_stmt|,
modifier|*
name|errorlist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|perr_buf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer with error messages */
end_comment

begin_decl_stmt
name|int
name|WtOnMk
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write the modified files when we make */
end_comment

begin_comment
comment|/* Add an error to the end of the list of errors.  This is used for    parse-{C,LINT}-errors and for the spell-buffer command */
end_comment

begin_decl_stmt
name|private
name|struct
name|error
modifier|*
name|AddError
argument_list|(
name|laste
argument_list|,
name|errline
argument_list|,
name|buf
argument_list|,
name|line
argument_list|,
name|charpos
argument_list|)
decl|struct
name|error
modifier|*
name|laste
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Line
modifier|*
name|errline
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|error
modifier|*
name|new
init|=
operator|(
expr|struct
name|error
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
decl_stmt|;
name|new
operator|->
name|er_prev
operator|=
name|laste
expr_stmt|;
if|if
condition|(
name|laste
condition|)
name|laste
operator|->
name|er_next
operator|=
name|new
expr_stmt|;
else|else
block|{
if|if
condition|(
name|errorlist
condition|)
comment|/* Free up old errors */
name|ErrFree
argument_list|()
expr_stmt|;
name|cur_error
operator|=
name|errorlist
operator|=
name|new
expr_stmt|;
block|}
name|laste
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|er_next
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|er_buf
operator|=
name|buf
expr_stmt|;
name|new
operator|->
name|er_text
operator|=
name|line
expr_stmt|;
name|new
operator|->
name|er_char
operator|=
name|charpos
expr_stmt|;
name|new
operator|->
name|er_mess
operator|=
name|errline
expr_stmt|;
return|return
name|new
return|;
block|}
end_block

begin_macro
name|ParseAll
argument_list|()
end_macro

begin_block
block|{
name|ErrParse
argument_list|(
name|errfmt
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|XParse
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|sstr
decl_stmt|;
name|sstr
operator|=
name|ask
argument_list|(
name|errfmt
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
name|ErrParse
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Parse for {C,LINT} errors (or anything that matches fmtstr) in the    current buffer.  Set up for the next-error command.  This is neat    because this will work for any kind of output that prints a file    name and a line number on the same line. */
end_comment

begin_macro
name|ErrParse
argument_list|(
argument|fmtstr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmtstr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|char
name|fname
index|[
name|FILESIZE
index|]
decl_stmt|,
name|lineno
index|[
literal|10
index|]
decl_stmt|,
name|REbuf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|REalts
index|[
literal|10
index|]
decl_stmt|;
name|int
name|lnum
decl_stmt|,
name|last_lnum
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|error
modifier|*
name|ep
init|=
literal|0
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lastb
init|=
literal|0
decl_stmt|;
name|Line
modifier|*
name|err_line
decl_stmt|;
name|ErrFree
argument_list|()
expr_stmt|;
comment|/* This is important! */
name|ToFirst
argument_list|()
expr_stmt|;
name|perr_buf
operator|=
name|curbuf
expr_stmt|;
name|REcompile
argument_list|(
name|fmtstr
argument_list|,
literal|1
argument_list|,
name|REbuf
argument_list|,
name|REalts
argument_list|)
expr_stmt|;
comment|/* Find a line with a number on it. */
while|while
condition|(
name|bp
operator|=
name|docompiled
argument_list|(
name|FORWARD
argument_list|,
name|REbuf
argument_list|,
name|REalts
argument_list|)
condition|)
block|{
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|1
argument_list|,
name|fname
argument_list|,
sizeof|sizeof
name|fname
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|2
argument_list|,
name|lineno
argument_list|,
sizeof|sizeof
name|lineno
argument_list|)
expr_stmt|;
name|buf
operator|=
name|do_find
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
name|fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|lastb
condition|)
block|{
name|lastb
operator|=
name|buf
expr_stmt|;
name|last_lnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* signals new file */
name|err_line
operator|=
name|buf
operator|->
name|b_first
expr_stmt|;
block|}
name|lnum
operator|=
name|chr_to_int
argument_list|(
name|lineno
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnum
operator|==
name|last_lnum
condition|)
comment|/* one error per line is nicer */
continue|continue;
if|if
condition|(
name|last_lnum
operator|==
operator|-
literal|1
condition|)
name|last_lnum
operator|=
literal|1
expr_stmt|;
comment|/* that's where we really are */
name|err_line
operator|=
name|next_line
argument_list|(
name|err_line
argument_list|,
name|lnum
operator|-
name|last_lnum
argument_list|)
expr_stmt|;
name|ep
operator|=
name|AddError
argument_list|(
name|ep
argument_list|,
name|curline
argument_list|,
name|buf
argument_list|,
name|err_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_lnum
operator|=
name|lnum
expr_stmt|;
block|}
if|if
condition|(
name|cur_error
operator|!=
literal|0
condition|)
name|ShowErr
argument_list|()
expr_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free up all the errors */
end_comment

begin_macro
name|ErrFree
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|error
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|errorlist
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|er_next
control|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|)
expr_stmt|;
name|errorlist
operator|=
name|cur_error
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Internal next error sets cur_error to the next error, taking the    argument count, supplied by the user, into consideration. */
end_comment

begin_decl_stmt
name|private
name|char
name|errbounds
index|[]
init|=
literal|"You're at the %s error."
decl_stmt|,
name|noerrs
index|[]
init|=
literal|"No errors!"
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|toerror
parameter_list|(
name|forward
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|error
modifier|*
name|e
init|=
name|cur_error
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
name|complain
argument_list|(
name|noerrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|forward
operator|&&
operator|(
name|e
operator|->
name|er_next
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|!
name|forward
operator|&&
operator|(
name|e
operator|->
name|er_prev
operator|==
literal|0
operator|)
operator|)
condition|)
name|complain
argument_list|(
name|errbounds
argument_list|,
name|forward
condition|?
literal|"last"
else|:
literal|"first"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|forward
condition|?
name|e
operator|->
name|er_next
else|:
name|e
operator|->
name|er_prev
operator|)
operator|==
literal|0
condition|)
break|break;
name|cur_error
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|NextError
argument_list|()
end_macro

begin_block
block|{
name|ToError
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PrevError
argument_list|()
end_macro

begin_block
block|{
name|ToError
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|okay_error
parameter_list|()
block|{
return|return
operator|(
operator|(
name|inlist
argument_list|(
name|perr_buf
operator|->
name|b_first
argument_list|,
name|cur_error
operator|->
name|er_mess
argument_list|)
operator|)
operator|&&
operator|(
name|inlist
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_first
argument_list|,
name|cur_error
operator|->
name|er_text
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Go the the next error, if there is one.  Put the error buffer in    one window and the buffer with the error in another window.    It checks to make sure that the error actually exists. */
end_comment

begin_macro
name|ToError
argument_list|(
argument|forward
argument_list|)
end_macro

begin_block
block|{
do|do
block|{
name|toerror
argument_list|(
name|forward
argument_list|)
expr_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|okay_error
argument_list|()
condition|)
do|;
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|EWSize
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* percentage of screen the error window 			   should be */
end_comment

begin_comment
comment|/* Show the current error, i.e. put the line containing the error message    in one window, and the buffer containing the actual error in another    window. */
end_comment

begin_macro
name|ShowErr
argument_list|()
end_macro

begin_block
block|{
name|Window
modifier|*
name|err_wind
decl_stmt|,
modifier|*
name|buf_wind
decl_stmt|;
name|int
name|w_size
decl_stmt|;
comment|/* size of window */
if|if
condition|(
name|cur_error
operator|==
literal|0
condition|)
name|complain
argument_list|(
name|noerrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|okay_error
argument_list|()
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|err_wind
operator|=
name|windbp
argument_list|(
name|perr_buf
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|windbp
argument_list|(
name|cur_error
operator|->
name|er_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_wind
operator|&&
operator|!
name|buf_wind
condition|)
block|{
name|SetWind
argument_list|(
name|err_wind
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_name
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|curwind
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|err_wind
operator|&&
name|buf_wind
condition|)
block|{
name|SetWind
argument_list|(
name|buf_wind
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|perr_buf
operator|->
name|b_name
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err_wind
operator|=
name|curwind
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|err_wind
operator|&&
operator|!
name|buf_wind
condition|)
block|{
name|pop_wind
argument_list|(
name|perr_buf
operator|->
name|b_name
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err_wind
operator|=
name|curwind
expr_stmt|;
name|pop_wind
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_name
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|curwind
expr_stmt|;
block|}
comment|/* Put the current error message at the top of its Window */
name|SetWind
argument_list|(
name|err_wind
argument_list|)
expr_stmt|;
name|SetLine
argument_list|(
name|cur_error
operator|->
name|er_mess
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
operator|(
name|curwind
operator|->
name|w_line
operator|=
name|cur_error
operator|->
name|er_mess
operator|)
argument_list|)
expr_stmt|;
name|w_size
operator|=
operator|(
name|ILI
operator|*
name|EWSize
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|w_size
operator|>=
literal|1
condition|)
name|WindSize
argument_list|(
name|curwind
argument_list|,
name|w_size
operator|-
operator|(
name|curwind
operator|->
name|w_height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* now go to the the line with the error in the other window */
name|SetWind
argument_list|(
name|buf_wind
argument_list|)
expr_stmt|;
name|DotTo
argument_list|(
name|cur_error
operator|->
name|er_text
argument_list|,
name|cur_error
operator|->
name|er_char
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|ShcomBuf
index|[
literal|128
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a buffer name given the command `command', i.e. "fgrep -n foo *.c"    will return the buffer name "fgrep".  */
end_comment

begin_function
name|char
modifier|*
name|MakeName
parameter_list|(
name|command
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
block|{
specifier|static
name|char
name|bufname
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|bufname
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|command
operator|++
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
do|do
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|command
operator|++
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
condition|)
do|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|bufname
argument_list|,
name|basename
argument_list|(
name|bufname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bufname
return|;
block|}
end_function

begin_comment
comment|/* Run make, first writing all the modified buffers (if the WtOnMk flag is    non-zero), parse the errors, and go the first error. */
end_comment

begin_decl_stmt
name|char
name|make_cmd
index|[
literal|128
index|]
init|=
literal|"make"
decl_stmt|;
end_decl_stmt

begin_macro
name|MakeErrors
argument_list|()
end_macro

begin_block
block|{
name|Window
modifier|*
name|old
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|,
name|compilation
decl_stmt|;
if|if
condition|(
name|WtOnMk
condition|)
name|put_bufs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* When we're not doing make or cc (i.e., the last command 	   was probably a grep or something) and the user just types 	   C-X C-E, he probably (possibly, hopefully, usually (in my 	   case)) doesn't want to do the grep again but rather wants 	   to do a make again; so we ring the bell and insert the 	   default command and let the person decide. */
name|compilation
operator|=
operator|(
name|sindex
argument_list|(
literal|"make"
argument_list|,
name|make_cmd
argument_list|)
operator|||
name|sindex
argument_list|(
literal|"cc"
argument_list|,
name|make_cmd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|exp_p
operator|||
operator|!
name|compilation
condition|)
block|{
if|if
condition|(
operator|!
name|compilation
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|Inputp
operator|=
name|make_cmd
expr_stmt|;
comment|/* insert the default for the 						   user */
block|}
name|null_ncpy
argument_list|(
name|make_cmd
argument_list|,
name|ask
argument_list|(
name|make_cmd
argument_list|,
literal|"Compilation command: "
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|make_cmd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|UnixToBuf
argument_list|(
name|MakeName
argument_list|(
name|make_cmd
argument_list|)
argument_list|,
name|YES
argument_list|,
name|EWSize
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|basename
argument_list|(
name|Shell
argument_list|)
argument_list|,
name|ShFlags
argument_list|,
name|make_cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|make_cmd
argument_list|)
expr_stmt|;
name|ErrParse
argument_list|(
name|errfmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_error
condition|)
name|SetWind
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SPELL
end_ifdef

begin_macro
name|SpelBuffer
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|Spell
init|=
literal|"Spell"
decl_stmt|,
name|com
index|[
literal|100
index|]
decl_stmt|;
name|Window
modifier|*
name|savewp
init|=
name|curwind
decl_stmt|;
name|put_bufs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|com
argument_list|,
literal|"spell %s"
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|UnixToBuf
argument_list|(
name|Spell
argument_list|,
name|YES
argument_list|,
name|EWSize
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|basename
argument_list|(
name|Shell
argument_list|)
argument_list|,
name|ShFlags
argument_list|,
name|com
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"[Delete the irrelevant words and then type C-X C-C]"
argument_list|)
expr_stmt|;
name|Recur
argument_list|()
expr_stmt|;
name|SetWind
argument_list|(
name|savewp
argument_list|)
expr_stmt|;
name|SpelParse
argument_list|(
name|Spell
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SpelWords
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|buftospel
decl_stmt|;
name|Buffer
modifier|*
name|wordsb
init|=
name|curbuf
decl_stmt|;
if|if
condition|(
operator|(
name|buftospel
operator|=
name|ask_buf
argument_list|(
operator|(
name|Buffer
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|buftospel
argument_list|)
argument_list|)
expr_stmt|;
name|SpelParse
argument_list|(
name|wordsb
operator|->
name|b_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SpelParse
argument_list|(
argument|bname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Buffer
modifier|*
name|buftospel
decl_stmt|,
modifier|*
name|wordsb
decl_stmt|;
name|char
name|wordspel
index|[
literal|100
index|]
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|struct
name|error
modifier|*
name|ep
init|=
literal|0
decl_stmt|;
name|ErrFree
argument_list|()
expr_stmt|;
comment|/* This is important! */
name|buftospel
operator|=
name|curbuf
expr_stmt|;
name|wordsb
operator|=
name|buf_exists
argument_list|(
name|bname
argument_list|)
expr_stmt|;
name|perr_buf
operator|=
name|wordsb
expr_stmt|;
comment|/* This is important (buffer containing 				   error messages) */
name|SetBuf
argument_list|(
name|wordsb
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
name|f_mess
argument_list|(
literal|"Finding misspelled words ... "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|wordspel
argument_list|,
literal|"\\<%s\\>"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|buftospel
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
while|while
condition|(
name|bp
operator|=
name|dosearch
argument_list|(
name|wordspel
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ep
operator|=
name|AddError
argument_list|(
name|ep
argument_list|,
name|wordsb
operator|->
name|b_dot
argument_list|,
name|buftospel
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
name|SetBuf
argument_list|(
name|wordsb
argument_list|)
expr_stmt|;
name|line_move
argument_list|(
name|FORWARD
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|add_mess
argument_list|(
literal|"Done."
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|buftospel
argument_list|)
expr_stmt|;
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|SPELL
end_endif

begin_macro
name|ShToBuf
argument_list|()
end_macro

begin_block
block|{
name|char
name|bufname
index|[
literal|100
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|bufname
argument_list|,
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"Buffer: "
argument_list|)
argument_list|)
expr_stmt|;
name|DoShell
argument_list|(
name|bufname
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
literal|"Command: "
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ShellCom
argument_list|()
end_macro

begin_block
block|{
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DoShell
argument_list|(
name|MakeName
argument_list|(
name|ShcomBuf
argument_list|)
argument_list|,
name|ShcomBuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Run the shell command into `bufname'.  Empty the buffer except when we    give a numeric argument, in which case it inserts the output at the    current position in the buffer.  */
end_comment

begin_function
name|private
name|DoShell
parameter_list|(
name|bufname
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|bufname
decl_stmt|,
decl|*
name|command
decl_stmt|;
end_function

begin_block
block|{
name|Window
modifier|*
name|savewp
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|;
name|exp
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
name|bufname
argument_list|,
name|YES
argument_list|,
literal|0
argument_list|,
operator|!
name|exp_p
argument_list|,
name|Shell
argument_list|,
name|basename
argument_list|(
name|Shell
argument_list|)
argument_list|,
name|ShFlags
argument_list|,
name|command
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|savewp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|com_finish
parameter_list|(
name|status
parameter_list|,
name|com
parameter_list|)
name|char
modifier|*
name|com
decl_stmt|;
block|{
name|s_mess
argument_list|(
literal|"\"%s\" completed %ssuccessfully."
argument_list|,
name|com
argument_list|,
name|status
condition|?
literal|"un"
else|:
name|NullStr
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|dowait
argument_list|(
argument|pid
argument_list|,
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|,
modifier|*
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|IPROCS
name|int
name|rpid
decl_stmt|;
while|while
condition|(
operator|(
name|rpid
operator|=
name|wait
argument_list|(
name|status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
empty_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD4_2
include|#
directive|include
file|<sys/wait.h>
else|#
directive|else
include|#
directive|include
file|<wait.h>
endif|#
directive|endif
name|union
name|wait
name|w
decl_stmt|;
name|int
name|rpid
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|VMUNIX
name|rpid
operator|=
name|wait2
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|rpid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rpid
operator|==
name|pid
condition|)
block|{
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|w
operator|.
name|w_status
expr_stmt|;
break|break;
block|}
else|else
name|kill_off
argument_list|(
name|rpid
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|IPROCS
block|}
end_block

begin_comment
comment|/* Run the command to bufname, erase the buffer if clobber is non-zero,    and redisplay if disp is non-zero.  Leaves current buffer in `bufname'    and leaves any windows it creates lying around.  It's up to the caller    to fix everything up after we're done.  (Usually there's nothing to    fix up.) */
end_comment

begin_comment
comment|/* VARARGS3 */
end_comment

begin_macro
name|UnixToBuf
argument_list|(
argument|bufname
argument_list|,
argument|disp
argument_list|,
argument|wsize
argument_list|,
argument|clobber
argument_list|,
argument|cmd
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bufname
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|,
name|pid
decl_stmt|;
specifier|extern
name|int
name|ninbuf
decl_stmt|;
name|Buffer
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|clobber
operator|&&
operator|(
name|bp
operator|=
name|buf_exists
argument_list|(
name|bufname
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|bp
operator|->
name|b_type
operator|!=
name|B_PROCESS
operator|&&
name|bp
operator|->
name|b_type
operator|!=
name|B_IPROCESS
condition|)
name|complain
argument_list|(
literal|"Command would over-write buffer %s."
argument_list|,
name|bufname
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
name|message
argument_list|(
literal|"Starting up..."
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|bufname
argument_list|,
name|clobber
argument_list|,
name|clobber
condition|?
name|B_PROCESS
else|:
name|B_FILE
argument_list|)
expr_stmt|;
name|wsize
operator|=
operator|(
name|LI
operator|*
name|wsize
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|wsize
operator|>=
literal|1
operator|&&
operator|!
name|one_windp
argument_list|()
condition|)
name|WindSize
argument_list|(
name|curwind
argument_list|,
name|wsize
operator|-
operator|(
name|curwind
operator|->
name|w_height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
name|exp
operator|=
literal|1
expr_stmt|;
name|dopipe
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[Fork failed]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"Execl failed.\n"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|status
decl_stmt|;
name|int
function_decl|(
modifier|*
name|oldint
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
name|char
modifier|*
name|mess
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fd_open
argument_list|(
name|cmd
argument_list|,
name|F_READ
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|iobuff
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|inIOread
operator|=
literal|1
operator|,
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
name|LBSIZE
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|inIOread
operator|=
literal|0
expr_stmt|;
name|ins_str
argument_list|(
name|genbuf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|LineInsert
argument_list|()
expr_stmt|;
if|if
condition|(
name|disp
operator|!=
literal|0
operator|&&
name|fp
operator|->
name|f_cnt
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_AV
block|{
name|double
name|theavg
decl_stmt|;
name|get_la
argument_list|(
operator|&
name|theavg
argument_list|)
expr_stmt|;
if|if
condition|(
name|theavg
operator|<
literal|2.0
condition|)
name|mess
operator|=
literal|"Screaming along..."
expr_stmt|;
elseif|else
if|if
condition|(
name|theavg
operator|<
literal|5.0
condition|)
name|mess
operator|=
literal|"Chugging along..."
expr_stmt|;
else|else
name|mess
operator|=
literal|"Crawling along..."
expr_stmt|;
block|}
else|#
directive|else
name|mess
operator|=
literal|"Chugging along..."
expr_stmt|;
endif|#
directive|endif
endif|LOAD_AV
name|message
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|disp
condition|)
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldint
argument_list|)
expr_stmt|;
name|dowait
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|status
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_decl_stmt
name|private
name|int
name|SigMask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|sighold
argument_list|(
argument|sig
argument_list|)
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|SigMask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|sig
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sigrelse
argument_list|(
argument|sig
argument_list|)
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|SigMask
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|sig
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|FilterRegion
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|cmd
init|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|": %f (through command) "
argument_list|,
name|ProcFmt
argument_list|)
decl_stmt|;
name|RegToUnix
argument_list|(
name|curbuf
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Send the current region to CMD and insert the output from the    command into OUT_BUF. */
end_comment

begin_macro
name|RegToUnix
argument_list|(
argument|outbuf
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|Buffer
modifier|*
name|outbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Mark
modifier|*
name|m
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|mktemp
argument_list|(
literal|"/tmp/jfilterXXXXXX"
argument_list|)
decl_stmt|,
name|combuf
index|[
literal|130
index|]
decl_stmt|;
name|Window
modifier|*
name|save_wind
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|CATCH
name|fp
init|=
name|open_file
argument_list|(
name|tname
argument_list|,
name|iobuff
argument_list|,
name|F_WRITE
argument_list|,
name|COMPLAIN
argument_list|,
name|QUIET
argument_list|)
decl_stmt|;
name|putreg
argument_list|(
name|fp
argument_list|,
name|m
operator|->
name|m_line
argument_list|,
name|m
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|DelReg
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|combuf
argument_list|,
literal|"%s< %s"
argument_list|,
name|cmd
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
name|outbuf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
literal|0
argument_list|,
name|outbuf
operator|->
name|b_type
operator|==
name|B_SCRATCH
argument_list|,
name|Shell
argument_list|,
name|basename
argument_list|(
name|Shell
argument_list|)
argument_list|,
name|ShFlags
argument_list|,
name|combuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ONERROR
expr_stmt|;
comment|/* Do nothing ... but fall through and delete the tmp 		   file. */
name|ENDCATCH
name|f_close
parameter_list|(
name|fp
parameter_list|)
function_decl|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|save_wind
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|combuf
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

