begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      enet.c	Stanford	25 April 1983 */
end_comment

begin_comment
comment|/*  *  Ethernet packet filter layer,  *  	formerly: Ethernet interface driver  *  **********************************************************************  * HISTORY  * 7 October 1985	Jeff Mogul	Stanford  *	Removed ENMAXOPENS limitation; available minors are now  *	dynamically allocated to interfaces, out of pool of NENETFILTER  *	minors.  *	Certain arrays formerly in the enState structure are now global.  *	Depends on modified openi() function so that enetopen() need  *	only be called once.  *	Remove support for "kernel access", it won't ever be used again.  *	Added EIOCMFREE ioctl.  *  * 17 October 1984	Jeff Mogul	Stanford  *    More performance improvements:  *	Added ENF_CAND, ENF_COR, ENF_CNAND, and ENF_CNOR, short-circuit  *	operators, to make filters run faster.  *	All evaluate "(*sp++ == *sp++)":  *	ENF_CAND: returns false immediately if result is false, otherwise  *		continue  *	ENF_COR: returns true immediately if result is true, otherwise  *		continue  *	ENF_CNAND: returns true immediately if result is false, otherwise  *		continue  *	ENF_CNOR: returns false immediately if result is true, otherwise  *		continue  *	Also added ENF_NEQ to complement ENF_EQ  *    - Maintain count of received packets per filter, dynamically  *	re-organize filter queue to keep highly active filters in  *	front of queue (but maintaining priority order), if they are  *	"high priority" filters.  *  * 2 October 1984	Jeff Mogul	Stanford  *	Made a few changes to enDoFilter() to speed it up, since profiling  *	shows it to be rather popular:  *	- precompute maximum word in packet and address of end of  *	filters (thereby moving this code out of "inner loop").  *	- minor re-arrangement to avoid re-evaluating a  *	common subexpression.  *	- changed #ifdef DEBUG in a few routines to #ifdef INNERDEBUG,  *	so that code in inner loops isn't always testing the enDebug  *	flag; this not only costs directly, but also breaks up some  *	basic blocks that the optimizer could play with.  *	- added enOneCopy flag; if true, then never deliver more than  *	one copy of a packet.  This is equivalent to giving everyone  *	a "high priority" device, and cuts down the number of superfluous  *	calls to enDoFilter(). [Temporary hack, will remove this!]  *  * 24 August 1984	Jeff Mogul	Stanford  *	YA bug with sleeping in enetwrite(); straightened out handling  *	of counts in enKludgeSleep so that they indicate the number  *	of sleeps in progress. Maybe I've got this right, now?  *	Also, don't sleep forever (since the net might be down).  *  * 17 July 1984	Jeff Mogul	Stanford  *	Bug fix: in enetwrite(), several problems with sleeping on  *	IF_QFULL:  *	- don't do it for kernel mode writes.  *	- count # of procs sleeping, to avoid lost wakeups.  Old  *		scheme would only wake up the first sleeper.  *	- using sleeper-count, avoid using more than one timeout  *		table entry per device; old scheme caused timeout table panics  *	- trap interupted sleeps using setjmp, so that we can deallocate  *		packet header and mbufs; otherwise we lost them and panicked.  *  * 5 July 1984	Jeff Mogul	Stanford  *	Bug fix: in enetwrite() make sure enP_RefCount is zero before  *	deallocating "packet".  Otherwise, "packets" get lost, and  *	take mbufs (and ultimately, the system) with them.  *  * 8 December 1983	Jeffrey Mogul	Stanford  *	Fixed bug in enetwrite() that eventually caused	allocator  *	to run out of packets and panic.  If enetwrite() returns  *	an error it should first deallocate any packets it has allocated.  *  * 10 November 1983	Jeffrey Mogul	Stanford  *	Slight restructuring for support of 10mb ethers;  *	- added the EIOCDEVP ioctl  *	- removed the EIOCMTU ioctl (subsumed by EIOCDEVP)  *	This requires an additional parameter to the enetattach  *	call so that the device driver can specify things.  *  *	Also, cleaned up the enDebug scheme by adding symbolic  *	definitions for the bits.  *  * 25-Apr-83	Jeffrey Mogul	Stanford  *	Began conversion to 4.2BSD.  This involves removing all  *		references to the actual hardware.  *	Changed read/write interface to use uio scheme.  *	Changed ioctl interface to "new style"; this places a hard  *		limit on the size of a filter (about 128 bytes).  *	"Packets" now point to mbufs, not private buffers.  *	Filter can only access data in first mbuf (about 50 words worst case);  *		this is long enough for all Pup purposes.  *	Added EIOCMTU ioctl to get MTU (max packet size).  *	Added an enetselect() routine and other select() support.  *	Other stuff is (more or less) left intact.  *	Most previous history comments removed.  *	Changed some names from enXXXX to enetXXXX to avoid confusion(?)  *  * 10-Aug-82  Mike Accetta (mja) at Carnegie-Mellon University  *	Added new EIOCMBIS and EIOCMBIC ioctl calls to set and clear  *	bits in mode word;  added mode bit ENHOLDSIG which suppresses  *	the resetting of an enabled signal after it is sent (to be  *	used inconjunction with the SIGHOLD mechanism);  changed  *	EIOCGETP to zero pad word for future compatibility;  changed enwrite()  *	to enforce correct source host address on output packets (V3.05e).  *	(Stanford already uses long timeout value and has no pad word - JCM)  *	[Last change before 4.2BSD conversion starts.]  *  * 01-Dec-81  Mike Accetta (mja) at Carnegie-Mellon University  *	Fixed bug in timeout handling caused by missing "break" in the  *	"switch" state check within enetread().  This caused all reads  *	to be preceeded by a bogus timeout.  In addition, fixed another  *	bug in signal processing by also recording process ID of  *	process to signal when an input packet is available.  This is  *	necessary because it is possible for a process with an enabled  *	signal to fork and exit with no guarantee that the child will  *	reenable the signal.  Thus under appropriately bizarre race  *	conditions, an incoming packet to the child can cause a signal  *	to be sent to the unsuspecting process which inherited the  *	process slot of the parent.  Of course, if the PID's wrap around  *	AND the inheriting process has the same PID, well ... (V3.03d).  *  * 22-Feb-80  Rick Rashid (rfr) at Carnegie-Mellon University  *	Rewritten to provide multiple user access via user settable  *	filters (V1.05).  *  * 18-Jan-80  Mike Accetta (mja) at Carnegie-Mellon University  *      Created (V1.00).  *  **********************************************************************  */
end_comment

begin_include
include|#
directive|include
file|"en.h"
end_include

begin_include
include|#
directive|include
file|"ec.h"
end_include

begin_include
include|#
directive|include
file|"il.h"
end_include

begin_include
include|#
directive|include
file|"de.h"
end_include

begin_include
include|#
directive|include
file|"enetfilter.h"
end_include

begin_comment
comment|/* number of potential units */
end_comment

begin_define
define|#
directive|define
name|NENET
value|(NEC + NEN + NIL + NDE)
end_define

begin_if
if|#
directive|if
operator|(
name|NENETFILTER
operator|>
literal|0
operator|)
end_if

begin_define
define|#
directive|define
name|SUN_OPENI
end_define

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"map.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"inode.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_undef
undef|#
directive|undef
name|queue
end_undef

begin_undef
undef|#
directive|undef
name|dequeue
end_undef

begin_include
include|#
directive|include
file|"../net/enet.h"
end_include

begin_include
include|#
directive|include
file|"../net/enetdefs.h"
end_include

begin_if
if|#
directive|if
operator|(
name|NENETFILTER
operator|<
literal|32
operator|)
end_if

begin_undef
undef|#
directive|undef
name|NENETFILTER
end_undef

begin_define
define|#
directive|define
name|NENETFILTER
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|NENETFILTER
operator|>
literal|256
operator|)
end_if

begin_undef
undef|#
directive|undef
name|NENETFILTER
end_undef

begin_define
define|#
directive|define
name|NENETFILTER
value|256
end_define

begin_comment
comment|/* maximum number of minor devices */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUG
value|1
end_define

begin_comment
comment|/* #define INNERDEBUG 1 */
end_comment

begin_comment
comment|/* define only when debugging enDoFilter() 					or enInputDone()  */
end_comment

begin_define
define|#
directive|define
name|enprintf
parameter_list|(
name|flags
parameter_list|)
value|if (enDebug&(flags)) printf
end_define

begin_comment
comment|/*  * Symbolic definitions for enDebug flag bits  *	ENDBG_TRACE should be 1 because it is the most common  *	use in the code, and the compiler generates faster code  *	for testing the low bit in a word.  */
end_comment

begin_define
define|#
directive|define
name|ENDBG_TRACE
value|1
end_define

begin_comment
comment|/* trace most operations */
end_comment

begin_define
define|#
directive|define
name|ENDBG_DESQ
value|2
end_define

begin_comment
comment|/* trace descriptor queues */
end_comment

begin_define
define|#
directive|define
name|ENDBG_INIT
value|4
end_define

begin_comment
comment|/* initialization info */
end_comment

begin_define
define|#
directive|define
name|ENDBG_SCAV
value|8
end_define

begin_comment
comment|/* scavenger operation */
end_comment

begin_define
define|#
directive|define
name|ENDBG_ABNORM
value|16
end_define

begin_comment
comment|/* abnormal events */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( ((a)<=(b)) ? (a) : (b) )
end_define

begin_define
define|#
directive|define
name|splenet
value|splimp
end_define

begin_comment
comment|/* used to be spl6 but I'm paranoid */
end_comment

begin_define
define|#
directive|define
name|PRINET
value|26
end_define

begin_comment
comment|/* interruptible */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *  'enQueueElts' is the pool of packet headers used by the driver.  *  'enPackets'   is the pool of packets used by the driver (these should  *	          be allocated dynamically when this becomes possible).  *  'enFreeq'     is the queue of available packets  *  'enState'     is the driver state table per logical unit number  *  'enUnit'  	  is the physical unit number table per logical unit number;  *		  the first "attach"ed ethernet is logical unit 0, etc.  *  'enUnitMap'	  maps minor device numbers onto interface unit #s  *  'enAllocMap'  indicates if minor device is allocated or free  *  'enAllDescriptors' stores OpenDescriptors, indexed by minor device #  *  'enFreeqMin'  is the minimum number of packets ever in the free queue  *		  (for statistics purposes)  *  'enScavenges' is the number of scavenges of the active input queues  *		  (for statustics purposes)  *  'enDebug'	  is a collection of debugging bits which enable trace and/or  *		  diagnostic output as defined above (ENDBG_*)  *  'enUnits'	  is the number of attached units  *  'enOneCopy'   if true, then no packet is delivered to more than one minor  *		  device  */
end_comment

begin_decl_stmt
name|struct
name|enPacket
name|enQueueElts
index|[
name|ENPACKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|enQueue
name|enFreeq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|enState
name|enState
index|[
name|NENET
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|enUnitMap
index|[
name|NENETFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|enAllocMap
index|[
name|NENETFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|enOpenDescriptor
name|enAllDescriptors
index|[
name|NENETFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enFreeqMin
init|=
name|ENPACKETS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enScavenges
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enDebug
init|=
name|ENDBG_ABNORM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enUnits
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enOneCopy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enMaxMinors
init|=
name|NENETFILTER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Forward declarations for subroutines which return other  *  than integer types.  */
end_comment

begin_function_decl
specifier|extern
name|boolean
name|enDoFilter
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Linkages to if_en.c  */
end_comment

begin_struct
struct|struct
name|enet_info
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* which ifp for output */
block|}
name|enet_info
index|[
name|NENET
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|sockaddr
name|enetaf
init|=
block|{
name|AF_IMPLINK
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *								*  *		Various Macros& Routines			*  *								*  ****************************************************************/
end_comment

begin_comment
comment|/*  *  forAllOpenDescriptors(p) -- a macro for iterating  *  over all currently open devices.  Use it in place of  *      "for ( ...; ... ; ... )"  *  and supply your own loop body.  The loop variable is the  *  parameter p which is set to point to the descriptor for  *  each open device in turn.  */
end_comment

begin_define
define|#
directive|define
name|forAllOpenDescriptors
parameter_list|(
name|p
parameter_list|)
define|\
value|for ((p) = (struct enOpenDescriptor *)enDesq.enQ_F;		\ 	      (struct Queue *)(&enDesq) !=&((p)->enOD_Link);		\ 	      (p) = (struct enOpenDescriptor *)(p)->enOD_Link.F)
end_define

begin_comment
comment|/*  *  enEnqueue - add an element to a queue  */
end_comment

begin_define
define|#
directive|define
name|enEnqueue
parameter_list|(
name|q
parameter_list|,
name|elt
parameter_list|)
define|\
value|{									\ 	enqueue((struct Queue *)(q), (struct Queue *)(elt));		\ 	(q)->enQ_NumQueued++;						\ }
end_define

begin_comment
comment|/*  *  enFlushQueue - release all packets from queue, freeing any  *  whose reference counts drop to 0.  Assumes caller  *  is at high IPL so that queue will not be modified while  *  it is being flushed.  */
end_comment

begin_expr_stmt
name|enFlushQueue
argument_list|(
name|q
argument_list|)
specifier|register
expr|struct
name|enQueue
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|enPacket
modifier|*
name|qelt
decl_stmt|;
while|while
condition|(
operator|(
name|qelt
operator|=
operator|(
expr|struct
name|enPacket
operator|*
operator|)
name|dequeue
argument_list|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
literal|0
operator|==
operator|--
operator|(
name|qelt
operator|->
name|enP_RefCount
operator|)
condition|)
block|{
name|enEnqueue
argument_list|(
operator|&
name|enFreeq
argument_list|,
name|qelt
argument_list|)
expr_stmt|;
block|}
block|}
name|q
operator|->
name|enQ_NumQueued
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  enInitWaitQueue - initialize an empty packet wait queue  */
end_comment

begin_expr_stmt
name|enInitWaitQueue
argument_list|(
name|wq
argument_list|)
specifier|register
expr|struct
name|enWaitQueue
operator|*
name|wq
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|wq
operator|->
name|enWQ_Head
operator|=
literal|0
expr_stmt|;
name|wq
operator|->
name|enWQ_Tail
operator|=
literal|0
expr_stmt|;
name|wq
operator|->
name|enWQ_NumQueued
operator|=
literal|0
expr_stmt|;
name|wq
operator|->
name|enWQ_MaxWaiting
operator|=
name|ENDEFWAITING
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  enEnWaitQueue - add a packet to a wait queue  */
end_comment

begin_expr_stmt
name|enEnWaitQueue
argument_list|(
name|wq
argument_list|,
name|p
argument_list|)
specifier|register
expr|struct
name|enWaitQueue
operator|*
name|wq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|wq
operator|->
name|enWQ_Packets
index|[
name|wq
operator|->
name|enWQ_Tail
index|]
operator|=
name|p
expr_stmt|;
name|wq
operator|->
name|enWQ_NumQueued
operator|++
expr_stmt|;
name|enNextWaitQueueIndex
argument_list|(
name|wq
operator|->
name|enWQ_Tail
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  enDeWaitQueue - remove a packet from a wait queue  */
end_comment

begin_function
name|struct
name|enPacket
modifier|*
name|enDeWaitQueue
parameter_list|(
name|wq
parameter_list|)
specifier|register
name|struct
name|enWaitQueue
modifier|*
name|wq
decl_stmt|;
block|{
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
name|wq
operator|->
name|enWQ_NumQueued
operator|--
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|enWQ_NumQueued
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"enDeWaitQueue"
argument_list|)
expr_stmt|;
name|p
operator|=
name|wq
operator|->
name|enWQ_Packets
index|[
name|wq
operator|->
name|enWQ_Head
index|]
expr_stmt|;
name|enNextWaitQueueIndex
argument_list|(
name|wq
operator|->
name|enWQ_Head
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  enTrimWaitQueue - cut a wait queue back to size  */
end_comment

begin_expr_stmt
name|enTrimWaitQueue
argument_list|(
name|wq
argument_list|,
name|threshold
argument_list|)
specifier|register
expr|struct
name|enWaitQueue
operator|*
name|wq
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|Counter
init|=
operator|(
name|wq
operator|->
name|enWQ_NumQueued
operator|-
name|threshold
operator|)
decl_stmt|;
specifier|register
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_SCAV
argument_list|)
argument_list|(
literal|"enTrimWaitQueue(%x, %d): %d\n"
argument_list|,
name|wq
argument_list|,
name|threshold
argument_list|,
name|Counter
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|Counter
operator|--
operator|>
literal|0
condition|)
block|{
name|wq
operator|->
name|enWQ_NumQueued
operator|--
expr_stmt|;
name|enPrevWaitQueueIndex
argument_list|(
name|wq
operator|->
name|enWQ_Tail
argument_list|)
expr_stmt|;
name|p
operator|=
name|wq
operator|->
name|enWQ_Packets
index|[
name|wq
operator|->
name|enWQ_Tail
index|]
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|--
operator|(
name|p
operator|->
name|enP_RefCount
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|p
operator|->
name|enP_mbuf
argument_list|)
expr_stmt|;
name|enEnqueue
argument_list|(
operator|&
name|enFreeq
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *  enFlushWaitQueue - remove all packets from wait queue  */
end_comment

begin_define
define|#
directive|define
name|enFlushWaitQueue
parameter_list|(
name|wq
parameter_list|)
value|enTrimWaitQueue(wq, 0)
end_define

begin_comment
comment|/*  *  scavenging thresholds:  *  *  index by number of active files;  for N open files, each queue may retain  *  up to 1/Nth of the packets not guaranteed to be freed on scavenge.  The  *  total number of available packets is computed less one for sending.  *  *  (assumes high IPL)  */
end_comment

begin_decl_stmt
name|char
name|enScavLevel
index|[
name|NENETFILTER
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  enInitScavenge -- set up ScavLevel table  */
end_comment

begin_macro
name|enInitScavenge
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|PoolSize
init|=
operator|(
name|ENPACKETS
operator|-
name|ENMINSCAVENGE
operator|)
decl_stmt|;
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
name|enScavLevel
argument_list|)
decl_stmt|;
name|PoolSize
operator|--
expr_stmt|;
comment|/* leave one for transmitter */
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
name|enScavLevel
index|[
name|i
index|]
operator|=
operator|(
name|PoolSize
operator|/
name|i
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  enScavenge -- scan all OpenDescriptors for all ethernets, releasing  *    any queued buffers beyond the prescribed limit and freeing any whose  *    refcounts drop to 0.  *    Assumes caller is at high IPL so that it is safe to modify the queues.  */
end_comment

begin_macro
name|enScavenge
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|threshold
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|enState
modifier|*
name|enStatep
decl_stmt|;
for|for
control|(
name|enStatep
operator|=
name|enState
init|;
name|enStatep
operator|<
operator|&
name|enState
index|[
name|NENET
index|]
condition|;
name|enStatep
operator|++
control|)
name|threshold
operator|+=
name|enCurOpens
expr_stmt|;
name|threshold
operator|=
name|enScavLevel
index|[
name|threshold
index|]
expr_stmt|;
comment|/* recalculate thresholds based on current allocations */
name|enInitScavenge
argument_list|()
expr_stmt|;
name|enScavenges
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_SCAV
argument_list|)
argument_list|(
literal|"enScavenge: %d\n"
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|enStatep
operator|=
name|enState
init|;
name|enStatep
operator|<
operator|&
name|enState
index|[
name|NENET
index|]
condition|;
name|enStatep
operator|++
control|)
block|{
if|if
condition|(
name|enDesq
operator|.
name|enQ_F
operator|==
literal|0
condition|)
continue|continue;
comment|/* never initialized */
name|forAllOpenDescriptors
argument_list|(
argument|d
argument_list|)
block|{
name|enTrimWaitQueue
argument_list|(
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *  enAllocatePacket - allocate the next packet from the free list  *  *  Assumes IPL is at high priority so that it is safe to touch the  *  packet queue.  If the queue is currently empty, scavenge for  *  more packets.  */
end_comment

begin_function
name|struct
name|enPacket
modifier|*
name|enAllocatePacket
parameter_list|()
block|{
specifier|register
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|enFreeq
operator|.
name|enQ_NumQueued
condition|)
name|enScavenge
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|enPacket
operator|*
operator|)
name|dequeue
argument_list|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
operator|&
name|enFreeq
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"enAllocatePacket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|enFreeqMin
operator|>
operator|--
name|enFreeq
operator|.
name|enQ_NumQueued
condition|)
name|enFreeqMin
operator|=
name|enFreeq
operator|.
name|enQ_NumQueued
expr_stmt|;
name|p
operator|->
name|enP_RefCount
operator|=
literal|0
expr_stmt|;
comment|/* just in case */
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  enDeallocatePacket - place the packet back on the free packet queue  *  *  (High IPL assumed).  */
end_comment

begin_define
define|#
directive|define
name|enDeallocatePacket
parameter_list|(
name|p
parameter_list|)
define|\
value|{									\ 	if (p->enP_RefCount) panic("enDeallocatePacket: refcount != 0");\ 	enqueue((struct Queue *)&enFreeq, (struct Queue *)(p));		\ 	enFreeq.enQ_NumQueued++;					\ }
end_define

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *								*  *	    Routines to move uio data to/from mbufs		*  *								*  ****************************************************************/
end_comment

begin_comment
comment|/*  * These two routines were inspired by/stolen from ../sys/uipc_socket.c  *	   Both return error code (or 0 if success).  */
end_comment

begin_comment
comment|/*  * read: return contents of mbufs to user.  DO NOT free them, since  *	there may be multiple claims on the packet!  */
end_comment

begin_expr_stmt
name|enrmove
argument_list|(
name|m
argument_list|,
name|uio
argument_list|,
name|count
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
comment|/* # of bytes to return */
while|while
condition|(
operator|(
name|count
operator|>
literal|0
operator|)
operator|&&
name|m
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
condition|)
block|{
name|len
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* length of this transfer */
name|count
operator|-=
name|len
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|enwmove
argument_list|(
name|uio
argument_list|,
name|mbufp
argument_list|)
specifier|register
expr|struct
name|uio
operator|*
name|uio
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mbufp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* top mbuf is returned by reference */
end_comment

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|mtop
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
init|=
operator|&
name|mtop
decl_stmt|;
specifier|register
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
condition|)
block|{
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
if|if
condition|(
name|iov
operator|->
name|iov_len
operator|==
literal|0
condition|)
block|{
name|uio
operator|->
name|uio_iov
operator|++
expr_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_iovcnt
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"enwmove: uio_iovcnt< 0 while uio_resid> 0"
argument_list|)
expr_stmt|;
block|}
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|iov
operator|->
name|iov_len
operator|>=
name|CLBYTES
condition|)
block|{
comment|/* big enough to use a page */
specifier|register
name|struct
name|mbuf
modifier|*
name|p
decl_stmt|;
name|MCLGET
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
goto|goto
name|nopages
goto|;
name|m
operator|->
name|m_off
operator|=
operator|(
name|int
operator|)
name|p
operator|-
operator|(
name|int
operator|)
name|m
expr_stmt|;
name|len
operator|=
name|CLBYTES
expr_stmt|;
block|}
else|else
block|{
name|nopages
label|:
name|len
operator|=
name|MIN
argument_list|(
name|MLEN
argument_list|,
name|iov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
operator|(
name|m
operator|->
name|m_next
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* probably uiomove fouled up */
if|if
condition|(
name|mtop
condition|)
name|m_freem
argument_list|(
name|mtop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|mbufp
operator|=
name|mtop
expr_stmt|;
comment|/* return ptr to top mbuf */
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  enetopen - open ether net device  *  *  Errors:	ENXIO	- illegal minor device number  *		EBUSY	- minor device already in use  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|enetopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|newmin
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|newmin
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|md
decl_stmt|;
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|enState
modifier|*
name|enStatep
decl_stmt|;
ifndef|#
directive|ifndef
name|SUN_OPENI
specifier|register
name|int
name|error
decl_stmt|;
endif|#
directive|endif
endif|SUN_OPENI
comment|/*      * Each open enet file has a different minor device number.      * When a user tries to open any of them, we actually open      * any available minor device and associate it with the      * corresponding unit.      *      * This is not elegant, but UNIX will call      * open for each new open file using the same inode but calls      * close only when the last open file referring to the inode       * is released. This means that we cannot know inside the      * driver code when the resources associated with a particular      * open of the same inode should be deallocated.  Thus, we have      * to make up a temporary inode to represent each simultaneous      * open of the ethernet.  Each inode has a different minor device number.      */
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enetopen(%o, %x):\n"
argument_list|,
name|unit
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for illegal minor dev */
if|if
condition|(
operator|(
name|unit
operator|>=
name|enUnits
operator|)
comment|/* bad unit */
operator|||
operator|(
name|enet_info
index|[
name|unit
index|]
operator|.
name|ifp
operator|==
literal|0
operator|)
comment|/* ifp not known */
operator|||
operator|(
operator|(
name|enet_info
index|[
name|unit
index|]
operator|.
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* or if down */
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|md
operator|=
name|enFindMinor
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enetopen: md = %d\n"
argument_list|,
name|md
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|md
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|enUnitMap
index|[
name|md
index|]
operator|=
name|unit
expr_stmt|;
name|enAllocMap
index|[
name|md
index|]
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_OPENI
operator|*
name|newmin
operator|=
name|md
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|mkpseudo
argument_list|(
name|makedev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|md
argument_list|)
argument_list|)
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|error
condition|)
block|{
name|enAllocMap
index|[
name|md
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_if

begin_endif
endif|#
directive|endif
endif|SUN_OPENI
end_endif

begin_expr_stmt
name|enStatep
operator|=
operator|&
name|enState
index|[
name|unit
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|enprintf
argument_list|(
name|ENDBG_DESQ
argument_list|)
argument_list|(
literal|"enetopen: Desq: %x, %x\n"
argument_list|,
name|enDesq
operator|.
name|enQ_F
argument_list|,
name|enDesq
operator|.
name|enQ_B
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|enInitDescriptor
argument_list|(
operator|&
name|enAllDescriptors
index|[
name|md
index|]
argument_list|,
name|flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|enInsertDescriptor
argument_list|(
operator|&
operator|(
name|enDesq
operator|)
argument_list|,
operator|&
name|enAllDescriptors
index|[
name|md
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * enFindMinor - find a free logical device on specified unit  */
end_comment

begin_expr_stmt
unit|enFindMinor
operator|(
operator|)
block|{
specifier|register
name|int
name|md
block|;
for|for
control|(
name|md
operator|=
literal|0
init|;
name|md
operator|<
name|enMaxMinors
condition|;
name|md
operator|++
control|)
block|{
if|if
condition|(
name|enAllocMap
index|[
name|md
index|]
operator|==
name|FALSE
condition|)
return|return
operator|(
name|md
operator|)
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
operator|-
literal|1
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  *  enInit - intialize ethernet unit (called by enetattach)  */
end_comment

begin_expr_stmt
unit|enInit
operator|(
name|enStatep
operator|,
name|unit
operator|)
specifier|register
expr|struct
name|enState
operator|*
name|enStatep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_INIT
argument_list|)
argument_list|(
literal|"enInit(%x %d):\n"
argument_list|,
name|enStatep
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  initialize free queue if not already done  */
if|if
condition|(
name|enFreeq
operator|.
name|enQ_F
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|initqueue
argument_list|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
operator|&
name|enFreeq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ENPACKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|enQueueElts
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|enP_RefCount
operator|=
literal|0
expr_stmt|;
name|enDeallocatePacket
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* also a good time to init enAllocMap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enMaxMinors
condition|;
name|i
operator|++
control|)
name|enAllocMap
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
name|initqueue
argument_list|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
operator|&
name|enDesq
argument_list|)
expr_stmt|;
comment|/* init descriptor queue */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *  enetclose - ether net device close routine  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|enetclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|md
init|=
name|ENINDEX
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|enState
modifier|*
name|enStatep
init|=
operator|&
name|enState
index|[
name|ENUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|d
init|=
operator|&
name|enAllDescriptors
index|[
name|md
index|]
decl_stmt|;
name|int
name|ipl
decl_stmt|;
name|enAllocMap
index|[
name|md
index|]
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enetclose(%d, %x):\n"
argument_list|,
name|md
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      *  insure that receiver doesn't try to queue something      *  for the device as we are decommissioning it.      *  (I don't think this is necessary, but I'm a coward.)      */
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
name|dequeue
argument_list|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
name|d
operator|->
name|enOD_Link
operator|.
name|B
argument_list|)
expr_stmt|;
name|enCurOpens
operator|--
expr_stmt|;
name|enprintf
argument_list|(
name|ENDBG_DESQ
argument_list|)
argument_list|(
literal|"enetclose: Desq: %x, %x\n"
argument_list|,
name|enDesq
operator|.
name|enQ_F
argument_list|,
name|enDesq
operator|.
name|enQ_B
argument_list|)
expr_stmt|;
name|enFlushWaitQueue
argument_list|(
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *  enetread - read next packet from net  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|enetread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|d
init|=
operator|&
name|enAllDescriptors
index|[
name|ENINDEX
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
name|int
name|ipl
decl_stmt|;
name|int
name|error
decl_stmt|;
extern|extern enTimeout(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_expr_stmt
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enetread(%x):"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*      *  If nothing is on the queue of packets waiting for      *  this open enet file, then set timer and sleep until      *  either the timeout has occurred or a packet has      *  arrived.      */
end_comment

begin_while
while|while
condition|(
literal|0
operator|==
name|d
operator|->
name|enOD_Waiting
operator|.
name|enWQ_NumQueued
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|enOD_Timeout
operator|<
literal|0
condition|)
block|{
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|d
operator|->
name|enOD_Timeout
condition|)
block|{
comment|/* 	     *  If there was a previous timeout pending for this file, 	     *  cancel it before setting another.  This is necessary since 	     *  a cancel after the sleep might never happen if the read is 	     *  interrupted by a signal. 	     */
if|if
condition|(
name|d
operator|->
name|enOD_RecvState
operator|==
name|ENRECVTIMING
condition|)
name|untimeout
argument_list|(
name|enTimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|enTimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
call|(
name|int
call|)
argument_list|(
name|d
operator|->
name|enOD_Timeout
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|enOD_RecvState
operator|=
name|ENRECVTIMING
expr_stmt|;
block|}
else|else
name|d
operator|->
name|enOD_RecvState
operator|=
name|ENRECVIDLE
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|PRINET
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|enOD_RecvState
condition|)
block|{
case|case
name|ENRECVTIMING
case|:
block|{
name|untimeout
argument_list|(
name|enTimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|enOD_RecvState
operator|=
name|ENRECVIDLE
expr_stmt|;
break|break;
block|}
case|case
name|ENRECVTIMEDOUT
case|:
block|{
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_while

begin_expr_stmt
name|p
operator|=
name|enDeWaitQueue
argument_list|(
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*        * Move data from packet into user space.      */
end_comment

begin_expr_stmt
name|error
operator|=
name|enrmove
argument_list|(
name|p
operator|->
name|enP_mbuf
argument_list|,
name|uio
argument_list|,
name|p
operator|->
name|enP_ByteCount
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|0
operator|==
operator|--
operator|(
name|p
operator|->
name|enP_RefCount
operator|)
condition|)
comment|/* if no more claims on this packet */
block|{
name|m_freem
argument_list|(
name|p
operator|->
name|enP_mbuf
argument_list|)
expr_stmt|;
comment|/* release mbuf */
name|enDeallocatePacket
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* and packet */
block|}
end_if

begin_expr_stmt
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|error
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  *  enTimeout - process ethernet read timeout  */
end_comment

begin_expr_stmt
unit|enTimeout
operator|(
name|d
operator|)
specifier|register
expr|struct
name|enOpenDescriptor
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|ipl
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enTimeout(%x):\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
name|d
operator|->
name|enOD_RecvState
operator|=
name|ENRECVTIMEDOUT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|enetwakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *  enetwrite - write next packet to net  */
end_comment

begin_decl_stmt
name|int
name|enKludgeSleep
index|[
name|NENET
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we sleeping on IF_QFULL? */
end_comment

begin_comment
comment|/*  really, # of procs sleeping on IF_QFULL */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|enetwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|unit
init|=
name|ENUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|enState
modifier|*
name|enStatep
init|=
operator|&
name|enState
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|enet_info
index|[
name|unit
index|]
operator|.
name|ifp
decl_stmt|;
name|int
name|ipl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|sleepcount
decl_stmt|;
name|int
name|enKludgeTime
parameter_list|()
function_decl|;
if|#
directive|if
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enetwrite(%x):\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
comment|/* too large */
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
comment|/*      * Copy user data into mbufs      */
if|if
condition|(
name|error
operator|=
name|enwmove
argument_list|(
name|uio
argument_list|,
operator|&
name|mp
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
comment|/*      * if the queue is full,      * hang around until there's room or until process is interrupted      */
name|sleepcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|IF_QFULL
argument_list|(
operator|&
operator|(
name|ifp
operator|->
name|if_snd
operator|)
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|hz
decl_stmt|;
if|if
condition|(
name|sleepcount
operator|++
operator|>
literal|2
condition|)
block|{
comment|/* don't sleep too long */
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* if nobody else has a timeout pending for this unit, set one */
if|if
condition|(
name|enKludgeSleep
index|[
name|unit
index|]
operator|==
literal|0
condition|)
name|timeout
argument_list|(
name|enKludgeTime
argument_list|,
operator|(
name|caddr_t
operator|)
name|unit
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|enKludgeSleep
index|[
name|unit
index|]
operator|++
expr_stmt|;
comment|/* record that we are sleeping */
if|if
condition|(
name|setjmp
argument_list|(
operator|&
name|u
operator|.
name|u_qsave
argument_list|)
condition|)
block|{
comment|/* sleep (following) was interrupted, clean up */
if|#
directive|if
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_ABNORM
argument_list|)
argument_list|(
literal|"enetwrite(%x): enet%d sleep %d interrupted\n"
argument_list|,
name|dev
argument_list|,
name|unit
argument_list|,
name|enKludgeSleep
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|enKludgeSleep
index|[
name|unit
index|]
operator|--
expr_stmt|;
comment|/* we're no longer sleeping */
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|enKludgeSleep
index|[
name|unit
index|]
operator|)
argument_list|,
name|PRINET
argument_list|)
expr_stmt|;
name|enKludgeSleep
index|[
name|unit
index|]
operator|--
expr_stmt|;
comment|/* we are no longer sleeping */
block|}
comment|/* place mbuf chain on outgoing queue& start if necessary */
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|mp
argument_list|,
operator|&
name|enetaf
argument_list|)
expr_stmt|;
comment|/* this always frees the mbuf chain */
name|enXcnt
operator|++
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|enKludgeTime
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* XXX perhaps we should always wakeup? */
if|if
condition|(
name|enKludgeSleep
index|[
name|unit
index|]
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|enKludgeSleep
index|[
name|unit
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX should we restart transmitter? */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *  enetioctl - ether net control  *  *  EIOCGETP	 - get ethernet parameters  *  EIOCSETP	 - set ethernet read timeout  *  EIOCSETF	 - set ethernet read filter  *  EIOCENBS	 - enable signal when read packet available  *  EIOCINHS     - inhibit signal when read packet available  *  FIONREAD	 - check for read packet available  *  EIOCSETW	 - set maximum read packet waiting queue length  *  EIOCFLUSH	 - flush read packet waiting queue  *  EIOCMBIS	 - set mode bits  *  EIOCMBIC	 - clear mode bits  *  EICODEVP	 - get device parameters  *  EIOCMFREE	 - number of free minors  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|enetioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|addr
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|enState
modifier|*
name|enStatep
init|=
operator|&
name|enState
index|[
name|ENUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|d
init|=
operator|&
name|enAllDescriptors
index|[
name|ENINDEX
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|ipl
decl_stmt|;
if|#
directive|if
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enetioctl(%x, %x, %x, %x):\n"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|EIOCGETP
case|:
block|{
name|struct
name|eniocb
name|t
decl_stmt|;
name|t
operator|.
name|en_maxwaiting
operator|=
name|ENMAXWAITING
expr_stmt|;
name|t
operator|.
name|en_maxpriority
operator|=
name|ENMAXPRI
expr_stmt|;
name|t
operator|.
name|en_rtout
operator|=
name|d
operator|->
name|enOD_Timeout
expr_stmt|;
name|t
operator|.
name|en_addr
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|.
name|en_maxfilters
operator|=
name|ENMAXFILTERS
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|t
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|t
argument_list|)
expr_stmt|;
block|}
name|endcase
case|case
name|EIOCSETP
case|:
block|{
name|struct
name|eniocb
name|t
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
name|t
argument_list|)
expr_stmt|;
name|d
operator|->
name|enOD_Timeout
operator|=
name|t
operator|.
name|en_rtout
expr_stmt|;
block|}
name|endcase
case|case
name|EIOCSETF
case|:
block|{
name|struct
name|enfilter
name|f
decl_stmt|;
name|unsigned
name|short
modifier|*
name|fp
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|f
argument_list|,
sizeof|sizeof
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|enf_FilterLen
operator|>
name|ENMAXFILTERS
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* insure that filter is installed indivisibly */
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|f
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|d
operator|->
name|enOD_OpenFilter
operator|)
argument_list|,
sizeof|sizeof
name|f
argument_list|)
expr_stmt|;
comment|/* pre-compute length of filter */
name|fp
operator|=
operator|&
operator|(
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Filter
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|d
operator|->
name|enOD_FiltEnd
operator|=
operator|&
operator|(
name|fp
index|[
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_FilterLen
index|]
operator|)
expr_stmt|;
name|d
operator|->
name|enOD_RecvCount
operator|=
literal|0
expr_stmt|;
comment|/* reset count when filter changes */
name|dequeue
argument_list|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
name|d
operator|->
name|enOD_Link
operator|.
name|B
argument_list|)
expr_stmt|;
name|enDesq
operator|.
name|enQ_NumQueued
operator|--
expr_stmt|;
name|enInsertDescriptor
argument_list|(
operator|&
operator|(
name|enDesq
operator|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
block|}
name|endcase
comment|/* 	 *  Enable signal n on input packet 	 */
case|case
name|EIOCENBS
case|:
block|{
name|int
name|snum
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|snum
argument_list|,
sizeof|sizeof
name|snum
argument_list|)
expr_stmt|;
if|if
condition|(
name|snum
operator|<
name|NSIG
condition|)
block|{
name|d
operator|->
name|enOD_SigProc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
name|d
operator|->
name|enOD_SigPid
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_pid
expr_stmt|;
name|d
operator|->
name|enOD_SigNumb
operator|=
name|snum
expr_stmt|;
comment|/* This must be set last */
block|}
else|else
block|{
goto|goto
name|bad
goto|;
block|}
block|}
name|endcase
comment|/* 	 *  Disable signal on input packet 	 */
case|case
name|EIOCINHS
case|:
block|{
name|d
operator|->
name|enOD_SigNumb
operator|=
literal|0
expr_stmt|;
block|}
name|endcase
comment|/* 	 *  Check for packet waiting 	 */
case|case
name|FIONREAD
case|:
block|{
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|enWaitQueue
modifier|*
name|wq
decl_stmt|;
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|wq
operator|=
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
operator|)
operator|->
name|enWQ_NumQueued
condition|)
name|n
operator|=
name|wq
operator|->
name|enWQ_Packets
index|[
name|wq
operator|->
name|enWQ_Head
index|]
operator|->
name|enP_ByteCount
expr_stmt|;
else|else
name|n
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|n
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|n
argument_list|)
expr_stmt|;
block|}
name|endcase
comment|/* 	 *  Set maximum recv queue length for a device 	 */
case|case
name|EIOCSETW
case|:
block|{
name|unsigned
name|un
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|un
argument_list|,
sizeof|sizeof
name|un
argument_list|)
expr_stmt|;
comment|/*              *  unsigned un         MaxQueued              * ----------------    ------------              *  0               ->  DEFWAITING 	     *  1..MAXWAITING   ->  un 	     *  MAXWAITING..-1  ->  MAXWAITING              */
name|d
operator|->
name|enOD_Waiting
operator|.
name|enWQ_MaxWaiting
operator|=
operator|(
name|un
operator|)
condition|?
name|min
argument_list|(
name|un
argument_list|,
name|ENMAXWAITING
argument_list|)
else|:
name|ENDEFWAITING
expr_stmt|;
block|}
name|endcase
comment|/* 	 *  Flush all packets queued for a device 	 */
case|case
name|EIOCFLUSH
case|:
block|{
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
name|enFlushWaitQueue
argument_list|(
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
block|}
name|endcase
comment|/* 	 *  Set mode bits 	 */
case|case
name|EIOCMBIS
case|:
block|{
name|u_short
name|mode
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|ENPRIVMODES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
name|d
operator|->
name|enOD_Flag
operator||=
name|mode
expr_stmt|;
block|}
name|endcase
comment|/* 	 *  Clear mode bits 	 */
case|case
name|EIOCMBIC
case|:
block|{
name|u_short
name|mode
decl_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|ENPRIVMODES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
name|d
operator|->
name|enOD_Flag
operator|&=
operator|~
name|mode
expr_stmt|;
block|}
name|endcase
comment|/* 	 * Return hardware-specific device parameters. 	 */
case|case
name|EIOCDEVP
case|:
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|enDevParams
operator|)
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|endevp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|endcase
expr_stmt|;
comment|/* 	 * Return # of free minor devices. 	 */
case|case
name|EIOCMFREE
case|:
block|{
specifier|register
name|int
name|md
decl_stmt|;
specifier|register
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|md
operator|=
literal|0
init|;
name|md
operator|<
name|enMaxMinors
condition|;
name|md
operator|++
control|)
if|if
condition|(
name|enAllocMap
index|[
name|md
index|]
operator|==
name|FALSE
condition|)
name|sum
operator|++
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sum
expr_stmt|;
block|}
name|endcase
expr_stmt|;
default|default:
block|{
name|bad
label|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****************************************************************  *								*  *		Support for select() system call		*  *								*  *	Other hooks in:						*  *		enInitDescriptor()				*  *		enInputDone()					*  *		enTimeout()					*  ****************************************************************/
end_comment

begin_comment
comment|/*  * inspired by the code in tty.c for the same purpose.  */
end_comment

begin_comment
comment|/*  * enetselect - returns true iff the specific operation  *	will not block indefinitely.  Otherwise, return  *	false but make a note that a selwakeup() must be done.  */
end_comment

begin_expr_stmt
name|enetselect
argument_list|(
name|dev
argument_list|,
name|rw
argument_list|)
specifier|register
name|dev_t
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|enWaitQueue
modifier|*
name|wq
decl_stmt|;
specifier|register
name|int
name|ipl
decl_stmt|;
specifier|register
name|int
name|avail
decl_stmt|;
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|FREAD
case|:
comment|/* 		 * an imitation of the FIONREAD ioctl code 		 */
name|d
operator|=
operator|&
operator|(
name|enAllDescriptors
index|[
name|ENINDEX
argument_list|(
name|dev
argument_list|)
index|]
operator|)
expr_stmt|;
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
name|wq
operator|=
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|enWQ_NumQueued
condition|)
name|avail
operator|=
literal|1
expr_stmt|;
comment|/* at least one packet queued */
else|else
block|{
name|avail
operator|=
literal|0
expr_stmt|;
comment|/* sorry, nothing queued now */
comment|/* 			 * If there's already a select() waiting on this 			 * minor device then this is a collision. 			 * [This shouldn't happen because enet minors 			 * really should not be shared, but if a process 			 * forks while one of these is open, it is possible 			 * that both processes could select() us.] 			 */
if|if
condition|(
name|d
operator|->
name|enOD_SelProc
operator|&&
name|d
operator|->
name|enOD_SelProc
operator|->
name|p_wchan
operator|==
operator|(
name|caddr_t
operator|)
operator|&
name|selwait
condition|)
name|d
operator|->
name|enOD_SelColl
operator|=
literal|1
expr_stmt|;
else|else
name|d
operator|->
name|enOD_SelProc
operator|=
name|u
operator|.
name|u_procp
expr_stmt|;
block|}
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
return|return
operator|(
name|avail
operator|)
return|;
case|case
name|FWRITE
case|:
comment|/* 		 * since the queueing for output is shared not just with 		 * the other enet devices but also with the IP system, 		 * we can't predict what would happen on a subsequent 		 * write.  However, since we presume that all writes 		 * complete eventually, and probably fairly fast, we 		 * pretend that select() is true. 		 */
return|return
operator|(
literal|1
operator|)
return|;
default|default:
comment|/* hmmm. */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* don't block in select() */
block|}
block|}
end_block

begin_expr_stmt
name|enetwakeup
argument_list|(
name|d
argument_list|)
specifier|register
expr|struct
name|enOpenDescriptor
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|d
operator|->
name|enOD_SelProc
condition|)
block|{
name|selwakeup
argument_list|(
name|d
operator|->
name|enOD_SelProc
argument_list|,
name|d
operator|->
name|enOD_SelColl
argument_list|)
expr_stmt|;
name|d
operator|->
name|enOD_SelColl
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|enOD_SelProc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * enetFilter - incoming linkage from ../vaxif/if_en.c  */
end_comment

begin_expr_stmt
name|enetFilter
argument_list|(
name|en
argument_list|,
name|m
argument_list|,
name|count
argument_list|)
specifier|register
name|int
name|en
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|enState
modifier|*
name|enStatep
init|=
operator|&
name|enState
index|[
name|en
index|]
decl_stmt|;
specifier|register
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|pullcount
decl_stmt|;
comment|/* bytes, not words */
name|int
name|s
init|=
name|splenet
argument_list|()
decl_stmt|;
if|#
directive|if
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enetFilter(%d):\n"
argument_list|,
name|en
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|enAllocatePacket
argument_list|()
expr_stmt|;
comment|/* panics if not possible */
name|p
operator|->
name|enP_ByteCount
operator|=
name|count
expr_stmt|;
name|pullcount
operator|=
name|min
argument_list|(
name|MLEN
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* largest possible first mbuf */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|pullcount
condition|)
block|{
comment|/* first mbuf not as full as it could be - fix this */
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|pullcount
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* evidently no resources; bloody m_pullup discarded mbuf */
name|enDeallocatePacket
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|enRdrops
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|p
operator|->
name|enP_mbuf
operator|=
name|m
expr_stmt|;
name|p
operator|->
name|enP_Data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_short
operator|*
argument_list|)
expr_stmt|;
name|enInputDone
argument_list|(
name|enStatep
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * enInputDone - process correctly received packet  */
end_comment

begin_expr_stmt
name|enInputDone
argument_list|(
name|enStatep
argument_list|,
name|p
argument_list|)
specifier|register
expr|struct
name|enState
operator|*
name|enStatep
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|d
decl_stmt|;
name|int
name|queued
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|maxword
decl_stmt|;
specifier|register
name|unsigned
name|long
name|rcount
decl_stmt|;
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|prevd
decl_stmt|;
if|#
directive|if
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enInputDone(%x): %x\n"
argument_list|,
name|enStatep
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* precompute highest possible word offset */
comment|/* can't address beyond end of packet or end of first mbuf */
name|maxword
operator|=
operator|(
name|min
argument_list|(
name|p
operator|->
name|enP_ByteCount
argument_list|,
name|p
operator|->
name|enP_mbuf
operator|->
name|m_len
argument_list|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|forAllOpenDescriptors
argument_list|(
argument|d
argument_list|)
block|{
if|if
condition|(
name|enDoFilter
argument_list|(
name|p
argument_list|,
name|d
argument_list|,
name|maxword
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|enOD_Waiting
operator|.
name|enWQ_NumQueued
operator|<
name|d
operator|->
name|enOD_Waiting
operator|.
name|enWQ_MaxWaiting
condition|)
block|{
name|enEnWaitQueue
argument_list|(
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|enP_RefCount
operator|++
expr_stmt|;
name|queued
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
name|enetwakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|#
directive|if
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enInputDone: queued\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  send notification when input packet received  */
if|if
condition|(
name|d
operator|->
name|enOD_SigNumb
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|enOD_SigProc
operator|->
name|p_pid
operator|==
name|d
operator|->
name|enOD_SigPid
condition|)
name|psignal
argument_list|(
name|d
operator|->
name|enOD_SigProc
argument_list|,
name|d
operator|->
name|enOD_SigNumb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|enOD_Flag
operator|&
name|ENHOLDSIG
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|enOD_SigNumb
operator|=
literal|0
expr_stmt|;
comment|/* disable signal */
block|}
name|rcount
operator|=
operator|++
operator|(
name|d
operator|->
name|enOD_RecvCount
operator|)
expr_stmt|;
comment|/* see if ordering of filters is wrong */
if|if
condition|(
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Priority
operator|>=
name|ENHIPRI
condition|)
block|{
name|prevd
operator|=
operator|(
expr|struct
name|enOpenDescriptor
operator|*
operator|)
name|d
operator|->
name|enOD_Link
operator|.
name|B
expr_stmt|;
comment|/* 		 * If d is not the first element on the queue, and 		 * the previous element is at equal priority but has 		 * a lower count, then promote d to be in front of prevd. 		 */
if|if
condition|(
operator|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
name|prevd
operator|!=
operator|&
operator|(
name|enDesq
operator|.
name|enQ_Head
operator|)
operator|)
operator|&&
operator|(
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Priority
operator|==
name|prevd
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Priority
operator|)
condition|)
block|{
comment|/* threshold difference to avoid thrashing */
if|if
condition|(
operator|(
literal|100
operator|+
name|prevd
operator|->
name|enOD_RecvCount
operator|)
operator|<
name|rcount
condition|)
block|{
name|enReorderQueue
argument_list|(
operator|&
operator|(
name|prevd
operator|->
name|enOD_Link
operator|)
argument_list|,
operator|&
operator|(
name|d
operator|->
name|enOD_Link
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* high-priority filter => no more deliveries */
block|}
elseif|else
if|if
condition|(
name|enOneCopy
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|queued
operator|==
literal|0
condition|)
comment|/* this buffer no longer in use */
block|{
name|m_freem
argument_list|(
name|p
operator|->
name|enP_mbuf
argument_list|)
expr_stmt|;
comment|/* free mbuf */
name|enDeallocatePacket
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/*  and packet */
name|enRdrops
operator|++
expr_stmt|;
block|}
else|else
name|enRcnt
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_define
define|#
directive|define
name|opx
parameter_list|(
name|i
parameter_list|)
value|(i>>ENF_NBPA)
end_define

begin_function
name|boolean
name|enDoFilter
parameter_list|(
name|p
parameter_list|,
name|d
parameter_list|,
name|maxword
parameter_list|)
name|struct
name|enPacket
modifier|*
name|p
decl_stmt|;
name|struct
name|enOpenDescriptor
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|maxword
decl_stmt|;
block|{
specifier|register
name|unsigned
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|fp
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|fpe
decl_stmt|;
specifier|register
name|unsigned
name|op
decl_stmt|;
specifier|register
name|unsigned
name|arg
decl_stmt|;
name|unsigned
name|short
name|stack
index|[
name|ENMAXFILTERS
operator|+
literal|1
index|]
decl_stmt|;
struct|struct
name|fw
block|{
name|unsigned
name|arg
range|:
name|ENF_NBPA
decl_stmt|,
name|op
range|:
name|ENF_NBPO
decl_stmt|;
block|}
struct|;
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enDoFilter(%x,%x):\n"
argument_list|,
name|p
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
operator|&
name|stack
index|[
name|ENMAXFILTERS
index|]
expr_stmt|;
name|fp
operator|=
operator|&
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Filter
index|[
literal|0
index|]
expr_stmt|;
name|fpe
operator|=
name|d
operator|->
name|enOD_FiltEnd
expr_stmt|;
comment|/* ^ is really: fpe =&fp[d->enOD_OpenFilter.enf_FilterLen]; */
operator|*
name|sp
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
name|fp
operator|<
name|fpe
condition|;
control|)
block|{
name|op
operator|=
operator|(
operator|(
expr|struct
name|fw
operator|*
operator|)
name|fp
operator|)
operator|->
name|op
expr_stmt|;
name|arg
operator|=
operator|(
operator|(
expr|struct
name|fw
operator|*
operator|)
name|fp
operator|)
operator|->
name|arg
expr_stmt|;
name|fp
operator|++
expr_stmt|;
switch|switch
condition|(
name|arg
condition|)
block|{
default|default:
name|arg
operator|-=
name|ENF_PUSHWORD
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
comment|/* 		 * This next test is a little bogus; since arg 		 * is unsigned, it is always>= 0 (the compiler 		 * knows this and emits no code).  If arg were 		 * less than ENF_PUSHWORD before the subtract, 		 * it is certaintly going to be more than maxword 		 * afterward, so the code does work "right" 		 */
if|if
condition|(
operator|(
name|arg
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|arg
operator|<
name|maxword
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|arg
operator|<
name|maxword
condition|)
endif|#
directive|endif
endif|lint
operator|*
operator|--
name|sp
operator|=
name|p
operator|->
name|enP_Data
index|[
name|arg
index|]
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>0(len)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
break|break;
case|case
name|ENF_PUSHLIT
case|:
operator|*
operator|--
name|sp
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
break|break;
case|case
name|ENF_PUSHZERO
case|:
operator|*
operator|--
name|sp
operator|=
literal|0
expr_stmt|;
case|case
name|ENF_NOPUSH
case|:
break|break;
block|}
if|if
condition|(
name|sp
operator|<
operator|&
name|stack
index|[
literal|2
index|]
condition|)
comment|/* check stack overflow: small yellow zone */
block|{
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>0(--sp)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|op
operator|==
name|ENF_NOP
condition|)
continue|continue;
comment|/* 	 * all non-NOP operators binary, must have at least two operands 	 * on stack to evaluate. 	 */
if|if
condition|(
name|sp
operator|>
operator|&
name|stack
index|[
name|ENMAXFILTERS
operator|-
literal|2
index|]
condition|)
block|{
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>0(sp++)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|arg
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>0(def)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
case|case
name|opx
argument_list|(
name|ENF_AND
argument_list|)
case|:
operator|*
name|sp
operator|&=
name|arg
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_OR
argument_list|)
case|:
operator|*
name|sp
operator||=
name|arg
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_XOR
argument_list|)
case|:
operator|*
name|sp
operator|^=
name|arg
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_EQ
argument_list|)
case|:
operator|*
name|sp
operator|=
operator|(
operator|*
name|sp
operator|==
name|arg
operator|)
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_NEQ
argument_list|)
case|:
operator|*
name|sp
operator|=
operator|(
operator|*
name|sp
operator|!=
name|arg
operator|)
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_LT
argument_list|)
case|:
operator|*
name|sp
operator|=
operator|(
operator|*
name|sp
operator|<
name|arg
operator|)
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_LE
argument_list|)
case|:
operator|*
name|sp
operator|=
operator|(
operator|*
name|sp
operator|<=
name|arg
operator|)
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_GT
argument_list|)
case|:
operator|*
name|sp
operator|=
operator|(
operator|*
name|sp
operator|>
name|arg
operator|)
expr_stmt|;
break|break;
case|case
name|opx
argument_list|(
name|ENF_GE
argument_list|)
case|:
operator|*
name|sp
operator|=
operator|(
operator|*
name|sp
operator|>=
name|arg
operator|)
expr_stmt|;
break|break;
comment|/* short-circuit operators */
case|case
name|opx
argument_list|(
name|ENF_COR
argument_list|)
case|:
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
name|arg
condition|)
block|{
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>COR %x\n"
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
break|break;
case|case
name|opx
argument_list|(
name|ENF_CAND
argument_list|)
case|:
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
name|arg
condition|)
block|{
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>CAND %x\n"
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
break|break;
case|case
name|opx
argument_list|(
name|ENF_CNOR
argument_list|)
case|:
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
name|arg
condition|)
block|{
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>COR %x\n"
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
break|break;
case|case
name|opx
argument_list|(
name|ENF_CNAND
argument_list|)
case|:
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
name|arg
condition|)
block|{
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>CAND %x\n"
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|INNERDEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>%x\n"
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|boolean
operator|)
operator|*
name|sp
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
name|enInitDescriptor
argument_list|(
name|d
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|enOpenDescriptor
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|#
directive|if
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"enInitDescriptor(%x):\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|enOD_RecvState
operator|=
name|ENRECVIDLE
expr_stmt|;
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_FilterLen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Priority
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|enOD_FiltEnd
operator|=
operator|&
operator|(
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Filter
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|d
operator|->
name|enOD_RecvCount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|enOD_Timeout
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|enOD_SigNumb
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|enOD_Flag
operator|=
name|flag
expr_stmt|;
name|d
operator|->
name|enOD_SelColl
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|enOD_SelProc
operator|=
literal|0
expr_stmt|;
comment|/* probably unnecessary */
comment|/*      * Remember the PID that opened us, at least until some process      * sets a signal for this minor device      */
name|d
operator|->
name|enOD_SigPid
operator|=
name|u
operator|.
name|u_procp
operator|->
name|p_pid
expr_stmt|;
name|enInitWaitQueue
argument_list|(
operator|&
operator|(
name|d
operator|->
name|enOD_Waiting
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_TRACE
argument_list|)
argument_list|(
literal|"=>eninitdescriptor\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  *  enInsertDescriptor - insert open descriptor in queue ordered by priority  */
end_comment

begin_expr_stmt
name|enInsertDescriptor
argument_list|(
name|q
argument_list|,
name|d
argument_list|)
specifier|register
expr|struct
name|enQueue
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|enOpenDescriptor
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|enOpenDescriptor
modifier|*
name|nxt
decl_stmt|;
specifier|register
name|int
name|ipl
decl_stmt|;
name|ipl
operator|=
name|splenet
argument_list|()
expr_stmt|;
name|nxt
operator|=
operator|(
expr|struct
name|enOpenDescriptor
operator|*
operator|)
name|q
operator|->
name|enQ_F
expr_stmt|;
while|while
condition|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
name|q
operator|!=
operator|&
operator|(
name|nxt
operator|->
name|enOD_Link
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Priority
operator|>
name|nxt
operator|->
name|enOD_OpenFilter
operator|.
name|enf_Priority
condition|)
break|break;
name|nxt
operator|=
operator|(
expr|struct
name|enOpenDescriptor
operator|*
operator|)
name|nxt
operator|->
name|enOD_Link
operator|.
name|F
expr_stmt|;
block|}
name|enqueue
argument_list|(
operator|(
expr|struct
name|Queue
operator|*
operator|)
operator|&
operator|(
name|nxt
operator|->
name|enOD_Link
operator|)
argument_list|,
operator|(
expr|struct
name|Queue
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|enOD_Link
operator|)
argument_list|)
expr_stmt|;
name|enprintf
argument_list|(
name|ENDBG_DESQ
argument_list|)
argument_list|(
literal|"enID: Desq: %x, %x\n"
argument_list|,
name|q
operator|->
name|enQ_F
argument_list|,
name|q
operator|->
name|enQ_B
argument_list|)
expr_stmt|;
name|q
operator|->
name|enQ_NumQueued
operator|++
expr_stmt|;
name|splx
argument_list|(
name|ipl
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|enReorderCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for external monitoring */
end_comment

begin_comment
comment|/*  * enReorderQueue - swap order of two elements in queue  *	assumed to be called at splenet  */
end_comment

begin_expr_stmt
name|enReorderQueue
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
specifier|register
expr|struct
name|Queue
operator|*
name|first
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|Queue
modifier|*
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Queue
modifier|*
name|prev
decl_stmt|;
specifier|register
name|struct
name|Queue
modifier|*
name|next
decl_stmt|;
name|enprintf
argument_list|(
name|ENDBG_DESQ
argument_list|)
argument_list|(
literal|"enReorderQ: %x, %x\n"
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|enReorderCount
operator|++
expr_stmt|;
comment|/* get pointers to other queue elements */
name|prev
operator|=
name|first
operator|->
name|B
expr_stmt|;
name|next
operator|=
name|last
operator|->
name|F
expr_stmt|;
comment|/* 	 * no more reading from queue elements; this ensures that 	 * the code works even if there are fewer than 4 elements 	 * in the queue. 	 */
name|prev
operator|->
name|F
operator|=
name|last
expr_stmt|;
name|next
operator|->
name|B
operator|=
name|first
expr_stmt|;
name|last
operator|->
name|B
operator|=
name|prev
expr_stmt|;
name|last
operator|->
name|F
operator|=
name|first
expr_stmt|;
name|first
operator|->
name|F
operator|=
name|next
expr_stmt|;
name|first
operator|->
name|B
operator|=
name|last
expr_stmt|;
block|}
end_block

begin_macro
name|enetattach
argument_list|(
argument|ifp
argument_list|,
argument|devp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|endevp
modifier|*
name|devp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|enState
modifier|*
name|enStatep
init|=
operator|&
name|enState
index|[
name|enUnits
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enprintf
argument_list|(
name|ENDBG_INIT
argument_list|)
argument_list|(
literal|"enetattach: type %d, addr "
argument_list|,
name|devp
operator|->
name|end_dev_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|enDebug
operator|&
name|ENDBG_INIT
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devp
operator|->
name|end_addr_len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%o "
argument_list|,
name|devp
operator|->
name|end_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
name|enet_info
index|[
name|enUnits
index|]
operator|.
name|ifp
operator|=
name|ifp
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|devp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|enDevParams
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|endevp
argument_list|)
argument_list|)
expr_stmt|;
name|enInit
argument_list|(
name|enStatep
argument_list|,
name|enUnits
argument_list|)
expr_stmt|;
return|return
operator|(
name|enUnits
operator|++
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|(NENETFILTER> 0)
end_endif

end_unit

