begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (C) 1983 by Lee Moore.  All rights reserved.  *  * Token package  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/*  * Get one character from the input.  Set flags.  */
end_comment

begin_function
specifier|static
name|int
name|GetCharacter1
parameter_list|(
name|ts
parameter_list|)
name|struct
name|TokenState
modifier|*
name|ts
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|ts
operator|->
name|Input
argument_list|)
expr_stmt|;
name|ts
operator|->
name|NotEndOfFile
operator|=
operator|(
name|c
operator|!=
name|EOF
operator|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  *  Get one character from the input.  Set Flags.  (see above)  *	Ignore comments.  */
end_comment

begin_function
specifier|static
name|int
name|GetCharacter
parameter_list|(
name|ts
parameter_list|)
name|struct
name|TokenState
modifier|*
name|ts
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|GetCharacter1
argument_list|(
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
comment|/* quote the next character? */
name|c
operator|=
name|GetCharacter1
argument_list|(
name|ts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
comment|/* if this a comment? */
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|GetCharacter1
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over blank space.  Set LastTokenInLine if we see at a new-line.  */
end_comment

begin_expr_stmt
specifier|static
name|SkipBlankSpace
argument_list|(
argument|ts
argument_list|)
expr|struct
name|TokenState
operator|*
name|ts
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|ts
operator|->
name|LastTokenInLine
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|ts
operator|->
name|CurChar
argument_list|)
condition|)
block|{
if|if
condition|(
name|ts
operator|->
name|CurChar
operator|==
literal|'\n'
condition|)
name|ts
operator|->
name|LastTokenInLine
operator|=
name|TRUE
expr_stmt|;
name|ts
operator|->
name|CurChar
operator|=
name|GetCharacter
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Initialize token package  */
end_comment

begin_function
name|struct
name|TokenState
modifier|*
name|InitTokenStream
parameter_list|(
name|from
parameter_list|)
name|FILE
modifier|*
name|from
decl_stmt|;
block|{
name|struct
name|TokenState
modifier|*
name|ts
decl_stmt|;
name|ts
operator|=
operator|(
expr|struct
name|TokenState
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|TokenState
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|->
name|LastTokenInLine
operator|=
name|FALSE
expr_stmt|;
name|ts
operator|->
name|NotEndOfFile
operator|=
name|FALSE
operator|,
name|ts
operator|->
name|Input
operator|=
name|from
expr_stmt|;
name|ts
operator|->
name|CurChar
operator|=
name|GetCharacter
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|SkipBlankSpace
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
name|ts
return|;
block|}
end_function

begin_comment
comment|/*  * Close and release resources  */
end_comment

begin_macro
name|CloseTokenStream
argument_list|(
argument|ts
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|TokenState
modifier|*
name|ts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fclose
argument_list|(
name|ts
operator|->
name|Input
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the next token in the input.  Tokens are strings of characters that are  *	delimited by<space>,<tab> and<new-line>  */
end_comment

begin_macro
name|GetToken
argument_list|(
argument|ts
argument_list|,
argument|arg
argument_list|,
argument|maxSize
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|TokenState
modifier|*
name|ts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxSize
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
name|ts
operator|->
name|CurChar
argument_list|)
operator|&&
name|ts
operator|->
name|CurChar
operator|!=
name|EOF
operator|&&
name|maxSize
operator|>
literal|0
condition|)
block|{
operator|*
name|arg
operator|++
operator|=
name|ts
operator|->
name|CurChar
expr_stmt|;
name|ts
operator|->
name|CurChar
operator|=
name|GetCharacter
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|maxSize
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|maxSize
operator|>
literal|0
condition|)
operator|*
name|arg
operator|=
literal|'\0'
expr_stmt|;
name|SkipBlankSpace
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Test if we have read all the tokens in the current line  */
end_comment

begin_macro
name|EndOfLine
argument_list|(
argument|ts
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|TokenState
modifier|*
name|ts
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|ts
operator|->
name|LastTokenInLine
return|;
block|}
end_block

begin_comment
comment|/*  * return true if we have read all the tokens in the file  */
end_comment

begin_macro
name|EndOfFile
argument_list|(
argument|ts
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|TokenState
modifier|*
name|ts
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|!
name|ts
operator|->
name|NotEndOfFile
return|;
block|}
end_block

end_unit

