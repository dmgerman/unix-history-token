begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)main.c	8.1 (down!honey) 86/01/19"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAIN
end_define

begin_comment
comment|/* for sccsid in header files */
end_comment

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_define
define|#
directive|define
name|USAGE
value|"usage: %s [-vci] [-l localname] [-d deadlink] [-t tracelink] [-g file] [-s file]\n"
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|locname
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|errflg
init|=
literal|0
decl_stmt|;
name|ProgName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|allocation
argument_list|()
expr_stmt|;
comment|/* initialize data space monitoring */
name|Cfile
operator|=
literal|"[deadlinks]"
expr_stmt|;
comment|/* for tracing dead links */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cd:g:il:s:t:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* print cost info */
name|Cflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* dead host or link */
name|deadlink
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* graph output file */
name|Graphout
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* ignore case */
name|Iflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* local name */
name|locname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* show shortest path tree */
name|Linkout
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* trace this link */
if|if
condition|(
name|tracelink
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can trace only %d links\n"
argument_list|,
name|ProgName
argument_list|,
name|NTRACE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Tflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* verbose stderr, mixed blessing */
name|Vflag
operator|++
expr_stmt|;
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errflg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|USAGE
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* kludge for yywrap() */
if|if
condition|(
operator|*
name|argv
condition|)
block|{
name|Ifiles
operator|=
name|argv
expr_stmt|;
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|locname
condition|)
name|locname
operator|=
name|local
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|locname
operator|==
literal|0
condition|)
block|{
name|locname
operator|=
literal|"lostinspace"
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: using \"%s\" for local name\n"
argument_list|,
name|ProgName
argument_list|,
name|locname
argument_list|)
expr_stmt|;
block|}
name|Home
operator|=
name|addnode
argument_list|(
name|locname
argument_list|)
expr_stmt|;
comment|/* add home node */
name|Home
operator|->
name|n_cost
operator|=
literal|0
expr_stmt|;
comment|/* doesn't cost to get here */
name|yyparse
argument_list|()
expr_stmt|;
comment|/* read in link info */
if|if
condition|(
name|Vflag
operator|>
literal|1
condition|)
name|hashanalyze
argument_list|()
expr_stmt|;
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d vertices, %d edges\n"
argument_list|,
name|Ncount
argument_list|,
name|Lcount
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"allocation is %ldk after parsing\n"
argument_list|,
name|allocation
argument_list|()
argument_list|)
expr_stmt|;
name|Cfile
operator|=
literal|"[backlinks]"
expr_stmt|;
comment|/* for tracing back links */
name|Lineno
operator|=
literal|0
expr_stmt|;
name|mapit
argument_list|()
expr_stmt|;
comment|/* compute shortest path tree */
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"allocation is %ldk after mapping\n"
argument_list|,
name|allocation
argument_list|()
argument_list|)
expr_stmt|;
name|printit
argument_list|()
expr_stmt|;
comment|/* traverse tree and print paths */
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"allocation is %ldk after printing\n"
argument_list|,
name|allocation
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|badmagic
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|n
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot recover!\n"
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|abort
argument_list|()
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

end_unit

