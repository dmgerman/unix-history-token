begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)mapit.c	8.1 (down!honey) 86/01/19"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_comment
comment|/* privates */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|reheap
argument_list|()
decl_stmt|,
name|insert
argument_list|()
decl_stmt|,
name|heapswap
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|link
modifier|*
name|min_node
argument_list|()
decl_stmt|,
modifier|*
name|rmlink
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Cost
name|costof
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|long
name|Nheap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|Heaphighwater
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|link
modifier|*
modifier|*
name|Heap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* transform the graph to a shortest-path tree by marking tree edges */
end_comment

begin_macro
name|mapit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
name|link
modifier|*
name|lprev
decl_stmt|,
modifier|*
name|lnext
decl_stmt|;
name|Cost
name|cost
decl_stmt|;
comment|/* 	 * re-use the hash table space for the heap. 	 */
name|Heap
operator|=
operator|(
name|link
operator|*
operator|*
operator|)
name|Table
expr_stmt|;
name|pack
argument_list|()
expr_stmt|;
comment|/* remove holes in the Table */
if|if
condition|(
name|Linkout
operator|&&
operator|*
name|Linkout
condition|)
comment|/* dump cheapest links */
name|showlinks
argument_list|()
expr_stmt|;
if|if
condition|(
name|Graphout
operator|&&
operator|*
name|Graphout
condition|)
comment|/* dump the edge list */
name|dumpgraph
argument_list|()
expr_stmt|;
comment|/* invent and insert a link for Home to get things started */
name|l
operator|=
name|newlink
argument_list|()
expr_stmt|;
name|l
operator|->
name|l_to
operator|=
name|Home
expr_stmt|;
operator|(
name|void
operator|)
name|dehash
argument_list|(
name|Home
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* main mapping loop */
name|remap
label|:
name|Heaphighwater
operator|=
name|Nheap
expr_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|min_node
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|l
operator|->
name|l_flag
operator||=
name|LTREE
expr_stmt|;
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
name|n
operator|->
name|n_flag
operator||=
name|MAPPED
expr_stmt|;
comment|/* add children to heap */
name|lprev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|n
operator|->
name|n_link
init|;
name|l
operator|!=
literal|0
condition|;
name|l
operator|=
name|lnext
control|)
block|{
name|next
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
comment|/* neighboring node */
if|if
condition|(
name|next
operator|->
name|n_flag
operator|&
name|MAPPED
condition|)
block|{
name|lnext
operator|=
name|rmlink
argument_list|(
name|l
argument_list|,
name|lprev
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cost
operator|=
name|costof
argument_list|(
name|n
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|skiplink
argument_list|(
name|l
argument_list|,
name|n
argument_list|,
name|cost
argument_list|)
condition|)
block|{
name|lnext
operator|=
name|rmlink
argument_list|(
name|l
argument_list|,
name|lprev
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * put this link in the heap, in a place where it may 			 * percolate up, but not down.  if new, or if cost is 			 * being increased, move to end.  otherwise, cost is 			 * same or less, so leave it where it is.  unfortunately, 			 * freeing a link already in the heap is too costly at 			 * this point. 			 * 			 * TODO: avoid heaping aliases and network members. 			 */
if|if
condition|(
name|dehash
argument_list|(
name|next
argument_list|)
operator|==
literal|0
condition|)
comment|/* first time in heap */
name|insert
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* insert at end */
else|else
block|{
comment|/* replace heaped link by this one */
if|if
condition|(
name|cost
operator|>
name|next
operator|->
name|n_cost
condition|)
block|{
comment|/* gateway */
comment|/* move old link to end of heap */
name|heapswap
argument_list|(
call|(
name|long
call|)
argument_list|(
name|next
operator|->
name|n_tloc
argument_list|)
argument_list|,
name|Nheap
argument_list|)
expr_stmt|;
name|next
operator|->
name|n_tloc
operator|=
name|Nheap
expr_stmt|;
block|}
name|Heap
index|[
name|next
operator|->
name|n_tloc
index|]
operator|=
name|l
expr_stmt|;
block|}
name|next
operator|->
name|n_cost
operator|=
name|cost
expr_stmt|;
name|next
operator|->
name|n_parent
operator|=
name|n
expr_stmt|;
name|reheap
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* restore heap property */
comment|/* 			 * note whether we got here via a gatewayed net. 			 * domains are presumed to require gateways. 			 * aliases inherit parent's gateway status. 			 */
name|next
operator|->
name|n_flag
operator|&=
operator|~
name|GATEWAYIN
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|l_flag
operator|&
name|LALIAS
condition|)
name|next
operator|->
name|n_flag
operator||=
operator|(
name|n
operator|->
name|n_flag
operator|&
name|GATEWAYIN
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GATEWAYED
argument_list|(
name|n
argument_list|)
condition|)
name|next
operator|->
name|n_flag
operator||=
name|GATEWAYIN
expr_stmt|;
name|lprev
operator|=
name|l
expr_stmt|;
comment|/* this link's a keeper */
name|lnext
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
block|}
block|}
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"heap high water mark was %d\n"
argument_list|,
name|Heaphighwater
argument_list|)
expr_stmt|;
comment|/* sanity check on implementation */
if|if
condition|(
name|Nheap
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: null entry found in heap\n"
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Hashpart
operator|<
name|Tabsize
condition|)
block|{
comment|/* 		 * add back links from unreachable hosts to reachable 		 * neighbors, then remap.  asymptotically, this is 		 * quadratic.  in practice, this is done exactly once. 		 */
name|backlinks
argument_list|()
expr_stmt|;
if|if
condition|(
name|Nheap
condition|)
goto|goto
name|remap
goto|;
block|}
if|if
condition|(
name|Hashpart
operator|<
name|Tabsize
condition|)
block|{
name|fputs
argument_list|(
literal|"You can't get there from here:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|Hashpart
operator|<
name|Tabsize
condition|;
name|Hashpart
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s"
argument_list|,
name|Table
index|[
name|Hashpart
index|]
operator|->
name|n_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Table
index|[
name|Hashpart
index|]
operator|->
name|n_flag
operator|&
operator|(
name|ISPRIVATE
operator||
name|COLLISION
operator|)
condition|)
name|fputs
argument_list|(
literal|" (private)"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * can this link be ignored?  if yes, return 1, o.w. 0.  * a link can be skipped if it is not in the shortest path tree.  */
end_comment

begin_function
name|STATIC
name|int
name|skiplink
parameter_list|(
name|l
parameter_list|,
name|parent
parameter_list|,
name|cost
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
comment|/* new link to this node */
name|node
modifier|*
name|parent
decl_stmt|;
comment|/* new parent of this node */
name|Cost
name|cost
decl_stmt|;
comment|/* new cost to this node */
block|{
name|node
modifier|*
name|n
decl_stmt|;
comment|/* this node */
name|link
modifier|*
name|lheap
decl_stmt|;
comment|/* existing link to this node */
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
comment|/* first time we've reached this node? */
if|if
condition|(
name|n
operator|->
name|n_tloc
operator|>=
name|Hashpart
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lheap
operator|=
name|Heap
index|[
name|n
operator|->
name|n_tloc
index|]
expr_stmt|;
comment|/* examine links to nets that require gateways */
if|if
condition|(
name|GATEWAYED
argument_list|(
name|n
argument_list|)
condition|)
block|{
comment|/* if exactly one is a gateway, use it */
if|if
condition|(
operator|(
name|lheap
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
operator|&&
operator|!
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* old is gateway */
if|if
condition|(
operator|!
operator|(
name|lheap
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
operator|&&
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* new is gateway */
comment|/* no gateway or both gateways;  resolve in standard way ... */
block|}
comment|/* examine dup link (sanity check) */
if|if
condition|(
name|n
operator|->
name|n_parent
operator|==
name|parent
operator|&&
operator|(
operator|(
name|lheap
operator|->
name|l_flag
operator|&
name|LDEAD
operator|)
operator|||
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LDEAD
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: dup dead link not eliminated: %s -> %s\n"
argument_list|,
name|ProgName
argument_list|,
name|parent
operator|->
name|n_name
argument_list|,
name|n
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  examine cost */
if|if
condition|(
name|cost
operator|<
name|n
operator|->
name|n_cost
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cost
operator|>
name|n
operator|->
name|n_cost
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* all other things being equal, consult the oracle */
return|return
operator|(
name|tiebreaker
argument_list|(
name|n
argument_list|,
name|parent
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|Cost
name|costof
parameter_list|(
name|prev
parameter_list|,
name|l
parameter_list|)
specifier|register
name|node
modifier|*
name|prev
decl_stmt|;
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|next
decl_stmt|;
specifier|register
name|Cost
name|cost
decl_stmt|;
name|next
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|l_flag
operator|&
name|LALIAS
condition|)
block|{
comment|/* copy left/right bits */
name|next
operator|->
name|n_flag
operator|&=
operator|~
operator|(
name|HASLEFT
operator||
name|HASRIGHT
operator|)
expr_stmt|;
name|next
operator|->
name|n_flag
operator||=
operator|(
name|prev
operator|->
name|n_flag
operator|&
operator|(
name|HASLEFT
operator||
name|HASRIGHT
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|prev
operator|->
name|n_cost
operator|)
return|;
comment|/* by definition */
block|}
name|cost
operator|=
name|prev
operator|->
name|n_cost
operator|+
name|l
operator|->
name|l_cost
expr_stmt|;
comment|/* basic cost */
comment|/* 	 * heuristics: 	 *    charge for a dead link. 	 *    charge for getting out of a dead host. 	 *    charge for getting into a gatewayed net (except at a gateway). 	 *    discourage mixing of left and right syntax when next is a host. 	 *    charge for leaving a gatewayed net. 	 * 	 * life was simpler when pathalias computed true shortest paths. 	 */
if|if
condition|(
name|l
operator|->
name|l_flag
operator|&
name|LDEAD
condition|)
comment|/* dead link */
name|cost
operator|+=
name|INF
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|DEADHOST
argument_list|(
name|prev
argument_list|)
condition|)
comment|/* dead host */
name|cost
operator|+=
name|INF
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|GATEWAYED
argument_list|(
name|next
argument_list|)
operator|&&
operator|!
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
condition|)
comment|/* not gateway */
name|cost
operator|+=
name|INF
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|ISANET
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* charge for mixed syntax here */
if|if
condition|(
operator|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LLEFT
operator|&&
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|HASRIGHT
operator|)
operator|)
operator|||
operator|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LRIGHT
operator|&&
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|HASLEFT
operator|)
operator|)
condition|)
name|cost
operator|+=
name|DEFCOST
expr_stmt|;
block|}
comment|/* 	 * if reached by a gatewayed net, discourage further links. 	 * this has some relevance to common carriers and the FCC ... 	 * the penalty inheres to hosts, not aliases, nets, or domains. 	 */
if|if
condition|(
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|GATEWAYIN
operator|)
operator|&&
operator|!
name|ISADOMAIN
argument_list|(
name|prev
argument_list|)
operator|&&
operator|!
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|NNET
operator|)
condition|)
name|cost
operator|+=
name|INF
operator|/
literal|2
expr_stmt|;
comment|/* heavyweight, but appropriate */
comment|/* set left/right bits */
name|next
operator|->
name|n_flag
operator|&=
operator|~
operator|(
name|HASLEFT
operator||
name|HASRIGHT
operator|)
expr_stmt|;
if|if
condition|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LLEFT
operator|||
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|HASLEFT
operator|)
condition|)
name|next
operator|->
name|n_flag
operator||=
name|HASLEFT
expr_stmt|;
if|if
condition|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LRIGHT
operator|||
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|HASRIGHT
operator|)
condition|)
name|next
operator|->
name|n_flag
operator||=
name|HASRIGHT
expr_stmt|;
return|return
operator|(
name|cost
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|link
modifier|*
name|rmlink
parameter_list|(
name|l
parameter_list|,
name|lprev
parameter_list|,
name|n
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|,
decl|*
name|lprev
decl_stmt|;
end_function

begin_decl_stmt
name|node
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|link
modifier|*
name|lnext
decl_stmt|;
name|lnext
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|lprev
condition|)
name|lprev
operator|->
name|l_next
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
else|else
name|n
operator|->
name|n_link
operator|=
name|l
operator|->
name|l_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|lnext
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * binary heap implementation of priority queue.  * TODO: make the heap smaller by giving inserting a placeholder  * for net members when the net is extracted.  this requires storing the  * cost of a net in the net node itself -- yuck.  is it worth it?  */
end_comment

begin_function
name|STATIC
name|void
name|insert
parameter_list|(
name|l
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
name|Heap
index|[
name|n
operator|->
name|n_tloc
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Heap
index|[
name|Nheap
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: heap error in insert\n"
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Nheap
operator|++
operator|==
literal|0
condition|)
block|{
name|Heap
index|[
literal|1
index|]
operator|=
name|l
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Vflag
operator|&&
name|Nheap
operator|>
name|Heaphighwater
condition|)
name|Heaphighwater
operator|=
name|Nheap
expr_stmt|;
comment|/* diagnostics */
comment|/* insert at the end.  caller must reheap(). */
name|Heap
index|[
name|Nheap
index|]
operator|=
name|l
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|Nheap
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * replace existing link in heap by this one, then  * "percolate" up the heap by exchanging with the parent  */
end_comment

begin_function
name|STATIC
name|void
name|reheap
parameter_list|(
name|l
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|long
name|loc
decl_stmt|,
name|parent
decl_stmt|;
specifier|register
name|Cost
name|cost
decl_stmt|;
specifier|register
name|node
modifier|*
name|n
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
name|cost
operator|=
name|n
operator|->
name|n_cost
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|n
operator|->
name|n_tloc
init|;
name|loc
operator|>
literal|1
condition|;
name|loc
operator|=
name|parent
control|)
block|{
name|parent
operator|=
name|loc
operator|/
literal|2
expr_stmt|;
comment|/* sanity check on implementation */
if|if
condition|(
name|Heap
index|[
name|parent
index|]
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: heap error in insert\n"
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|np
operator|=
name|Heap
index|[
name|parent
index|]
operator|->
name|l_to
expr_stmt|;
if|if
condition|(
name|cost
operator|>
name|np
operator|->
name|n_cost
condition|)
return|return;
comment|/* move nets below hosts for output stability */
if|if
condition|(
name|cost
operator|==
name|np
operator|->
name|n_cost
operator|&&
operator|(
operator|(
name|n
operator|->
name|n_flag
operator|&
name|NNET
operator|)
operator|||
operator|!
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NNET
operator|)
operator|)
condition|)
return|return;
name|heapswap
argument_list|(
name|loc
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* extract min (== Heap[1]) from heap */
end_comment

begin_function
name|STATIC
name|link
modifier|*
name|min_node
parameter_list|()
block|{
name|link
modifier|*
name|rval
decl_stmt|;
specifier|register
name|link
modifier|*
modifier|*
name|regheap
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|,
name|child
decl_stmt|;
if|if
condition|(
name|Nheap
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|regheap
operator|=
name|Heap
expr_stmt|;
comment|/* in register -- heavily used */
name|rval
operator|=
name|regheap
index|[
literal|1
index|]
expr_stmt|;
comment|/* return this one */
comment|/* move last entry into root, percolate down */
name|regheap
index|[
literal|1
index|]
operator|=
name|regheap
index|[
name|Nheap
index|]
expr_stmt|;
name|regheap
index|[
literal|1
index|]
operator|->
name|l_to
operator|->
name|n_tloc
operator|=
literal|1
expr_stmt|;
name|regheap
index|[
name|Nheap
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|Nheap
operator|==
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* swap with smaller child down the tree */
name|child
operator|=
name|i
operator|*
literal|2
expr_stmt|;
comment|/* lhs child is 2i, rhs is 2i+1. */
if|if
condition|(
name|child
operator|>=
name|Nheap
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* use rhs child if smaller than lhs child */
if|if
condition|(
name|regheap
index|[
name|child
index|]
operator|->
name|l_to
operator|->
name|n_cost
operator|>
name|regheap
index|[
name|child
operator|+
literal|1
index|]
operator|->
name|l_to
operator|->
name|n_cost
operator|||
operator|(
name|regheap
index|[
name|child
index|]
operator|->
name|l_to
operator|->
name|n_cost
operator|==
name|regheap
index|[
name|child
operator|+
literal|1
index|]
operator|->
name|l_to
operator|->
name|n_cost
operator|&&
operator|!
name|ISANET
argument_list|(
name|regheap
index|[
name|child
operator|+
literal|1
index|]
operator|->
name|l_to
argument_list|)
operator|)
condition|)
name|child
operator|++
expr_stmt|;
if|if
condition|(
name|regheap
index|[
name|i
index|]
operator|->
name|l_to
operator|->
name|n_cost
operator|<
name|regheap
index|[
name|child
index|]
operator|->
name|l_to
operator|->
name|n_cost
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* move nets below hosts for output stability */
if|if
condition|(
name|regheap
index|[
name|i
index|]
operator|->
name|l_to
operator|->
name|n_cost
operator|==
name|regheap
index|[
name|child
index|]
operator|->
name|l_to
operator|->
name|n_cost
operator|&&
operator|(
operator|!
name|ISANET
argument_list|(
name|regheap
index|[
name|i
index|]
operator|->
name|l_to
argument_list|)
operator|||
name|ISANET
argument_list|(
name|regheap
index|[
name|child
index|]
operator|->
name|l_to
argument_list|)
operator|)
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|heapswap
argument_list|(
name|i
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|i
operator|=
name|child
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* exchange Heap[i] and Heap[j] pointers */
end_comment

begin_function
name|STATIC
name|void
name|heapswap
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
specifier|register
name|link
modifier|*
name|temp
decl_stmt|,
modifier|*
modifier|*
name|regheap
decl_stmt|;
name|regheap
operator|=
name|Heap
expr_stmt|;
comment|/* heavily used -- put in register */
name|temp
operator|=
name|regheap
index|[
name|i
index|]
expr_stmt|;
name|regheap
index|[
name|i
index|]
operator|=
name|regheap
index|[
name|j
index|]
expr_stmt|;
name|regheap
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
name|regheap
index|[
name|j
index|]
operator|->
name|l_to
operator|->
name|n_tloc
operator|=
name|j
expr_stmt|;
name|regheap
index|[
name|i
index|]
operator|->
name|l_to
operator|->
name|n_tloc
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return 1 if n is already de-hashed (n_tloc< Hashpart), 0 o.w. */
end_comment

begin_expr_stmt
name|dehash
argument_list|(
name|n
argument_list|)
specifier|register
name|node
operator|*
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|->
name|n_tloc
operator|<
name|Hashpart
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* swap with entry in Table[Hashpart] */
name|Table
index|[
name|Hashpart
index|]
operator|->
name|n_tloc
operator|=
name|n
operator|->
name|n_tloc
expr_stmt|;
name|Table
index|[
name|n
operator|->
name|n_tloc
index|]
operator|=
name|Table
index|[
name|Hashpart
index|]
expr_stmt|;
name|Table
index|[
name|Hashpart
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|Hashpart
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|backlinks
argument_list|()
end_macro

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|;
name|node
modifier|*
name|n
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|nomap
decl_stmt|;
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|Hashpart
init|;
name|i
operator|<
name|Tabsize
condition|;
name|i
operator|++
control|)
block|{
name|nomap
operator|=
name|Table
index|[
name|i
index|]
expr_stmt|;
name|parent
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|nomap
operator|->
name|n_link
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|l_next
control|)
block|{
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|n_flag
operator|&
name|MAPPED
operator|)
condition|)
continue|continue;
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
block|{
name|parent
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|->
name|n_cost
operator|>
name|parent
operator|->
name|n_cost
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|n_cost
operator|==
name|parent
operator|->
name|n_cost
condition|)
block|{
name|nomap
operator|->
name|n_parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|tiebreaker
argument_list|(
name|nomap
argument_list|,
name|n
argument_list|)
condition|)
continue|continue;
block|}
name|parent
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|dehash
argument_list|(
name|nomap
argument_list|)
expr_stmt|;
name|l
operator|=
name|addlink
argument_list|(
name|parent
argument_list|,
name|nomap
argument_list|,
name|INF
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|nomap
operator|->
name|n_parent
operator|=
name|parent
expr_stmt|;
name|nomap
operator|->
name|n_cost
operator|=
name|costof
argument_list|(
name|parent
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|reheap
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d backlinks\n"
argument_list|,
name|Nheap
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

