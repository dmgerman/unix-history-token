begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)addlink.c	8.1 (down!honey) 86/01/19"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_decl_stmt
specifier|static
name|link
modifier|*
name|Trace
index|[
name|NTRACE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Tracecount
decl_stmt|;
end_decl_stmt

begin_function
name|link
modifier|*
name|addlink
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cost
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|;
specifier|register
name|node
modifier|*
name|to
decl_stmt|;
name|Cost
name|cost
decl_stmt|;
name|char
name|netchar
decl_stmt|;
name|char
name|netdir
decl_stmt|;
block|{
specifier|register
name|link
modifier|*
name|l
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Tflag
condition|)
name|ltrace
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|cost
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|)
expr_stmt|;
comment|/* maintain uniqueness for dead links (only) */
for|for
control|(
name|l
operator|=
name|from
operator|->
name|n_link
init|;
name|l
operator|&&
name|l
operator|->
name|l_flag
operator|&
name|LDEAD
condition|;
name|l
operator|=
name|l
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|to
operator|==
name|l
operator|->
name|l_to
condition|)
block|{
comment|/* what the hell, use cheaper cost */
if|if
condition|(
name|cost
operator|<
name|l
operator|->
name|l_cost
condition|)
block|{
name|l
operator|->
name|l_cost
operator|=
name|cost
expr_stmt|;
name|netbits
argument_list|(
name|l
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
name|prev
operator|=
name|l
expr_stmt|;
block|}
comment|/* allocate and link in the new link struct */
name|l
operator|=
name|newlink
argument_list|()
expr_stmt|;
if|if
condition|(
name|cost
operator|!=
name|INF
condition|)
comment|/* ignore back links */
name|Lcount
operator|++
expr_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|l
operator|->
name|l_next
operator|=
name|prev
operator|->
name|l_next
expr_stmt|;
name|prev
operator|->
name|l_next
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
name|l
operator|->
name|l_next
operator|=
name|from
operator|->
name|n_link
expr_stmt|;
name|from
operator|->
name|n_link
operator|=
name|l
expr_stmt|;
block|}
name|l
operator|->
name|l_to
operator|=
name|to
expr_stmt|;
name|l
operator|->
name|l_cost
operator|=
name|cost
expr_stmt|;
if|if
condition|(
name|netchar
operator|==
literal|0
condition|)
block|{
name|netchar
operator|=
name|DEFNET
expr_stmt|;
name|netdir
operator|=
name|DEFDIR
expr_stmt|;
block|}
name|netbits
argument_list|(
name|l
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_function
name|link
modifier|*
name|addgateway
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cost
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|;
name|node
modifier|*
name|to
decl_stmt|;
name|Cost
name|cost
decl_stmt|;
name|char
name|netchar
decl_stmt|;
name|char
name|netdir
decl_stmt|;
block|{
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|addlink
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|cost
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|LGATEWAY
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_macro
name|deadlink
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|t
decl_stmt|,
name|c
decl_stmt|;
name|link
modifier|*
name|l
decl_stmt|;
name|t
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|c
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|addlink
argument_list|(
name|addnode
argument_list|(
name|s
argument_list|)
argument_list|,
name|addnode
argument_list|(
name|t
operator|+
literal|1
argument_list|)
argument_list|,
name|INF
operator|/
literal|2
argument_list|,
name|c
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
name|LDEAD
expr_stmt|;
block|}
else|else
name|addnode
argument_list|(
name|s
argument_list|)
operator|->
name|n_flag
operator||=
name|NDEAD
expr_stmt|;
block|}
end_block

begin_macro
name|netbits
argument_list|(
argument|l
argument_list|,
argument|netchar
argument_list|,
argument|netdir
argument_list|)
end_macro

begin_decl_stmt
name|link
modifier|*
name|l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netchar
decl_stmt|,
name|netdir
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|nptr
decl_stmt|;
if|if
condition|(
operator|(
name|nptr
operator|=
name|index
argument_list|(
name|Netchars
argument_list|,
name|netchar
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown network operator: %c\n"
argument_list|,
name|ProgName
argument_list|,
name|netchar
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|l
operator|->
name|l_flag
operator|&=
operator|~
operator|(
name|LNETCHARS
operator||
name|LDIR
operator|)
expr_stmt|;
name|l
operator|->
name|l_flag
operator||=
operator|(
name|nptr
operator|-
name|Netchars
operator|)
operator||
name|dirbits
argument_list|(
name|netdir
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tracelink
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|bang
decl_stmt|;
name|link
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|Tracecount
operator|>=
name|NTRACE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|l
operator|=
name|newlink
argument_list|()
expr_stmt|;
name|bang
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bang
condition|)
block|{
operator|*
name|bang
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|l_to
operator|=
name|addnode
argument_list|(
name|bang
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|l
operator|->
name|l_to
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|l_from
operator|=
operator|(
name|link
operator|*
operator|)
name|addnode
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|Trace
index|[
name|Tracecount
operator|++
index|]
operator|=
name|l
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|STATIC
name|ltrace
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cost
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|Cost
name|cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netdir
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Tracecount
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|Trace
index|[
name|i
index|]
expr_stmt|;
comment|/* overkill -- you asked for it! */
if|if
condition|(
operator|(
name|l
operator|->
name|l_to
operator|==
literal|0
operator|&&
operator|(
name|from
operator|==
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|||
name|to
operator|==
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|)
operator|)
operator|||
operator|(
name|from
operator|==
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|&&
name|to
operator|==
name|l
operator|->
name|l_to
operator|)
operator|||
operator|(
name|to
operator|==
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|&&
name|from
operator|==
name|l
operator|->
name|l_to
operator|)
condition|)
block|{
name|ltrprint
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|cost
argument_list|,
name|netchar
argument_list|,
name|netdir
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/* print a trace item */
end_comment

begin_function
name|STATIC
name|ltrprint
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|cost
parameter_list|,
name|netchar
parameter_list|,
name|netdir
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|Cost
name|cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netdir
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|bptr
init|=
name|buf
decl_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|from
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|strlen
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
operator|*
name|bptr
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|netdir
operator|==
name|LRIGHT
condition|)
comment|/* @% */
operator|*
name|bptr
operator|++
operator|=
name|netchar
expr_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|to
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|strlen
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netdir
operator|==
name|LLEFT
condition|)
comment|/* !: */
operator|*
name|bptr
operator|++
operator|=
name|netchar
expr_stmt|;
name|sprintf
argument_list|(
name|bptr
argument_list|,
literal|"(%ld)"
argument_list|,
name|cost
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|atrace
argument_list|(
argument|n1
argument_list|,
argument|n2
argument_list|)
end_macro

begin_decl_stmt
name|node
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|link
modifier|*
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Tracecount
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|Trace
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|l_to
operator|==
literal|0
operator|&&
operator|(
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|==
name|n1
operator|||
operator|(
name|node
operator|*
operator|)
name|l
operator|->
name|l_from
operator|==
name|n2
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s = %s"
argument_list|,
name|n1
operator|->
name|n_name
argument_list|,
name|n2
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

end_unit

