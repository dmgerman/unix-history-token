begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tags file maker to go with GNUmacs    Copyright (C) 1984, 1987, 1988 Free Software Foundation, Inc. and Ken Arnold  			   NO WARRANTY    BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC, RICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M. STALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY WHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS PROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.  		GENERAL PUBLIC LICENSE TO COPY    1. You may copy and distribute verbatim copies of this source file as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy a valid copyright notice "Copyright (C) 1986 Free Software Foundation"; and include following the copyright notice a verbatim copy of the above disclaimer of warranty and of this License.    2. You may modify your copy or copies of this source file or any portion of it, and copy and distribute such modifications under the terms of Paragraph 1 above, provided that you also do the following:      a) cause the modified files to carry prominent notices stating     that you changed the files and the date of any change; and      b) cause the whole of any work that you distribute or publish,     that in whole or in part contains or is a derivative of this     program or any part thereof, to be licensed at no charge to all     third parties on terms identical to those contained in this     License Agreement (except that you may choose to grant more extensive     warranty protection to some or all third parties, at your option).      c) You may charge a distribution fee for the physical act of     transferring a copy, and you may at your option offer warranty     protection in exchange for a fee.  Mere aggregation of another unrelated program with this program (or its derivative) on a volume of a storage or distribution medium does not bring the other program under the scope of these terms.    3. You may copy and distribute this program (or a portion or derivative of it, under Paragraph 2) in object code or executable form under the terms of Paragraphs 1 and 2 above provided that you also do one of the following:      a) accompany it with the complete corresponding machine-readable     source code, which must be distributed under the terms of     Paragraphs 1 and 2 above; or,      b) accompany it with a written offer, valid for at least three     years, to give any third party free (except for a nominal     shipping charge) a complete machine-readable copy of the     corresponding source code, to be distributed under the terms of     Paragraphs 1 and 2 above; or,      c) accompany it with the information you received as to where the     corresponding source code may be obtained.  (This alternative is     allowed only for noncommercial distribution and only if you     received the program in object code or executable form alone.)  For an executable file, complete source code means all the source code for all modules it contains; but, as a special exception, it need not include source code for modules which are standard libraries that accompany the operating system on which the executable file runs.    4. You may not copy, sublicense, distribute or transfer this program except as expressly provided under this License Agreement.  Any attempt otherwise to copy, sublicense, distribute or transfer this program is void and your rights to use the program under this License agreement shall be automatically terminated.  However, parties who have received computer software programs from you with this License Agreement will not have their licenses terminated so long as such parties remain in full compliance.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Define the symbol ETAGS to make the program "etags",  which makes emacs-style tag tables by default.  Define CTAGS to make the program "ctags" compatible with the usual one.  Define neither one to get behavior that depends  on the name with which the program is invoked  (but we don't normally compile it that way).  */
end_comment

begin_comment
comment|/* On VMS, CTAGS is not useful, so always do ETAGS.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ETAGS
end_ifndef

begin_define
define|#
directive|define
name|ETAGS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Exit codes for success and failure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|GOOD
value|(1)
end_define

begin_define
define|#
directive|define
name|BAD
value|(0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GOOD
value|(0)
end_define

begin_define
define|#
directive|define
name|BAD
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_define
define|#
directive|define
name|logical
value|char
end_define

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|arg
parameter_list|)
value|(_wht[arg])
end_define

begin_comment
comment|/* T if char is white		*/
end_comment

begin_define
define|#
directive|define
name|begtoken
parameter_list|(
name|arg
parameter_list|)
value|(_btk[arg])
end_define

begin_comment
comment|/* T if char can start token	*/
end_comment

begin_define
define|#
directive|define
name|intoken
parameter_list|(
name|arg
parameter_list|)
value|(_itk[arg])
end_define

begin_comment
comment|/* T if char can be in token	*/
end_comment

begin_define
define|#
directive|define
name|endtoken
parameter_list|(
name|arg
parameter_list|)
value|(_etk[arg])
end_define

begin_comment
comment|/* T if char ends tokens	*/
end_comment

begin_define
define|#
directive|define
name|isgood
parameter_list|(
name|arg
parameter_list|)
value|(_gd[arg])
end_define

begin_comment
comment|/* T if char can be after ')'	*/
end_comment

begin_define
define|#
directive|define
name|max
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
value|(I1> I2 ? I1 : I2)
end_define

begin_comment
comment|/* cause token checking for typedef, struct, union, enum to distinguish    keywords from identifier-prefixes (e.g. struct vs struct_tag).  */
end_comment

begin_define
define|#
directive|define
name|istoken
parameter_list|(
name|s
parameter_list|,
name|tok
parameter_list|,
name|len
parameter_list|)
value|(!strncmp(s,tok,len)&& endtoken(*((s)+(len))))
end_define

begin_struct
struct|struct
name|nd_st
block|{
comment|/* sorting structure			*/
name|char
modifier|*
name|name
decl_stmt|;
comment|/* function or type name	*/
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file name			*/
name|logical
name|f
decl_stmt|;
comment|/* use pattern or line no	*/
name|int
name|lno
decl_stmt|;
comment|/* line number tag is on	*/
name|long
name|cno
decl_stmt|;
comment|/* character number line starts on */
name|char
modifier|*
name|pat
decl_stmt|;
comment|/* search pattern		*/
name|logical
name|been_warned
decl_stmt|;
comment|/* set if noticed dup		*/
name|struct
name|nd_st
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* left and right sons		*/
block|}
struct|;
end_struct

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|struct
name|nd_st
name|NODE
typedef|;
end_typedef

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tokens found so far on line starting with # (including #) */
end_comment

begin_decl_stmt
name|logical
name|gotone
decl_stmt|,
comment|/* found a func already on line	*/
comment|/* boolean "func" (see init)	*/
name|_wht
index|[
literal|0177
index|]
decl_stmt|,
name|_etk
index|[
literal|0177
index|]
decl_stmt|,
name|_itk
index|[
literal|0177
index|]
decl_stmt|,
name|_btk
index|[
literal|0177
index|]
decl_stmt|,
name|_gd
index|[
literal|0177
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* typedefs are recognized using a simple finite automata, 	 * tydef is its state variable. 	 */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|none
block|,
name|begin
block|,
name|tag_ok
block|,
name|middle
block|,
name|end
block|}
name|TYST
typedef|;
end_typedef

begin_decl_stmt
name|TYST
name|tydef
init|=
name|none
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|searchar
init|=
literal|'/'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use /.../ searches 		*/
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current line */
end_comment

begin_decl_stmt
name|long
name|charno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current character number */
end_comment

begin_decl_stmt
name|long
name|linecharno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character number of start of line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|curfile
decl_stmt|,
comment|/* current input file name		*/
modifier|*
name|outfile
init|=
literal|0
decl_stmt|,
comment|/* output file				*/
modifier|*
name|white
init|=
literal|" \f\t\n"
decl_stmt|,
comment|/* white chars				*/
modifier|*
name|endtk
init|=
literal|" \t\n\"'#()[]{}=-+%*/&|^~!<>;,.:?"
decl_stmt|,
comment|/* token ending chars			*/
modifier|*
name|begtk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz$"
decl_stmt|,
comment|/* token starting chars			*/
modifier|*
name|intk
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz$0123456789"
decl_stmt|,
comment|/* valid in-token chars			*/
modifier|*
name|notgd
init|=
literal|",;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-valid after-function chars	*/
end_comment

begin_decl_stmt
name|int
name|file_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current file number			*/
end_comment

begin_decl_stmt
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a: append to tags */
end_comment

begin_decl_stmt
name|int
name|tflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t: create tags for typedefs */
end_comment

begin_decl_stmt
name|int
name|uflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -u: update tags */
end_comment

begin_decl_stmt
name|int
name|wflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w: suppress warnings */
end_comment

begin_decl_stmt
name|int
name|vflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -v: create vgrind style index output */
end_comment

begin_decl_stmt
name|int
name|xflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -x: create cxref style output */
end_comment

begin_decl_stmt
name|int
name|eflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -e: emacs style output */
end_comment

begin_comment
comment|/* Name this program was invoked with.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|inf
decl_stmt|,
comment|/* ioptr for current input file		*/
modifier|*
name|outf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ioptr for tags file			*/
end_comment

begin_decl_stmt
name|NODE
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the head of the sorted binary tree	*/
end_comment

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|savenstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|initbuffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|readline
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* A `struct linebuffer' is a structure which holds a line of text.  `readline' reads a line from a stream into a linebuffer  and works regardless of the length of the line.  */
end_comment

begin_struct
struct|struct
name|linebuffer
block|{
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|linebuffer
name|lb
decl_stmt|,
name|lb1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* VMS now provides the `system' function.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_endif
unit|void system (buf)      char *buf; {   struct dsc$descriptor_s command =     {       strlen(buf), DSC$K_DTYPE_T, DSC$K_CLASS_S, buf     };    LIB$SPAWN(&command); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fflag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|this_file
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|char
name|got_err
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gfnames
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|massage_name
parameter_list|()
function_decl|;
endif|#
directive|endif
name|progname
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|ETAGS
name|eflag
operator|=
literal|1
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|CTAGS
name|eflag
operator|=
literal|0
expr_stmt|;
else|#
directive|else
block|{
name|char
modifier|*
name|subname
init|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|subname
operator|++
operator|==
name|NULL
condition|)
name|subname
operator|=
name|progname
expr_stmt|;
name|eflag
operator|=
operator|!
name|strcmp
argument_list|(
name|subname
argument_list|,
literal|"ctags"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
while|while
condition|(
name|ac
operator|>
literal|1
operator|&&
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|av
index|[
literal|1
index|]
index|[
name|i
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|VMS
comment|/* These options are useful only with ctags, 		and VMS can't input them, so just omit them.  */
case|case
literal|'B'
case|:
name|searchar
operator|=
literal|'?'
expr_stmt|;
name|eflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|searchar
operator|=
literal|'/'
expr_stmt|;
name|eflag
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'a'
case|:
name|aflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|eflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|fflag
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -f flag may only be given once\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|fflag
operator|++
operator|,
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
if|if
condition|(
name|ac
operator|<=
literal|1
operator|||
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -f flag must be followed by a filename\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|outfile
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|end_loop
goto|;
case|case
literal|'t'
case|:
name|tflag
operator|++
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|VMS
case|case
literal|'u'
case|:
name|uflag
operator|++
expr_stmt|;
name|eflag
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'w'
case|:
name|wflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vflag
operator|++
expr_stmt|;
name|xflag
operator|++
expr_stmt|;
name|eflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
name|eflag
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
block|}
name|end_loop
label|:
empty_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|<=
literal|1
condition|)
block|{
name|usage
label|:
ifdef|#
directive|ifdef
name|VMS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-aetwvx] [-f outfile] file ...\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-BFaetuwvx] [-f outfile] file ...\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
block|{
name|outfile
operator|=
name|eflag
condition|?
literal|"TAGS"
else|:
literal|"tags"
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
comment|/* set up boolean "functions"		*/
name|initbuffer
argument_list|(
operator|&
name|lb
argument_list|)
expr_stmt|;
name|initbuffer
argument_list|(
operator|&
name|lb1
argument_list|)
expr_stmt|;
comment|/*    * loop through files finding functions    */
if|if
condition|(
name|eflag
condition|)
block|{
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|aflag
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outf
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
block|}
name|file_num
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
for|for
control|(
name|ac
operator|--
operator|,
name|av
operator|++
init|;
operator|(
name|this_file
operator|=
name|gfnames
argument_list|(
operator|&
name|ac
argument_list|,
operator|&
name|av
argument_list|,
operator|&
name|got_err
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|file_num
operator|++
control|)
block|{
if|if
condition|(
name|got_err
condition|)
block|{
name|error
argument_list|(
literal|"Can't find file %s\n"
argument_list|,
name|this_file
argument_list|)
expr_stmt|;
name|ac
operator|--
operator|,
name|av
operator|++
expr_stmt|;
block|}
else|else
block|{
name|this_file
operator|=
name|massage_name
argument_list|(
name|this_file
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
init|;
name|file_num
operator|<
name|ac
condition|;
name|file_num
operator|++
control|)
block|{
name|this_file
operator|=
name|av
index|[
name|file_num
index|]
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
name|find_entries
argument_list|(
name|this_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"\f\n%s,%d\n"
argument_list|,
name|this_file
argument_list|,
name|total_size_of_entries
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|eflag
condition|)
block|{
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xflag
condition|)
block|{
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"mv %s OTAGS;fgrep -v '\t%s\t' OTAGS>%s;rm OTAGS"
argument_list|,
name|outfile
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|aflag
operator|++
expr_stmt|;
block|}
name|outf
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|aflag
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|uflag
condition|)
block|{
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"sort %s -o %s"
argument_list|,
name|outfile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
comment|/*  * This routine sets up the boolean psuedo-functions which work  * by seting boolean flags dependent upon the corresponding character  * Every char which is NOT in that string is not a white char.  Therefore,  * all of the array "_wht" is set to FALSE, and then the elements  * subscripted by the chars in "white" are set to TRUE.  Thus "_wht"  * of a char is TRUE if it is the string "white", else FALSE.  */
name|init
argument_list|()
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0177
condition|;
name|i
operator|++
control|)
block|{
name|_wht
index|[
name|i
index|]
operator|=
name|_etk
index|[
name|i
index|]
operator|=
name|_itk
index|[
name|i
index|]
operator|=
name|_btk
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|_gd
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|white
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_wht
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|endtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_etk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|intk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_itk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|begtk
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_btk
index|[
operator|*
name|sp
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|notgd
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
name|_gd
index|[
operator|*
name|sp
index|]
operator|=
name|FALSE
expr_stmt|;
name|_wht
index|[
literal|0
index|]
operator|=
name|_wht
index|[
literal|'\n'
index|]
expr_stmt|;
name|_etk
index|[
literal|0
index|]
operator|=
name|_etk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_btk
index|[
literal|0
index|]
operator|=
name|_btk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_itk
index|[
literal|0
index|]
operator|=
name|_itk
index|[
literal|'\n'
index|]
expr_stmt|;
name|_gd
index|[
literal|0
index|]
operator|=
name|_gd
index|[
literal|'\n'
index|]
expr_stmt|;
block|}
comment|/*  * This routine opens the specified file and calls the function  * which finds the function and type definitions.  */
name|find_entries
argument_list|(
argument|file
argument_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|curfile
operator|=
name|savestr
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* .tex, .aux or .bbl implies LaTeX source code */
if|if
condition|(
name|cp
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"tex"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"aux"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"bbl"
argument_list|)
operator|)
condition|)
block|{
name|TEX_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* .l or .el or .lisp (or .cl or .clisp or ...) implies lisp source code */
if|if
condition|(
name|cp
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"l"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"el"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"lsp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"lisp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"cl"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"clisp"
argument_list|)
operator|)
condition|)
block|{
name|L_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* .scm or .sm or .scheme implies scheme source code */
if|if
condition|(
name|cp
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"sm"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"scm"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"scheme"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"t"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"sch"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"SM"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"SCM"
argument_list|)
comment|/* The `SCM' or `scm' prefix with a version number */
operator|||
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'m'
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|cp
index|[
operator|-
literal|3
index|]
operator|==
literal|'s'
operator|)
operator|||
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'M'
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'C'
operator|&&
name|cp
index|[
operator|-
literal|3
index|]
operator|==
literal|'S'
operator|)
operator|)
condition|)
block|{
name|Scheme_funcs
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if not a .c or .h or .y file, try fortran */
if|if
condition|(
name|cp
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|'c'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'h'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'y'
operator|)
operator|&&
name|cp
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|PF_funcs
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
name|rewind
argument_list|(
name|inf
argument_list|)
expr_stmt|;
comment|/* no fortran tags found, try C */
block|}
name|C_entries
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
comment|/* Record a tag on the current line.   name is the tag name,   f is nonzero to use a pattern, zero to use line number instead. */
name|pfnote
argument_list|(
argument|name
argument_list|,
argument|f
argument_list|,
argument|linestart
argument_list|,
argument|linelen
argument_list|,
argument|lno
argument_list|,
argument|cno
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|logical
name|f
decl_stmt|;
comment|/* f == TRUE when function */
name|char
modifier|*
name|linestart
decl_stmt|;
name|int
name|linelen
decl_stmt|;
name|int
name|lno
decl_stmt|;
name|long
name|cno
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|altname
decl_stmt|;
name|char
name|tem
index|[
literal|51
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: too many entries to sort\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|put_entries
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free_tree
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
operator|(
name|NODE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Change name "main" to M<thisfilename>. */
if|if
condition|(
operator|!
name|eflag
operator|&&
operator|!
name|xflag
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|rindex
argument_list|(
name|curfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
name|fp
operator|=
name|curfile
expr_stmt|;
else|else
name|fp
operator|++
expr_stmt|;
name|altname
operator|=
name|concat
argument_list|(
literal|"M"
argument_list|,
name|fp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fp
operator|=
name|rindex
argument_list|(
name|altname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|&&
name|fp
index|[
literal|2
index|]
operator|==
literal|0
condition|)
operator|*
name|fp
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|altname
expr_stmt|;
block|}
name|np
operator|->
name|name
operator|=
name|savestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|file
operator|=
name|curfile
expr_stmt|;
name|np
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|np
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|np
operator|->
name|cno
operator|=
name|cno
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|np
operator|->
name|right
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
name|linestart
index|[
name|linelen
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xflag
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|tem
argument_list|,
name|strlen
argument_list|(
name|linestart
argument_list|)
operator|<
literal|50
condition|?
literal|"%s$"
else|:
literal|"%.50s"
argument_list|,
name|linestart
argument_list|)
expr_stmt|;
name|linestart
operator|=
name|tem
expr_stmt|;
block|}
name|np
operator|->
name|pat
operator|=
name|savestr
argument_list|(
name|linestart
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|np
expr_stmt|;
else|else
name|add_node
argument_list|(
name|np
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
name|free_tree
argument_list|(
argument|node
argument_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
while|while
condition|(
name|node
condition|)
block|{
name|free_tree
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
block|}
block|}
name|add_node
argument_list|(
argument|node
argument_list|,
argument|cur_node
argument_list|)
name|NODE
modifier|*
name|node
decl_stmt|,
modifier|*
name|cur_node
decl_stmt|;
block|{
specifier|register
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|strcmp
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|cur_node
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If this tag name matches an existing one, then      unless -e was given, do not add the node, but maybe print a warning */
if|if
condition|(
operator|!
name|eflag
operator|&&
operator|!
name|dif
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|file
operator|==
name|cur_node
operator|->
name|file
condition|)
block|{
if|if
condition|(
operator|!
name|wflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Duplicate entry in file %s, line %d: %s\n"
argument_list|,
name|progname
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|lineno
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Second entry ignored\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|cur_node
operator|->
name|been_warned
condition|)
if|if
condition|(
operator|!
name|wflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Duplicate entry in files %s and %s: %s (Warning only)\n"
argument_list|,
name|progname
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|cur_node
operator|->
name|file
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|cur_node
operator|->
name|been_warned
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/* Actually add the node */
if|if
condition|(
name|dif
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cur_node
operator|->
name|left
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|left
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|left
operator|=
name|node
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cur_node
operator|->
name|right
operator|!=
name|NULL
condition|)
name|add_node
argument_list|(
name|node
argument_list|,
name|cur_node
operator|->
name|right
argument_list|)
expr_stmt|;
else|else
name|cur_node
operator|->
name|right
operator|=
name|node
expr_stmt|;
block|}
name|put_entries
argument_list|(
argument|node
argument_list|)
name|reg
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|reg
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
comment|/* Output subentries that precede this one */
name|put_entries
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* Output this entry */
if|if
condition|(
name|eflag
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s%c%d,%d\n"
argument_list|,
name|node
operator|->
name|pat
argument_list|,
literal|0177
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xflag
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%s\t%s\t"
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|f
condition|)
block|{
comment|/* a function */
name|putc
argument_list|(
name|searchar
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'^'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|node
operator|->
name|pat
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
operator|||
operator|*
name|sp
operator|==
name|searchar
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|sp
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|searchar
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* a typedef; text pattern inadequate */
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%d"
argument_list|,
name|node
operator|->
name|lno
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vflag
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s %d\n"
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|file
argument_list|,
operator|(
name|node
operator|->
name|lno
operator|+
literal|63
operator|)
operator|/
literal|64
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-16s%4d %-16s %s\n"
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|node
operator|->
name|lno
argument_list|,
name|node
operator|->
name|file
argument_list|,
name|node
operator|->
name|pat
argument_list|)
expr_stmt|;
comment|/* Output subentries that follow this one */
name|put_entries
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
comment|/* Return total number of characters that put_entries will output for  the nodes in the subtree of the specified node.  Works only if eflag is set, but called only in that case.  */
name|total_size_of_entries
argument_list|(
argument|node
argument_list|)
name|reg
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|reg
name|int
name|total
init|=
literal|0
decl_stmt|;
name|reg
name|long
name|num
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Count subentries that precede this one */
name|total
operator|=
name|total_size_of_entries
argument_list|(
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* Count subentries that follow this one */
name|total
operator|+=
name|total_size_of_entries
argument_list|(
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
comment|/* Count this entry */
name|total
operator|+=
name|strlen
argument_list|(
name|node
operator|->
name|pat
argument_list|)
operator|+
literal|3
expr_stmt|;
name|num
operator|=
name|node
operator|->
name|lno
expr_stmt|;
while|while
condition|(
name|num
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|num
operator|/=
literal|10
expr_stmt|;
block|}
name|num
operator|=
name|node
operator|->
name|cno
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
name|total
operator|++
expr_stmt|;
while|while
condition|(
name|num
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|num
operator|/=
literal|10
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/*  * This routine finds functions and typedefs in C syntax and adds them  * to the list.  */
ifdef|#
directive|ifdef
name|VMS
name|long
name|vmslinecharno
decl_stmt|;
define|#
directive|define
name|VMS_SET_LINECHARNO
value|(vmslinecharno = ftell(inf))
else|#
directive|else
define|#
directive|define
name|VMS_SET_LINECHARNO
endif|#
directive|endif
define|#
directive|define
name|CNL_SAVE_NUMBER
define|\
value|{ \   VMS_SET_LINECHARNO; \   linecharno = charno; lineno++; \   charno += 1 + readline (&lb, inf); \   lp = lb.buffer; \ }
define|#
directive|define
name|CNL
define|\
value|{ \   CNL_SAVE_NUMBER; \   number = 0; \ }
name|C_entries
argument_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|token
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|logical
name|incomm
decl_stmt|,
name|inquote
decl_stmt|,
name|inchar
decl_stmt|,
name|midtoken
decl_stmt|;
name|int
name|level
decl_stmt|;
name|char
name|tok
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|gotone
operator|=
name|midtoken
operator|=
name|inquote
operator|=
name|inchar
operator|=
name|incomm
operator|=
name|FALSE
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|CNL
expr_stmt|;
name|gotone
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|CNL_SAVE_NUMBER
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|incomm
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|==
literal|'*'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|CNL
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|incomm
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|inquote
condition|)
block|{
comment|/* 	  * Too dumb to know about \" not being magic, but 	  * they usually occur in pairs anyway. 	  */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|inquote
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inchar
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inchar
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|inquote
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
name|inchar
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|'*'
condition|)
block|{
name|lp
operator|++
expr_stmt|;
name|incomm
operator|=
name|TRUE
expr_stmt|;
block|}
continue|continue;
case|case
literal|'#'
case|:
if|if
condition|(
name|lp
operator|==
name|lb
operator|.
name|buffer
operator|+
literal|1
condition|)
name|number
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'{'
case|:
if|if
condition|(
name|tydef
operator|==
name|tag_ok
condition|)
block|{
name|tydef
operator|=
name|middle
expr_stmt|;
block|}
name|level
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'}'
case|:
if|if
condition|(
name|lp
operator|==
name|lb
operator|.
name|buffer
operator|+
literal|1
condition|)
name|level
operator|=
literal|0
expr_stmt|;
comment|/* reset */
else|else
name|level
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|level
operator|&&
name|tydef
operator|==
name|middle
condition|)
block|{
name|tydef
operator|=
name|end
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|level
operator|&&
operator|!
name|inquote
operator|&&
operator|!
name|incomm
operator|&&
name|gotone
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|midtoken
condition|)
block|{
if|if
condition|(
name|endtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|lb
operator|.
name|buffer
decl_stmt|;
name|int
name|endpos
init|=
name|lp
operator|-
name|lb
operator|.
name|buffer
decl_stmt|;
name|char
modifier|*
name|lp1
init|=
name|lp
decl_stmt|;
name|int
name|line
init|=
name|lineno
decl_stmt|;
name|long
name|linestart
init|=
name|linecharno
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|long
name|vmslinestart
init|=
name|vmslinecharno
decl_stmt|;
endif|#
directive|endif
name|int
name|tem
init|=
name|consider_token
argument_list|(
operator|&
name|lp1
argument_list|,
name|token
argument_list|,
operator|&
name|f
argument_list|,
name|level
argument_list|)
decl_stmt|;
name|lp
operator|=
name|lp1
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|linestart
operator|!=
name|linecharno
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|getline
argument_list|(
name|vmslinestart
argument_list|)
expr_stmt|;
else|#
directive|else
name|getline
argument_list|(
name|linestart
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
name|tok
argument_list|,
name|token
operator|+
operator|(
name|lb1
operator|.
name|buffer
operator|-
name|buf
operator|)
argument_list|,
name|tp
operator|-
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tok
index|[
name|tp
operator|-
name|token
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|f
argument_list|,
name|lb1
operator|.
name|buffer
argument_list|,
name|endpos
argument_list|,
name|line
argument_list|,
name|linestart
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|tok
argument_list|,
name|token
argument_list|,
name|tp
operator|-
name|token
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tok
index|[
name|tp
operator|-
name|token
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pfnote
argument_list|(
name|tok
argument_list|,
name|f
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|endpos
argument_list|,
name|line
argument_list|,
name|linestart
argument_list|)
expr_stmt|;
block|}
name|gotone
operator|=
name|f
expr_stmt|;
comment|/* function */
block|}
name|midtoken
operator|=
name|FALSE
expr_stmt|;
name|token
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intoken
argument_list|(
name|c
argument_list|)
condition|)
name|tp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|token
operator|=
name|tp
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
name|midtoken
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|';'
operator|&&
name|tydef
operator|==
name|end
condition|)
comment|/* clean with typedefs */
name|tydef
operator|=
name|none
expr_stmt|;
block|}
block|}
comment|/*  * This routine  checks to see if the current token is  * at the start of a function, or corresponds to a typedef  * It updates the input line * so that the '(' will be  * in it when it returns.  */
name|consider_token
argument_list|(
argument|lpp
argument_list|,
argument|token
argument_list|,
argument|f
argument_list|,
argument|level
argument_list|)
name|char
modifier|*
modifier|*
name|lpp
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|int
modifier|*
name|f
decl_stmt|,
name|level
decl_stmt|;
block|{
name|reg
name|char
modifier|*
name|lp
init|=
operator|*
name|lpp
decl_stmt|;
name|reg
name|char
name|c
decl_stmt|;
specifier|static
name|logical
name|next_token_is_func
decl_stmt|;
name|logical
name|firsttok
decl_stmt|;
comment|/* T if have seen first token in ()'s */
name|int
name|bad
decl_stmt|,
name|win
decl_stmt|;
operator|*
name|f
operator|=
literal|1
expr_stmt|;
comment|/* a function */
name|c
operator|=
name|lp
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|number
condition|)
block|{
comment|/* space is not allowed in macro defs	*/
while|while
condition|(
name|iswhite
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
break|break;
name|CNL
expr_stmt|;
block|}
block|}
comment|/* the following tries to make it so that a #define a b(c)	*/
comment|/* doesn't count as a define of b.				*/
block|}
else|else
block|{
name|number
operator|++
expr_stmt|;
if|if
condition|(
name|number
operator|>=
literal|4
operator|||
operator|(
name|number
operator|==
literal|2
operator|&&
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"define"
argument_list|,
literal|6
argument_list|)
operator|)
condition|)
block|{
name|gotone
operator|=
name|TRUE
expr_stmt|;
name|badone
label|:
name|bad
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
comment|/* check for the typedef cases		*/
if|if
condition|(
name|tflag
operator|&&
name|istoken
argument_list|(
name|token
argument_list|,
literal|"typedef"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|tydef
operator|=
name|begin
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|begin
operator|&&
operator|(
name|istoken
argument_list|(
name|token
argument_list|,
literal|"struct"
argument_list|,
literal|6
argument_list|)
operator|||
name|istoken
argument_list|(
name|token
argument_list|,
literal|"union"
argument_list|,
literal|5
argument_list|)
operator|||
name|istoken
argument_list|(
name|token
argument_list|,
literal|"enum"
argument_list|,
literal|4
argument_list|)
operator|)
condition|)
block|{
name|tydef
operator|=
name|tag_ok
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|tag_ok
condition|)
block|{
name|tydef
operator|=
name|middle
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|begin
condition|)
comment|/* e.g. typedef ->int<- */
block|{
name|tydef
operator|=
name|end
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|tydef
operator|==
name|middle
operator|&&
name|level
operator|==
literal|0
condition|)
comment|/* e.g. typedef struct tag ->struct_t<- */
block|{
name|tydef
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|tydef
operator|==
name|end
condition|)
block|{
operator|*
name|f
operator|=
literal|0
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Detect GNUmacs's function-defining macros. */
if|if
condition|(
operator|!
name|number
operator|&&
operator|!
name|strncmp
argument_list|(
name|token
argument_list|,
literal|"DEF"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|next_token_is_func
operator|=
literal|1
expr_stmt|;
goto|goto
name|badone
goto|;
block|}
if|if
condition|(
name|next_token_is_func
condition|)
block|{
name|next_token_is_func
operator|=
literal|0
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
goto|goto
name|badone
goto|;
name|firsttok
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
break|break;
name|CNL
expr_stmt|;
block|}
comment|/* 	* This line used to confuse ctags: 	*	int	(*oldhup)(); 	* This fixes it. A nonwhite char before the first 	* token, other than a / (in case of a comment in there) 	* makes this not a declaration. 	*/
if|if
condition|(
name|begtoken
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'/'
condition|)
name|firsttok
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|iswhite
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|firsttok
condition|)
goto|goto
name|badone
goto|;
block|}
while|while
condition|(
name|iswhite
argument_list|(
name|c
operator|=
operator|*
name|lp
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
break|break;
name|CNL
expr_stmt|;
block|}
block|}
name|win
operator|=
name|isgood
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ret
label|:
operator|*
name|lpp
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
return|return
operator|!
name|bad
operator|&&
name|win
return|;
block|}
name|getline
argument_list|(
argument|atchar
argument_list|)
name|long
name|atchar
decl_stmt|;
block|{
name|long
name|saveftell
init|=
name|ftell
argument_list|(
name|inf
argument_list|)
decl_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|atchar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|readline
argument_list|(
operator|&
name|lb1
argument_list|,
name|inf
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|inf
argument_list|,
name|saveftell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Fortran parsing */
name|char
modifier|*
name|dbp
decl_stmt|;
name|int
name|pfcnt
decl_stmt|;
name|PF_funcs
argument_list|(
argument|fi
argument_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|'%'
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Ratfor escape to fortran */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"integer"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"real"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"logical"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"complex"
argument_list|)
operator|||
name|tail
argument_list|(
literal|"character"
argument_list|)
condition|)
name|takeprec
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tail
argument_list|(
literal|"precision"
argument_list|)
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
operator|*
name|dbp
operator||
literal|' '
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"function"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"subroutine"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
if|if
condition|(
name|tail
argument_list|(
literal|"program"
argument_list|)
condition|)
block|{
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tail
argument_list|(
literal|"procedure"
argument_list|)
condition|)
name|getit
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|pfcnt
operator|)
return|;
block|}
name|tail
argument_list|(
argument|cp
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|&
operator|~
literal|' '
operator|)
operator|==
operator|(
operator|(
operator|*
operator|(
name|dbp
operator|+
name|len
operator|)
operator|)
operator|&
operator|~
literal|' '
operator|)
condition|)
name|cp
operator|++
operator|,
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|dbp
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|takeprec
argument_list|()
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|!=
literal|'*'
condition|)
return|return;
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
block|{
operator|--
name|dbp
expr_stmt|;
comment|/* force failure */
return|return;
block|}
do|do
name|dbp
operator|++
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
do|;
block|}
name|getit
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
operator|||
operator|!
name|isalpha
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/*  * lisp tag functions  * just look for (def or (DEF  */
name|L_funcs
argument_list|(
argument|fi
argument_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|L_getit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|L_getit
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
continue|continue;
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/*  * Scheme tag functions  * look for (def... xyzzy  * look for (def... (xyzzy  * look for (def ... ((...(xyzzy ....  * look for (set! xyzzy  */
specifier|static
name|get_scheme
argument_list|()
expr_stmt|;
name|Scheme_funcs
argument_list|(
argument|fi
argument_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Skip over open parens and white space */
while|while
condition|(
operator|*
name|dbp
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
operator|||
operator|*
name|dbp
operator|==
literal|'('
operator|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|get_scheme
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dbp
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|dbp
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|dbp
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|dbp
index|[
literal|2
index|]
operator|==
literal|'e'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|3
index|]
operator|==
literal|'T'
operator|||
name|dbp
index|[
literal|3
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|dbp
index|[
literal|4
index|]
operator|==
literal|'!'
operator|||
name|dbp
index|[
literal|4
index|]
operator|==
literal|'!'
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|dbp
index|[
literal|5
index|]
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
comment|/* Skip over white space */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
name|dbp
operator|++
expr_stmt|;
name|get_scheme
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|get_scheme
argument_list|()
block|{
specifier|register
name|char
operator|*
name|cp
block|;
name|char
name|c
block|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
block|;
if|if
condition|(
operator|*
name|dbp
operator|==
literal|0
condition|)
return|return;
comment|/* Go till you get to white space or a syntactic break */
for|for
control|(
name|cp
operator|=
name|dbp
operator|+
literal|1
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
comment|/* Null terminate the string there. */
name|c
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Copy the string */
name|strcpy
argument_list|(
name|nambuf
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
comment|/* Unterminate the string */
name|cp
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* Announce the change */
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|cp
operator|-
name|lb
operator|.
name|buffer
operator|+
literal|1
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/* Find tags in TeX and LaTeX input files.  */
comment|/* TEX_toktab is a table of TeX control sequences that define tags.    Each TEX_tabent records one such control sequence.  */
struct|struct
name|TEX_tabent
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
name|struct
name|TEX_tabent
modifier|*
name|TEX_toktab
init|=
name|NULL
decl_stmt|;
comment|/* Table with tag tokens */
comment|/* Default set of control sequences to put into TEX_toktab.    The value of environment var TEXTAGS is prepended to this.  */
specifier|static
name|char
modifier|*
name|TEX_defenv
init|=
literal|":chapter:section:subsection:subsubsection:eqno:label:ref:cite:bibitem:typeout"
decl_stmt|;
name|struct
name|TEX_tabent
modifier|*
name|TEX_decode_env
parameter_list|()
function_decl|;
specifier|static
name|char
name|TEX_esc
init|=
literal|'\\'
decl_stmt|;
specifier|static
name|char
name|TEX_opgrp
init|=
literal|'{'
decl_stmt|;
specifier|static
name|char
name|TEX_clgrp
init|=
literal|'}'
decl_stmt|;
comment|/*  * TeX/LaTeX scanning loop.  */
name|TEX_funcs
argument_list|(
argument|fi
argument_list|)
name|FILE
modifier|*
name|fi
decl_stmt|;
block|{
name|char
modifier|*
name|lasthit
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|charno
operator|=
literal|0
expr_stmt|;
name|pfcnt
operator|=
literal|0
expr_stmt|;
comment|/* Select either \ or ! as escape character.  */
name|TEX_mode
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* Initialize token table once from environment. */
if|if
condition|(
operator|!
name|TEX_toktab
condition|)
name|TEX_toktab
operator|=
name|TEX_decode_env
argument_list|(
literal|"TEXTAGS"
argument_list|,
name|TEX_defenv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
name|lasthit
operator|=
name|dbp
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fi
argument_list|)
condition|)
block|{
comment|/* Scan each line in file */
name|lineno
operator|++
expr_stmt|;
name|linecharno
operator|=
name|charno
expr_stmt|;
name|charno
operator|+=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|fi
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dbp
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
name|lasthit
operator|=
name|dbp
expr_stmt|;
while|while
condition|(
name|dbp
operator|=
name|index
argument_list|(
name|dbp
argument_list|,
name|TEX_esc
argument_list|)
condition|)
comment|/* Look at each escape in line */
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|*
operator|(
operator|++
name|dbp
operator|)
condition|)
break|break;
name|linecharno
operator|+=
name|dbp
operator|-
name|lasthit
expr_stmt|;
name|lasthit
operator|=
name|dbp
expr_stmt|;
name|i
operator|=
name|TEX_Token
argument_list|(
name|lasthit
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|i
condition|)
block|{
name|TEX_getit
argument_list|(
name|lasthit
argument_list|,
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
comment|/* We only save a line once */
block|}
block|}
block|}
block|}
block|}
define|#
directive|define
name|TEX_LESC
value|'\\'
define|#
directive|define
name|TEX_SESC
value|'!'
comment|/* Figure out whether TeX's escapechar is '\\' or '!' and set grouping */
comment|/* chars accordingly. */
name|TEX_mode
argument_list|(
argument|f
argument_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|c
operator|==
name|TEX_LESC
operator|||
name|c
operator|==
name|TEX_SESC
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|TEX_LESC
condition|)
block|{
name|TEX_esc
operator|=
name|TEX_LESC
expr_stmt|;
name|TEX_opgrp
operator|=
literal|'{'
expr_stmt|;
name|TEX_clgrp
operator|=
literal|'}'
expr_stmt|;
block|}
else|else
block|{
name|TEX_esc
operator|=
name|TEX_SESC
expr_stmt|;
name|TEX_opgrp
operator|=
literal|'<'
expr_stmt|;
name|TEX_clgrp
operator|=
literal|'>'
expr_stmt|;
block|}
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Read environment and prepend it to the default string. */
comment|/* Build token table. */
name|struct
name|TEX_tabent
modifier|*
name|TEX_decode_env
parameter_list|(
name|evarname
parameter_list|,
name|defenv
parameter_list|)
name|char
modifier|*
name|evarname
decl_stmt|;
name|char
modifier|*
name|defenv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|savenstr
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|struct
name|TEX_tabent
modifier|*
name|tab
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
comment|/* Append deafult string to environment. */
name|env
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
name|evarname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
name|env
operator|=
name|defenv
expr_stmt|;
else|else
name|env
operator|=
name|concat
argument_list|(
name|env
argument_list|,
name|defenv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Allocate a token table */
for|for
control|(
name|size
operator|=
literal|1
operator|,
name|p
operator|=
name|env
init|;
name|p
condition|;
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|*
operator|(
operator|++
name|p
operator|)
condition|)
name|size
operator|++
expr_stmt|;
name|tab
operator|=
operator|(
expr|struct
name|TEX_tabent
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|TEX_tabent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unpack environment string into token table. Be careful about */
comment|/* zero-length strings (leading ':', "::" and trailing ':') */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|env
condition|;
control|)
block|{
name|p
operator|=
name|index
argument_list|(
name|env
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
comment|/* End of environment string. */
name|p
operator|=
name|env
operator|+
name|strlen
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|env
operator|>
literal|0
condition|)
block|{
comment|/* Only non-zero strings. */
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|=
name|savenstr
argument_list|(
name|env
argument_list|,
name|p
operator|-
name|env
argument_list|)
expr_stmt|;
name|tab
index|[
name|i
index|]
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|tab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
condition|)
name|env
operator|=
name|p
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* Mark end of table. */
name|tab
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|tab
return|;
block|}
comment|/* Record a tag defined by a TeX command of length LEN and starting at NAME.    The name being defined actually starts at (NAME + LEN + 1).    But we seem to include the TeX command in the tag name.  */
name|TEX_getit
argument_list|(
argument|name
argument_list|,
argument|len
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|name
operator|+
name|len
decl_stmt|;
name|char
name|nambuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|0
condition|)
return|return;
comment|/* Let tag name extend to next group close (or end of line) */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
name|TEX_clgrp
condition|)
name|p
operator|++
expr_stmt|;
name|strncpy
argument_list|(
name|nambuf
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|nambuf
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|0
expr_stmt|;
name|pfnote
argument_list|(
name|nambuf
argument_list|,
name|TRUE
argument_list|,
name|lb
operator|.
name|buffer
argument_list|,
name|strlen
argument_list|(
name|lb
operator|.
name|buffer
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|linecharno
argument_list|)
expr_stmt|;
name|pfcnt
operator|++
expr_stmt|;
block|}
comment|/* If the text at CP matches one of the tag-defining TeX command names,    return the index of that command in TEX_toktab.    Otherwise return -1.  */
comment|/* Keep the capital `T' in `Token' for dumb truncating compilers    (this distinguishes it from `TEX_toktab' */
name|TEX_Token
argument_list|(
argument|cp
argument_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|cp
argument_list|,
name|TEX_toktab
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Initialize a linebuffer for use */
name|void
name|initbuffer
parameter_list|(
name|linebuffer
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
block|{
name|linebuffer
operator|->
name|size
operator|=
literal|200
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
comment|/* Read a line of text from `stream' into `linebuffer'.  Return the length of the line.  */
name|long
name|readline
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
specifier|register
name|char
modifier|*
name|pend
init|=
name|p
operator|+
name|linebuffer
operator|->
name|size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
block|{
name|linebuffer
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|linebuffer
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|pend
operator|=
name|buffer
operator|+
name|linebuffer
operator|->
name|size
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
name|char
modifier|*
name|savestr
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
return|return
name|savenstr
argument_list|(
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
return|;
block|}
name|char
modifier|*
name|savenstr
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dp
return|;
block|}
comment|/*  * Return the ptr in sp at which the character c last  * appears; NULL if not found  *  * Identical to v7 rindex, included for portability.  */
name|char
modifier|*
name|rindex
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|sp
operator|++
condition|)
do|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/*  * Return the ptr in sp at which the character c first  * appears; NULL if not found  *  * Identical to v7 index, included for portability.  */
name|char
modifier|*
name|index
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|c
condition|)
return|return
operator|(
name|sp
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|sp
operator|++
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Print error message and exit.  */
name|fatal
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Like malloc but get fatal error if memory is exhausted.  */
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

