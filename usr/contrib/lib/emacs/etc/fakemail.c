begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sendmail-like interface to /bin/mail for system V,    Copyright (C) 1985 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_define
define|#
directive|define
name|NO_SHORTNAMES
end_define

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD4_1
argument_list|)
end_if

begin_comment
comment|/* This program isnot used in BSD, so just avoid loader complaints.  */
end_comment

begin_function
name|main
parameter_list|()
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not BSD 4.2 (or newer) */
end_comment

begin_comment
comment|/* This conditional contains all the rest of the file.  */
end_comment

begin_comment
comment|/* These are defined in config in some versions. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|static
end_ifdef

begin_undef
undef|#
directive|undef
name|static
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|read
end_ifdef

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Type definitions */
end_comment

begin_define
define|#
directive|define
name|boolean
value|int
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_comment
comment|/* Various lists */
end_comment

begin_struct
struct|struct
name|line_record
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|line_record
modifier|*
name|continuation
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|line_record
modifier|*
name|line_list
typedef|;
end_typedef

begin_struct
struct|struct
name|header_record
block|{
name|line_list
name|text
decl_stmt|;
name|struct
name|header_record
modifier|*
name|next
decl_stmt|;
name|struct
name|header_record
modifier|*
name|previous
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|header_record
modifier|*
name|header
typedef|;
end_typedef

begin_struct
struct|struct
name|stream_record
block|{
name|FILE
modifier|*
name|handle
decl_stmt|;
name|int
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|stream_record
modifier|*
name|rest_streams
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|stream_record
modifier|*
name|stream_list
typedef|;
end_typedef

begin_comment
comment|/* A `struct linebuffer' is a structure which holds a line of text.  * `readline' reads a line from a stream into a linebuffer  * and works regardless of the length of the line.  */
end_comment

begin_struct
struct|struct
name|linebuffer
block|{
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|linebuffer
name|lb
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|new_list
parameter_list|()
define|\
value|((line_list) xmalloc (sizeof (struct line_record)))
end_define

begin_define
define|#
directive|define
name|new_header
parameter_list|()
define|\
value|((header) xmalloc (sizeof (struct header_record)))
end_define

begin_define
define|#
directive|define
name|new_stream
parameter_list|()
define|\
value|((stream_list) xmalloc (sizeof (struct stream_record)))
end_define

begin_define
define|#
directive|define
name|alloc_string
parameter_list|(
name|nchars
parameter_list|)
define|\
value|((char *) xmalloc ((nchars) + 1))
end_define

begin_escape
end_escape

begin_comment
comment|/* Global declarations */
end_comment

begin_define
define|#
directive|define
name|BUFLEN
value|1024
end_define

begin_define
define|#
directive|define
name|KEYWORD_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|FROM_PREFIX
value|"From"
end_define

begin_define
define|#
directive|define
name|MY_NAME
value|"fakemail"
end_define

begin_define
define|#
directive|define
name|NIL
value|((line_list) NULL)
end_define

begin_define
define|#
directive|define
name|INITIAL_LINE_SIZE
value|200
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAIL_PROGRAM_NAME
end_ifndef

begin_define
define|#
directive|define
name|MAIL_PROGRAM_NAME
value|"/bin/mail"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|my_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|the_date
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|the_user
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|line_list
name|file_preface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|stream_list
name|the_streams
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|no_problems
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|fclose
argument_list|()
decl_stmt|,
name|pclose
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CURRENT_USER
end_ifdef

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|short
name|geteuid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|passwd
modifier|*
name|my_entry
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cuserid
parameter_list|(
name|s
parameter_list|)
define|\
value|(my_entry = getpwuid (((int) geteuid ())),	\  my_entry->pw_name)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Utilities */
end_comment

begin_comment
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|no_problems
operator|=
name|false
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|malloc
argument_list|(
operator|(
operator|(
name|unsigned
operator|)
name|size
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|size
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize a linebuffer for use */
end_comment

begin_function
name|void
name|init_linebuffer
parameter_list|(
name|linebuffer
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
block|{
name|linebuffer
operator|->
name|size
operator|=
name|INITIAL_LINE_SIZE
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|INITIAL_LINE_SIZE
argument_list|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a line of text from `stream' into `linebuffer'.  * Return the length of the line.    */
end_comment

begin_function
name|long
name|readline
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|linebuffer
operator|->
name|size
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
name|linebuffer
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|linebuffer
operator|->
name|size
argument_list|)
operator|)
expr_stmt|;
name|p
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|end
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|get_keyword
parameter_list|(
name|field
parameter_list|,
name|rest
parameter_list|)
specifier|register
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
modifier|*
name|rest
decl_stmt|;
block|{
specifier|static
name|char
name|keyword
index|[
name|KEYWORD_SIZE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|ptr
operator|=
operator|&
name|keyword
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|=
operator|*
name|field
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|':'
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
operator|*
name|ptr
operator|++
operator|=
operator|(
operator|(
name|islower
argument_list|(
name|c
argument_list|)
operator|)
condition|?
operator|(
name|toupper
argument_list|(
name|c
argument_list|)
operator|)
else|:
name|c
operator|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|field
operator|++
operator|)
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|!
operator|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|)
operator|)
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|(
operator|(
name|islower
argument_list|(
name|c
argument_list|)
operator|)
condition|?
operator|(
name|toupper
argument_list|(
name|c
argument_list|)
operator|)
else|:
name|c
operator|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
name|field
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
operator|*
name|rest
operator|=
name|field
expr_stmt|;
return|return
operator|&
name|keyword
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|boolean
name|has_keyword
parameter_list|(
name|field
parameter_list|)
name|char
modifier|*
name|field
decl_stmt|;
block|{
name|char
modifier|*
name|ignored
decl_stmt|;
return|return
operator|(
name|get_keyword
argument_list|(
name|field
argument_list|,
operator|&
name|ignored
argument_list|)
operator|!=
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|add_field
parameter_list|(
name|the_list
parameter_list|,
name|field
parameter_list|,
name|where
parameter_list|)
name|line_list
name|the_list
decl_stmt|;
specifier|register
name|char
modifier|*
name|field
decl_stmt|,
decl|*
name|where
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
operator|*
name|where
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|field
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|where
operator|++
operator|=
operator|(
operator|(
name|c
operator|==
literal|','
operator|)
condition|?
literal|' '
else|:
name|c
operator|)
expr_stmt|;
if|if
condition|(
name|the_list
operator|==
name|NIL
condition|)
break|break;
name|field
operator|=
name|the_list
operator|->
name|string
expr_stmt|;
name|the_list
operator|=
name|the_list
operator|->
name|continuation
expr_stmt|;
block|}
return|return
name|where
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|line_list
name|make_file_preface
parameter_list|()
block|{
name|char
modifier|*
name|the_string
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|long
name|idiotic_interface
decl_stmt|;
name|long
name|prefix_length
decl_stmt|;
name|long
name|user_length
decl_stmt|;
name|long
name|date_length
decl_stmt|;
name|line_list
name|result
decl_stmt|;
name|prefix_length
operator|=
name|strlen
argument_list|(
name|FROM_PREFIX
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|idiotic_interface
argument_list|)
expr_stmt|;
name|the_date
operator|=
name|ctime
argument_list|(
operator|&
name|idiotic_interface
argument_list|)
expr_stmt|;
comment|/* the_date has an unwanted newline at the end */
name|date_length
operator|=
name|strlen
argument_list|(
name|the_date
argument_list|)
operator|-
literal|1
expr_stmt|;
name|the_date
index|[
name|date_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|cuserid
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|user_length
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|the_user
operator|=
name|alloc_string
argument_list|(
name|user_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_user
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|the_string
operator|=
name|alloc_string
argument_list|(
literal|3
operator|+
name|prefix_length
operator|+
name|user_length
operator|+
name|date_length
argument_list|)
expr_stmt|;
name|temp
operator|=
name|the_string
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|FROM_PREFIX
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|&
name|temp
index|[
name|prefix_length
index|]
expr_stmt|;
operator|*
name|temp
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|the_user
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|&
name|temp
index|[
name|user_length
index|]
expr_stmt|;
operator|*
name|temp
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|the_date
argument_list|)
expr_stmt|;
name|result
operator|=
name|new_list
argument_list|()
expr_stmt|;
name|result
operator|->
name|string
operator|=
name|the_string
expr_stmt|;
name|result
operator|->
name|continuation
operator|=
operator|(
operator|(
name|line_list
operator|)
name|NULL
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|write_line_list
parameter_list|(
name|the_list
parameter_list|,
name|the_stream
parameter_list|)
specifier|register
name|line_list
name|the_list
decl_stmt|;
name|FILE
modifier|*
name|the_stream
decl_stmt|;
block|{
for|for
control|(
init|;
name|the_list
operator|!=
operator|(
operator|(
name|line_list
operator|)
name|NULL
operator|)
condition|;
name|the_list
operator|=
name|the_list
operator|->
name|continuation
control|)
block|{
name|fputs
argument_list|(
name|the_list
operator|->
name|string
argument_list|,
name|the_stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|the_stream
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|close_the_streams
parameter_list|()
block|{
specifier|register
name|stream_list
name|rem
decl_stmt|;
for|for
control|(
name|rem
operator|=
name|the_streams
init|;
name|rem
operator|!=
operator|(
operator|(
name|stream_list
operator|)
name|NULL
operator|)
condition|;
name|rem
operator|=
name|rem
operator|->
name|rest_streams
control|)
name|no_problems
operator|=
operator|(
name|no_problems
operator|&&
operator|(
call|(
modifier|*
name|rem
operator|->
name|action
call|)
argument_list|(
name|rem
operator|->
name|handle
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
name|the_streams
operator|=
operator|(
operator|(
name|stream_list
operator|)
name|NULL
operator|)
expr_stmt|;
return|return
operator|(
name|no_problems
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|void
name|add_a_stream
argument_list|(
name|the_stream
argument_list|,
name|closing_action
argument_list|)
name|FILE
modifier|*
name|the_stream
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|closing_action
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|stream_list
name|old
init|=
name|the_streams
decl_stmt|;
name|the_streams
operator|=
name|new_stream
argument_list|()
expr_stmt|;
name|the_streams
operator|->
name|handle
operator|=
name|the_stream
expr_stmt|;
name|the_streams
operator|->
name|action
operator|=
name|closing_action
expr_stmt|;
name|the_streams
operator|->
name|rest_streams
operator|=
name|old
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|int
name|my_fclose
parameter_list|(
name|the_file
parameter_list|)
name|FILE
modifier|*
name|the_file
decl_stmt|;
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|the_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|the_file
argument_list|)
expr_stmt|;
return|return
name|fclose
argument_list|(
name|the_file
argument_list|)
return|;
block|}
end_function

begin_function
name|boolean
name|open_a_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|the_stream
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"a"
argument_list|)
decl_stmt|;
if|if
condition|(
name|the_stream
operator|!=
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|add_a_stream
argument_list|(
name|the_stream
argument_list|,
name|my_fclose
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_user
operator|==
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
name|file_preface
operator|=
name|make_file_preface
argument_list|()
expr_stmt|;
name|write_line_list
argument_list|(
name|file_preface
argument_list|,
name|the_stream
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|put_string
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|stream_list
name|rem
decl_stmt|;
for|for
control|(
name|rem
operator|=
name|the_streams
init|;
name|rem
operator|!=
operator|(
operator|(
name|stream_list
operator|)
name|NULL
operator|)
condition|;
name|rem
operator|=
name|rem
operator|->
name|rest_streams
control|)
name|fputs
argument_list|(
name|s
argument_list|,
name|rem
operator|->
name|handle
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|put_line
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|stream_list
name|rem
decl_stmt|;
for|for
control|(
name|rem
operator|=
name|the_streams
init|;
name|rem
operator|!=
operator|(
operator|(
name|stream_list
operator|)
name|NULL
operator|)
condition|;
name|rem
operator|=
name|rem
operator|->
name|rest_streams
control|)
block|{
name|fputs
argument_list|(
name|s
argument_list|,
name|rem
operator|->
name|handle
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|rem
operator|->
name|handle
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|mail_error
value|error
end_define

begin_function
name|void
name|setup_files
parameter_list|(
name|the_list
parameter_list|,
name|field
parameter_list|)
specifier|register
name|line_list
name|the_list
decl_stmt|;
specifier|register
name|char
modifier|*
name|field
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|start
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|field
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|','
operator|)
operator|)
condition|)
name|field
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|start
operator|=
name|field
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|field
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|','
operator|)
condition|)
name|field
operator|+=
literal|1
expr_stmt|;
operator|*
name|field
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|open_a_file
argument_list|(
name|start
argument_list|)
condition|)
name|mail_error
argument_list|(
literal|"Could not open file %s"
argument_list|,
name|start
argument_list|)
expr_stmt|;
operator|*
name|field
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
continue|continue;
block|}
if|if
condition|(
name|the_list
operator|==
operator|(
operator|(
name|line_list
operator|)
name|NULL
operator|)
condition|)
return|return;
name|field
operator|=
name|the_list
operator|->
name|string
expr_stmt|;
name|the_list
operator|=
name|the_list
operator|->
name|continuation
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|args_size
parameter_list|(
name|the_header
parameter_list|)
name|header
name|the_header
decl_stmt|;
block|{
specifier|register
name|header
name|old
init|=
name|the_header
decl_stmt|;
specifier|register
name|line_list
name|rem
decl_stmt|;
specifier|register
name|int
name|size
init|=
literal|0
decl_stmt|;
do|do
block|{
name|char
modifier|*
name|field
decl_stmt|;
specifier|register
name|char
modifier|*
name|keyword
init|=
name|get_keyword
argument_list|(
name|the_header
operator|->
name|text
operator|->
name|string
argument_list|,
operator|&
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"TO"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"CC"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"BCC"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|field
argument_list|)
expr_stmt|;
for|for
control|(
name|rem
operator|=
name|the_header
operator|->
name|text
operator|->
name|continuation
init|;
name|rem
operator|!=
name|NIL
condition|;
name|rem
operator|=
name|rem
operator|->
name|continuation
control|)
name|size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|rem
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|the_header
operator|=
name|the_header
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|the_header
operator|!=
name|old
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_macro
name|parse_header
argument_list|(
argument|the_header
argument_list|,
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|header
name|the_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|header
name|old
init|=
name|the_header
decl_stmt|;
do|do
block|{
name|char
modifier|*
name|field
decl_stmt|;
specifier|register
name|char
modifier|*
name|keyword
init|=
name|get_keyword
argument_list|(
name|the_header
operator|->
name|text
operator|->
name|string
argument_list|,
operator|&
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"TO"
argument_list|)
operator|==
literal|0
condition|)
name|where
operator|=
name|add_field
argument_list|(
name|the_header
operator|->
name|text
operator|->
name|continuation
argument_list|,
name|field
argument_list|,
name|where
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"CC"
argument_list|)
operator|==
literal|0
condition|)
name|where
operator|=
name|add_field
argument_list|(
name|the_header
operator|->
name|text
operator|->
name|continuation
argument_list|,
name|field
argument_list|,
name|where
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"BCC"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|where
operator|=
name|add_field
argument_list|(
name|the_header
operator|->
name|text
operator|->
name|continuation
argument_list|,
name|field
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|the_header
operator|->
name|previous
operator|->
name|next
operator|=
name|the_header
operator|->
name|next
expr_stmt|;
name|the_header
operator|->
name|next
operator|->
name|previous
operator|=
name|the_header
operator|->
name|previous
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
argument_list|,
literal|"FCC"
argument_list|)
operator|==
literal|0
condition|)
name|setup_files
argument_list|(
name|the_header
operator|->
name|text
operator|->
name|continuation
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|the_header
operator|=
name|the_header
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|the_header
operator|!=
name|old
condition|)
do|;
operator|*
name|where
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_function
name|header
name|read_header
parameter_list|()
block|{
specifier|register
name|header
name|the_header
init|=
operator|(
operator|(
name|header
operator|)
name|NULL
operator|)
decl_stmt|;
specifier|register
name|line_list
modifier|*
name|next_line
init|=
operator|(
operator|(
name|line_list
operator|*
operator|)
name|NULL
operator|)
decl_stmt|;
name|init_linebuffer
argument_list|(
operator|&
name|lb
argument_list|)
expr_stmt|;
do|do
block|{
name|long
name|length
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|line
operator|=
name|lb
operator|.
name|buffer
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|has_keyword
argument_list|(
name|line
argument_list|)
condition|)
block|{
specifier|register
name|header
name|old
init|=
name|the_header
decl_stmt|;
name|the_header
operator|=
name|new_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|(
operator|(
name|header
operator|)
name|NULL
operator|)
condition|)
block|{
name|the_header
operator|->
name|next
operator|=
name|the_header
expr_stmt|;
name|the_header
operator|->
name|previous
operator|=
name|the_header
expr_stmt|;
block|}
else|else
block|{
name|the_header
operator|->
name|previous
operator|=
name|old
expr_stmt|;
name|the_header
operator|->
name|next
operator|=
name|old
operator|->
name|next
expr_stmt|;
name|old
operator|->
name|next
operator|=
name|the_header
expr_stmt|;
block|}
name|next_line
operator|=
operator|&
operator|(
name|the_header
operator|->
name|text
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|next_line
operator|==
operator|(
operator|(
name|line_list
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
comment|/* Not a valid header */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|next_line
operator|=
name|new_list
argument_list|()
expr_stmt|;
operator|(
operator|*
name|next_line
operator|)
operator|->
name|string
operator|=
name|alloc_string
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
operator|(
operator|*
name|next_line
operator|)
operator|->
name|string
operator|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|next_line
operator|=
operator|&
operator|(
operator|(
operator|*
name|next_line
operator|)
operator|->
name|continuation
operator|)
expr_stmt|;
operator|*
name|next_line
operator|=
name|NIL
expr_stmt|;
block|}
do|while
condition|(
name|true
condition|)
do|;
return|return
name|the_header
operator|->
name|next
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|write_header
parameter_list|(
name|the_header
parameter_list|)
name|header
name|the_header
decl_stmt|;
block|{
specifier|register
name|header
name|old
init|=
name|the_header
decl_stmt|;
do|do
block|{
specifier|register
name|line_list
name|the_list
decl_stmt|;
for|for
control|(
name|the_list
operator|=
name|the_header
operator|->
name|text
init|;
name|the_list
operator|!=
name|NIL
condition|;
name|the_list
operator|=
name|the_list
operator|->
name|continuation
control|)
name|put_line
argument_list|(
name|the_list
operator|->
name|string
argument_list|)
expr_stmt|;
name|the_header
operator|=
name|the_header
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|the_header
operator|!=
name|old
condition|)
do|;
name|put_line
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|command_line
decl_stmt|;
name|header
name|the_header
decl_stmt|;
name|long
name|name_length
init|=
name|strlen
argument_list|(
name|MAIL_PROGRAM_NAME
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|BUFLEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|FILE
modifier|*
name|the_pipe
decl_stmt|;
name|my_name
operator|=
name|MY_NAME
expr_stmt|;
name|the_streams
operator|=
operator|(
operator|(
name|stream_list
operator|)
name|NULL
operator|)
expr_stmt|;
name|the_date
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
name|the_user
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
name|the_header
operator|=
name|read_header
argument_list|()
expr_stmt|;
name|command_line
operator|=
name|alloc_string
argument_list|(
name|name_length
operator|+
name|args_size
argument_list|(
name|the_header
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|command_line
argument_list|,
name|MAIL_PROGRAM_NAME
argument_list|)
expr_stmt|;
name|parse_header
argument_list|(
name|the_header
argument_list|,
operator|&
name|command_line
index|[
name|name_length
index|]
argument_list|)
expr_stmt|;
name|the_pipe
operator|=
name|popen
argument_list|(
name|command_line
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_pipe
operator|==
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
condition|)
name|fatal
argument_list|(
literal|"cannot open pipe to real mailer"
argument_list|)
expr_stmt|;
name|add_a_stream
argument_list|(
name|the_pipe
argument_list|,
name|pclose
argument_list|)
expr_stmt|;
name|write_header
argument_list|(
name|the_header
argument_list|)
expr_stmt|;
comment|/* Dump the message itself */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|size
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFLEN
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|buf
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put_string
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|close_the_streams
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD 4.2 (or newer) */
end_comment

end_unit

