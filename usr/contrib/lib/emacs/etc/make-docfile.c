begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate doc-string file for GNU Emacs from source files.    Copyright (C) 1985, 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but without any warranty.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the document "GNU Emacs copying permission notice".   An exact copy of the document is supposed to have been given to you along with GNU Emacs so that you can know how you may redistribute it all. It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* The arguments given to this program are all the C and Lisp source files  of GNU Emacs.  .elc and .el and .c files are allowed.  A .o file can also be specified; the .c file it was made from is used.  This helps the makefile pass the correct list of files.   The results, which go to standard output or to a file  specified with -a or -o (-a to append, -o to start from nothing),  are entries containing function or variable names and their documentation.  Each entry starts with a ^_ character.  Then comes F for a function or V for a variable.  Then comes the function or variable name, terminated with a newline.  Then comes the documentation for that function or variable.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|err_count
init|=
literal|0
decl_stmt|;
name|outfile
operator|=
name|stdout
expr_stmt|;
comment|/* If first two args are -o FILE, output to FILE.  */
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|>
name|i
operator|+
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-o"
argument_list|)
condition|)
block|{
name|outfile
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
name|i
operator|+
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-a"
argument_list|)
condition|)
block|{
name|outfile
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|err_count
operator|+=
name|scan_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* err_count seems to be {mis,un}used */
ifndef|#
directive|ifndef
name|VMS
name|exit
argument_list|(
name|err_count
argument_list|)
expr_stmt|;
comment|/* see below - shane */
endif|#
directive|endif
endif|VMS
block|}
end_function

begin_comment
comment|/* Read file FILENAME and output its doc strings to stdout.  */
end_comment

begin_comment
comment|/* Return 1 if file is not found, 0 if it is found.  */
end_comment

begin_macro
name|scan_file
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".elc"
argument_list|)
condition|)
return|return
name|scan_lisp_file
argument_list|(
name|filename
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".el"
argument_list|)
condition|)
return|return
name|scan_lisp_file
argument_list|(
name|filename
argument_list|)
return|;
else|else
return|return
name|scan_c_file
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Skip a C string from INFILE,  and return the character that follows the closing ".  If printflag is positive, output string contents to stdout.  If it is negative, store contents in buf.  Convert escape sequences \n and \t to newline and tab;  discard \ followed by newline.  */
end_comment

begin_macro
name|read_c_string
argument_list|(
argument|infile
argument_list|,
argument|printflag
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|printflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
name|c
operator|=
literal|'\t'
expr_stmt|;
block|}
if|if
condition|(
name|printflag
operator|>
literal|0
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|printflag
operator|<
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
break|break;
if|if
condition|(
name|printflag
operator|>
literal|0
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|printflag
operator|<
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printflag
operator|<
literal|0
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read through a c file.  If a .o file is named,  the corresponding .c file is read instead.  Looks for DEFUN constructs such as are defined in ../src/lisp.h.  Accepts any word starting DEF... so it finds DEFSIMPLE and DEFPRED.  */
end_comment

begin_macro
name|scan_c_file
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|commas
decl_stmt|;
specifier|register
name|int
name|defunflag
decl_stmt|;
specifier|register
name|int
name|defvarflag
decl_stmt|;
if|if
condition|(
name|filename
index|[
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'o'
condition|)
name|filename
index|[
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'c'
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* No error if non-ex input file */
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'D'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'E'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'F'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'V'
condition|)
continue|continue;
name|defvarflag
operator|=
literal|1
expr_stmt|;
name|defunflag
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'E'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'F'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|defunflag
operator|=
name|c
operator|==
literal|'U'
expr_stmt|;
name|defvarflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
continue|continue;
while|while
condition|(
name|c
operator|!=
literal|'('
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
continue|continue;
name|c
operator|=
name|read_c_string
argument_list|(
name|infile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|defunflag
condition|)
name|commas
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|defvarflag
condition|)
name|commas
operator|=
literal|1
expr_stmt|;
else|else
comment|/* For DEFSIMPLE and DEFPRED */
name|commas
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|commas
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|commas
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|c
operator|=
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|','
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
literal|037
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|defvarflag
condition|?
literal|'V'
else|:
literal|'F'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read a file of Lisp code, compiled or interpreted.  Looks for   (defun NAME ARGS DOCSTRING ...)   (autoload 'NAME FILE DOCSTRING ...)   (defvar NAME VALUE DOCSTRING)   (defconst NAME VALUE DOCSTRING)  starting in column zero.  ARGS, FILE or VALUE is ignored.  We do not know how to parse Lisp code  so we use a kludge to skip them:   In a function definition, the form of ARGS of FILE is known, and we   can skip it.   In a variable definition, we use a formatting convention:   the DOCSTRING, if present, must be followed by a closeparen and a newline,   and no newline must appear between the defvar or defconst and the docstring,   The only source file that must follow this convention is loaddefs.el;   aside from that, it is always the .elc file that we look at, and   they are no problem because byte-compiler output follows this convention.  The NAME and DOCSTRING are output.  NAME is preceded by `F' for a function or `V' for a variable.  An entry is output only if DOCSTRING has \ newline just after the opening "  */
end_comment

begin_macro
name|scan_lisp_file
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|commas
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|defvarflag
decl_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* No error */
block|}
name|c
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'a'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'u'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'t'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'o'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'l'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'o'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'a'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'d'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'q'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'u'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'o'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'t'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'e'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
continue|continue;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
literal|1
return|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'e'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'f'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'n'
condition|)
continue|continue;
name|defvarflag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'a'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'r'
condition|)
continue|continue;
name|defvarflag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'o'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'n'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'s'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'t'
condition|)
continue|continue;
name|defvarflag
operator|=
literal|1
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* Now we have seen "defun" or "defvar" or "defconst".  */
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Read and store name of function or variable being defined 	     Discard backslashes that are for quoting.  */
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|defvarflag
condition|)
block|{
comment|/* A function: */
comment|/* Skip the arguments: either "nil" or a list in parens */
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|c
operator|!=
literal|'('
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|')'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A variable:  */
comment|/* Skip until the first newline; remember 		 the two previous characters.  */
name|char
name|c1
init|=
literal|0
decl_stmt|,
name|c2
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
name|c1
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
comment|/* If two previous characters were " and \, 		 this is a doc string.  Otherwise, there is none.  */
if|if
condition|(
name|c2
operator|==
literal|'"'
operator|&&
name|c1
operator|==
literal|'\\'
condition|)
block|{
name|putc
argument_list|(
literal|037
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'V'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
else|else
continue|continue;
comment|/* Here for a function definition. 	 We have skipped the file name or arguments 	 and arrived at where the doc string is, 	 if there is a doc string.  */
comment|/* Skip whitespace */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* " followed by \ and newline means a doc string we should gobble */
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
name|putc
argument_list|(
literal|037
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'F'
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

end_unit

