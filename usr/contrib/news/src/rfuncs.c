begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * rfuncs - functions for readnews.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)rfuncs.c	2.29	3/19/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_decl_stmt
name|char
name|lentab
index|[
name|LINES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of newsgroupname for each rcline */
end_comment

begin_decl_stmt
name|long
name|nngsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next upcoming value of ngsize. */
end_comment

begin_decl_stmt
name|long
name|nminartno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Smallest article number in this group */
end_comment

begin_decl_stmt
name|int
name|BITMAPSIZE
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|nextng
argument_list|()
end_macro

begin_block
block|{
name|long
name|curpos
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextng()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curpos
operator|=
name|ftell
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|next
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"next:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
block|{
if|if
condition|(
name|back
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|back
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|actfp
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|nngsize
argument_list|,
operator|&
name|nminartno
argument_list|)
operator|<
literal|3
condition|)
block|{
name|bfr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nngsize
operator|=
literal|0
expr_stmt|;
name|nminartno
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bfr = '%s'\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|bfr
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|xflag
condition|)
name|readmode
operator|=
name|SPEC
expr_stmt|;
else|else
name|readmode
operator|=
name|NEXT
expr_stmt|;
if|if
condition|(
name|selectng
argument_list|(
name|bfr
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
goto|goto
name|next
goto|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|selectng
argument_list|(
argument|name
argument_list|,
argument|fastcheck
argument_list|,
argument|resubscribe
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
name|punct
init|=
literal|','
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|cur
decl_stmt|;
name|long
name|next
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|af
decl_stmt|;
name|long
name|s
decl_stmt|,
name|sm
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
name|n
index|[
literal|100
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selectng: groupdir = %s\n"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|*
name|groupdir
condition|)
name|updaterc
argument_list|()
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfr
argument_list|)
condition|)
block|{
name|af
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|af
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %ld %ld"
argument_list|,
name|n
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|sm
argument_list|)
operator|==
literal|3
operator|&&
name|strcmp
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ngsize
operator|=
name|s
expr_stmt|;
name|minartno
operator|=
name|sm
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|af
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ngsize
operator|=
name|nngsize
expr_stmt|;
name|minartno
operator|=
name|nminartno
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selectng(%s) sets ngsize to %ld, minartno to %ld\n"
argument_list|,
name|name
argument_list|,
name|ngsize
argument_list|,
name|minartno
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xflag
condition|)
block|{
name|i
operator|=
name|findrcline
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|resubscribe
condition|)
block|{
case|case
name|FALSE
case|:
name|groupdir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TRUE
case|:
operator|*
name|p
operator|=
literal|':'
expr_stmt|;
break|break;
case|case
name|PERHAPS
case|:
name|zapng
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
comment|/* shouldn't happen */
name|p
operator|=
name|rcline
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|==
literal|' '
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"%s%s%ld"
argument_list|,
name|rcline
index|[
name|i
index|]
argument_list|,
operator|*
name|p
operator|==
literal|'\0'
condition|?
literal|" "
else|:
literal|","
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"ng: %ld"
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"ng: %ld"
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rcbuf set to %s\n"
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Fast check for common case: 1-### 	 */
if|if
condition|(
name|fastcheck
condition|)
block|{
name|p
operator|=
name|rcbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'1'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'-'
condition|)
block|{
name|cur
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|cur
operator|=
literal|10
operator|*
name|cur
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
operator|&&
name|cur
operator|==
name|ngsize
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Group: %s, all read\n"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|groupdir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|cur
operator|>
name|ngsize
condition|)
block|{
comment|/* 				 * Claim to have read articles 				 * which "active" believes have 				 * never existed - we believe "active" 				 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s...\r\n\t%s %ld to %ld\r\n"
argument_list|,
literal|"Warning: newsgroup"
argument_list|,
name|groupdir
argument_list|,
literal|"last article claimed read reset from"
argument_list|,
name|cur
argument_list|,
name|ngsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  * The key to understanding this piece of code is that a bit is set iff  * that article has NOT been read.  Thus, we fill in the holes when  * commas are found (e.g. 1-20,30-35 will result in filling in the 21-29  * holes), and so we assume the newsrc file is properly ordered, the way  * we write it out.  */
if|if
condition|(
operator|(
name|ngsize
operator|-
name|minartno
operator|)
operator|>
name|BITMAPSIZE
condition|)
block|{
comment|/* This should never happen */
operator|(
name|void
operator|)
name|xerror
argument_list|(
literal|"Bitmap not large enough for newsgroup %s"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|bitmap
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ngsize
operator|-
name|minartno
argument_list|)
operator|/
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 8 bits per character */
comment|/* Decode the .newsrc line indicating what we have read. */
for|for
control|(
name|ptr
operator|=
name|rcbuf
init|;
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|':'
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
while|while
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
break|break;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|punct
operator|==
literal|','
condition|)
block|{
while|while
condition|(
operator|++
name|cur
operator|<
name|next
condition|)
block|{
name|set
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
name|cur
operator|=
name|next
expr_stmt|;
while|while
condition|(
operator|!
name|ispunct
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
name|ptr
operator|++
expr_stmt|;
name|punct
operator|=
operator|*
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|rflag
condition|)
name|bit
operator|=
name|ngsize
operator|+
literal|1
expr_stmt|;
else|else
name|bit
operator|=
name|minartno
operator|-
literal|1
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TMAIL
end_ifdef

begin_macro
name|catchterm
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The -M (Mail) interface.  This code is a reasonably simple model for  * writing other interfaces.  We write out all relevant articles to  * a temp file, then invoke Mail with an option to have it tell us which  * articles it read.  Finally we count those articles as really read.  */
end_comment

begin_macro
name|Mail
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|,
modifier|*
name|ofp
decl_stmt|;
name|struct
name|hbuf
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|int
name|news
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUNREC
condition|;
name|i
operator|++
control|)
name|h
operator|.
name|unrec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|mktemp
argument_list|(
name|outfile
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|&&
operator|*
name|datebuf
condition|)
if|if
condition|(
operator|(
name|atime
operator|=
name|cgtdate
argument_list|(
name|datebuf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|xerror
argument_list|(
literal|"Cannot parse date string"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|nextng
argument_list|()
condition|)
while|while
condition|(
name|bit
operator|<=
name|ngsize
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%ld"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
literal|4
argument_list|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|!
name|aselect
argument_list|(
operator|&
name|h
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad article '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|fname
operator|=
name|ptr
operator|=
name|index
argument_list|(
name|h
operator|.
name|from
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
while|while
condition|(
name|ptr
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|--
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
name|fname
operator|++
expr_stmt|;
name|ptr
operator|=
name|fname
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|')'
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
name|h
operator|.
name|subtime
operator|=
name|cgtdate
argument_list|(
name|h
operator|.
name|subdate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"From %s %s"
argument_list|,
ifdef|#
directive|ifdef
name|INTERNET
name|h
operator|.
name|from
index|[
literal|0
index|]
condition|?
name|h
operator|.
name|from
else|:
endif|#
directive|endif
name|h
operator|.
name|path
argument_list|,
name|ctime
argument_list|(
operator|&
name|h
operator|.
name|subtime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Full-Name: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|h
operator|.
name|nbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|h
operator|.
name|title
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article-ID: %s/%ld\n\n"
argument_list|,
name|groupdir
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|fp
argument_list|,
name|ofp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|news
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
block|}
name|updaterc
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|news
condition|)
block|{
if|if
condition|(
operator|!
name|checkngs
argument_list|()
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No news.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catchterm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|catchterm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s -f %s -T %s"
argument_list|,
name|TMAIL
argument_list|,
name|outfile
argument_list|,
name|mktemp
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|ushell
argument_list|,
name|bfr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|actfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|nngsize
argument_list|)
operator|<
literal|2
condition|)
block|{
name|bfr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nngsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|bfr
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
condition|)
continue|continue;
operator|*
name|groupdir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|selectng
argument_list|(
name|bfr
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ofp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|groupdir
argument_list|,
name|BUFLEN
argument_list|,
name|ofp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|nstrip
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|groupdir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|updaterc
argument_list|()
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|updaterc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|long
name|cur
init|=
literal|1
decl_stmt|,
name|next
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|oldptr
decl_stmt|;
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"%s%c "
argument_list|,
name|groupdir
argument_list|,
name|zapng
condition|?
literal|'!'
else|:
literal|':'
argument_list|)
expr_stmt|;
name|zapng
operator|=
name|FALSE
expr_stmt|;
name|again
label|:
name|ptr
operator|=
operator|&
name|rcbuf
index|[
name|strlen
argument_list|(
name|rcbuf
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|get
argument_list|(
name|next
argument_list|)
operator|&&
name|next
operator|<=
name|ngsize
condition|)
name|next
operator|++
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|get
argument_list|(
name|next
argument_list|)
operator|)
operator|&&
name|next
operator|<=
name|ngsize
condition|)
name|next
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|next
condition|)
block|{
name|next
operator|=
name|ngsize
operator|+
literal|1
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|cur
operator|+
literal|1
operator|==
name|next
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%ld"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%ld-%ld"
argument_list|,
name|cur
argument_list|,
name|next
operator|-
literal|1
argument_list|)
expr_stmt|;
name|skip
label|:
if|if
condition|(
operator|(
name|long
operator|)
name|next
operator|>
name|ngsize
condition|)
block|{
if|if
condition|(
name|strpbrk
argument_list|(
name|rcbuf
argument_list|,
literal|":!"
argument_list|)
operator|==
name|NULL
condition|)
comment|/* bad line, huh?? */
return|return;
name|ptr
operator|=
name|index
argument_list|(
name|rcbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
comment|/* impossible */
return|return;
name|ptr
operator|--
expr_stmt|;
name|oldptr
operator|=
operator|*
name|ptr
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|findrcline
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|ptr
index|[
literal|0
index|]
operator|=
name|oldptr
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|rcline
index|[
name|i
index|]
operator|=
name|realloc
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|rcbuf
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcline
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot realloc"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" new rcline = %s\n"
argument_list|,
name|rcline
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
if|if
condition|(
operator|++
name|line
operator|>
name|LINES
condition|)
name|xerror
argument_list|(
literal|"Too many newsgroups"
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|oldptr
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|rcline
index|[
name|line
index|]
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|rcbuf
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rcline
index|[
name|line
index|]
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" new rcline2 = %s\n"
argument_list|,
name|rcline
index|[
name|line
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
name|cur
operator|=
name|next
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_block

begin_macro
name|newrc
argument_list|(
argument|rcname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|rcname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|close
argument_list|(
name|creat
argument_list|(
name|rcname
argument_list|,
literal|0666
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Cannot create %s"
argument_list|,
name|newsrc
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/users"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bfr
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|bfr
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|nextbit
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextbit() bit = %ld\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|last
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|readmode
operator|==
name|SPEC
operator|||
name|xflag
condition|)
block|{
if|if
condition|(
name|rflag
condition|)
name|bit
operator|--
expr_stmt|;
else|else
name|bit
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rflag
condition|)
while|while
condition|(
operator|--
name|bit
operator|,
operator|!
name|get
argument_list|(
name|bit
argument_list|)
operator|&&
name|bit
operator|>
name|minartno
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|++
name|bit
operator|,
operator|!
name|get
argument_list|(
name|bit
argument_list|)
operator|&&
name|bit
operator|<=
name|ngsize
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextng leaves bit as %ld\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_block

begin_comment
comment|/*  * Return TRUE if the user has not ruled out this article.  */
end_comment

begin_expr_stmt
name|aselect
argument_list|(
name|hp
argument_list|,
name|insist
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|insist
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|insist
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|tflag
operator|&&
operator|!
name|titmat
argument_list|(
name|hp
argument_list|,
name|header
operator|.
name|title
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|aflag
operator|&&
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
operator|<
name|atime
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|index
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
literal|','
argument_list|)
operator|&&
operator|!
name|rightgroup
argument_list|(
name|hp
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fflag
operator|&&
operator|(
name|hp
operator|->
name|followid
index|[
literal|0
index|]
operator|||
name|prefix
argument_list|(
name|hp
operator|->
name|title
argument_list|,
literal|"Re:"
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * Code to avoid showing multiple articles for news.  * Works even if you exit news.  * Returns nonzero if we should show this article.  */
end_comment

begin_macro
name|rightgroup
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ng
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flag
decl_stmt|;
name|strcpy
argument_list|(
name|ng
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|g
operator|=
name|ng
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|g
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|g
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|g
argument_list|,
name|groupdir
argument_list|)
operator|==
literal|0
condition|)
return|return
name|flag
return|;
if|if
condition|(
name|ngmatch
argument_list|(
name|g
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
operator|&&
operator|(
operator|(
name|i
operator|=
name|findrcline
argument_list|(
name|g
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|index
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|flag
operator|=
literal|0
expr_stmt|;
name|g
operator|=
name|p
expr_stmt|;
block|}
comment|/* we must be in "junk" or "control" */
return|return
name|TRUE
return|;
block|}
end_block

begin_macro
name|back
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|fseek
argument_list|(
name|actfp
argument_list|,
operator|-
literal|2L
argument_list|,
literal|1
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|ftell
argument_list|(
name|actfp
argument_list|)
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|actfp
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ftell
argument_list|(
name|actfp
argument_list|)
operator|==
literal|0L
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Trap interrupts.  */
end_comment

begin_macro
name|onsig
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|n
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|SigTrap
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|rcreadok
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Aborted early\n"
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * finds the line in your .newsrc file (actually the in-core "rcline"  * copy of it) and returns the index into the array where it was found.  * -1 means it didn't find it.  *  * We play clever games here to make this faster.  It's inherently  * quadratic - we spend lots of CPU time here because we search through  * the whole .newsrc for each line.  The "prev" variable remembers where  * the last match was found; we start the search there and loop around  * to the beginning, in the hopes that the calls will be roughly in order.  */
end_comment

begin_function
name|int
name|findrcline
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|top
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|prev
decl_stmt|;
specifier|static
name|int
name|didthru
decl_stmt|;
for|for
control|(
init|;
name|didthru
operator|<=
name|line
condition|;
operator|++
name|didthru
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|didthru
index|]
argument_list|,
literal|'!'
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|p
operator|=
name|index
argument_list|(
name|rcline
index|[
name|didthru
index|]
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|lentab
index|[
name|didthru
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|rcline
index|[
name|didthru
index|]
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|top
operator|=
name|line
expr_stmt|;
name|i
operator|=
name|prev
expr_stmt|;
name|loop
label|:
for|for
control|(
init|;
name|i
operator|<=
name|top
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|lentab
index|[
name|i
index|]
operator|==
name|len
operator|&&
name|rcline
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|rcline
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|prev
operator|=
name|i
return|;
if|if
condition|(
name|i
operator|>
name|line
operator|&&
name|line
operator|>
name|prev
operator|-
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|prev
operator|-
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * sortactive - make a local copy of the active file, sorted according  *   to the user's preferences, according to his .newsrc file.  */
end_comment

begin_struct
struct|struct
name|table_elt
block|{
name|int
name|rcindex
decl_stmt|;
name|long
name|maxart
decl_stmt|,
name|minart
decl_stmt|;
name|char
name|yn
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SORTACTIVE
end_ifdef

begin_function
specifier|static
name|int
name|rcsort
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
operator|(
operator|(
expr|struct
name|table_elt
operator|*
operator|)
name|a
operator|)
operator|->
name|rcindex
operator|-
operator|(
operator|(
expr|struct
name|table_elt
operator|*
operator|)
name|b
operator|)
operator|->
name|rcindex
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|newactivename
init|=
literal|"/tmp/newsaXXXXXX"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SORTACTIVE */
end_comment

begin_macro
name|sortactive
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|table_elt
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|nfp
decl_stmt|,
modifier|*
name|afp
decl_stmt|;
name|char
name|aline
index|[
name|BUFLEN
index|]
decl_stmt|,
name|ngname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|struct
name|table_elt
name|table
index|[
name|LINES
index|]
decl_stmt|;
name|int
name|nlines
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|delta
decl_stmt|,
name|lastline
decl_stmt|;
ifdef|#
directive|ifdef
name|SORTACTIVE
comment|/* make a new sorted copy of ACTIVE */
name|nfp
operator|=
name|fopen
argument_list|(
name|mktemp
argument_list|(
name|newactivename
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|newactivename
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|newactivename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* look up all the lines in ACTIVE, finding their positions in .newsrc */
name|p
operator|=
name|ACTIVE
expr_stmt|;
name|ACTIVE
operator|=
name|newactivename
expr_stmt|;
name|afp
operator|=
name|xfopen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|tp
operator|=
name|table
expr_stmt|;
else|#
directive|else
comment|/* !SORTACTIVE */
name|afp
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SORTACTIVE */
while|while
condition|(
name|fgets
argument_list|(
name|aline
argument_list|,
sizeof|sizeof
name|aline
argument_list|,
name|afp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|aline
argument_list|,
literal|"%s %ld %ld %c"
argument_list|,
name|ngname
argument_list|,
operator|&
name|tp
operator|->
name|maxart
argument_list|,
operator|&
name|tp
operator|->
name|minart
argument_list|,
operator|&
name|tp
operator|->
name|yn
argument_list|)
operator|!=
literal|4
condition|)
name|xerror
argument_list|(
literal|"Active file corrupt"
argument_list|)
expr_stmt|;
name|delta
operator|=
name|tp
operator|->
name|maxart
operator|-
name|tp
operator|->
name|minart
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
name|BITMAPSIZE
condition|)
name|BITMAPSIZE
operator|=
name|delta
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SORTACTIVE
name|tp
operator|->
name|rcindex
operator|=
name|findrcline
argument_list|(
name|ngname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|rcindex
operator|<
literal|0
condition|)
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* it's not in his .newsrc, maybe it's aliased? */
name|f
operator|=
name|xfopen
argument_list|(
name|ALIASES
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%s %s"
argument_list|,
name|afline
argument_list|,
name|bfr
argument_list|)
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|ngname
argument_list|,
name|bfr
argument_list|)
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ngname
argument_list|,
name|bfr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
name|j
operator|=
name|findrcline
argument_list|(
name|afline
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
name|rcline
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|bfr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|rcline
index|[
name|j
index|]
operator|=
name|realloc
argument_list|(
name|rcline
index|[
name|j
index|]
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|bfr
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcline
index|[
name|j
index|]
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcline
index|[
name|j
index|]
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|tp
operator|++
operator|->
name|rcindex
operator|=
name|j
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|++
name|line
operator|>
name|LINES
condition|)
name|xerror
argument_list|(
literal|"Too many newsgroups"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ngname
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|rcline
index|[
name|line
index|]
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|ngname
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcline
index|[
name|line
index|]
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcline
index|[
name|line
index|]
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcindex
operator|=
name|line
expr_stmt|;
block|}
name|tp
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* SORTACTIVE */
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|afp
argument_list|)
expr_stmt|;
name|BITMAPSIZE
operator|=
literal|8
operator|*
operator|(
operator|(
name|BITMAPSIZE
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|bitmap
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|BITMAPSIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Can't malloc bitmap"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SORTACTIVE
comment|/* sort by position in user's .newsrc file (new groups come up last) */
name|nlines
operator|=
name|tp
operator|-
name|table
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|table
argument_list|,
name|nlines
argument_list|,
sizeof|sizeof
name|table
index|[
literal|0
index|]
argument_list|,
name|rcsort
argument_list|)
expr_stmt|;
name|tp
operator|=
name|table
expr_stmt|;
name|lastline
operator|=
name|tp
operator|->
name|rcindex
operator|-
literal|1
expr_stmt|;
comment|/* copy active to newactive, in the new order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|++
name|lastline
operator|<
name|tp
operator|->
name|rcindex
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate .newsrc line or bad group %s\n"
argument_list|,
name|rcline
index|[
name|lastline
index|]
argument_list|)
expr_stmt|;
name|lentab
index|[
name|lastline
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|rcline
index|[
name|lastline
index|]
argument_list|)
expr_stmt|;
name|rcline
index|[
name|lastline
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rcline
index|[
name|tp
operator|->
name|rcindex
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|rcline
index|[
name|tp
operator|->
name|rcindex
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'!'
condition|)
name|fputc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|nfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|nfp
argument_list|,
literal|" %ld %ld %c\n"
argument_list|,
name|tp
operator|->
name|maxart
argument_list|,
name|tp
operator|->
name|minart
argument_list|,
name|tp
operator|->
name|yn
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SORTACTIVE */
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|checkngs
argument_list|(
argument|nbuf
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

end_unit

