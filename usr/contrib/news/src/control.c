begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * Control message handling code.  Deal with messages which are to be  * acted on by netnews itself rather than by people.  *  * See defs.h "news_version" for the real version of netnews.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)control.c	2.43	3/19/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|msg
parameter_list|)
value|(strcmp(msg, cargv[0]) == 0)
end_define

begin_decl_stmt
name|int
name|cargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|cargv
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|hfopen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|popen
argument_list|()
decl_stmt|,
modifier|*
name|mhopen
argument_list|()
decl_stmt|,
modifier|*
name|mailhdr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|senderof
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|u370
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|htmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* u370 */
end_comment

begin_macro
name|control
argument_list|(
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ctlmsgtext
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|h
operator|->
name|title
argument_list|,
literal|"cmsg "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|cp1
operator|=
name|h
operator|->
name|title
expr_stmt|;
name|cp2
operator|=
name|h
operator|->
name|title
operator|+
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|++
operator|=
operator|*
name|cp2
operator|++
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|h
operator|->
name|ctlmsg
condition|)
name|ctlmsgtext
operator|=
name|h
operator|->
name|ctlmsg
expr_stmt|;
else|else
name|ctlmsgtext
operator|=
name|h
operator|->
name|title
expr_stmt|;
name|log
argument_list|(
literal|"Ctl Msg %s from %s: %s"
argument_list|,
name|h
operator|->
name|nbuf
argument_list|,
name|h
operator|->
name|path
argument_list|,
name|ctlmsgtext
argument_list|)
expr_stmt|;
comment|/* 	 * Control messages have the standard format 	 *	command [args] 	 * much like shell commands.  Each site has the option 	 * of customizing this code to deal with control messages 	 * as they see fit, but we would like to buy back the 	 * code, ifdeffed or otherwise parameterized, to simplify 	 * the maintenence issues. 	 */
name|argparse
argument_list|(
name|ctlmsgtext
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
literal|"cancel"
argument_list|)
condition|)
return|return
name|c_cancel
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
return|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"newgroup"
argument_list|)
condition|)
name|c_newgroup
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"ihave"
argument_list|)
condition|)
name|c_ihave
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"sendme"
argument_list|)
condition|)
name|c_sendme
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"sendbad"
argument_list|)
condition|)
name|c_sendme
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"rmgroup"
argument_list|)
condition|)
name|c_rmgroup
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"sendsys"
argument_list|)
condition|)
name|c_sendsys
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"senduuname"
argument_list|)
condition|)
name|c_senduuname
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"version"
argument_list|)
condition|)
name|c_version
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"checkgroups"
argument_list|)
condition|)
name|c_checkgroups
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"delsub"
argument_list|)
condition|)
name|c_unimp
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
else|else
name|c_unknown
argument_list|(
name|h
argument_list|,
name|ctlmsgtext
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Parse the string str into separate words in cargc and cargv  * as per the usual UNIX convention.  Nothing fancy here, just  * blanks and tabs separating words.  */
end_comment

begin_macro
name|argparse
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|cavpbuf
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|cavbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|nextfree
init|=
name|cavbuf
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"Control message %s has no title"
argument_list|,
name|header
operator|.
name|ident
argument_list|)
expr_stmt|;
name|cargc
operator|=
operator|(
operator|*
name|str
operator|!=
literal|'\0'
operator|)
expr_stmt|;
name|cargv
operator|=
name|cavpbuf
expr_stmt|;
name|cargv
index|[
literal|0
index|]
operator|=
name|cavbuf
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|<=
literal|' '
condition|)
block|{
operator|*
name|nextfree
operator|++
operator|=
literal|0
expr_stmt|;
name|cargv
index|[
name|cargc
index|]
operator|=
name|nextfree
expr_stmt|;
name|cargc
operator|++
expr_stmt|;
comment|/* skip over white space */
while|while
condition|(
operator|*
name|str
operator|!=
literal|'\0'
operator|&&
operator|*
name|str
operator|<=
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
comment|/* line ends in white space */
return|return;
block|}
else|else
operator|*
name|nextfree
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * ihave<artid><remotesys>  * The other system is telling you it has article<artid>, in case  * you decide you want it to transmit it to you.  */
end_comment

begin_macro
name|c_ihave
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tl
index|[
literal|256
index|]
decl_stmt|,
name|ng
index|[
literal|256
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|u370
name|struct
name|hbuf
name|htmp
decl_stmt|;
endif|#
directive|endif
comment|/* !u370 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|xerror
argument_list|(
literal|"ihave: Not enough arguments."
argument_list|)
expr_stmt|;
comment|/* 	 * Check that we haven't already seen it (history) 	 * and then send back a "sendme" message if we subscribe. 	 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|htmp
operator|.
name|ident
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|BUFLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
operator|&
name|htmp
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Should probably check SUBFILE here. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tl
argument_list|,
literal|"sendme %s %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|FULLSYSNAME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ng
argument_list|,
literal|"to.%s.ctl"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|xmitmsg
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|tl
argument_list|,
name|ng
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * sendme<artid> ...<remotesys>  * The other system wants me to send him article<artid>.  */
end_comment

begin_macro
name|c_sendme
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|srec
name|srec
decl_stmt|;
ifndef|#
directive|ifndef
name|u370
name|struct
name|hbuf
name|htmp
decl_stmt|;
endif|#
directive|endif
comment|/* !u370 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|xerror
argument_list|(
literal|"sendme: Not enough arguments."
argument_list|)
expr_stmt|;
comment|/* Don't ask for it from myself */
if|if
condition|(
name|strncmp
argument_list|(
name|FULLSYSNAME
argument_list|,
name|argv
index|[
name|argc
index|]
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Find the sys record */
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
operator|&
name|srec
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|argv
index|[
name|argc
index|]
argument_list|,
name|SNLN
argument_list|)
condition|)
continue|continue;
comment|/* It's the right one.  Send them. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|hfopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|htmp
operator|.
name|unrec
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|htmp
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfr
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|fp
operator|=
name|xfopen
argument_list|(
name|bfr
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|htmp
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Article %s is garbled."
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
block|}
else|else
name|xerror
argument_list|(
literal|"Article %s is garbled."
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"sendme"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* check that other sys subscribes. */
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|htmp
operator|.
name|nbuf
argument_list|,
name|srec
operator|.
name|s_nbuf
argument_list|)
operator|||
operator|!
operator|(
name|htmp
operator|.
name|distribution
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|ngmatch
argument_list|(
name|htmp
operator|.
name|distribution
argument_list|,
name|srec
operator|.
name|s_nbuf
argument_list|)
operator|)
condition|)
continue|continue;
block|}
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* transmit does fclose(fp) */
block|}
return|return;
block|}
name|xerror
argument_list|(
literal|"Cannot find system %s to send article %s to."
argument_list|,
name|argv
index|[
name|argc
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * newgroup<groupname>  * A new newsgroup has been created.  * The body of the article, if present, is a description of the  * purpose of the newsgroup.  *  */
end_comment

begin_macro
name|c_newgroup
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|didcreate
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|xerror
argument_list|(
literal|"newgroup: Not enough arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
name|validng
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
return|return;
if|if
condition|(
name|header
operator|.
name|approved
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"newgroup: %s not approved"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NONEWGROUPS
ifdef|#
directive|ifdef
name|ORGDISTRIB
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ORGDISTRIB
argument_list|,
name|header
operator|.
name|distribution
argument_list|)
condition|)
block|{
name|didcreate
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* ORGDISTRIB */
name|actfp
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|actfp
argument_list|,
literal|"%s 00000 00001 y\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ORGDISTRIB
block|}
endif|#
directive|endif
comment|/* ORGDISTRIB */
endif|#
directive|endif
comment|/* !NONEWGROUPS */
ifdef|#
directive|ifdef
name|NOTIFY
name|fd
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|"creation of new newsgroup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|didcreate
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"A new newsgroup called '%s' has been created by %s.\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s requested that a new newsgroup called '%s' be created.\n"
argument_list|,
name|header
operator|.
name|path
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"It was approved by %s\n\n"
argument_list|,
name|header
operator|.
name|approved
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ORGDISTRIB
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You can accomplish this by sending a newgroup control message with a\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"distribution code of %s; in other words, by executing the command:\n"
argument_list|,
name|ORGDISTRIB
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s/inews -n net.news -d %s -t \"cmsg newgroup %s\"\n"
argument_list|,
name|LIB
argument_list|,
name|ORGDISTRIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ORGDISTRIB */
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTIFY */
end_comment

begin_comment
comment|/*  * rmgroup<groupname>  * An old newsgroup is being cancelled on a network wide basis.  */
end_comment

begin_macro
name|c_rmgroup
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|shouldremove
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|xerror
argument_list|(
literal|"rmgroup: Not enough arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validng
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
return|return;
if|if
condition|(
name|header
operator|.
name|approved
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"rmgroup: %s not approved"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MANUALLY
ifdef|#
directive|ifdef
name|ORGDISTRIB
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ORGDISTRIB
argument_list|,
name|header
operator|.
name|distribution
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ORGDISTRIB */
name|shouldremove
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* !MANUALLY */
ifdef|#
directive|ifdef
name|NOTIFY
name|fd
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|"rmgroup control message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|shouldremove
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"A newsgroup called '%s' has been removed by %s.\n\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You may need to remove the directory %s by hand\n"
argument_list|,
name|dirname
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s has requested that newsgroup %s be removed.\n"
argument_list|,
name|header
operator|.
name|path
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You should remove it by hand\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"To do this, execute the command\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\t%s/rmgroup %s\n"
argument_list|,
name|LIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
if|if
condition|(
name|shouldremove
condition|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* We let the shell do all the work. 		 * See the rmgrp shell script. */
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* otherwise it won't rmdir the dir */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"exec %s/rmgroup %s"
argument_list|,
name|LIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"system(%s) status %d"
argument_list|,
name|bfr
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * cancel<artid>  * Cancel the named article  */
end_comment

begin_macro
name|c_cancel
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|poster
decl_stmt|;
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|whatsisname
index|[
name|BUFLEN
index|]
decl_stmt|,
name|nfilename
index|[
name|BUFLEN
index|]
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|int
name|su
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|u370
name|struct
name|hbuf
name|htmp
decl_stmt|;
endif|#
directive|endif
comment|/* !u370 */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|xerror
argument_list|(
literal|"cancel: Not enough arguments."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|whatsisname
argument_list|,
name|senderof
argument_list|(
operator|&
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|findhist
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|log
argument_list|(
literal|"Can't cancel %s:  non-existent"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|sprintf
argument_list|(
argument|bfr
argument_list|,
literal|"%s\t%2.2d/%2.2d/%d %2.2d:%2.2d\tcancelled"
argument_list|,
else|#
directive|else
comment|/* !USG */
argument|sprintf(bfr,
literal|"%s\t%02d/%02d/%d %02d:%02d\tcancelled"
argument|,
endif|#
directive|endif
comment|/* !USG */
argument|argv[
literal|1
argument|], tm->tm_mon+
literal|1
argument|, tm->tm_mday, tm->tm_year, tm->tm_hour, 		   tm->tm_min); 		savehist(bfr); 		return
literal|1
argument|; 	}  	q = index(line,
literal|'\t'
argument|); 	p = index(q+
literal|1
argument|,
literal|'\t'
argument|); 	if (p == NULL || *++p ==
literal|'\0'
argument||| *p ==
literal|'\n'
argument|) { 		*q =
literal|'\0'
argument|; 		log(
literal|"Expired article %s"
argument|, line); 		return
literal|1
argument|; 	} 	if (strcmp(p,
literal|"cancelled"
argument|) ==
literal|0
argument|) { 		*q =
literal|'\0'
argument|; 		log(
literal|"Already Cancelled %s"
argument|, line); 		return
literal|1
argument|; 	} else 		log(
literal|"Cancelling %s"
argument|, line); 	if ((uid == ROOTID||uid ==
literal|0
argument|)&& strcmp(header.distribution,
literal|"local"
argument|) ==
literal|0
argument|) 		su =
literal|1
argument|; 	while (*p) { 		q = index(p,
literal|' '
argument|); 		if (q) 			*q =
literal|'\0'
argument|; 		(void) strcpy(nfilename, dirname(p)); 		fp = fopen(nfilename,
literal|"r"
argument|); 		if (fp == NULL) { 			log(
literal|"Already Cancelled %s"
argument|, line); 			return
literal|1
argument|; 		} 		htmp.unrec[
literal|0
argument|] = NULL; 		if (hread(&htmp, fp, TRUE) == NULL) { 			if (bfr[
literal|0
argument|] ==
literal|'/'
argument|) { 				fp = fopen(bfr,
literal|"r"
argument|); 				if (fp == NULL 					|| hread(&htmp, fp, TRUE) == NULL) 					xerror(
literal|"Article is garbled."
argument|); 			} else  				xerror(
literal|"Article is garbled."
argument|); 		} 		(void) fclose(fp); 		poster = senderof(&htmp);
comment|/* only compare up to '.' or ' ' */
argument|r = index(poster,
literal|'.'
argument|); 		if (r == NULL) 			r = index(poster,
literal|' '
argument|); 		if (r != NULL) 			*r =
literal|'\0'
argument|; 		if (!su&& strncmp(whatsisname, poster,strlen(poster))) { 			xerror(
literal|"Not contributor: posted by %s, and you are %s"
argument|, poster, whatsisname); 		}  		(void) unlink(nfilename); 		p = q+
literal|1
argument|; 	} 	return
literal|0
argument|; }
comment|/*  * sendsys	(no arguments)  *  * Mail the sys file to the person submitting the article.  * POLICY: the contents of your sys file are public information  * and as such, you should not change this code.  You may feel  * free to arrange for it to manually notify you, in the event  * that you want to do something to clean it up before it goes out.  * Secret sites on the net are expressly frowned on.  *   * The purpose of this command is for making a network map.  The  * details of your link and which newsgroups are forwarded are not  * important, in case you want to sanitize them.  Since the definition  * of USENET is those sites getting net.announce, you can disable this  * on sites not getting net articles, but if you take out the list of  * forwarded newsgroups, and you have sites that only get local newsgroups,  * you should make this clear, or remove those sites from what you send out.  */
comment|/* ARGSUSED */
argument|c_sendsys(argc, argv) char **argv; { 	register FILE *f
argument_list|,
argument|*u; 	int c;
ifdef|#
directive|ifdef
name|NOTIFY
argument|f = mailhdr((struct hbuf *)NULL,
literal|"sendsys control message"
argument|); 	if (f != NULL) { 		fprintf(f,
literal|"%s requested your %s/sys file.\n"
argument|, header.path, LIB); 		fprintf(f,
literal|"It has been sent.\n"
argument|); 		(void) mclose(f); 	}
endif|#
directive|endif
argument|f = mailhdr(&header,
literal|"response to your sendsys request"
argument|); 	u = fopen(SUBFILE,
literal|"r"
argument|); 	if (f != NULL&& u != NULL) { 		while ((c=getc(u)) != EOF) 			putc(c, f); 		(void) fclose(u); 		(void) mclose(f); 	} }
comment|/*  * senduuname	(no arguments)  *  * Run the "uuname" command and send it back to the person who submitted  * the article.  The purpose of this control message is for attempting to  * make a uucp net map.  *  * POLICY: If you view this information as not public (because you have  * a connection you consider secret, or know a site that considers itself  * secret) you can feel free to change this code in whatever way is  * appropriate, so long as it sends some response back to the sender.  If  * you don't run uucp, this code does not make sense, and so an error  * message (or garbage, such as "research") will be mailed back.  *  * If you wish to add or remove sites from the output of uuname, you  * may wish to use the euuname.sh shell script here.  */
comment|/* ARGSUSED */
argument|c_senduuname(argc, argv) char **argv; { 	char buf[
literal|256
argument|]; 	FILE *fd
argument_list|,
argument|*u; 	int c;
ifdef|#
directive|ifdef
name|NOTIFY
argument|fd = mailhdr((struct hbuf *)NULL,
literal|"uuname control message"
argument|); 	fprintf(fd,
literal|"%s requested your uuname output\n"
argument|, header.path); 	(void) mclose(fd);
endif|#
directive|endif
argument|fd = mailhdr(&header,
literal|"response to your senduuname request"
argument|);
ifdef|#
directive|ifdef
name|UUPROG
argument|if (UUPROG[
literal|0
argument|] ==
literal|'/'
argument|) 		(void) strcpy(buf, UUPROG); 	else 		(void) sprintf(buf,
literal|"%s/%s"
argument|, LIB, UUPROG);
else|#
directive|else
argument|(void) strcpy(buf,
literal|"uuname"
argument|);
endif|#
directive|endif
argument|u = popen(buf,
literal|"r"
argument|); 	if (fd != NULL&& u != NULL) { 		while ((c=getc(u)) != EOF) 			putc(c, fd); 		(void) pclose(u); 		(void) mclose(fd); 	} }
comment|/*  * Send the version number to the right person.  */
comment|/* ARGSUSED */
argument|c_version(argc, argv) char **argv; { 	register FILE *f;  	f = mailhdr(&header,
literal|"Our news version"
argument|); 	if (f == NULL) 		xerror(
literal|"Cannot send back error message"
argument|); 	fprintf(f,
literal|"Currently running news version %s.\n\n"
argument|, news_version); 	fprintf(f,
literal|"The header of your message follows:\n\n"
argument|); 	(void) hwrite(&header, f); 	(void) mclose(f); }
comment|/*  * Check the active file for old or missing newsgroups  * Body of article is list of valid groups  */
comment|/* ARGSUSED */
argument|c_checkgroups(argc, argv) char **argv; { 	int rc;  	(void) setuid(geteuid());
comment|/* dont change the cat %s| to< %s, it breaks some "unix" systems */
argument|(void) sprintf(bfr,
literal|"cat %s | %s/checkgroups %s"
argument|, INFILE, LIB,
ifdef|#
directive|ifdef
name|NOTIFY
argument|(TELLME&& *TELLME) ? TELLME : NEWSUSR );
else|#
directive|else
comment|/* !NOTIFY */
argument|NEWSUSR
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/* !NOTIFY */
name|rc
operator|=
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"system(%s) status %d"
argument_list|,
name|bfr
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/*  * An unknown control message has been received.  */
name|c_unknown
argument_list|(
argument|h
argument_list|,
argument|ctlmsgtext
argument_list|)
name|struct
name|hbuf
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|ctlmsgtext
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|log
argument_list|(
literal|"UNKNOWN Ctl Msg %s from %s"
argument_list|,
name|ctlmsgtext
argument_list|,
name|h
operator|->
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|f
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|"Unrecognized Control Message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Currently running news version %s.\n\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The header of the message follows:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hwrite
argument_list|(
name|h
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
block|}
comment|/* ARGSUSED */
name|c_unimp
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|f
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|"Unimplemented Control Message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Currently running news version B %s.\n\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The header of the message follows:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hwrite
argument_list|(
operator|&
name|header
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
block|}
name|xmitmsg
argument_list|(
argument|tosys
argument_list|,
argument|title
argument_list|,
argument|ng
argument_list|)
name|char
modifier|*
name|tosys
decl_stmt|,
modifier|*
name|title
decl_stmt|,
modifier|*
name|ng
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|u370
name|struct
name|hbuf
name|htmp
decl_stmt|;
endif|#
directive|endif
comment|/* !u370 */
name|struct
name|srec
name|srec
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Make an article called ARTICLE */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|htmp
operator|.
name|from
argument_list|,
literal|"%s@%s%s"
argument_list|,
literal|"usenet"
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|htmp
operator|.
name|path
argument_list|,
name|NEWSUSR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|htmp
operator|.
name|nbuf
argument_list|,
name|ng
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|htmp
operator|.
name|title
argument_list|,
name|title
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|htmp
operator|.
name|ctlmsg
argument_list|,
name|title
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|htmp
operator|.
name|subdate
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|htmp
operator|.
name|expdate
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|getident
argument_list|(
operator|&
name|htmp
argument_list|)
expr_stmt|;
name|dates
argument_list|(
operator|&
name|htmp
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|xfopen
argument_list|(
name|fname
operator|=
name|mktemp
argument_list|(
literal|"/tmp/xmsgXXXXXX"
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|hwrite
argument_list|(
operator|&
name|htmp
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
comment|/* Find the sys record */
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
operator|&
name|srec
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|tosys
argument_list|,
name|SNLN
argument_list|)
condition|)
continue|continue;
name|tfp
operator|=
name|xfopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|tfp
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
argument_list|(
literal|"Can't find sys record for %s"
argument_list|,
name|tosys
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"Cannot find sys record"
argument_list|)
expr_stmt|;
block|}
comment|/*  * This is a modified version of popen, made more secure.  Rather than  * forking off a shell, you get a bare process.  You must have exactly  * one argument, and the command must be mail (or sendmail if you have it).  */
define|#
directive|define
name|RDR
value|0
define|#
directive|define
name|WTR
value|1
specifier|static
name|int
name|mopen_pid
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|replyname
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|mhopen
parameter_list|(
name|hptr
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|myside
operator|,
name|hisside
operator|,
name|pid
expr_stmt|;
name|char
modifier|*
name|sendto
init|=
literal|"usenet"
decl_stmt|;
if|if
condition|(
name|hptr
condition|)
name|sendto
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|NOTIFY
if|if
condition|(
name|TELLME
operator|&&
operator|*
name|TELLME
condition|)
name|sendto
operator|=
name|TELLME
expr_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
if|if
condition|(
name|sendto
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|verifyname
argument_list|(
name|sendto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|myside
operator|=
name|p
index|[
name|WTR
index|]
expr_stmt|;
name|hisside
operator|=
name|p
index|[
name|RDR
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* myside and hisside reverse roles in child */
operator|(
name|void
operator|)
name|close
argument_list|(
name|myside
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SENDMAIL
name|execl
argument_list|(
name|SENDMAIL
argument_list|,
literal|"sendmail"
argument_list|,
literal|"-oi"
argument_list|,
literal|"-oeq"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SENDMAIL */
ifdef|#
directive|ifdef
name|MMDF
name|execl
argument_list|(
name|MMDF
argument_list|,
literal|"inews-mail"
argument_list|,
literal|"-smuxto,cc*"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MMDF */
name|execl
argument_list|(
literal|"/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/ucb/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|mopen_pid
index|[
name|myside
index|]
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
return|return
operator|(
name|fdopen
argument_list|(
name|myside
argument_list|,
literal|"w"
argument_list|)
operator|)
return|;
block|}
name|mclose
argument_list|(
argument|ptr
argument_list|)
name|FILE
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|f
operator|,
name|r
operator|,
call|(
modifier|*
name|hstat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|istat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|qstat
call|)
argument_list|()
expr_stmt|;
name|int
name|status
decl_stmt|;
name|f
operator|=
name|fileno
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|mopen_pid
index|[
name|f
index|]
operator|&&
name|r
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/*  * mhopen a pipe to mail, write out a std header, and return the file ptr.  *  * We don't include a From: field because this is probably uucp, i.e.  * explicitly routed.  Leave it up to the recipient's mailer.  * Always include the To: field because if we ge back failed mail, we  * might be able to deliver it by hand if we know to wom it was addressed.  * By convention, hptr==NULL means to send the message to the local contact person.  */
name|FILE
modifier|*
name|mailhdr
parameter_list|(
name|hptr
parameter_list|,
name|subject
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
name|char
modifier|*
name|subject
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|to
init|=
literal|"usenet"
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
if|if
condition|(
name|TELLME
operator|&&
operator|*
name|TELLME
condition|)
name|to
operator|=
name|TELLME
expr_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
if|if
condition|(
name|hptr
condition|)
name|to
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|mhopen
argument_list|(
name|hptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MMDF
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: The News System<usenet@%s%s>\n"
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MMDF */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subject
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIDDENNET
if|if
condition|(
name|strcmp
argument_list|(
name|LOCALSYSNAME
argument_list|,
name|FULLSYSNAME
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Responding-System: %s.%s%s\n\n"
argument_list|,
name|LOCALSYSNAME
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HIDDENNET */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Responding-System: %s%s\n\n"
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
comment|/*  * verify that the name mail is being sent to does not contain any  * nasty hooks to invoke funny functions from the shell or the like.  */
name|verifyname
argument_list|(
argument|sendto
argument_list|)
name|char
modifier|*
name|sendto
decl_stmt|;
block|{
comment|/* Be sure we DO allow alphabetics, !, :, ., -, @. *. */
name|char
modifier|*
name|nasty
init|=
literal|"\"'\\`^|;&<>/~"
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sendto
index|[
literal|0
index|]
operator|<=
literal|' '
condition|)
block|{
name|log
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|sendto
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strpbrk
argument_list|(
name|sendto
argument_list|,
name|nasty
argument_list|)
operator|!=
name|NULL
condition|)
name|xerror
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|nasty
operator|=
name|sendto
init|;
operator|(
name|nasty
operator|=
name|index
argument_list|(
name|nasty
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|++
name|nasty
operator|==
literal|'.'
condition|)
comment|/* check for .. */
name|xerror
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Checks to make sure the control message is OK to post.  */
name|ctlcheck
argument_list|()
block|{
name|char
name|msg
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|is_ctl
condition|)
return|return;
if|if
condition|(
name|header
operator|.
name|ctlmsg
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|msg
argument_list|,
name|header
operator|.
name|ctlmsg
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|msg
argument_list|,
name|header
operator|.
name|title
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|msg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"ihave"
argument_list|)
operator|==
literal|0
condition|)
block|{ 	}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"sendme"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"newgroup"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"rmgroup"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"sendsys"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"senduuname"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"checkgroups"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"version"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"cancel"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions at this level */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"delsub"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|prefix
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
literal|"to."
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Must be in a 'to.system' newsgroup."
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unrecognized control message - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure this guy is special. */
name|suser
argument_list|()
block|{
if|if
condition|(
name|uid
operator|==
literal|0
operator|||
name|uid
operator|==
name|ROOTID
condition|)
return|return;
comment|/* 	 * We assume that since our real uid is the same as NEWSUSR 	 * (the euid) we were run by rootid and it did a setuid. 	 * Too bad we can't set just the effective uid like suid does. 	 */
if|if
condition|(
name|uid
operator|==
name|geteuid
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|IHCC
name|printf
argument_list|(
literal|"Please use the command:\n\ttoolnews providers\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"then call one of the news people.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Get your local netnews contact to do it for you.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

