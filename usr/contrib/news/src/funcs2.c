begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1985 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  *  * funcs2 - functions used by both inews and readnews.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)funcs2.c	1.13	1/17/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SunIII
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|INTERNET
end_ifndef

begin_define
define|#
directive|define
name|INTERNET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !INTERNET */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SunIII */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_comment
comment|/*  * Get user name and home directory.  */
end_comment

begin_macro
name|getuser
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|flag
init|=
name|TRUE
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot get user's name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|username
operator|==
name|NULL
operator|||
name|username
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|username
operator|=
name|AllocCpy
argument_list|(
name|p
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|userhome
operator|=
name|AllocCpy
argument_list|(
name|p
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|flag
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|header
operator|.
name|path
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|sysfile
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|fldget
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|sfline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open SUBFILE.  */
end_comment

begin_macro
name|s_openr
argument_list|()
end_macro

begin_block
block|{
name|sysfile
operator|=
name|xfopen
argument_list|(
name|SUBFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|sfline
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read SUBFILE.  */
end_comment

begin_expr_stmt
name|s_read
argument_list|(
name|sp
argument_list|)
specifier|register
expr|struct
name|srec
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|chop_spaces
init|=
literal|0
decl_stmt|;
name|again
label|:
name|p
operator|=
name|bfr
expr_stmt|;
comment|/*          * Read  the  SUBFILE  (/usr/lib/news/sys)  from   the   current 	 * position  to  the  first  unescaped newline.  If a newline is 	 * escaped with a backslash (\) continue reading but throw  away 	 * the backslash and newline; read the next line skipping spaces 	 * and tabs until the first non-space/tab character, then  start 	 * looking   for   a   newline   again.   Skipping  the  leading 	 * spaces/tabs after a escaped newline  keeps  the  news  groups 	 * together.  If  a  line  begins  with a newline, just skip it. 	 */
for|for
control|(
name|e
operator|=
name|p
operator|+
name|LBUFLEN
init|;
name|p
operator|<
name|e
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|sysfile
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|sfline
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|bfr
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
block|{
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
name|chop_spaces
operator|++
expr_stmt|;
name|p
operator|-=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chop_spaces
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
condition|)
name|p
operator|--
expr_stmt|;
else|else
name|chop_spaces
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|p
operator|=
name|bfr
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
goto|goto
name|again
goto|;
comment|/* skip newlines */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|p
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"SUBFILE (%s) line %d too long."
argument_list|,
name|SUBFILE
argument_list|,
name|sfline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
goto|goto
name|again
goto|;
name|sp
operator|->
name|s_xmit
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|s_flags
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|s_nosend
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|p
operator|=
name|fldget
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"Bad SUBFILE (%s) line %d."
argument_list|,
name|SUBFILE
argument_list|,
name|sfline
argument_list|)
expr_stmt|;
comment|/*  * A sys file line reading "ME" means the name of the local system.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
literal|"ME"
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
name|FULLSYSNAME
argument_list|)
expr_stmt|;
name|e
operator|=
name|index
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
operator|*
name|e
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|s_nosend
operator|=
name|e
expr_stmt|;
block|}
name|p
operator|=
name|fldget
argument_list|(
name|sp
operator|->
name|s_nbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lcase
argument_list|(
name|sp
operator|->
name|s_nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
name|p
operator|=
name|fldget
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
operator|(
name|void
operator|)
name|fldget
argument_list|(
name|sp
operator|->
name|s_xmit
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|fldget
parameter_list|(
name|q
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|q
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_comment
comment|/*  * Find the SUBFILE record for a system.  */
end_comment

begin_expr_stmt
name|s_find
argument_list|(
name|sp
argument_list|,
name|system
argument_list|)
specifier|register
expr|struct
name|srec
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|system
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
name|sp
argument_list|)
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|system
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s_close
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|s_close
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Close sysfile.  */
end_comment

begin_macro
name|s_close
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sysfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|time_t
name|cgtdate
parameter_list|(
name|datestr
parameter_list|)
name|char
modifier|*
name|datestr
decl_stmt|;
block|{
name|char
name|junk
index|[
literal|40
index|]
decl_stmt|,
name|month
index|[
literal|40
index|]
decl_stmt|,
name|day
index|[
literal|30
index|]
decl_stmt|,
name|tod
index|[
literal|60
index|]
decl_stmt|,
name|year
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|time_t
name|lasttime
decl_stmt|;
specifier|static
name|char
name|lastdatestr
index|[
name|BUFLEN
index|]
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|lastdatestr
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|datestr
argument_list|,
name|lastdatestr
argument_list|)
operator|==
literal|0
condition|)
return|return
name|lasttime
return|;
name|lasttime
operator|=
name|getdate
argument_list|(
name|datestr
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lasttime
operator|<
literal|0
operator|&&
name|sscanf
argument_list|(
name|datestr
argument_list|,
literal|"%s %s %s %s %s"
argument_list|,
name|junk
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|tod
argument_list|,
name|year
argument_list|)
operator|==
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s %s, %s %s"
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|year
argument_list|,
name|tod
argument_list|)
expr_stmt|;
name|lasttime
operator|=
name|getdate
argument_list|(
name|bfr
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|lastdatestr
argument_list|,
name|datestr
argument_list|,
name|BUFLEN
argument_list|)
expr_stmt|;
return|return
name|lasttime
return|;
block|}
end_function

begin_expr_stmt
name|lcase
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|s
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|*
name|ptr
operator|=
name|tolower
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return a compact representation of the person who posted the given  * message.  A sender or internet name will be used, otherwise  * the last part of the path is used preceded by an optional ".."  */
end_comment

begin_function
name|char
modifier|*
name|tailpath
parameter_list|(
name|hp
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|static
name|char
name|resultbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
name|pathbuf
index|[
name|PATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* 	 * This only happens for articles posted by old news software 	 * in non-internet format. 	 */
name|resultbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pathbuf
argument_list|,
name|hp
operator|->
name|path
argument_list|,
name|PATHLEN
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|pathbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Chop off trailing " (name)" */
name|r
operator|=
name|rindex
argument_list|(
name|pathbuf
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|pathbuf
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|r
operator|>
name|pathbuf
operator|&&
operator|*
operator|--
name|r
operator|!=
literal|'!'
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|>
name|pathbuf
condition|)
block|{
name|r
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resultbuf
argument_list|,
literal|"..!"
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|resultbuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|resultbuf
return|;
block|}
end_function

begin_comment
comment|/*  * arpadate is like ctime(3) except that the time is returned in  * an acceptable ARPANET time format instead of ctime format.  */
end_comment

begin_function
name|char
modifier|*
name|arpadate
parameter_list|(
name|longtime
parameter_list|)
name|time_t
modifier|*
name|longtime
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|ud
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|b
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|asctime
parameter_list|()
function_decl|;
comment|/*  Get current time. This will be used resolve the timezone. */
name|ud
operator|=
name|asctime
argument_list|(
name|gmtime
argument_list|(
name|longtime
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Crack the UNIX date line in a singularly unoriginal way. */
name|q
operator|=
name|b
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* until every site installs the fix to getdate.y, the day    of the week can cause time warps */
name|p
operator|=
operator|&
name|ud
index|[
literal|0
index|]
expr_stmt|;
comment|/* Mon */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
operator|&
name|ud
index|[
literal|8
index|]
expr_stmt|;
comment|/* 16 */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|4
index|]
expr_stmt|;
comment|/* Sep */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|22
index|]
expr_stmt|;
comment|/* 1979 */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|11
index|]
expr_stmt|;
comment|/* 01:03:52 */
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'G'
expr_stmt|;
comment|/* GMT */
operator|*
name|q
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|replyname
parameter_list|(
name|hptr
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|char
name|tbuf
index|[
name|PATHLEN
index|]
decl_stmt|;
name|ptr
operator|=
name|hptr
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|prefix
argument_list|(
name|ptr
argument_list|,
name|FULLSYSNAME
argument_list|)
operator|&&
name|index
argument_list|(
name|NETCHRS
argument_list|,
name|ptr
index|[
name|strlen
argument_list|(
name|FULLSYSNAME
argument_list|)
index|]
argument_list|)
condition|)
name|ptr
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|'!'
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|hptr
operator|->
name|from
index|[
literal|0
index|]
condition|)
name|ptr
operator|=
name|hptr
operator|->
name|from
expr_stmt|;
if|if
condition|(
name|hptr
operator|->
name|replyto
index|[
literal|0
index|]
condition|)
name|ptr
operator|=
name|hptr
operator|->
name|replyto
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tbuf
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|tbuf
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
while|while
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|--
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SunIII
if|if
condition|(
name|ptr
operator|=
name|rindex
argument_list|(
name|tbuf
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
name|prefix
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"OZ"
argument_list|)
condition|)
block|{
comment|/* some people only allow it in lower case ... */
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"oz"
argument_list|)
expr_stmt|;
return|return
name|tbuf
return|;
block|}
if|if
condition|(
name|prefix
argument_list|(
name|ptr
argument_list|,
literal|"UUCP"
argument_list|)
operator|||
name|prefix
argument_list|(
name|ptr
argument_list|,
literal|"ARPA"
argument_list|)
operator|||
name|prefix
argument_list|(
name|ptr
argument_list|,
literal|"DEC"
argument_list|)
operator|||
name|prefix
argument_list|(
name|ptr
argument_list|,
literal|"CSNET"
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|tbuf
argument_list|,
literal|"@munnari.oz"
argument_list|)
expr_stmt|;
comment|/* via sun to munnari */
return|return
name|tbuf
return|;
block|}
block|}
comment|/* 	 * must(?) have come from a uucp site, lets look see if path passes 	 * through munnari, and if so delete the fake uucp path after that. 	 */
for|for
control|(
name|ptr
operator|=
name|tbuf
init|;
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|prefix
argument_list|(
name|ptr
argument_list|,
literal|"munnari!"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|tbuf
argument_list|,
name|ptr
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
break|break;
block|}
comment|/* 	 * now, just send the address we have left to munnari, and 	 * hope that something sensible will be done with it there. 	 * (This works in more cases than you'd think ...) 	 */
name|strcat
argument_list|(
name|tbuf
argument_list|,
literal|"@munnari.oz"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SunIII */
ifndef|#
directive|ifndef
name|INTERNET
comment|/* 	 * Play games stripping off multiple berknet 	 * addresses (a!b!c:d:e => a!b!d:e) here. 	 */
for|for
control|(
name|ptr
operator|=
name|tbuf
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|ptr2
decl_stmt|;
if|if
condition|(
name|index
argument_list|(
name|NETCHRS
argument_list|,
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
operator|==
literal|':'
operator|&&
operator|(
name|ptr2
operator|=
name|index
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|ptr2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !INTERNET */
endif|#
directive|endif
comment|/* SunIII */
return|return
name|tbuf
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DBM
end_ifdef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|dptr
decl_stmt|;
name|int
name|dsize
decl_stmt|;
block|}
name|datum
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBM */
end_comment

begin_comment
comment|/*  * Given an article ID, find the line in the history file that mentions it.  * Return the text of the line, or NULL if not found.  A pointer to a  * static area is returned.  */
end_comment

begin_function
name|char
modifier|*
name|findhist
parameter_list|(
name|artid
parameter_list|)
name|char
modifier|*
name|artid
decl_stmt|;
block|{
specifier|static
name|char
name|lbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|oidbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|hfp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DBM
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|datum
name|fetch
parameter_list|()
function_decl|;
name|long
name|fpos
decl_stmt|;
comment|/* We have to use an explicit variable to insure alignment */
else|#
directive|else
comment|/* !DBM */
name|char
modifier|*
name|histfile
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* !DBM */
comment|/* Try to understand old artid's as well.  Assume .UUCP domain. */
if|if
condition|(
name|artid
index|[
literal|0
index|]
operator|!=
literal|'<'
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|artid
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|oidbuf
argument_list|,
literal|"<%s@%s.UUCP>"
argument_list|,
name|p
argument_list|,
name|artid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
operator|--
name|p
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oidbuf
argument_list|,
name|artid
argument_list|)
expr_stmt|;
name|lcase
argument_list|(
name|oidbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
name|initdbm
argument_list|(
name|ARTFILE
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|dptr
operator|=
name|oidbuf
expr_stmt|;
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|lhs
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|=
name|fetch
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|dptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hfp
operator|=
name|xfopen
argument_list|(
name|ARTFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* The bcopy is NECESSARY to insure alignment on some machines */
name|bcopy
argument_list|(
name|rhs
operator|.
name|dptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fpos
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|hfp
argument_list|,
name|fpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DBM */
name|hfp
operator|=
name|xfopen
argument_list|(
name|histfile
argument_list|(
name|oidbuf
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DBM */
while|while
condition|(
name|fgets
argument_list|(
name|lbuf
argument_list|,
name|BUFLEN
argument_list|,
name|hfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lbuf
argument_list|,
name|artid
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|lbuf
argument_list|,
name|oidbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\t'
expr_stmt|;
operator|*
operator|(
name|lbuf
operator|+
name|strlen
argument_list|(
name|lbuf
argument_list|)
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* zap the \n */
return|return
name|lbuf
return|;
block|}
ifdef|#
directive|ifdef
name|DBM
break|break;
endif|#
directive|endif
comment|/* DBM */
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Hunt up the article "artid", and return the newsgroup/artnum  * where it can be found.  */
end_comment

begin_function
name|char
modifier|*
name|findfname
parameter_list|(
name|artid
parameter_list|)
name|char
modifier|*
name|artid
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
specifier|static
name|char
name|fname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|line
operator|=
name|findhist
argument_list|(
name|artid
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
block|{
comment|/* Look for it stored as an article, where it should be */
name|p
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|fname
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Hunt up the article "artid", fopen it for read, and return a  * file descriptor to it.  We look everywhere we can think of.  */
end_comment

begin_function
name|FILE
modifier|*
name|hfopen
parameter_list|(
name|artid
parameter_list|)
name|char
modifier|*
name|artid
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|rv
init|=
name|NULL
decl_stmt|;
name|char
name|fname
index|[
name|BUFLEN
index|]
decl_stmt|;
name|p
operator|=
name|findfname
argument_list|(
name|artid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|dirname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* NOT xfopen! */
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot hfopen article %s"
argument_list|,
name|artid
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DBM
end_ifdef

begin_comment
comment|/* ** Avoid problems of multiple dbminit calls. */
end_comment

begin_macro
name|initdbm
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|called
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|called
operator|!=
literal|0
condition|)
return|return;
name|called
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|dbminit
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_comment
comment|/*  * move n bytes from a to b  */
end_comment

begin_expr_stmt
name|bcopy
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|a
operator|,
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
end_if

begin_expr_stmt
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|char
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BSD4_2&& ! BSD4_1C */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBM
end_ifndef

begin_comment
comment|/* ** Generate the appropriate history subfile name */
end_comment

begin_function
name|char
modifier|*
name|histfile
parameter_list|(
name|hline
parameter_list|)
name|char
modifier|*
name|hline
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|chr
decl_stmt|;
comment|/* least significant digit of article number */
specifier|static
name|char
name|subfile
index|[
name|BUFLEN
index|]
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|hline
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|>
name|hline
condition|)
name|chr
operator|=
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|chr
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|chr
argument_list|)
condition|)
name|chr
operator|=
literal|'0'
expr_stmt|;
name|sprintf
argument_list|(
name|subfile
argument_list|,
literal|"%s.d/%c"
argument_list|,
name|ARTFILE
argument_list|,
name|chr
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|subfile
argument_list|,
literal|04
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARTFILE
operator|)
return|;
return|return
operator|(
name|subfile
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DBM */
end_comment

end_unit

