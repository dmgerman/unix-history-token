begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * readr - /bin/mail and msgs interface and associated functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)readr.c	2.55	1/17/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_1C
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BSD4_2&& !BSD4_1C */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Progname
init|=
literal|"readnews"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by xerror to identify failing program */
end_comment

begin_decl_stmt
specifier|static
name|char
name|lbuf
index|[
name|BUFLEN
operator|*
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|atol
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|saveart
value|oobit = bit;strcpy(ofilename1, filename);strcpy(ogroupdir, groupdir);hptr = h;h = hold;hold = hptr;ongsize = pngsize
end_define

begin_define
define|#
directive|define
name|NLINES
parameter_list|(
name|h
parameter_list|,
name|fp
parameter_list|)
value|(h->numlines[0] ? h->intnumlines : (h->intnumlines=linecnt(fp),sprintf(h->numlines, "%d", h->intnumlines), h->intnumlines))
end_define

begin_decl_stmt
name|char
modifier|*
name|tft
init|=
literal|"/tmp/folXXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These were made static for u370 with its buggy cc.  * I judged it better to have one copy with no ifdefs than  * to conditionally compile them as automatic variables  * in readr (which they originally were).  Performance  * considerations might warrant moving some of the simple  * things into register variables, but I don't know what  * breaks the u370 cc.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|goodone
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last decent article		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|ogroupdir
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last groupdir		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|address
index|[
name|PATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for reply copy		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|edcmdbuf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rfq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for last article		*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|ongsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous ngsize		*/
end_comment

begin_decl_stmt
specifier|static
name|long
name|pngsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Printing ngsize		*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp pointer.		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|srec
name|srec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* srec for sys file entries	*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary file name 		*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|ofilename1
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous file name		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|hbuf1
decl_stmt|,
name|hbuf2
decl_stmt|,
comment|/* for minusing			*/
modifier|*
name|h
init|=
operator|&
name|hbuf1
decl_stmt|,
comment|/* current header		*/
modifier|*
name|hold
init|=
operator|&
name|hbuf2
decl_stmt|,
comment|/* previous header		*/
modifier|*
name|hptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary 			*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ptr1
decl_stmt|,
modifier|*
name|ptr2
decl_stmt|,
modifier|*
name|ptr3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for reply manipulation	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|abs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we asked absolutely	*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|tf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|oobit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last bit, really		*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|dgest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ofp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current output file to terminal*/
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current article to be printed*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|holdup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff should stop before hdr */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignorenews
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff readnews -p> /dev/null*/
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|timelastsaved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time newsrc last written out */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|sigjmpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for signal processing */
end_comment

begin_decl_stmt
specifier|static
name|int
name|canlongjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if setjmp on sigjmp valid */
end_comment

begin_function_decl
name|int
name|catchcont
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|readr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|m
init|=
name|getenv
argument_list|(
literal|"MORE"
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|m2
decl_stmt|,
name|cc
decl_stmt|;
comment|/* 	 * Turn of more's 'l' option, so \f kludge will work. 	 * This is really revolting! 	 */
if|if
condition|(
name|m2
operator|=
name|m
condition|)
block|{
while|while
condition|(
name|cc
operator|=
operator|*
name|m
operator|++
condition|)
if|if
condition|(
name|cc
operator|!=
literal|'l'
condition|)
operator|*
name|m2
operator|++
operator|=
name|cc
expr_stmt|;
operator|*
name|m2
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readr()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aflag
condition|)
block|{
if|if
condition|(
operator|*
name|datebuf
condition|)
block|{
if|if
condition|(
operator|(
name|atime
operator|=
name|cgtdate
argument_list|(
name|datebuf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|xerror
argument_list|(
literal|"Cannot parse date string"
argument_list|)
expr_stmt|;
block|}
else|else
name|atime
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pflag
operator|&&
name|ignoring
argument_list|()
condition|)
name|ignorenews
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|xflag
condition|)
name|uflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uflag
condition|)
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|timelastsaved
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|cflag
operator|&&
name|coptbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
comment|/* get "unique" file name */
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|outfile
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|N_UMASK
argument_list|)
expr_stmt|;
name|cflag
operator|=
name|FALSE
expr_stmt|;
name|pflag
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* loop reading articles. */
name|fp
operator|=
name|NULL
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|nextng
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|getnextart
argument_list|(
name|FALSE
argument_list|)
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"after getnextart, fp %x, pos %ld, bit %ld, group '%s', filename '%s'\n"
argument_list|,
name|fp
argument_list|,
name|ftell
argument_list|(
name|fp
argument_list|)
argument_list|,
name|bit
argument_list|,
name|groupdir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|goodone
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
operator|||
name|lflag
operator|||
name|eflag
condition|)
block|{
comment|/* This code should be gotten rid of */
if|if
condition|(
name|SigTrap
condition|)
block|{
name|qfflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|cdump
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* kludge! drop when qfflush works */
return|return;
block|}
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|pp
decl_stmt|;
name|int
name|nlines
decl_stmt|;
name|int
function_decl|(
modifier|*
name|ointr
function_decl|)
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|SIGCONT
name|int
function_decl|(
modifier|*
name|ocont
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|sigjmpbuf
argument_list|)
expr_stmt|;
name|canlongjmp
operator|=
name|TRUE
expr_stmt|;
name|SigTrap
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
if|if
condition|(
name|rfq
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Last article.  [qfr] "
argument_list|)
expr_stmt|;
else|else
block|{
name|nlines
operator|=
name|NLINES
argument_list|(
name|h
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"(0 lines) Next? [nqfr] "
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"(%d lines) More? [ynq] "
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"? "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|bptr
operator|=
name|lbuf
expr_stmt|;
name|ointr
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catchcont
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCONT
name|ocont
operator|=
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|catchcont
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pp
operator|=
name|fgets
argument_list|(
name|bptr
argument_list|,
name|BUFLEN
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|canlongjmp
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ointr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCONT
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCONT
argument_list|,
name|ocont
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|SigTrap
condition|)
return|return;
ifdef|#
directive|ifdef
name|SIGCONT
if|if
condition|(
name|SigTrap
operator|!=
name|SIGCONT
condition|)
endif|#
directive|endif
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nstrip
argument_list|(
name|bptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
operator|||
operator|*
name|bptr
operator|==
literal|'\t'
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
name|command
argument_list|()
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|pflag
operator|&&
operator|!
name|news
condition|)
block|{
if|if
condition|(
operator|!
name|checkngs
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
name|actfp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No news.\n"
argument_list|)
expr_stmt|;
block|}
name|cout
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|EOL
parameter_list|()
value|if (*bptr != '\0') { fprintf(ofp, "? for commands.\n"); return FALSE; }
end_define

begin_comment
comment|/*  * Process one command, which has already been typed in.  */
end_comment

begin_macro
name|command
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
name|long
name|i
decl_stmt|;
switch|switch
condition|(
operator|*
name|bptr
operator|++
condition|)
block|{
comment|/* No.  Go on to next article. */
case|case
literal|'n'
case|:
name|EOL
argument_list|()
expr_stmt|;
name|readmode
operator|=
name|NEXT
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
break|break;
comment|/* Undigestify the article. */
case|case
literal|'d'
case|:
name|dgest
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
comment|/* yes: print this article, go on. */
case|case
literal|'y'
case|:
name|EOL
argument_list|()
expr_stmt|;
comment|/* fall through. */
comment|/* The user hit return.  Default is 'y' unless rfq, then it's 'q'. */
case|case
literal|'\0'
case|:
if|if
condition|(
operator|!
name|bptr
index|[
operator|-
literal|1
index|]
operator|&&
name|rfq
condition|)
return|return
name|TRUE
return|;
name|readmode
operator|=
name|NEXT
expr_stmt|;
name|showtail
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Unsubscribe to the newsgroup and go on to next group 	 */
case|case
literal|'u'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"To unsubscribe, use 'U'\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Unsubscribing to newsgroup: %s\n"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
name|zapng
operator|=
name|TRUE
expr_stmt|;
name|saveart
expr_stmt|;
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
break|break;
comment|/* Print the current version of news */
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"News version: %s\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
break|break;
comment|/* reprint the article */
case|case
literal|'p'
case|:
name|EOL
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
goto|goto
name|minus
goto|;
name|readmode
operator|=
name|NEXT
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bit
operator|=
name|last
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* decrypt joke */
case|case
literal|'D'
case|:
name|caesar_command
argument_list|()
expr_stmt|;
name|readmode
operator|=
name|NEXT
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
break|break;
comment|/* write out the article someplace */
case|case
literal|'s'
case|:
case|case
literal|'w'
case|:
block|{
name|char
modifier|*
name|grn
init|=
name|groupdir
decl_stmt|;
name|tfilename
operator|=
name|filename
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
name|bptr
operator|++
expr_stmt|;
name|grn
operator|=
name|ogroupdir
expr_stmt|;
if|if
condition|(
operator|*
name|ofilename1
condition|)
name|tfilename
operator|=
name|ofilename1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'\0'
operator|&&
operator|*
name|bptr
operator|!=
literal|' '
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Bad file name.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'|'
operator|&&
operator|*
name|bptr
operator|!=
literal|'/'
condition|)
block|{
name|char
name|hetyped
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|boxptr
decl_stmt|;
name|struct
name|stat
name|stbf
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hetyped
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hetyped
index|[
literal|0
index|]
operator|==
literal|'~'
operator|&&
name|hetyped
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|hetyped
argument_list|,
name|bptr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|userhome
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|boxptr
operator|=
name|getenv
argument_list|(
literal|"NEWSBOX"
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|boxptr
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|bptr
argument_list|,
name|boxptr
argument_list|,
name|grn
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bptr
argument_list|,
operator|&
name|stbf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|bptr
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Cannot create directory %s"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|stbf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s is not a directory"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|strcpy
argument_list|(
name|bptr
argument_list|,
name|boxptr
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bptr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hetyped
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|bptr
argument_list|,
name|hetyped
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"Articles"
argument_list|)
expr_stmt|;
block|}
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|save
argument_list|,
name|tfilename
argument_list|,
name|bptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* back up  */
case|case
literal|'-'
case|:
name|minus
label|:
name|rfq
operator|=
literal|0
expr_stmt|;
name|abs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ofilename1
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
block|{
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
name|hptr
operator|=
name|h
expr_stmt|;
name|h
operator|=
name|hold
expr_stmt|;
name|hold
operator|=
name|hptr
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|ofilename1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ofilename1
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|obit
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
block|}
name|bit
operator|=
name|oobit
expr_stmt|;
name|oobit
operator|=
name|obit
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|getnextart
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* skip forwards */
case|case
literal|'+'
case|:
name|caseplus
label|:
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|bptr
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|last
operator|=
name|bit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|atol
argument_list|(
name|bptr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|nextbit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bit
operator|>
name|pngsize
operator|)
operator|||
operator|(
name|rflag
operator|&&
name|bit
operator|<
literal|1
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
comment|/* exit - time updated to that of most recently read article */
case|case
literal|'q'
case|:
name|EOL
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
comment|/* exit - no time update. */
case|case
literal|'x'
case|:
name|EOL
argument_list|()
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* cancel the article. */
case|case
literal|'c'
case|:
operator|(
name|void
operator|)
name|cancel_command
argument_list|()
expr_stmt|;
break|break;
comment|/* escape to shell */
case|case
literal|'!'
case|:
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|ushell
argument_list|,
name|bptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|hdr
argument_list|()
expr_stmt|;
break|break;
comment|/* mail reply */
case|case
literal|'r'
case|:
operator|(
name|void
operator|)
name|reply_command
argument_list|()
expr_stmt|;
break|break;
comment|/* send to some system */
case|case
literal|'X'
case|:
name|xmit_command
argument_list|()
expr_stmt|;
break|break;
comment|/* mark the rest of the articles in this group as read */
case|case
literal|'K'
case|:
name|saveart
expr_stmt|;
while|while
condition|(
name|bit
operator|<=
name|pngsize
operator|&&
name|bit
operator|>=
name|minartno
condition|)
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
block|}
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
comment|/* next newsgroup */
case|case
literal|'P'
case|:
operator|*
name|bptr
operator|=
literal|'-'
expr_stmt|;
case|case
literal|'N'
case|:
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_ng_command
argument_list|()
condition|)
return|return
name|TRUE
return|;
break|break;
case|case
literal|'b'
case|:
comment|/* back up 1 article */
name|i
operator|=
name|bit
operator|-
literal|1
expr_stmt|;
goto|goto
name|tryartnum
goto|;
case|case
literal|'0'
case|:
comment|/* specific no. */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|--
name|bptr
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Bad article no.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|pngsize
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Not that many articles.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|tryartnum
label|:
name|readmode
operator|=
name|SPEC
expr_stmt|;
name|abs
operator|=
name|TRUE
expr_stmt|;
name|bit
operator|=
name|i
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|rfq
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* specific message ID. */
case|case
literal|'<'
case|:
name|ptr1
operator|=
name|findhist
argument_list|(
operator|--
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr1
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"No such article: %s.\n"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr2
operator|=
name|index
argument_list|(
name|ptr1
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|ptr3
operator|=
name|index
argument_list|(
operator|++
name|ptr2
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|ptr2
operator|=
name|index
argument_list|(
operator|++
name|ptr3
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr2
condition|)
operator|*
name|ptr2
operator|=
literal|'\0'
expr_stmt|;
name|ptr2
operator|=
name|index
argument_list|(
name|ptr3
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr2
condition|)
block|{
operator|*
name|ptr3
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|++
name|ptr3
argument_list|,
literal|"cancelled"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %s has been cancelled.\n"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %s (dated %s) has expired.\n"
argument_list|,
name|bptr
argument_list|,
name|index
argument_list|(
name|ptr1
argument_list|,
literal|'\t'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|ptr2
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|abs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
block|{
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
name|saveart
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|ptr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|,
name|TRUE
argument_list|,
name|PERHAPS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ogroupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|ptr2
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
name|oobit
operator|=
name|obit
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|bit
expr_stmt|;
operator|(
name|void
operator|)
name|getnextart
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|!=
name|i
operator|||
name|strcmp
argument_list|(
name|groupdir
argument_list|,
name|ptr3
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't read %s/%ld.\n"
argument_list|,
name|ptr3
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|minus
goto|;
block|}
name|rfq
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* follow-up article */
case|case
literal|'f'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|followto
argument_list|,
literal|"poster"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|reply_command
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
name|tfilename
operator|=
name|ofilename1
expr_stmt|;
else|else
name|tfilename
operator|=
name|filename
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s %s"
argument_list|,
name|BIN
argument_list|,
literal|"postnews"
argument_list|,
name|tfilename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
break|break;
comment|/* erase - pretend we haven't seen this article. */
case|case
literal|'e'
case|:
if|if
condition|(
name|rfq
operator|||
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
condition|)
block|{
name|i
operator|=
name|bit
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|ogroupdir
argument_list|,
name|FALSE
argument_list|,
name|PERHAPS
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|oobit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Holding article %ld newsgroup %s\n"
argument_list|,
name|oobit
argument_list|,
name|ogroupdir
argument_list|)
operator|,
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|ogroupdir
argument_list|)
expr_stmt|;
name|selectng
argument_list|(
name|bfr
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|bit
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Holding article %ld\n"
argument_list|,
name|oobit
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|oobit
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Holding article %ld\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|bit
argument_list|)
expr_stmt|;
goto|goto
name|caseplus
goto|;
comment|/* skip this article for now */
block|}
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
if|if
condition|(
operator|!
name|hflag
condition|)
name|dash
argument_list|(
literal|8
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|oobit
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %ld:\n"
argument_list|,
name|oobit
argument_list|)
expr_stmt|;
name|hprint
argument_list|(
name|hold
argument_list|,
name|ofp
argument_list|,
literal|1
operator|+
operator|(
name|bptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'H'
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %ld of %ld: %s\n"
argument_list|,
name|rfq
condition|?
name|oobit
else|:
name|bit
argument_list|,
name|pngsize
argument_list|,
name|h
operator|->
name|ident
argument_list|)
expr_stmt|;
name|hprint
argument_list|(
name|h
argument_list|,
name|ofp
argument_list|,
literal|1
operator|+
operator|(
name|bptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'H'
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hflag
condition|)
name|dash
argument_list|(
literal|8
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %ld of %ld: newsgroup %s\n"
argument_list|,
name|rfq
condition|?
name|oobit
else|:
name|bit
argument_list|,
name|pngsize
argument_list|,
name|rfq
condition|?
name|ogroupdir
else|:
name|groupdir
argument_list|)
expr_stmt|;
break|break;
comment|/* error */
case|case
literal|'?'
case|:
name|help
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"? for commands.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|cancel_command
argument_list|()
end_macro

begin_block
block|{
name|int
name|notauthor
decl_stmt|;
name|tfilename
operator|=
name|filename
expr_stmt|;
name|hptr
operator|=
name|h
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|ofilename1
condition|)
block|{
name|tfilename
operator|=
name|ofilename1
expr_stmt|;
name|hptr
operator|=
name|hold
expr_stmt|;
block|}
name|bptr
operator|++
expr_stmt|;
block|}
name|EOL
argument_list|()
expr_stmt|;
name|readmode
operator|=
name|SPEC
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rcbuf
argument_list|,
name|hptr
operator|->
name|path
argument_list|)
expr_stmt|;
name|ptr1
operator|=
name|index
argument_list|(
name|rcbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr1
condition|)
operator|*
name|ptr1
operator|=
literal|0
expr_stmt|;
name|notauthor
operator|=
name|strcmp
argument_list|(
name|username
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
name|ROOTID
operator|&&
name|uid
operator|&&
name|notauthor
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't cancel what you didn't write.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|cancel
argument_list|(
name|ofp
argument_list|,
name|hptr
argument_list|,
name|notauthor
argument_list|)
operator|&&
name|hptr
operator|==
name|h
condition|)
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|saveart
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|reply_command
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|pathptr
decl_stmt|;
name|int
name|edit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|ed
decl_stmt|,
modifier|*
name|fbp
decl_stmt|;
name|int
name|idlen
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|char
modifier|*
name|replyname
parameter_list|()
function_decl|;
name|char
name|subj
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
name|folbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|long
name|creatm
decl_stmt|;
name|hptr
operator|=
name|h
expr_stmt|;
while|while
condition|(
operator|*
name|bptr
operator|&&
name|index
argument_list|(
literal|"d-"
argument_list|,
operator|*
name|bptr
argument_list|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|bptr
condition|)
block|{
comment|/* Followup the previous article. */
case|case
literal|'-'
case|:
name|hptr
operator|=
name|hold
expr_stmt|;
break|break;
comment|/* Don't edit the headers */
case|case
literal|'d'
case|:
name|edit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bptr
operator|++
expr_stmt|;
block|}
name|EOL
argument_list|()
expr_stmt|;
name|ptr1
operator|=
name|index
argument_list|(
name|MAILPARSER
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr1
condition|)
operator|*
name|ptr1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|edit
operator|&&
name|access
argument_list|(
name|MAILPARSER
argument_list|,
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|IHCC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't edit headers, 'recmail' missing.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't edit headers without %s\n"
argument_list|,
name|MAILPARSER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|edit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ptr1
condition|)
operator|*
name|ptr1
operator|=
literal|' '
expr_stmt|;
operator|*
name|rcbuf
operator|=
literal|'\0'
expr_stmt|;
name|pathptr
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
empty_stmt|;
for|for
control|(
name|ptr1
operator|=
name|address
operator|,
name|ptr2
operator|=
name|pathptr
init|;
operator|*
name|ptr2
condition|;
name|ptr1
operator|++
operator|,
name|ptr2
operator|++
control|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"\"\\$"
argument_list|,
operator|*
name|ptr2
argument_list|)
condition|)
operator|*
name|ptr1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|ptr1
operator|=
operator|*
name|ptr2
expr_stmt|;
block|}
operator|*
name|ptr1
operator|=
literal|'\0'
expr_stmt|;
name|folbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* References */
if|if
condition|(
name|hptr
operator|->
name|followid
index|[
literal|0
index|]
condition|)
block|{
name|fbp
operator|=
name|hptr
operator|->
name|followid
expr_stmt|;
name|idlen
operator|=
name|strlen
argument_list|(
name|hptr
operator|->
name|ident
argument_list|)
expr_stmt|;
comment|/* 		 * If the references line is too long, truncate it. 		 * The "3" is for the comma, the space, and the '\0' at 		 * the end of the string. 		 */
while|while
condition|(
name|fbp
operator|&&
name|strlen
argument_list|(
name|fbp
argument_list|)
operator|+
name|idlen
operator|>
name|BUFLEN
operator|-
literal|3
condition|)
name|fbp
operator|=
name|index
argument_list|(
name|fbp
operator|+
literal|1
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|folbuf
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|folbuf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|folbuf
argument_list|,
name|hptr
operator|->
name|ident
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|subj
argument_list|,
name|hptr
operator|->
name|title
argument_list|)
expr_stmt|;
comment|/* Subject */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bptr
argument_list|)
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|subj
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
argument_list|(
name|subj
argument_list|,
literal|"Re:"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|subj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|subj
argument_list|,
literal|"Re: %s"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|edit
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|pathptr
argument_list|)
expr_stmt|;
name|ed
operator|=
name|index
argument_list|(
name|MAILER
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|&&
name|ed
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
block|}
comment|/* Put the user in the editor to create the body of the followup. */
if|if
condition|(
name|edit
condition|)
block|{
name|int
name|oumask
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tf
argument_list|,
name|tft
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed
operator|==
name|NULL
condition|)
name|ed
operator|=
name|DFTEDITOR
expr_stmt|;
name|oumask
operator|=
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfp
operator|=
name|fopen
argument_list|(
name|tf
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|creatm
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|pathptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subj
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"News-Path: %s\n"
argument_list|,
name|hptr
operator|->
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INTERNET */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"References: %s\n\n"
argument_list|,
name|folbuf
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fileno
argument_list|(
name|tfp
argument_list|)
argument_list|,
operator|&
name|statb
argument_list|)
expr_stmt|;
name|creatm
operator|=
name|statb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oumask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|edcmdbuf
argument_list|,
literal|"%s %s"
argument_list|,
name|ed
argument_list|,
name|tf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|edcmdbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rcbuf
argument_list|,
name|MAILPARSER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|rcbuf
argument_list|,
literal|" -t"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|rcbuf
argument_list|,
literal|"< "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|rcbuf
argument_list|,
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|tf
argument_list|,
literal|4
argument_list|)
operator|||
name|stat
argument_list|(
name|tf
argument_list|,
operator|&
name|statb
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reply not sent: no input file.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|statb
operator|.
name|st_mtime
operator|==
name|creatm
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reply not sent: cancelled.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Sending reply.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|system
argument_list|(
name|rcbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
name|MAILER
argument_list|,
name|hptr
operator|->
name|title
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s %s"
argument_list|,
name|rcbuf
argument_list|,
name|address
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
name|hdr
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|xmit_command
argument_list|()
end_macro

begin_block
block|{
name|tfilename
operator|=
name|filename
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|ofilename1
condition|)
name|tfilename
operator|=
name|ofilename1
expr_stmt|;
name|bptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bptr
operator|!=
literal|'\0'
operator|&&
operator|*
name|bptr
operator|!=
literal|' '
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Bad system name.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|bptr
operator|==
literal|' '
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Missing system name.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s_find
argument_list|(
operator|&
name|srec
argument_list|,
name|bptr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s not in SYSFILE\n"
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|tfilename
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|next_ng_command
argument_list|()
end_macro

begin_block
block|{
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bptr
operator|||
operator|*
name|bptr
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
condition|)
name|actdirect
operator|=
name|BACKWARD
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
name|saveart
expr_stmt|;
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bptr
argument_list|)
condition|)
name|bptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|validng
argument_list|(
name|bptr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"No such group.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|cflag
condition|)
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|readmode
operator|=
name|SPEC
expr_stmt|;
name|rfq
operator|=
literal|0
expr_stmt|;
name|saveart
expr_stmt|;
name|back
argument_list|()
expr_stmt|;
name|selectng
argument_list|(
name|bptr
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|caesar_command
argument_list|()
end_macro

begin_block
block|{
name|char
name|temp
index|[
name|BUFLEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|pfp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Caesar decoding:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
literal|"caesar"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bptr
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|temp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|temp
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NLINES
argument_list|(
name|h
argument_list|,
name|fp
argument_list|)
operator|>
name|LNCNT
operator|&&
operator|*
name|PAGER
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|temp
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|temp
argument_list|,
name|PAGER
argument_list|)
expr_stmt|;
block|}
name|pfp
operator|=
name|popen
argument_list|(
name|temp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|fp
argument_list|,
name|pfp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Show the user the tail, if any, of the message on file  * descriptor fd, and close fd.  The digester is considered,  * and the pager is used if appropriate.  */
end_comment

begin_macro
name|showtail
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dgest
condition|)
block|{
name|digest
argument_list|(
name|fd
argument_list|,
name|ofp
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|lflag
operator|&&
operator|!
name|pflag
operator|&&
operator|!
name|eflag
condition|)
block|{
name|pprint
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print out the rest of the article through the pager.  */
end_comment

begin_macro
name|pprint
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|PAGE
comment|/* Filter the tail of long messages through PAGER. */
if|if
condition|(
name|NLINES
argument_list|(
name|h
argument_list|,
name|fd
argument_list|)
operator|>
name|LNCNT
operator|&&
operator|*
name|PAGER
condition|)
block|{
if|if
condition|(
operator|!
name|index
argument_list|(
name|PAGER
argument_list|,
name|FMETA
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|pfp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|pfp
operator|=
name|popen
argument_list|(
name|PAGER
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
name|pfp
operator|=
name|ofp
expr_stmt|;
comment|/* 			 * What follows is an attempt to prevent the 			 * next message from scrolling part of this 			 * message off the top of the screen before 			 * the poor luser can read it. 			 */
name|tprint
argument_list|(
name|fd
argument_list|,
name|pfp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\f'
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
else|else
name|pout
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|holdup
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|tprint
argument_list|(
name|fd
argument_list|,
name|ofp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Find the next article we want to consider, if we're done with  * the last one, and show the header.  */
end_comment

begin_macro
name|getnextart
argument_list|(
argument|minus
argument_list|)
end_macro

begin_decl_stmt
name|int
name|minus
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|noaccess
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dir
decl_stmt|;
name|long
name|nextnum
decl_stmt|,
name|tnum
decl_stmt|;
name|noaccess
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|minus
condition|)
goto|goto
name|nextart2
goto|;
comment|/* Kludge for "-" command. */
if|if
condition|(
name|bit
operator|==
name|obit
condition|)
comment|/* Return if still on same article as last time */
return|return
literal|0
return|;
name|SigTrap
operator|=
name|FALSE
expr_stmt|;
name|nextart
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextart:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|dgest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bit
operator|<
name|minartno
operator|&&
operator|!
name|rflag
condition|)
name|bit
operator|=
name|minartno
expr_stmt|;
comment|/* If done with this newsgroup, find the next one. */
while|while
condition|(
name|ngsize
operator|<=
literal|0
operator|||
operator|(
operator|!
name|rflag
operator|&&
operator|(
operator|(
name|long
operator|)
name|bit
operator|>
name|ngsize
operator|)
operator|)
operator|||
operator|(
name|rflag
operator|&&
name|bit
operator|<
name|minartno
operator|)
condition|)
block|{
if|if
condition|(
name|nextng
argument_list|()
condition|)
block|{
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Can't back up.\n"
argument_list|)
expr_stmt|;
name|actdirect
operator|=
name|FORWARD
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rfq
operator|++
operator|||
name|pflag
operator|||
name|cflag
condition|)
return|return
literal|1
return|;
break|break;
block|}
if|if
condition|(
name|rflag
condition|)
name|bit
operator|=
name|ngsize
operator|+
literal|1
expr_stmt|;
else|else
name|bit
operator|=
name|minartno
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|uflag
operator|&&
operator|!
name|xflag
condition|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|timelastsaved
operator|>
literal|5
operator|*
literal|60
comment|/* 5 minutes */
condition|)
block|{
if|if
condition|(
operator|!
name|xflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[Saving .newsrc]\n"
argument_list|)
expr_stmt|;
name|writeoutrc
argument_list|()
expr_stmt|;
name|timelastsaved
operator|=
name|now
expr_stmt|;
block|}
block|}
name|noaccess
operator|=
literal|0
expr_stmt|;
block|}
name|nextart2
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"article: %s/%ld\n"
argument_list|,
name|groupdir
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rcreadok
condition|)
name|rcreadok
operator|=
literal|2
expr_stmt|;
comment|/* have seen>= 1 article */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%ld"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfq
operator|&&
name|goodone
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|goodone
argument_list|)
expr_stmt|;
if|if
condition|(
name|SigTrap
condition|)
block|{
if|if
condition|(
name|SigTrap
operator|==
name|SIGHUP
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|rcreadok
condition|)
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Abort (n)?  "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gets
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bfr
operator|==
literal|'y'
operator|||
operator|*
name|bfr
operator|==
literal|'Y'
condition|)
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SigTrap
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"filename = '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Decide if we want to show this article. */
if|if
condition|(
name|bit
operator|<=
literal|0
operator|||
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* don't show the header if the article was specifically 		 * requested and it isn't there 		 */
if|if
condition|(
name|lbuf
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|lbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bit
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* since there can be holes in legal article numbers, */
comment|/* we wait till we hit 5 consecutive bad articles */
comment|/* before we haul off and scan the directory */
if|if
condition|(
operator|++
name|noaccess
operator|<
literal|5
condition|)
goto|goto
name|badart
goto|;
name|noaccess
operator|=
literal|0
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EACCES
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s\n"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badart
goto|;
block|}
name|nextnum
operator|=
name|rflag
condition|?
name|minartno
operator|-
literal|1
else|:
name|ngsize
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|dir
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tnum
operator|=
name|atol
argument_list|(
name|dir
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnum
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rflag
condition|?
operator|(
name|tnum
operator|>
name|nextnum
operator|&&
name|tnum
operator|<
name|bit
operator|)
else|:
operator|(
name|tnum
operator|<
name|nextnum
operator|&&
name|tnum
operator|>
name|bit
operator|)
condition|)
name|nextnum
operator|=
name|tnum
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|?
operator|(
name|nextnum
operator|>=
name|bit
operator|)
else|:
operator|(
name|nextnum
operator|<=
name|bit
operator|)
condition|)
goto|goto
name|badart
goto|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextnum = %ld\n"
argument_list|,
name|nextnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
do|do
block|{
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|rflag
condition|?
operator|(
name|nextnum
operator|<
name|bit
operator|)
else|:
operator|(
name|nextnum
operator|>
name|bit
operator|)
condition|)
do|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|abs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|nextart
goto|;
block|}
else|else
name|noaccess
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignorenews
operator|||
name|hread
argument_list|(
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
operator|||
operator|(
operator|!
name|rfq
operator|&&
operator|!
name|aselect
argument_list|(
name|h
argument_list|,
name|abs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ignorenews
condition|)
name|news
operator|=
name|TRUE
expr_stmt|;
name|badart
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad article '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|obit
operator|=
operator|-
literal|1
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|abs
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|nextart
goto|;
block|}
name|abs
operator|=
name|FALSE
expr_stmt|;
name|actdirect
operator|=
name|FORWARD
expr_stmt|;
name|news
operator|=
name|TRUE
expr_stmt|;
name|hdr
argument_list|()
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
name|tprint
argument_list|(
name|fp
argument_list|,
name|ofp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflag
operator|&&
operator|!
name|lflag
operator|&&
operator|!
name|eflag
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|pprint
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|||
name|lflag
operator|||
name|eflag
operator|||
name|pflag
condition|)
block|{
name|SigTrap
operator|=
name|FALSE
expr_stmt|;
name|FCLOSE
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|obit
operator|=
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Print out whatever the appropriate header is  */
end_comment

begin_macro
name|hdr
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|briefdate
parameter_list|()
function_decl|;
if|if
condition|(
name|rfq
condition|)
return|return;
if|if
condition|(
name|lflag
operator|||
name|eflag
condition|)
block|{
name|hprint
argument_list|(
name|h
argument_list|,
name|ofp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Print out a header */
if|if
condition|(
name|ngrp
condition|)
block|{
name|pngsize
operator|=
name|ngsize
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
name|nghprint
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hflag
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article %ld of %ld, %s.\n"
argument_list|,
name|bit
argument_list|,
name|pngsize
argument_list|,
name|briefdate
argument_list|(
name|h
operator|->
name|subdate
argument_list|)
argument_list|)
expr_stmt|;
name|hprint
argument_list|(
name|h
argument_list|,
name|ofp
argument_list|,
name|pflag
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nghprint
argument_list|(
argument|title
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|title
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|tstr
init|=
literal|"Newsgroup "
decl_stmt|;
name|int
name|l
init|=
name|strlen
argument_list|(
name|title
argument_list|)
operator|+
name|strlen
argument_list|(
name|tstr
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
condition|)
block|{
name|dash
argument_list|(
name|l
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s%s\n"
argument_list|,
name|tstr
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|dash
argument_list|(
name|l
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s%s, "
argument_list|,
name|tstr
argument_list|,
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|==
name|pngsize
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%ld\n"
argument_list|,
name|pngsize
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%ld-%ld\n"
argument_list|,
name|bit
argument_list|,
name|pngsize
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Routine to catch a continue signal.  */
end_comment

begin_macro
name|catchcont
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|sig
argument_list|,
name|catchcont
argument_list|)
expr_stmt|;
name|SigTrap
operator|=
name|sig
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCONT
if|if
condition|(
name|fp
operator|&&
name|sig
operator|==
name|SIGCONT
condition|)
name|hdr
argument_list|()
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGCONT
condition|)
endif|#
directive|endif
comment|/* SIGCONT */
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|canlongjmp
condition|)
name|longjmp
argument_list|(
name|sigjmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|xxit
argument_list|(
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SORTACTIVE
if|if
condition|(
name|strncmp
argument_list|(
name|ACTIVE
argument_list|,
literal|"/tmp/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ACTIVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SORTACTIVE */
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

