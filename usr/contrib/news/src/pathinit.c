begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * This function initializes all the strings used for the various  * filenames.  They cannot be compiled into the program, since that  * would be non-portable.  With this convention, the netnews sub-system  * can be owned by any non-privileged user.  It is also possible  * to work when the administration randomly moves users from one  * filesystem to another.  The convention is that a particular user  * (HOME, see Makefile) is searched for in /etc/passwd and all files  * are presumed relative to there.  This method also allows one copy  * of the object code to be used on ANY machine.  (this code runs  * un-modified on 50+ machines at IH!!)  *  * The disadvantage to using this method is that all netnews programs  * (inews, readnews, rnews, checknews) must first search /etc/passwd  * before they can start up.  This can cause significant overhead if  * you have a big password file.  *  * Some games are played with ifdefs to get four .o files out of this  * one source file.  INEW is defined for inews, READ for readnews,  * CHKN for checknews, and EXP for expire.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)pathinit.c	1.17	1/17/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INEW
argument_list|)
operator|||
name|defined
argument_list|(
name|EXP
argument_list|)
end_if

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INEW || EXP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|READ
end_ifdef

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* READ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHKN
argument_list|)
end_if

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHKN */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FULLSYSNAME
decl_stmt|,
modifier|*
name|SPOOL
decl_stmt|,
modifier|*
name|LIB
decl_stmt|,
modifier|*
name|BIN
decl_stmt|,
modifier|*
name|ACTIVE
decl_stmt|,
modifier|*
name|SUBFILE
decl_stmt|,
modifier|*
name|ARTFILE
decl_stmt|,
modifier|*
name|username
decl_stmt|,
modifier|*
name|userhome
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INEW
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|LOCKFILE
decl_stmt|,
modifier|*
name|SEQFILE
decl_stmt|,
modifier|*
name|ARTICLE
decl_stmt|,
modifier|*
name|INFILE
decl_stmt|,
modifier|*
name|TELLME
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INEW */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INEW
argument_list|)
operator|||
name|defined
argument_list|(
name|READ
argument_list|)
end_if

begin_decl_stmt
name|char
modifier|*
name|ALIASES
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INEW || READ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXP
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|OLDNEWS
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|READ
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|MAILPARSER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* READ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HIDDENNET
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|LOCALSYSNAME
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HIDDENNET */
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|Sprintf
parameter_list|(
name|where
parameter_list|,
name|fmt
parameter_list|,
name|arg
parameter_list|)
value|(void) sprintf(bfr,fmt,arg); where = AllocCpy(bfr)
end_define

begin_function
name|char
modifier|*
name|AllocCpy
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|mp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"malloc failed on %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_macro
name|pathinit
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|INEW
argument_list|)
operator|&&
name|defined
argument_list|(
name|NOTIFY
argument_list|)
name|FILE
modifier|*
name|nfd
decl_stmt|;
comment|/* notify file descriptor		*/
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
comment|/* INEW&& NOTIFY */
ifndef|#
directive|ifndef
name|ROOTID
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* struct for pw lookup			*/
endif|#
directive|endif
comment|/* !ROOTID */
ifdef|#
directive|ifdef
name|EXP
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
comment|/* EXP */
ifndef|#
directive|ifndef
name|CHKN
name|struct
name|utsname
name|ubuf
decl_stmt|;
name|uname
argument_list|(
operator|&
name|ubuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIDDENNET
name|FULLSYSNAME
operator|=
name|AllocCpy
argument_list|(
name|HIDDENNET
argument_list|)
expr_stmt|;
name|LOCALSYSNAME
operator|=
name|AllocCpy
argument_list|(
name|ubuf
operator|.
name|nodename
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !HIDDENNET */
name|FULLSYSNAME
operator|=
name|AllocCpy
argument_list|(
name|ubuf
operator|.
name|nodename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HIDDENNET */
endif|#
directive|endif
comment|/* !CHKN */
ifdef|#
directive|ifdef
name|HOME
comment|/* Relative to the home directory of user HOME */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|SPOOLDIR
argument_list|)
expr_stmt|;
name|SPOOL
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|LIBDIR
argument_list|)
expr_stmt|;
name|LIB
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !HOME */
comment|/* Fixed paths defined in Makefile */
name|SPOOL
operator|=
name|AllocCpy
argument_list|(
name|SPOOLDIR
argument_list|)
expr_stmt|;
name|LIB
operator|=
name|AllocCpy
argument_list|(
name|LIBDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HOME */
ifdef|#
directive|ifdef
name|IHCC
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|BINDIR
argument_list|)
expr_stmt|;
name|BIN
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !IHCC */
name|Sprintf
argument_list|(
name|BIN
argument_list|,
literal|"%s"
argument_list|,
name|BINDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !IHCC */
name|Sprintf
argument_list|(
name|ACTIVE
argument_list|,
literal|"%s/active"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXP
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|bfr
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|strcpy
argument_list|(
operator|++
name|p
argument_list|,
literal|"oldnews"
argument_list|)
expr_stmt|;
name|OLDNEWS
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
else|else
name|OLDNEWS
operator|=
name|AllocCpy
argument_list|(
literal|"oldnews"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EXP */
ifndef|#
directive|ifndef
name|CHKN
name|Sprintf
argument_list|(
name|SUBFILE
argument_list|,
literal|"%s/sys"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|ARTFILE
argument_list|,
literal|"%s/history"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !CHKN */
ifdef|#
directive|ifdef
name|READ
ifdef|#
directive|ifdef
name|SENDMAIL
name|Sprintf
argument_list|(
name|MAILPARSER
argument_list|,
literal|"%s -oi -oem"
argument_list|,
name|SENDMAIL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SENDMAIL */
name|Sprintf
argument_list|(
name|MAILPARSER
argument_list|,
literal|"%s/recmail"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SENDMAIL */
endif|#
directive|endif
comment|/* READ */
if|#
directive|if
name|defined
argument_list|(
name|READ
argument_list|)
operator|||
name|defined
argument_list|(
name|INEW
argument_list|)
name|Sprintf
argument_list|(
name|ALIASES
argument_list|,
literal|"%s/aliases"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* READ || INEW */
ifdef|#
directive|ifdef
name|INEW
name|Sprintf
argument_list|(
name|LOCKFILE
argument_list|,
literal|"%s/LOCK"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|SEQFILE
argument_list|,
literal|"%s/seq"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|ARTICLE
argument_list|,
literal|"%s/.arXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|INFILE
argument_list|,
literal|"%s/.inXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
comment|/*  * The person notified by the netnews sub-system.  Again, no name is  * compiled in, but instead the information is taken from a file.  * If the file does not exist, a "default" person will get the mail.  * If the file exists, but is empty, nobody will get the mail.  This  * may seem backwards, but is a better fail-safe.  */
ifdef|#
directive|ifdef
name|NOTIFY
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/notify"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|nfd
operator|=
name|fopen
argument_list|(
name|bfr
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfd
operator|!=
name|NULL
condition|)
block|{
name|bfr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|nfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* strip newline */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|TELLME
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfd
argument_list|)
expr_stmt|;
block|}
else|else
name|TELLME
operator|=
name|AllocCpy
argument_list|(
name|NOTIFY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
comment|/*  * Since the netnews owner's id number is different on different  * systems, we'll extract it from the /etc/passwd file.  If no entry,  * default to root.  This id number seems to only be used to control who  * can input certain control messages or cancel any message.  Note that  * entry is the name from the "notify" file as found above if possible.  * Defining ROOTID in defs.h hardwires in a number and avoids  * another search of /etc/passwd.  */
ifndef|#
directive|ifndef
name|ROOTID
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|TELLME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ROOTID
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|HOME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ROOTID
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
else|else
name|ROOTID
operator|=
literal|0
expr_stmt|;
comment|/* nobody left, let only root */
endif|#
directive|endif
comment|/* !ROOTID */
endif|#
directive|endif
comment|/* INEW */
block|}
end_block

end_unit

