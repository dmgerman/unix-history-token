begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Header: xnsprint.c,v 2.0 85/11/21 07:23:11 jqj Exp $  *  * a program to print InterPress masters on an InterPress printer via  * Ethernet.   Uses xns Courier.  * This version runs on 4.3BSD only!  */
end_comment

begin_comment
comment|/*  * $Log:	xnsprint.c,v $  * Revision 2.0  85/11/21  07:23:11  jqj  * 4.3BSD standard release  *   * Revision 1.1  85/11/20  13:56:53  jqj  * Initial revision  *   * modified 8-6-85 by jqj.  *  Eliminated any hardwired addresses.  Instead, use CH_Enumerate to  *  find a printer if none is specified.  Also, you can now print multiple  *  files in a single call to xnsprint, and getopt() is used to parse  *  arguments.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/sp.h>
end_include

begin_include
include|#
directive|include
file|"Printing3_defs.h"
end_include

begin_include
include|#
directive|include
file|<xnscourier/Clearinghouse2.h>
end_include

begin_include
include|#
directive|include
file|<xnscourier/except.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ipfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ExitStatus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modified lpd conventions: */
end_comment

begin_comment
comment|/* 0 => Job printed.  (successfully sent to print-server) */
end_comment

begin_define
define|#
directive|define
name|X_GOOD
value|0
end_define

begin_comment
comment|/* 1 => Couldn't send job.  Retry forever, should go eventually. */
end_comment

begin_define
define|#
directive|define
name|X_RETRY
value|1
end_define

begin_comment
comment|/* 2 => Couldn't send job,  Strange error, Retry a limited number*/
end_comment

begin_comment
comment|/*		of times.  If it still hasn't worked, give up.	 */
end_comment

begin_define
define|#
directive|define
name|X_LIMRETRY
value|2
end_define

begin_comment
comment|/* 3 => Couldn't send job:  Hard error, don't bother retrying,	 */
end_comment

begin_comment
comment|/*		get rid of the job.				 */
end_comment

begin_define
define|#
directive|define
name|X_NORETRY
value|3
end_define

begin_macro
name|SendSource
argument_list|(
argument|bdtconnection
argument_list|)
end_macro

begin_decl_stmt
name|CourierConnection
modifier|*
name|bdtconnection
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|;
name|char
name|buffer
index|[
name|SPPMAXDATA
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|SPPMAXDATA
argument_list|,
name|ipfile
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|BDTwrite
argument_list|(
name|bdtconnection
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|BDTclosewrite
argument_list|(
name|bdtconnection
argument_list|)
expr_stmt|;
comment|/* last packet with EOM set */
else|else
name|BDTabort
argument_list|(
name|bdtconnection
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * misc externals  */
end_comment

begin_decl_stmt
name|int
name|remove
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|attn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write lpr system STATUS file?	LCP 850415*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|attnfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status file name.		LCP 850415 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FileName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UserName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Banner
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|copies
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Clearinghouse2_Name
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xnshost
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_macro
name|setxnshost
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|Clearinghouse2_ObjectName
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
if|if
condition|(
name|xnshost
operator|==
name|NULL
condition|)
name|xnshost
operator|=
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
operator|.
name|object
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|name
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|ns_addr
modifier|*
name|destaddr
decl_stmt|;
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
specifier|extern
name|struct
name|ns_addr
modifier|*
name|getXNSaddr
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|ns_addr
modifier|*
name|CH_LookupAddr
parameter_list|()
function_decl|;
name|Clearinghouse2_Name
name|hostname
decl_stmt|,
name|defaultname
decl_stmt|;
specifier|extern
name|Clearinghouse2_Name
name|CH_StringToName
parameter_list|()
function_decl|;
name|int
name|opt
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:n:b:P:h:rqa:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* copies */
name|copies
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* user name */
name|UserName
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* file name */
name|Banner
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* printer */
case|case
literal|'h'
case|:
comment|/* host */
name|xnshost
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* remove input file when done */
name|remove
operator|++
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* don't print status messages */
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Write lpr STATUS file.  Name follows.  LCP 850415 */
name|quiet
operator|++
expr_stmt|;
name|attn
operator|++
expr_stmt|;
name|attnfile
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|errflg
condition|)
block|{
name|attnmsg
argument_list|(
literal|"Usage: %s [-r] [-P host] [-c #] [-n name] [-b banner] file...\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_NORETRY
argument_list|)
expr_stmt|;
block|}
comment|/* set User Name for banner if necessary */
if|if
condition|(
name|UserName
operator|==
name|NULL
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|getpwuid
argument_list|()
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|UserName
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UserName
operator|=
name|pwd
operator|->
name|pw_gecos
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|index
argument_list|(
name|UserName
argument_list|,
literal|','
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\000'
expr_stmt|;
block|}
block|}
comment|/* figure out what address we're sending to */
name|CH_NameDefault
argument_list|(
operator|&
name|defaultname
argument_list|)
expr_stmt|;
comment|/* default from clearinghouse.addresses */
if|if
condition|(
name|xnshost
operator|==
name|NULL
condition|)
block|{
comment|/* find the first object in the local domain of the CH  		 * with a printService property.  setxnshost sets xnshost 		 * to the name part of the object 		 */
name|hostname
operator|=
name|defaultname
expr_stmt|;
name|hostname
operator|.
name|object
operator|=
literal|"*"
expr_stmt|;
name|CH_Enumerate
argument_list|(
name|hostname
argument_list|,
literal|10001
argument_list|,
name|setxnshost
argument_list|)
expr_stmt|;
name|hostname
operator|.
name|object
operator|=
name|xnshost
expr_stmt|;
block|}
else|else
name|hostname
operator|=
name|CH_StringToName
argument_list|(
name|xnshost
argument_list|,
operator|&
name|defaultname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|destaddr
operator|=
name|CH_LookupAddr
argument_list|(
name|hostname
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|attnmsg
argument_list|(
literal|"Invalid address, %s:%s:%s\n"
argument_list|,
name|hostname
operator|.
name|object
argument_list|,
name|hostname
operator|.
name|domain
argument_list|,
name|hostname
operator|.
name|organization
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_NORETRY
argument_list|)
expr_stmt|;
block|}
comment|/* make sure the printer is available */
name|checkIPstatus
argument_list|(
name|destaddr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|FileName
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|FileName
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipfile
operator|=
name|stdin
expr_stmt|;
name|FileName
operator|=
literal|"standard input"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ipfile
operator|=
name|fopen
argument_list|(
name|FileName
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_NORETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Banner
operator|==
name|NULL
condition|)
name|Banner
operator|=
name|FileName
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Sending to %s..."
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sendIPfile
argument_list|(
name|ipfile
argument_list|,
name|destaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|ipfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_GOOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check printer status first so we won't dump big interpress  * files accross the net unless we're fairly confidant that they'll  * be accepted.  */
end_comment

begin_macro
name|checkIPstatus
argument_list|(
argument|destaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ns_addr
modifier|*
name|destaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
name|GetPrinterStatusResults
name|StatusResult
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Opening connection to %s. "
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Opening connection to %s.\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conn
operator|=
name|CourierOpen
argument_list|(
name|destaddr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Can't open connection to %s\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_LIMRETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Connected.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Requesting status.\n"
argument_list|)
expr_stmt|;
name|DURING
name|StatusResult
init|=
name|GetPrinterStatus
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|HANDLER
block|{
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
switch|switch
condition|(
name|Exception
operator|.
name|Code
condition|)
block|{
case|case
name|ServiceUnavailable
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"GetStat: Service unavailable\n"
argument_list|)
expr_stmt|;
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
break|break;
case|case
name|SystemError
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"GetStat: System Error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Undefined
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"GetStat: Undefined error, number %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|UndefinedArgs
argument_list|,
name|problem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REJECT_ERROR
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"GetStat: REJECT:  type = %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|rejectionDetails
argument_list|,
name|designator
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"GetStat: Some random error, code %d\n"
argument_list|,
name|Exception
operator|.
name|Code
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStatus
argument_list|)
expr_stmt|;
block|}
name|END_HANDLER
expr_stmt|;
name|CourierClose
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|printresults
argument_list|(
name|StatusResult
operator|.
name|status
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
end_block

begin_comment
comment|/*   * display printer status, return 0 IFF spooler is available   */
end_comment

begin_function
name|int
name|printresults
parameter_list|(
name|status
parameter_list|)
name|PrinterStatus
name|status
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|typ
decl_stmt|;
specifier|static
name|char
modifier|*
name|spoollist
index|[]
init|=
block|{
literal|"available"
block|,
literal|"busy"
block|,
literal|"disabled"
block|,
literal|"full"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|formatlist
index|[]
init|=
block|{
literal|"available"
block|,
literal|"busy"
block|,
literal|"disabled"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|printlist
index|[]
init|=
block|{
literal|"available"
block|,
literal|"busy"
block|,
literal|"disabled"
block|,
literal|"needs attention"
block|,
literal|"needs key operator"
block|}
decl_stmt|;
name|int
name|error
init|=
literal|1
decl_stmt|;
name|char
name|bufr
index|[
literal|256
index|]
decl_stmt|;
name|bufr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|designator
condition|)
block|{
case|case
name|spooler
case|:
name|typ
operator|=
operator|(
name|int
operator|)
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|spooler_case
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|||
name|typ
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|bufr
operator|+
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|,
literal|"Spooler: %s; "
argument_list|,
name|spoollist
index|[
name|typ
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|typ
expr_stmt|;
break|break;
case|case
name|formatter
case|:
name|typ
operator|=
operator|(
name|int
operator|)
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|formatter_case
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|||
name|typ
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|bufr
operator|+
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|,
literal|"Formatter: %s; "
argument_list|,
name|formatlist
index|[
name|typ
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|printer
case|:
name|typ
operator|=
operator|(
name|int
operator|)
name|status
operator|.
name|sequence
index|[
name|i
index|]
operator|.
name|printer_case
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|||
name|typ
operator|>
literal|1
condition|)
name|sprintf
argument_list|(
name|bufr
operator|+
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|,
literal|"Printer: %s. "
argument_list|,
name|printlist
index|[
name|typ
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|media
case|:
comment|/* printmedia(status.sequence[i].media_case); */
break|break;
block|}
block|}
if|if
condition|(
name|bufr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"%s\n"
argument_list|,
name|bufr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|bufr
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Retrying... "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufr
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Status: Busy.  Retrying...\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|15
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_macro
name|attnmsg
argument_list|(
argument|fmt
argument_list|,
argument|a0
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|,
argument|a9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|bufr
index|[
literal|256
index|]
decl_stmt|;
name|int
name|af
decl_stmt|;
if|if
condition|(
name|attn
condition|)
block|{
if|if
condition|(
operator|(
name|af
operator|=
name|open
argument_list|(
name|attnfile
argument_list|,
name|O_TRUNC
operator||
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* Oh Well. */
name|sprintf
argument_list|(
name|bufr
argument_list|,
name|fmt
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|af
argument_list|,
name|bufr
argument_list|,
name|strlen
argument_list|(
name|bufr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In case of error??? */
name|close
argument_list|(
name|af
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sendIPfile
argument_list|(
argument|ipfile
argument_list|,
argument|destaddr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|ipfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns_addr
modifier|*
name|destaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PrintResults
name|result
decl_stmt|;
name|CourierConnection
modifier|*
name|conn
decl_stmt|;
name|PrintAttributes
name|attributes
decl_stmt|;
name|PrintOptions
name|options
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* only use sender name and file name, no date */
name|attributes
operator|.
name|length
operator|=
literal|2
expr_stmt|;
name|attributes
operator|.
name|sequence
operator|=
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|attributes
operator|.
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|designator
operator|=
name|printObjectName
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|printObjectName_case
operator|=
name|Banner
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|1
index|]
operator|.
name|designator
operator|=
name|senderName
expr_stmt|;
name|attributes
operator|.
name|sequence
index|[
literal|1
index|]
operator|.
name|senderName_case
operator|=
name|UserName
expr_stmt|;
name|options
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|options
operator|.
name|sequence
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|options
operator|.
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|designator
operator|=
name|copyCount
expr_stmt|;
name|options
operator|.
name|sequence
index|[
literal|0
index|]
operator|.
name|copyCount_case
operator|=
name|copies
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Opening connection to %s. "
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Opening connection to %s.\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|conn
operator|=
name|CourierOpen
argument_list|(
name|destaddr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Can't open connection to %s\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|X_LIMRETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Connected.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Sending to %s\n"
argument_list|,
name|xnshost
argument_list|)
expr_stmt|;
name|DURING
name|result
init|=
name|Print
argument_list|(
name|conn
argument_list|,
name|SendSource
argument_list|,
name|BulkData1_immediateSource
argument_list|,
name|attributes
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|HANDLER
block|{
name|ExitStatus
operator|=
name|X_RETRY
expr_stmt|;
switch|switch
condition|(
name|Exception
operator|.
name|Code
condition|)
block|{
case|case
name|Busy
case|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Busy, retrying...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
condition|)
name|attnmsg
argument_list|(
literal|"Busy, retrying...\n"
argument_list|)
expr_stmt|;
name|CourierClose
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|rewind
argument_list|(
name|ipfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Can't rewind file\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|again
goto|;
case|case
name|ConnectionError
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Connection error, %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|ConnectionErrorArgs
argument_list|,
name|problem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|InsufficientSpoolSpace
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Insufficient Spool Space error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|InvalidPrintParameters
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"InvalidPrintParameters error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MasterTooLarge
case|:
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"MasterTooLarge error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MediumUnavailable
case|:
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"MediumUnavailable error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ServiceUnavailable
case|:
name|ExitStatus
operator|=
name|X_NORETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"ServiceUnavailable error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SpoolingDisabled
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"SpoolingDisabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SpoolingQueueFull
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"SpoolingQueueFull error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SystemError
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"System Error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TooManyClients
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"TooManyClients error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TransferError
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"TransferError error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Undefined
case|:
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Undefined error, number %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|UndefinedArgs
argument_list|,
name|problem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REJECT_ERROR
case|:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"REJECT:  type = %d\n"
argument_list|,
name|CourierErrArgs
argument_list|(
name|rejectionDetails
argument_list|,
name|designator
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ExitStatus
operator|=
name|X_LIMRETRY
expr_stmt|;
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Some random error, code %d\n"
argument_list|,
name|Exception
operator|.
name|Code
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|remove
operator|&&
operator|!
name|attn
condition|)
name|attnmsg
argument_list|(
name|stderr
argument_list|,
literal|"Output left in %s\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStatus
argument_list|)
expr_stmt|;
block|}
name|END_HANDLER
expr_stmt|;
name|CourierClose
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* RETURNS [printRequestID: RequestID] */
if|if
condition|(
name|remove
condition|)
name|unlink
argument_list|(
name|FileName
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

