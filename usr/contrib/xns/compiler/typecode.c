begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984 by Eric C. Cooper.  * All rights reserved.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: typecode.c,v 2.0 85/11/21 07:21:47 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	typecode.c,v $  * Revision 2.0  85/11/21  07:21:47  jqj  * 4.3BSD standard release  *   * Revision 1.6  85/05/23  06:20:12  jqj  * *** empty log message ***  *   * Revision 1.6  85/05/23  06:20:12  jqj  * Public Beta-test version, released 24 May 1985  *   * Revision 1.5  85/05/06  08:13:43  jqj  * Almost Beta-test version.  *   * Revision 1.4  85/03/26  06:10:42  jqj  * Revised public alpha-test version, released 26 March 1985  *   * Revision 1.3  85/03/11  16:40:21  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.2  85/02/21  11:06:11  jqj  * alpha test version  *   * Revision 1.1  85/02/15  13:55:45  jqj  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_define
define|#
directive|define
name|candidate_name
parameter_list|(
name|str
parameter_list|)
value|(str)
end_define

begin_comment
comment|/*  * This function is used to cope with the fact that C passes arrays  * by reference but all other types by value.  * The argument should be a base type.  */
end_comment

begin_function
name|char
modifier|*
name|refstr
parameter_list|(
name|typtr
parameter_list|)
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
block|{
comment|/*	if (typtr->o_class != O_TYPE) 		error(FATAL, "internal error (refstr): not a type");  */
return|return
operator|(
name|typtr
operator|->
name|type_constr
operator|==
name|C_ARRAY
condition|?
literal|""
else|:
literal|"&"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Names of translation functions for types.  * Warning: returns pointer to a static buffer.  */
end_comment

begin_function
name|char
modifier|*
name|xfn
parameter_list|(
name|kind
parameter_list|,
name|typtr
parameter_list|)
name|enum
name|translation
name|kind
decl_stmt|;
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|EXTERNALIZE
case|:
name|name
operator|=
literal|"externalize"
expr_stmt|;
break|break;
case|case
name|INTERNALIZE
case|:
name|name
operator|=
literal|"internalize"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s_%s"
argument_list|,
name|name
argument_list|,
name|typtr
operator|->
name|type_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the heading for a type externalizing or internalizing function.  */
end_comment

begin_expr_stmt
name|xfn_header
argument_list|(
name|kind
argument_list|,
name|typtr
argument_list|,
name|ptr_type
argument_list|)
expr|enum
name|translation
name|kind
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|,
modifier|*
name|ptr_type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|EXTERNALIZE
case|:
name|f
operator|=
name|support1
expr_stmt|;
break|break;
case|case
name|INTERNALIZE
case|:
name|f
operator|=
name|support2
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n\ int\n\ %s(p, buf)\n\ \tregister %s *p;\n\ \tregister Unspecified *buf;\n"
argument_list|,
name|xfn
argument_list|(
name|kind
argument_list|,
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|ptr_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * create an alias for a type's datastructures.  Note that caller must  * create the alias for the typedef name itself.  */
end_comment

begin_macro
name|copy_typefns
argument_list|(
argument|headerfile
argument_list|,
argument|new
argument_list|,
argument|old
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|headerfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|headerfile
argument_list|,
literal|"#define sizeof_%s sizeof_%s\n\ #define clear_%s clear_%s\n\ #define externalize_%s externalize_%s\n\ #define internalize_%s internalize_%s\n\n"
argument_list|,
name|new
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|define_enumeration_type
argument_list|(
argument|typtr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
name|typtr
operator|->
name|type_xsize
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|recursive_flag
condition|)
return|return;
comment|/* 	 * Print a C definition for the enumeration. 	 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\ntypedef enum {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|q
operator|=
name|car
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\t%s = %s"
argument_list|,
name|name_of
argument_list|(
name|car
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|cdr
argument_list|(
name|q
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdr
argument_list|(
name|p
argument_list|)
operator|!=
name|NIL
condition|)
name|fprintf
argument_list|(
name|header
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"} %s;\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We use the same sizeof and translation functions 	 * for all enumerated types. 	 */
name|copy_typefns
argument_list|(
name|header
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
literal|"enumeration"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|define_record_type
argument_list|(
argument|typtr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|type
modifier|*
name|bt
decl_stmt|;
name|list
name|p
decl_stmt|,
name|q
decl_stmt|;
name|int
name|fixed_size
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|,
modifier|*
name|ref
decl_stmt|,
modifier|*
name|member
decl_stmt|;
comment|/* 	 * Make sure all subtypes are defined and have sizes 	 */
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|typename
argument_list|(
name|bt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|object
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|make_symbol
argument_list|(
name|gensym
argument_list|(
literal|"T_r"
argument_list|)
argument_list|,
name|CurrentProgram
argument_list|)
expr_stmt|;
name|define_type
argument_list|(
name|name
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate size field. 	 * The size is equal to the sum of the sizes of each field. 	 */
name|fixed_size
operator|=
literal|0
expr_stmt|;
name|typtr
operator|->
name|type_xsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|==
operator|-
literal|1
condition|)
name|typtr
operator|->
name|type_xsize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|fixed_size
operator|+=
name|bt
operator|->
name|type_xsize
expr_stmt|;
block|}
if|if
condition|(
name|typtr
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
name|typtr
operator|->
name|type_xsize
operator|=
name|fixed_size
expr_stmt|;
if|if
condition|(
name|recursive_flag
condition|)
return|return;
comment|/* 	 * Print a C definition for the record. 	 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\ntypedef struct {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|member
operator|=
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\t%s %s;\n"
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"} %s;\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Generate sizeof and free functions for the record. 	 */
if|if
condition|(
name|typtr
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * The record is fixed-size, so just define a macro. 		 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\ #define sizeof_%s(p) %d\n\ \n\ #define clear_%s(p)\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typtr
operator|->
name|type_xsize
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There are some variable-size fields, so define functions. 		 */
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ int\n\ sizeof_%s(p)\n\ \tregister %s *p;\n\ {\n\ \tregister int size = %d;\n\ \n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|fixed_size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|member
operator|=
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\tsize += sizeof_%s(%sp->%s);\n"
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\treturn (size);\n\ }\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ int\n\ clear_%s(p)\n\ \tregister %s *p;\n\ {\n\ \n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|member
operator|=
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\tclear_%s(%sp->%s);\n"
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Define translation functions. 	 */
name|xfn_header
argument_list|(
name|EXTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
name|xfn_header
argument_list|(
name|INTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"{\n\ \tregister Unspecified *bp;\n\ \n\ \tbp = buf;\n"
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"\tbp += %s(%sp->%s, bp);\n"
expr_stmt|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|member
operator|=
operator|(
name|char
operator|*
operator|)
name|car
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|format
operator|=
literal|"\treturn (bp - buf);\n\ }\n"
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|define_array_type
argument_list|(
argument|typtr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|type
modifier|*
name|bt
decl_stmt|;
name|int
name|true_size
decl_stmt|;
name|char
modifier|*
name|ref
decl_stmt|,
modifier|*
name|format
decl_stmt|;
name|bt
operator|=
name|typtr
operator|->
name|type_basetype
expr_stmt|;
comment|/* 	 * Make sure the component type is defined and sized 	 */
if|if
condition|(
name|typename
argument_list|(
name|bt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|object
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|make_symbol
argument_list|(
name|gensym
argument_list|(
literal|"T_a"
argument_list|)
argument_list|,
name|CurrentProgram
argument_list|)
expr_stmt|;
name|define_type
argument_list|(
name|name
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
name|true_size
operator|=
name|typtr
operator|->
name|type_size
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
name|typtr
operator|->
name|type_xsize
operator|=
name|true_size
operator|*
name|bt
operator|->
name|type_xsize
expr_stmt|;
else|else
name|typtr
operator|->
name|type_xsize
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|recursive_flag
condition|)
return|return;
comment|/* 	 * Print a C definition for the array. 	 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\ntypedef %s %s[%d];\n"
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|true_size
argument_list|)
expr_stmt|;
comment|/* 	 * Generate a sizeof and free functions for the array. 	 * The size is equal to the sum of the sizes of each element. 	 */
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * The element type, and hence the array, is fixed-size, 		 * so just define a macro. 		 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\ #define sizeof_%s(p) %d\n\ \n\ #define clear_%s(p)\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typtr
operator|->
name|type_xsize
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The element type is variable-size, so define a function. 		 */
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ int\n\ sizeof_%s(p)\n\ \tregister %s *p;\n\ {\n\ \tregister int size = 0;\n\ \tregister int i;\n\ \n\ \tfor (i = 0; i< %d; i += 1)\n\ \t\tsize += sizeof_%s(%sp[i]);\n\ \treturn (size);\n\ }\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|true_size
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ clear_%s(p)\n\ \t%s *p;\n\ {\n\ \tregister int i;\n\ \n\ \tfor (i = 0; i< %d; i += 1)\n\ \t\tclear_%s(%sp[i]);\n\ }\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|true_size
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Define translation functions. 	 */
name|xfn_header
argument_list|(
name|EXTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|xfn_header
argument_list|(
name|INTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"{\n\ \tregister Unspecified *bp;\n\ \tregister int i;\n\ \n\ \tbp = buf;\n\ \tfor (i = 0; i< %d; i += 1)\n\ \t\tbp += %s(%sp[i], bp);\n\ \treturn (bp - buf);\n\ }\n"
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|,
name|true_size
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|,
name|true_size
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|define_sequence_type
argument_list|(
argument|typtr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|type
modifier|*
name|bt
decl_stmt|;
name|char
modifier|*
name|ref
decl_stmt|,
modifier|*
name|format
decl_stmt|;
name|typtr
operator|->
name|type_xsize
operator|=
operator|-
literal|1
expr_stmt|;
name|bt
operator|=
name|typtr
operator|->
name|type_basetype
expr_stmt|;
comment|/* 	 * Make sure the component type is defined 	 */
if|if
condition|(
name|typename
argument_list|(
name|bt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|object
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|make_symbol
argument_list|(
name|gensym
argument_list|(
literal|"T_s"
argument_list|)
argument_list|,
name|CurrentProgram
argument_list|)
expr_stmt|;
name|define_type
argument_list|(
name|name
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recursive_flag
condition|)
return|return;
comment|/* 	 * Print a C definition for the sequence. 	 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\ typedef struct {\n\ \tCardinal length;\n\ \t%s *sequence;\n\ } %s;\n"
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Generate sizeof and free functions for the sequence. 	 * The size is equal to 1 (for the length word) 	 * plus the sum of the sizes of each element. 	 */
name|bt
operator|=
name|typtr
operator|->
name|type_basetype
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * The element type is fixed-size, so just define a macro. 		 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\ #define sizeof_%s(p) (1 + (p)->length * %d)\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|bt
operator|->
name|type_xsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ clear_%s(p)\n\ \tregister %s *p;\n\ {\n\ \tDeallocate((Unspecified*) p->sequence);\n\ \tp->length = 0;  p->sequence = (%s*) 0;\n\ }\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The element type is variable-size, so define a function. 		 */
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ int\n\ sizeof_%s(p)\n\ \tregister %s *p;\n\ {\n\ \tregister int size = 1;\n\ \tregister int i;\n\ \n\ \tif (p->sequence == (%s*) 0) return(size);\n\ \tfor (i = 0; i< p->length; i += 1)\n\ \t\tsize += sizeof_%s(%sp->sequence[i]);\n\ \treturn (size);\n\ }\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ clear_%s(p)\n\ \tregister %s *p;\n\ {\n\ \tregister int i;\n\ \n\ \tif (p->sequence != (%s*) 0) for (i = 0; i< p->length; i += 1)\n\ \t\tclear_%s(%sp->sequence[i]);\n\ \tDeallocate((Unspecified*) p->sequence);\n\ \tp->length = 0;  p->sequence = (%s*) 0;\n\ }\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Define translation functions. 	 */
name|xfn_header
argument_list|(
name|EXTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
name|xfn_header
argument_list|(
name|INTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
comment|/* 	 * The externalize function (trivially) checks its pointer 	 * for consistency. 	 */
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"{\n\ \tregister Unspecified *bp;\n\ \tregister int i;\n\ \n\ \tif (p->sequence == (%s*)0) p->length = 0;\n\ \tbp = buf + %s(&p->length, buf);\n"
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|Cardinal_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The internalize function needs to allocate space 	 * for the sequence elements dynamically. 	 */
name|fprintf
argument_list|(
name|support2
argument_list|,
literal|"{\n\ \tregister Unspecified *bp;\n\ \tregister int i;\n\ \n\ \tbp = buf + %s(&p->length, buf);\n\ \tp->sequence = (%s *)\n\ \t\tAllocate(p->length * sizeof(%s)/sizeof(Cardinal));\n"
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|Cardinal_type
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"\tfor (i = 0; i< p->length; i++)\n\ \t\tbp += %s(%sp->sequence[i], bp);\n\ \treturn (bp - buf);\n\ }\n"
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|define_choice_type
argument_list|(
argument|typtr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|type
modifier|*
name|designator
decl_stmt|,
modifier|*
name|bt
decl_stmt|;
name|list
name|p
decl_stmt|,
name|q
decl_stmt|,
name|candidates
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|,
modifier|*
name|ref
decl_stmt|,
modifier|*
name|member
decl_stmt|;
name|typtr
operator|->
name|type_xsize
operator|=
operator|-
literal|1
expr_stmt|;
name|designator
operator|=
name|typtr
operator|->
name|type_designator
expr_stmt|;
name|candidates
operator|=
name|typtr
operator|->
name|type_candidates
expr_stmt|;
if|if
condition|(
operator|!
name|recursive_flag
condition|)
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\ extern struct %s;\n\ typedef struct %s %s;\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure each arm type is defined 	 */
for|for
control|(
name|p
operator|=
name|candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|typename
argument_list|(
name|bt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|object
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|make_symbol
argument_list|(
name|gensym
argument_list|(
literal|"T_c"
argument_list|)
argument_list|,
name|CurrentProgram
argument_list|)
expr_stmt|;
name|define_type
argument_list|(
name|name
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|recursive_flag
condition|)
return|return;
comment|/* 	 * Print a C definition for the choice. 	 * First, be prepared for recursive references of the SEQUENCE OF form 	 */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\n\ struct %s {\n\ \t%s designator;\n\ \tunion {\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|designator
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|member
operator|=
name|name_of
argument_list|(
name|caar
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\t\t%s u_%s;\n\ #define %s_case u.u_%s\n"
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|member
argument_list|,
name|candidate_name
argument_list|(
name|member
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"\t} u;\n\ };\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Generate a sizeof function for the choice. 	 * The size is equal to 1 (for the designator word) 	 * plus the size of the corresponding candidate. 	 * We could check if all the candidates happen to be the same size, 	 * but we don't bother and always call it variable-size. 	 */
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ int\n\ sizeof_%s(p)\n\ \tregister %s *p;\n\ {\n\ \tregister int size = 1;\n\ \n\ \tswitch (p->designator) {\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|member
operator|=
name|name_of
argument_list|(
name|caar
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\t    case %s:\n\ \t\tsize += sizeof_%s(%sp->%s_case);\n\ \t\tbreak;\n"
argument_list|,
name|member
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|candidate_name
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\t}\n\ \treturn (size);\n\ }\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Now generate the freeing function.  Here we do bother 	 * not to free constant-sized structures, just for kicks. 	 * However, we always generate a freeing function, even if 	 * all the arms of the choice are constant sized. 	 */
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\n\ clear_%s(p)\n\ \tregister %s *p;\n\ {\n\ \tswitch (p->designator) {\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|member
operator|=
name|name_of
argument_list|(
name|caar
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|->
name|type_xsize
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\t    case %s:\n\ \t\tbreak;\n"
argument_list|,
name|member
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\t    case %s:\n\ \t\tclear_%s(%sp->%s_case);\n\ \t\tbreak;\n"
argument_list|,
name|member
argument_list|,
name|typename
argument_list|(
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|candidate_name
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|support1
argument_list|,
literal|"\t}\n\ }\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Define translation functions. 	 */
name|xfn_header
argument_list|(
name|EXTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
name|xfn_header
argument_list|(
name|INTERNALIZE
argument_list|,
name|typtr
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"{\n\ \tregister Unspecified *bp;\n\ \n\ \tbp = buf + %s(&p->designator, buf);\n\ \tswitch (p->designator) {\n"
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|designator
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|designator
argument_list|)
argument_list|)
expr_stmt|;
name|format
operator|=
literal|"\t    case %s:\n\ \t\tbp += %s(%sp->%s_case, bp);\n\ \t\tbreak;\n"
expr_stmt|;
for|for
control|(
name|p
operator|=
name|candidates
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
block|{
name|bt
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|cdar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ref
operator|=
name|refstr
argument_list|(
name|bt
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|caar
argument_list|(
name|p
argument_list|)
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|cdr
argument_list|(
name|q
argument_list|)
control|)
block|{
name|member
operator|=
name|name_of
argument_list|(
name|caar
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|,
name|member
argument_list|,
name|xfn
argument_list|(
name|EXTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|candidate_name
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|,
name|member
argument_list|,
name|xfn
argument_list|(
name|INTERNALIZE
argument_list|,
name|bt
argument_list|)
argument_list|,
name|ref
argument_list|,
name|candidate_name
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|format
operator|=
literal|"\t}\n\ \treturn (bp - buf);\n\ }\n"
expr_stmt|;
name|fprintf
argument_list|(
name|support1
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|support2
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Generate a new full name of the form<module><version>_<name>  */
end_comment

begin_function
name|char
modifier|*
name|make_full_name
parameter_list|(
name|module
parameter_list|,
name|version
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|module
decl_stmt|;
name|int
name|version
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXSTR
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d_%s"
argument_list|,
name|module
argument_list|,
name|version
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|copy
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate defininitions for named types  * and their size and translation functions.  * We assume that each type with a type_name field has already been  * generated.  */
end_comment

begin_macro
name|define_type
argument_list|(
argument|name
argument_list|,
argument|typtr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|object
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* 	 * create the symbol -- it has already been made via make_symbol() 	 * which, along with allocating an object, set o_name 	 */
name|name
operator|->
name|o_class
operator|=
name|O_TYPE
expr_stmt|;
name|name
operator|->
name|o_type
operator|=
name|typtr
expr_stmt|;
name|fullname
operator|=
name|make_full_name
argument_list|(
name|name
operator|->
name|o_module
argument_list|,
name|name
operator|->
name|o_modversion
argument_list|,
name|name_of
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|code_type
argument_list|(
name|fullname
argument_list|,
name|typtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recursive_flag
condition|)
block|{
comment|/* widen scope */
name|fprintf
argument_list|(
name|header1
argument_list|,
literal|"typedef %s %s;\n"
argument_list|,
name|fullname
argument_list|,
name|name_of
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|copy_typefns
argument_list|(
name|header1
argument_list|,
name|name_of
argument_list|(
name|name
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Actually generate some code.  This routine may be called recursively  * if subtypes have no name.  */
end_comment

begin_macro
name|code_type
argument_list|(
argument|name
argument_list|,
argument|typtr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * check for simple case of "foo: TYPE = bar;" rename 	 */
if|if
condition|(
name|typename
argument_list|(
name|typtr
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|recursive_flag
condition|)
block|{
comment|/* create alias for typedef */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"typedef %s %s;\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copy_typefns
argument_list|(
name|header
argument_list|,
name|name
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * general case:  "foo: TYPE =<type>;" 	 * actually generate some code 	 */
switch|switch
condition|(
name|typtr
operator|->
name|type_constr
condition|)
block|{
case|case
name|C_PROCEDURE
case|:
comment|/* no code gets generated for these Types */
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
break|break;
case|case
name|C_NUMERIC
case|:
case|case
name|C_BOOLEAN
case|:
case|case
name|C_STRING
case|:
comment|/* create alias for typedef */
name|fprintf
argument_list|(
name|header
argument_list|,
literal|"typedef %s %s;\n"
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copy_typefns
argument_list|(
name|header
argument_list|,
name|name
argument_list|,
name|typename
argument_list|(
name|typtr
argument_list|)
argument_list|)
expr_stmt|;
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
break|break;
case|case
name|C_ENUMERATION
case|:
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
name|define_enumeration_type
argument_list|(
name|typtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_ARRAY
case|:
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
name|define_array_type
argument_list|(
name|typtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_SEQUENCE
case|:
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
name|define_sequence_type
argument_list|(
name|typtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_RECORD
case|:
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
name|define_record_type
argument_list|(
name|typtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_CHOICE
case|:
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
name|define_choice_type
argument_list|(
name|typtr
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_ERROR
case|:
name|typename
argument_list|(
name|typtr
argument_list|)
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|typtr
operator|->
name|type_list
operator|!=
name|NIL
condition|)
name|define_record_type
argument_list|(
name|typtr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_block

end_unit

