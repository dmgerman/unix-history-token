begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: constants.c,v 2.0 85/11/21 07:21:34 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	constants.c,v $  * Revision 2.0  85/11/21  07:21:34  jqj  * 4.3BSD standard release  *   * Revision 1.3  85/03/11  16:39:09  jqj  * *** empty log message ***  *   * Revision 1.3  85/03/11  16:39:09  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.2  85/02/21  11:05:02  jqj  * alpha test version  *   * Revision 1.1  85/02/15  13:55:22  jqj  * Initial revision  *   */
end_comment

begin_comment
comment|/*  * Generate build symbol tables, etc. for constant declarations.  */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_comment
comment|/*  * Allocate storage for constants  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|make_constant
parameter_list|(
name|constr
parameter_list|)
name|enum
name|constr
name|constr
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|New
argument_list|(
expr|struct
name|constant
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_constr
operator|=
name|constr
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate parse tree for simple constants -- Booleans  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|Boolean_constant
parameter_list|(
name|value
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|make_constant
argument_list|(
name|C_BOOLEAN
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_value
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate parse tree for simple constants -- strings  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|String_constant
parameter_list|(
name|value
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|make_constant
argument_list|(
name|C_STRING
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_value
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate parse tree for simple constants -- numeric values  * Note that we don't know the actual type of such constants;  * they are type-compatible with any numeric type.  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|Numeric_constant
parameter_list|(
name|value
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|make_constant
argument_list|(
name|C_NUMERIC
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_value
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate parse tree for simple constants -- enumerations  * Note that we don't know the actual type of such constants;  * they are type-compatible with any numeric type.  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|enumeration_constant
parameter_list|(
name|value
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|make_constant
argument_list|(
name|C_ENUMERATION
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_value
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate parse tree for complex constants -- arrays and sequences  * Note that we treat them all as arrays, and allow sequences to  * be type-compatible with arrays at declaration time.  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|array_constant
parameter_list|(
name|values
parameter_list|)
name|list
name|values
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|make_constant
argument_list|(
name|C_ARRAY
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_list
operator|=
name|values
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate parse tree for complex constants -- records  * As a special case, NIL record constants are also type-compatible  * with some arrays and all sequences.  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|record_constant
parameter_list|(
name|values
parameter_list|)
name|list
name|values
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|make_constant
argument_list|(
name|C_RECORD
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_list
operator|=
name|values
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate parse tree for complex constants -- choices  */
end_comment

begin_function
name|struct
name|constant
modifier|*
name|choice_constant
parameter_list|(
name|values
parameter_list|)
name|list
name|values
decl_stmt|;
block|{
name|struct
name|constant
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|make_constant
argument_list|(
name|C_CHOICE
argument_list|)
expr_stmt|;
name|c
operator|->
name|cn_list
operator|=
name|values
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

end_unit

