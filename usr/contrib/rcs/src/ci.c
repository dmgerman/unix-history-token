begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS checkin operation  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/wft/RCS/SRC/RCS/ci.c,v 3.9 83/02/15 15:25:44 wft Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************  *                       check revisions into RCS files  *******************************************************************  *  * Copyright (C) 1982 by Walter F. Tichy  *                       Purdue University  *                       Computer Science Department  *                       West Lafayette, IN 47907  *  * All rights reserved. No part of this software may be sold or distributed  * in any form or by any means without the prior written permission of the  * author.  * Report problems and direct all inquiries to Tichy@purdue (ARPA net).  */
end_comment

begin_comment
comment|/* $Log:	ci.c,v $  * Revision 3.9  83/02/15  15:25:44  wft  * Added call to fastcopy() to copy remainder of RCS file.  *   * Revision 3.8  83/01/14  15:34:05  wft  * Added ignoring of interrupts while new RCS file is renamed;  * Avoids deletion of RCS files by interrupts.  *  * Revision 3.7  82/12/10  16:09:20  wft  * Corrected checking of return code from diff.  *  * Revision 3.6  82/12/08  21:34:49  wft  * Using DATEFORM to prepare date of checked-in revision;  * Fixed return from addbranch().  *  * Revision 3.5  82/12/04  18:32:42  wft  * Replaced getdelta() with gettree(), SNOOPDIR with SNOOPFILE. Updated  * field lockedby in removelock(), moved getlogmsg() before calling diff.  *  * Revision 3.4  82/12/02  13:27:13  wft  * added option -k.  *  * Revision 3.3  82/11/28  20:53:31  wft  * Added mustcheckin() to check for redundant checkins.  * Added xpandfile() to do keyword expansion for -u and -l;  * -m appends linefeed to log message if necessary.  * getlogmsg() suppresses prompt if stdin is not a terminal.  * Replaced keeplock with lockflag, fclose() with ffclose(),  * %02d with %.2d, getlogin() with getpwuid().  *  * Revision 3.2  82/10/18  20:57:23  wft  * An RCS file inherits its mode during the first ci from the working file,  * otherwise it stays the same, except that write permission is removed.  * Fixed ci -l, added ci -u (both do an implicit co after the ci).  * Fixed call to getlogin(), added call to getfullRCSname(), added check  * for write error.  * Changed conflicting identifiers.  *  * Revision 3.1  82/10/13  16:04:59  wft  * fixed type of variables receiving from getc() (char -> int).  * added include file dbm.h for getting BYTESIZ. This is used  * to check the return code from diff portably.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|rcsbaseid
index|[]
init|=
name|RCSBASE
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_function_decl
specifier|extern
name|int
name|rename
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*rename files                       */
end_comment

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|genrevs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*generate delta numbers             */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next input character               */
end_comment

begin_extern
extern|extern quietflag;
end_extern

begin_comment
comment|/*suppresses diagnostics if true     */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nerror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*counter for errors                 */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|buildrevision
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* constructs desired revision       */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|checkid
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*check identifiers                  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getdate
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*formates current date  (forward)   */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktempfile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*temporary file name generator      */
end_comment

begin_function_decl
specifier|extern
name|struct
name|lock
modifier|*
name|addlock
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*adds a new lock                    */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getlogmsg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* obtains log message; forward      */
end_comment

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|removelock
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*finds a caller's lock  (forward)   */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|xpandfile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* perform keyword expansion; forward*/
end_comment

begin_decl_stmt
specifier|extern
name|char
name|prevauthor
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|prevdate
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|prevrev
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|prevstate
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file                    */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new RCS file                      */
end_comment

begin_decl_stmt
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|,
modifier|*
name|expfilename
decl_stmt|,
modifier|*
name|newworkfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|newRCSfilename
decl_stmt|,
modifier|*
name|diffilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether input should be echoed to frewrite */
end_comment

begin_decl_stmt
name|int
name|copyflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether a string should be copied into memory*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|state
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|initflag
decl_stmt|,
name|rcsinitflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lockflag
decl_stmt|,
name|keepworkingfile
decl_stmt|,
name|keepflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forceciflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forces check in                    */
end_comment

begin_decl_stmt
name|int
name|symrebindflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|textflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|textfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|caller
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* caller's login;                    */
end_comment

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|targetdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old delta to be generated          */
end_comment

begin_decl_stmt
name|char
modifier|*
name|olddeltanum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of old delta                */
end_comment

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|gendeltas
index|[
name|hshsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stores deltas to be generated      */
end_comment

begin_decl_stmt
name|char
name|newdelnum
index|[
name|revlength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds new revision number          */
end_comment

begin_decl_stmt
name|int
name|newdnumlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual length of new rev. num.     */
end_comment

begin_decl_stmt
name|char
name|branchpointnum
index|[
name|revlength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of branchpoint              */
end_comment

begin_decl_stmt
name|struct
name|hshentry
name|newdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new delta to be inserted           */
end_comment

begin_decl_stmt
name|struct
name|branchhead
name|newbranch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new branch to be inserted          */
end_comment

begin_decl_stmt
name|char
name|logmsg
index|[
name|logsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for log message             */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|cmdusage
decl_stmt|;
comment|/* holds command format                    */
name|char
name|command
index|[
name|NCPPN
operator|+
literal|50
index|]
decl_stmt|;
comment|/* holds diff commands                     */
name|char
name|curdate
index|[
name|datelength
index|]
decl_stmt|;
comment|/* date for new delta                      */
name|struct
name|stat
name|filestatus
decl_stmt|;
comment|/* used for getting the mode               */
name|int
name|msglen
decl_stmt|;
comment|/* length of message given by -m           */
name|int
name|exit_stats
decl_stmt|;
comment|/* return code for system() calls          */
name|catchints
argument_list|()
expr_stmt|;
name|cmdid
operator|=
literal|"ci"
expr_stmt|;
name|cmdusage
operator|=
literal|"command format:\nci -r[rev] -l[rev] -u[rev] -f[rev] -k[rev] -q[rev] -mmsg -nname -Nname -sstate -t[txtfile] file ..."
expr_stmt|;
name|rev
operator|=
name|state
operator|=
name|msg
operator|=
name|symbol
operator|=
name|textfile
operator|=
name|caller
operator|=
name|nil
expr_stmt|;
name|initflag
operator|=
name|rcsinitflag
operator|=
name|symrebindflag
operator|=
name|textflag
operator|=
name|quietflag
operator|=
name|false
expr_stmt|;
name|forceciflag
operator|=
name|lockflag
operator|=
name|keepworkingfile
operator|=
name|keepflag
operator|=
name|false
expr_stmt|;
name|caller
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|->
name|pw_name
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|lockflag
operator|=
name|false
expr_stmt|;
name|revno
label|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|rev
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of revision number"
argument_list|)
expr_stmt|;
name|rev
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
name|keepworkingfile
operator|=
name|lockflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'u'
case|:
name|keepworkingfile
operator|=
name|true
expr_stmt|;
name|lockflag
operator|=
name|false
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'f'
case|:
name|forceciflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'k'
case|:
name|keepflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|msg
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -m option"
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|msglen
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|>=
name|logsize
condition|)
block|{
name|warn
argument_list|(
literal|"log message truncated to %d characters"
argument_list|,
name|logsize
argument_list|)
expr_stmt|;
name|msg
index|[
name|logsize
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|msg
index|[
name|logsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|msg
index|[
name|msglen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/*append linefeed*/
name|strcpy
argument_list|(
name|logmsg
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|logmsg
expr_stmt|;
name|msg
index|[
name|msglen
index|]
operator|=
literal|'\n'
expr_stmt|;
name|msg
index|[
operator|++
name|msglen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
name|warn
argument_list|(
literal|"Missing message for -m option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|symrebindflag
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|symbol
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of symbolic name"
argument_list|)
expr_stmt|;
name|symbol
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|checkid
argument_list|(
name|symbol
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Missing name for -n option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|symrebindflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|symbol
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of symbolic name"
argument_list|)
expr_stmt|;
name|symbol
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|checkid
argument_list|(
name|symbol
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Missing name for -N option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -s option"
argument_list|)
expr_stmt|;
name|state
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
name|checkid
argument_list|(
name|state
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Missing state for -s option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|textflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|textfile
operator|!=
name|nil
condition|)
name|warn
argument_list|(
literal|"Redefinition of -t option"
argument_list|)
expr_stmt|;
name|textfile
operator|=
operator|(
operator|*
name|argv
operator|)
operator|+
literal|2
expr_stmt|;
block|}
break|break;
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s\n%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end processing of options */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"No input file\n%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|msg
operator|==
name|nil
operator|&&
name|textflag
operator|&&
name|textfile
operator|==
name|nil
condition|)
block|{
comment|/* would need both log message and descriptive text from a file */
name|faterror
argument_list|(
literal|"Can't take both log and description from redirected stdin; use -ttextfile"
argument_list|)
expr_stmt|;
block|}
comment|/* now handle all filenames */
do|do
block|{
name|gendeltas
index|[
literal|0
index|]
operator|=
name|nil
expr_stmt|;
name|copyflag
operator|=
name|rewriteflag
operator|=
name|false
expr_stmt|;
name|finptr
operator|=
name|frewrite
operator|=
name|NULL
expr_stmt|;
name|targetdelta
operator|=
name|nil
expr_stmt|;
name|olddeltanum
operator|=
name|nil
expr_stmt|;
switch|switch
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* New RCS file */
name|initflag
operator|=
name|true
expr_stmt|;
name|rcsinitflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Error */
continue|continue;
case|case
literal|1
case|:
comment|/* Normal checkin with prev . RCS file */
name|initflag
operator|=
name|false
expr_stmt|;
name|rcsinitflag
operator|=
operator|(
name|Head
operator|==
name|nil
operator|)
expr_stmt|;
block|}
comment|/* now RCSfilename contains the name of the RCS file, and          * workfilename contains the name of the working file.          * if !initflag, finptr contains the file descriptor for the          * RCS file. The admin node is initialized.          */
name|diagnose
argument_list|(
literal|"%s<--  %s"
argument_list|,
name|RCSfilename
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|workfilename
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"working file %s not readable or nonexistent"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|initflag
operator|||
name|rcsinitflag
condition|)
comment|/* get mode for RCSfile from workfile*/
name|stat
argument_list|(
name|workfilename
argument_list|,
operator|&
name|filestatus
argument_list|)
expr_stmt|;
else|else
comment|/* otherwise keep the one from the RCS file.*/
name|fstat
argument_list|(
name|fileno
argument_list|(
name|finptr
argument_list|)
argument_list|,
operator|&
name|filestatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trydiraccess
argument_list|(
name|RCSfilename
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
operator|!
name|initflag
operator|&&
operator|!
name|checkaccesslist
argument_list|(
name|caller
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
operator|!
name|trysema
argument_list|(
name|RCSfilename
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
comment|/* give up */
if|if
condition|(
name|keepflag
condition|)
block|{
comment|/* get keyword values from working file */
if|if
condition|(
operator|!
name|getoldkeys
argument_list|(
name|workfilename
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rev
operator|==
name|nil
operator|&&
operator|*
operator|(
name|rev
operator|=
name|prevrev
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Can't find a revision number in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|prevdate
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"Can't find a date in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|prevauthor
operator|==
literal|'\0'
condition|)
name|warn
argument_list|(
literal|"Can't find an author in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prevstate
operator|==
literal|'\0'
condition|)
name|warn
argument_list|(
literal|"Can't find a state in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
block|}
comment|/* end processing keepflag */
name|gettree
argument_list|()
expr_stmt|;
comment|/* reads in the delta tree.*/
comment|/* expand symbolic revision number */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|rev
argument_list|,
name|newdelnum
argument_list|)
condition|)
continue|continue;
name|newdnumlength
operator|=
name|countnumflds
argument_list|(
name|newdelnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|initflag
operator|||
name|rcsinitflag
condition|)
block|{
comment|/* this covers non-existing RCS file and a file initialized with rcs -i */
if|if
condition|(
name|newdnumlength
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|newdelnum
argument_list|,
literal|"1.1"
argument_list|)
expr_stmt|;
name|elsif
argument_list|(
argument|newdnumlength==
literal|1
argument_list|)
name|strcat
argument_list|(
name|newdelnum
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
name|elsif
argument_list|(
argument|newdnumlength>
literal|2
argument_list|)
block|{
name|error
argument_list|(
literal|"Branch point does not exist for %s"
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* newdnumlength == 2 is OK;  */
name|olddeltanum
operator|=
name|nil
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|newdnumlength==
literal|0
argument_list|)
block|{
comment|/* derive new revision number from locks */
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|removelock
argument_list|(
name|caller
argument_list|,
name|nil
argument_list|)
operator|)
condition|)
continue|continue;
name|olddeltanum
operator|=
name|targetdelta
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|genrevs
argument_list|(
name|olddeltanum
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|gendeltas
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|targetdelta
operator|==
name|Head
condition|)
block|{
comment|/* make new head */
name|newdelta
operator|.
name|next
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|(targetdelta->next==nil)&&(countnumflds(olddeltanum)>
literal|2
argument|)
argument_list|)
block|{
comment|/* new tip revision on side branch */
name|targetdelta
operator|->
name|next
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* middle revision; start a new branch */
name|newdelnum
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|addbranch
argument_list|(
name|targetdelta
argument_list|,
name|newdelnum
argument_list|)
condition|)
continue|continue;
block|}
block|}
name|elsif
argument_list|(
argument|newdnumlength<=
literal|2
argument_list|)
block|{
comment|/* add new head per given number */
comment|/* put new revision on trunk */
name|olddeltanum
operator|=
name|Head
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|newdnumlength
operator|==
literal|1
condition|)
block|{
comment|/* make a two-field number out of it*/
if|if
condition|(
name|cmpnumfld
argument_list|(
name|newdelnum
argument_list|,
name|olddeltanum
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|newdelnum
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmpnum
argument_list|(
name|newdelnum
argument_list|,
name|olddeltanum
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"deltanumber %s too low; must be higher than %s"
argument_list|,
name|newdelnum
argument_list|,
name|Head
operator|->
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|removelock
argument_list|(
name|caller
argument_list|,
name|Head
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|genrevs
argument_list|(
name|olddeltanum
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
name|newdelta
operator|.
name|next
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
block|}
else|else
block|{
comment|/* put new revision on side branch */
comment|/*first, get branch point */
name|tp
operator|=
name|branchpointnum
expr_stmt|;
name|sp
operator|=
name|newdelnum
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newdnumlength
operator|-
operator|(
name|newdnumlength
operator|%
literal|2
operator|==
literal|1
condition|?
literal|1
else|:
literal|2
operator|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'.'
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/*copy field*/
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/*copy dot  */
block|}
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* kill final dot */
name|olddeltanum
operator|=
name|branchpointnum
expr_stmt|;
comment|/*temporary old delta*/
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|branchpointnum
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cmpnum
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
name|branchpointnum
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find branchpoint %s"
argument_list|,
name|branchpointnum
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|addbranch
argument_list|(
name|targetdelta
argument_list|,
name|newdelnum
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|initflag
operator|||
name|rcsinitflag
condition|)
block|{
name|diagnose
argument_list|(
literal|"initial revision: %s"
argument_list|,
name|newdelnum
argument_list|)
expr_stmt|;
block|}
else|else
name|diagnose
argument_list|(
literal|"new revision: %s; previous revision: %s"
argument_list|,
name|newdelnum
argument_list|,
name|olddeltanum
argument_list|)
expr_stmt|;
name|newdelta
operator|.
name|num
operator|=
name|newdelnum
expr_stmt|;
name|newdelta
operator|.
name|branches
operator|=
name|nil
expr_stmt|;
name|newdelta
operator|.
name|log
operator|=
name|nil
expr_stmt|;
name|newdelta
operator|.
name|lockedby
operator|=
name|nil
expr_stmt|;
comment|/*might be changed by addlock() */
if|if
condition|(
operator|!
name|keepflag
condition|)
block|{
name|newdelta
operator|.
name|author
operator|=
name|caller
expr_stmt|;
name|newdelta
operator|.
name|state
operator|=
name|state
operator|==
name|nil
condition|?
name|DEFAULTSTATE
else|:
name|state
expr_stmt|;
name|newdelta
operator|.
name|date
operator|=
name|getdate
argument_list|(
name|curdate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newdelta
operator|.
name|author
operator|=
operator|(
operator|*
name|prevauthor
operator|==
literal|'\0'
operator|)
condition|?
name|caller
else|:
name|prevauthor
expr_stmt|;
name|newdelta
operator|.
name|state
operator|=
operator|(
operator|*
name|prevstate
operator|==
literal|'\0'
operator|)
condition|?
name|DEFAULTSTATE
else|:
name|prevstate
expr_stmt|;
name|newdelta
operator|.
name|date
operator|=
name|prevdate
expr_stmt|;
if|if
condition|(
name|newdelta
operator|.
name|next
operator|!=
name|nil
operator|&&
name|cmpnum
argument_list|(
name|prevdate
argument_list|,
name|newdelta
operator|.
name|next
operator|->
name|date
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Date in %s is older than existing revision %s"
argument_list|,
name|workfilename
argument_list|,
name|newdelta
operator|.
name|next
operator|->
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|lockflag
operator|&&
operator|!
name|addlock
argument_list|(
operator|&
name|newdelta
argument_list|,
name|caller
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|symbol
operator|&&
operator|!
name|addsymbol
argument_list|(
operator|&
name|newdelta
argument_list|,
name|symbol
argument_list|,
name|symrebindflag
argument_list|)
condition|)
continue|continue;
comment|/* prepare for rewriting the RCS file */
name|newRCSfilename
operator|=
name|mktempfile
argument_list|(
name|RCSfilename
argument_list|,
name|NEWRCSFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frewrite
operator|=
name|fopen
argument_list|(
name|newRCSfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Can't open file %s"
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|putadmin
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|putdesc
argument_list|(
name|initflag
argument_list|,
name|textflag
argument_list|,
name|textfile
argument_list|,
name|quietflag
argument_list|)
expr_stmt|;
comment|/* build rest of file */
if|if
condition|(
name|initflag
operator|||
name|rcsinitflag
condition|)
block|{
comment|/* get logmessage */
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|newdelnum
argument_list|,
name|newdelta
operator|.
name|log
argument_list|,
name|workfilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
name|ffclose
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|frewrite
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|diffilename
operator|=
name|mktempfile
argument_list|(
literal|"/tmp/"
argument_list|,
name|DIFFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|newdelta
operator|==
name|Head
condition|)
block|{
comment|/* prepend new one */
name|rewriteflag
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expfilename
operator|=
name|buildrevision
argument_list|(
name|gendeltas
argument_list|,
name|targetdelta
argument_list|,
literal|"/tmp/"
argument_list|,
name|false
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mustcheckin
argument_list|(
name|expfilename
argument_list|,
name|targetdelta
argument_list|)
condition|)
continue|continue;
comment|/* don't check in files that aren't different, unless forced*/
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s -n %s %s> %s\n"
argument_list|,
name|DIFF
argument_list|,
name|workfilename
argument_list|,
name|expfilename
argument_list|,
name|diffilename
argument_list|)
expr_stmt|;
name|exit_stats
operator|=
name|system
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_stats
operator|!=
literal|0
operator|&&
name|exit_stats
operator|!=
operator|(
literal|1
operator|<<
name|BYTESIZ
operator|)
condition|)
name|faterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
comment|/* diff returns 2 in the upper byte on failure */
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|newdelnum
argument_list|,
name|newdelta
operator|.
name|log
argument_list|,
name|workfilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|olddeltanum
argument_list|,
name|targetdelta
operator|->
name|log
argument_list|,
name|diffilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* insert new delta text */
name|rewriteflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|expfilename
operator|=
name|buildrevision
argument_list|(
name|gendeltas
argument_list|,
name|targetdelta
argument_list|,
literal|"/tmp/"
argument_list|,
name|false
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mustcheckin
argument_list|(
name|expfilename
argument_list|,
name|targetdelta
argument_list|)
condition|)
continue|continue;
comment|/* don't check in files that aren't different, unless forced*/
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s -n %s %s> %s\n"
argument_list|,
name|DIFF
argument_list|,
name|expfilename
argument_list|,
name|workfilename
argument_list|,
name|diffilename
argument_list|)
expr_stmt|;
name|exit_stats
operator|=
name|system
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_stats
operator|!=
literal|0
operator|&&
name|exit_stats
operator|!=
operator|(
literal|1
operator|<<
name|BYTESIZ
operator|)
condition|)
name|faterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|newdelnum
argument_list|,
name|newdelta
operator|.
name|log
argument_list|,
name|diffilename
argument_list|,
name|frewrite
argument_list|)
condition|)
continue|continue;
block|}
comment|/* rewrite rest of RCS file */
name|fastcopy
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|frewrite
operator|=
name|NULL
expr_stmt|;
block|}
name|ignoreints
argument_list|()
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|newRCSfilename
argument_list|,
name|RCSfilename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't write new RCS file %s; saved in %s"
argument_list|,
name|RCSfilename
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
name|newRCSfilename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* avoid deletion by cleanup*/
name|catchints
argument_list|()
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
break|break;
block|}
name|newRCSfilename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* avoid re-unlinking by cleanup()*/
if|if
condition|(
name|chmod
argument_list|(
name|RCSfilename
argument_list|,
name|filestatus
operator|.
name|st_mode
operator|&
operator|~
literal|0222
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"Can't set mode of %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|catchints
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SNOOPFILE
name|logcommand
argument_list|(
literal|"ci"
argument_list|,
operator|&
name|newdelta
argument_list|,
name|gendeltas
argument_list|,
name|caller
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|keepworkingfile
condition|)
block|{
name|unlink
argument_list|(
name|workfilename
argument_list|)
expr_stmt|;
comment|/* get rid of old file */
block|}
else|else
block|{
comment|/* expand keywords in file */
name|newworkfilename
operator|=
name|xpandfile
argument_list|(
name|workfilename
argument_list|,
name|workfilename
comment|/*for directory*/
argument_list|,
operator|&
name|newdelta
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newworkfilename
condition|)
continue|continue;
comment|/* expand failed */
name|ignoreints
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
name|workfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|newworkfilename
argument_list|,
name|workfilename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't expand keywords in %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|catchints
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|workfilename
argument_list|,
name|WORKMODE
argument_list|(
name|filestatus
operator|.
name|st_mode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"Can't adjust mode of %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|catchints
argument_list|()
expr_stmt|;
block|}
name|diagnose
argument_list|(
literal|"done"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|exit
argument_list|(
name|nerror
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of main (ci) */
end_comment

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/* the rest are auxiliary routines                               */
end_comment

begin_function
name|int
name|addbranch
parameter_list|(
name|branchpoint
parameter_list|,
name|num
parameter_list|)
name|struct
name|hshentry
modifier|*
name|branchpoint
decl_stmt|;
name|char
modifier|*
name|num
decl_stmt|;
comment|/* adds a new branch and branch delta at branchpoint.  * If num is the null string, appends the new branch, incrementing  * the highest branch number (initially 1), and setting the level number to 1.  * the new delta and branchhead are in globals newdelta and newbranch, resp.  * the new number is placed into num.  * returns false on error.  */
block|{
name|struct
name|branchhead
modifier|*
name|bhead
decl_stmt|,
modifier|*
name|btrail
decl_stmt|;
name|char
name|branchnum
index|[
name|revlength
index|]
decl_stmt|;
name|int
name|numlength
decl_stmt|,
name|result
decl_stmt|,
name|field
decl_stmt|;
name|numlength
operator|=
name|countnumflds
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|branchpoint
operator|->
name|branches
operator|==
name|nil
condition|)
block|{
comment|/* start first branch */
name|branchpoint
operator|->
name|branches
operator|=
operator|&
name|newbranch
expr_stmt|;
if|if
condition|(
name|numlength
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|num
argument_list|,
name|branchpoint
operator|->
name|num
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1.1"
argument_list|)
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|countnumflds(num)%
literal|2
argument|==
literal|1
argument_list|)
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
name|nil
expr_stmt|;
block|}
name|elsif
argument_list|(
argument|numlength==
literal|0
argument_list|)
block|{
comment|/* append new branch to the end */
name|bhead
operator|=
name|branchpoint
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|bhead
operator|->
name|nextbranch
condition|)
name|bhead
operator|=
name|bhead
operator|->
name|nextbranch
expr_stmt|;
name|bhead
operator|->
name|nextbranch
operator|=
operator|&
name|newbranch
expr_stmt|;
name|getbranchno
argument_list|(
name|bhead
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|branchnum
argument_list|)
expr_stmt|;
name|incnum
argument_list|(
name|branchnum
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
name|nil
expr_stmt|;
block|}
else|else
block|{
comment|/* place the branch properly */
name|field
operator|=
name|numlength
operator|-
operator|(
name|numlength
operator|%
literal|2
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* field of branch number */
name|bhead
operator|=
name|branchpoint
operator|->
name|branches
expr_stmt|;
while|while
condition|(
operator|(
name|bhead
operator|!=
name|nil
operator|)
operator|&&
operator|(
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|num
argument_list|,
name|bhead
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|field
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|btrail
operator|=
name|bhead
expr_stmt|;
name|bhead
operator|=
name|bhead
operator|->
name|nextbranch
expr_stmt|;
block|}
if|if
condition|(
name|bhead
operator|==
name|nil
operator|||
name|result
operator|<
literal|0
condition|)
block|{
comment|/* insert/append new branchhead */
if|if
condition|(
name|bhead
operator|==
name|branchpoint
operator|->
name|branches
condition|)
name|branchpoint
operator|->
name|branches
operator|=
operator|&
name|newbranch
expr_stmt|;
else|else
name|btrail
operator|->
name|nextbranch
operator|=
operator|&
name|newbranch
expr_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
name|bhead
expr_stmt|;
if|if
condition|(
name|numlength
operator|%
literal|2
operator|==
literal|1
condition|)
name|strcat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* branch exists; append to end */
name|getbranchno
argument_list|(
name|num
argument_list|,
name|branchnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|branchnum
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|,
name|gendeltas
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|olddeltanum
operator|=
name|targetdelta
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|cmpnum
argument_list|(
name|num
argument_list|,
name|olddeltanum
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"deltanumber %s too low; must be higher than %s"
argument_list|,
name|num
argument_list|,
name|olddeltanum
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|removelock
argument_list|(
name|caller
argument_list|,
name|targetdelta
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|numlength
operator|%
literal|2
operator|==
literal|1
condition|)
name|incnum
argument_list|(
name|olddeltanum
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|targetdelta
operator|->
name|next
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
return|return
name|true
return|;
comment|/* Don't do anything to newbranch */
block|}
block|}
name|newbranch
operator|.
name|hsh
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
name|nil
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|struct
name|hshentry
modifier|*
name|removelock
parameter_list|(
name|who
parameter_list|,
name|delta
parameter_list|)
name|char
modifier|*
name|who
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
comment|/* function: Finds the lock held by who on delta,  * removes it, and returns a pointer to the delta.  * delta may be nil; then the first lock held by who is chosen.  * Prints an error message and returns nil if there is no such lock.  * An exception is if StrictLocks==false, and who is the owner of  * the RCS file. If who does not have a lock in this case,  * delta is returned (or Head, if delta is nil).  */
block|{
specifier|register
name|struct
name|lock
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
name|char
modifier|*
name|num
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|struct
name|lock
name|dummy
decl_stmt|;
name|int
name|owner
decl_stmt|,
name|whomatch
decl_stmt|,
name|nummatch
decl_stmt|;
name|num
operator|=
operator|(
name|delta
operator|==
name|nil
operator|)
condition|?
name|nil
else|:
name|delta
operator|->
name|num
expr_stmt|;
name|dummy
operator|.
name|nextlock
operator|=
name|next
operator|=
name|Locks
expr_stmt|;
name|trail
operator|=
operator|&
name|dummy
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
name|whomatch
operator|=
name|strcmp
argument_list|(
name|who
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|whomatch
operator|==
literal|0
condition|)
break|break;
comment|/* found a lock by who */
block|}
else|else
block|{
name|nummatch
operator|=
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|whomatch
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/*found a lock on delta by who*/
if|if
condition|(
operator|(
name|whomatch
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"revision %s locked by %s"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
comment|/*found one; delete it */
name|trail
operator|->
name|nextlock
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|Locks
operator|=
name|dummy
operator|.
name|nextlock
expr_stmt|;
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|nil
expr_stmt|;
comment|/* reset locked-by */
return|return
name|next
operator|->
name|delta
return|;
block|}
else|else
block|{
name|fstat
argument_list|(
name|fileno
argument_list|(
name|finptr
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|owner
operator|=
operator|(
name|StrictLocks
operator|==
name|false
operator|)
operator|&&
operator|(
name|getuid
argument_list|()
operator|==
name|statbuf
operator|.
name|st_uid
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|owner
condition|)
block|{
if|if
condition|(
name|num
operator|==
name|nil
condition|)
name|error
argument_list|(
literal|"no lock set by %s"
argument_list|,
name|who
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no lock set by %s for revision %s"
argument_list|,
name|who
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
name|elsif
argument_list|(
argument|num!=nil
argument_list|)
block|{
return|return
name|delta
return|;
block|}
else|else
block|{
comment|/* want to return Head, but check first if locked*/
name|next
operator|=
name|Locks
expr_stmt|;
name|num
operator|=
name|Head
operator|->
name|num
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"revision %s locked by %s"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
return|return
name|Head
return|;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|getdate
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Function: puts the current date in the form  * YY.MM.DD.hh.mm.ss\0 into buffer and returns a pointer to it.  */
block|{
include|#
directive|include
file|"time.h"
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
name|long
name|clock
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|clock
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|DATEFORM
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xpandfile
parameter_list|(
name|unexfname
parameter_list|,
name|dir
parameter_list|,
name|delta
parameter_list|)
name|char
modifier|*
name|unexfname
decl_stmt|,
decl|*
name|dir
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Reads file unexpfname and copies it to a  * file in dir, performing keyword substitution with data from delta.  * returns the name of the expanded file if successful, nil otherwise.  */
end_comment

begin_block
block|{
name|char
modifier|*
name|targetfname
decl_stmt|;
name|FILE
modifier|*
name|unexfile
decl_stmt|,
modifier|*
name|exfile
decl_stmt|;
name|targetfname
operator|=
name|mktempfile
argument_list|(
name|dir
argument_list|,
name|TMPFILE3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unexfile
operator|=
name|fopen
argument_list|(
name|unexfname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|exfile
operator|=
name|fopen
argument_list|(
name|targetfname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Can't expand file %s"
argument_list|,
name|unexfname
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
while|while
condition|(
name|expandline
argument_list|(
name|unexfile
argument_list|,
name|exfile
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
empty_stmt|;
comment|/*expand*/
name|ffclose
argument_list|(
name|unexfile
argument_list|)
expr_stmt|;
name|ffclose
argument_list|(
name|exfile
argument_list|)
expr_stmt|;
return|return
name|targetfname
return|;
block|}
end_block

begin_macro
name|mustcheckin
argument_list|(
argument|unexfname
argument_list|,
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|unexfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: determines whether checkin should proceed.  * Compares the wrkfilename with unexfname, disregarding keywords.  * If the 2 files differ, returns true. If they do not differ, asks the user  * whether to return true or false (i.e., whether to checkin the file anyway.  * If the files do not differ, and quietflag==true, returns false.  * Shortcut: If forceciflag==true, mustcheckin() always returns true.  */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|response
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|forceciflag
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|rcsfcmp
argument_list|(
name|workfilename
argument_list|,
name|unexfname
argument_list|,
name|delta
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If files are different, must check them in. */
comment|/* files are the same */
name|diagnose
argument_list|(
literal|"File %s is unchanged with respect to revision %s"
argument_list|,
name|workfilename
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|quietflag
operator|||
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Files are the same, but can't ask, so don't checkin*/
name|result
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* ask user whether to check in */
name|fputs
argument_list|(
literal|"checkin anyway? [ny](n): "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|response
operator|=
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip to end of line*/
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|response
operator|==
literal|'y'
operator|||
name|response
operator|==
literal|'Y'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|quietflag
condition|)
block|{
name|warn
argument_list|(
literal|"checkin aborted since %s was not changed; %s %sdeleted."
argument_list|,
name|workfilename
argument_list|,
name|workfilename
argument_list|,
name|keepworkingfile
condition|?
literal|"not "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"checkin aborted; %s %sdeleted."
argument_list|,
name|workfilename
argument_list|,
name|keepworkingfile
condition|?
literal|"not "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keepworkingfile
condition|)
name|unlink
argument_list|(
name|workfilename
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* --------------------- G E T L O G M S G --------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|getlogmsg
parameter_list|()
comment|/* Function: obtains a log message and returns a pointer to it.  * If a log message is given via the -m option, a pointer to that  * string is returned.  * If this is the initial revision, a standard log message is returned.  * Otherwise, reads a character string from the terminal.  * The string must be terminated with a control-d or a single '.' on a  * line. getlogmsg prompts the first time it is called for the  * log message; during all later calls it asks whether the previous  * log message can be reused.  * returns a pointer to the character string; the pointer is always non-nil.  */
block|{
specifier|static
name|logyet
operator|=
name|false
expr_stmt|;
comment|/*indicates whether previous log present*/
specifier|static
name|char
name|emptylog
index|[]
init|=
literal|"*** empty log message ***\n"
decl_stmt|;
specifier|static
name|char
name|initiallog
index|[]
init|=
literal|"Initial revision\n"
decl_stmt|;
name|char
name|response
decl_stmt|;
name|int
name|cin
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|old1
decl_stmt|,
name|old2
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|msg
condition|)
return|return
name|msg
return|;
if|if
condition|(
operator|(
name|olddeltanum
operator|==
name|nil
operator|)
operator|&&
operator|(
operator|(
name|cmpnum
argument_list|(
name|newdelnum
argument_list|,
literal|"1.1"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|cmpnum
argument_list|(
name|newdelnum
argument_list|,
literal|"1.0"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|initiallog
return|;
if|if
condition|(
name|logyet
condition|)
block|{
comment|/*previous log available*/
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
return|return
name|logmsg
return|;
comment|/* reuse if stdin is not a terminal*/
comment|/* otherwise ask */
name|fputs
argument_list|(
literal|"reuse log message of previous file? [yn](y): "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|response
operator|=
name|cin
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|cin
operator|==
name|EOF
operator|||
name|cin
operator|==
literal|'\n'
operator|)
condition|)
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip to end of line*/
if|if
condition|(
name|cin
operator|==
name|EOF
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
literal|'\n'
operator|||
name|response
operator|==
literal|'y'
operator|||
name|response
operator|==
literal|'Y'
condition|)
return|return
name|logmsg
return|;
else|else
name|logmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*kill existing log message */
block|}
comment|/* now read string from terminal */
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"enter log message:\n(terminate with ^D or single '.')\n>> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|tp
operator|=
name|logmsg
expr_stmt|;
name|old1
operator|=
literal|'\n'
expr_stmt|;
name|old2
operator|=
literal|' '
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|cin
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* append newline */
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
comment|/*terminate*/
break|break;
block|}
if|if
condition|(
name|cin
operator|==
literal|'\n'
operator|&&
name|old1
operator|==
literal|'.'
operator|&&
name|old2
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/*kill last period */
break|break;
block|}
if|if
condition|(
name|tp
operator|>=
name|logmsg
operator|+
name|logsize
operator|-
literal|2
condition|)
block|{
comment|/* overflow */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"log message truncated to %d characters"
argument_list|,
name|logsize
argument_list|)
expr_stmt|;
name|logmsg
index|[
name|logsize
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|logmsg
index|[
name|logsize
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|logmsg
return|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"log message too long. Maximum: %d\n"
argument_list|,
name|logsize
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"reenter log message:\n>> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|tp
operator|=
name|logmsg
expr_stmt|;
name|old1
operator|=
literal|'\n'
expr_stmt|;
name|old2
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|cin
operator|!=
literal|'\n'
operator|&&
name|cin
operator|!=
name|EOF
condition|)
name|cin
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/*skip line */
continue|continue;
block|}
if|if
condition|(
name|cin
operator|==
literal|'\n'
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|">> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|cin
expr_stmt|;
name|old2
operator|=
name|old1
expr_stmt|;
name|old1
operator|=
name|cin
expr_stmt|;
comment|/* this is the actual work!*/
comment|/*SDELIM will be changed to double SDELIM by putdtext*/
block|}
comment|/* end for */
comment|/* now check whether the log message is not empty */
name|tp
operator|=
name|logmsg
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|tp
operator|++
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\f'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|tp
operator|==
literal|'\0'
condition|)
block|{
name|logyet
operator|=
name|false
expr_stmt|;
return|return
name|emptylog
return|;
block|}
else|else
block|{
name|logyet
operator|=
name|true
expr_stmt|;
return|return
name|logmsg
return|;
block|}
block|}
end_function

end_unit

