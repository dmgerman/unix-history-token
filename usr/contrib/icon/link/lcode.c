begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines to parse .u1 files and produce icode.  */
end_comment

begin_include
include|#
directive|include
file|"ilink.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"datatype.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|pc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* simulated program counter */
end_comment

begin_comment
comment|/*  * gencode - read .u1 file, resolve variable references, and generate icode.  *  Basic process is to read each line in the file and take some action  *  as dictated by the opcode.  This action sometimes involves parsing  *  of operands and usually culminates in the call of the appropriate  *  emit* routine.  *  * Appendix C of the "tour" has a complete description of the intermediate  *  language that gencode parses.  */
end_comment

begin_macro
name|gencode
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|op
decl_stmt|,
name|k
decl_stmt|,
name|lab
decl_stmt|;
name|int
name|j
decl_stmt|,
name|nargs
decl_stmt|,
name|flags
decl_stmt|,
name|implicit
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|procname
decl_stmt|;
name|struct
name|centry
modifier|*
name|cp
decl_stmt|;
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|,
modifier|*
name|flocate
argument_list|()
decl_stmt|;
specifier|extern
name|long
name|getint
parameter_list|()
function_decl|;
specifier|extern
name|double
name|getreal
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getid
argument_list|()
decl_stmt|,
modifier|*
name|getstrlit
argument_list|()
decl_stmt|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|op
operator|=
name|getop
argument_list|(
operator|&
name|name
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* Ternary operators. */
case|case
name|OP_TOBY
case|:
case|case
name|OP_SECT
case|:
comment|/* Binary operators. */
case|case
name|OP_ASGN
case|:
case|case
name|OP_CAT
case|:
case|case
name|OP_DIFF
case|:
case|case
name|OP_DIV
case|:
case|case
name|OP_EQV
case|:
case|case
name|OP_INTER
case|:
case|case
name|OP_LCONCAT
case|:
case|case
name|OP_LEXEQ
case|:
case|case
name|OP_LEXGE
case|:
case|case
name|OP_LEXGT
case|:
case|case
name|OP_LEXLE
case|:
case|case
name|OP_LEXLT
case|:
case|case
name|OP_LEXNE
case|:
case|case
name|OP_MINUS
case|:
case|case
name|OP_MOD
case|:
case|case
name|OP_MULT
case|:
case|case
name|OP_NEQV
case|:
case|case
name|OP_NUMEQ
case|:
case|case
name|OP_NUMGE
case|:
case|case
name|OP_NUMGT
case|:
case|case
name|OP_NUMLE
case|:
case|case
name|OP_NUMLT
case|:
case|case
name|OP_NUMNE
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_POWER
case|:
case|case
name|OP_RASGN
case|:
case|case
name|OP_RSWAP
case|:
case|case
name|OP_SUBSC
case|:
case|case
name|OP_SWAP
case|:
case|case
name|OP_UNIONCS
case|:
comment|/* Unary operators. */
case|case
name|OP_BANG
case|:
case|case
name|OP_COMPL
case|:
case|case
name|OP_NEG
case|:
case|case
name|OP_NONNULL
case|:
case|case
name|OP_NULL
case|:
case|case
name|OP_NUMBER
case|:
case|case
name|OP_RANDOM
case|:
case|case
name|OP_REFRESH
case|:
case|case
name|OP_SIZE
case|:
case|case
name|OP_TABMAT
case|:
case|case
name|OP_VALUE
case|:
comment|/* Instructions. */
case|case
name|OP_BSCAN
case|:
case|case
name|OP_CCASE
case|:
case|case
name|OP_COACT
case|:
case|case
name|OP_COFAIL
case|:
case|case
name|OP_CORET
case|:
case|case
name|OP_DUP
case|:
case|case
name|OP_EFAIL
case|:
case|case
name|OP_ERET
case|:
case|case
name|OP_ESCAN
case|:
case|case
name|OP_ESUSP
case|:
case|case
name|OP_INCRES
case|:
case|case
name|OP_LIMIT
case|:
case|case
name|OP_LSUSP
case|:
case|case
name|OP_PFAIL
case|:
case|case
name|OP_PNULL
case|:
case|case
name|OP_POP
case|:
case|case
name|OP_PRET
case|:
case|case
name|OP_PSUSP
case|:
case|case
name|OP_PUSH1
case|:
case|case
name|OP_PUSHN1
case|:
case|case
name|OP_SDUP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CHFAIL
case|:
case|case
name|OP_CREATE
case|:
case|case
name|OP_GOTO
case|:
case|case
name|OP_INIT
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitl
argument_list|(
name|op
argument_list|,
name|lab
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CSET
case|:
case|case
name|OP_REAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitr
argument_list|(
name|op
argument_list|,
name|ctable
index|[
name|k
index|]
operator|.
name|c_pc
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FIELD
case|:
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|fp
operator|=
name|flocate
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
name|id
argument_list|,
literal|"invalid field name"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|emitn
argument_list|(
name|op
argument_list|,
name|fp
operator|->
name|f_fid
operator|-
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FILE
case|:
name|file
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emiti
argument_list|(
name|op
argument_list|,
name|file
operator|-
name|strings
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INT
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_flag
operator|&
name|F_LONGLIT
condition|)
name|emitr
argument_list|(
name|OP_CON
argument_list|,
name|cp
operator|->
name|c_pc
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|c_val
operator|.
name|ival
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|16
condition|)
name|emit
argument_list|(
name|OP_INTX
operator|+
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|emitint
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_INVOKE
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|abbrev
argument_list|(
name|op
argument_list|,
name|k
argument_list|,
name|name
argument_list|,
name|OP_INVKX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_KEYWD
case|:
case|case
name|OP_LLIST
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitn
argument_list|(
name|op
argument_list|,
name|k
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LAB
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"L%d:\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|backpatch
argument_list|(
name|lab
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LINE
case|:
name|line
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|abbrev
argument_list|(
name|op
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|OP_LINEX
argument_list|,
literal|64
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|lab
operator|!=
literal|0
condition|)
name|emitl
argument_list|(
name|op
argument_list|,
name|lab
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
name|OP_MARK0
argument_list|,
literal|"mark0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
name|id
operator|=
name|cp
operator|->
name|c_val
operator|.
name|sval
expr_stmt|;
name|emitin
argument_list|(
name|op
argument_list|,
name|id
operator|-
name|strings
argument_list|,
name|cp
operator|->
name|c_length
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_UNMARK
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|abbrev
argument_list|(
name|op
argument_list|,
name|k
argument_list|,
name|name
argument_list|,
name|OP_UNMKX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VAR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|flags
operator|=
name|ltable
index|[
name|k
index|]
operator|.
name|l_flag
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_GLOBAL
condition|)
name|abbrev
argument_list|(
name|OP_GLOBAL
argument_list|,
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|global
operator|-
name|gtable
argument_list|,
literal|"global"
argument_list|,
name|OP_GLOBX
argument_list|,
literal|16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STATIC
condition|)
name|abbrev
argument_list|(
name|OP_STATIC
argument_list|,
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|staticid
operator|-
literal|1
argument_list|,
literal|"static"
argument_list|,
name|OP_STATX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_ARGUMENT
condition|)
name|abbrev
argument_list|(
name|OP_ARG
argument_list|,
name|nargs
operator|-
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
argument_list|,
literal|"arg"
argument_list|,
name|OP_ARGX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|abbrev
argument_list|(
name|OP_LOCAL
argument_list|,
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
operator|-
literal|1
argument_list|,
literal|"local"
argument_list|,
name|OP_LOCX
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
comment|/* Declarations. */
case|case
name|OP_PROC
case|:
name|procname
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|locinit
argument_list|()
expr_stmt|;
name|clearlab
argument_list|()
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
name|gp
operator|=
name|glocate
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|implicit
operator|=
name|gp
operator|->
name|g_flag
operator|&
name|F_IMPERROR
expr_stmt|;
name|nargs
operator|=
name|gp
operator|->
name|g_nargs
expr_stmt|;
name|emiteven
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_LOCAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|putloc
argument_list|(
name|k
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|implicit
argument_list|,
name|procname
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CON
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_INTLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_REALLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|getreal
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STRLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|pc
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_CSETLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|pc
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal constant\n"
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitcon
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DECLEND
case|:
name|newline
argument_list|()
expr_stmt|;
name|gp
operator|->
name|g_pc
operator|=
name|pc
expr_stmt|;
name|emitproc
argument_list|(
name|procname
argument_list|,
name|nargs
argument_list|,
name|dynoff
argument_list|,
name|statics
operator|-
name|static1
argument_list|,
name|static1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_END
case|:
name|newline
argument_list|()
expr_stmt|;
name|flushcode
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal opcode(%d): %s\n"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * abbrev - for certain opcodes with integer arguments that are small enough,  * use an abbreviated opcode that includes the integer argument in it.  */
end_comment

begin_macro
name|abbrev
argument_list|(
argument|op
argument_list|,
argument|n
argument_list|,
argument|name
argument_list|,
argument|altop
argument_list|,
argument|limit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|altop
decl_stmt|,
name|limit
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|limit
condition|)
name|emit
argument_list|(
name|altop
operator|+
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|emitn
argument_list|(
name|op
argument_list|,
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  emit - emit opcode.  *  emitl - emit opcode with reference to program label, consult the "tour"  *	for a description of the chaining and backpatching for labels.  *  emitn - emit opcode with integer argument.  *  emitr - emit opcode with pc-relative reference.  *  emiti - emit opcode with reference to identifier table.  *  emitin - emit opcode with reference to identifier table& integer argument.  *  emitint - emit INT opcode with integer argument.  *  emiteven - emit null bytes to bring pc to word boundary.  *  emitcon - emit constant table entry.  *  emitproc - emit procedure block.  *  * The emit* routines call out* routines to effect the "outputting" of icode.  *  Note that the majority of the code for the emit* routines is for debugging  *  purposes.  */
end_comment

begin_macro
name|emit
argument_list|(
argument|op
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outop
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitl
argument_list|(
argument|op
argument_list|,
argument|lab
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|lab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tL%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|lab
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab
operator|>=
name|maxlabels
condition|)
name|syserr
argument_list|(
literal|"too many labels in ucode"
argument_list|)
expr_stmt|;
name|outop
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
index|[
name|lab
index|]
operator|<=
literal|0
condition|)
block|{
comment|/* forward reference */
name|outopnd
argument_list|(
name|labels
index|[
name|lab
index|]
argument_list|)
expr_stmt|;
name|labels
index|[
name|lab
index|]
operator|=
name|OPNDSIZE
operator|-
name|pc
expr_stmt|;
comment|/* add to front of reference chain */
block|}
else|else
comment|/* output relative offset */
name|outopnd
argument_list|(
name|labels
index|[
name|lab
index|]
operator|-
operator|(
name|pc
operator|+
name|OPNDSIZE
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitn
argument_list|(
argument|op
argument_list|,
argument|n
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outopnd
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitr
argument_list|(
argument|op
argument_list|,
argument|loc
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|loc
operator|-=
name|pc
operator|+
operator|(
name|OPSIZE
operator|+
name|OPNDSIZE
operator|)
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
if|if
condition|(
name|loc
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t*+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|loc
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t*-%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
operator|-
name|loc
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|outop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outopnd
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emiti
argument_list|(
argument|op
argument_list|,
argument|offset
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|offset
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outopnd
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitin
argument_list|(
argument|op
argument_list|,
argument|offset
argument_list|,
argument|n
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|offset
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tI+%d,%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|offset
argument_list|,
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outopnd
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|outopnd
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * emitint can have some pitfalls.  outword is used to output the  *  integer and this is picked up in the interpreter as the second  *  word of a short integer.  The integer value output must be  *  the same size as what the interpreter expects.  See op_int and op_intx  *  in interp.s  */
end_comment

begin_macro
name|emitint
argument_list|(
argument|op
argument_list|,
argument|i
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emiteven
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
operator|(
name|pc
operator|%
name|WORDSIZE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t0\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|outop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|emitcon
argument_list|(
name|k
argument_list|)
specifier|register
name|int
name|k
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|csbuf
index|[
name|CSETSIZE
index|]
decl_stmt|;
union|union
block|{
name|char
name|ovly
index|[
literal|1
index|]
decl_stmt|;
comment|/* Array used to overlay l and f on a bytewise basis. */
name|long
name|int
name|l
decl_stmt|;
name|double
name|f
decl_stmt|;
block|}
name|x
union|;
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_REALLIT
condition|)
block|{
name|x
operator|.
name|f
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d"
argument_list|,
name|pc
argument_list|,
name|T_REAL
argument_list|)
expr_stmt|;
name|dumpblock
argument_list|(
name|x
operator|.
name|ovly
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t\t\t( %g )\n"
argument_list|,
name|x
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
name|outword
argument_list|(
name|T_REAL
argument_list|)
expr_stmt|;
name|outblock
argument_list|(
name|x
operator|.
name|ovly
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_LONGLIT
condition|)
block|{
name|x
operator|.
name|l
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|ival
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d"
argument_list|,
name|pc
argument_list|,
name|T_LONGINT
argument_list|)
expr_stmt|;
name|dumpblock
argument_list|(
name|x
operator|.
name|ovly
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t\t\t( %ld)\n"
argument_list|,
name|x
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
name|outword
argument_list|(
name|T_LONGINT
argument_list|)
expr_stmt|;
name|outblock
argument_list|(
name|x
operator|.
name|ovly
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_CSETLIT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSETSIZE
condition|;
name|i
operator|++
control|)
name|csbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|sval
expr_stmt|;
name|i
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_length
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|setb
argument_list|(
operator|*
name|s
argument_list|,
name|csbuf
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d"
argument_list|,
name|pc
argument_list|,
name|T_CSET
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|T_CSET
argument_list|)
expr_stmt|;
name|outblock
argument_list|(
name|csbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|csbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|dumpblock
argument_list|(
name|csbuf
argument_list|,
name|CSETSIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|emitproc
argument_list|(
argument|name
argument_list|,
argument|nargs
argument_list|,
argument|ndyn
argument_list|,
argument|nstat
argument_list|,
argument|fstat
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
decl_stmt|,
name|ndyn
decl_stmt|,
name|nstat
decl_stmt|,
name|fstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/*     * ProcBlockSize = sizeof(BasicProcBlock) +      *  sizeof(descrip)*(# of args + # of dynamics + # of statics).     */
name|size
operator|=
operator|(
literal|9
operator|*
name|WORDSIZE
operator|)
operator|+
operator|(
literal|2
operator|*
name|WORDSIZE
operator|)
operator|*
operator|(
name|nargs
operator|+
name|ndyn
operator|+
name|nstat
operator|)
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d"
argument_list|,
name|pc
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
comment|/* type code */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* size of block */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\tZ+%d\n"
argument_list|,
name|pc
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* entry point */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
comment|/* # of arguments */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|ndyn
argument_list|)
expr_stmt|;
comment|/* # of dynamic locals */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|nstat
argument_list|)
expr_stmt|;
comment|/* # of static locals */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\n"
argument_list|,
name|fstat
argument_list|)
expr_stmt|;
comment|/* first static */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
comment|/* name of procedure */
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
operator|-
name|strings
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|outword
argument_list|(
name|T_PROC
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|pc
operator|+
name|size
operator|-
literal|2
operator|*
name|WORDSIZE
argument_list|)
expr_stmt|;
comment|/* Have to allow for the two words                                      that we've already output. */
name|outword
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|ndyn
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|nstat
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|fstat
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|name
operator|-
name|strings
argument_list|)
expr_stmt|;
comment|/*     * Output string descriptors for argument names by looping through     *  all locals, and picking out those with F_ARGUMENT set.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_ARGUMENT
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|p
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * Output string descriptors for local variable names.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_DYNAMIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|p
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * Output string descriptors for local variable names.     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_STATIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|p
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * gentables - generate interpreter code for global, static,  *  identifier, and record tables, and built-in procedure blocks.  */
end_comment

begin_macro
name|gentables
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
name|struct
name|rentry
modifier|*
name|rp
decl_stmt|;
name|struct
name|header
name|hdr
decl_stmt|;
name|emiteven
argument_list|()
expr_stmt|;
comment|/*     * Output record constructor procedure blocks.     */
name|hdr
operator|.
name|records
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t\t\t\t# record blocks\n"
argument_list|,
name|pc
argument_list|,
name|nrecords
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|nrecords
argument_list|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
name|s
operator|=
name|gp
operator|->
name|g_name
expr_stmt|;
name|gp
operator|->
name|g_pc
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|RKBLKSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t_mkrec+4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|gp
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t-2"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|-
name|strings
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|outword
argument_list|(
name|T_PROC
argument_list|)
expr_stmt|;
comment|/* type code */
name|outword
argument_list|(
name|RKBLKSIZE
argument_list|)
expr_stmt|;
comment|/* size of block */
name|outword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* entry point (filled in by interp)*/
name|outword
argument_list|(
name|gp
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
comment|/* number of fields */
name|outword
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* record constructor indicator */
name|outword
argument_list|(
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
comment|/* record id */
name|outword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* not used */
name|outword
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* name of record */
name|outword
argument_list|(
name|s
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * Output record/field table.     */
name|hdr
operator|.
name|ftab
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t\t\t\t\t# record/field table\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|ftable
init|;
name|fp
operator|<
name|ffree
condition|;
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|rp
operator|=
name|fp
operator|->
name|f_rlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrecords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|rp
operator|->
name|r_recid
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|rp
operator|->
name|r_fnum
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|rp
operator|->
name|r_fnum
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rp
operator|->
name|r_link
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t-1"
argument_list|)
expr_stmt|;
name|outword
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Dflag
operator|&&
operator|(
name|i
operator|==
name|nrecords
operator|||
operator|(
name|i
operator|&
literal|03
operator|)
operator|==
literal|0
operator|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbgfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * Output global variable descriptors.     */
name|hdr
operator|.
name|globals
operator|=
name|pc
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_BUILTIN
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
comment|/* built-in procedure */
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%06o\t%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|D_PROC
argument_list|,
operator|-
name|gp
operator|->
name|g_procid
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|D_PROC
argument_list|)
expr_stmt|;
name|outword
argument_list|(
operator|-
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_PROC
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
comment|/* Icon procedure */
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%06o\tZ+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_pc
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|D_PROC
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|gp
operator|->
name|g_pc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
comment|/* record constructor */
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%06o\tZ+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_pc
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|D_PROC
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|gp
operator|->
name|g_pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* global variable */
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t0\t0\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|outword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * Output descriptors for global variable names.     */
name|hdr
operator|.
name|gnames
operator|=
name|pc
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|strlen
argument_list|(
name|gp
operator|->
name|g_name
argument_list|)
argument_list|,
name|gp
operator|->
name|g_name
operator|-
name|strings
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|strlen
argument_list|(
name|gp
operator|->
name|g_name
argument_list|)
argument_list|)
expr_stmt|;
name|outword
argument_list|(
name|gp
operator|->
name|g_name
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
comment|/*     * Output a null descriptor for each static variable.     */
name|hdr
operator|.
name|statics
operator|=
name|pc
expr_stmt|;
for|for
control|(
name|i
operator|=
name|statics
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t0\t0\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|outword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|outword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|flushcode
argument_list|()
expr_stmt|;
comment|/*     * Output the identifier table.  Note that the call to write     *  really does all the work.     */
name|hdr
operator|.
name|ident
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
for|for
control|(
name|s
operator|=
name|strings
init|;
name|s
operator|<
name|sfree
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%03o"
argument_list|,
name|pc
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|s
operator|>=
name|sfree
condition|)
break|break;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|" %03o"
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbgfile
argument_list|)
expr_stmt|;
block|}
block|}
name|write
argument_list|(
name|fileno
argument_list|(
name|outfile
argument_list|)
argument_list|,
name|strings
argument_list|,
name|sfree
operator|-
name|strings
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|sfree
operator|-
name|strings
expr_stmt|;
comment|/*     * Output icode file header.     */
name|hdr
operator|.
name|size
operator|=
name|pc
expr_stmt|;
name|hdr
operator|.
name|trace
operator|=
name|trace
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"size:    %d\n"
argument_list|,
name|hdr
operator|.
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"trace:   %d\n"
argument_list|,
name|hdr
operator|.
name|trace
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"records: %d\n"
argument_list|,
name|hdr
operator|.
name|records
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"ftab:    %d\n"
argument_list|,
name|hdr
operator|.
name|ftab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"globals: %d\n"
argument_list|,
name|hdr
operator|.
name|globals
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"gnames:  %d\n"
argument_list|,
name|hdr
operator|.
name|gnames
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"statics: %d\n"
argument_list|,
name|hdr
operator|.
name|statics
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"ident:   %d\n"
argument_list|,
name|hdr
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|outfile
argument_list|,
operator|(
name|long
operator|)
name|hdrloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fileno
argument_list|(
name|outfile
argument_list|)
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|CodeCheck
value|if (codep>= code + maxcode)\                      syserr("out of code buffer space")
end_define

begin_comment
comment|/*  * outop(i) outputs the integer i as an interpreter opcode.  This  *  assumes opcodes fit into a char.  If they don't, outop will  *  need to look like outword and outopnd.  */
end_comment

begin_macro
name|outop
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CodeCheck
expr_stmt|;
operator|*
name|codep
operator|++
operator|=
name|op
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * outopnd(i) outputs i as an operand for an interpreter operation.  *  OPNDSIZE bytes must be moved from&opnd[0] to&codep[0].  */
end_comment

begin_macro
name|outopnd
argument_list|(
argument|opnd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|opnd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|i
decl_stmt|;
name|char
name|c
index|[
name|OPNDSIZE
index|]
decl_stmt|;
block|}
name|u
union|;
name|CodeCheck
expr_stmt|;
name|u
operator|.
name|i
operator|=
operator|(
name|char
operator|*
operator|)
name|opnd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPNDSIZE
condition|;
name|i
operator|++
control|)
name|codep
index|[
name|i
index|]
operator|=
name|u
operator|.
name|c
index|[
name|i
index|]
expr_stmt|;
name|codep
operator|+=
name|OPNDSIZE
expr_stmt|;
name|pc
operator|+=
name|OPNDSIZE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * outword(i) outputs i as a word that is used by the runtime system  *  WORDSIZE bytes must be moved from&word[0] to&codep[0].  */
end_comment

begin_macro
name|outword
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|int
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|i
decl_stmt|;
name|char
name|c
index|[
name|WORDSIZE
index|]
decl_stmt|;
block|}
name|u
union|;
name|CodeCheck
expr_stmt|;
name|u
operator|.
name|i
operator|=
operator|(
name|char
operator|*
operator|)
name|word
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WORDSIZE
condition|;
name|i
operator|++
control|)
name|codep
index|[
name|i
index|]
operator|=
name|u
operator|.
name|c
index|[
name|i
index|]
expr_stmt|;
name|codep
operator|+=
name|WORDSIZE
expr_stmt|;
name|pc
operator|+=
name|WORDSIZE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * outblock(a,i) output i bytes starting at address a.  */
end_comment

begin_macro
name|outblock
argument_list|(
argument|addr
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|codep
operator|+
name|count
operator|>
name|code
operator|+
name|maxcode
condition|)
name|syserr
argument_list|(
literal|"out of code buffer space"
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
name|codep
operator|++
operator|=
operator|*
name|addr
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * dumpblock(a,i) dump contents of i bytes at address a, used only  *  in conjunction with -D.  */
end_comment

begin_macro
name|dumpblock
argument_list|(
argument|addr
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|" %03o"
argument_list|,
operator|(
name|unsigned
operator|)
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbgfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * flushcode - write buffered code to the output file.  */
end_comment

begin_macro
name|flushcode
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|codep
operator|>
name|code
condition|)
comment|/*fwrite(code, 1, codep - code, outfile);*/
name|write
argument_list|(
name|fileno
argument_list|(
name|outfile
argument_list|)
argument_list|,
name|code
argument_list|,
name|codep
operator|-
name|code
argument_list|)
expr_stmt|;
name|codep
operator|=
name|code
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * clearlab - clear label table to all zeroes.  */
end_comment

begin_macro
name|clearlab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxlabels
condition|;
name|i
operator|++
control|)
name|labels
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * backpatch - fill in all forward references to lab.  */
end_comment

begin_macro
name|backpatch
argument_list|(
argument|lab
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lab
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|p
decl_stmt|,
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|VAX
specifier|register
name|int
modifier|*
name|q
decl_stmt|;
endif|#
directive|endif
endif|VAX
ifdef|#
directive|ifdef
name|PORT
name|int
modifier|*
name|q
decl_stmt|;
comment|/* BE SURE to properly declare q - this won't always work. */
return|return;
endif|#
directive|endif
endif|PORT
ifdef|#
directive|ifdef
name|PDP11
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
endif|#
directive|endif
endif|PDP11
if|if
condition|(
name|lab
operator|>=
name|maxlabels
condition|)
name|syserr
argument_list|(
literal|"too many labels in ucode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|labels
index|[
name|lab
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
name|syserr
argument_list|(
literal|"multiply defined label in ucode"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
literal|0
condition|)
block|{
comment|/* follow reference chain */
name|r
operator|=
name|pc
operator|-
operator|(
name|OPNDSIZE
operator|-
name|p
operator|)
expr_stmt|;
comment|/* compute relative offset */
ifdef|#
directive|ifdef
name|VAX
name|q
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|codep
operator|-
operator|(
name|pc
operator|+
name|p
operator|)
operator|)
expr_stmt|;
comment|/* point to word with address */
name|p
operator|=
operator|*
name|q
expr_stmt|;
comment|/* get next address on chain */
operator|*
name|q
operator|=
name|r
expr_stmt|;
comment|/* fill in correct offset */
endif|#
directive|endif
endif|VAX
ifdef|#
directive|ifdef
name|PORT
endif|#
directive|endif
endif|PORT
ifdef|#
directive|ifdef
name|PDP11
name|q
operator|=
name|codep
operator|-
operator|(
name|pc
operator|+
name|p
operator|)
expr_stmt|;
comment|/* point to word with address */
name|p
operator|=
operator|*
name|q
operator|++
operator|&
literal|0377
expr_stmt|;
comment|/* get next address on chain */
name|p
operator||=
operator|*
name|q
operator|<<
literal|8
expr_stmt|;
operator|*
name|q
operator|=
name|r
operator|>>
literal|8
expr_stmt|;
comment|/* fill in correct offset */
operator|*
operator|--
name|q
operator|=
name|r
expr_stmt|;
endif|#
directive|endif
endif|PDP11
block|}
name|labels
index|[
name|lab
index|]
operator|=
name|pc
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * genheader - output the header line to the .u1 file.  */
end_comment

begin_macro
name|genheader
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|ixhdr
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

