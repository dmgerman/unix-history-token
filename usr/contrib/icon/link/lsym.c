begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines for symbol table manipulation.  */
end_comment

begin_include
include|#
directive|include
file|"ilink.h"
end_include

begin_decl_stmt
name|int
name|dynoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack offset counter for locals */
end_comment

begin_decl_stmt
name|int
name|argoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack offset counter for arguments */
end_comment

begin_decl_stmt
name|int
name|static1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first static in procedure */
end_comment

begin_decl_stmt
name|int
name|statics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static variable counter */
end_comment

begin_decl_stmt
name|int
name|nlocal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of locals in local table */
end_comment

begin_decl_stmt
name|int
name|nconst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of constants in constant table */
end_comment

begin_decl_stmt
name|int
name|nfields
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fields in field table */
end_comment

begin_comment
comment|/*  * instalid - copy the string s to the start of the string free space  *  and call putident with the length of the string.  */
end_comment

begin_function
name|char
modifier|*
name|instalid
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|l
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|extern
name|char
modifier|*
name|putident
parameter_list|()
function_decl|;
name|p1
operator|=
name|sfree
expr_stmt|;
name|p2
operator|=
name|s
expr_stmt|;
name|l
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
condition|)
name|l
operator|++
expr_stmt|;
return|return
operator|(
name|putident
argument_list|(
name|l
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * putident - install the identifier named by the string starting at sfree  *  and extending for len bytes.  The installation entails making an  *  entry in the identifier hash table and then making an identifier  *  table entry for it with alcident.  A side effect of installation  *  is the incrementing of sfree by the length of the string, thus  *  "saving" it.  *  * Nothing is changed if the identifier has already been installed.  */
end_comment

begin_function
name|char
modifier|*
name|putident
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|ientry
modifier|*
name|ip
decl_stmt|;
name|int
name|l
decl_stmt|;
specifier|extern
name|struct
name|ientry
modifier|*
name|alcident
parameter_list|()
function_decl|;
comment|/*     * Compute hash value by adding bytes and masking result with imask.     *  (Recall that imask is ihsize-1.)     */
name|s
operator|=
name|sfree
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
name|hash
operator|+=
operator|*
name|s
operator|++
expr_stmt|;
name|l
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|sfree
expr_stmt|;
name|hash
operator|&=
name|imask
expr_stmt|;
comment|/*     * If the identifier hasn't been installed, install it.     */
if|if
condition|(
operator|(
name|ip
operator|=
name|ihash
index|[
name|hash
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* collision */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* work down i_blink chain until id is found or the                      end of the chain is reached */
if|if
condition|(
name|l
operator|==
name|ip
operator|->
name|i_length
operator|&&
name|lexeq
argument_list|(
name|l
argument_list|,
name|s
argument_list|,
name|ip
operator|->
name|i_name
argument_list|)
condition|)
return|return
operator|(
name|ip
operator|->
name|i_name
operator|)
return|;
comment|/* id is already installed, return it */
if|if
condition|(
name|ip
operator|->
name|i_blink
operator|==
name|NULL
condition|)
block|{
comment|/* end of chain */
name|ip
operator|->
name|i_blink
operator|=
name|alcident
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|l
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|ip
operator|=
name|ip
operator|->
name|i_blink
expr_stmt|;
block|}
block|}
comment|/*     * Hashed to an empty slot.     */
name|ihash
index|[
name|hash
index|]
operator|=
name|alcident
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|l
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lexeq - compare two strings of given length.  Returns non-zero if  *  equal, zero if not equal.  */
end_comment

begin_expr_stmt
name|lexeq
argument_list|(
name|l
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|int
name|l
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * alcident - get the next free identifier table entry, and fill it in with  *  the specified values.  */
end_comment

begin_function
name|struct
name|ientry
modifier|*
name|alcident
parameter_list|(
name|blink
parameter_list|,
name|nam
parameter_list|,
name|len
parameter_list|)
name|struct
name|ientry
modifier|*
name|blink
decl_stmt|;
name|char
modifier|*
name|nam
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|ientry
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|ifree
operator|>=
operator|&
name|itable
index|[
name|isize
index|]
condition|)
name|syserr
argument_list|(
literal|"out of identifier table space"
argument_list|)
expr_stmt|;
name|ip
operator|=
name|ifree
operator|++
expr_stmt|;
name|ip
operator|->
name|i_blink
operator|=
name|blink
expr_stmt|;
name|ip
operator|->
name|i_name
operator|=
name|nam
expr_stmt|;
name|ip
operator|->
name|i_length
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * locinit -  clear local symbol table.  */
end_comment

begin_macro
name|locinit
argument_list|()
end_macro

begin_block
block|{
name|dynoff
operator|=
literal|0
expr_stmt|;
name|argoff
operator|=
literal|0
expr_stmt|;
name|nlocal
operator|=
operator|-
literal|1
expr_stmt|;
name|nconst
operator|=
operator|-
literal|1
expr_stmt|;
name|static1
operator|=
name|statics
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * putloc - make a local symbol table entry.  */
end_comment

begin_function
name|struct
name|lentry
modifier|*
name|putloc
parameter_list|(
name|n
parameter_list|,
name|id
parameter_list|,
name|flags
parameter_list|,
name|imperror
parameter_list|,
name|procname
parameter_list|)
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
specifier|register
name|int
name|flags
decl_stmt|;
name|int
name|imperror
decl_stmt|;
name|char
modifier|*
name|procname
decl_stmt|;
block|{
specifier|register
name|struct
name|lentry
modifier|*
name|lp
decl_stmt|;
specifier|register
union|union
block|{
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|int
name|bn
decl_stmt|;
block|}
name|p
union|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
argument_list|()
decl_stmt|,
modifier|*
name|putglob
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|lsize
condition|)
name|syserr
argument_list|(
literal|"out of local symbol table space."
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nlocal
condition|)
name|nlocal
operator|=
name|n
expr_stmt|;
name|lp
operator|=
operator|&
name|ltable
index|[
name|n
index|]
expr_stmt|;
name|lp
operator|->
name|l_name
operator|=
name|id
expr_stmt|;
name|lp
operator|->
name|l_flag
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
block|{
comment|/* undeclared */
if|if
condition|(
operator|(
name|p
operator|.
name|gp
operator|=
name|glocate
argument_list|(
name|id
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* check global */
name|lp
operator|->
name|l_flag
operator|=
name|F_GLOBAL
expr_stmt|;
name|lp
operator|->
name|l_val
operator|.
name|global
operator|=
name|p
operator|.
name|gp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|.
name|bn
operator|=
name|blocate
argument_list|(
name|id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* check builtin */
name|lp
operator|->
name|l_flag
operator|=
name|F_BUILTIN
expr_stmt|;
name|lp
operator|->
name|l_val
operator|.
name|global
operator|=
name|putglob
argument_list|(
name|id
argument_list|,
name|F_BUILTIN
operator||
name|F_PROC
argument_list|,
operator|-
literal|1
argument_list|,
name|p
operator|.
name|bn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* implicit local */
if|if
condition|(
name|imperror
condition|)
name|warn
argument_list|(
name|id
argument_list|,
literal|"undeclared identifier, procedure "
argument_list|,
name|procname
argument_list|)
expr_stmt|;
name|lp
operator|->
name|l_flag
operator|=
name|F_DYNAMIC
expr_stmt|;
name|lp
operator|->
name|l_val
operator|.
name|offset
operator|=
operator|++
name|dynoff
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_GLOBAL
condition|)
block|{
comment|/* global variable */
if|if
condition|(
operator|(
name|p
operator|.
name|gp
operator|=
name|glocate
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"putloc: global not in global table"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|l_val
operator|.
name|global
operator|=
name|p
operator|.
name|gp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_ARGUMENT
condition|)
comment|/* procedure argument */
name|lp
operator|->
name|l_val
operator|.
name|offset
operator|=
operator|++
name|argoff
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_DYNAMIC
condition|)
comment|/* local dynamic */
name|lp
operator|->
name|l_val
operator|.
name|offset
operator|=
operator|++
name|dynoff
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STATIC
condition|)
comment|/* local static */
name|lp
operator|->
name|l_val
operator|.
name|staticid
operator|=
operator|++
name|statics
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"putloc: unknown flags"
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * putglob - make a global symbol table entry.  */
end_comment

begin_function
name|struct
name|gentry
modifier|*
name|putglob
parameter_list|(
name|id
parameter_list|,
name|flags
parameter_list|,
name|nargs
parameter_list|,
name|procid
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|procid
decl_stmt|;
block|{
specifier|register
name|struct
name|gentry
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
argument_list|()
decl_stmt|,
modifier|*
name|alcglob
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|glocate
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* add to head of hash chain */
name|p
operator|=
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
operator|=
name|alcglob
argument_list|(
name|p
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|nargs
argument_list|,
name|procid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
operator|)
return|;
block|}
name|p
operator|->
name|g_flag
operator||=
name|flags
expr_stmt|;
name|p
operator|->
name|g_nargs
operator|=
name|nargs
expr_stmt|;
name|p
operator|->
name|g_procid
operator|=
name|procid
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * putconst - make a constant symbol table entry.  */
end_comment

begin_decl_stmt
name|struct
name|centry
modifier|*
name|putconst
argument_list|(
name|n
argument_list|,
name|flags
argument_list|,
name|len
argument_list|,
name|pc
argument_list|,
name|val
argument_list|)
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|long
name|ival
decl_stmt|;
name|double
name|rval
decl_stmt|;
name|char
modifier|*
name|sval
decl_stmt|;
block|}
name|val
union|;
end_union

begin_block
block|{
specifier|register
name|struct
name|centry
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|csize
condition|)
name|syserr
argument_list|(
literal|"out of constant table space"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nconst
operator|<
name|n
condition|)
name|nconst
operator|=
name|n
expr_stmt|;
name|p
operator|=
operator|&
name|ctable
index|[
name|n
index|]
expr_stmt|;
name|p
operator|->
name|c_flag
operator|=
name|flags
expr_stmt|;
name|p
operator|->
name|c_pc
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_INTLIT
condition|)
block|{
name|p
operator|->
name|c_val
operator|.
name|ival
operator|=
name|val
operator|.
name|ival
expr_stmt|;
ifdef|#
directive|ifdef
name|LONGS
if|if
condition|(
name|val
operator|.
name|ival
operator|<
operator|(
name|long
operator|)
operator|(
name|short
operator|)
name|MINSHORT
operator||
name|val
operator|.
name|ival
operator|>
operator|(
name|long
operator|)
operator|(
name|short
operator|)
name|MAXSHORT
condition|)
name|p
operator|->
name|c_flag
operator||=
name|F_LONGLIT
expr_stmt|;
endif|#
directive|endif
endif|LONGS
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STRLIT
condition|)
block|{
name|p
operator|->
name|c_val
operator|.
name|sval
operator|=
name|val
operator|.
name|sval
expr_stmt|;
name|p
operator|->
name|c_length
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_CSETLIT
condition|)
block|{
name|p
operator|->
name|c_val
operator|.
name|sval
operator|=
name|val
operator|.
name|sval
expr_stmt|;
name|p
operator|->
name|c_length
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_REALLIT
condition|)
name|p
operator|->
name|c_val
operator|.
name|rval
operator|=
name|val
operator|.
name|rval
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"putconst: bad flags: %06o %011o\n"
argument_list|,
name|flags
argument_list|,
name|val
operator|.
name|ival
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * putfield - make a record/field table entry.  */
end_comment

begin_macro
name|putfield
argument_list|(
argument|fname
argument_list|,
argument|rnum
argument_list|,
argument|fnum
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rnum
decl_stmt|,
name|fnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|rentry
modifier|*
name|rp
decl_stmt|,
modifier|*
name|rp2
decl_stmt|;
name|int
name|hash
decl_stmt|;
specifier|extern
name|struct
name|fentry
modifier|*
name|flocate
argument_list|()
decl_stmt|,
modifier|*
name|alcfhead
argument_list|()
decl_stmt|;
specifier|extern
name|struct
name|rentry
modifier|*
name|alcfrec
parameter_list|()
function_decl|;
name|fp
operator|=
name|flocate
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* create a field entry */
name|nfields
operator|++
expr_stmt|;
name|hash
operator|=
name|fhasher
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fhash
index|[
name|hash
index|]
expr_stmt|;
name|fhash
index|[
name|hash
index|]
operator|=
name|alcfhead
argument_list|(
name|fp
argument_list|,
name|fname
argument_list|,
name|nfields
argument_list|,
name|alcfrec
argument_list|(
name|NULL
argument_list|,
name|rnum
argument_list|,
name|fnum
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|=
name|fp
operator|->
name|f_rlist
expr_stmt|;
comment|/* found field entry, look for */
if|if
condition|(
name|rp
operator|->
name|r_recid
operator|>
name|rnum
condition|)
block|{
comment|/*   spot in record list */
name|fp
operator|->
name|f_rlist
operator|=
name|alcfrec
argument_list|(
name|rp
argument_list|,
name|rnum
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|rp
operator|->
name|r_recid
operator|<
name|rnum
condition|)
block|{
comment|/* keep record list ascending */
if|if
condition|(
name|rp
operator|->
name|r_link
operator|==
name|NULL
condition|)
block|{
name|rp
operator|->
name|r_link
operator|=
name|alcfrec
argument_list|(
name|NULL
argument_list|,
name|rnum
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp2
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|rp
operator|->
name|r_link
expr_stmt|;
block|}
name|rp2
operator|->
name|r_link
operator|=
name|alcfrec
argument_list|(
name|rp
argument_list|,
name|rnum
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * glocate - lookup identifier in global symbol table, return NULL  *  if not present.  */
end_comment

begin_function
name|struct
name|gentry
modifier|*
name|glocate
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
block|{
specifier|register
name|struct
name|gentry
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|g_name
operator|!=
name|id
condition|)
name|p
operator|=
name|p
operator|->
name|g_blink
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * flocate - lookup identifier in field table.  */
end_comment

begin_function
name|struct
name|fentry
modifier|*
name|flocate
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
block|{
specifier|register
name|struct
name|fentry
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|fhash
index|[
name|fhasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|f_name
operator|!=
name|id
condition|)
name|p
operator|=
name|p
operator|->
name|f_blink
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * alcglob - create a new global symbol table entry.  */
end_comment

begin_function
name|struct
name|gentry
modifier|*
name|alcglob
parameter_list|(
name|blink
parameter_list|,
name|name
parameter_list|,
name|flag
parameter_list|,
name|nargs
parameter_list|,
name|procid
parameter_list|)
name|struct
name|gentry
modifier|*
name|blink
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|procid
decl_stmt|;
block|{
specifier|register
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|gfree
operator|>=
operator|&
name|gtable
index|[
name|gsize
index|]
condition|)
name|syserr
argument_list|(
literal|"out of global symbol table space"
argument_list|)
expr_stmt|;
name|gp
operator|=
name|gfree
operator|++
expr_stmt|;
name|gp
operator|->
name|g_blink
operator|=
name|blink
expr_stmt|;
name|gp
operator|->
name|g_name
operator|=
name|name
expr_stmt|;
name|gp
operator|->
name|g_flag
operator|=
name|flag
expr_stmt|;
name|gp
operator|->
name|g_nargs
operator|=
name|nargs
expr_stmt|;
name|gp
operator|->
name|g_procid
operator|=
name|procid
expr_stmt|;
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * alcfhead - allocate a field table header.  */
end_comment

begin_function
name|struct
name|fentry
modifier|*
name|alcfhead
parameter_list|(
name|blink
parameter_list|,
name|name
parameter_list|,
name|fid
parameter_list|,
name|rlist
parameter_list|)
name|struct
name|fentry
modifier|*
name|blink
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fid
decl_stmt|;
name|struct
name|rentry
modifier|*
name|rlist
decl_stmt|;
block|{
specifier|register
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|ffree
operator|>=
operator|&
name|ftable
index|[
name|fsize
index|]
condition|)
name|syserr
argument_list|(
literal|"out of field table space"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|ffree
operator|++
expr_stmt|;
name|fp
operator|->
name|f_blink
operator|=
name|blink
expr_stmt|;
name|fp
operator|->
name|f_name
operator|=
name|name
expr_stmt|;
name|fp
operator|->
name|f_fid
operator|=
name|fid
expr_stmt|;
name|fp
operator|->
name|f_rlist
operator|=
name|rlist
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * alcfrec - allocate a field table record list element.  */
end_comment

begin_function
name|struct
name|rentry
modifier|*
name|alcfrec
parameter_list|(
name|link
parameter_list|,
name|rnum
parameter_list|,
name|fnum
parameter_list|)
name|struct
name|rentry
modifier|*
name|link
decl_stmt|;
name|int
name|rnum
decl_stmt|,
name|fnum
decl_stmt|;
block|{
specifier|register
name|struct
name|rentry
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|rfree
operator|>=
operator|&
name|rtable
index|[
name|rsize
index|]
condition|)
name|syserr
argument_list|(
literal|"out of field table space for record lists"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rfree
operator|++
expr_stmt|;
name|rp
operator|->
name|r_link
operator|=
name|link
expr_stmt|;
name|rp
operator|->
name|r_recid
operator|=
name|rnum
expr_stmt|;
name|rp
operator|->
name|r_fnum
operator|=
name|fnum
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
block|}
end_function

end_unit

