begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../h/rt.h"
end_include

begin_include
include|#
directive|include
file|"../h/keyword.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSTIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
else|SYSTIME
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
endif|SYSTIME
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|day
index|[]
init|=
block|{
literal|"Sunday"
block|,
literal|"Monday"
block|,
literal|"Tuesday"
block|,
literal|"Wednesday"
block|,
literal|"Thursday"
block|,
literal|"Friday"
block|,
literal|"Saturday"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|month
index|[]
init|=
block|{
literal|"January"
block|,
literal|"February"
block|,
literal|"March"
block|,
literal|"April"
block|,
literal|"May"
block|,
literal|"June"
block|,
literal|"July"
block|,
literal|"August"
block|,
literal|"September"
block|,
literal|"October"
block|,
literal|"November"
block|,
literal|"December"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * keywd - process keyword.  */
end_comment

begin_macro
name|keywd
argument_list|(
argument|nargs
argument_list|,
argument|arg1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|descrip
name|arg1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|hour
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|merid
decl_stmt|;
name|char
name|sbuf
index|[
name|MAXSTRING
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tbuf
decl_stmt|,
modifier|*
name|localtime
argument_list|()
decl_stmt|;
name|struct
name|tms
name|tp
decl_stmt|;
name|long
name|time
argument_list|()
decl_stmt|,
name|clock
decl_stmt|,
name|runtim
decl_stmt|;
name|char
modifier|*
name|alcstr
parameter_list|()
function_decl|;
name|SetBound
expr_stmt|;
comment|/*     * This is just plug and chug code.  For whatever keyword is desired,     *  the appropriate value is dug out of the system and made into     *  a suitable Icon value.     *     * A few special cases are worth noting:     *&fail - calls fail();     *&pos,&random,&trace - trapped variables are made for possible     *   subsequent assignments.     */
switch|switch
condition|(
name|INTVAL
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
case|case
name|K_ASCII
case|:
name|arg1
operator|.
name|type
operator|=
name|D_CSET
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_ascii
expr_stmt|;
break|break;
case|case
name|K_CLOCK
case|:
name|sneed
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tbuf
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%02d:%02d:%02d"
argument_list|,
name|tbuf
operator|->
name|tm_hour
argument_list|,
name|tbuf
operator|->
name|tm_min
argument_list|,
name|tbuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|STRLEN
argument_list|(
name|arg1
argument_list|)
operator|=
literal|8
expr_stmt|;
name|STRLOC
argument_list|(
name|arg1
argument_list|)
operator|=
name|alcstr
argument_list|(
name|sbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_CSET
case|:
name|arg1
operator|.
name|type
operator|=
name|D_CSET
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_cset
expr_stmt|;
break|break;
case|case
name|K_DATE
case|:
name|sneed
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tbuf
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%04d/%02d/%02d"
argument_list|,
operator|(
name|tbuf
operator|->
name|tm_year
operator|)
operator|+
literal|1900
argument_list|,
name|tbuf
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tbuf
operator|->
name|tm_mday
argument_list|)
expr_stmt|;
name|STRLEN
argument_list|(
name|arg1
argument_list|)
operator|=
literal|10
expr_stmt|;
name|STRLOC
argument_list|(
name|arg1
argument_list|)
operator|=
name|alcstr
argument_list|(
name|sbuf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_DATELINE
case|:
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tbuf
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hour
operator|=
name|tbuf
operator|->
name|tm_hour
operator|)
operator|>=
literal|12
condition|)
block|{
name|merid
operator|=
literal|"pm"
expr_stmt|;
if|if
condition|(
name|hour
operator|>
literal|12
condition|)
name|hour
operator|-=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|merid
operator|=
literal|"am"
expr_stmt|;
if|if
condition|(
name|hour
operator|<
literal|1
condition|)
name|hour
operator|+=
literal|12
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%s, %s %d, %d  %d:%02d %s"
argument_list|,
name|day
index|[
name|tbuf
operator|->
name|tm_wday
index|]
argument_list|,
name|month
index|[
name|tbuf
operator|->
name|tm_mon
index|]
argument_list|,
name|tbuf
operator|->
name|tm_mday
argument_list|,
literal|1900
operator|+
name|tbuf
operator|->
name|tm_year
argument_list|,
name|hour
argument_list|,
name|tbuf
operator|->
name|tm_min
argument_list|,
name|merid
argument_list|)
expr_stmt|;
name|sneed
argument_list|(
name|i
operator|=
name|strlen
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|STRLEN
argument_list|(
name|arg1
argument_list|)
operator|=
name|i
expr_stmt|;
name|STRLOC
argument_list|(
name|arg1
argument_list|)
operator|=
name|alcstr
argument_list|(
name|sbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_ERROUT
case|:
name|arg1
operator|.
name|type
operator|=
name|D_FILE
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_errout
expr_stmt|;
break|break;
case|case
name|K_FAIL
case|:
name|fail
argument_list|()
expr_stmt|;
break|break;
case|case
name|K_HOST
case|:
name|iconhost
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
name|sneed
argument_list|(
name|i
operator|=
name|strlen
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|STRLEN
argument_list|(
name|arg1
argument_list|)
operator|=
name|i
expr_stmt|;
name|STRLOC
argument_list|(
name|arg1
argument_list|)
operator|=
name|alcstr
argument_list|(
name|sbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_INPUT
case|:
name|arg1
operator|.
name|type
operator|=
name|D_FILE
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_input
expr_stmt|;
break|break;
case|case
name|K_LCASE
case|:
name|arg1
operator|.
name|type
operator|=
name|D_CSET
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_lcase
expr_stmt|;
break|break;
case|case
name|K_LEVEL
case|:
name|arg1
operator|.
name|type
operator|=
name|D_INTEGER
expr_stmt|;
name|INTVAL
argument_list|(
name|arg1
argument_list|)
operator|=
name|k_level
expr_stmt|;
break|break;
case|case
name|K_MAIN
case|:
name|arg1
operator|=
name|k_main
expr_stmt|;
break|break;
case|case
name|K_NULL
case|:
name|arg1
operator|=
name|nulldesc
expr_stmt|;
break|break;
case|case
name|K_OUTPUT
case|:
name|arg1
operator|.
name|type
operator|=
name|D_FILE
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_output
expr_stmt|;
break|break;
case|case
name|K_POS
case|:
name|arg1
operator|.
name|type
operator|=
name|D_TVPOS
expr_stmt|;
name|INTVAL
argument_list|(
name|arg1
argument_list|)
operator|=
name|k_pos
expr_stmt|;
break|break;
case|case
name|K_RANDOM
case|:
name|arg1
operator|.
name|type
operator|=
name|D_TVRAND
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_random
expr_stmt|;
break|break;
case|case
name|K_SOURCE
case|:
name|arg1
operator|=
name|BLKLOC
argument_list|(
name|current
argument_list|)
operator|->
name|estack
operator|.
name|activator
expr_stmt|;
break|break;
case|case
name|K_SUBJECT
case|:
name|arg1
operator|.
name|type
operator|=
name|D_VAR
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_subject
expr_stmt|;
break|break;
case|case
name|K_TIME
case|:
name|times
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
name|runtim
operator|=
literal|1000
operator|*
operator|(
operator|(
name|tp
operator|.
name|tms_utime
operator|-
name|starttime
operator|)
operator|/
operator|(
name|double
operator|)
name|HZ
operator|)
expr_stmt|;
name|mkint
argument_list|(
name|runtim
argument_list|,
operator|&
name|arg1
argument_list|)
expr_stmt|;
break|break;
case|case
name|K_TRACE
case|:
name|arg1
operator|.
name|type
operator|=
name|D_TVTRACE
expr_stmt|;
name|INTVAL
argument_list|(
name|arg1
argument_list|)
operator|=
name|k_trace
expr_stmt|;
break|break;
case|case
name|K_UCASE
case|:
name|arg1
operator|.
name|type
operator|=
name|D_CSET
expr_stmt|;
name|BLKLOC
argument_list|(
name|arg1
argument_list|)
operator|=
operator|(
expr|union
name|block
operator|*
operator|)
operator|&
name|k_ucase
expr_stmt|;
break|break;
case|case
name|K_VERSION
case|:
name|sneed
argument_list|(
name|i
operator|=
name|strlen
argument_list|(
name|VERSION
argument_list|)
argument_list|)
expr_stmt|;
name|STRLEN
argument_list|(
name|arg1
argument_list|)
operator|=
name|i
expr_stmt|;
name|STRLOC
argument_list|(
name|arg1
argument_list|)
operator|=
name|VERSION
expr_stmt|;
break|break;
case|case
name|K_OPTIONS
case|:
name|sneed
argument_list|(
name|i
operator|=
name|strlen
argument_list|(
name|OPTIONS
argument_list|)
argument_list|)
expr_stmt|;
name|STRLEN
argument_list|(
name|arg1
argument_list|)
operator|=
name|i
expr_stmt|;
name|STRLOC
argument_list|(
name|arg1
argument_list|)
operator|=
name|OPTIONS
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"keyword: unknown keyword type."
argument_list|)
expr_stmt|;
block|}
name|ClearBound
expr_stmt|;
block|}
end_block

end_unit

