begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2uni.c,v 1.1 84/06/28 00:49:27 timo Exp $ */
end_comment

begin_comment
comment|/* B units */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_comment
comment|/* for ptr */
end_comment

begin_include
include|#
directive|include
file|"b2fil.h"
end_include

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_include
include|#
directive|include
file|"b2scr.h"
end_include

begin_include
include|#
directive|include
file|"b2err.h"
end_include

begin_include
include|#
directive|include
file|"b2key.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2sou.h"
end_include

begin_include
include|#
directive|include
file|"b2sem.h"
end_include

begin_decl_stmt
name|Forward
name|loc
name|fopnd
argument_list|()
decl_stmt|,
name|fop
argument_list|()
decl_stmt|,
name|basfop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value
name|resval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|outcome
name|resout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|terminated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value
name|global
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|value
name|formlist
decl_stmt|,
name|sharelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|envtab
name|reftab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forming
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|Procedure
name|get_unit
parameter_list|(
name|filed
parameter_list|)
name|bool
name|filed
decl_stmt|;
block|{
name|bool
name|xeq0
init|=
name|xeq
decl_stmt|,
name|hu
init|=
name|No
decl_stmt|,
name|yu
init|=
name|No
decl_stmt|,
name|tu
init|=
name|No
decl_stmt|;
name|txptr
name|fux
init|=
name|tx
decl_stmt|,
name|lux
decl_stmt|;
name|value
name|u
decl_stmt|;
name|literal
name|adic
decl_stmt|;
if|if
condition|(
operator|(
name|hu
operator|=
name|atkw
argument_list|(
name|HOW_TO
argument_list|)
operator|)
operator|||
operator|(
name|yu
operator|=
name|atkw
argument_list|(
name|YIELD
argument_list|)
operator|)
operator|||
operator|(
name|tu
operator|=
name|atkw
argument_list|(
name|TEST
argument_list|)
operator|)
condition|)
block|{
name|lino
operator|=
literal|1
expr_stmt|;
name|uname
operator|=
name|aster
expr_stmt|;
if|if
condition|(
name|cur_ilev
operator|!=
literal|0
condition|)
name|parerr
argument_list|(
literal|"unit starts with indentation"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|formlist
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
if|if
condition|(
name|hu
condition|)
block|{
name|txptr
name|utx
decl_stmt|,
name|vtx
decl_stmt|;
name|value
name|f
decl_stmt|;
name|uname
operator|=
name|keyword
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|utype
operator|=
name|FHW
expr_stmt|;
name|req
argument_list|(
literal|":"
argument_list|,
name|ceol
argument_list|,
operator|&
name|utx
argument_list|,
operator|&
name|vtx
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|utx
condition|)
block|{
if|if
condition|(
name|Cap
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
goto|goto
name|nxt_kw
goto|;
if|if
condition|(
operator|!
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
name|parerr
argument_list|(
literal|"no formal parameter where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|f
operator|=
name|tag
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
argument_list|(
name|f
argument_list|,
name|formlist
argument_list|)
condition|)
name|pprerr
argument_list|(
literal|"multiple use of formal parameter"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|f
argument_list|,
operator|&
name|formlist
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|nxt_kw
label|:
if|if
condition|(
name|tx
operator|<
name|utx
condition|)
block|{
name|release
argument_list|(
name|keyword
argument_list|(
name|utx
argument_list|)
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|tx
operator|=
name|vtx
expr_stmt|;
block|}
else|else
block|{
name|ytu_heading
argument_list|(
operator|&
name|uname
argument_list|,
operator|&
name|adic
argument_list|,
name|ceol
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|utype
operator|=
name|adic
operator|==
name|Zer
condition|?
name|FZR
else|:
name|adic
operator|==
name|Mon
condition|?
name|FMN
else|:
name|FDY
expr_stmt|;
block|}
name|xeq
operator|=
name|No
expr_stmt|;
name|sharelist
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|unicomm_suite
argument_list|()
expr_stmt|;
name|Mark_unit_end
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|reftab
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|ref_suite
argument_list|()
expr_stmt|;
name|lux
operator|=
name|tx
operator|+
literal|1
expr_stmt|;
name|adjust_unit
argument_list|(
operator|&
name|fux
argument_list|,
operator|&
name|lux
argument_list|,
operator|&
name|reftab
argument_list|)
expr_stmt|;
name|u
operator|=
name|hu
condition|?
name|mk_how
argument_list|(
name|fux
argument_list|,
name|lux
argument_list|,
name|reftab
argument_list|,
name|filed
argument_list|)
else|:
name|yu
condition|?
name|mk_fun
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
name|adic
argument_list|,
name|Use
argument_list|,
name|fux
argument_list|,
name|lux
argument_list|,
name|reftab
argument_list|,
name|filed
argument_list|)
else|:
name|mk_prd
argument_list|(
name|adic
argument_list|,
name|Use
argument_list|,
name|fux
argument_list|,
name|lux
argument_list|,
name|reftab
argument_list|,
name|filed
argument_list|)
expr_stmt|;
name|def_unit
argument_list|(
name|u
argument_list|,
name|uname
argument_list|,
name|utype
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|sharelist
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|formlist
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|xeq
operator|=
name|xeq0
expr_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"no HOW'TO, YIELD or TEST where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|ytu_heading
parameter_list|(
name|name
parameter_list|,
name|adic
parameter_list|,
name|wtx
parameter_list|,
name|form
parameter_list|)
name|value
modifier|*
name|name
decl_stmt|;
name|literal
modifier|*
name|adic
decl_stmt|;
name|txptr
name|wtx
decl_stmt|;
name|bool
name|form
decl_stmt|;
block|{
comment|/* xeq == No */
name|intlet
name|ad
init|=
literal|0
decl_stmt|;
name|value
name|t1
init|=
name|Vnil
decl_stmt|,
name|t2
init|=
name|Vnil
decl_stmt|,
name|t3
init|=
name|Vnil
decl_stmt|;
name|forming
operator|=
name|form
expr_stmt|;
comment|/*should be a parameter to fopnd()*/
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Montormark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
name|parerr
argument_list|(
literal|"user defined functions or predicates must be tags"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
operator|*
name|name
operator|=
name|t1
operator|=
name|tag
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|fopnd
argument_list|(
name|wtx
argument_list|)
operator|==
name|Vnil
condition|)
comment|/* ignore */
empty_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"something unexpected instead of formal formula"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|':'
condition|)
goto|goto
name|postff
goto|;
if|if
condition|(
name|Dyatormark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
name|parerr
argument_list|(
literal|"user defined functions or predicates must be tags"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|t2
operator|=
name|tag
argument_list|()
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|Vnil
condition|)
operator|*
name|name
operator|=
name|t2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|t1
operator|==
name|Vnil
condition|)
name|parerr
argument_list|(
literal|"no function name where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fopnd
argument_list|(
name|wtx
argument_list|)
operator|==
name|Vnil
condition|)
comment|/* ignore */
empty_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"no function name or formal operand where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ad
operator|=
literal|1
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|t1
operator|==
name|Vnil
condition|)
name|nothing
argument_list|(
name|tx
argument_list|,
literal|"second formal operand"
argument_list|)
expr_stmt|;
goto|goto
name|postff
goto|;
block|}
if|if
condition|(
name|t2
operator|==
name|Vnil
condition|)
name|parerr
argument_list|(
literal|"something unexpected following monadic formal formula"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|t2
expr_stmt|;
if|if
condition|(
name|forming
operator|&&
name|t1
operator|!=
name|Vnil
condition|)
name|insert
argument_list|(
name|t1
argument_list|,
operator|&
name|formlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|t3
operator|=
name|tag
argument_list|()
expr_stmt|;
if|if
condition|(
name|forming
condition|)
name|insert
argument_list|(
name|t3
argument_list|,
operator|&
name|formlist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|fopnd
argument_list|(
name|wtx
argument_list|)
operator|==
name|Vnil
condition|)
comment|/* ignore */
empty_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"no formal operand where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ad
operator|=
literal|2
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|':'
condition|)
name|parerr
argument_list|(
literal|"something unexpected following dyadic formal formula"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|postff
label|:
if|if
condition|(
name|t1
operator|!=
name|Vnil
operator|&&
name|t1
operator|!=
operator|*
name|name
condition|)
name|release
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|!=
name|Vnil
operator|&&
name|t2
operator|!=
operator|*
name|name
condition|)
name|release
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3
operator|!=
name|Vnil
condition|)
name|release
argument_list|(
name|t3
argument_list|)
expr_stmt|;
operator|*
name|adic
operator|=
name|ad
operator|==
literal|0
condition|?
name|Zer
else|:
name|ad
operator|==
literal|1
condition|?
name|Mon
else|:
name|Dya
expr_stmt|;
name|tx
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|value
name|mk_formal
parameter_list|(
name|ftx
parameter_list|)
name|txptr
name|ftx
decl_stmt|;
block|{
comment|/* Move */
name|value
name|f
init|=
name|grab_for
argument_list|()
decl_stmt|;
name|formal
modifier|*
name|fp
init|=
name|Formal
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|sv_context
argument_list|(
operator|&
operator|(
name|fp
operator|->
name|con
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ftx
operator|=
name|ftx
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|udc
parameter_list|()
block|{
name|value
name|un
decl_stmt|,
modifier|*
name|aa
decl_stmt|;
name|context
name|ic
decl_stmt|,
name|hc
decl_stmt|;
name|envchain
name|nw_envchain
decl_stmt|;
name|txptr
name|tx0
init|=
name|tx
decl_stmt|,
name|uux
decl_stmt|,
name|vux
decl_stmt|,
name|wux
decl_stmt|;
name|bool
name|formals
init|=
name|No
decl_stmt|;
if|if
condition|(
operator|!
name|Cap
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
operator|!
name|xeq
condition|)
block|{
name|tx
operator|=
name|ceol
expr_stmt|;
if|if
condition|(
name|skipping
condition|)
name|parerr
argument_list|(
literal|"X"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* to prevent skipping= No; */
return|return
name|Yes
return|;
block|}
name|un
operator|=
name|keyword
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"udc^ called"
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_unit
argument_list|(
name|un
argument_list|,
name|FHW
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tx0
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
operator|!
name|Is_howto
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"no howto associated with keyword"
argument_list|)
expr_stmt|;
name|curnv
operator|=
operator|&
name|nw_envchain
expr_stmt|;
name|curnv
operator|->
name|tab
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|curnv
operator|->
name|inv_env
operator|=
name|Enil
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|resexp
operator|=
name|Voi
expr_stmt|;
name|uname
operator|=
name|un
expr_stmt|;
name|utype
operator|=
name|FHW
expr_stmt|;
name|cur_ilev
operator|=
literal|0
expr_stmt|;
name|lino
operator|=
literal|1
expr_stmt|;
name|tx
operator|=
operator|(
name|How_to
argument_list|(
operator|*
name|aa
argument_list|)
operator|)
operator|->
name|fux
expr_stmt|;
name|terminated
operator|=
name|No
expr_stmt|;
name|debug
argument_list|(
literal|"ready to howto"
argument_list|)
expr_stmt|;
name|findceol
argument_list|()
expr_stmt|;
name|wux
operator|=
name|ceol
expr_stmt|;
name|req
argument_list|(
literal|":"
argument_list|,
name|wux
argument_list|,
operator|&
name|uux
argument_list|,
operator|&
name|vux
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atkw
argument_list|(
name|HOW_TO
argument_list|)
operator|||
operator|(
name|compare
argument_list|(
name|uname
operator|=
name|keyword
argument_list|(
name|uux
argument_list|)
argument_list|,
name|un
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|syserr
argument_list|(
literal|"out of phase in udc"
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|<
name|uux
condition|)
block|{
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|,
name|fux
decl_stmt|,
name|tux
decl_stmt|;
name|value
name|fp
decl_stmt|,
name|ap
decl_stmt|,
name|kw
decl_stmt|;
name|kw
operator|=
name|findkw
argument_list|(
name|uux
argument_list|,
operator|&
name|fux
argument_list|,
operator|&
name|tux
argument_list|)
expr_stmt|;
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
name|fp
operator|=
name|bastarg
argument_list|(
name|fux
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tx
operator|<
name|fux
condition|)
block|{
name|release
argument_list|(
name|kw
argument_list|)
expr_stmt|;
name|parerr
argument_list|(
literal|"no formal parameter where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|Vnil
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|hc
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|fux
operator|==
name|uux
condition|)
name|ftx
operator|=
name|ttx
operator|=
name|ceol
expr_stmt|;
else|else
name|reqkw
argument_list|(
name|strval
argument_list|(
name|kw
argument_list|)
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
comment|/*dangerous use of strval*/
name|release
argument_list|(
name|kw
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|Vnil
condition|)
block|{
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|nothing
argument_list|(
name|ftx
argument_list|,
literal|"actual parameter"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|mk_formal
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|formals
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|<
name|ftx
condition|)
name|parerr
argument_list|(
literal|"actual parameter without formal"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|tx
operator|=
name|ttx
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|hc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|Vnil
condition|)
block|{
name|put
argument_list|(
name|ap
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|tx
operator|=
name|tux
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|tx
operator|=
name|vux
expr_stmt|;
name|add_reftab
argument_list|(
operator|(
name|How_to
argument_list|(
operator|*
name|aa
argument_list|)
operator|)
operator|->
name|reftab
argument_list|)
expr_stmt|;
if|if
condition|(
name|formals
condition|)
name|curnv
operator|->
name|inv_env
operator|=
name|ic
operator|.
name|curnv
expr_stmt|;
name|unicomm_suite
argument_list|()
expr_stmt|;
name|terminated
operator|=
name|No
expr_stmt|;
name|release
argument_list|(
name|curnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|eva_formal
parameter_list|(
name|f
parameter_list|)
name|value
name|f
decl_stmt|;
block|{
name|value
name|v
decl_stmt|;
name|formal
modifier|*
name|ff
init|=
name|Formal
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|context
name|cc
decl_stmt|;
if|if
condition|(
operator|!
name|Is_formal
argument_list|(
name|f
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"eva_formal has wrong argument"
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|!=
name|In_formal
condition|)
name|how_context
operator|=
name|cc
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|ff
operator|->
name|con
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|In_formal
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|ff
operator|->
name|ftx
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Visible
name|loc
name|loc_formal
parameter_list|(
name|f
parameter_list|)
name|value
name|f
decl_stmt|;
block|{
name|loc
name|l
decl_stmt|;
name|formal
modifier|*
name|ff
init|=
name|Formal
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|context
name|cc
decl_stmt|;
if|if
condition|(
operator|!
name|Is_formal
argument_list|(
name|f
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"loc_formal has wrong argument"
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|!=
name|In_formal
condition|)
name|how_context
operator|=
name|cc
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|ff
operator|->
name|con
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|In_formal
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ff
operator|->
name|ftx
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|ref_com
parameter_list|()
block|{
comment|/* if !xeq, ref_com always returns Yes unless skipping */
name|value
name|rn
decl_stmt|,
modifier|*
name|aa
decl_stmt|,
name|rname
decl_stmt|;
name|context
name|ic
decl_stmt|;
name|txptr
name|tx0
init|=
name|tx
decl_stmt|,
name|wux
decl_stmt|;
if|if
condition|(
operator|!
name|Cap
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
return|return
name|No
return|;
name|debug
argument_list|(
literal|"ref_com^ called"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xeq
condition|)
block|{
name|tx
operator|=
name|ceol
expr_stmt|;
if|if
condition|(
name|skipping
condition|)
name|parerr
argument_list|(
literal|"X"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* to prevent skipping= No; */
return|return
name|Yes
return|;
block|}
name|rn
operator|=
name|keyword
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|aa
operator|=
name|lookup
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|Pnil
condition|)
block|{
name|release
argument_list|(
name|rn
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tx0
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
operator|!
name|Is_refinement
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"no refinement associated with keyword"
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|ceol
argument_list|,
literal|"refined-command"
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|resexp
operator|=
name|Voi
expr_stmt|;
name|cur_ilev
operator|=
literal|0
expr_stmt|;
name|lino
operator|=
operator|(
name|Refinement
argument_list|(
operator|*
name|aa
argument_list|)
operator|)
operator|->
name|rlino
expr_stmt|;
name|tx
operator|=
operator|(
name|Refinement
argument_list|(
operator|*
name|aa
argument_list|)
operator|)
operator|->
name|rp
expr_stmt|;
name|terminated
operator|=
name|No
expr_stmt|;
name|debug
argument_list|(
literal|"ready to execute refinement"
argument_list|)
expr_stmt|;
name|findceol
argument_list|()
expr_stmt|;
name|wux
operator|=
name|ceol
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|rname
operator|=
name|keyword
argument_list|(
name|wux
argument_list|)
argument_list|,
name|rn
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"out of phase in ref_com"
argument_list|)
expr_stmt|;
name|thought
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
name|terminated
operator|=
name|No
expr_stmt|;
name|release
argument_list|(
name|rn
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|udfpr
parameter_list|(
name|nd1
parameter_list|,
name|fpr
parameter_list|,
name|nd2
parameter_list|,
name|re
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|nd2
decl_stmt|;
name|funprd
modifier|*
name|fpr
decl_stmt|;
name|literal
name|re
decl_stmt|;
block|{
name|context
name|ic
decl_stmt|;
name|envchain
name|nw_envchain
decl_stmt|;
name|value
name|f
decl_stmt|;
name|txptr
name|uux
decl_stmt|,
name|vux
decl_stmt|,
name|wux
decl_stmt|;
name|debug
argument_list|(
literal|"udfpr^ called"
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
name|curnv
operator|=
operator|&
name|nw_envchain
expr_stmt|;
name|curnv
operator|->
name|tab
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|curnv
operator|->
name|inv_env
operator|=
name|Enil
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|resexp
operator|=
name|re
expr_stmt|;
name|uname
operator|=
name|aster
expr_stmt|;
name|cur_ilev
operator|=
literal|0
expr_stmt|;
name|lino
operator|=
literal|1
expr_stmt|;
name|tx
operator|=
name|fpr
operator|->
name|fux
expr_stmt|;
name|resval
operator|=
name|Vnil
expr_stmt|;
name|resout
operator|=
name|Und
expr_stmt|;
name|terminated
operator|=
name|No
expr_stmt|;
name|debug
argument_list|(
literal|"ready to Yield/Test"
argument_list|)
expr_stmt|;
name|findceol
argument_list|()
expr_stmt|;
name|wux
operator|=
name|ceol
expr_stmt|;
name|req
argument_list|(
literal|":"
argument_list|,
name|wux
argument_list|,
operator|&
name|uux
argument_list|,
operator|&
name|vux
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atkw
argument_list|(
name|YIELD
argument_list|)
operator|&&
operator|!
name|atkw
argument_list|(
name|TEST
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"out of phase in udfpr"
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fpr
operator|->
name|adic
condition|)
block|{
case|case
name|Zer
case|:
name|uname
operator|=
name|tag
argument_list|()
expr_stmt|;
name|utype
operator|=
name|FZR
expr_stmt|;
break|break;
case|case
name|Mon
case|:
name|uname
operator|=
name|tag
argument_list|()
expr_stmt|;
name|utype
operator|=
name|FMN
expr_stmt|;
name|put
argument_list|(
name|nd2
argument_list|,
name|f
operator|=
name|fopnd
argument_list|(
name|uux
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
name|Dya
case|:
name|put
argument_list|(
name|nd1
argument_list|,
name|f
operator|=
name|fopnd
argument_list|(
name|uux
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|uname
operator|=
name|tag
argument_list|()
expr_stmt|;
name|utype
operator|=
name|FDY
expr_stmt|;
name|put
argument_list|(
name|nd2
argument_list|,
name|f
operator|=
name|fopnd
argument_list|(
name|uux
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
name|thought
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|tx
operator|=
name|vux
expr_stmt|;
name|add_reftab
argument_list|(
name|fpr
operator|->
name|reftab
argument_list|)
expr_stmt|;
name|unicomm_suite
argument_list|()
expr_stmt|;
name|terminated
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
if|if
condition|(
name|re
operator|==
name|Ret
operator|&&
name|resval
operator|==
name|Vnil
condition|)
name|error
argument_list|(
literal|"command-suite of YIELD-unit returns no value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|Rep
operator|&&
name|resout
operator|==
name|Und
condition|)
name|error
argument_list|(
literal|"command-suite of TEST-unit reports no outcome"
argument_list|)
expr_stmt|;
block|}
name|terminated
operator|=
name|No
expr_stmt|;
name|release
argument_list|(
name|curnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NET
value|8
end_define

begin_function
name|Visible
name|Procedure
name|ref_et
parameter_list|(
name|rfv
parameter_list|,
name|re
parameter_list|)
name|value
name|rfv
decl_stmt|;
name|literal
name|re
decl_stmt|;
block|{
name|context
name|ic
decl_stmt|;
name|value
name|bndtglist
decl_stmt|,
name|rname
decl_stmt|;
name|env
name|ee
decl_stmt|;
name|bool
name|prmnv_saved
init|=
name|No
decl_stmt|;
name|envtab
name|svperm_envtab
init|=
name|Vnil
decl_stmt|,
name|et0
decl_stmt|,
name|envtabs
index|[
name|NET
index|]
decl_stmt|,
modifier|*
name|et
decl_stmt|,
modifier|*
name|etp
decl_stmt|;
name|intlet
name|etl
decl_stmt|;
name|txptr
name|uux
decl_stmt|,
name|vux
decl_stmt|,
name|wux
decl_stmt|;
name|debug
argument_list|(
literal|"ref_et^ called"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_refinement
argument_list|(
name|rfv
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ref_et called with non-refinement"
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
name|ee
operator|=
name|curnv
expr_stmt|;
name|etl
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ee
operator|!=
name|Enil
condition|)
block|{
if|if
condition|(
name|ee
operator|==
name|prmnv
condition|)
break|break;
name|etl
operator|++
expr_stmt|;
name|ee
operator|=
name|ee
operator|->
name|inv_env
expr_stmt|;
block|}
if|if
condition|(
name|etl
operator|<=
name|NET
condition|)
name|et
operator|=
name|envtabs
expr_stmt|;
else|else
name|et
operator|=
operator|(
name|envtab
operator|*
operator|)
name|getmem
argument_list|(
operator|(
name|unsigned
operator|)
name|etl
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|ee
operator|=
name|curnv
expr_stmt|;
name|etp
operator|=
name|et
expr_stmt|;
while|while
condition|(
name|ee
operator|!=
name|Enil
condition|)
block|{
if|if
condition|(
name|ee
operator|==
name|prmnv
condition|)
block|{
if|if
condition|(
name|prmnvtab
operator|==
name|Vnil
condition|)
block|{
comment|/* the original permanent environment */
name|prmnvtab
operator|=
name|prmnv
operator|->
name|tab
expr_stmt|;
name|prmnv
operator|->
name|tab
operator|=
name|copy
argument_list|(
name|prmnvtab
argument_list|)
expr_stmt|;
block|}
else|else
name|svperm_envtab
operator|=
name|copy
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|prmnv_saved
operator|=
name|Yes
expr_stmt|;
break|break;
block|}
operator|*
name|etp
operator|++
operator|=
name|copy
argument_list|(
name|ee
operator|->
name|tab
argument_list|)
expr_stmt|;
name|ee
operator|=
name|ee
operator|->
name|inv_env
expr_stmt|;
block|}
if|if
condition|(
name|resexp
operator|==
name|Voi
operator|&&
operator|!
name|prmnv_saved
condition|)
block|{
comment|/* possible access through SHARE */
if|if
condition|(
name|prmnvtab
operator|==
name|Vnil
condition|)
block|{
name|prmnvtab
operator|=
name|prmnv
operator|->
name|tab
expr_stmt|;
name|prmnv
operator|->
name|tab
operator|=
name|copy
argument_list|(
name|prmnvtab
argument_list|)
expr_stmt|;
block|}
else|else
name|svperm_envtab
operator|=
name|copy
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|prmnv_saved
operator|=
name|Yes
expr_stmt|;
block|}
name|bndtglist
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|bndtgs
operator|=
operator|&
name|bndtglist
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|resexp
operator|=
name|re
expr_stmt|;
name|cur_ilev
operator|=
literal|0
expr_stmt|;
name|lino
operator|=
operator|(
name|Refinement
argument_list|(
name|rfv
argument_list|)
operator|)
operator|->
name|rlino
expr_stmt|;
name|tx
operator|=
operator|(
name|Refinement
argument_list|(
name|rfv
argument_list|)
operator|)
operator|->
name|rp
expr_stmt|;
name|resval
operator|=
name|Vnil
expr_stmt|;
name|resout
operator|=
name|Und
expr_stmt|;
name|terminated
operator|=
name|No
expr_stmt|;
name|debug
argument_list|(
literal|"ready to eval/test refinement"
argument_list|)
expr_stmt|;
name|findceol
argument_list|()
expr_stmt|;
name|wux
operator|=
name|ceol
expr_stmt|;
name|req
argument_list|(
literal|":"
argument_list|,
name|wux
argument_list|,
operator|&
name|uux
argument_list|,
operator|&
name|vux
argument_list|)
expr_stmt|;
name|rname
operator|=
name|tag
argument_list|()
expr_stmt|;
name|thought
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
if|if
condition|(
name|re
operator|==
name|Ret
operator|&&
name|resval
operator|==
name|Vnil
condition|)
name|error
argument_list|(
literal|"refinement returns no value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|Rep
operator|&&
name|resout
operator|==
name|Und
condition|)
name|error
argument_list|(
literal|"refinement reports no outcome"
argument_list|)
expr_stmt|;
block|}
name|terminated
operator|=
name|No
expr_stmt|;
name|release
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|ee
operator|=
name|curnv
expr_stmt|;
name|etp
operator|=
name|et
expr_stmt|;
while|while
condition|(
name|ee
operator|!=
name|Enil
condition|)
block|{
if|if
condition|(
name|ee
operator|==
name|prmnv
condition|)
break|break;
if|if
condition|(
name|ee
operator|==
name|curnv
condition|)
name|et0
operator|=
name|ee
operator|->
name|tab
expr_stmt|;
else|else
name|release
argument_list|(
name|ee
operator|->
name|tab
argument_list|)
expr_stmt|;
name|ee
operator|->
name|tab
operator|=
operator|*
name|etp
operator|++
expr_stmt|;
name|ee
operator|=
name|ee
operator|->
name|inv_env
expr_stmt|;
block|}
if|if
condition|(
name|prmnv_saved
condition|)
block|{
name|release
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|svperm_envtab
operator|==
name|Vnil
condition|)
block|{
name|prmnv
operator|->
name|tab
operator|=
name|prmnvtab
expr_stmt|;
name|prmnvtab
operator|=
name|Vnil
expr_stmt|;
block|}
else|else
name|prmnv
operator|->
name|tab
operator|=
name|svperm_envtab
expr_stmt|;
block|}
name|set_context
argument_list|(
operator|&
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|curnv
operator|!=
name|prmnv
condition|)
block|{
if|if
condition|(
name|re
operator|==
name|Rep
condition|)
name|extbnd_tags
argument_list|(
name|bndtglist
argument_list|,
operator|&
operator|(
name|curnv
operator|->
name|tab
operator|)
argument_list|,
name|et0
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|et0
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|bndtglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|etl
operator|>
name|NET
condition|)
name|freemem
argument_list|(
operator|(
name|ptr
operator|)
name|et
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|loc
name|fopnd
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|txptr
name|ttx
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|>=
name|q
condition|)
name|syserr
argument_list|(
literal|"fopnd called when it should not be"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|ttx
operator|=
name|tx
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|Tagmark
argument_list|(
name|Char
argument_list|(
name|ttx
argument_list|)
argument_list|)
condition|)
name|ttx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|txptr
name|tx0
init|=
name|tx
operator|++
decl_stmt|,
name|ftx
decl_stmt|;
name|req
argument_list|(
literal|")"
argument_list|,
name|q
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tx0
expr_stmt|;
block|}
else|else
name|syserr
argument_list|(
literal|"fopnd does not see formal operand"
argument_list|)
expr_stmt|;
return|return
name|basfop
argument_list|(
name|ttx
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|loc
name|fop
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|value
name|c
init|=
name|Vnil
decl_stmt|;
name|loc
name|l
decl_stmt|;
name|txptr
name|i
decl_stmt|,
name|j
decl_stmt|;
name|intlet
name|len
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
literal|1
operator|+
name|count
argument_list|(
literal|","
argument_list|,
name|q
argument_list|)
operator|)
operator|==
literal|1
condition|)
return|return
name|basfop
argument_list|(
name|q
argument_list|)
return|;
if|if
condition|(
name|xeq
condition|)
name|c
operator|=
name|mk_compound
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|k_Overfields
block|{
if|if
condition|(
operator|!
name|Lastfield
argument_list|(
name|k
argument_list|)
condition|)
name|req
argument_list|(
literal|","
argument_list|,
name|q
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|q
expr_stmt|;
name|l
operator|=
name|basfop
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|put_in_field
argument_list|(
name|l
argument_list|,
operator|&
name|c
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Lastfield
argument_list|(
name|k
argument_list|)
condition|)
name|tx
operator|=
name|j
expr_stmt|;
block|}
return|return
operator|(
name|loc
operator|)
name|c
return|;
block|}
end_function

begin_function
name|Hidden
name|loc
name|basfop
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|loc
name|l
init|=
name|Vnil
decl_stmt|;
name|txptr
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|nothing
argument_list|(
name|q
argument_list|,
literal|"formal operand"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|tx
operator|++
expr_stmt|;
name|req
argument_list|(
literal|")"
argument_list|,
name|q
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|l
operator|=
name|fop
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tx
operator|=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|value
name|t
init|=
name|tag
argument_list|()
decl_stmt|;
if|if
condition|(
name|forming
operator|&&
operator|!
name|xeq
condition|)
name|insert
argument_list|(
name|t
argument_list|,
operator|&
name|formlist
argument_list|)
expr_stmt|;
else|else
name|l
operator|=
name|local_loc
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"no formal operand where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|unicomm_suite
parameter_list|()
block|{
if|if
condition|(
name|ateol
argument_list|()
condition|)
block|{
while|while
condition|(
name|ilev
argument_list|(
name|Yes
argument_list|)
operator|>
literal|0
operator|&&
name|atkw
argument_list|(
name|SHARE
argument_list|)
condition|)
block|{
name|findceol
argument_list|()
expr_stmt|;
name|share
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|To_eol
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|veli
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur_ilev
operator|>
literal|0
condition|)
block|{
name|cur_ilev
operator|=
literal|0
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|command
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|share
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|intlet
name|n
decl_stmt|,
name|k
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
operator|+
name|count
argument_list|(
literal|","
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n
condition|;
name|k
operator|++
control|)
block|{
name|txptr
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|k
operator|<
name|n
operator|-
literal|1
condition|)
name|req
argument_list|(
literal|","
argument_list|,
name|q
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|q
expr_stmt|;
name|sharebas
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|n
operator|-
literal|1
condition|)
name|need
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|upto
argument_list|(
name|q
argument_list|,
literal|"SHAREd identifier"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SH_IN_USE
value|"SHAREd identifier is already in use as formal parameter or operand"
end_define

begin_function
name|Hidden
name|Procedure
name|sharebas
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|nothing
argument_list|(
name|q
argument_list|,
literal|"SHAREd identifier"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|txptr
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tx
operator|++
expr_stmt|;
name|req
argument_list|(
literal|")"
argument_list|,
name|q
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|share
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tx
operator|=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|value
name|t
init|=
name|tag
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xeq
condition|)
block|{
if|if
condition|(
name|in
argument_list|(
name|t
argument_list|,
name|formlist
argument_list|)
condition|)
name|pprerr
argument_list|(
name|SH_IN_USE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|t
argument_list|,
operator|&
name|sharelist
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resexp
operator|==
name|Voi
condition|)
block|{
comment|/*ie we're in a HOW'TO*/
name|loc
name|l
decl_stmt|;
name|value
modifier|*
name|aa
init|=
name|lookup
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|aa
operator|==
name|Pnil
condition|)
block|{
name|put
argument_list|(
name|global
argument_list|,
name|l
operator|=
name|local_loc
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*we're in a TEST or YIELD*/
name|loc
name|l
init|=
name|global_loc
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|value
name|g
init|=
name|content
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|g
argument_list|,
name|l
operator|=
name|local_loc
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* can this be achieved by scratch-pad copying? */
block|}
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|q
argument_list|,
literal|"SHAREd identifier"
argument_list|)
expr_stmt|;
block|}
else|else
name|parerr
argument_list|(
literal|"no identifier where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|REF_IN_USE
value|"refinement-tag is already in use as formal parameter or operand"
end_define

begin_function
name|Hidden
name|Procedure
name|ref_suite
parameter_list|()
block|{
name|txptr
name|rp
decl_stmt|;
name|intlet
name|rlino
decl_stmt|;
name|value
name|r
decl_stmt|,
name|kt
decl_stmt|,
modifier|*
name|aa
decl_stmt|;
name|rref
label|:
if|if
condition|(
name|ilev
argument_list|(
name|Yes
argument_list|)
operator|>
literal|0
condition|)
name|parerr
argument_list|(
literal|"indentation where not allowed"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|findceol
argument_list|()
expr_stmt|;
if|if
condition|(
name|Cap
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
operator|&&
operator|!
name|atkw
argument_list|(
name|SELECT
argument_list|)
condition|)
block|{
name|kt
operator|=
name|findkw
argument_list|(
name|lcol
argument_list|()
argument_list|,
operator|&
name|rp
argument_list|,
operator|&
name|tx
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|':'
condition|)
block|{
name|release
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|veli
argument_list|()
expr_stmt|;
return|return;
block|}
name|rlino
operator|=
name|lino
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|rp
operator|=
name|tx
expr_stmt|;
while|while
condition|(
name|Tagmark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
name|tx
operator|++
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
literal|':'
condition|)
block|{
name|veli
argument_list|()
expr_stmt|;
return|return;
block|}
name|tx
operator|=
name|rp
expr_stmt|;
name|rlino
operator|=
name|lino
expr_stmt|;
name|kt
operator|=
name|tag
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
argument_list|(
name|kt
argument_list|,
name|formlist
argument_list|)
condition|)
name|pprerr
argument_list|(
name|REF_IN_USE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
argument_list|(
name|kt
argument_list|,
name|sharelist
argument_list|)
condition|)
name|pprerr
argument_list|(
literal|"refinement-tag is already in use as SHAREd identifier"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|veli
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|in_env
argument_list|(
name|reftab
argument_list|,
name|kt
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
name|error
argument_list|(
literal|"redefinition of refinement"
argument_list|)
expr_stmt|;
name|thought
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|r
operator|=
name|mk_ref
argument_list|(
name|rp
argument_list|,
name|rlino
argument_list|)
expr_stmt|;
name|e_replace
argument_list|(
name|r
argument_list|,
operator|&
name|reftab
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Eol
argument_list|(
name|tx
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"comm_suite does not leave tx at Eol"
argument_list|)
expr_stmt|;
name|Mark_unit_end
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|kt
argument_list|)
expr_stmt|;
goto|goto
name|rref
goto|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|add_reftab
parameter_list|(
name|rt
parameter_list|)
name|envtab
name|rt
decl_stmt|;
block|{
name|int
name|k
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|Is_table
argument_list|(
name|rt
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"add_reftab called with non_table"
argument_list|)
expr_stmt|;
name|len
operator|=
name|length
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|e_replace
argument_list|(
operator|*
name|assoc
argument_list|(
name|rt
argument_list|,
name|k
argument_list|)
argument_list|,
operator|&
operator|(
name|curnv
operator|->
name|tab
operator|)
argument_list|,
operator|*
name|key
argument_list|(
name|rt
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|inithow
parameter_list|()
block|{
name|aster
operator|=
name|mk_text
argument_list|(
literal|"***"
argument_list|)
expr_stmt|;
name|global
operator|=
name|grab_glo
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|adjust_unit
parameter_list|(
name|fux
parameter_list|,
name|lux
parameter_list|,
name|reftb
parameter_list|)
name|txptr
modifier|*
name|fux
decl_stmt|,
decl|*
name|lux
decl_stmt|;
end_function

begin_decl_stmt
name|value
modifier|*
name|reftb
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* The text of the unit still resides in the text buffer. 	   It is moved to an allocated area and the text pointers 	   are adjusted accordingly. */
name|txptr
name|tm
decl_stmt|,
name|ta
decl_stmt|;
name|int
name|adj
decl_stmt|,
name|k
decl_stmt|,
name|len
init|=
name|length
argument_list|(
operator|*
name|reftb
argument_list|)
decl_stmt|;
name|ta
operator|=
operator|(
name|txptr
operator|)
name|getmem
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
operator|*
name|lux
operator|-
operator|*
name|fux
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|=
operator|*
name|fux
expr_stmt|;
name|adj
operator|=
name|ta
operator|-
name|tm
expr_stmt|;
while|while
condition|(
name|tm
operator|<=
name|tx
condition|)
operator|*
name|ta
operator|++
operator|=
operator|*
name|tm
operator|++
expr_stmt|;
operator|*
name|fux
operator|+=
name|adj
expr_stmt|;
operator|*
name|lux
operator|+=
name|adj
expr_stmt|;
name|k_Over_len
block|{
name|Refinement
argument_list|(
operator|*
name|assoc
argument_list|(
operator|*
name|reftb
argument_list|,
name|k
argument_list|)
argument_list|)
operator|->
name|rp
operator|+=
name|adj
expr_stmt|;
comment|/*Change*/
block|}
block|}
end_block

end_unit

