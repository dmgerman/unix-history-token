begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3fil.c,v 1.4 85/08/27 10:56:00 timo Exp $ */
end_comment

begin_comment
comment|/* Facilities supplied by the file system */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b0fil.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b3scr.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3fil.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_comment
comment|/*This file defines the facilities needed for dealing with files,   apart from C's standard I/O facilities which are used throughout the system.    Units are held on files in a 'workspace', which on Unix is modelled   using directories. The function 'f_uname' converts a unit name into a   unique filename. On Unix this is done by prepending a character to the unit   name to indicate the kind of unit (for how'to ', and for tests and yields< for zeroadic, " for monadic and> for dyadic; these have been chosen as   characters that are not usually used in filenames), and truncating the   name if necessary. If the name does have to be truncated, then it is   hashed to produce a character that is appended to the filename, in an attempt   to produce a unique filename. Even so, it is still possible for different   unit names to produce the same filename, and in the unlikely event of this   happening you get an error message that the unit already exists when you   try to create the clashing unit name.    Filenames are at most SAFEFNLEN characters long, which on standard Unix   systems gives you one spare character for making backups or whatever.    It would be better if the B system effectively maintained its own directories   that mapped units onto files in the real file system, as is done for targets.   With operating systems with a more limited file system (eg even shorter   filenames) this is the only possibility.    The B system can operate in two ways: with the interpreter in command,   and then the editor is called from the interpreter to edit units;   and with the editor in command, when the editor calls the interpreter to   execute commands. The variable 'filtered' is Yes when the editor is in   command, and No otherwise. */
end_comment

begin_define
define|#
directive|define
name|COML
value|60
end_define

begin_decl_stmt
name|Hidden
name|char
name|com_line
index|[
name|COML
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|At_eos
parameter_list|(
name|s
parameter_list|)
value|((s)+= strlen(s))
end_define

begin_function
name|Visible
name|Procedure
name|f_edit
parameter_list|(
name|fname
parameter_list|,
name|errline
parameter_list|)
name|value
name|fname
decl_stmt|;
name|intlet
name|errline
decl_stmt|;
block|{
comment|/*The default editor is called with a first parameter of the line number 	  and a second parameter of the file name*/
name|string
name|cl
init|=
name|com_line
decl_stmt|;
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|unix
if|if
condition|(
name|filtered
condition|)
block|{
name|printf
argument_list|(
literal|"\001: +%d %s\n"
argument_list|,
name|errline
argument_list|,
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
do|do
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
name|still_ok
operator|=
name|Yes
expr_stmt|;
comment|/*ignore interrupts that occurred*/
block|}
else|else
block|{
name|strcpy
argument_list|(
name|cl
argument_list|,
name|editorfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cl
operator|+
name|strlen
argument_list|(
name|cl
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|errline
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|cl
operator|+
name|strlen
argument_list|(
name|cl
argument_list|)
operator|-
literal|1
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
name|app_fname
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com_line
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
else|!unix
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Editing units not yet implemented\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|unix
block|}
end_function

begin_else
else|#
directive|else
else|INTEGRATION
end_else

begin_function
name|Visible
name|Procedure
name|f_edit
parameter_list|(
name|fname
parameter_list|,
name|errline
parameter_list|,
name|prompt
parameter_list|)
name|value
name|fname
decl_stmt|;
name|intlet
name|errline
decl_stmt|;
name|literal
name|prompt
decl_stmt|;
block|{
name|string
name|filename
init|=
name|Str
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|btop
argument_list|(
operator|&
name|filename
argument_list|,
name|errline
argument_list|,
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|still_ok
operator|=
name|Yes
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Visible
name|bool
name|ws_writable
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|tempfile
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|No
return|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|f_copy
parameter_list|(
name|fname
parameter_list|,
name|sname
parameter_list|)
name|value
name|fname
decl_stmt|,
name|sname
decl_stmt|;
block|{
name|string
name|fn
init|=
name|strval
argument_list|(
name|fname
argument_list|)
decl_stmt|,
name|sn
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
name|No
return|;
name|sn
operator|=
name|strval
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|sp
operator|=
name|fopen
argument_list|(
name|sn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ok
operator|=
name|fflush
argument_list|(
name|sp
argument_list|)
operator|!=
name|EOF
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|sp
argument_list|)
operator|==
name|EOF
condition|)
name|ok
operator|=
name|No
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|f_save
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
comment|/* saves the file in a temporary file, whose name is returned */
name|value
name|sname
init|=
name|mk_text
argument_list|(
name|tempfile
argument_list|)
decl_stmt|;
name|VOID
name|f_copy
argument_list|(
name|fname
argument_list|,
name|sname
argument_list|)
decl_stmt|;
return|return
name|sname
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|f_rename
parameter_list|(
name|fname
parameter_list|,
name|nfname
parameter_list|)
name|value
name|fname
decl_stmt|,
name|nfname
decl_stmt|;
block|{
name|char
modifier|*
name|f1
decl_stmt|,
name|f2
index|[
literal|100
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|f2
argument_list|,
name|strval
argument_list|(
name|nfname
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|f2
argument_list|)
expr_stmt|;
name|f1
operator|=
name|strval
argument_list|(
name|fname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RENAME
name|link
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|f1
argument_list|)
expr_stmt|;
else|#
directive|else
name|rename
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* what if it fails??? */
block|}
end_function

begin_function
name|Visible
name|Procedure
name|f_delete
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
name|unlink
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|bool
name|f_exists
parameter_list|(
name|file
parameter_list|)
name|string
name|file
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|No
return|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_function
name|Hidden
name|Procedure
name|app_fname
parameter_list|(
name|ceos
parameter_list|,
name|fname
parameter_list|)
name|string
name|ceos
decl_stmt|;
name|value
name|fname
decl_stmt|;
block|{
name|string
name|fp
init|=
name|strval
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|intlet
name|k
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|fp
argument_list|)
decl_stmt|;
operator|*
name|ceos
operator|++
operator|=
literal|' '
expr_stmt|;
name|k_Over_len
block|{
operator|*
name|ceos
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|ceos
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
comment|/*should really use charval(thof(...))*/
block|}
operator|*
name|ceos
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Visible
name|unsigned
name|f_size
parameter_list|(
name|ifile
parameter_list|)
name|FILE
modifier|*
name|ifile
decl_stmt|;
block|{
name|long
name|size
decl_stmt|,
name|ftell
argument_list|()
decl_stmt|;
name|fseek
argument_list|(
name|ifile
argument_list|,
literal|0l
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|size
operator|=
name|ftell
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|ifile
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* rewind */
return|return
name|size
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|f_close
parameter_list|(
name|ofile
parameter_list|)
name|FILE
modifier|*
name|ofile
decl_stmt|;
block|{
name|bool
name|ok
init|=
name|fflush
argument_list|(
name|ofile
argument_list|)
operator|!=
name|EOF
decl_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|ofile
argument_list|)
operator|==
name|EOF
operator|||
operator|!
name|ok
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3203
argument_list|,
literal|"write error (disk full?)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|bool
name|f_interactive
parameter_list|(
name|ifile
parameter_list|)
name|FILE
modifier|*
name|ifile
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ISATTY
return|return
name|isatty
argument_list|(
name|fileno
argument_list|(
name|ifile
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|fileno
argument_list|(
name|ifile
argument_list|)
operator|<
literal|3
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_define
define|#
directive|define
name|FNMLEN
value|8
end_define

begin_define
define|#
directive|define
name|TYPLEN
value|3
end_define

begin_define
define|#
directive|define
name|SPCLEN
value|1
end_define

begin_define
define|#
directive|define
name|FHW
value|"how"
end_define

begin_define
define|#
directive|define
name|FZR
value|"zer"
end_define

begin_define
define|#
directive|define
name|FMN
value|"mon"
end_define

begin_define
define|#
directive|define
name|FDY
value|"dya"
end_define

begin_define
define|#
directive|define
name|FTR
value|"tar"
end_define

begin_function
name|Hidden
name|string
name|filetype
parameter_list|(
name|type
parameter_list|)
name|literal
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Zer
case|:
return|return
name|FZR
return|;
case|case
name|Mon
case|:
return|return
name|FMN
return|;
case|case
name|Dya
case|:
return|return
name|FDY
return|;
case|case
name|How
case|:
return|return
name|FHW
return|;
case|case
name|Tar
case|:
return|return
name|FTR
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3200
argument_list|,
literal|"filetype()"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|cr_fname
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|fname
parameter_list|,
name|len
parameter_list|,
name|pname
parameter_list|)
name|value
name|name
decl_stmt|;
name|string
name|fname
decl_stmt|,
decl|*
name|pname
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|pname
operator|=
name|fname
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|pname
argument_list|,
name|strval
argument_list|(
name|name
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fname
operator|+
name|len
argument_list|,
literal|".%s"
argument_list|,
name|filetype
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|IBMPC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|unix
end_ifdef

begin_define
define|#
directive|define
name|FNMLEN
value|12
end_define

begin_define
define|#
directive|define
name|TYPLEN
value|1
end_define

begin_define
define|#
directive|define
name|SPCLEN
value|0
end_define

begin_define
define|#
directive|define
name|FHW
value|'\''
end_define

begin_define
define|#
directive|define
name|FZR
value|'<'
end_define

begin_define
define|#
directive|define
name|FMN
value|'"'
end_define

begin_define
define|#
directive|define
name|FDY
value|'>'
end_define

begin_define
define|#
directive|define
name|FTR
value|'='
end_define

begin_function
name|Hidden
name|literal
name|filetype
parameter_list|(
name|type
parameter_list|)
name|literal
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Zer
case|:
return|return
name|FZR
return|;
case|case
name|Mon
case|:
return|return
name|FMN
return|;
case|case
name|Dya
case|:
return|return
name|FDY
return|;
case|case
name|How
case|:
return|return
name|FHW
return|;
case|case
name|Tar
case|:
return|return
name|FTR
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3201
argument_list|,
literal|"filetype()"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|cr_fname
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|fname
parameter_list|,
name|len
parameter_list|,
name|pname
parameter_list|)
name|value
name|name
decl_stmt|;
name|string
name|fname
decl_stmt|,
decl|*
name|pname
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|fname
operator|=
name|filetype
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pname
operator|=
name|fname
operator|+
literal|1
expr_stmt|;
name|strncat
argument_list|(
name|fname
argument_list|,
name|strval
argument_list|(
name|name
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|unix
end_endif

begin_function
name|Hidden
name|bool
name|exists
parameter_list|(
name|name
parameter_list|)
name|string
name|name
decl_stmt|;
block|{
name|value
name|v
init|=
name|mk_text
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|bool
name|exist
init|=
name|in
argument_list|(
name|v
argument_list|,
name|file_names
argument_list|)
decl_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|exist
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|new_fname
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
block|{
name|char
name|fname
index|[
name|FNMLEN
operator|+
name|TYPLEN
operator|+
name|SPCLEN
operator|+
literal|1
index|]
decl_stmt|;
name|intlet
name|len
init|=
name|length
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|string
name|pname
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|FNMLEN
condition|)
name|len
operator|=
name|FNMLEN
expr_stmt|;
name|cr_fname
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|fname
argument_list|,
name|len
argument_list|,
operator|&
name|pname
argument_list|)
expr_stmt|;
while|while
condition|(
name|exists
argument_list|(
name|fname
argument_list|)
condition|)
name|new
argument_list|(
name|pname
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|mk_text
argument_list|(
name|fname
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function
name|Hidden
name|Procedure
name|new
parameter_list|(
name|name
parameter_list|,
name|n
parameter_list|)
name|string
name|name
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3202
argument_list|,
literal|"too many units"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|name
index|[
name|n
index|]
argument_list|)
condition|)
name|name
index|[
name|n
index|]
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
name|n
index|]
operator|!=
literal|'9'
condition|)
operator|++
name|name
index|[
name|n
index|]
expr_stmt|;
else|else
block|{
name|name
index|[
name|n
index|]
operator|=
literal|'0'
expr_stmt|;
name|new
argument_list|(
name|name
argument_list|,
operator|--
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

