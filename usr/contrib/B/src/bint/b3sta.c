begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3sta.c,v 1.4 85/08/22 16:59:30 timo Exp $ */
end_comment

begin_comment
comment|/* Stacks used by the interpreter */
end_comment

begin_comment
comment|/* Scratch-pad copying.     One of the hairiest details of B is scratch-pad copying and its    interaction with formal parameters (to HOW'TO units).    Via formal parameters one can peek and poke into the local environment    of the HOW'TO's in the call chain.  When a parameter is changed from    within an expression- or test-refinement, the scratch-pad copying    prescribes that the whole chain of local environments is restored    to its original state when the refinement exits.  Example:>>> HOW'TO X fp: 	    WRITE fp, ref, fp / 	ref: 	    PUT fp+1 IN fp 	    RETURN fp>>> HOW'TO Y fp: 	    X fp>>> HOW'TO Z: 	    PUT 1 IN t 	    Y t 	    WRITE t>>> Z     1 2 1     1     It is clear that the scratch-pad copying for the call of ref in X    must save the local environments of Y and Z, and restore them when    ref exits.    For similar reasons we must save the permanent environment.    All this also interacts with the practice of 'locating' a target.    All targets eventually refer to (one or more) basic targets.    The location of a basic target is represented as a pair (env, key)    where 'env' is the address of the environment in which the target    resides and 'key' is the target's name (for permanent targets) or    its number (for local targets).  When we consider the PUT fp+1 IN fp    line in unit X above, we can see that the (local) environment    for the location returned by 'fp' is the local environment of Z.    Therefore this whole chain must still be intact.    There can be even trickier cases, where a location is saved for a    long time on the execution stack while the environment it refers to    is subject to scratch-pad copying and restoring; when the location    is finally popped off the stack, it must still refer to the correct    environment.     Another detail to consider is that for the permanent environment,    we need access to the 'real' permanent environment, i.e., its value    before any scratch-pad copying occurred.  (Example:>>> YIELD f: 	    SHARE x 	    PUT x+1 IN x 	    READ t EG 0 	    RETURN t>>> PUT 0 IN x>>> WRITE x, f, x     ??? x     0, 0, 0>>>      Even though at the time the READ is called, x has been given the value    1 temporarily, the value of x used in the evaluation of the input    expression is the original value, 0.)     A final detail to be observed is the passing back of 'bound tags'    when a refined test is called.     The chosen implementation is as follows:    - Environments are saved in a linked list of structures (envchain) with      two fields: tab, the actual environment (a table or compound) and      inv_env, the link to the previous entry in the list.    - The routines newenvchain and popenvchain push and pop such lists.    - There is one list for the permanent environment, whose head is prmnv,      and one list for the current environment, whose head is usually curnv.      The last element of both lists is actually the same, because at the      immediate command level the current environment is the permanent      environment.  When we are evaluating or locating a formal parameter,      'curnv' points somewhere in the middle of its chain, to the local      environment of the caller.      The two lists are manipulated separately:    - Prmnv is pushed (with a copy of itself) for each scratch-pad copy,      and popped whe a scratch-pad is thrown away.    - Curnv is pushed for each unit invocation, with the new local      environment, and popped when the unit exits.    - When a scratch-pad copy is required, the chain headed by curnv      is walked until a local environment is found without HOW'TO formal      parameters, and a compound containing copies of all the local      environments thus found is saved on the general-purpose value stack.      This value is popped off that stack again and the local environments      in the chain are restored when the scratch-pad copy has to be thrown      away.  (Thus we work on the real thing and save and restore a copy      of it, while the DP prescribes that the system work on a copy.      The effect is the same, of course.)    - There is a third list for bound tags whose treatment is left as an      exercise for the reader.    - When a formal parameter is called, the current value of 'curnv' must      be saved somewhere, so that it can be restored later; in this case      it doesn't follow the stack-wise discipline of the chain.    - Finally note thate that when a YIELD unit is called during the      evaluation of a formal parameter, the chain of local environments      "splices" temorarily, because the new local environment is linked      to curnv which is not the end of the chain.  No problem!     All this nonsense can be avoided when a copy-restore parameter mechanism    is used instead: then there are no accesses to other local environments    that the current, except a transfer between two "adjacent" ones at call    and return time.  Maybe ABC will have such a parameter mechanism...  */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3int.h"
end_include

begin_include
include|#
directive|include
file|"b3sem.h"
end_include

begin_include
include|#
directive|include
file|"b3sou.h"
end_include

begin_comment
comment|/* for permkey() and get_pname() */
end_comment

begin_include
include|#
directive|include
file|"b3sta.h"
end_include

begin_comment
comment|/* Fundamental registers: (shared only between this file and b3int.c) */
end_comment

begin_decl_stmt
name|Visible
name|parsetree
name|pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'Program counter', current parsetree node */
end_comment

begin_decl_stmt
name|Visible
name|parsetree
name|next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next parsetree node (changed by jumps) */
end_comment

begin_decl_stmt
name|Visible
name|bool
name|report
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'Condition code register', outcome of last test */
end_comment

begin_decl_stmt
name|Visible
name|bool
name|noloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set while evaluating (as opposed to locating) 			formal parameters of HOW'TOs */
end_comment

begin_decl_stmt
name|Hidden
name|env
name|boundtags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds bound tags chain */
end_comment

begin_comment
comment|/* Value stack: */
end_comment

begin_comment
comment|/* The run-time value stack grows upward, sp points to the next free entry.    Allocated stack space lies between st_base and st_top.    In the current invocation, the stack pointer (sp) must lie between    st_bottom and st_top.    Stack overflow is corrected by growing st_top, underflow is a fatal    error (generated code is wrong). */
end_comment

begin_decl_stmt
name|Hidden
name|value
modifier|*
name|st_base
decl_stmt|,
modifier|*
name|st_bottom
decl_stmt|,
modifier|*
name|st_top
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|int
name|call_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While run() can be called recursively */
end_comment

begin_define
define|#
directive|define
name|EmptyStack
parameter_list|()
value|(sp == st_bottom)
end_define

begin_define
define|#
directive|define
name|BotOffset
parameter_list|()
value|(st_bottom - st_base)
end_define

begin_define
define|#
directive|define
name|SetBotOffset
parameter_list|(
name|n
parameter_list|)
value|(st_bottom= st_base + (n))
end_define

begin_define
define|#
directive|define
name|INCREMENT
value|100
end_define

begin_function
name|Hidden
name|Procedure
name|st_grow
parameter_list|(
name|incr
parameter_list|)
name|int
name|incr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|st_base
condition|)
block|{
comment|/* First time ever */
name|st_bottom
operator|=
name|sp
operator|=
name|st_base
operator|=
operator|(
name|value
operator|*
operator|)
name|getmem
argument_list|(
operator|(
name|unsigned
operator|)
name|incr
operator|*
sizeof|sizeof
argument_list|(
name|value
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|st_top
operator|=
name|st_base
operator|+
name|incr
expr_stmt|;
block|}
else|else
block|{
name|int
name|syze
init|=
operator|(
name|st_top
operator|-
name|st_base
operator|)
operator|+
name|incr
decl_stmt|;
name|int
name|n_bottom
init|=
name|BotOffset
argument_list|()
decl_stmt|;
name|int
name|n_sp
init|=
name|sp
operator|-
name|st_base
decl_stmt|;
name|regetmem
argument_list|(
operator|(
name|ptr
operator|*
operator|)
operator|&
name|st_base
argument_list|,
operator|(
name|unsigned
operator|)
name|syze
operator|*
sizeof|sizeof
argument_list|(
name|value
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|st_base
operator|+
name|n_sp
expr_stmt|;
name|SetBotOffset
argument_list|(
name|n_bottom
argument_list|)
expr_stmt|;
name|st_top
operator|=
name|st_base
operator|+
name|syze
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|pop
parameter_list|()
block|{
if|if
condition|(
name|sp
operator|<=
name|st_bottom
condition|)
block|{
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4100
argument_list|,
literal|"stack underflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
return|return
operator|*
operator|--
name|sp
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|push
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|>=
name|st_top
condition|)
name|st_grow
argument_list|(
name|INCREMENT
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
name|v
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* - - - */
end_comment

begin_comment
comment|/* Various call types, used as index in array: */
end_comment

begin_define
define|#
directive|define
name|C_prmnv
value|0
end_define

begin_define
define|#
directive|define
name|C_immexp
value|1
end_define

begin_define
define|#
directive|define
name|C_immcmd
value|2
end_define

begin_define
define|#
directive|define
name|C_read
value|3
end_define

begin_define
define|#
directive|define
name|C_howto
value|4
end_define

begin_define
define|#
directive|define
name|C_yield
value|5
end_define

begin_define
define|#
directive|define
name|C_test
value|6
end_define

begin_define
define|#
directive|define
name|C_refcmd
value|7
end_define

begin_define
define|#
directive|define
name|C_refexp
value|8
end_define

begin_define
define|#
directive|define
name|C_reftest
value|9
end_define

begin_define
define|#
directive|define
name|C_formal
value|10
end_define

begin_comment
comment|/* What can happen to a thing: */
end_comment

begin_define
define|#
directive|define
name|Old
value|'o'
end_define

begin_define
define|#
directive|define
name|Cpy
value|'c'
end_define

begin_define
define|#
directive|define
name|New
value|'n'
end_define

begin_define
define|#
directive|define
name|Non
value|'-'
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|literal
name|do_cur
decl_stmt|;
name|literal
name|do_prm
decl_stmt|;
name|literal
name|do_bnd
decl_stmt|;
name|literal
name|do_for
decl_stmt|;
name|literal
name|do_cntxt
decl_stmt|;
name|literal
name|do_resexp
decl_stmt|;
block|}
name|dorecord
typedef|;
end_typedef

begin_comment
comment|/* Table encoding what to save/restore for various call/return types: */
end_comment

begin_comment
comment|/* (Special cases are handled elsewhere.) */
end_comment

begin_decl_stmt
name|Hidden
name|dorecord
name|doo
index|[]
init|=
block|{
comment|/*		 cur  prm  bnd  for  cntxt    resexp */
comment|/* prmnv */
block|{
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|In_prmnv
block|,
name|Voi
block|}
block|,
comment|/* imm expr */
block|{
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|In_command
block|,
name|Voi
block|}
block|,
comment|/* imm cmd */
block|{
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|In_command
block|,
name|Voi
block|}
block|,
comment|/* READ EG */
block|{
name|Non
block|,
name|Non
block|,
name|Non
block|,
name|Non
block|,
name|In_read
block|,
name|Voi
block|}
block|,
comment|/* HOW-TO */
block|{
name|New
block|,
name|Old
block|,
name|Non
block|,
name|New
block|,
name|In_unit
block|,
name|Voi
block|}
block|,
comment|/* YIELD */
block|{
name|New
block|,
name|Cpy
block|,
name|Non
block|,
name|Non
block|,
name|In_unit
block|,
name|Ret
block|}
block|,
comment|/* TEST */
block|{
name|New
block|,
name|Cpy
block|,
name|Non
block|,
name|Non
block|,
name|In_unit
block|,
name|Rep
block|}
block|,
comment|/* REF-CMD */
block|{
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|Old
block|,
name|In_unit
block|,
name|Voi
block|}
block|,
comment|/* ref-expr */
block|{
name|Cpy
block|,
name|Cpy
block|,
name|Non
block|,
name|Old
block|,
name|In_unit
block|,
name|Ret
block|}
block|,
comment|/* ref-test */
block|{
name|Cpy
block|,
name|Cpy
block|,
name|New
block|,
name|Old
block|,
name|In_unit
block|,
name|Rep
block|}
block|,
comment|/* formal */
block|{
name|Non
block|,
name|Old
block|,
name|Non
block|,
name|Non
block|,
name|In_formal
block|,
name|Voi
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXTYPE
value|((sizeof doo) / (sizeof doo[0]))
end_define

begin_define
define|#
directive|define
name|Checksum
parameter_list|(
name|type
parameter_list|)
value|(12345 - (type))
end_define

begin_comment
comment|/* Reversible */
end_comment

begin_define
define|#
directive|define
name|Ipush
parameter_list|(
name|n
parameter_list|)
value|push(MkSmallInt(n))
end_define

begin_define
define|#
directive|define
name|Ipop
parameter_list|()
value|SmallIntVal(pop())
end_define

begin_function
name|Hidden
name|env
name|newenv
parameter_list|(
name|tab
parameter_list|,
name|inv_env
parameter_list|)
name|envtab
name|tab
decl_stmt|;
name|env
name|inv_env
decl_stmt|;
block|{
name|env
name|e
init|=
operator|(
name|env
operator|)
name|getmem
argument_list|(
sizeof|sizeof
argument_list|(
name|envchain
argument_list|)
argument_list|)
decl_stmt|;
name|e
operator|->
name|tab
operator|=
name|tab
expr_stmt|;
comment|/* Eats a reference to tab! */
name|e
operator|->
name|inv_env
operator|=
name|inv_env
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|popenv
parameter_list|(
name|pe
parameter_list|)
name|env
modifier|*
name|pe
decl_stmt|;
block|{
name|env
name|e
init|=
operator|*
name|pe
decl_stmt|;
operator|*
name|pe
operator|=
name|e
operator|->
name|inv_env
expr_stmt|;
name|release
argument_list|(
name|e
operator|->
name|tab
argument_list|)
expr_stmt|;
name|freemem
argument_list|(
operator|(
name|ptr
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|Forward
name|value
name|save_curnv_chain
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Hidden
name|Procedure
name|call
parameter_list|(
name|type
parameter_list|,
name|new_pc
parameter_list|)
name|intlet
name|type
decl_stmt|;
name|parsetree
name|new_pc
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>=
name|MAXTYPE
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4101
argument_list|,
literal|"bad call type"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
condition|)
name|tr_call
argument_list|()
expr_stmt|;
comment|/* Push other stacks */
if|if
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_bnd
operator|!=
name|Old
condition|)
block|{
name|boundtags
operator|=
name|newenv
argument_list|(
operator|(
name|doo
index|[
name|type
index|]
operator|.
name|do_bnd
operator|==
name|New
operator|)
condition|?
name|mk_elt
argument_list|()
else|:
name|Vnil
argument_list|,
name|boundtags
argument_list|)
expr_stmt|;
name|bndtgs
operator|=
operator|&
name|boundtags
operator|->
name|tab
expr_stmt|;
block|}
switch|switch
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_cur
condition|)
block|{
case|case
name|New
case|:
name|curnv
operator|=
name|newenv
argument_list|(
name|Vnil
argument_list|,
name|curnv
argument_list|)
expr_stmt|;
break|break;
case|case
name|Cpy
case|:
name|push
argument_list|(
name|save_curnv_chain
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Non
case|:
name|push
argument_list|(
name|mk_int
argument_list|(
call|(
name|double
call|)
argument_list|(
operator|(
name|int
operator|)
name|curnv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PORTABILITY?!?! */
break|break;
block|}
if|if
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_prm
operator|!=
name|Old
condition|)
block|{
name|prmnv
operator|=
name|newenv
argument_list|(
operator|(
name|doo
index|[
name|type
index|]
operator|.
name|do_prm
operator|==
name|Cpy
operator|)
condition|?
name|copy
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
else|:
name|Vnil
argument_list|,
name|prmnv
argument_list|)
expr_stmt|;
block|}
comment|/* Push those things that depend on the call type: */
if|if
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_for
operator|!=
name|Old
condition|)
block|{
comment|/* Formal parameter context and unit name/type */
comment|/* FP removed */
name|push
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|Vnil
expr_stmt|;
block|}
comment|/* Push miscellaneous context info: */
name|push
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|curlino
argument_list|)
expr_stmt|;
name|Ipush
argument_list|(
name|noloc
argument_list|)
expr_stmt|;
name|noloc
operator|=
name|No
expr_stmt|;
name|Ipush
argument_list|(
name|resexp
argument_list|)
expr_stmt|;
name|resexp
operator|=
name|doo
index|[
name|type
index|]
operator|.
name|do_resexp
expr_stmt|;
name|Ipush
argument_list|(
name|cntxt
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|doo
index|[
name|type
index|]
operator|.
name|do_cntxt
expr_stmt|;
name|resval
operator|=
name|Vnil
expr_stmt|;
comment|/* Push vital data: */
name|push
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|Ipush
argument_list|(
name|BotOffset
argument_list|()
argument_list|)
expr_stmt|;
operator|++
name|call_level
expr_stmt|;
name|Ipush
argument_list|(
name|Checksum
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Kind of checksum */
comment|/* Set st_bottom and jump: */
name|st_bottom
operator|=
name|sp
expr_stmt|;
name|next
operator|=
name|new_pc
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|ret
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|value
name|rv
init|=
name|resval
decl_stmt|;
name|literal
name|re
init|=
name|resexp
decl_stmt|;
name|value
name|oldcurnvtab
init|=
name|Vnil
decl_stmt|,
name|oldbtl
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
name|tracing
condition|)
name|tr_ret
argument_list|()
expr_stmt|;
if|if
condition|(
name|cntxt
operator|==
name|In_formal
operator|&&
name|still_ok
condition|)
block|{
name|rv
operator|=
name|pop
argument_list|()
expr_stmt|;
name|re
operator|=
name|Ret
expr_stmt|;
block|}
comment|/* Clear stack: */
while|while
condition|(
operator|!
name|EmptyStack
argument_list|()
condition|)
name|release
argument_list|(
name|pop
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Pop type and hope it's good: */
name|st_bottom
operator|=
name|st_base
expr_stmt|;
comment|/* Trick to allow popping the return info */
name|type
operator|=
name|Checksum
argument_list|(
name|Ipop
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
operator|||
name|type
operator|>=
name|MAXTYPE
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4102
argument_list|,
literal|"stack clobbered"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop vital data: */
name|SetBotOffset
argument_list|(
name|Ipop
argument_list|()
argument_list|)
expr_stmt|;
operator|--
name|call_level
expr_stmt|;
name|next
operator|=
name|pop
argument_list|()
expr_stmt|;
comment|/* Pop context info: */
name|cntxt
operator|=
name|Ipop
argument_list|()
expr_stmt|;
name|resexp
operator|=
name|Ipop
argument_list|()
expr_stmt|;
name|noloc
operator|=
name|Ipop
argument_list|()
expr_stmt|;
name|curlino
operator|=
name|pop
argument_list|()
expr_stmt|;
name|curline
operator|=
name|pop
argument_list|()
expr_stmt|;
comment|/* Variable part: */
if|if
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_for
operator|!=
name|Old
condition|)
block|{
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|pop
argument_list|()
expr_stmt|;
comment|/* FP removed */
block|}
if|if
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_prm
operator|!=
name|Old
condition|)
name|popenv
argument_list|(
operator|&
name|prmnv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_cur
condition|)
block|{
case|case
name|Cpy
case|:
name|oldcurnvtab
operator|=
name|copy
argument_list|(
name|curnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|rest_curnv_chain
argument_list|(
name|pop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|New
case|:
name|oldcurnvtab
operator|=
name|copy
argument_list|(
name|curnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|popenv
argument_list|(
operator|&
name|curnv
argument_list|)
expr_stmt|;
break|break;
case|case
name|Non
case|:
block|{
name|value
name|v
init|=
name|pop
argument_list|()
decl_stmt|;
name|curnv
operator|=
operator|(
name|env
operator|)
name|intval
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|doo
index|[
name|type
index|]
operator|.
name|do_bnd
operator|!=
name|Old
condition|)
block|{
name|oldbtl
operator|=
name|copy
argument_list|(
operator|*
name|bndtgs
argument_list|)
expr_stmt|;
name|popenv
argument_list|(
operator|&
name|boundtags
argument_list|)
expr_stmt|;
name|bndtgs
operator|=
operator|&
name|boundtags
operator|->
name|tab
expr_stmt|;
block|}
comment|/* Fiddle bound tags */
if|if
condition|(
name|oldbtl
operator|!=
name|Vnil
condition|)
block|{
name|extbnd_tags
argument_list|(
name|oldbtl
argument_list|,
name|oldcurnvtab
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|oldbtl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldcurnvtab
operator|!=
name|Vnil
condition|)
name|release
argument_list|(
name|oldcurnvtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_level
operator|==
literal|0
condition|)
name|re_env
argument_list|()
expr_stmt|;
comment|/* Resets bndtgs */
comment|/* Push return value (if any): */
if|if
condition|(
name|re
operator|==
name|Ret
operator|&&
name|still_ok
condition|)
name|push
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* - - - */
end_comment

begin_function
name|Visible
name|Procedure
name|call_formal
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|,
name|targ
parameter_list|)
name|value
name|name
decl_stmt|,
name|number
decl_stmt|;
name|bool
name|targ
decl_stmt|;
block|{
name|value
modifier|*
name|aa
init|=
name|envassoc
argument_list|(
name|curnv
operator|->
name|tab
argument_list|,
name|number
argument_list|)
decl_stmt|;
name|formal
modifier|*
name|ff
init|=
name|Formal
argument_list|(
operator|*
name|aa
argument_list|)
decl_stmt|;
name|literal
name|ct
decl_stmt|;
if|if
condition|(
name|aa
operator|==
name|Pnil
operator|||
operator|!
name|Is_formal
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4103
argument_list|,
literal|"formal gone"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|!=
name|In_formal
condition|)
block|{
name|release
argument_list|(
name|how_context
operator|.
name|uname
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|how_context
argument_list|)
expr_stmt|;
comment|/* for error messages */
block|}
name|call
argument_list|(
name|C_formal
argument_list|,
name|ff
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* The following should be different, but for now... */
name|curnv
operator|=
name|ff
operator|->
name|con
operator|.
name|curnv
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|copy
argument_list|(
name|ff
operator|->
name|con
operator|.
name|uname
argument_list|)
expr_stmt|;
name|curline
operator|=
name|ff
operator|->
name|con
operator|.
name|cur_line
expr_stmt|;
name|curlino
operator|=
name|ff
operator|->
name|con
operator|.
name|cur_lino
expr_stmt|;
name|ct
operator|=
name|cntxt
expr_stmt|;
name|cntxt
operator|=
name|ff
operator|->
name|con
operator|.
name|cntxt
expr_stmt|;
name|release
argument_list|(
name|act_context
operator|.
name|uname
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|act_context
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|ct
expr_stmt|;
comment|/* for error messages */
if|if
condition|(
operator|!
name|targ
condition|)
name|noloc
operator|=
name|Yes
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Thread2
argument_list|(
name|next
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|4104
argument_list|,
literal|"expression used as target"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|call_refinement
parameter_list|(
name|name
parameter_list|,
name|def
parameter_list|,
name|test
parameter_list|)
name|value
name|name
decl_stmt|;
name|parsetree
name|def
decl_stmt|;
name|bool
name|test
decl_stmt|;
block|{
name|call
argument_list|(
name|test
condition|?
name|C_reftest
else|:
name|C_refexp
argument_list|,
operator|*
name|Branch
argument_list|(
name|Refinement
argument_list|(
name|def
argument_list|)
operator|->
name|rp
argument_list|,
name|REF_START
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|YOU_TEST
value|MESS(4105, "You haven't told me how to TEST ")
end_define

begin_define
define|#
directive|define
name|YOU_YIELD
value|MESS(4106, "You haven't told me how to YIELD ")
end_define

begin_function
name|Hidden
name|Procedure
name|udfpr
parameter_list|(
name|nd1
parameter_list|,
name|name
parameter_list|,
name|nd2
parameter_list|,
name|isfunc
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|name
decl_stmt|,
name|nd2
decl_stmt|;
name|bool
name|isfunc
decl_stmt|;
block|{
name|value
modifier|*
name|aa
decl_stmt|;
name|parsetree
name|u
decl_stmt|;
name|int
name|k
decl_stmt|,
name|nlocals
decl_stmt|;
name|funprd
modifier|*
name|fpr
decl_stmt|;
name|int
name|adicity
init|=
name|nd1
condition|?
name|Dya
else|:
name|nd2
condition|?
name|Mon
else|:
name|Zer
decl_stmt|;
if|if
condition|(
operator|!
name|is_unit
argument_list|(
name|name
argument_list|,
name|adicity
argument_list|,
operator|&
name|aa
argument_list|)
operator|||
operator|!
operator|(
name|isfunc
condition|?
name|Is_function
argument_list|(
operator|*
name|aa
argument_list|)
else|:
name|Is_predicate
argument_list|(
operator|*
name|aa
argument_list|)
operator|)
condition|)
block|{
name|error3
argument_list|(
name|isfunc
condition|?
name|YOU_YIELD
else|:
name|YOU_TEST
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|fpr
operator|=
name|Funprd
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fpr
operator|->
name|adic
operator|==
name|Zer
condition|?
name|nd2
operator|==
name|Vnil
else|:
operator|(
name|fpr
operator|->
name|adic
operator|==
name|Mon
operator|)
operator|==
operator|(
name|nd1
operator|==
name|Vnil
operator|)
operator|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4107
argument_list|,
literal|"invoked unit has other adicity than invoker"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpr
operator|->
name|pre
operator|!=
name|Use
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4108
argument_list|,
literal|"udfpr with predefined unit"
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|fpr
operator|->
name|unit
expr_stmt|;
if|if
condition|(
name|fpr
operator|->
name|unparsed
condition|)
name|fix_nodes
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|fpr
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
block|{
name|rem_unit
argument_list|(
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
name|fpr
operator|->
name|unparsed
operator|=
name|No
expr_stmt|;
name|nlocals
operator|=
name|intval
argument_list|(
operator|*
name|Branch
argument_list|(
name|u
argument_list|,
name|FPR_NLOCALS
argument_list|)
argument_list|)
expr_stmt|;
name|call
argument_list|(
name|isfunc
condition|?
name|C_yield
else|:
name|C_test
argument_list|,
name|fpr
operator|->
name|code
argument_list|)
expr_stmt|;
name|curnv
operator|->
name|tab
operator|=
name|mk_compound
argument_list|(
name|nlocals
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nlocals
condition|;
operator|++
name|k
control|)
operator|*
name|Field
argument_list|(
name|curnv
operator|->
name|tab
argument_list|,
name|k
argument_list|)
operator|=
name|Vnil
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|get_pname
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd1
operator|!=
name|Vnil
condition|)
name|push
argument_list|(
name|copy
argument_list|(
name|nd1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd2
operator|!=
name|Vnil
condition|)
name|push
argument_list|(
name|copy
argument_list|(
name|nd2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|formula
parameter_list|(
name|nd1
parameter_list|,
name|name
parameter_list|,
name|nd2
parameter_list|,
name|tor
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|name
decl_stmt|,
name|nd2
decl_stmt|,
name|tor
decl_stmt|;
block|{
if|if
condition|(
name|tor
operator|==
name|Vnil
condition|)
name|udfpr
argument_list|(
name|nd1
argument_list|,
name|name
argument_list|,
name|nd2
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|Is_function
argument_list|(
name|tor
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4109
argument_list|,
literal|"formula called with non-function"
argument_list|)
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|pre_fun
argument_list|(
name|nd1
argument_list|,
name|Funprd
argument_list|(
name|tor
argument_list|)
operator|->
name|pre
argument_list|,
name|nd2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|proposition
parameter_list|(
name|nd1
parameter_list|,
name|name
parameter_list|,
name|nd2
parameter_list|,
name|pred
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|name
decl_stmt|,
name|nd2
decl_stmt|,
name|pred
decl_stmt|;
block|{
if|if
condition|(
name|pred
operator|==
name|Vnil
condition|)
name|udfpr
argument_list|(
name|nd1
argument_list|,
name|name
argument_list|,
name|nd2
argument_list|,
name|No
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|Is_predicate
argument_list|(
name|pred
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4110
argument_list|,
literal|"proposition called with non-predicate"
argument_list|)
argument_list|)
expr_stmt|;
name|report
operator|=
name|pre_prop
argument_list|(
name|nd1
argument_list|,
name|Funprd
argument_list|(
name|pred
argument_list|)
operator|->
name|pre
argument_list|,
name|nd2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|v_mystery
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|)
name|value
name|name
decl_stmt|,
name|number
decl_stmt|;
block|{
name|value
modifier|*
name|aa
decl_stmt|;
name|fun
name|f
decl_stmt|;
name|aa
operator|=
name|envassoc
argument_list|(
name|curnv
operator|->
name|tab
argument_list|,
name|Is_compound
argument_list|(
name|curnv
operator|->
name|tab
argument_list|)
condition|?
name|number
else|:
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|!=
name|Pnil
condition|)
name|push
argument_list|(
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_zerfun
argument_list|(
name|name
argument_list|,
operator|&
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|Funprd
argument_list|(
name|f
argument_list|)
operator|->
name|pre
operator|==
name|Use
condition|)
name|f
operator|=
name|Vnil
expr_stmt|;
name|formula
argument_list|(
name|Vnil
argument_list|,
name|name
argument_list|,
name|Vnil
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|error3
argument_list|(
literal|0
argument_list|,
name|name
argument_list|,
name|MESS
argument_list|(
literal|4111
argument_list|,
literal|" has not yet received a value"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|value
name|mk_formal
parameter_list|(
name|pt
parameter_list|)
name|parsetree
name|pt
decl_stmt|;
block|{
name|value
name|f
init|=
name|grab_for
argument_list|()
decl_stmt|;
name|formal
modifier|*
name|ff
init|=
name|Formal
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|ff
operator|->
name|con
argument_list|)
expr_stmt|;
name|ff
operator|->
name|fp
operator|=
name|pt
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|x_user_command
parameter_list|(
name|name
parameter_list|,
name|actuals
parameter_list|,
name|def
parameter_list|)
name|value
name|name
decl_stmt|;
name|parsetree
name|actuals
decl_stmt|;
name|value
name|def
decl_stmt|;
block|{
name|how
modifier|*
name|h
decl_stmt|;
name|parsetree
name|u
decl_stmt|;
name|value
modifier|*
name|aa
decl_stmt|;
name|value
name|v
decl_stmt|,
name|formals
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|def
operator|!=
name|Vnil
condition|)
block|{
if|if
condition|(
operator|!
name|Is_refinement
argument_list|(
name|def
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4112
argument_list|,
literal|"bad def in x_user_command"
argument_list|)
argument_list|)
expr_stmt|;
name|call
argument_list|(
name|C_refcmd
argument_list|,
operator|*
name|Branch
argument_list|(
name|Refinement
argument_list|(
name|def
argument_list|)
operator|->
name|rp
argument_list|,
name|REF_START
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|is_unit
argument_list|(
name|name
argument_list|,
name|How
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
name|error3
argument_list|(
name|MESS
argument_list|(
literal|4113
argument_list|,
literal|"You haven't told me HOW'TO "
argument_list|)
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|u
operator|=
operator|(
name|h
operator|=
name|How_to
argument_list|(
operator|*
name|aa
argument_list|)
operator|)
operator|->
name|unit
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|unparsed
condition|)
name|fix_nodes
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|h
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
block|{
name|rem_unit
argument_list|(
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
name|h
operator|->
name|unparsed
operator|=
name|No
expr_stmt|;
name|formals
operator|=
operator|*
name|Branch
argument_list|(
name|u
argument_list|,
name|HOW_FORMALS
argument_list|)
expr_stmt|;
name|len
operator|=
name|intval
argument_list|(
operator|*
name|Branch
argument_list|(
name|u
argument_list|,
name|HOW_NLOCALS
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|mk_compound
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|actuals
operator|!=
name|Vnil
operator|&&
name|formals
operator|!=
name|Vnil
condition|)
block|{
comment|/* Save actuals */
if|if
condition|(
operator|*
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_EXPR
argument_list|)
operator|!=
name|Vnil
condition|)
block|{
if|if
condition|(
name|k
operator|>=
name|len
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4114
argument_list|,
literal|"too many actuals"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
operator|++
argument_list|)
operator|=
name|mk_formal
argument_list|(
operator|*
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_START
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|actuals
operator|=
operator|*
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_NEXT
argument_list|)
expr_stmt|;
name|formals
operator|=
operator|*
name|Branch
argument_list|(
name|formals
argument_list|,
name|FML_NEXT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|k
operator|<
name|len
condition|;
operator|++
name|k
control|)
block|{
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
operator|=
name|Vnil
expr_stmt|;
block|}
name|call
argument_list|(
name|C_howto
argument_list|,
name|h
operator|->
name|code
argument_list|)
expr_stmt|;
name|curnv
operator|->
name|tab
operator|=
name|v
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|How
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|endsta
parameter_list|()
block|{
if|if
condition|(
name|st_base
condition|)
block|{
name|freemem
argument_list|(
operator|(
name|ptr
operator|)
name|st_base
argument_list|)
expr_stmt|;
name|st_base
operator|=
name|Pnil
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|value
name|save_curnv_chain
parameter_list|()
block|{
name|value
name|pad
decl_stmt|;
name|value
name|c
decl_stmt|,
name|f
decl_stmt|;
name|formal
modifier|*
name|ff
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|k
decl_stmt|;
comment|/* Count how many */
name|c
operator|=
name|curnv
operator|->
name|tab
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|Is_compound
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|++
name|cnt
expr_stmt|;
name|f
operator|=
operator|*
name|Field
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_formal
argument_list|(
name|f
argument_list|)
condition|)
break|break;
name|ff
operator|=
name|Formal
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|ff
operator|->
name|con
operator|.
name|curnv
operator|->
name|tab
expr_stmt|;
block|}
name|pad
operator|=
name|mk_compound
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
comment|/* Do the copy */
name|c
operator|=
name|curnv
operator|->
name|tab
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|Is_compound
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|*
name|Field
argument_list|(
name|pad
argument_list|,
name|k
argument_list|)
operator|=
name|copy
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|k
operator|>=
name|cnt
condition|)
break|break;
name|f
operator|=
operator|*
name|Field
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_formal
argument_list|(
name|f
argument_list|)
condition|)
break|break;
name|ff
operator|=
name|Formal
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
name|ff
operator|->
name|con
operator|.
name|curnv
operator|->
name|tab
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|!=
name|cnt
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4115
argument_list|,
literal|"save_curnv_chain: phase error"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pad
return|;
block|}
end_function

begin_function
name|Hidden
name|rest_curnv_chain
parameter_list|(
name|pad
parameter_list|)
name|value
name|pad
decl_stmt|;
block|{
name|int
name|k
decl_stmt|,
name|cnt
decl_stmt|;
name|value
name|f
decl_stmt|,
modifier|*
name|c
init|=
operator|&
name|curnv
operator|->
name|tab
decl_stmt|;
name|formal
modifier|*
name|ff
decl_stmt|;
if|if
condition|(
name|pad
operator|==
name|Vnil
operator|||
operator|!
name|Is_compound
argument_list|(
name|pad
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4116
argument_list|,
literal|"rest_curnv_chain: bad pad"
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|Nfields
argument_list|(
name|pad
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|Is_compound
argument_list|(
operator|*
name|c
argument_list|)
condition|)
break|break;
name|release
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|copy
argument_list|(
operator|*
name|Field
argument_list|(
name|pad
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|k
operator|>=
name|cnt
condition|)
break|break;
name|f
operator|=
operator|*
name|Field
argument_list|(
operator|*
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_formal
argument_list|(
name|f
argument_list|)
condition|)
break|break;
name|ff
operator|=
name|Formal
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|ff
operator|->
name|con
operator|.
name|curnv
operator|->
name|tab
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|!=
name|cnt
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4117
argument_list|,
literal|"rest_curnv_chain: phase error"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pad
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

