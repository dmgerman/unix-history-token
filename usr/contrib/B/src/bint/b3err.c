begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3err.c,v 1.4 85/08/22 16:57:50 timo Exp $ */
end_comment

begin_comment
comment|/* B error message handling */
end_comment

begin_comment
comment|/* There are two kinds of errors: 	1) parsing, when the line in error is in a buffer 	2) execution, when the line in error is a parse-tree, and must 	   therefore be reconstructed. */
end_comment

begin_comment
comment|/* All error messages are collected in a file, both to save data space    and to ease translation to other languages.	The English version    of the database can be recreated from the program sources by scanning    for the pattern "MESS(".  This is a macro whose first argument is    the message number and whose second number is the message string;    this macro expands to only the message number which is passed to    the error routines.	The error routines then dig the message from    the error message file, or just print the number if the file can't be    opened.  There is also a way to pass a message that is determined    at runtime. */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b0fil.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3fil.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3scr.h"
end_include

begin_include
include|#
directive|include
file|"b3sig.h"
end_include

begin_include
include|#
directive|include
file|"b3sou.h"
end_include

begin_decl_stmt
name|Visible
name|bool
name|still_ok
decl_stmt|,
name|interrupted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|parsetree
name|curline
init|=
name|Vnil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|value
name|curlino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|context
name|how_context
decl_stmt|,
name|act_context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|errfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first thing a visible routine must do is set this */
end_comment

begin_comment
comment|/* usually by calling line()				 */
end_comment

begin_define
define|#
directive|define
name|Interactive
value|(errfile == stderr)
end_define

begin_comment
comment|/*********************************************************************/
end_comment

begin_comment
comment|/* While we are reading the Messages file, we build an index.    probe[k] contains the first message number found in block k.    blocks are BUFSIZ in size. */
end_comment

begin_define
define|#
directive|define
name|FILESIZE
value|12916
end_define

begin_comment
comment|/* Approximated current size of Messages file */
end_comment

begin_define
define|#
directive|define
name|MAXPROBE
value|(10 + FILESIZE/BUFSIZ)
end_define

begin_comment
comment|/* Allow some growth */
end_comment

begin_decl_stmt
name|Hidden
name|short
name|probe
index|[
name|MAXPROBE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|int
name|nprobes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|FILE
modifier|*
name|messfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|string
name|savedmess
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|int
name|MESSMAKE
parameter_list|(
name|mess
parameter_list|)
name|string
name|mess
decl_stmt|;
block|{
name|savedmess
operator|=
name|mess
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|Visible
name|string
name|getmess
parameter_list|(
name|nr
parameter_list|)
name|int
name|nr
decl_stmt|;
block|{
name|int
name|last
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|bool
name|new
decl_stmt|;
name|int
name|block
decl_stmt|;
name|long
name|ftell
parameter_list|()
function_decl|;
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
block|{
return|return
name|savedmess
return|;
block|}
if|if
condition|(
name|messfp
operator|==
name|NULL
condition|)
name|messfp
operator|=
name|fopen
argument_list|(
name|messfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|messfp
condition|)
block|{
for|for
control|(
name|block
operator|=
name|nprobes
operator|-
literal|1
init|;
name|block
operator|>
literal|0
condition|;
operator|--
name|block
control|)
block|{
if|if
condition|(
name|probe
index|[
name|block
index|]
operator|<=
name|nr
condition|)
break|break;
block|}
name|new
operator|=
name|block
operator|==
name|nprobes
operator|-
literal|1
expr_stmt|;
name|fseek
argument_list|(
name|messfp
argument_list|,
operator|(
name|long
operator|)
name|block
operator|*
name|BUFSIZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|last
operator|<
name|nr
condition|)
block|{
if|if
condition|(
name|new
condition|)
name|block
operator|=
name|ftell
argument_list|(
name|messfp
argument_list|)
operator|/
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|messfp
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|last
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|new
operator|&&
name|block
operator|>=
name|nprobes
operator|&&
name|nprobes
operator|<
name|MAXPROBE
condition|)
block|{
name|probe
index|[
name|block
index|]
operator|=
name|last
expr_stmt|;
name|nprobes
operator|=
name|block
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last
operator|==
name|nr
condition|)
block|{
name|cp
operator|=
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip terminating \n */
name|cp
operator|=
name|buf
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|buf
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
return|return
name|cp
operator|+
literal|1
return|;
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" (error %d) "
argument_list|,
name|nr
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|prmess
parameter_list|(
name|nr
parameter_list|)
name|int
name|nr
decl_stmt|;
block|{
name|errmess
argument_list|(
name|getmess
argument_list|(
name|nr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************/
end_comment

begin_function
name|Hidden
name|Procedure
name|putch
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|errfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|line
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EXT_COMMAND
name|e_done
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|==
name|In_read
condition|)
block|{
if|if
condition|(
name|rd_interactive
condition|)
block|{
name|errfile
operator|=
name|stderr
expr_stmt|;
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
else|else
name|errfile
operator|=
name|stdout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|interactive
condition|)
name|errfile
operator|=
name|stderr
expr_stmt|;
else|else
name|errfile
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
operator|!
name|at_nwl
condition|)
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|errmess
parameter_list|(
name|m
parameter_list|)
name|string
name|m
decl_stmt|;
block|{
name|fputs
argument_list|(
name|m
argument_list|,
name|errfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_function
name|Hidden
name|Procedure
name|core_dump
parameter_list|()
block|{
name|errmess
argument_list|(
literal|"*** Core-dump for inspection purposes: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Hidden
name|Procedure
name|prname
parameter_list|(
name|name
parameter_list|)
name|value
name|name
decl_stmt|;
block|{
if|if
condition|(
name|Is_text
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|still_ok
operator|=
name|Yes
expr_stmt|;
name|writ
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|still_ok
operator|=
name|No
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|Visible
name|value
name|erruname
init|=
name|Vnil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|intlet
name|errlino
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|intlet
name|pr_line
parameter_list|(
name|at
parameter_list|)
name|bool
name|at
decl_stmt|;
block|{
comment|/*prints the line that tx is in, with an arrow pointing to the column 	  that tx is at. 	*/
name|txptr
name|lx
init|=
name|fcol
argument_list|()
decl_stmt|;
name|intlet
name|ap
init|=
operator|-
literal|1
decl_stmt|,
name|p
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|txptr
name|ax
init|=
name|tx
decl_stmt|;
if|if
condition|(
operator|!
name|at
condition|)
do|do
name|ax
operator|--
expr_stmt|;
do|while
condition|(
name|Space
argument_list|(
name|Char
argument_list|(
name|ax
argument_list|)
argument_list|)
condition|)
do|;
while|while
condition|(
operator|!
name|Eol
argument_list|(
name|lx
argument_list|)
operator|&&
name|Char
argument_list|(
name|lx
argument_list|)
operator|!=
name|Eotc
condition|)
block|{
if|if
condition|(
name|lx
operator|==
name|ax
condition|)
name|ap
operator|=
name|p
expr_stmt|;
name|c
operator|=
operator|*
name|lx
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
do|do
block|{
name|putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
operator|++
name|p
operator|)
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|<
literal|0
condition|)
name|ap
operator|=
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ap
operator|+
literal|4
condition|;
name|p
operator|++
control|)
name|putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"^\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|sh_lino
parameter_list|(
name|lino
parameter_list|)
name|intlet
name|lino
decl_stmt|;
block|{
switch|switch
condition|(
name|cntxt
condition|)
block|{
case|case
name|In_command
case|:
case|case
name|In_read
case|:
case|case
name|In_edval
case|:
case|case
name|In_tarval
case|:
case|case
name|In_prmnv
case|:
return|return
name|No
return|;
case|case
name|In_unit
case|:
return|return
name|lino
operator|!=
literal|1
return|;
default|default:
return|return
name|Yes
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|show_line
parameter_list|(
name|in_node
parameter_list|,
name|at
parameter_list|,
name|node
parameter_list|,
name|line_no
parameter_list|)
name|bool
name|in_node
decl_stmt|,
name|at
decl_stmt|;
name|parsetree
name|node
decl_stmt|;
name|int
name|line_no
decl_stmt|;
block|{
if|if
condition|(
name|sh_lino
argument_list|(
name|line_no
argument_list|)
condition|)
name|fprintf
argument_list|(
name|errfile
argument_list|,
literal|" in line %d of your "
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
else|else
name|errmess
argument_list|(
literal|" in your "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cntxt
condition|)
block|{
case|case
name|In_command
case|:
name|errmess
argument_list|(
literal|"command"
argument_list|)
expr_stmt|;
break|break;
case|case
name|In_read
case|:
name|errmess
argument_list|(
literal|"expression to be read"
argument_list|)
expr_stmt|;
break|break;
case|case
name|In_edval
case|:
name|errmess
argument_list|(
literal|"edited value"
argument_list|)
expr_stmt|;
break|break;
case|case
name|In_tarval
case|:
name|errmess
argument_list|(
literal|"target value"
argument_list|)
expr_stmt|;
break|break;
case|case
name|In_unit
case|:
name|errmess
argument_list|(
literal|"unit "
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
if|if
condition|(
name|Is_text
argument_list|(
name|uname
argument_list|)
condition|)
block|{
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|p_name_type
argument_list|(
name|uname
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|prname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|erruname
operator|=
name|copy
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|errlino
operator|=
name|line_no
expr_stmt|;
block|}
else|else
name|erruname
operator|=
name|Vnil
expr_stmt|;
break|break;
case|case
name|In_prmnv
case|:
name|errmess
argument_list|(
literal|"permanent environment"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errmess
argument_list|(
literal|"???\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|errmess
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_node
operator|||
name|node
operator|!=
name|Vnil
condition|)
name|errmess
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_node
condition|)
name|display
argument_list|(
name|errfile
argument_list|,
name|node
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
else|else
name|pr_line
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|unit_file
parameter_list|()
block|{
name|value
modifier|*
name|aa
decl_stmt|;
return|return
name|cntxt
operator|==
name|In_unit
operator|&&
name|Is_text
argument_list|(
name|uname
argument_list|)
operator|&&
name|p_exists
argument_list|(
name|uname
argument_list|,
operator|&
name|aa
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|show_where
parameter_list|(
name|in_node
parameter_list|,
name|at
parameter_list|,
name|node
parameter_list|)
name|bool
name|in_node
decl_stmt|,
name|at
decl_stmt|;
name|parsetree
name|node
decl_stmt|;
block|{
name|int
name|line_no
init|=
name|in_node
condition|?
name|intval
argument_list|(
name|curlino
argument_list|)
else|:
name|lino
decl_stmt|;
if|if
condition|(
name|cntxt
operator|==
name|In_formal
condition|)
block|{
comment|/*can only happen when in_node*/
name|context
name|cc
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|how_context
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|show_line
argument_list|(
name|Yes
argument_list|,
name|Yes
argument_list|,
name|curline
argument_list|,
name|intval
argument_list|(
name|curlino
argument_list|)
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"*** originating"
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|act_context
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|show_line
argument_list|(
name|Yes
argument_list|,
name|Yes
argument_list|,
name|curline
argument_list|,
name|intval
argument_list|(
name|curlino
argument_list|)
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|cc
argument_list|)
expr_stmt|;
block|}
else|else
name|show_line
argument_list|(
name|in_node
argument_list|,
name|at
argument_list|,
name|node
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Interactive
operator|&&
operator|!
name|unit_file
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|errfile
argument_list|,
literal|"*** (detected after reading %d input line%s of your input file "
argument_list|,
name|f_lino
argument_list|,
name|f_lino
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iname
operator|==
name|Vnil
condition|)
name|errmess
argument_list|(
literal|"standard input"
argument_list|)
expr_stmt|;
else|else
name|prname
argument_list|(
name|iname
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|fatal
parameter_list|(
name|m
parameter_list|,
name|in_node
parameter_list|)
name|int
name|m
decl_stmt|;
name|bool
name|in_node
decl_stmt|;
block|{
name|line
argument_list|()
expr_stmt|;
name|errmess
argument_list|(
literal|"*** Sorry, B system malfunction"
argument_list|)
expr_stmt|;
name|show_where
argument_list|(
name|in_node
argument_list|,
name|Yes
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"*** The problem is: "
argument_list|)
expr_stmt|;
name|prmess
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"*** Please save pertinent data for inspection by B guru\n"
argument_list|)
expr_stmt|;
name|bye
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|syserr
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
name|fatal
argument_list|(
name|m
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EXT_COMMAND
end_ifdef

begin_function
name|Visible
name|Procedure
name|psyserr
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
name|fatal
argument_list|(
name|m
argument_list|,
name|No
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Visible
name|Procedure
name|memexh
parameter_list|()
block|{
name|line
argument_list|()
expr_stmt|;
name|errmess
argument_list|(
literal|"*** Sorry, memory exhausted"
argument_list|)
expr_stmt|;
comment|/* show_where(Yes, Yes); don't know if in node or not; to fix */
name|errmess
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"*** Get your boss to buy a larger computer\n"
argument_list|)
expr_stmt|;
name|bye
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|fix_files
parameter_list|()
block|{
if|if
condition|(
name|ifile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_interactive
argument_list|(
name|stdin
argument_list|)
operator|||
name|filtered
condition|)
block|{
name|interactive
operator|=
name|Yes
expr_stmt|;
name|release
argument_list|(
name|iname
argument_list|)
expr_stmt|;
name|iname
operator|=
name|Vnil
expr_stmt|;
name|ifile
operator|=
name|stdin
expr_stmt|;
name|sv_ifile
operator|=
name|ifile
expr_stmt|;
name|Eof
operator|=
name|No
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|message
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|,
name|v
parameter_list|,
name|m3
parameter_list|,
name|in_node
parameter_list|,
name|at
parameter_list|)
name|string
name|m1
decl_stmt|;
name|int
name|m2
decl_stmt|,
name|m3
decl_stmt|;
name|value
name|v
decl_stmt|;
name|bool
name|in_node
decl_stmt|,
name|at
decl_stmt|;
block|{
name|still_ok
operator|=
name|No
expr_stmt|;
name|line
argument_list|()
expr_stmt|;
name|errmess
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|show_where
argument_list|(
name|in_node
argument_list|,
name|at
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"*** The problem is: "
argument_list|)
expr_stmt|;
name|prmess
argument_list|(
name|m2
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|Vnil
condition|)
name|errmess
argument_list|(
name|strval
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|prmess
argument_list|(
name|m3
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|pprerr
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
if|if
condition|(
name|still_ok
condition|)
name|message
argument_list|(
literal|"*** There's something I don't understand"
argument_list|,
name|m
argument_list|,
name|Vnil
argument_list|,
literal|0
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|pprerr2
parameter_list|(
name|tag
parameter_list|,
name|m
parameter_list|)
name|value
name|tag
decl_stmt|;
name|int
name|m
decl_stmt|;
block|{
if|if
condition|(
name|still_ok
condition|)
name|message
argument_list|(
literal|"*** There's something I don't understand"
argument_list|,
literal|0
argument_list|,
name|tag
argument_list|,
name|m
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|parerr2
parameter_list|(
name|m
parameter_list|,
name|ss
parameter_list|)
name|int
name|m
decl_stmt|,
name|ss
decl_stmt|;
block|{
if|if
condition|(
name|still_ok
condition|)
name|message
argument_list|(
literal|"*** There's something I don't understand"
argument_list|,
name|m
argument_list|,
name|Vnil
argument_list|,
name|ss
argument_list|,
name|No
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|parerr
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
name|parerr2
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|fixerr3
parameter_list|(
name|m1
parameter_list|,
name|v
parameter_list|,
name|m2
parameter_list|)
name|value
name|v
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|;
block|{
if|if
condition|(
name|still_ok
condition|)
name|message
argument_list|(
literal|"*** There's something I can't resolve"
argument_list|,
name|m1
argument_list|,
name|v
argument_list|,
name|m2
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|fixerr2
parameter_list|(
name|v
parameter_list|,
name|m
parameter_list|)
name|value
name|v
decl_stmt|;
name|int
name|m
decl_stmt|;
block|{
name|fixerr3
argument_list|(
literal|0
argument_list|,
name|v
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|fixerr
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
name|fixerr3
argument_list|(
literal|0
argument_list|,
name|Vnil
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|error3
parameter_list|(
name|m1
parameter_list|,
name|v
parameter_list|,
name|m2
parameter_list|)
name|value
name|v
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|;
block|{
name|message
argument_list|(
literal|"*** Can't cope with problem"
argument_list|,
name|m1
argument_list|,
name|v
argument_list|,
name|m2
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|error2
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
name|int
name|m
decl_stmt|;
name|value
name|v
decl_stmt|;
block|{
name|error3
argument_list|(
name|m
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|error
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
name|error3
argument_list|(
name|m
argument_list|,
name|Vnil
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|checkerr
parameter_list|()
block|{
name|still_ok
operator|=
name|No
expr_stmt|;
name|line
argument_list|()
expr_stmt|;
name|errmess
argument_list|(
literal|"*** Your check failed"
argument_list|)
expr_stmt|;
name|show_where
argument_list|(
name|Yes
argument_list|,
name|No
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNAL
end_ifdef

begin_function
name|Visible
name|Procedure
name|int_signal
parameter_list|()
block|{
name|interrupted
operator|=
name|Yes
expr_stmt|;
name|still_ok
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|cntxt
operator|==
name|In_prmnv
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
name|fix_files
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
name|bye
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|line
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|errmess
argument_list|(
literal|"*** interrupted\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INTEGRATION
if|if
condition|(
name|filtered
condition|)
name|errmess
argument_list|(
literal|"\177"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cntxt
operator|==
name|In_read
condition|)
block|{
name|set_context
argument_list|(
operator|&
name|read_context
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|uname
argument_list|)
expr_stmt|;
block|}
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|SIGNAL
end_endif

begin_decl_stmt
name|Visible
name|bool
name|bugs
init|=
name|No
decl_stmt|,
name|testing
init|=
name|No
decl_stmt|,
name|tracing
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_function
name|Visible
name|Procedure
name|debug
parameter_list|(
name|m
parameter_list|)
name|string
name|m
decl_stmt|;
block|{
if|if
condition|(
name|bugs
condition|)
block|{
name|line
argument_list|()
expr_stmt|;
name|errmess
argument_list|(
literal|"*** Debugging "
argument_list|)
expr_stmt|;
name|show_where
argument_list|(
name|Yes
argument_list|,
name|Yes
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|errfile
argument_list|,
literal|"*** %s\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EXT_COMMAND
end_ifdef

begin_comment
comment|/* User-callable error message */
end_comment

begin_function
name|Visible
name|Procedure
name|e_error
parameter_list|(
name|mesg
parameter_list|)
name|value
name|mesg
decl_stmt|;
block|{
name|value
name|v
init|=
name|convert
argument_list|(
name|mesg
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"*** Halted"
argument_list|,
literal|0
argument_list|,
name|v
argument_list|,
literal|0
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Visible
name|Procedure
name|bye
parameter_list|(
name|ex
parameter_list|)
name|int
name|ex
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EXT_COMMAND
name|e_done
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|at_nwl
operator|=
name|Yes
expr_stmt|;
name|putprmnv
argument_list|()
expr_stmt|;
name|endall
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|0
condition|)
block|{
name|term_mem
argument_list|()
expr_stmt|;
name|endmem
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IBMPC
name|memstat
argument_list|(
literal|"at end"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|IBMPC
name|exit
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|initerr
parameter_list|()
block|{
name|still_ok
operator|=
name|Yes
expr_stmt|;
name|interrupted
operator|=
name|No
expr_stmt|;
name|curline
operator|=
name|Vnil
expr_stmt|;
name|curlino
operator|=
name|zero
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HZ
value|60
end_define

begin_comment
comment|/* 4.2BSD: not line frequency but historical constant */
end_comment

begin_macro
name|showtime
argument_list|(
argument|whence
argument_list|)
end_macro

begin_decl_stmt
name|string
name|whence
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|TIMING
specifier|static
name|long
name|total
index|[
literal|2
index|]
decl_stmt|;
name|long
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|extern
name|bool
name|timing
decl_stmt|;
comment|/* Set in b3mai.c by -T option */
if|if
condition|(
operator|!
name|timing
condition|)
return|return;
name|times
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|line
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|errfile
argument_list|,
literal|"*** Times %s: user %.2f sys %.2f (total %.2f %.2f)\n"
argument_list|,
name|whence
argument_list|,
call|(
name|float
call|)
argument_list|(
name|buf
index|[
literal|0
index|]
operator|-
name|total
index|[
literal|0
index|]
argument_list|)
operator|/
name|HZ
argument_list|,
call|(
name|float
call|)
argument_list|(
name|buf
index|[
literal|1
index|]
operator|-
name|total
index|[
literal|1
index|]
argument_list|)
operator|/
name|HZ
argument_list|,
operator|(
name|float
operator|)
name|total
index|[
literal|0
index|]
operator|/
name|HZ
argument_list|,
operator|(
name|float
operator|)
name|total
index|[
literal|1
index|]
operator|/
name|HZ
argument_list|)
expr_stmt|;
name|total
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|total
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
endif|TIMING
block|}
end_block

end_unit

