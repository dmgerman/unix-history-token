begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3scr.c,v 1.4 85/08/22 16:58:54 timo Exp $ */
end_comment

begin_comment
comment|/* B input/output handling */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_comment
comment|/*for CLEAR_EOF*/
end_comment

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2par.h"
end_include

begin_include
include|#
directive|include
file|"b3scr.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3fil.h"
end_include

begin_include
include|#
directive|include
file|"b3typ.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3sem.h"
end_include

begin_include
include|#
directive|include
file|"b3int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SETJMP
end_ifdef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Visible
name|bool
name|interactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|bool
name|rd_interactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|value
name|iname
init|=
name|Vnil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input name */
end_comment

begin_decl_stmt
name|Visible
name|bool
name|filtered
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|bool
name|outeractive
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SETJMP
end_ifdef

begin_decl_stmt
name|Visible
name|bool
name|awaiting_input
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Visible
name|jmp_buf
name|read_interrupt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Visible
name|bool
name|at_nwl
init|=
name|Yes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Yes if currently at the start of an output line*/
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|woa
decl_stmt|,
name|wnwl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*was outeractive, was at_nwl */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|last_was_text
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Yes if last value written was a text*/
end_comment

begin_decl_stmt
name|Visible
name|bool
name|Eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ofile
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ifile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|sv_ifile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* copy of ifile for restoring after reading unit */
end_comment

begin_comment
comment|/******************************* Output *******************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_function
name|Hidden
name|Procedure
name|putch
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|still_ok
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
else|else
name|at_nwl
operator|=
name|No
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|Hidden
name|int
name|ocol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current output column */
end_comment

begin_function
name|Hidden
name|Procedure
name|putch
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|still_ok
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|ofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|at_nwl
operator|=
name|Yes
expr_stmt|;
name|ocol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|at_nwl
condition|)
block|{
name|ocol
operator|=
literal|0
expr_stmt|;
name|at_nwl
operator|=
name|No
expr_stmt|;
block|}
operator|++
name|ocol
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Visible
name|Procedure
name|newline
parameter_list|()
block|{
name|putch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|line
parameter_list|()
block|{
if|if
condition|(
operator|!
name|at_nwl
condition|)
name|newline
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|wri_space
parameter_list|()
block|{
name|putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|writ
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|wri
argument_list|(
name|v
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|Putch_sp
parameter_list|()
value|{if (!perm) putch(' ');}
end_define

begin_function
name|Hidden
name|int
name|intsize
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|value
name|s
init|=
name|size
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|large
argument_list|(
name|s
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3800
argument_list|,
literal|"value too big to output"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|intval
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_decl_stmt
name|Hidden
name|bool
name|lwt
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|Procedure
name|wri
parameter_list|(
name|v
parameter_list|,
name|coll
parameter_list|,
name|outer
parameter_list|,
name|perm
parameter_list|)
name|value
name|v
decl_stmt|;
name|bool
name|coll
decl_stmt|,
name|outer
decl_stmt|,
name|perm
decl_stmt|;
block|{
if|if
condition|(
name|outer
operator|&&
operator|!
name|at_nwl
operator|&&
operator|(
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
operator|||
operator|!
name|last_was_text
operator|)
operator|&&
operator|(
operator|!
name|Is_compound
argument_list|(
name|v
argument_list|)
operator|||
operator|!
name|coll
operator|)
condition|)
name|putch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|lwt
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|Is_number
argument_list|(
name|v
argument_list|)
condition|)
block|{
if|if
condition|(
name|perm
condition|)
name|printnum
argument_list|(
name|ofile
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
block|{
name|string
name|cp
init|=
name|convnum
argument_list|(
name|v
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|still_ok
condition|)
name|putch
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|INTEGRATION
name|wrtext
argument_list|(
name|putch
argument_list|,
name|v
argument_list|,
name|outer
condition|?
literal|'\0'
else|:
literal|'"'
argument_list|)
expr_stmt|;
else|#
directive|else
name|value
name|ch
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
init|=
name|Length
argument_list|(
name|v
argument_list|)
decl_stmt|;
define|#
directive|define
name|QUOTE
value|'"'
if|if
condition|(
operator|!
name|outer
condition|)
name|putch
argument_list|(
name|QUOTE
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
operator|&&
name|still_ok
condition|;
name|k
operator|++
control|)
block|{
name|ch
operator|=
name|thof
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|putch
argument_list|(
name|c
operator|=
name|charval
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outer
operator|&&
operator|(
name|c
operator|==
name|QUOTE
operator|||
name|c
operator|==
literal|'`'
operator|)
condition|)
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|outer
condition|)
name|putch
argument_list|(
name|QUOTE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lwt
operator|=
name|outer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Is_compound
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|intlet
name|k
decl_stmt|,
name|len
init|=
name|Nfields
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|outer
operator|&=
name|coll
expr_stmt|;
if|if
condition|(
operator|!
name|coll
condition|)
name|putch
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
operator|&&
name|still_ok
condition|;
name|k
operator|++
control|)
block|{
name|wri
argument_list|(
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|No
argument_list|,
name|outer
argument_list|,
name|perm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Lastfield
argument_list|(
name|k
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|outer
condition|)
block|{
name|putch
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|Putch_sp
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|coll
condition|)
name|putch
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Is_list
argument_list|(
name|v
argument_list|)
operator|||
name|Is_ELT
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|value
name|ve
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
init|=
name|intsize
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|putch
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
operator|&&
name|still_ok
condition|;
name|k
operator|++
control|)
block|{
name|wri
argument_list|(
name|ve
operator|=
name|thof
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|v
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|,
name|perm
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|ve
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Last
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|putch
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|Putch_sp
argument_list|()
expr_stmt|;
block|}
block|}
name|putch
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Is_table
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|int
name|k
decl_stmt|,
name|len
init|=
name|intsize
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|putch
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
operator|&&
name|still_ok
condition|;
name|k
operator|++
control|)
block|{
name|putch
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|wri
argument_list|(
operator|*
name|key
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|,
name|perm
argument_list|)
expr_stmt|;
name|putch
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|putch
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|Putch_sp
argument_list|()
expr_stmt|;
name|wri
argument_list|(
operator|*
name|assoc
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|,
name|perm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Last
argument_list|(
name|k
argument_list|)
condition|)
block|{
name|putch
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|Putch_sp
argument_list|()
expr_stmt|;
block|}
block|}
name|putch
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bugs
operator|||
name|testing
condition|)
block|{
name|putch
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|putch
argument_list|(
name|Type
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|putch
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3801
argument_list|,
literal|"writing value of unknown type"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last_was_text
operator|=
name|lwt
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|interrupted
condition|)
name|clearerr
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/***************************** Input ****************************************/
end_comment

begin_decl_stmt
name|Hidden
name|char
name|cmbuf
index|[
name|CMBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for commands */
end_comment

begin_decl_stmt
name|Hidden
name|char
name|rdbuf
index|[
name|RDBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for READ EG/RAW */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_decl_stmt
name|Visible
name|string
name|cmd_prompt
init|=
literal|">>> "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* commands  */
end_comment

begin_decl_stmt
name|Visible
name|string
name|eg_prompt
init|=
literal|"?\b"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* READ EG   */
end_comment

begin_decl_stmt
name|Visible
name|string
name|raw_prompt
init|=
literal|"?\b"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* READ RAW  */
end_comment

begin_decl_stmt
name|Visible
name|string
name|qn_prompt
init|=
literal|"?\b"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* questions */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|Hidden
name|literal
name|cmd_prompt
init|=
literal|'>'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* commands  */
end_comment

begin_decl_stmt
name|Hidden
name|literal
name|eg_prompt
init|=
literal|'E'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* READ EG   */
end_comment

begin_decl_stmt
name|Hidden
name|literal
name|raw_prompt
init|=
literal|'R'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* READ RAW  */
end_comment

begin_decl_stmt
name|Hidden
name|literal
name|qn_prompt
init|=
literal|'Y'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* questions */
end_comment

begin_decl_stmt
name|Visible
name|literal
name|unit_prompt
init|=
literal|':'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* units */
end_comment

begin_decl_stmt
name|Visible
name|literal
name|tar_prompt
init|=
literal|'='
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* targets */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read a line; EOF only allowed if not interactive, in which case eof set */
end_comment

begin_comment
comment|/* Returns the line input                                                  */
end_comment

begin_comment
comment|/* This is the only place where a long jump is necessary                   */
end_comment

begin_comment
comment|/* In other places, interrupts are just like procedure calls, and checks   */
end_comment

begin_comment
comment|/* of still_ok and interrupted suffice: eventually the stack unwinds to the*/
end_comment

begin_comment
comment|/* main loop in imm_command(). Here though, an interrupt must actually     */
end_comment

begin_comment
comment|/* terminate the read. Hence the bool awaiting_input indicating if the     */
end_comment

begin_comment
comment|/* long jump is necessary or not                                           */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_function
name|Hidden
name|txptr
name|read_line
parameter_list|(
name|should_prompt
parameter_list|,
name|prompt
parameter_list|,
name|cmd
parameter_list|,
name|eof
parameter_list|,
name|eof_message
parameter_list|)
name|bool
name|should_prompt
decl_stmt|,
name|cmd
decl_stmt|,
decl|*
name|eof
decl_stmt|;
end_function

begin_decl_stmt
name|string
name|prompt
decl_stmt|,
name|eof_message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|txptr
name|buf
decl_stmt|,
name|rp
decl_stmt|,
name|bufend
decl_stmt|;
name|intlet
name|k
decl_stmt|;
name|bool
name|got
init|=
name|No
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
operator|*
name|eof
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|cmd
condition|)
block|{
name|buf
operator|=
name|cmbuf
expr_stmt|;
name|bufend
operator|=
operator|&
name|cmbuf
index|[
name|CMBUFSIZE
operator|-
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|rdbuf
expr_stmt|;
name|bufend
operator|=
operator|&
name|rdbuf
index|[
name|RDBUFSIZE
operator|-
literal|2
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SETJMP
if|if
condition|(
name|setjmp
argument_list|(
name|read_interrupt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|awaiting_input
operator|=
name|No
expr_stmt|;
return|return
name|buf
return|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|!
name|got
condition|)
block|{
name|rp
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP
name|awaiting_input
operator|=
name|Yes
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|should_prompt
condition|)
block|{
if|if
condition|(
name|cmd
condition|)
block|{
if|if
condition|(
name|outeractive
condition|)
block|{
name|line
argument_list|()
expr_stmt|;
name|at_nwl
operator|=
name|No
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|f
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|ifile
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|k
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|k
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|rp
operator|++
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|rp
operator|>=
name|bufend
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3802
argument_list|,
literal|"buffer overflow"
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SETJMP
name|awaiting_input
operator|=
name|No
expr_stmt|;
endif|#
directive|endif
name|got
operator|=
name|Yes
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|should_prompt
condition|)
block|{
if|if
condition|(
name|filtered
condition|)
block|{
name|bye
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*Editor has died*/
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r*** %s\n"
argument_list|,
name|eof_message
argument_list|)
expr_stmt|;
name|CLEAR_EOF
expr_stmt|;
if|if
condition|(
name|outeractive
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
name|got
operator|=
name|No
expr_stmt|;
block|}
block|}
else|else
operator|*
name|eof
operator|=
name|Yes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|should_prompt
operator|&&
name|outeractive
operator|&&
name|k
operator|==
literal|'\n'
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_else
else|#
directive|else
else|INTEGRATION
end_else

begin_function
name|Hidden
name|intlet
name|rd_fileline
parameter_list|(
name|nbuf
parameter_list|,
name|file
parameter_list|,
name|nbufend
parameter_list|)
name|string
name|nbuf
decl_stmt|,
name|nbufend
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|intlet
name|k
decl_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|getc
argument_list|(
name|file
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|k
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|nbuf
operator|++
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|nbuf
operator|>=
name|nbufend
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3803
argument_list|,
literal|"buffer overflow rd_fileline()"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|nbuf
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|nbuf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_function
name|Hidden
name|intlet
name|rd_bufline
parameter_list|(
name|nbuf
parameter_list|,
name|obuf
parameter_list|,
name|nbufend
parameter_list|)
name|string
name|nbuf
decl_stmt|,
decl|*
name|obuf
decl_stmt|,
name|nbufend
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
operator|*
name|obuf
operator|&&
operator|*
operator|*
name|obuf
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|nbuf
operator|++
operator|=
operator|*
operator|*
name|obuf
expr_stmt|;
operator|++
operator|*
name|obuf
expr_stmt|;
if|if
condition|(
name|nbuf
operator|>=
name|nbufend
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3804
argument_list|,
literal|"buffer overflow rd_bufline()"
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|nbuf
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|nbuf
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|obuf
condition|)
block|{
operator|++
operator|*
name|obuf
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
else|else
return|return
name|EOF
return|;
block|}
end_block

begin_decl_stmt
name|Hidden
name|string
name|edcmdbuf
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|txptr
name|read_line
parameter_list|(
name|should_prompt
parameter_list|,
name|prompt
parameter_list|,
name|cmd
parameter_list|,
name|eof
parameter_list|,
name|eof_message
parameter_list|)
name|bool
name|should_prompt
decl_stmt|,
name|cmd
decl_stmt|,
decl|*
name|eof
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|string
name|eof_message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|txptr
name|buf
decl_stmt|,
name|rp
decl_stmt|,
name|bufend
decl_stmt|;
name|intlet
name|k
decl_stmt|,
name|indent
init|=
literal|0
decl_stmt|;
name|bool
name|got
init|=
name|No
decl_stmt|;
specifier|static
name|string
name|pedcmdbuf
decl_stmt|;
if|if
condition|(
name|prompt
operator|==
name|eg_prompt
operator|||
name|prompt
operator|==
name|raw_prompt
condition|)
name|indent
operator|=
name|ocol
expr_stmt|;
operator|*
name|eof
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|cmd
condition|)
block|{
name|buf
operator|=
name|cmbuf
expr_stmt|;
name|bufend
operator|=
operator|&
name|cmbuf
index|[
name|CMBUFSIZE
operator|-
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|rdbuf
expr_stmt|;
name|bufend
operator|=
operator|&
name|rdbuf
index|[
name|RDBUFSIZE
operator|-
literal|2
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SETJMP
if|if
condition|(
name|setjmp
argument_list|(
name|read_interrupt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|awaiting_input
operator|=
name|No
expr_stmt|;
return|return
name|buf
return|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|!
name|got
condition|)
block|{
name|rp
operator|=
name|buf
expr_stmt|;
name|got
operator|=
name|Yes
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP
name|awaiting_input
operator|=
name|Yes
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|should_prompt
condition|)
block|{
name|k
operator|=
name|rd_fileline
argument_list|(
name|rp
argument_list|,
name|ifile
argument_list|,
name|bufend
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|EOF
condition|)
operator|*
name|eof
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|edcmdbuf
condition|)
block|{
if|if
condition|(
name|cmd
operator|&&
name|outeractive
condition|)
block|{
name|line
argument_list|()
expr_stmt|;
name|at_nwl
operator|=
name|No
expr_stmt|;
block|}
name|btop
argument_list|(
operator|&
name|edcmdbuf
argument_list|,
literal|0
argument_list|,
name|prompt
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|pedcmdbuf
operator|=
name|edcmdbuf
expr_stmt|;
block|}
name|k
operator|=
name|rd_bufline
argument_list|(
name|rp
argument_list|,
operator|&
name|pedcmdbuf
argument_list|,
name|bufend
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|EOF
condition|)
block|{
name|freemem
argument_list|(
operator|(
name|ptr
operator|)
name|edcmdbuf
argument_list|)
expr_stmt|;
name|edcmdbuf
operator|=
operator|(
name|string
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|prompt
operator|!=
literal|'>'
condition|)
name|got
operator|=
name|No
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SETJMP
name|awaiting_input
operator|=
name|No
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|should_prompt
operator|&&
name|outeractive
operator|&&
name|k
operator|==
literal|'\n'
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|INTEGRATION
end_endif

begin_comment
comment|/* Rather over-fancy routine to ask the user a question */
end_comment

begin_comment
comment|/* Will anybody discover that you're only given 4 chances? */
end_comment

begin_decl_stmt
name|Hidden
name|char
name|USE_YES_OR_NO
index|[]
init|=
literal|"Answer with yes or no (or use interrupt to duck the question)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|char
name|LAST_CHANCE
index|[]
init|=
literal|"This is your last chance. Take it. I really don't know what you want.\n\     So answer the question"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|char
name|NO_THEN
index|[]
init|=
literal|"Well, I shall assume that your refusal to answer the question means no!"
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|bool
name|is_intended
parameter_list|(
name|m
parameter_list|)
name|string
name|m
decl_stmt|;
block|{
name|char
name|answer
decl_stmt|;
name|intlet
name|try
decl_stmt|;
name|txptr
name|tp
decl_stmt|;
name|bool
name|eof
decl_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
return|return
name|Yes
return|;
if|if
condition|(
name|outeractive
condition|)
name|line
argument_list|()
expr_stmt|;
for|for
control|(
name|try
operator|=
literal|1
init|;
name|try
operator|<=
literal|4
condition|;
name|try
operator|++
control|)
block|{
if|if
condition|(
name|try
operator|==
literal|1
operator|||
name|try
operator|==
literal|3
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** %s\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tp
operator|=
name|read_line
argument_list|(
name|Yes
argument_list|,
name|qn_prompt
argument_list|,
name|No
argument_list|,
operator|&
name|eof
argument_list|,
name|USE_YES_OR_NO
argument_list|)
expr_stmt|;
name|skipsp
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
name|answer
operator|=
name|Char
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
literal|'y'
operator|||
name|answer
operator|==
literal|'Y'
condition|)
return|return
name|Yes
return|;
if|if
condition|(
name|answer
operator|==
literal|'n'
operator|||
name|answer
operator|==
literal|'N'
condition|)
return|return
name|No
return|;
if|if
condition|(
name|outeractive
condition|)
name|line
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** %s\n"
argument_list|,
name|try
operator|==
literal|1
condition|?
literal|"Please answer with yes or no"
else|:
name|try
operator|==
literal|2
condition|?
literal|"Just yes or no, please"
else|:
name|try
operator|==
literal|3
condition|?
name|LAST_CHANCE
else|:
name|NO_THEN
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
return|return
name|No
return|;
block|}
end_function

begin_comment
comment|/* Read_eg uses evaluation but it shouldn't.    Wait for a more general mechanism. */
end_comment

begin_function
name|Visible
name|Procedure
name|read_eg
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
name|loc
name|l
decl_stmt|;
name|btype
name|t
decl_stmt|;
block|{
name|context
name|c
decl_stmt|;
name|parsetree
name|code
decl_stmt|;
name|parsetree
name|r
init|=
name|NilTree
decl_stmt|;
name|value
name|rv
init|=
name|Vnil
decl_stmt|;
name|btype
name|rt
init|=
name|Vnil
decl_stmt|;
name|envtab
name|svprmnvtab
init|=
name|Vnil
decl_stmt|;
name|txptr
name|fcol_save
init|=
name|first_col
decl_stmt|,
name|tx_save
init|=
name|tx
decl_stmt|;
do|do
block|{
name|still_ok
operator|=
name|Yes
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|!=
name|In_read
condition|)
block|{
name|release
argument_list|(
name|read_context
operator|.
name|uname
argument_list|)
expr_stmt|;
name|sv_context
argument_list|(
operator|&
name|read_context
argument_list|)
expr_stmt|;
block|}
name|svprmnvtab
operator|=
name|prmnvtab
operator|==
name|Vnil
condition|?
name|Vnil
else|:
name|prmnv
operator|->
name|tab
expr_stmt|;
comment|/* save scratch-pad copy because of following setprmnv() */
name|setprmnv
argument_list|()
expr_stmt|;
name|cntxt
operator|=
name|In_read
expr_stmt|;
name|first_col
operator|=
name|tx
operator|=
name|read_line
argument_list|(
name|rd_interactive
argument_list|,
name|eg_prompt
argument_list|,
name|No
argument_list|,
operator|&
name|Eof
argument_list|,
literal|"use interrupt to abort READ command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
operator|&&
name|Eof
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3805
argument_list|,
literal|"End of file encountered during READ command"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rd_interactive
condition|)
name|f_lino
operator|++
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
block|{
name|findceol
argument_list|()
expr_stmt|;
name|r
operator|=
name|expr
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|fix_nodes
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|rv
operator|=
name|evalthread
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|rt
operator|=
name|still_ok
condition|?
name|valtype
argument_list|(
name|rv
argument_list|)
else|:
name|Vnil
expr_stmt|;
if|if
condition|(
name|svprmnvtab
operator|!=
name|Vnil
condition|)
block|{
name|prmnvtab
operator|=
name|prmnv
operator|->
name|tab
expr_stmt|;
name|prmnv
operator|->
name|tab
operator|=
name|svprmnvtab
expr_stmt|;
block|}
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|must_agree
argument_list|(
name|t
argument_list|,
name|rt
argument_list|,
name|MESS
argument_list|(
literal|3806
argument_list|,
literal|"type of expression does not agree with that of EG sample"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|still_ok
operator|&&
name|rd_interactive
operator|&&
operator|!
name|interrupted
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Please try again\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|interrupted
operator|&&
operator|!
name|still_ok
operator|&&
name|rd_interactive
condition|)
do|;
if|if
condition|(
name|still_ok
condition|)
name|put
argument_list|(
name|rv
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|first_col
operator|=
name|fcol_save
expr_stmt|;
name|tx
operator|=
name|tx_save
expr_stmt|;
name|release
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|read_raw
parameter_list|(
name|l
parameter_list|)
name|loc
name|l
decl_stmt|;
block|{
name|value
name|r
decl_stmt|;
name|bool
name|eof
decl_stmt|;
name|txptr
name|line
init|=
name|read_line
argument_list|(
name|rd_interactive
argument_list|,
name|raw_prompt
argument_list|,
name|No
argument_list|,
operator|&
name|eof
argument_list|,
literal|"use interrupt to abort READ t RAW"
argument_list|)
decl_stmt|;
if|if
condition|(
name|still_ok
operator|&&
name|eof
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3807
argument_list|,
literal|"End of file encountered during READ t RAW"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rd_interactive
condition|)
name|f_lino
operator|++
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
block|{
name|txptr
name|rp
init|=
name|line
decl_stmt|;
while|while
condition|(
operator|*
name|rp
operator|!=
literal|'\n'
condition|)
name|rp
operator|++
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|mk_text
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|txptr
name|getline
parameter_list|()
block|{
name|bool
name|should_prompt
init|=
name|interactive
operator|&&
name|sv_ifile
operator|==
name|ifile
decl_stmt|;
return|return
name|read_line
argument_list|(
name|should_prompt
argument_list|,
name|cmd_prompt
argument_list|,
name|Yes
argument_list|,
operator|&
name|Eof
argument_list|,
literal|"use QUIT to end session"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************* Files ******************************/
end_comment

begin_function
name|Visible
name|Procedure
name|redirect
parameter_list|(
name|of
parameter_list|)
name|FILE
modifier|*
name|of
decl_stmt|;
block|{
name|ofile
operator|=
name|of
expr_stmt|;
if|if
condition|(
name|of
operator|==
name|stdout
condition|)
block|{
name|outeractive
operator|=
name|woa
expr_stmt|;
name|at_nwl
operator|=
name|wnwl
expr_stmt|;
block|}
else|else
block|{
name|woa
operator|=
name|outeractive
expr_stmt|;
name|outeractive
operator|=
name|No
expr_stmt|;
name|wnwl
operator|=
name|at_nwl
expr_stmt|;
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|vs_ifile
parameter_list|()
block|{
name|ifile
operator|=
name|sv_ifile
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|re_screen
parameter_list|()
block|{
name|sv_ifile
operator|=
name|ifile
expr_stmt|;
name|interactive
operator|=
name|f_interactive
argument_list|(
name|ifile
argument_list|)
operator|||
operator|(
name|ifile
operator|==
name|stdin
operator|&&
name|filtered
operator|)
expr_stmt|;
name|Eof
operator|=
name|No
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initscr is a reserved name of CURSES */
end_comment

begin_function
name|Visible
name|Procedure
name|init_scr
parameter_list|()
block|{
name|outeractive
operator|=
name|f_interactive
argument_list|(
name|stdout
argument_list|)
operator|||
name|filtered
expr_stmt|;
name|rd_interactive
operator|=
name|f_interactive
argument_list|(
name|stdin
argument_list|)
operator|||
name|filtered
expr_stmt|;
name|rdbuf
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|tx
operator|=
name|rdbuf
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|endscr
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|INTEGRATION
if|if
condition|(
name|edcmdbuf
condition|)
block|{
name|freemem
argument_list|(
operator|(
name|ptr
operator|)
name|edcmdbuf
argument_list|)
expr_stmt|;
name|edcmdbuf
operator|=
operator|(
name|string
operator|)
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

