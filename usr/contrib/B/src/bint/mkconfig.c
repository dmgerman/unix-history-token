begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: mkconfig.c,v 1.4 85/08/26 10:41:39 timo Exp $ */
end_comment

begin_comment
comment|/* Generate constants for configuration file			*/
end_comment

begin_comment
comment|/* If your C system is not unix but does have signal/setjmp,	*/
end_comment

begin_comment
comment|/*    add a #define unix					*/
end_comment

begin_comment
comment|/* You may also need to add some calls to signal().		*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|unix
end_ifdef

begin_define
define|#
directive|define
name|SIGNAL
end_define

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|jmp_buf
name|lab
decl_stmt|;
end_decl_stmt

begin_macro
name|overflow
argument_list|(
argument|sig
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sig
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* what to do on overflow/underflow */
name|signal
argument_list|(
name|sig
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|lab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Dummy routines instead */
end_comment

begin_decl_stmt
name|int
name|lab
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|setjmp
parameter_list|(
name|lab
parameter_list|)
name|int
name|lab
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|fabs
parameter_list|(
name|x
parameter_list|)
value|(((x)<0.0)?(-x):(x))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)<(y))?(x):(y))
end_define

begin_comment
comment|/* These routines are intended to defeat any attempt at optimisation */
end_comment

begin_macro
name|Dstore
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|double
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|b
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_function
name|double
name|Dsum
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|double
name|r
decl_stmt|;
name|Dstore
argument_list|(
name|a
operator|+
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|double
name|Ddiff
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|double
name|r
decl_stmt|;
name|Dstore
argument_list|(
name|a
operator|-
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|double
name|Dmul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|double
name|r
decl_stmt|;
name|Dstore
argument_list|(
name|a
operator|*
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|double
name|Ddiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|double
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|double
name|r
decl_stmt|;
name|Dstore
argument_list|(
name|a
operator|/
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|double
name|power
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|int
name|x
decl_stmt|,
name|n
decl_stmt|;
block|{
name|double
name|r
init|=
literal|1.0
decl_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
name|r
operator|*=
name|x
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|log
parameter_list|(
name|base
parameter_list|,
name|x
parameter_list|)
name|int
name|base
decl_stmt|;
name|double
name|x
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|x
operator|>=
name|base
condition|)
block|{
name|r
operator|++
expr_stmt|;
name|x
operator|/=
name|base
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|short
name|newshort
decl_stmt|,
name|maxshort
decl_stmt|,
name|maxershort
decl_stmt|;
name|int
name|newint
decl_stmt|,
name|maxint
decl_stmt|,
name|shortbits
decl_stmt|,
name|bits
decl_stmt|,
name|mantbits
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|shortpower
decl_stmt|,
name|intpower
decl_stmt|,
name|longpower
decl_stmt|;
name|long
name|newlong
decl_stmt|,
name|maxlong
decl_stmt|,
name|count
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ibase
decl_stmt|,
name|iexp
decl_stmt|,
name|irnd
decl_stmt|,
name|imant
decl_stmt|,
name|iz
decl_stmt|,
name|k
decl_stmt|,
name|machep
decl_stmt|,
name|maxexp
decl_stmt|,
name|minexp
decl_stmt|,
name|mx
decl_stmt|,
name|negeps
decl_stmt|,
name|ngrd
decl_stmt|,
name|normalised
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|base
decl_stmt|,
name|basein
decl_stmt|,
name|basem1
decl_stmt|,
name|eps
decl_stmt|,
name|epsneg
decl_stmt|,
name|xmax
decl_stmt|,
name|newxmax
decl_stmt|,
name|xmin
decl_stmt|,
name|xminner
decl_stmt|,
name|y
decl_stmt|,
name|y1
decl_stmt|,
name|z
decl_stmt|,
name|z1
decl_stmt|,
name|z2
decl_stmt|;
name|double
name|BIG
decl_stmt|,
name|Maxreal
decl_stmt|;
name|int
name|BASE
decl_stmt|,
name|MAXNUMDIG
decl_stmt|,
name|ipower
decl_stmt|,
name|tenlogBASE
decl_stmt|,
name|Maxexpo
decl_stmt|,
name|Minexpo
decl_stmt|,
name|Dblbits
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGNAL
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|overflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected over/underflow\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/****** Calculate max short *********************************************/
comment|/*      Calculate 2**n-1 until overflow - then use the previous value	*/
name|newshort
operator|=
literal|1
expr_stmt|;
name|maxshort
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|shortpower
operator|=
literal|0
init|;
name|newshort
operator|>
name|maxshort
condition|;
name|shortpower
operator|++
control|)
block|{
name|maxshort
operator|=
name|newshort
expr_stmt|;
name|newshort
operator|=
name|newshort
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Now for those daft Cybers: */
name|maxershort
operator|=
literal|0
expr_stmt|;
name|newshort
operator|=
name|maxshort
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|shortbits
operator|=
name|shortpower
init|;
name|newshort
operator|>
name|maxershort
condition|;
name|shortbits
operator|++
control|)
block|{
name|maxershort
operator|=
name|newshort
expr_stmt|;
name|newshort
operator|=
name|newshort
operator|+
name|newshort
operator|+
literal|1
expr_stmt|;
block|}
name|bits
operator|=
operator|(
name|shortbits
operator|+
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|char
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/\* char=%d bits, %ssigned *\/\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
operator|*
name|bits
argument_list|,
operator|(
operator|(
name|int
operator|)
name|c
operator|)
operator|<
literal|0
condition|?
literal|""
else|:
literal|"un"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/\* maxshort=%d (=2**%d-1) *\/\n"
argument_list|,
name|maxshort
argument_list|,
name|shortpower
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxershort
operator|>
name|maxshort
condition|)
block|{
name|printf
argument_list|(
literal|"/\* There is a larger maxshort, %d (=2**%d-1), %s *\/\n"
argument_list|,
name|maxershort
argument_list|,
name|shortbits
argument_list|,
literal|"but only for addition, not multiplication"
argument_list|)
expr_stmt|;
block|}
comment|/****** Calculate max int by the same method ***************************/
name|newint
operator|=
literal|1
expr_stmt|;
name|maxint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|intpower
operator|=
literal|0
init|;
name|newint
operator|>
name|maxint
condition|;
name|intpower
operator|++
control|)
block|{
name|maxint
operator|=
name|newint
expr_stmt|;
name|newint
operator|=
name|newint
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/\* maxint=%d (=2**%d-1) *\/\n"
argument_list|,
name|maxint
argument_list|,
name|intpower
argument_list|)
expr_stmt|;
comment|/****** Calculate max long by the same method ***************************/
name|newlong
operator|=
literal|1
expr_stmt|;
name|maxlong
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
for|for
control|(
name|longpower
operator|=
literal|0
init|;
name|newlong
operator|>
name|maxlong
condition|;
name|longpower
operator|++
control|)
block|{
name|maxlong
operator|=
name|newlong
expr_stmt|;
name|newlong
operator|=
name|newlong
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nUnexpected under/overflow\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/\* maxlong=%ld (=2**%d-1) *\/\n"
argument_list|,
name|maxlong
argument_list|,
name|longpower
argument_list|)
expr_stmt|;
comment|/****** Pointers ********************************************************/
name|printf
argument_list|(
literal|"/\* pointers=%d bits%s *\/\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
operator|*
name|bits
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|?
literal|" BEWARE! larger than int!"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/****** Base and size of mantissa ***************************************/
name|a
operator|=
literal|1.0
expr_stmt|;
do|do
block|{
name|a
operator|=
name|Dsum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Ddiff
argument_list|(
name|Ddiff
argument_list|(
name|Dsum
argument_list|(
name|a
argument_list|,
literal|1.0
argument_list|)
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
do|;
name|b
operator|=
literal|1.0
expr_stmt|;
do|do
block|{
name|b
operator|=
name|Dsum
argument_list|(
name|b
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|base
operator|=
name|Ddiff
argument_list|(
name|Dsum
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|,
name|a
argument_list|)
operator|)
operator|==
literal|0.0
condition|)
do|;
name|ibase
operator|=
name|base
expr_stmt|;
name|printf
argument_list|(
literal|"/\* base=%d *\/\n"
argument_list|,
name|ibase
argument_list|)
expr_stmt|;
name|imant
operator|=
literal|0
expr_stmt|;
name|b
operator|=
literal|1.0
expr_stmt|;
do|do
block|{
name|imant
operator|++
expr_stmt|;
name|b
operator|=
name|Dmul
argument_list|(
name|b
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Ddiff
argument_list|(
name|Ddiff
argument_list|(
name|Dsum
argument_list|(
name|b
argument_list|,
literal|1.0
argument_list|)
argument_list|,
name|b
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
do|;
name|printf
argument_list|(
literal|"/\* Significant base digits=%d *\/\n"
argument_list|,
name|imant
argument_list|)
expr_stmt|;
comment|/****** Various flavours of epsilon *************************************/
name|basem1
operator|=
name|Ddiff
argument_list|(
name|base
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ddiff
argument_list|(
name|Dsum
argument_list|(
name|a
argument_list|,
name|basem1
argument_list|)
argument_list|,
name|a
argument_list|)
operator|!=
literal|0.0
condition|)
name|irnd
operator|=
literal|1
expr_stmt|;
else|else
name|irnd
operator|=
literal|0
expr_stmt|;
name|negeps
operator|=
name|imant
operator|+
name|imant
expr_stmt|;
name|basein
operator|=
literal|1.0
operator|/
name|base
expr_stmt|;
name|a
operator|=
literal|1.0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|negeps
condition|;
name|i
operator|++
control|)
name|a
operator|*=
name|basein
expr_stmt|;
name|b
operator|=
name|a
expr_stmt|;
while|while
condition|(
name|Ddiff
argument_list|(
name|Ddiff
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
block|{
name|a
operator|*=
name|base
expr_stmt|;
name|negeps
operator|--
expr_stmt|;
block|}
name|negeps
operator|=
operator|-
name|negeps
expr_stmt|;
name|printf
argument_list|(
literal|"/\* Smallest x such that 1.0-base**x != 1.0=%d *\/\n"
argument_list|,
name|negeps
argument_list|)
expr_stmt|;
name|epsneg
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|ibase
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|irnd
operator|==
literal|1
operator|)
condition|)
block|{
comment|/*	a=(a*(1.0+a))/(1.0+1.0); => */
name|a
operator|=
name|Ddiv
argument_list|(
name|Dmul
argument_list|(
name|a
argument_list|,
name|Dsum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|)
argument_list|,
name|Dsum
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	if ((1.0-a)-1.0 != 0.0) epsneg=a; => */
if|if
condition|(
name|Ddiff
argument_list|(
name|Ddiff
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|!=
literal|0.0
condition|)
name|epsneg
operator|=
name|a
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/\* Small x such that 1.0-x != 1.0=%g *\/\n"
argument_list|,
name|epsneg
argument_list|)
expr_stmt|;
comment|/* it may not be the smallest */
name|machep
operator|=
operator|-
name|imant
operator|-
name|imant
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
while|while
condition|(
name|Ddiff
argument_list|(
name|Dsum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|==
literal|0.0
condition|)
block|{
name|a
operator|*=
name|base
expr_stmt|;
name|machep
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/\* Smallest x such that 1.0+base**x != 1.0=%d *\/\n"
argument_list|,
name|machep
argument_list|)
expr_stmt|;
name|eps
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|ibase
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|irnd
operator|==
literal|1
operator|)
condition|)
block|{
comment|/*	a=(a*(1.0+a))/(1.0+1.0); => */
name|a
operator|=
name|Ddiv
argument_list|(
name|Dmul
argument_list|(
name|a
argument_list|,
name|Dsum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|)
argument_list|,
name|Dsum
argument_list|(
literal|1.0
argument_list|,
literal|1.0
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	if ((1.0+a)-1.0 != 0.0) eps=a; => */
if|if
condition|(
name|Ddiff
argument_list|(
name|Dsum
argument_list|(
literal|1.0
argument_list|,
name|a
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|!=
literal|0.0
condition|)
name|eps
operator|=
name|a
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/\* Smallest x such that 1.0+x != 1.0=%g *\/\n"
argument_list|,
name|eps
argument_list|)
expr_stmt|;
comment|/****** Round or chop ***************************************************/
name|ngrd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|irnd
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"/\* Arithmetic rounds *\/\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"/\* Arithmetic chops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ddiff
argument_list|(
name|Dmul
argument_list|(
name|Dsum
argument_list|(
literal|1.0
argument_list|,
name|eps
argument_list|)
argument_list|,
literal|1.0
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|!=
literal|0.0
condition|)
block|{
name|ngrd
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|" but uses guard digits"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" *\/\n"
argument_list|)
expr_stmt|;
block|}
comment|/****** Size of and minimum normalised exponent ****************************/
name|y
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|z
operator|=
name|basein
expr_stmt|;
name|z1
operator|=
operator|(
literal|1.0
operator|+
name|eps
operator|)
operator|/
name|base
expr_stmt|;
comment|/* Coarse search for the largest power of two */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
comment|/* in case of underflow trap */
do|do
block|{
name|y
operator|=
name|z
expr_stmt|;
name|y1
operator|=
name|z1
expr_stmt|;
name|z
operator|=
name|Dmul
argument_list|(
name|y
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z1
operator|=
name|Dmul
argument_list|(
name|z1
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|a
operator|=
name|Dmul
argument_list|(
name|z
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|z2
operator|=
name|Ddiv
argument_list|(
name|z1
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|z2
operator|!=
name|y1
condition|)
break|break;
if|if
condition|(
operator|(
name|Dsum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
literal|0.0
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|z
argument_list|)
operator|>=
name|y
operator|)
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|k
operator|+=
name|k
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|ibase
operator|!=
literal|10
condition|)
block|{
name|iexp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* for the sign */
name|mx
operator|=
name|k
operator|+
name|k
expr_stmt|;
block|}
else|else
block|{
name|iexp
operator|=
literal|2
expr_stmt|;
name|iz
operator|=
name|ibase
expr_stmt|;
while|while
condition|(
name|k
operator|>=
name|iz
condition|)
block|{
name|iz
operator|*=
name|ibase
expr_stmt|;
name|iexp
operator|++
expr_stmt|;
block|}
name|mx
operator|=
name|iz
operator|+
name|iz
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Fine tune starting with y and y1 */
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
comment|/* in case of underflow trap */
do|do
block|{
name|xmin
operator|=
name|y
expr_stmt|;
name|z1
operator|=
name|y1
expr_stmt|;
name|y
operator|=
name|Ddiv
argument_list|(
name|y
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|y1
operator|=
name|Ddiv
argument_list|(
name|y1
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|a
operator|=
name|Dmul
argument_list|(
name|y
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|z2
operator|=
name|Dmul
argument_list|(
name|y1
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|z2
operator|!=
name|z1
condition|)
break|break;
if|if
condition|(
operator|(
name|Dsum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
literal|0.0
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|y
argument_list|)
operator|>=
name|xmin
operator|)
condition|)
break|break;
name|k
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected over/underflow\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|minexp
operator|=
operator|(
operator|-
name|k
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mx
operator|<=
name|k
operator|+
name|k
operator|-
literal|3
operator|)
operator|&&
operator|(
name|ibase
operator|!=
literal|10
operator|)
condition|)
block|{
name|mx
operator|+=
name|mx
expr_stmt|;
name|iexp
operator|+=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/\* Number of bits used for exponent=%d *\/\n"
argument_list|,
name|iexp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/\* Minimum normalised exponent=%d *\/\n"
argument_list|,
name|minexp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/\* Minimum normalised positive number=%g *\/\n"
argument_list|,
name|xmin
argument_list|)
expr_stmt|;
comment|/****** Minimum exponent ***************************************************/
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
comment|/* in case of underflow trap */
do|do
block|{
name|xminner
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|Ddiv
argument_list|(
name|y
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|a
operator|=
name|Dmul
argument_list|(
name|y
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Dsum
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
operator|==
literal|0.0
operator|)
operator|||
operator|(
name|fabs
argument_list|(
name|y
argument_list|)
operator|>=
name|xminner
operator|)
condition|)
break|break;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected over/underflow\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|normalised
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xminner
operator|!=
literal|0.0
operator|&&
name|xminner
operator|!=
name|xmin
condition|)
block|{
name|normalised
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"/\* The smallest numbers are not kept normalised *\/\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/\* Smallest unnormalised positive number=%g *\/\n"
argument_list|,
name|xminner
argument_list|)
expr_stmt|;
block|}
comment|/****** Maximum exponent ***************************************************/
name|maxexp
operator|=
literal|2
expr_stmt|;
name|xmax
operator|=
literal|1.0
expr_stmt|;
name|newxmax
operator|=
name|base
operator|+
literal|1.0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|xmax
operator|<
name|newxmax
condition|)
block|{
name|xmax
operator|=
name|newxmax
expr_stmt|;
name|newxmax
operator|=
name|Dmul
argument_list|(
name|newxmax
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ddiv
argument_list|(
name|newxmax
argument_list|,
name|base
argument_list|)
operator|!=
name|xmax
condition|)
break|break;
comment|/* ieee infinity */
name|maxexp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|lab
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected over/underflow\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"/\* Maximum exponent=%d *\/\n"
argument_list|,
name|maxexp
argument_list|)
expr_stmt|;
comment|/****** Largest and smallest numbers ************************************/
name|xmax
operator|=
name|Ddiff
argument_list|(
literal|1.0
argument_list|,
name|epsneg
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dmul
argument_list|(
name|xmax
argument_list|,
literal|1.0
argument_list|)
operator|!=
name|xmax
condition|)
name|xmax
operator|=
name|Ddiff
argument_list|(
literal|1.0
argument_list|,
name|Dmul
argument_list|(
name|base
argument_list|,
name|epsneg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxexp
condition|;
name|i
operator|++
control|)
name|xmax
operator|=
name|Dmul
argument_list|(
name|xmax
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/\* Maximum number=%g *\/\n"
argument_list|,
name|xmax
argument_list|)
expr_stmt|;
comment|/****** Hidden bit + sanity check ***************************************/
if|if
condition|(
name|ibase
operator|!=
literal|10
condition|)
block|{
name|mantbits
operator|=
name|log
argument_list|(
literal|2
argument_list|,
operator|(
name|double
operator|)
name|ibase
argument_list|)
operator|*
name|imant
expr_stmt|;
if|if
condition|(
name|mantbits
operator|+
name|iexp
operator|+
literal|1
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|bits
operator|+
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"/\* Double arithmetic uses a hidden bit *\/\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mantbits
operator|+
name|iexp
operator|+
literal|1
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|*
name|bits
condition|)
block|{
name|printf
argument_list|(
literal|"/\* Double arithmetic doesn't use a hidden bit *\/\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"/\* Something fishy here! %s %s *\/\n"
argument_list|,
literal|"Exponent size + mantissa size doesn't match"
argument_list|,
literal|"with the size of a double."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/****** The point of it all: ********************************************/
name|printf
argument_list|(
literal|"\n/\* Numeric package constants *\/\n"
argument_list|)
expr_stmt|;
name|BIG
operator|=
name|power
argument_list|(
name|ibase
argument_list|,
name|imant
argument_list|)
operator|-
literal|1.0
expr_stmt|;
name|MAXNUMDIG
operator|=
name|log
argument_list|(
literal|10
argument_list|,
name|BIG
argument_list|)
expr_stmt|;
name|ipower
operator|=
name|log
argument_list|(
literal|10
argument_list|,
call|(
name|double
call|)
argument_list|(
name|maxint
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|Maxreal
operator|=
name|xmax
expr_stmt|;
name|Maxexpo
operator|=
name|log
argument_list|(
literal|2
argument_list|,
operator|(
name|double
operator|)
name|ibase
argument_list|)
operator|*
name|maxexp
expr_stmt|;
name|Minexpo
operator|=
name|log
argument_list|(
literal|2
argument_list|,
operator|(
name|double
operator|)
name|ibase
argument_list|)
operator|*
name|minexp
expr_stmt|;
name|Dblbits
operator|=
name|log
argument_list|(
literal|2
argument_list|,
operator|(
name|double
operator|)
name|ibase
argument_list|)
operator|*
name|imant
expr_stmt|;
name|tenlogBASE
operator|=
name|min
argument_list|(
name|MAXNUMDIG
operator|/
literal|2
argument_list|,
name|ipower
argument_list|)
expr_stmt|;
name|BASE
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tenlogBASE
condition|;
name|i
operator|++
control|)
name|BASE
operator|*=
literal|10
expr_stmt|;
name|printf
argument_list|(
literal|"#define BIG %1.1f /\* Maximum integral double *\/\n"
argument_list|,
name|BIG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define LONG "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|MAXNUMDIG
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"9"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".5 /\* Maximum power of ten less than BIG *\/\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MAXNUMDIG %d /\* The number of 9's in LONG *\/\n"
argument_list|,
name|MAXNUMDIG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define MINNUMDIG 6 /\* Don't change: this is here for consistency *\/\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define BASE %d /\* %s *\/\n"
argument_list|,
name|BASE
argument_list|,
literal|"BASE**2<=BIG&& BASE*2<=Maxint&& -2*BASE>=Minint"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|BASE
operator|)
operator|*
name|BASE
operator|>
name|BIG
operator|||
operator|(
operator|(
name|double
operator|)
name|BASE
operator|)
operator|+
name|BASE
operator|>
name|maxint
condition|)
block|{
name|printf
argument_list|(
literal|"*** BASE value wrong\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"#define tenlogBASE %d /\*  = log10(BASE) *\/\n"
argument_list|,
name|tenlogBASE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Maxreal %e /\* Maximum double *\/\n"
argument_list|,
name|Maxreal
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Maxexpo %d /\* Maximum value such that 2**Maxexpo<=Maxreal *\/\n"
argument_list|,
name|Maxexpo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Minexpo (%d) /\* Minimum value such that -2**Minexpo>=Minreal *\/\n"
argument_list|,
name|Minexpo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Dblbits %d /\* Maximum value such that 2**Dblbits<=BIG *\/\n"
argument_list|,
name|Dblbits
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Maxintlet %d /\* Maximum short *\/\n"
argument_list|,
name|maxshort
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Maxint %d /\* Maximum int *\/\n"
argument_list|,
name|maxint
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Maxsmallint %d /\* BASE-1 *\/\n"
argument_list|,
name|BASE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define Minsmallint (%d) /\* -BASE *\/\n"
argument_list|,
operator|-
name|BASE
argument_list|)
expr_stmt|;
comment|/* An extra goody: the approximate amount of data-space */
comment|/* Put here because it is likely to be slower then the rest */
comment|/*Allocate blocks of 1000 until no more available*/
comment|/*Don't be tempted to change this to 1024: */
comment|/*we don't know how much header information there is*/
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|(
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|1000
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|count
operator|++
control|)
block|{ }
name|printf
argument_list|(
literal|"\n/\* Memory~= %d000 *\/\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

