begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3sou.c,v 1.4 85/08/22 16:59:08 timo Exp $ */
end_comment

begin_comment
comment|/* Sources: maintaining units and values on external files */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b0fil.h"
end_include

begin_include
include|#
directive|include
file|"b1mem.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2par.h"
end_include

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3scr.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3sem.h"
end_include

begin_include
include|#
directive|include
file|"b3fil.h"
end_include

begin_include
include|#
directive|include
file|"b3sou.h"
end_include

begin_include
include|#
directive|include
file|"b3int.h"
end_include

begin_comment
comment|/************************** UNITS ************************************/
end_comment

begin_decl_stmt
name|Hidden
name|value
name|b_perm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table that maps tags to their file names */
end_comment

begin_decl_stmt
name|Hidden
name|value
name|b_units
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table that maps tags to their internal repr. */
end_comment

begin_function
name|Hidden
name|bool
name|u_exists
parameter_list|(
name|pname
parameter_list|,
name|aa
parameter_list|)
name|value
name|pname
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_block
block|{
return|return
name|in_env
argument_list|(
name|b_units
argument_list|,
name|pname
argument_list|,
name|aa
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|Procedure
name|def_unit
parameter_list|(
name|pname
parameter_list|,
name|u
parameter_list|)
name|value
name|pname
decl_stmt|,
name|u
decl_stmt|;
block|{
name|e_replace
argument_list|(
name|u
argument_list|,
operator|&
name|b_units
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|free_unit
parameter_list|(
name|pname
parameter_list|)
name|value
name|pname
decl_stmt|;
block|{
name|e_delete
argument_list|(
operator|&
name|b_units
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|del_units
parameter_list|()
block|{
name|int
name|len
init|=
name|length
argument_list|(
name|b_units
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|how
modifier|*
name|u
decl_stmt|;
for|for
control|(
name|k
operator|=
name|len
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
operator|--
name|k
control|)
block|{
comment|/* Reverse loop so deletions don't affect the numbering! */
name|u
operator|=
name|How_to
argument_list|(
operator|*
name|assoc
argument_list|(
name|b_units
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
operator|->
name|unparsed
condition|)
name|free_unit
argument_list|(
operator|*
name|key
argument_list|(
name|b_units
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
comment|/*Therefore standard B functions must be entered as unparsed*/
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|rem_unit
parameter_list|(
name|u
parameter_list|)
name|parsetree
name|u
decl_stmt|;
block|{
name|value
name|pname
init|=
name|get_pname
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|free_unit
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** */
end_comment

begin_function
name|Visible
name|Procedure
name|p_name_type
parameter_list|(
name|pname
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|value
name|pname
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|literal
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|name
operator|=
name|behead
argument_list|(
name|pname
argument_list|,
name|MkSmallInt
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|strval
argument_list|(
name|pname
argument_list|)
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'0'
case|:
operator|*
name|type
operator|=
name|Zer
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
operator|*
name|type
operator|=
name|Mon
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
operator|*
name|type
operator|=
name|Dya
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
operator|*
name|type
operator|=
name|How
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
operator|*
name|type
operator|=
name|Tar
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4000
argument_list|,
literal|"p_name_type"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_function
name|Visible
name|value
name|permkey
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
block|{
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
name|string
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Zer
case|:
name|t
operator|=
literal|"0"
expr_stmt|;
break|break;
case|case
name|Mon
case|:
name|t
operator|=
literal|"1"
expr_stmt|;
break|break;
case|case
name|Dya
case|:
name|t
operator|=
literal|"2"
expr_stmt|;
break|break;
case|case
name|How
case|:
name|t
operator|=
literal|"3"
expr_stmt|;
break|break;
case|case
name|Tar
case|:
name|t
operator|=
literal|"4"
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4001
argument_list|,
literal|"wrong permkey"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
name|mk_text
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|v
operator|=
name|concat
argument_list|(
name|w
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|p_exists
parameter_list|(
name|pname
parameter_list|,
name|aa
parameter_list|)
name|value
name|pname
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_block
block|{
return|return
name|in_env
argument_list|(
name|b_perm
argument_list|,
name|pname
argument_list|,
name|aa
argument_list|)
return|;
block|}
end_block

begin_decl_stmt
name|Visible
name|value
name|file_names
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|Procedure
name|def_perm
parameter_list|(
name|pname
parameter_list|,
name|f
parameter_list|)
name|value
name|pname
decl_stmt|,
name|f
decl_stmt|;
block|{
name|e_replace
argument_list|(
name|f
argument_list|,
operator|&
name|b_perm
argument_list|,
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
argument_list|(
name|f
argument_list|,
name|file_names
argument_list|)
condition|)
name|insert
argument_list|(
name|f
argument_list|,
operator|&
name|file_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|free_perm
parameter_list|(
name|pname
parameter_list|)
name|value
name|pname
decl_stmt|;
block|{
name|value
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
name|p_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
name|remove
argument_list|(
operator|*
name|aa
argument_list|,
operator|&
name|file_names
argument_list|)
expr_stmt|;
name|f_delete
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
name|e_delete
argument_list|(
operator|&
name|b_perm
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|value
name|get_fname
parameter_list|(
name|pname
parameter_list|)
name|value
name|pname
decl_stmt|;
block|{
name|value
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
name|p_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
return|return
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
return|;
else|else
block|{
name|value
name|fname
decl_stmt|,
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|p_name_type
argument_list|(
name|pname
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|fname
operator|=
name|new_fname
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|def_perm
argument_list|(
name|pname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|fname
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|bool
name|p_version
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|pname
parameter_list|)
name|value
name|name
decl_stmt|,
decl|*
name|pname
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|value
modifier|*
name|aa
decl_stmt|;
operator|*
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_exists
argument_list|(
operator|*
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
return|return
name|Yes
return|;
name|release
argument_list|(
operator|*
name|pname
argument_list|)
expr_stmt|;
operator|*
name|pname
operator|=
name|Vnil
expr_stmt|;
return|return
name|No
return|;
block|}
end_block

begin_function
name|Hidden
name|bool
name|how_unit
parameter_list|(
name|pname
parameter_list|)
name|value
name|pname
decl_stmt|;
block|{
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|p_name_type
argument_list|(
name|pname
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|type
operator|==
name|How
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|zermon_units
parameter_list|(
name|pname
parameter_list|,
name|other_pname
parameter_list|)
name|value
name|pname
decl_stmt|,
decl|*
name|other_pname
decl_stmt|;
end_function

begin_block
block|{
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|bool
name|is
decl_stmt|;
name|p_name_type
argument_list|(
name|pname
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|is
operator|=
operator|(
name|type
operator|==
name|Zer
operator|&&
name|p_version
argument_list|(
name|name
argument_list|,
name|Mon
argument_list|,
name|other_pname
argument_list|)
operator|)
operator|||
operator|(
name|type
operator|==
name|Mon
operator|&&
name|p_version
argument_list|(
name|name
argument_list|,
name|Zer
argument_list|,
name|other_pname
argument_list|)
operator|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|is
return|;
block|}
end_block

begin_comment
comment|/***********************************************************************/
end_comment

begin_function
name|Hidden
name|bool
name|is_loaded
parameter_list|(
name|pname
parameter_list|,
name|aa
parameter_list|)
name|value
name|pname
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_block
block|{
name|value
name|u
init|=
name|Vnil
decl_stmt|,
name|npname
init|=
name|Vnil
decl_stmt|,
name|get_unit
argument_list|()
decl_stmt|;
if|if
condition|(
name|u_exists
argument_list|(
name|pname
argument_list|,
name|aa
argument_list|)
condition|)
return|return
name|Yes
return|;
comment|/* already loaded */
if|if
condition|(
operator|!
name|p_exists
argument_list|(
name|pname
argument_list|,
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
name|ifile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
operator|*
operator|*
name|aa
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|==
name|NULL
condition|)
block|{
name|vs_ifile
argument_list|()
expr_stmt|;
return|return
name|No
return|;
block|}
name|Eof
operator|=
name|No
expr_stmt|;
name|first_ilev
argument_list|()
expr_stmt|;
name|u
operator|=
name|get_unit
argument_list|(
operator|&
name|npname
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|def_unit
argument_list|(
name|npname
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
name|Eof
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|still_ok
operator|&&
operator|!
name|u_exists
argument_list|(
name|pname
argument_list|,
name|aa
argument_list|)
condition|)
block|{
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|p_name_type
argument_list|(
name|npname
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|copy
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|curline
operator|=
name|How_to
argument_list|(
name|u
argument_list|)
operator|->
name|unit
expr_stmt|;
name|curlino
operator|=
name|one
expr_stmt|;
name|error2
argument_list|(
name|MESS
argument_list|(
literal|4002
argument_list|,
literal|"filename and unit name incompatible for "
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|npname
argument_list|)
expr_stmt|;
return|return
name|still_ok
return|;
block|}
end_block

begin_comment
comment|/* Does the unit exist without faults? */
end_comment

begin_function
name|Visible
name|bool
name|is_unit
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|aa
parameter_list|)
name|value
name|name
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|value
name|pname
decl_stmt|;
name|context
name|c
decl_stmt|;
name|bool
name|is
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|In_unit
expr_stmt|;
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|is
operator|=
name|is_loaded
argument_list|(
name|pname
argument_list|,
name|aa
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
return|return
name|is
return|;
block|}
end_block

begin_comment
comment|/***********************************************************************/
end_comment

begin_decl_stmt
name|Hidden
name|char
name|DISCARD
index|[]
init|=
literal|"the unit name is already in use;\n\ *** should the old unit be discarded?"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CANT_WRITE
define|\
value|MESS(4003, "cannot create file; need write permission in directory")
end_define

begin_define
define|#
directive|define
name|CANT_READ
value|MESS(4004, "unable to find file")
end_define

begin_define
define|#
directive|define
name|MON_VERSION
value|MESS(4005, " is already a monadic function/predicate")
end_define

begin_define
define|#
directive|define
name|ZER_VERSION
value|MESS(4006, " is already a zeroadic function/predicate")
end_define

begin_function
name|Hidden
name|Procedure
name|u_name_type
parameter_list|(
name|v
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|parsetree
name|v
decl_stmt|;
name|value
modifier|*
name|name
decl_stmt|;
name|literal
modifier|*
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|Nodetype
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
name|HOW_TO
case|:
operator|*
name|name
operator|=
name|copy
argument_list|(
operator|*
name|Branch
argument_list|(
name|v
argument_list|,
name|UNIT_NAME
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|How
expr_stmt|;
break|break;
case|case
name|YIELD
case|:
case|case
name|TEST
case|:
operator|*
name|name
operator|=
name|copy
argument_list|(
operator|*
name|Branch
argument_list|(
name|v
argument_list|,
name|UNIT_NAME
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intval
argument_list|(
operator|*
name|Branch
argument_list|(
name|v
argument_list|,
name|FPR_ADICITY
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|type
operator|=
name|Zer
expr_stmt|;
break|break;
case|case
literal|1
case|:
operator|*
name|type
operator|=
name|Mon
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|type
operator|=
name|Dya
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4007
argument_list|,
literal|"wrong adicity"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4008
argument_list|,
literal|"wrong nodetype of unit"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|value
name|get_unit
parameter_list|(
name|pname
parameter_list|,
name|filed
parameter_list|)
name|value
modifier|*
name|pname
decl_stmt|;
name|bool
name|filed
decl_stmt|;
block|{
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|parsetree
name|u
init|=
name|unit
argument_list|(
name|No
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|==
name|NilTree
condition|)
return|return
name|Vnil
return|;
name|u_name_type
argument_list|(
name|u
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
operator|*
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Nodetype
argument_list|(
name|u
argument_list|)
condition|)
block|{
case|case
name|HOW_TO
case|:
return|return
name|mk_how
argument_list|(
name|u
argument_list|,
name|filed
argument_list|)
return|;
case|case
name|YIELD
case|:
return|return
name|mk_fun
argument_list|(
name|type
argument_list|,
name|Use
argument_list|,
name|u
argument_list|,
name|filed
argument_list|)
return|;
case|case
name|TEST
case|:
return|return
name|mk_prd
argument_list|(
name|type
argument_list|,
name|Use
argument_list|,
name|u
argument_list|,
name|filed
argument_list|)
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4009
argument_list|,
literal|"wrong nodetype in 'get_unit'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|Visible
name|value
name|get_pname
parameter_list|(
name|v
parameter_list|)
name|parsetree
name|v
decl_stmt|;
block|{
name|value
name|pname
decl_stmt|,
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|u_name_type
argument_list|(
name|v
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|pname
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|get_heading
parameter_list|(
name|h
parameter_list|,
name|pname
parameter_list|)
name|parsetree
modifier|*
name|h
decl_stmt|;
name|value
modifier|*
name|pname
decl_stmt|;
block|{
operator|*
name|h
operator|=
name|unit
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
operator|*
name|pname
operator|=
name|still_ok
condition|?
name|get_pname
argument_list|(
operator|*
name|h
argument_list|)
else|:
name|Vnil
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a unit via the editor or from the input stream */
end_comment

begin_function
name|Visible
name|Procedure
name|create_unit
parameter_list|()
block|{
name|value
name|pname
init|=
name|Vnil
decl_stmt|,
modifier|*
name|aa
decl_stmt|;
name|parsetree
name|heading
init|=
name|NilTree
decl_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
name|value
name|v
init|=
name|get_unit
argument_list|(
operator|&
name|pname
argument_list|,
name|No
argument_list|)
decl_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|def_unit
argument_list|(
name|pname
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_heading
argument_list|(
operator|&
name|heading
argument_list|,
operator|&
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
block|{
name|value
name|v
decl_stmt|;
if|if
condition|(
name|p_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_intended
argument_list|(
name|DISCARD
argument_list|)
condition|)
block|{
name|free_unit
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|free_perm
argument_list|(
name|pname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|=
name|ceol
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|heading
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|zermon_units
argument_list|(
name|pname
argument_list|,
operator|&
name|v
argument_list|)
condition|)
block|{
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|p_name_type
argument_list|(
name|pname
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|curline
operator|=
name|heading
expr_stmt|;
name|curlino
operator|=
name|one
expr_stmt|;
name|error3
argument_list|(
literal|0
argument_list|,
name|name
argument_list|,
name|type
operator|==
name|Zer
condition|?
name|MON_VERSION
else|:
name|ZER_VERSION
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|still_ok
condition|)
block|{
name|value
name|fname
init|=
name|get_fname
argument_list|(
name|pname
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|ofile
init|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ofile
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|CANT_WRITE
argument_list|)
expr_stmt|;
else|else
block|{
name|txptr
name|tp
init|=
name|fcol
argument_list|()
decl_stmt|;
do|do
block|{
name|fputc
argument_list|(
name|Char
argument_list|(
name|tp
argument_list|)
argument_list|,
name|ofile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|Char
argument_list|(
name|tp
operator|++
argument_list|)
operator|!=
literal|'\n'
condition|)
do|;
name|f_close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|ed_unit
argument_list|(
name|pname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|heading
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************************/
end_comment

begin_comment
comment|/* Edit a unit. The name of the unit is either given, or is defaulted    to the last unit edited or the last unit that gave an error, whichever    was most recent.    It is possible for the user to mess things up with the w command, for    instance, but this is not checked. It is allowed to rename the unit though,    or delete it completely. If the file is empty, the unit is disposed of.    Otherwise, the name and adicity are determined and if these have changed,    the new unit is written out to a new file, and the original written back.    Thus the original is not lost.     Renaming, deleting, or changing the adicity of a test or yield    unfortunately requires all other units to be thrown away internally    (by del_units), since the unit parse trees may be wrong. For instance,    consider the effect on the following of making a formerly monadic    function f, into a zeroadic function: 	WRITE f root 2 */
end_comment

begin_decl_stmt
name|Hidden
name|char
name|ZEROADIC
index|[]
init|=
literal|"the unit name is in use both for a zeroadic and a dyadic version;\n\ *** do you want to edit the zeroadic version?"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|char
name|MONADIC
index|[]
init|=
literal|"the unit name is in use both for a monadic and a dyadic version;\n\ *** do you want to edit the monadic version?"
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|Procedure
name|edit_unit
parameter_list|()
block|{
name|value
name|name
init|=
name|Vnil
decl_stmt|,
name|pname
init|=
name|Vnil
decl_stmt|,
name|v
init|=
name|Vnil
decl_stmt|;
name|bool
name|ens_filed
parameter_list|()
function_decl|;
name|value
name|fname
decl_stmt|;
if|if
condition|(
name|Ceol
argument_list|(
name|tx
argument_list|)
condition|)
block|{
if|if
condition|(
name|erruname
operator|==
name|Vnil
condition|)
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|4010
argument_list|,
literal|"no current unit"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pname
operator|=
name|copy
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_keyword
argument_list|(
operator|&
name|name
argument_list|)
condition|)
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|How
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_tag
argument_list|(
operator|&
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_version
argument_list|(
name|name
argument_list|,
name|Zer
argument_list|,
operator|&
name|pname
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_version
argument_list|(
name|name
argument_list|,
name|Dya
argument_list|,
operator|&
name|v
argument_list|)
operator|&&
operator|!
name|is_intended
argument_list|(
name|ZEROADIC
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|pname
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_version
argument_list|(
name|name
argument_list|,
name|Mon
argument_list|,
operator|&
name|pname
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_version
argument_list|(
name|name
argument_list|,
name|Dya
argument_list|,
operator|&
name|v
argument_list|)
operator|&&
operator|!
name|is_intended
argument_list|(
name|MONADIC
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|pname
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|Dya
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|4011
argument_list|,
literal|"I find nothing editible here"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|still_ok
operator|&&
name|ens_filed
argument_list|(
name|pname
argument_list|,
operator|&
name|fname
argument_list|)
condition|)
block|{
name|ed_unit
argument_list|(
name|pname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|Hidden
name|char
name|NO_U_WRITE
index|[]
init|=
literal|"you have no write permission in this workspace: you may not change the unit\n\ *** do you still want to display the unit?"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|char
name|ZER_MON
index|[]
init|=
literal|"the unit name is already in use for a zeroadic function or predicate;\n\ *** should that unit be discarded?\n\ *** (if not you have to change the monadic unit name)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|char
name|MON_ZER
index|[]
init|=
literal|"the unit name is already in use for a monadic function or predicate;\n\ *** should that unit be discarded?\n\ *** (if not you have to change the zeroadic unit name)"
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|Procedure
name|ed_unit
parameter_list|(
name|pname
parameter_list|,
name|fname
parameter_list|)
name|value
name|pname
decl_stmt|,
name|fname
decl_stmt|;
block|{
name|value
name|sname
init|=
name|Vnil
decl_stmt|,
name|npname
init|=
name|Vnil
decl_stmt|,
name|nfname
init|=
name|Vnil
decl_stmt|;
name|value
name|u
decl_stmt|,
modifier|*
name|aa
decl_stmt|,
name|v
init|=
name|Vnil
decl_stmt|,
name|v_free
init|=
name|Vnil
decl_stmt|;
name|intlet
name|err_line
parameter_list|()
function_decl|;
name|bool
name|new_def
init|=
name|Yes
decl_stmt|,
name|same_name
init|=
name|No
decl_stmt|,
name|still_there
argument_list|()
decl_stmt|,
name|ed_again
init|=
name|No
decl_stmt|;
if|if
condition|(
operator|!
name|ws_writable
argument_list|()
operator|&&
operator|!
name|is_intended
argument_list|(
name|NO_U_WRITE
argument_list|)
condition|)
return|return;
name|sname
operator|=
name|f_save
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* in case the unit gets renamed */
if|if
condition|(
name|sname
operator|==
name|Vnil
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|4012
argument_list|,
literal|"can't save to temporary file"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|release
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uname
operator|=
name|copy
argument_list|(
name|pname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INTEGRATION
name|f_edit
argument_list|(
name|fname
argument_list|,
name|err_line
argument_list|(
name|pname
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|f_edit
argument_list|(
name|fname
argument_list|,
name|err_line
argument_list|(
name|pname
argument_list|)
argument_list|,
name|unit_prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|still_there
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|free_unit
argument_list|(
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|how_unit
argument_list|(
name|pname
argument_list|)
condition|)
name|del_units
argument_list|()
expr_stmt|;
name|release
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
name|erruname
operator|=
name|Vnil
expr_stmt|;
name|errlino
operator|=
literal|0
expr_stmt|;
name|free_perm
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|f_delete
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|sname
argument_list|)
expr_stmt|;
return|return;
block|}
name|first_ilev
argument_list|()
expr_stmt|;
name|u
operator|=
name|get_unit
argument_list|(
operator|&
name|npname
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
name|Eof
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|u
operator|==
name|Vnil
operator|||
name|npname
operator|==
name|Vnil
condition|)
name|new_def
operator|=
name|No
expr_stmt|;
elseif|else
if|if
condition|(
name|same_name
operator|=
name|compare
argument_list|(
name|pname
argument_list|,
name|npname
argument_list|)
operator|==
literal|0
condition|)
name|new_def
operator|=
name|p_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p_exists
argument_list|(
name|npname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
name|new_def
operator|=
name|is_intended
argument_list|(
name|DISCARD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zermon_units
argument_list|(
name|npname
argument_list|,
operator|&
name|v
argument_list|)
condition|)
block|{
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|p_name_type
argument_list|(
name|npname
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_def
operator|=
name|is_intended
argument_list|(
name|type
operator|==
name|Zer
condition|?
name|MON_ZER
else|:
name|ZER_MON
argument_list|)
condition|)
block|{
name|free_unit
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v_free
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* YIELD f => YIELD f x */
block|}
else|else
block|{
name|nfname
operator|=
name|new_fname
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|f_rename
argument_list|(
name|fname
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|ed_again
operator|=
name|Yes
expr_stmt|;
block|}
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_def
condition|)
block|{
if|if
condition|(
operator|!
name|how_unit
argument_list|(
name|npname
argument_list|)
condition|)
name|del_units
argument_list|()
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|def_unit
argument_list|(
name|npname
argument_list|,
name|u
argument_list|)
expr_stmt|;
else|else
name|free_unit
argument_list|(
name|npname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_name
condition|)
block|{
name|nfname
operator|=
name|get_fname
argument_list|(
name|npname
argument_list|)
expr_stmt|;
name|f_rename
argument_list|(
name|fname
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_free
condition|)
name|free_perm
argument_list|(
name|v_free
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|erruname
argument_list|)
expr_stmt|;
name|erruname
operator|=
name|copy
argument_list|(
name|npname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|same_name
condition|)
name|f_rename
argument_list|(
name|sname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|f_delete
argument_list|(
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
name|f_delete
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ed_again
condition|)
name|ed_unit
argument_list|(
name|npname
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|npname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|nfname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find out if the file exists, and is not empty. Some wretched editors    for some reason don't allow a file to be edited to empty, but insist it    should be at least one empty line. Thus an initial empty line may be    disregarded, but this is not harmful. */
end_comment

begin_function
name|Hidden
name|bool
name|still_there
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|ifile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|==
name|NULL
condition|)
block|{
name|vs_ifile
argument_list|()
expr_stmt|;
comment|/* error(CANT_READ); */
return|return
name|No
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|==
name|EOF
operator|||
operator|(
name|k
operator|==
literal|'\n'
operator|&&
operator|(
name|k
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|f_delete
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
return|return
name|No
return|;
block|}
name|ungetc
argument_list|(
name|k
argument_list|,
name|ifile
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
end_function

begin_comment
comment|/* Ensure the unit is filed. If the unit was read non-interactively (eg passed    as a parameter to b), it is only held in store.    Editing it puts it into a file. This is the safest way to copy a unit from    one workspace to another. */
end_comment

begin_function
name|Hidden
name|bool
name|ens_filed
parameter_list|(
name|pname
parameter_list|,
name|fname
parameter_list|)
name|value
name|pname
decl_stmt|,
decl|*
name|fname
decl_stmt|;
end_function

begin_block
block|{
name|value
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
name|p_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
operator|*
name|fname
operator|=
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|u_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
operator|||
name|How_to
argument_list|(
operator|*
name|aa
argument_list|)
operator|->
name|unit
operator|==
name|NilTree
condition|)
block|{
name|pprerr
argument_list|(
name|MESS
argument_list|(
literal|4013
argument_list|,
literal|"no such unit in this workspace"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
else|else
block|{
name|how
modifier|*
name|du
init|=
name|How_to
argument_list|(
operator|*
name|aa
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|ofile
decl_stmt|;
if|if
condition|(
name|du
operator|->
name|filed
operator|==
name|Yes
condition|)
block|{
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4014
argument_list|,
literal|"ens_filed()"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
operator|*
name|fname
operator|=
name|get_fname
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|ofile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
operator|*
name|fname
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ofile
condition|)
block|{
name|error
argument_list|(
name|CANT_WRITE
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|*
name|fname
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
else|else
block|{
name|display
argument_list|(
name|ofile
argument_list|,
name|du
operator|->
name|unit
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|f_close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|du
operator|->
name|filed
operator|=
name|Yes
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
block|}
end_block

begin_function
name|Hidden
name|intlet
name|err_line
parameter_list|(
name|pname
parameter_list|)
name|value
name|pname
decl_stmt|;
block|{
if|if
condition|(
name|errlino
operator|==
literal|0
operator|||
name|erruname
operator|==
name|Vnil
operator|||
name|compare
argument_list|(
name|erruname
argument_list|,
name|pname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|intlet
name|el
init|=
name|errlino
decl_stmt|;
name|errlino
operator|=
literal|0
expr_stmt|;
return|return
name|el
return|;
block|}
block|}
end_function

begin_comment
comment|/************************** VALUES ***************************************/
end_comment

begin_comment
comment|/* The permanent environment in the old format was kept as a single file */
end_comment

begin_comment
comment|/* but this caused slow start ups if the file was big.			 */
end_comment

begin_comment
comment|/* Thus the new version stores each permanent target on a separate file, */
end_comment

begin_comment
comment|/* that furthermore is only loaded on demand.				 */
end_comment

begin_comment
comment|/* To achieve this, a directory is kept of the permanent tags and their  */
end_comment

begin_comment
comment|/* file names. Care has to be taken that disaster occurring in		 */
end_comment

begin_comment
comment|/* the middle of an update of this directory does the least harm.	 */
end_comment

begin_comment
comment|/* Having the directory refer to a non-existent file is considered less  */
end_comment

begin_comment
comment|/* harmful than leaving a file around that can never be accessed, for	 */
end_comment

begin_comment
comment|/* instance, so a file is deleted before its directory entry,		 */
end_comment

begin_comment
comment|/* and so forth.							 */
end_comment

begin_comment
comment|/*************************************************************************/
end_comment

begin_function
name|Hidden
name|bool
name|t_exists
parameter_list|(
name|name
parameter_list|,
name|aa
parameter_list|)
name|value
name|name
decl_stmt|,
decl|*
modifier|*
name|aa
decl_stmt|;
end_function

begin_block
block|{
return|return
name|in_env
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|,
name|aa
argument_list|)
return|;
block|}
end_block

begin_function
name|Hidden
name|Procedure
name|def_target
parameter_list|(
name|name
parameter_list|,
name|t
parameter_list|)
name|value
name|name
decl_stmt|,
name|t
decl_stmt|;
block|{
name|e_replace
argument_list|(
name|t
argument_list|,
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|free_target
parameter_list|(
name|name
parameter_list|)
name|value
name|name
decl_stmt|;
block|{
name|e_delete
argument_list|(
operator|&
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|tarfiled
parameter_list|(
name|name
parameter_list|,
name|v
parameter_list|)
name|value
name|name
decl_stmt|,
name|v
decl_stmt|;
block|{
name|value
name|p
init|=
name|mk_per
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|def_target
argument_list|(
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|value
name|tarvalue
parameter_list|(
name|name
parameter_list|,
name|v
parameter_list|)
name|value
name|name
decl_stmt|,
name|v
decl_stmt|;
block|{
name|value
name|getval
parameter_list|()
function_decl|;
if|if
condition|(
name|Is_filed
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|per
modifier|*
name|p
init|=
name|Perm
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|val
operator|==
name|Vnil
condition|)
block|{
name|value
modifier|*
name|aa
decl_stmt|,
name|pname
init|=
name|permkey
argument_list|(
name|name
argument_list|,
name|Tar
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_exists
argument_list|(
name|pname
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4015
argument_list|,
literal|"tarvalue"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|p
operator|->
name|val
operator|=
name|getval
argument_list|(
operator|*
name|aa
argument_list|,
name|In_tarval
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|->
name|val
return|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_decl_stmt
name|Hidden
name|value
name|last_tname
init|=
name|Vnil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*last edited target */
end_comment

begin_function
name|Visible
name|Procedure
name|edit_target
parameter_list|()
block|{
name|value
name|name
init|=
name|Vnil
decl_stmt|;
name|bool
name|ens_tfiled
parameter_list|()
function_decl|;
name|value
name|fname
decl_stmt|;
if|if
condition|(
name|Ceol
argument_list|(
name|tx
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_tname
operator|==
name|Vnil
condition|)
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|4016
argument_list|,
literal|"no current target"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|copy
argument_list|(
name|last_tname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_tag
argument_list|(
operator|&
name|name
argument_list|)
condition|)
name|parerr
argument_list|(
name|MESS
argument_list|(
literal|4017
argument_list|,
literal|"I find nothing editible here"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
operator|&&
name|ens_tfiled
argument_list|(
name|name
argument_list|,
operator|&
name|fname
argument_list|)
condition|)
block|{
name|ed_target
argument_list|(
name|name
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|Hidden
name|char
name|NO_T_WRITE
index|[]
init|=
literal|"you have no write permission in this workspace: you may not change the target\n\ *** do you still want to display the target?"
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|Procedure
name|ed_target
parameter_list|(
name|name
parameter_list|,
name|fname
parameter_list|)
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
block|{
comment|/* Edit a target. The value in the target is written to the file, 	   and then removed from the internal permanent environment so that 	   if a syntax error occurs when reading the value back, the value is 	   absent from the internal permanent environment. 	   Thus when editing the file to correct the syntax error, the 	   file doesn't get overwritten. 	   The contents may be completely deleted in which case the target is 	   deleted. 	*/
name|value
name|v
decl_stmt|,
name|getval
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ws_writable
argument_list|()
operator|&&
operator|!
name|is_intended
argument_list|(
name|NO_T_WRITE
argument_list|)
condition|)
return|return;
ifndef|#
directive|ifndef
name|INTEGRATION
name|f_edit
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|f_edit
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|,
name|tar_prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|still_there
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|value
name|pname
init|=
name|permkey
argument_list|(
name|name
argument_list|,
name|Tar
argument_list|)
decl_stmt|;
name|free_target
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free_perm
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|last_tname
argument_list|)
expr_stmt|;
name|last_tname
operator|=
name|Vnil
expr_stmt|;
return|return;
block|}
name|release
argument_list|(
name|last_tname
argument_list|)
expr_stmt|;
name|last_tname
operator|=
name|copy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
comment|/*since still_there leaves it open*/
name|v
operator|=
name|getval
argument_list|(
name|fname
argument_list|,
name|In_edval
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|def_target
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|ens_tfiled
parameter_list|(
name|name
parameter_list|,
name|fname
parameter_list|)
name|value
name|name
decl_stmt|,
decl|*
name|fname
decl_stmt|;
end_function

begin_block
block|{
name|value
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
operator|!
name|t_exists
argument_list|(
name|name
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
name|pprerr
argument_list|(
name|MESS
argument_list|(
literal|4018
argument_list|,
literal|"no such target in this workspace"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
else|else
block|{
name|value
name|pname
init|=
name|permkey
argument_list|(
name|name
argument_list|,
name|Tar
argument_list|)
decl_stmt|;
operator|*
name|fname
operator|=
name|get_fname
argument_list|(
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_filed
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
block|{
name|putval
argument_list|(
operator|*
name|fname
argument_list|,
operator|*
name|aa
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|tarfiled
argument_list|(
name|name
argument_list|,
operator|*
name|aa
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
end_block

begin_comment
comment|/***************************** Values on files ****************************/
end_comment

begin_function
name|Hidden
name|value
name|getval
parameter_list|(
name|fname
parameter_list|,
name|ct
parameter_list|)
name|value
name|fname
decl_stmt|;
name|literal
name|ct
decl_stmt|;
comment|/* context */
block|{
name|char
modifier|*
name|buf
init|=
name|Nil
decl_stmt|;
name|int
name|k
decl_stmt|;
name|parsetree
name|e
decl_stmt|,
name|code
decl_stmt|;
name|value
name|v
init|=
name|Vnil
decl_stmt|;
name|ifile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
condition|)
block|{
name|txptr
name|fcol_save
init|=
name|first_col
decl_stmt|,
name|tx_save
init|=
name|tx
decl_stmt|;
name|context
name|c
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|cntxt
operator|=
name|ct
expr_stmt|;
name|buf
operator|=
name|getmem
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|f_size
argument_list|(
name|ifile
argument_list|)
operator|+
literal|2
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|Nil
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|4019
argument_list|,
literal|"can't get buffer to read file"
argument_list|)
argument_list|)
expr_stmt|;
name|first_col
operator|=
name|tx
operator|=
name|ceol
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|k
operator|!=
literal|'\n'
condition|)
operator|*
name|ceol
operator|++
operator|=
name|k
expr_stmt|;
operator|*
name|ceol
operator|=
literal|'\n'
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
name|e
operator|=
name|expr
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|fix_nodes
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|curline
operator|=
name|e
expr_stmt|;
name|curlino
operator|=
name|one
expr_stmt|;
name|v
operator|=
name|evalthread
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|curline
operator|=
name|Vnil
expr_stmt|;
name|release
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|Nil
condition|)
name|freemem
argument_list|(
operator|(
name|ptr
operator|)
name|buf
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|first_col
operator|=
name|fcol_save
expr_stmt|;
name|tx
operator|=
name|tx_save
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|CANT_READ
argument_list|)
expr_stmt|;
name|vs_ifile
argument_list|()
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|getprmnv
parameter_list|()
block|{
name|intlet
name|k
decl_stmt|,
name|len
decl_stmt|;
name|value
name|name
decl_stmt|,
name|fname
decl_stmt|;
name|literal
name|type
decl_stmt|;
if|if
condition|(
name|f_exists
argument_list|(
name|BPERMFILE
argument_list|)
condition|)
block|{
name|value
name|fn
decl_stmt|;
name|fn
operator|=
name|mk_text
argument_list|(
name|BPERMFILE
argument_list|)
expr_stmt|;
name|b_perm
operator|=
name|getval
argument_list|(
name|fn
argument_list|,
name|In_prmnv
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|length
argument_list|(
name|b_perm
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|p_name_type
argument_list|(
operator|*
name|key
argument_list|(
name|b_perm
argument_list|,
name|k
argument_list|)
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|Tar
condition|)
name|tarfiled
argument_list|(
name|name
argument_list|,
name|Vnil
argument_list|)
expr_stmt|;
name|fname
operator|=
name|copy
argument_list|(
operator|*
name|assoc
argument_list|(
name|b_perm
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|fname
argument_list|,
operator|&
name|file_names
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|b_perm
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CONVERSION
if|if
condition|(
name|f_exists
argument_list|(
name|PRMNVFILE
argument_list|)
condition|)
block|{
comment|/* convert from old to new format */
name|value
name|tab
decl_stmt|,
name|v
decl_stmt|,
name|pname
decl_stmt|,
name|new_fname
argument_list|()
decl_stmt|;
name|value
name|fn
init|=
name|mk_text
argument_list|(
name|PRMNVFILE
argument_list|)
decl_stmt|,
name|save
init|=
name|mk_text
argument_list|(
name|SAVEPRMNVFILE
argument_list|)
decl_stmt|;
name|tab
operator|=
name|getval
argument_list|(
name|fn
argument_list|,
name|In_prmnv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|length
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|name
operator|=
name|copy
argument_list|(
operator|*
name|key
argument_list|(
name|tab
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|copy
argument_list|(
operator|*
name|assoc
argument_list|(
name|tab
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|def_target
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|Tar
argument_list|)
expr_stmt|;
name|fname
operator|=
name|get_fname
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|putval
argument_list|(
name|fname
argument_list|,
name|v
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|tarfiled
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
block|}
name|f_rename
argument_list|(
name|fn
argument_list|,
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"*** [Old permanent environment converted]\n"
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|CONVERSION
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|putval
parameter_list|(
name|fname
parameter_list|,
name|v
parameter_list|,
name|silently
parameter_list|)
name|value
name|fname
decl_stmt|,
name|v
decl_stmt|;
name|bool
name|silently
decl_stmt|;
block|{
name|FILE
modifier|*
name|ofile
decl_stmt|;
name|value
name|fn
init|=
name|mk_text
argument_list|(
name|tempfile
argument_list|)
decl_stmt|;
name|bool
name|was_ok
init|=
name|still_ok
decl_stmt|;
name|ofile
operator|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fn
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofile
operator|!=
name|NULL
condition|)
block|{
name|redirect
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|still_ok
operator|=
name|Yes
expr_stmt|;
name|wri
argument_list|(
name|v
argument_list|,
name|No
argument_list|,
name|No
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|f_close
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|redirect
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
name|f_rename
argument_list|(
name|fn
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|silently
condition|)
name|error
argument_list|(
name|CANT_WRITE
argument_list|)
expr_stmt|;
name|still_ok
operator|=
name|was_ok
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|putprmnv
parameter_list|()
block|{
specifier|static
name|bool
name|active
decl_stmt|;
name|value
name|v
decl_stmt|,
name|name
decl_stmt|,
name|fname
decl_stmt|,
name|fn
decl_stmt|,
modifier|*
name|aa
decl_stmt|,
name|pname
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|active
condition|)
return|return;
name|active
operator|=
name|Yes
expr_stmt|;
name|len
operator|=
name|length
argument_list|(
name|b_perm
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|len
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
operator|--
name|k
control|)
block|{
name|p_name_type
argument_list|(
operator|*
name|key
argument_list|(
name|b_perm
argument_list|,
name|k
argument_list|)
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|Tar
operator|&&
operator|!
name|t_exists
argument_list|(
name|name
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
name|free_perm
argument_list|(
operator|*
name|key
argument_list|(
name|b_perm
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|length
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|v
operator|=
name|copy
argument_list|(
operator|*
name|assoc
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_filed
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|name
operator|=
name|copy
argument_list|(
operator|*
name|key
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|pname
operator|=
name|permkey
argument_list|(
name|name
argument_list|,
name|Tar
argument_list|)
expr_stmt|;
name|fname
operator|=
name|get_fname
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|putval
argument_list|(
name|fname
argument_list|,
name|v
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|tarfiled
argument_list|(
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|mk_text
argument_list|(
name|BPERMFILE
argument_list|)
expr_stmt|;
name|putval
argument_list|(
name|fn
argument_list|,
name|b_perm
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
comment|/* Remove the file if the permanent environment is empty */
if|if
condition|(
name|length
argument_list|(
name|b_perm
argument_list|)
operator|==
literal|0
condition|)
name|f_delete
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|active
operator|=
name|No
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|initsou
parameter_list|()
block|{
name|b_units
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
name|file_names
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|endsou
parameter_list|()
block|{
comment|/* Release everything around so "memory leakage" can be detected */
name|release
argument_list|(
name|b_units
argument_list|)
expr_stmt|;
name|b_units
operator|=
name|Vnil
expr_stmt|;
name|release
argument_list|(
name|b_perm
argument_list|)
expr_stmt|;
name|b_perm
operator|=
name|Vnil
expr_stmt|;
name|release
argument_list|(
name|file_names
argument_list|)
expr_stmt|;
name|file_names
operator|=
name|Vnil
expr_stmt|;
name|release
argument_list|(
name|last_tname
argument_list|)
expr_stmt|;
name|last_tname
operator|=
name|Vnil
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|lst_uhds
parameter_list|()
block|{
name|intlet
name|k
decl_stmt|,
name|len
init|=
name|length
argument_list|(
name|b_perm
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
name|k_Over_len
block|{
name|p_name_type
argument_list|(
operator|*
name|key
argument_list|(
name|b_perm
argument_list|,
name|k
argument_list|)
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|Tar
condition|)
block|{
name|FILE
modifier|*
name|fn
init|=
name|fopen
argument_list|(
name|strval
argument_list|(
operator|*
name|assoc
argument_list|(
name|b_perm
argument_list|,
name|k
argument_list|)
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fn
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|length
argument_list|(
name|b_units
argument_list|)
expr_stmt|;
name|k_Over_len
block|{
name|how
modifier|*
name|u
init|=
name|How_to
argument_list|(
operator|*
name|assoc
argument_list|(
name|b_units
argument_list|,
name|k
argument_list|)
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|TRY
name|value
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
name|u
operator|->
name|filed
operator|==
name|No
operator|&&
operator|!
name|p_exists
argument_list|(
operator|*
name|key
argument_list|(
name|b_units
argument_list|,
name|k
argument_list|)
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|u
operator|->
name|filed
operator|==
name|No
condition|)
endif|#
directive|endif
name|display
argument_list|(
name|stdout
argument_list|,
name|u
operator|->
name|unit
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

