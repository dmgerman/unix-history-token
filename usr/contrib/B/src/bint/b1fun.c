begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1fun.c,v 1.4 85/08/22 16:48:24 timo Exp $ */
end_comment

begin_comment
comment|/* Functions defined on numeric values. */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* For EDOM and ERANGE */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b1num.h"
end_include

begin_comment
comment|/*  * The visible routines here implement predefined B arithmetic operators,  * taking one or two numeric values as operands, and returning a numeric  * value.  * No type checking of operands is done: this must be done by the caller.  */
end_comment

begin_typedef
typedef|typedef
name|value
function_decl|(
modifier|*
name|valfun
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|rational
function_decl|(
modifier|*
name|ratfun
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|real
function_decl|(
modifier|*
name|appfun
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|double
function_decl|(
modifier|*
name|mathfun
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_comment
comment|/*  * For the arithmetic functions (+, -, *, /) the same action is needed:  * 1) if both operands are Integral, use function from int_* submodule;  * 2) if both are Exact, use function from rat_* submodule (after possibly  *    converting one of them from Integral to Rational);  * 3) otherwise, make both approximate and use function from app_*  *    submodule.  * The functions performing the appropriate action for each of the submodules  * are passed as parameters.  * Division is a slight exception, since i/j can be a rational.  * See `quot' below.  */
end_comment

begin_function
name|Hidden
name|value
name|dyop
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|,
name|int_fun
parameter_list|,
name|rat_fun
parameter_list|,
name|app_fun
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
name|valfun
name|int_fun
decl_stmt|;
name|ratfun
name|rat_fun
decl_stmt|;
name|appfun
name|app_fun
decl_stmt|;
block|{
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
operator|&&
name|Integral
argument_list|(
name|v
argument_list|)
condition|)
comment|/* Use integral operation */
return|return
call|(
modifier|*
name|int_fun
call|)
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
if|if
condition|(
name|Exact
argument_list|(
name|u
argument_list|)
operator|&&
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|rational
name|u1
decl_stmt|,
name|v1
decl_stmt|,
name|a
decl_stmt|;
comment|/* Use rational operation */
name|u1
operator|=
name|Integral
argument_list|(
name|u
argument_list|)
condition|?
name|mk_rat
argument_list|(
operator|(
name|integer
operator|)
name|u
argument_list|,
name|int_1
argument_list|,
literal|0
argument_list|)
else|:
operator|(
name|rational
operator|)
name|Copy
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|v1
operator|=
name|Integral
argument_list|(
name|v
argument_list|)
condition|?
name|mk_rat
argument_list|(
operator|(
name|integer
operator|)
name|v
argument_list|,
name|int_1
argument_list|,
literal|0
argument_list|)
else|:
operator|(
name|rational
operator|)
name|Copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|a
operator|=
call|(
modifier|*
name|rat_fun
call|)
argument_list|(
name|u1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|u1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|v1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Denominator
argument_list|(
name|a
argument_list|)
operator|==
name|int_1
operator|&&
name|Roundsize
argument_list|(
name|a
argument_list|)
operator|==
literal|0
condition|)
block|{
name|integer
name|b
init|=
operator|(
name|integer
operator|)
name|Copy
argument_list|(
name|Numerator
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|b
return|;
block|}
return|return
operator|(
name|value
operator|)
name|a
return|;
block|}
comment|/* Use approximate operation */
block|{
name|real
name|u1
decl_stmt|,
name|v1
decl_stmt|,
name|a
decl_stmt|;
name|u1
operator|=
name|Approximate
argument_list|(
name|u
argument_list|)
condition|?
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|u
argument_list|)
else|:
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|v1
operator|=
name|Approximate
argument_list|(
name|v
argument_list|)
condition|?
operator|(
name|real
operator|)
name|Copy
argument_list|(
name|v
argument_list|)
else|:
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|a
operator|=
call|(
modifier|*
name|app_fun
call|)
argument_list|(
name|u1
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|u1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|v1
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|a
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|integer
name|isum
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|integer
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
return|return
name|int_sum
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|sum
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
if|if
condition|(
name|IsSmallInt
argument_list|(
name|u
argument_list|)
operator|&&
name|IsSmallInt
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|mk_integer
argument_list|(
name|SmallIntVal
argument_list|(
name|u
argument_list|)
operator|+
name|SmallIntVal
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
return|return
name|dyop
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|(
name|value
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|isum
argument_list|,
name|rat_sum
argument_list|,
name|app_sum
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|integer
name|idiff
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|integer
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
return|return
name|int_diff
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|diff
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
if|if
condition|(
name|IsSmallInt
argument_list|(
name|u
argument_list|)
operator|&&
name|IsSmallInt
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|mk_integer
argument_list|(
name|SmallIntVal
argument_list|(
name|u
argument_list|)
operator|-
name|SmallIntVal
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
return|return
name|dyop
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|(
name|value
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|idiff
argument_list|,
name|rat_diff
argument_list|,
name|app_diff
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|prod
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
if|if
condition|(
name|IsSmallInt
argument_list|(
name|u
argument_list|)
operator|&&
name|IsSmallInt
argument_list|(
name|v
argument_list|)
condition|)
return|return
operator|(
name|value
operator|)
name|mk_int
argument_list|(
operator|(
name|double
operator|)
name|SmallIntVal
argument_list|(
name|u
argument_list|)
operator|*
operator|(
name|double
operator|)
name|SmallIntVal
argument_list|(
name|v
argument_list|)
argument_list|)
return|;
return|return
name|dyop
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
operator|(
name|value
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|int_prod
argument_list|,
name|rat_prod
argument_list|,
name|app_prod
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * We cannot use int_quot (which performs integer division with truncation).  * Here is the routine we need.  */
end_comment

begin_function
name|Hidden
name|value
name|xxx_quot
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|integer
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|==
name|int_0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|400
argument_list|,
literal|"in i/j, j is zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|Copy
argument_list|(
name|u
argument_list|)
return|;
block|}
return|return
name|mk_exact
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|quot
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
return|return
name|dyop
argument_list|(
name|u
argument_list|,
name|v
argument_list|,
name|xxx_quot
argument_list|,
name|rat_quot
argument_list|,
name|app_quot
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unary minus and abs follow the same principle but with only one operand.  */
end_comment

begin_function
name|Visible
name|value
name|negated
parameter_list|(
name|u
parameter_list|)
name|value
name|u
decl_stmt|;
block|{
if|if
condition|(
name|IsSmallInt
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|mk_integer
argument_list|(
operator|-
name|SmallIntVal
argument_list|(
name|u
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
condition|)
return|return
operator|(
name|value
operator|)
name|int_neg
argument_list|(
operator|(
name|integer
operator|)
name|u
argument_list|)
return|;
if|if
condition|(
name|Rational
argument_list|(
name|u
argument_list|)
condition|)
return|return
operator|(
name|value
operator|)
name|rat_neg
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|)
return|;
return|return
operator|(
name|value
operator|)
name|app_neg
argument_list|(
operator|(
name|real
operator|)
name|u
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|absval
parameter_list|(
name|u
parameter_list|)
name|value
name|u
decl_stmt|;
block|{
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
condition|)
block|{
if|if
condition|(
name|Msd
argument_list|(
operator|(
name|integer
operator|)
name|u
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|value
operator|)
name|int_neg
argument_list|(
operator|(
name|integer
operator|)
name|u
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Rational
argument_list|(
name|u
argument_list|)
condition|)
block|{
if|if
condition|(
name|Msd
argument_list|(
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|value
operator|)
name|rat_neg
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Approximate
argument_list|(
name|u
argument_list|)
operator|&&
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|u
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|value
operator|)
name|app_neg
argument_list|(
operator|(
name|real
operator|)
name|u
argument_list|)
return|;
return|return
name|Copy
argument_list|(
name|u
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * The remaining operators follow less similar paths and some of  * them contain quite subtle code.  */
end_comment

begin_function
name|Visible
name|value
name|mod
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|value
name|p
decl_stmt|,
name|q
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
name|value
operator|)
name|int_0
operator|||
name|Rational
argument_list|(
name|v
argument_list|)
operator|&&
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
operator|==
name|int_0
operator|||
name|Approximate
argument_list|(
name|v
argument_list|)
operator|&&
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|v
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|401
argument_list|,
literal|"in x mod y, y is zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Copy
argument_list|(
name|u
argument_list|)
return|;
block|}
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
operator|&&
name|Integral
argument_list|(
name|v
argument_list|)
condition|)
return|return
operator|(
name|value
operator|)
name|int_mod
argument_list|(
operator|(
name|integer
operator|)
name|u
argument_list|,
operator|(
name|integer
operator|)
name|v
argument_list|)
return|;
comment|/* Compute `u-v*floor(u/v)', as in the formal definition of `u mod v'. */
name|q
operator|=
name|quot
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|n
operator|=
name|floorf
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|p
operator|=
name|prod
argument_list|(
name|n
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|m
operator|=
name|diff
argument_list|(
name|u
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * u**v has the most special cases of all the predefined arithmetic functions.  */
end_comment

begin_function
name|Visible
name|value
name|power
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|real
name|ru
decl_stmt|,
name|rv
decl_stmt|,
name|rw
decl_stmt|;
if|if
condition|(
name|Exact
argument_list|(
name|u
argument_list|)
operator|&&
operator|(
name|Integral
argument_list|(
name|v
argument_list|)
operator|||
comment|/* Next check catches for integers disguised as rationals: */
name|Rational
argument_list|(
name|v
argument_list|)
operator|&&
name|Denominator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
operator|==
name|int_1
operator|)
condition|)
block|{
name|rational
name|a
decl_stmt|;
name|integer
name|b
init|=
name|Integral
argument_list|(
name|v
argument_list|)
condition|?
operator|(
name|integer
operator|)
name|v
else|:
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
decl_stmt|;
comment|/* Now b is really an integer. */
name|u
operator|=
name|Integral
argument_list|(
name|u
argument_list|)
condition|?
operator|(
name|value
operator|)
name|mk_rat
argument_list|(
operator|(
name|integer
operator|)
name|u
argument_list|,
name|int_1
argument_list|,
literal|0
argument_list|)
else|:
name|Copy
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|a
operator|=
name|rat_power
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|Denominator
argument_list|(
name|a
argument_list|)
operator|==
name|int_1
condition|)
block|{
comment|/* Make integral result */
name|b
operator|=
operator|(
name|integer
operator|)
name|Copy
argument_list|(
name|Numerator
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|b
return|;
block|}
return|return
operator|(
name|value
operator|)
name|a
return|;
block|}
if|if
condition|(
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|integer
name|vn
decl_stmt|,
name|vd
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ru
operator|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|Frac
argument_list|(
name|ru
argument_list|)
operator|>
literal|0
operator|)
operator|-
operator|(
name|Frac
argument_list|(
name|ru
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
name|rv
operator|=
name|app_neg
argument_list|(
name|ru
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|ru
argument_list|)
operator|,
name|ru
operator|=
name|rv
expr_stmt|;
if|if
condition|(
name|Integral
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|vn
operator|=
operator|(
name|integer
operator|)
name|v
expr_stmt|;
name|vd
operator|=
name|int_1
expr_stmt|;
block|}
else|else
block|{
name|vd
operator|=
name|Denominator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
operator|&&
name|Even
argument_list|(
name|Lsd
argument_list|(
name|vd
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|402
argument_list|,
literal|"in x**(p/q), x is negative and q is even"
argument_list|)
argument_list|)
expr_stmt|;
name|vn
operator|=
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vn
operator|==
name|int_0
condition|)
block|{
name|release
argument_list|(
operator|(
name|value
operator|)
name|ru
argument_list|)
expr_stmt|;
return|return
name|one
return|;
block|}
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|Msd
argument_list|(
name|vn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|403
argument_list|,
literal|"in 0**y, y is negative"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|ru
return|;
block|}
if|if
condition|(
name|s
operator|<
literal|0
operator|&&
name|Even
argument_list|(
name|Lsd
argument_list|(
name|vn
argument_list|)
argument_list|)
condition|)
name|s
operator|=
literal|1
expr_stmt|;
name|rv
operator|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|rw
operator|=
name|app_power
argument_list|(
name|ru
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|ru
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
name|ru
operator|=
name|app_neg
argument_list|(
name|rw
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|rw
argument_list|)
operator|,
name|rw
operator|=
name|ru
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|rw
return|;
block|}
comment|/* Everything else: we now know u or v is approximate */
name|ru
operator|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|Frac
argument_list|(
name|ru
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|404
argument_list|,
literal|"in x**y, x is negative and y is not exact"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|ru
return|;
block|}
name|rv
operator|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|Frac
argument_list|(
name|ru
argument_list|)
operator|==
literal|0
operator|&&
name|Frac
argument_list|(
name|rv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|405
argument_list|,
literal|"in 0**y, y is negative"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|ru
return|;
block|}
name|rw
operator|=
name|app_power
argument_list|(
name|ru
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|ru
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|rw
return|;
block|}
end_function

begin_comment
comment|/*  * floor: for approximate numbers app_floor() is used;  * for integers it is a no-op; other exact numbers effectively calculate  * u - (u mod 1).  */
end_comment

begin_function
name|Visible
name|value
name|floorf
parameter_list|(
name|u
parameter_list|)
name|value
name|u
decl_stmt|;
block|{
name|integer
name|quo
decl_stmt|,
name|rem
decl_stmt|,
name|v
decl_stmt|;
name|digit
name|div
decl_stmt|;
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|Copy
argument_list|(
name|u
argument_list|)
return|;
if|if
condition|(
name|Approximate
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|app_floor
argument_list|(
operator|(
name|real
operator|)
name|u
argument_list|)
return|;
comment|/* It is a rational number */
name|div
operator|=
name|int_ldiv
argument_list|(
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|)
argument_list|,
name|Denominator
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|)
argument_list|,
operator|&
name|quo
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|div
operator|<
literal|0
operator|&&
name|rem
operator|!=
name|int_0
condition|)
block|{
comment|/* Correction for negative noninteger */
name|v
operator|=
name|int_diff
argument_list|(
name|quo
argument_list|,
name|int_1
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|quo
argument_list|)
expr_stmt|;
name|quo
operator|=
name|v
expr_stmt|;
block|}
name|release
argument_list|(
operator|(
name|value
operator|)
name|rem
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|quo
return|;
block|}
end_function

begin_comment
comment|/*  * ceiling x is defined as -floor(-x);  * and that's how it's implemented, except for integers.  */
end_comment

begin_function
name|Visible
name|value
name|ceilf
parameter_list|(
name|u
parameter_list|)
name|value
name|u
decl_stmt|;
block|{
name|value
name|v
decl_stmt|;
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|Copy
argument_list|(
name|u
argument_list|)
return|;
name|u
operator|=
name|negated
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|v
operator|=
name|floorf
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
name|negated
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|u
return|;
block|}
end_function

begin_comment
comment|/*  * round u is defined as floor(u+0.5), which is what is done here,  * except for integers which are left unchanged.  */
end_comment

begin_function
name|Visible
name|value
name|round1
parameter_list|(
name|u
parameter_list|)
name|value
name|u
decl_stmt|;
block|{
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|Copy
argument_list|(
name|u
argument_list|)
return|;
name|v
operator|=
name|sum
argument_list|(
name|u
argument_list|,
operator|(
name|value
operator|)
name|rat_half
argument_list|)
expr_stmt|;
name|w
operator|=
name|floorf
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/*  * u round v is defined as 10**-u * round(v*10**u).  * A complication is that u round v is always printed with exactly u digits  * after the decimal point, even if this involves trailing zeros,  * or if v is an integer.  * Consequently, the result is always kept as a rational, even if it can be  * simplified to an integer, and the size field of the rational number  * (which is made negative to distinguish it from integers, and< -1 to  * distinguish it from approximate numbers) is used to store the number of  * significant digits.  * Thus a size of -2 means a normal rational number, and a size< -2  * means a rounded number to be printed with (-2 - length) digits  * after the decimal point.  This last expression can be retrieved using  * the macro Roundsize(v) which should only be applied to Rational  * numbers.  */
end_comment

begin_function
name|Visible
name|value
name|round2
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|value
name|w
decl_stmt|,
name|tenp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|Integral
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|406
argument_list|,
literal|"in n round x, n is not an integer"
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|=
name|propintlet
argument_list|(
name|intval
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|tenp
operator|=
name|tento
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|v
operator|=
name|prod
argument_list|(
name|v
argument_list|,
name|tenp
argument_list|)
expr_stmt|;
name|w
operator|=
name|round1
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|quot
argument_list|(
name|w
argument_list|,
name|tenp
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|tenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* Set number of digits to be printed */
if|if
condition|(
name|propintlet
argument_list|(
operator|-
literal|2
operator|-
name|i
argument_list|)
operator|<
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|Rational
argument_list|(
name|v
argument_list|)
condition|)
name|Length
argument_list|(
name|v
argument_list|)
operator|=
operator|-
literal|2
operator|-
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|Integral
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|w
operator|=
name|v
expr_stmt|;
name|v
operator|=
name|mk_exact
argument_list|(
operator|(
name|integer
operator|)
name|w
argument_list|,
name|int_1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * sign u inspects the sign of either u, u's numerator or u's fractional part.  */
end_comment

begin_function
name|Visible
name|value
name|signum
parameter_list|(
name|u
parameter_list|)
name|value
name|u
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|Exact
argument_list|(
name|u
argument_list|)
condition|)
block|{
if|if
condition|(
name|Rational
argument_list|(
name|u
argument_list|)
condition|)
name|u
operator|=
operator|(
name|value
operator|)
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|)
expr_stmt|;
name|s
operator|=
name|u
operator|==
operator|(
name|value
operator|)
name|int_0
condition|?
literal|0
else|:
name|Msd
argument_list|(
operator|(
name|integer
operator|)
name|u
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
else|else
name|s
operator|=
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|u
argument_list|)
operator|>
literal|0
condition|?
literal|1
else|:
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|u
argument_list|)
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|MkSmallInt
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ~u makes an approximate number of any numerical value.  */
end_comment

begin_function
name|Visible
name|value
name|approximate
parameter_list|(
name|u
parameter_list|)
name|value
name|u
decl_stmt|;
block|{
name|double
name|x
decl_stmt|,
name|e
decl_stmt|,
name|expo
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Approximate
argument_list|(
name|u
argument_list|)
condition|)
return|return
name|Copy
argument_list|(
name|u
argument_list|)
return|;
if|if
condition|(
name|IsSmallInt
argument_list|(
name|u
argument_list|)
condition|)
name|x
operator|=
name|SmallIntVal
argument_list|(
name|u
argument_list|)
operator|,
name|expo
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|Rational
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|rational
name|r
init|=
operator|(
name|rational
operator|)
name|u
decl_stmt|;
name|integer
name|p
init|=
name|Numerator
argument_list|(
name|r
argument_list|)
decl_stmt|,
name|q
decl_stmt|;
name|double
name|xp
decl_stmt|,
name|xq
decl_stmt|;
name|int
name|lp
decl_stmt|,
name|lq
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|int_0
condition|)
return|return
name|Copy
argument_list|(
operator|(
name|value
operator|)
name|app_0
argument_list|)
return|;
name|q
operator|=
name|Denominator
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|lp
operator|=
name|IsSmallInt
argument_list|(
name|p
argument_list|)
condition|?
literal|1
else|:
name|Length
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lq
operator|=
name|IsSmallInt
argument_list|(
name|q
argument_list|)
condition|?
literal|1
else|:
name|Length
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|xp
operator|=
literal|0
operator|,
name|xq
operator|=
literal|0
expr_stmt|;
name|expo
operator|=
name|lp
operator|-
name|lq
expr_stmt|;
if|if
condition|(
name|IsSmallInt
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|xp
operator|=
name|SmallIntVal
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|expo
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|p
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|xp
operator|=
name|xp
operator|*
name|BASE
operator|+
name|Digit
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|--
name|expo
expr_stmt|;
if|if
condition|(
name|xp
operator|<
operator|-
name|Maxreal
operator|/
name|BASE
operator|||
name|xp
operator|>
name|Maxreal
operator|/
name|BASE
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|IsSmallInt
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|xq
operator|=
name|SmallIntVal
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|++
name|expo
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|q
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|xq
operator|=
name|xq
operator|*
name|BASE
operator|+
name|Digit
argument_list|(
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|++
name|expo
expr_stmt|;
if|if
condition|(
name|xq
operator|>
name|Maxreal
operator|/
name|BASE
condition|)
break|break;
block|}
block|}
name|x
operator|=
name|xp
operator|/
name|xq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Integral
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|integer
name|p
init|=
operator|(
name|integer
operator|)
name|u
decl_stmt|;
if|if
condition|(
name|Length
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Copy
argument_list|(
operator|(
name|value
operator|)
name|app_0
argument_list|)
return|;
name|x
operator|=
literal|0
expr_stmt|;
name|expo
operator|=
name|Length
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Length
argument_list|(
name|p
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|x
operator|=
name|x
operator|*
name|BASE
operator|+
name|Digit
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|--
name|expo
expr_stmt|;
if|if
condition|(
name|x
operator|<
operator|-
name|Maxreal
operator|/
name|BASE
operator|||
name|x
operator|>
name|Maxreal
operator|/
name|BASE
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|expo
operator|<
literal|0
operator|&&
name|fabs
argument_list|(
name|x
argument_list|)
operator|>
name|BASE
operator|/
name|Maxreal
condition|)
operator|++
name|expo
operator|,
name|x
operator|/=
name|BASE
expr_stmt|;
while|while
condition|(
name|expo
operator|>
literal|0
operator|&&
name|fabs
argument_list|(
name|x
argument_list|)
operator|<
name|Maxreal
operator|/
name|BASE
condition|)
operator|--
name|expo
operator|,
name|x
operator|*=
name|BASE
expr_stmt|;
if|if
condition|(
name|expo
operator|!=
literal|0
condition|)
block|{
name|expo
operator|=
name|expo
operator|*
name|twologBASE
operator|+
literal|1
expr_stmt|;
name|e
operator|=
name|floor
argument_list|(
name|expo
argument_list|)
expr_stmt|;
name|x
operator|*=
literal|.5
operator|*
name|exp
argument_list|(
operator|(
name|expo
operator|-
name|e
operator|)
operator|*
name|logtwo
argument_list|)
expr_stmt|;
block|}
else|else
name|e
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|mk_approx
argument_list|(
name|x
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * numerator v returns the numerator of v, whenever v is an exact number.  * For integers, that is v itself.  */
end_comment

begin_function
name|Visible
name|value
name|numerator
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|407
argument_list|,
literal|"*/ on approximate number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|zero
return|;
block|}
if|if
condition|(
name|Integral
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|Copy
argument_list|(
name|v
argument_list|)
return|;
return|return
operator|(
name|value
operator|)
name|Copy
argument_list|(
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * /*v returns the denominator of v, whenever v is an exact number.  * For integers, that is 1.  */
end_comment

begin_function
name|Visible
name|value
name|denominator
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|408
argument_list|,
literal|"/* on approximate number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|zero
return|;
block|}
if|if
condition|(
name|Integral
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|one
return|;
return|return
operator|(
name|value
operator|)
name|Copy
argument_list|(
name|Denominator
argument_list|(
operator|(
name|rational
operator|)
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * u root v is defined as v**(1/u), where u is usually but need not be  * an integer.  */
end_comment

begin_function
name|Visible
name|value
name|root2
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
if|if
condition|(
name|u
operator|==
operator|(
name|value
operator|)
name|int_0
operator|||
name|Rational
argument_list|(
name|u
argument_list|)
operator|&&
name|Numerator
argument_list|(
operator|(
name|rational
operator|)
name|u
argument_list|)
operator|==
name|int_0
operator|||
name|Approximate
argument_list|(
name|u
argument_list|)
operator|&&
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|u
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|409
argument_list|,
literal|"in n root x, n is zero"
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|Copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|quot
argument_list|(
operator|(
name|value
operator|)
name|int_1
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|v
operator|=
name|power
argument_list|(
name|v
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* root x is computed more exactly than n root x, by doing    one iteration step extra.  This ~guarantees root(n**2) = n. */
end_comment

begin_function
name|Visible
name|value
name|root1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|value
name|r
init|=
name|root2
argument_list|(
operator|(
name|value
operator|)
name|int_2
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|value
name|v_over_r
decl_stmt|,
name|theirsum
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|Approximate
argument_list|(
name|r
argument_list|)
operator|&&
name|Frac
argument_list|(
operator|(
name|real
operator|)
name|r
argument_list|)
operator|==
literal|0.0
condition|)
return|return
operator|(
name|value
operator|)
name|r
return|;
name|v_over_r
operator|=
name|quot
argument_list|(
name|v
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|theirsum
operator|=
name|sum
argument_list|(
name|r
argument_list|,
name|v_over_r
argument_list|)
operator|,
name|release
argument_list|(
name|r
argument_list|)
operator|,
name|release
argument_list|(
name|v_over_r
argument_list|)
expr_stmt|;
name|result
operator|=
name|quot
argument_list|(
name|theirsum
argument_list|,
operator|(
name|value
operator|)
name|int_2
argument_list|)
operator|,
name|release
argument_list|(
name|theirsum
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The rest of the mathematical functions */
end_comment

begin_function
name|Visible
name|value
name|pi
parameter_list|()
block|{
return|return
operator|(
name|value
operator|)
name|mk_approx
argument_list|(
literal|3.141592653589793238463
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|e
parameter_list|()
block|{
return|return
operator|(
name|value
operator|)
name|mk_approx
argument_list|(
literal|2.718281828459045235360
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|trig
parameter_list|(
name|v
parameter_list|,
name|fun
parameter_list|,
name|zeroflag
parameter_list|)
name|value
name|v
decl_stmt|;
name|mathfun
name|fun
decl_stmt|;
name|bool
name|zeroflag
decl_stmt|;
block|{
name|real
name|w
init|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|double
name|expo
init|=
name|Expo
argument_list|(
name|w
argument_list|)
decl_stmt|,
name|frac
init|=
name|Frac
argument_list|(
name|w
argument_list|)
decl_stmt|,
name|x
decl_stmt|,
name|result
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|expo
operator|<=
name|Minexpo
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|zeroflag
condition|)
return|return
operator|(
name|value
operator|)
name|w
return|;
comment|/* sin small x = x, etc. */
name|frac
operator|=
literal|0
operator|,
name|expo
operator|=
literal|0
expr_stmt|;
block|}
name|release
argument_list|(
operator|(
name|value
operator|)
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|expo
operator|>
name|Maxexpo
condition|)
name|errno
operator|=
name|EDOM
expr_stmt|;
else|else
block|{
name|x
operator|=
name|ldexp
argument_list|(
name|frac
argument_list|,
operator|(
name|int
operator|)
name|expo
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|Maxtrig
operator|||
name|x
operator|<=
operator|-
name|Maxtrig
condition|)
name|errno
operator|=
name|EDOM
expr_stmt|;
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|fun
call|)
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|410
argument_list|,
literal|"the result is too large to be representable"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EDOM
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|411
argument_list|,
literal|"x is too large to compute a meaningful result"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|MESS
argument_list|(
literal|412
argument_list|,
literal|"math library error"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Copy
argument_list|(
operator|(
name|value
operator|)
name|app_0
argument_list|)
return|;
block|}
return|return
operator|(
name|value
operator|)
name|mk_approx
argument_list|(
name|result
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|sin1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|trig
argument_list|(
name|v
argument_list|,
name|sin
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|cos1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|trig
argument_list|(
name|v
argument_list|,
name|cos
argument_list|,
name|No
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|tan1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|trig
argument_list|(
name|v
argument_list|,
name|tan
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|atn1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|real
name|w
init|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|double
name|expo
init|=
name|Expo
argument_list|(
name|w
argument_list|)
decl_stmt|,
name|frac
init|=
name|Frac
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|expo
operator|<=
name|Minexpo
operator|+
literal|2
condition|)
return|return
operator|(
name|value
operator|)
name|w
return|;
comment|/* atan of small x = x */
name|release
argument_list|(
operator|(
name|value
operator|)
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|expo
operator|>
name|Maxexpo
condition|)
name|expo
operator|=
name|Maxexpo
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|mk_approx
argument_list|(
name|atan
argument_list|(
name|ldexp
argument_list|(
name|frac
argument_list|,
operator|(
name|int
operator|)
name|expo
argument_list|)
argument_list|)
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|exp1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|real
name|w
init|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|real
name|x
init|=
name|app_exp
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|w
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|x
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|log1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|real
name|w
init|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|real
name|x
init|=
name|app_log
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|w
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|x
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|log2
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|value
name|w
decl_stmt|;
name|u
operator|=
name|log1
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|v
operator|=
name|log1
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|w
operator|=
name|quot
argument_list|(
name|v
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
operator|,
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|atn2
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|real
name|ru
init|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|u
argument_list|)
decl_stmt|,
name|rv
init|=
operator|(
name|real
operator|)
name|approximate
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|double
name|uexpo
init|=
name|Expo
argument_list|(
name|ru
argument_list|)
decl_stmt|,
name|ufrac
init|=
name|Frac
argument_list|(
name|ru
argument_list|)
decl_stmt|;
name|double
name|vexpo
init|=
name|Expo
argument_list|(
name|rv
argument_list|)
decl_stmt|,
name|vfrac
init|=
name|Frac
argument_list|(
name|rv
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|(
name|value
operator|)
name|ru
argument_list|)
operator|,
name|release
argument_list|(
operator|(
name|value
operator|)
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|uexpo
operator|>
name|Maxexpo
condition|)
name|uexpo
operator|=
name|Maxexpo
expr_stmt|;
if|if
condition|(
name|vexpo
operator|>
name|Maxexpo
condition|)
name|vexpo
operator|=
name|Maxexpo
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|mk_approx
argument_list|(
name|atan2
argument_list|(
name|vexpo
operator|<
name|Minexpo
condition|?
literal|0.0
else|:
name|ldexp
argument_list|(
name|vfrac
argument_list|,
operator|(
name|int
operator|)
name|vexpo
argument_list|)
argument_list|,
name|uexpo
operator|<
name|Minexpo
condition|?
literal|0.0
else|:
name|ldexp
argument_list|(
name|ufrac
argument_list|,
operator|(
name|int
operator|)
name|uexpo
argument_list|)
argument_list|)
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
end_function

end_unit

