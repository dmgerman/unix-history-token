begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/* $Header: b2gen.c,v 1.4 85/08/27 10:57:31 timo Exp $ */
end_comment

begin_comment
comment|/* Code generation */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2exp.h"
end_include

begin_include
include|#
directive|include
file|"b2nod.h"
end_include

begin_include
include|#
directive|include
file|"b2gen.h"
end_include

begin_comment
comment|/* Must be after b2nod.h */
end_comment

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3int.h"
end_include

begin_include
include|#
directive|include
file|"b3sem.h"
end_include

begin_include
include|#
directive|include
file|"b3sou.h"
end_include

begin_function
name|Visible
name|Procedure
name|fix_nodes
parameter_list|(
name|pt
parameter_list|,
name|code
parameter_list|)
name|parsetree
modifier|*
name|pt
decl_stmt|;
name|parsetree
modifier|*
name|code
decl_stmt|;
block|{
name|context
name|c
decl_stmt|;
name|value
modifier|*
name|setup
argument_list|()
decl_stmt|,
modifier|*
name|su
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|curline
operator|=
operator|*
name|pt
expr_stmt|;
name|curlino
operator|=
name|one
expr_stmt|;
name|su
operator|=
name|setup
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|su
condition|)
name|analyze
argument_list|(
operator|*
name|pt
argument_list|,
name|su
argument_list|)
expr_stmt|;
name|curline
operator|=
operator|*
name|pt
expr_stmt|;
name|curlino
operator|=
name|one
expr_stmt|;
name|inithreads
argument_list|()
expr_stmt|;
name|fix
argument_list|(
name|pt
argument_list|,
name|su
condition|?
literal|'x'
else|:
literal|'v'
argument_list|)
expr_stmt|;
name|endthreads
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TYPE_CHECK
if|if
condition|(
name|cntxt
operator|!=
name|In_prmnv
condition|)
name|type_check
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_comment
comment|/* Utilities used by threading. */
end_comment

begin_comment
comment|/* A 'threaded tree' is, in our case, a fixed(*) parse tree with extra links    that are used by the interpreter to determine the execution order.    __________    (*) 'Fixed' means: processed by 'fix_nodes', which removes UNPARSED        nodes and distinguishes TAG nodes into local, global tags etc.        fix_nodes also creates the threads, but this is accidental, not        essential.  For UNPARSED nodes, the threads are actually laid        in a second pass through the subtree that was UNPARSED.    __________     A small example: the parse tree for the expression  'a+b*c'  looks like  	(DYOP, 		(TAGlocal, "a"), 		"+", 		(DYOP, 			(TAGlocal, "b"), 			"*", 			(TAGlocal, "c"))).     The required execution order is here:  	1) (TAGlocal, "a") 	2) (TAGlocal, "b") 	3) (TAGlocal, "c") 	4) (DYOP, ..., "*", ...) 	5) (DYOP, ..., "+", ...)     Of course, the result of each operation (if it has a result) is pushed    on a stack, and the operands are popped from this same stack.  Think of    reversed polish notation (well-known by owners of HP pocket calculators).     The 'threads' are explicit links from each node to its successor in this    execution order.  Conditional operations like IF and AND have two threads,    one for success and one for failure.  Loops can be made by having the    thread from the last node of the loop body point to the head of the loop.     Threading expressions, locations and simple-commands is easy: recursively    thread each of the subtrees, then lay a thread from the last threaded    to the current node.  Nodes occurring in a 'location' context are    marked, so that the interpreter knows when to push a 'location' on    the stack.     Tests and looping commands cause most of the complexity of the threading    utilities.  The basic technique is 'backpatching'.    Nodes that need a conditional forward jump are chained together in a    linked list, and when their destination is reached, all nodes in the    chain get its 'address' patched into their secondary thread.  There is    one such chain, called 'bpchain', which at all times contains those nodes    whose secondary destination would be the next generated instruction.    This is used by IF, WHILE, test-suites, AND and OR.     To generate a loop, both this chain and the last normal instruction    (if any) are diverted to the node where the loop continues.     For test-suites, we also need to be capable of jumping unconditionally    forward (over the remainder of the SELECT-command).  This is done by    saving both the backpatch chain and the last node visited, and restoring    them after the remainder has been processed. */
end_comment

begin_comment
comment|/* Implementation tricks: in order not to show circular lists to 'release',    parse tree nodes are generated as compounds where there is room for two    more fields than their length indicates. */
end_comment

begin_define
define|#
directive|define
name|Flag
value|(MkSmallInt(1))
end_define

begin_comment
comment|/* Flag used to indicate Location or TestRefinement node */
end_comment

begin_decl_stmt
name|Hidden
name|parsetree
name|start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First instruction.  Picked up by endthreads() */
end_comment

begin_decl_stmt
name|Hidden
name|parsetree
name|last
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last visited node */
end_comment

begin_decl_stmt
name|Hidden
name|parsetree
name|bpchain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Backpatch chain for conditional goto's */
end_comment

begin_decl_stmt
name|Hidden
name|parsetree
modifier|*
name|wanthere
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of requests to return next tree */
end_comment

begin_decl_stmt
specifier|extern
name|string
name|opcodes
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start threading */
end_comment

begin_function
name|Hidden
name|Procedure
name|inithreads
parameter_list|()
block|{
name|bpchain
operator|=
name|NilTree
expr_stmt|;
name|wanthere
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
name|here
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish threading */
end_comment

begin_function
name|Hidden
name|Procedure
name|endthreads
parameter_list|(
name|code
parameter_list|)
name|parsetree
modifier|*
name|code
decl_stmt|;
block|{
name|jumpto
argument_list|(
name|Stop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
name|start
operator|=
name|NilTree
expr_stmt|;
operator|*
name|code
operator|=
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill 't' as secondary thread for all nodes in the backpatch chain,    leaving the chain empty. */
end_comment

begin_function
name|Hidden
name|Procedure
name|backpatch
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|parsetree
name|u
decl_stmt|;
while|while
condition|(
name|bpchain
operator|!=
name|NilTree
condition|)
block|{
name|u
operator|=
name|Thread2
argument_list|(
name|bpchain
argument_list|)
expr_stmt|;
name|Thread2
argument_list|(
name|bpchain
argument_list|)
operator|=
name|t
expr_stmt|;
name|bpchain
operator|=
name|u
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|jumpto
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|parsetree
name|u
decl_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
while|while
condition|(
name|wanthere
operator|!=
literal|0
condition|)
block|{
name|u
operator|=
operator|*
name|wanthere
expr_stmt|;
operator|*
name|wanthere
operator|=
name|t
expr_stmt|;
name|wanthere
operator|=
operator|(
name|parsetree
operator|*
operator|)
name|u
expr_stmt|;
block|}
while|while
condition|(
name|last
operator|!=
name|NilTree
condition|)
block|{
name|u
operator|=
name|Thread
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|Thread
argument_list|(
name|last
argument_list|)
operator|=
name|t
expr_stmt|;
name|last
operator|=
name|u
expr_stmt|;
block|}
name|backpatch
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|parsetree
name|seterr
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
name|parsetree
operator|)
name|MkSmallInt
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Visit node 't', and set its secondary thread to 't2'. */
end_comment

begin_function
name|Hidden
name|Procedure
name|visit2
parameter_list|(
name|t
parameter_list|,
name|t2
parameter_list|)
name|parsetree
name|t
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
name|jumpto
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|Thread2
argument_list|(
name|t
argument_list|)
operator|=
name|t2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tvisit %s %s\n"
argument_list|,
name|opcodes
index|[
name|Nodetype
argument_list|(
name|t
argument_list|)
index|]
argument_list|,
name|t2
operator|==
name|NilTree
condition|?
literal|""
else|:
literal|"[*]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|Thread
argument_list|(
name|t
argument_list|)
operator|=
name|NilTree
expr_stmt|;
name|last
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Visit node 't' */
end_comment

begin_function
name|Hidden
name|Procedure
name|visit
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|visit2
argument_list|(
name|t
argument_list|,
name|NilTree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Visit node 't' and flag it as a location (or test-refinement). */
end_comment

begin_function
name|Hidden
name|Procedure
name|lvisit
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|visit2
argument_list|(
name|t
argument_list|,
name|Flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_function
name|Hidden
name|Procedure
name|jumphere
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
name|Thread
argument_list|(
name|t
argument_list|)
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add node 't' to the backpatch chain. */
end_comment

begin_function
name|Hidden
name|Procedure
name|jump2here
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
name|Thread2
argument_list|(
name|t
argument_list|)
operator|=
name|bpchain
expr_stmt|;
name|bpchain
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|here
parameter_list|(
name|pl
parameter_list|)
name|parsetree
modifier|*
name|pl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
operator|*
name|pl
operator|=
operator|(
name|parsetree
operator|)
name|wanthere
expr_stmt|;
name|wanthere
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|hold
parameter_list|(
name|pl
parameter_list|)
name|struct
name|state
modifier|*
name|pl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
name|pl
operator|->
name|h_last
operator|=
name|last
expr_stmt|;
name|pl
operator|->
name|h_bpchain
operator|=
name|bpchain
expr_stmt|;
name|pl
operator|->
name|h_wanthere
operator|=
name|wanthere
expr_stmt|;
name|last
operator|=
name|bpchain
operator|=
name|NilTree
expr_stmt|;
name|wanthere
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|let_go
parameter_list|(
name|pl
parameter_list|)
name|struct
name|state
modifier|*
name|pl
decl_stmt|;
block|{
name|parsetree
name|p
decl_stmt|,
modifier|*
name|w
decl_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
if|if
condition|(
name|last
condition|)
block|{
for|for
control|(
name|p
operator|=
name|last
init|;
name|Thread
argument_list|(
name|p
argument_list|)
operator|!=
name|NilTree
condition|;
name|p
operator|=
name|Thread
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
name|Thread
argument_list|(
name|p
argument_list|)
operator|=
name|pl
operator|->
name|h_last
expr_stmt|;
block|}
else|else
name|last
operator|=
name|pl
operator|->
name|h_last
expr_stmt|;
if|if
condition|(
name|bpchain
condition|)
block|{
for|for
control|(
name|p
operator|=
name|bpchain
init|;
name|Thread2
argument_list|(
name|p
argument_list|)
operator|!=
name|NilTree
condition|;
name|p
operator|=
name|Thread2
argument_list|(
name|p
argument_list|)
control|)
empty_stmt|;
name|Thread2
argument_list|(
name|p
argument_list|)
operator|=
name|pl
operator|->
name|h_bpchain
expr_stmt|;
block|}
else|else
name|bpchain
operator|=
name|pl
operator|->
name|h_bpchain
expr_stmt|;
if|if
condition|(
name|wanthere
condition|)
block|{
for|for
control|(
name|w
operator|=
name|wanthere
init|;
operator|*
name|w
operator|!=
literal|0
condition|;
name|w
operator|=
operator|(
name|parsetree
operator|*
operator|)
operator|*
name|w
control|)
empty_stmt|;
operator|*
name|w
operator|=
operator|(
name|parsetree
operator|)
name|pl
operator|->
name|h_wanthere
expr_stmt|;
block|}
else|else
name|wanthere
operator|=
name|pl
operator|->
name|h_wanthere
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|reachable
parameter_list|()
block|{
return|return
name|last
operator|!=
name|NilTree
operator|||
name|bpchain
operator|!=
literal|0
operator|||
name|wanthere
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_comment
comment|/* *********************** code generation **************************** */
end_comment

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_function_decl
name|Forward
name|bool
name|is_variable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|bool
name|is_cmd_ref
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Forward
name|value
name|copydef
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Visible
name|Procedure
name|fix
parameter_list|(
name|pt
parameter_list|,
name|flag
parameter_list|)
name|parsetree
modifier|*
name|pt
decl_stmt|;
name|char
name|flag
decl_stmt|;
block|{
name|struct
name|state
name|st
decl_stmt|;
name|value
name|v
decl_stmt|,
name|function
decl_stmt|;
name|parsetree
name|t
decl_stmt|,
name|l1
init|=
name|NilTree
decl_stmt|;
name|typenode
name|nt
decl_stmt|;
name|string
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|n
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|;
name|t
operator|=
operator|*
name|pt
expr_stmt|;
if|if
condition|(
operator|!
name|Is_node
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|still_ok
condition|)
return|return;
name|nt
operator|=
name|Nodetype
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|<
literal|0
operator|||
name|nt
operator|>=
name|NTYPES
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|2200
argument_list|,
literal|"fix bad tree"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|gentab
index|[
name|nt
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|n
operator|=
name|First_fieldnr
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|'x'
condition|)
name|curline
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|still_ok
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|+
name|First_fieldnr
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|v
operator|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|Vnil
condition|)
block|{
name|len
operator|=
name|Nfields
argument_list|(
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
operator|++
name|k
control|)
name|fix
argument_list|(
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|curlino
operator|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'l'
case|:
if|if
condition|(
name|flag
operator|==
literal|'v'
operator|||
name|flag
operator|==
literal|'t'
condition|)
name|c
operator|=
name|flag
expr_stmt|;
comment|/* Fall through */
case|case
literal|'!'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'x'
case|:
name|fix
argument_list|(
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|f_fpr_formals
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
name|flag
operator|==
literal|'v'
condition|)
name|f_eunparsed
argument_list|(
name|pt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|==
literal|'t'
condition|)
name|f_cunparsed
argument_list|(
name|pt
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|2201
argument_list|,
literal|"fix unparsed with bad flag"
argument_list|)
argument_list|)
expr_stmt|;
name|fix
argument_list|(
name|pt
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|v
operator|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|REL_LEFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|Comparison
argument_list|(
name|Nodetype
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
name|jump2here
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|v
operator|=
operator|(
name|value
operator|)
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_dyafun
argument_list|(
name|v
argument_list|,
operator|&
name|function
argument_list|)
condition|)
name|fixerr2
argument_list|(
name|v
argument_list|,
name|MESS
argument_list|(
literal|2202
argument_list|,
literal|" isn't a dyadic function"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_FCT
argument_list|)
operator|=
name|copydef
argument_list|(
name|function
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|v
operator|=
operator|(
name|value
operator|)
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_dyaprd
argument_list|(
name|v
argument_list|,
operator|&
name|function
argument_list|)
condition|)
name|fixerr2
argument_list|(
name|v
argument_list|,
name|MESS
argument_list|(
literal|2203
argument_list|,
literal|" isn't a dyadic predicate"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_FCT
argument_list|)
operator|=
name|copydef
argument_list|(
name|function
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|jumpto
argument_list|(
name|l1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|here
argument_list|(
operator|&
name|l1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
operator|==
name|NilTree
condition|)
break|break;
comment|/* Else fall through */
case|case
literal|'J'
case|:
name|jump2here
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|hold
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|let_go
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|v
operator|=
operator|(
name|value
operator|)
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|MON_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_variable
argument_list|(
name|v
argument_list|)
operator|||
operator|!
name|is_monfun
argument_list|(
name|v
argument_list|,
operator|&
name|function
argument_list|)
condition|)
name|fixerr2
argument_list|(
name|v
argument_list|,
name|MESS
argument_list|(
literal|2204
argument_list|,
literal|" isn't a monadic function"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|MON_FCT
argument_list|)
operator|=
name|copydef
argument_list|(
name|function
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|v
operator|=
operator|(
name|value
operator|)
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|MON_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_variable
argument_list|(
name|v
argument_list|)
operator|||
operator|!
name|is_monprd
argument_list|(
name|v
argument_list|,
operator|&
name|function
argument_list|)
condition|)
name|fixerr2
argument_list|(
name|v
argument_list|,
name|MESS
argument_list|(
literal|2205
argument_list|,
literal|" isn't a monadic predicate"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|MON_FCT
argument_list|)
operator|=
name|copydef
argument_list|(
name|function
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|REACH
case|case
literal|'R'
case|:
if|if
condition|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
operator|!=
name|NilTree
operator|&&
operator|!
name|reachable
argument_list|()
condition|)
name|fixerr
argument_list|(
name|MESS
argument_list|(
literal|2206
argument_list|,
literal|"command cannot be reached"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'S'
case|:
name|jumpto
argument_list|(
name|Stop
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|flag
operator|==
literal|'t'
condition|)
name|f_ctag
argument_list|(
name|pt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|==
literal|'v'
operator|||
name|flag
operator|==
literal|'x'
condition|)
name|f_etag
argument_list|(
name|pt
argument_list|)
expr_stmt|;
else|else
name|f_ttag
argument_list|(
name|pt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|f_ucommand
argument_list|(
name|pt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|visit
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|flag
operator|==
literal|'a'
operator|||
name|flag
operator|==
literal|'l'
operator|||
name|flag
operator|==
literal|'!'
condition|)
name|lvisit
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|visit
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/*!*/
name|visit2
argument_list|(
name|t
argument_list|,
name|seterr
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|still_ok
operator|&&
name|reachable
argument_list|()
condition|)
block|{
if|if
condition|(
name|nt
operator|==
name|YIELD
condition|)
name|fixerr
argument_list|(
name|MESS
argument_list|(
literal|2207
argument_list|,
literal|"YIELD-unit returns no value"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fixerr
argument_list|(
name|MESS
argument_list|(
literal|2208
argument_list|,
literal|"TEST-unit reports no outcome"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
operator|!
name|is_cmd_ref
argument_list|(
name|t
argument_list|)
operator|&&
name|still_ok
operator|&&
name|reachable
argument_list|()
condition|)
name|fixerr
argument_list|(
name|MESS
argument_list|(
literal|2209
argument_list|,
literal|"refinement returns no value c.q. reports no outcome"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|REF_START
argument_list|)
operator|=
name|copy
argument_list|(
name|l1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_function
name|Hidden
name|bool
name|is_cmd_ref
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
comment|/* HACK */
name|value
name|name
init|=
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|REF_NAME
argument_list|)
decl_stmt|;
name|string
name|s
init|=
name|strval
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* return isupper(*s); */
return|return
operator|*
name|s
operator|<=
literal|'Z'
operator|&&
operator|*
name|s
operator|>=
literal|'A'
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|copydef
parameter_list|(
name|f
parameter_list|)
name|value
name|f
decl_stmt|;
block|{
name|funprd
modifier|*
name|fpr
init|=
name|Funprd
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|fpr
operator|->
name|pre
operator|==
name|Use
condition|)
return|return
name|Vnil
return|;
return|return
name|copy
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|is_basic_target
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|envassoc
argument_list|(
name|formals
argument_list|,
name|v
argument_list|)
operator|||
name|locals
operator|!=
name|Vnil
operator|&&
name|envassoc
argument_list|(
name|locals
argument_list|,
name|v
argument_list|)
operator|||
name|envassoc
argument_list|(
name|globals
argument_list|,
name|v
argument_list|)
operator|||
name|envassoc
argument_list|(
name|mysteries
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|is_variable
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|value
name|f
decl_stmt|;
return|return
name|is_basic_target
argument_list|(
name|v
argument_list|)
operator|||
name|envassoc
argument_list|(
name|refinements
argument_list|,
name|v
argument_list|)
operator|||
name|is_zerfun
argument_list|(
name|v
argument_list|,
operator|&
name|f
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|is_target
parameter_list|(
name|p
parameter_list|)
name|parsetree
name|p
decl_stmt|;
block|{
name|value
name|v
init|=
operator|*
name|Branch
argument_list|(
name|p
argument_list|,
name|First_fieldnr
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
decl_stmt|;
switch|switch
condition|(
name|Nodetype
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|TAG
case|:
return|return
name|is_basic_target
argument_list|(
name|v
argument_list|)
return|;
case|case
name|SELECTION
case|:
case|case
name|BEHEAD
case|:
case|case
name|CURTAIL
case|:
case|case
name|COMPOUND
case|:
return|return
name|is_target
argument_list|(
name|v
argument_list|)
return|;
case|case
name|COLLATERAL
case|:
name|len
operator|=
name|Nfields
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|k_Overfields
block|{
if|if
condition|(
operator|!
name|is_target
argument_list|(
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|)
condition|)
return|return
name|No
return|;
block|}
return|return
name|Yes
return|;
default|default:
return|return
name|No
return|;
block|}
block|}
end_function

begin_comment
comment|/* ******************************************************************** */
end_comment

begin_function
name|Hidden
name|Procedure
name|f_actuals
parameter_list|(
name|formals
parameter_list|,
name|pactuals
parameter_list|)
name|parsetree
name|formals
decl_stmt|,
decl|*
name|pactuals
decl_stmt|;
end_function

begin_block
block|{
comment|/* name, actual, next */
name|value
name|actuals
init|=
operator|*
name|pactuals
decl_stmt|,
name|act
decl_stmt|,
name|form
decl_stmt|,
name|next_a
decl_stmt|,
name|next_f
decl_stmt|,
name|kw
decl_stmt|,
modifier|*
name|pact
decl_stmt|;
name|kw
operator|=
operator|*
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_KEYW
argument_list|)
expr_stmt|;
name|pact
operator|=
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_EXPR
argument_list|)
expr_stmt|;
name|act
operator|=
operator|*
name|pact
expr_stmt|;
name|form
operator|=
operator|*
name|Branch
argument_list|(
name|formals
argument_list|,
name|FML_TAG
argument_list|)
expr_stmt|;
name|next_a
operator|=
operator|*
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_NEXT
argument_list|)
expr_stmt|;
name|next_f
operator|=
operator|*
name|Branch
argument_list|(
name|formals
argument_list|,
name|FML_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
operator|*
name|Branch
argument_list|(
name|formals
argument_list|,
name|FML_KEYW
argument_list|)
argument_list|,
name|kw
argument_list|)
operator|!=
literal|0
condition|)
name|fixerr3
argument_list|(
name|MESS
argument_list|(
literal|2210
argument_list|,
literal|"wrong keyword "
argument_list|)
argument_list|,
name|kw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|act
operator|==
name|Vnil
operator|&&
name|form
operator|!=
name|Vnil
condition|)
name|fixerr3
argument_list|(
name|MESS
argument_list|(
literal|2211
argument_list|,
literal|"missing actual after "
argument_list|)
argument_list|,
name|kw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|next_a
operator|==
name|Vnil
operator|&&
name|next_f
operator|!=
name|Vnil
condition|)
name|fixerr3
argument_list|(
name|MESS
argument_list|(
literal|2212
argument_list|,
literal|"can't find expected "
argument_list|)
argument_list|,
operator|*
name|Branch
argument_list|(
name|next_f
argument_list|,
name|FML_KEYW
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|act
operator|!=
name|Vnil
operator|&&
name|form
operator|==
name|Vnil
condition|)
name|fixerr3
argument_list|(
name|MESS
argument_list|(
literal|2213
argument_list|,
literal|"unexpected actual after "
argument_list|)
argument_list|,
name|kw
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|next_a
operator|!=
name|Vnil
operator|&&
name|next_f
operator|==
name|Vnil
condition|)
name|fixerr3
argument_list|(
name|MESS
argument_list|(
literal|2214
argument_list|,
literal|"unexpected keyword "
argument_list|)
argument_list|,
operator|*
name|Branch
argument_list|(
name|next_a
argument_list|,
name|ACT_KEYW
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|act
operator|!=
name|Vnil
condition|)
block|{
name|parsetree
name|st
decl_stmt|;
name|struct
name|state
name|save
decl_stmt|;
name|hold
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|here
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_target
argument_list|(
name|act
argument_list|)
condition|)
name|f_targ
argument_list|(
name|pact
argument_list|)
expr_stmt|;
else|else
name|f_expr
argument_list|(
name|pact
argument_list|)
expr_stmt|;
name|jumpto
argument_list|(
name|Stop
argument_list|)
expr_stmt|;
name|let_go
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
operator|*
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_START
argument_list|)
operator|=
name|copy
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|still_ok
operator|&&
name|next_a
operator|!=
name|Vnil
condition|)
name|f_actuals
argument_list|(
name|next_f
argument_list|,
name|Branch
argument_list|(
name|actuals
argument_list|,
name|ACT_NEXT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|Hidden
name|Procedure
name|f_ucommand
parameter_list|(
name|pt
parameter_list|)
name|parsetree
modifier|*
name|pt
decl_stmt|;
block|{
name|value
name|t
init|=
operator|*
name|pt
decl_stmt|,
modifier|*
name|aa
decl_stmt|;
name|parsetree
name|u
decl_stmt|,
modifier|*
name|f1
init|=
name|Branch
argument_list|(
name|t
argument_list|,
name|UCMD_NAME
argument_list|)
decl_stmt|,
modifier|*
name|f2
init|=
name|Branch
argument_list|(
name|t
argument_list|,
name|UCMD_ACTUALS
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|UCMD_DEF
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|UCMD_DEF
argument_list|)
operator|=
name|Vnil
expr_stmt|;
if|if
condition|(
operator|(
name|aa
operator|=
name|envassoc
argument_list|(
name|refinements
argument_list|,
operator|*
name|f1
argument_list|)
operator|)
operator|!=
name|Pnil
condition|)
block|{
if|if
condition|(
operator|*
name|Branch
argument_list|(
operator|*
name|f2
argument_list|,
name|ACT_EXPR
argument_list|)
operator|!=
name|Vnil
operator|||
operator|*
name|Branch
argument_list|(
operator|*
name|f2
argument_list|,
name|ACT_NEXT
argument_list|)
operator|!=
name|Vnil
condition|)
name|fixerr
argument_list|(
name|MESS
argument_list|(
literal|2215
argument_list|,
literal|"refinement with parameters"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|UCMD_DEF
argument_list|)
operator|=
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_unit
argument_list|(
operator|*
name|f1
argument_list|,
name|How
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
block|{
name|u
operator|=
name|How_to
argument_list|(
operator|*
name|aa
argument_list|)
operator|->
name|unit
expr_stmt|;
name|f_actuals
argument_list|(
operator|*
name|Branch
argument_list|(
name|u
argument_list|,
name|HOW_FORMALS
argument_list|)
argument_list|,
name|f2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|still_ok
condition|)
name|fixerr3
argument_list|(
name|MESS
argument_list|(
literal|2216
argument_list|,
literal|"you haven't told me HOW'TO "
argument_list|)
argument_list|,
operator|*
name|f1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|f_fpr_formals
parameter_list|(
name|t
parameter_list|)
name|parsetree
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|Nodetype
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TAG
case|:
break|break;
case|case
name|MONF
case|:
case|case
name|MONPRD
case|:
name|f_targ
argument_list|(
name|Branch
argument_list|(
name|t
argument_list|,
name|MON_RIGHT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DYAF
case|:
case|case
name|DYAPRD
case|:
name|f_targ
argument_list|(
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_LEFT
argument_list|)
argument_list|)
expr_stmt|;
name|f_targ
argument_list|(
name|Branch
argument_list|(
name|t
argument_list|,
name|DYA_RIGHT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|2217
argument_list|,
literal|"f_fpr_formals"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|bool
name|modify_tag
parameter_list|(
name|name
parameter_list|,
name|tag
parameter_list|)
name|parsetree
modifier|*
name|tag
decl_stmt|;
name|value
name|name
decl_stmt|;
block|{
name|value
modifier|*
name|aa
decl_stmt|,
name|function
decl_stmt|;
operator|*
name|tag
operator|=
name|NilTree
expr_stmt|;
if|if
condition|(
name|aa
operator|=
name|envassoc
argument_list|(
name|formals
argument_list|,
name|name
argument_list|)
condition|)
operator|*
name|tag
operator|=
name|node3
argument_list|(
name|TAGformal
argument_list|,
name|name
argument_list|,
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|locals
operator|!=
name|Vnil
operator|&&
operator|(
name|aa
operator|=
name|envassoc
argument_list|(
name|locals
argument_list|,
name|name
argument_list|)
operator|)
condition|)
operator|*
name|tag
operator|=
name|node3
argument_list|(
name|TAGlocal
argument_list|,
name|name
argument_list|,
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aa
operator|=
name|envassoc
argument_list|(
name|globals
argument_list|,
name|name
argument_list|)
condition|)
operator|*
name|tag
operator|=
name|node2
argument_list|(
name|TAGglobal
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aa
operator|=
name|envassoc
argument_list|(
name|mysteries
argument_list|,
name|name
argument_list|)
condition|)
operator|*
name|tag
operator|=
name|node3
argument_list|(
name|TAGmystery
argument_list|,
name|name
argument_list|,
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aa
operator|=
name|envassoc
argument_list|(
name|refinements
argument_list|,
name|name
argument_list|)
condition|)
operator|*
name|tag
operator|=
name|node3
argument_list|(
name|TAGrefinement
argument_list|,
name|name
argument_list|,
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_zerfun
argument_list|(
name|name
argument_list|,
operator|&
name|function
argument_list|)
condition|)
operator|*
name|tag
operator|=
name|node3
argument_list|(
name|TAGzerfun
argument_list|,
name|name
argument_list|,
name|copydef
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_zerprd
argument_list|(
name|name
argument_list|,
operator|&
name|function
argument_list|)
condition|)
operator|*
name|tag
operator|=
name|node3
argument_list|(
name|TAGzerprd
argument_list|,
name|name
argument_list|,
name|copydef
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|No
return|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|f_etag
parameter_list|(
name|pt
parameter_list|)
name|parsetree
modifier|*
name|pt
decl_stmt|;
block|{
name|parsetree
name|t
init|=
operator|*
name|pt
decl_stmt|;
name|value
name|name
init|=
name|copy
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|TAG_NAME
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|modify_tag
argument_list|(
name|name
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|release
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|Nodetype
argument_list|(
name|t
argument_list|)
operator|==
name|TAGzerprd
condition|)
name|fixerr2
argument_list|(
name|name
argument_list|,
name|MESS
argument_list|(
literal|2218
argument_list|,
literal|" cannot be used in an expression"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|visit
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixerr2
argument_list|(
name|name
argument_list|,
name|MESS
argument_list|(
literal|2219
argument_list|,
literal|" has not yet received a value"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|f_ttag
parameter_list|(
name|pt
parameter_list|)
name|parsetree
modifier|*
name|pt
decl_stmt|;
block|{
name|parsetree
name|t
init|=
operator|*
name|pt
decl_stmt|;
name|value
name|name
init|=
name|copy
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|TAG_NAME
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|modify_tag
argument_list|(
name|name
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|release
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|=
name|t
expr_stmt|;
switch|switch
condition|(
name|Nodetype
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TAGrefinement
case|:
name|fixerr
argument_list|(
name|MESS
argument_list|(
literal|2220
argument_list|,
literal|"a refinement may not be used as a target"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAGzerfun
case|:
case|case
name|TAGzerprd
case|:
name|fixerr2
argument_list|(
name|name
argument_list|,
name|MESS
argument_list|(
literal|2221
argument_list|,
literal|" hasn't been initialised or defined"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lvisit
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|fixerr2
argument_list|(
name|name
argument_list|,
name|MESS
argument_list|(
literal|2222
argument_list|,
literal|" hasn't been initialised or defined"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|f_ctag
parameter_list|(
name|pt
parameter_list|)
name|parsetree
modifier|*
name|pt
decl_stmt|;
block|{
name|parsetree
name|t
init|=
operator|*
name|pt
decl_stmt|;
name|value
name|name
init|=
name|copy
argument_list|(
operator|*
name|Branch
argument_list|(
name|t
argument_list|,
name|TAG_NAME
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|modify_tag
argument_list|(
name|name
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|release
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|=
name|t
expr_stmt|;
switch|switch
condition|(
name|Nodetype
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TAGrefinement
case|:
name|lvisit
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* 'Loc' flag here means 'Test' */
break|break;
case|case
name|TAGzerprd
case|:
name|visit
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fixerr2
argument_list|(
name|name
argument_list|,
name|MESS
argument_list|(
literal|2223
argument_list|,
literal|" is neither a refined test nor a zeroadic predicate"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|fixerr2
argument_list|(
name|name
argument_list|,
name|MESS
argument_list|(
literal|2224
argument_list|,
literal|" is neither a refined test nor a zeroadic predicate"
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

