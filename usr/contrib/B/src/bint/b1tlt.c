begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b1tlt.c,v 1.4 85/08/22 16:53:20 timo Exp $ */
end_comment

begin_comment
comment|/* generic routines for B texts, lists and tables */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1btr.h"
end_include

begin_include
include|#
directive|include
file|"b1val.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"b1tlt.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_comment
comment|/* From b1lta.c */
end_comment

begin_function_decl
name|int
name|l2size
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|value
name|l2min
argument_list|()
decl_stmt|,
name|l2max
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|value
name|mk_elt
parameter_list|()
block|{
comment|/* {}, internal only */
name|value
name|e
init|=
name|grab_tlt
argument_list|(
name|ELT
argument_list|,
name|Lt
argument_list|)
decl_stmt|;
name|Root
argument_list|(
name|e
argument_list|)
operator|=
name|Bnil
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|empty
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
comment|/* #v=0, internal only */
switch|switch
condition|(
name|Type
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
name|ELT
case|:
case|case
name|Lis
case|:
case|case
name|Tex
case|:
case|case
name|Tab
case|:
return|return
name|Root
argument_list|(
argument|v
argument_list|)
name|EQ
name|Bnil
return|;
default|default:
return|return
name|No
return|;
comment|/* Some routines must test empty(t) end return an error 		   message if it fails, before testing Type(t). 		   In this way, they won't give the wrong error message. */
block|}
block|}
end_function

begin_comment
comment|/* return size of (number of items in) dependent tree */
end_comment

begin_function
name|Hidden
name|value
name|treesize
parameter_list|(
name|pnode
parameter_list|)
name|btreeptr
name|pnode
decl_stmt|;
block|{
name|int
name|psize
decl_stmt|;
name|value
name|vsize
decl_stmt|,
name|childsize
decl_stmt|,
name|u
decl_stmt|;
name|intlet
name|l
decl_stmt|;
name|psize
operator|=
name|Size
argument_list|(
name|pnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
name|EQ
name|Bigsize
condition|)
block|{
switch|switch
condition|(
name|Flag
argument_list|(
name|pnode
argument_list|)
condition|)
block|{
case|case
name|Inner
case|:
name|vsize
operator|=
name|mk_integer
argument_list|(
operator|(
name|int
operator|)
name|Lim
argument_list|(
name|pnode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<=
name|Lim
argument_list|(
name|pnode
argument_list|)
condition|;
name|l
operator|++
control|)
block|{
name|childsize
operator|=
name|treesize
argument_list|(
name|Ptr
argument_list|(
name|pnode
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
name|vsize
expr_stmt|;
name|vsize
operator|=
name|sum
argument_list|(
name|vsize
argument_list|,
name|childsize
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|childsize
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Irange
case|:
name|u
operator|=
name|diff
argument_list|(
name|Upbval
argument_list|(
name|pnode
argument_list|)
argument_list|,
name|Lwbval
argument_list|(
name|pnode
argument_list|)
argument_list|)
expr_stmt|;
name|vsize
operator|=
name|sum
argument_list|(
name|u
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bottom
case|:
case|case
name|Crange
case|:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1700
argument_list|,
literal|"Bigsize in Bottom or Crange"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vsize
operator|)
return|;
block|}
return|return
name|mk_integer
argument_list|(
name|psize
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|size
parameter_list|(
name|t
parameter_list|)
name|value
name|t
decl_stmt|;
block|{
comment|/* #t */
name|int
name|tsize
decl_stmt|;
switch|switch
condition|(
name|Type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ELT
case|:
case|case
name|Lis
case|:
case|case
name|Tex
case|:
case|case
name|Tab
case|:
name|tsize
operator|=
name|Tltsize
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
name|EQ
name|Bigsize
condition|)
return|return
name|treesize
argument_list|(
name|Root
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
return|return
name|mk_integer
argument_list|(
name|tsize
argument_list|)
return|;
default|default:
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1701
argument_list|,
literal|"in #t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|zero
return|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|th_of
parameter_list|(
name|num
parameter_list|,
name|v
parameter_list|)
name|value
name|num
decl_stmt|,
name|v
decl_stmt|;
block|{
comment|/* num th'of v */
name|value
name|m
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1702
argument_list|,
literal|"in n th'of t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|num
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1703
argument_list|,
literal|"in n th'of t, n is not a number"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|empty
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1704
argument_list|,
literal|"in n th'of t, t is empty"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numcomp
argument_list|(
name|num
argument_list|,
name|one
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1705
argument_list|,
literal|"in n th'of t, n is< 1"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*RANGES?*/
name|m
operator|=
name|thof
argument_list|(
name|intval
argument_list|(
name|num
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|Vnil
operator|&&
name|still_ok
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1706
argument_list|,
literal|"in n th'of t, n exceeds #t"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * 'Walktree' handles functions on texts and associates of tables.  * The actual function performed is determined by the 'visit' function.  * The tree is walked (possibly recursively) and all items are visited.  * The return value of walktree() and visit() is used to determine whether  * the walk should continue (Yes == continue, No == stop now).  * Global variables are used to communicate the result, and the parameters  * of the function. The naming convention is according to "e func t".  */
end_comment

begin_decl_stmt
name|Hidden
name|intlet
name|tt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of walked value t */
end_comment

begin_decl_stmt
name|Hidden
name|intlet
name|wt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of items in walked value t */
end_comment

begin_decl_stmt
name|Hidden
name|value
name|ve
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of e, if func is dyadic */
end_comment

begin_decl_stmt
name|Hidden
name|char
name|ce
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C char in e, if t is a text */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result of size2 */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result for in */
end_comment

begin_decl_stmt
name|Hidden
name|intlet
name|m_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result for min/max on texts */
end_comment

begin_decl_stmt
name|Hidden
name|value
name|m_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result for min/max on tables */
end_comment

begin_define
define|#
directive|define
name|Lowchar
value|(-Maxintlet)
end_define

begin_comment
comment|/* -infinity for characters */
end_comment

begin_define
define|#
directive|define
name|Highchar
value|(Maxintlet)
end_define

begin_comment
comment|/* +infinity */
end_comment

begin_decl_stmt
name|Hidden
name|bool
name|walktree
argument_list|(
name|p
argument_list|,
name|visit
argument_list|)
name|btreeptr
name|p
decl_stmt|;
end_decl_stmt

begin_function_decl
name|bool
function_decl|(
modifier|*
name|visit
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|intlet
name|l
decl_stmt|;
if|if
condition|(
name|p
name|EQ
name|Bnil
condition|)
return|return
name|Yes
return|;
comment|/* i.e., not found (used by in() !) */
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|Lim
argument_list|(
name|p
argument_list|)
condition|;
name|l
operator|++
control|)
block|{
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Inner
case|:
if|if
condition|(
operator|!
name|walktree
argument_list|(
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
argument_list|,
name|visit
argument_list|)
operator|||
operator|!
name|still_ok
condition|)
return|return
name|No
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|visit
call|)
argument_list|(
name|Piitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|wt
argument_list|)
argument_list|)
operator|||
operator|!
name|still_ok
condition|)
return|return
name|No
return|;
break|break;
case|case
name|Bottom
case|:
if|if
condition|(
operator|!
call|(
modifier|*
name|visit
call|)
argument_list|(
name|Pbitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|wt
argument_list|)
argument_list|)
operator|||
operator|!
name|still_ok
condition|)
return|return
name|No
return|;
block|}
block|}
return|return
name|Flag
argument_list|(
argument|p
argument_list|)
name|EQ
name|Bottom
operator|||
name|walktree
argument_list|(
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
argument_list|,
name|visit
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Common code for min/max-1/2, size2, in. */
end_comment

begin_decl_stmt
name|Hidden
name|Procedure
name|tlt_func
argument_list|(
name|e
argument_list|,
name|t
argument_list|,
name|where
argument_list|,
name|li_func
argument_list|,
name|te_visit
argument_list|,
name|ta_visit
argument_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* [e] func t */
end_comment

begin_decl_stmt
name|string
name|where
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "in [e] func_name t" */
end_comment

begin_function_decl
name|value
function_decl|(
modifier|*
name|li_func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* func for lists */
end_comment

begin_decl_stmt
name|bool
argument_list|(
operator|*
name|te_visit
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|ta_visit
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'visit' for walktree */
end_comment

begin_block
block|{
name|m_val
operator|=
name|Vnil
expr_stmt|;
if|if
condition|(
name|empty
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error3
argument_list|(
name|MESSMAKE
argument_list|(
name|where
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESS
argument_list|(
literal|1707
argument_list|,
literal|", t is empty"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|wt
operator|=
name|Itemwidth
argument_list|(
name|Itemtype
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|tt
operator|=
name|Type
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tt
condition|)
block|{
case|case
name|Lis
case|:
name|m_val
operator|=
call|(
modifier|*
name|li_func
call|)
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tex
case|:
if|if
condition|(
name|e
name|NE
name|Vnil
condition|)
block|{
if|if
condition|(
operator|!
name|Character
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|error3
argument_list|(
name|MESSMAKE
argument_list|(
name|where
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESS
argument_list|(
literal|1708
argument_list|,
literal|", t is a text, but e is not a character"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ce
operator|=
name|Bchar
argument_list|(
name|Root
argument_list|(
name|e
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|found
operator|=
operator|!
name|walktree
argument_list|(
name|Root
argument_list|(
name|t
argument_list|)
argument_list|,
name|te_visit
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_char
name|NE
name|Lowchar
operator|&&
name|m_char
name|NE
name|Highchar
condition|)
name|m_val
operator|=
name|mkchar
argument_list|(
name|m_char
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tab
case|:
name|ve
operator|=
name|e
expr_stmt|;
name|found
operator|=
operator|!
name|walktree
argument_list|(
name|Root
argument_list|(
name|t
argument_list|)
argument_list|,
name|ta_visit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error3
argument_list|(
name|MESSMAKE
argument_list|(
name|where
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESS
argument_list|(
literal|1709
argument_list|,
literal|", t is not a text list or table"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|Hidden
name|value
name|li2size
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
name|count
operator|=
name|l2size
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|te2size
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|ce
name|EQ
name|Charval
argument_list|(
name|pitm
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|ta2size
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|compare
argument_list|(
argument|ve
argument_list|,
argument|Ascval(pitm)
argument_list|)
name|EQ
literal|0
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|size2
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
comment|/* e#t */
if|if
condition|(
name|empty
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Must check here because tlt_func would complain */
return|return
name|copy
argument_list|(
name|zero
argument_list|)
return|;
name|m_char
operator|=
name|Lowchar
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|tlt_func
argument_list|(
name|e
argument_list|,
name|t
argument_list|,
literal|"in e#t"
argument_list|,
name|li2size
argument_list|,
name|te2size
argument_list|,
name|ta2size
argument_list|)
expr_stmt|;
return|return
name|mk_integer
argument_list|(
name|count
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|li_in
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
name|found
operator|=
name|in_keys
argument_list|(
name|e
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|te_in
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
return|return
name|Charval
argument_list|(
argument|pitm
argument_list|)
name|NE
name|ce
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|ta_in
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
return|return
name|compare
argument_list|(
argument|ve
argument_list|,
argument|Ascval(pitm)
argument_list|)
name|NE
literal|0
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|in
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
if|if
condition|(
name|empty
argument_list|(
name|t
argument_list|)
condition|)
comment|/* Must check here because tlt_func would complain */
return|return
name|No
return|;
name|m_char
operator|=
name|Lowchar
expr_stmt|;
name|found
operator|=
name|No
expr_stmt|;
name|tlt_func
argument_list|(
name|e
argument_list|,
name|t
argument_list|,
literal|"in the test e in t"
argument_list|,
name|li_in
argument_list|,
name|te_in
argument_list|,
name|ta_in
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|li_min
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
return|return
name|th_of
argument_list|(
name|one
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|te_min
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|m_char
operator|>
name|Charval
argument_list|(
name|pitm
argument_list|)
condition|)
name|m_char
operator|=
name|Charval
argument_list|(
name|pitm
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|ta_min
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|m_val
name|EQ
name|Vnil
operator|||
name|compare
argument_list|(
name|m_val
argument_list|,
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|release
argument_list|(
name|m_val
argument_list|)
expr_stmt|;
name|m_val
operator|=
name|copy
argument_list|(
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|min1
parameter_list|(
name|t
parameter_list|)
name|value
name|t
decl_stmt|;
block|{
name|m_char
operator|=
name|Highchar
expr_stmt|;
name|tlt_func
argument_list|(
name|Vnil
argument_list|,
name|t
argument_list|,
literal|"in min t"
argument_list|,
name|li_min
argument_list|,
name|te_min
argument_list|,
name|ta_min
argument_list|)
expr_stmt|;
return|return
name|m_val
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|li_max
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
name|value
name|v
init|=
name|size
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|m_val
operator|=
name|th_of
argument_list|(
name|v
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|m_val
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|te_max
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|m_char
operator|<
name|Charval
argument_list|(
name|pitm
argument_list|)
condition|)
name|m_char
operator|=
name|Charval
argument_list|(
name|pitm
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|ta_max
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|m_val
name|EQ
name|Vnil
operator|||
name|compare
argument_list|(
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|,
name|m_val
argument_list|)
operator|>
literal|0
condition|)
block|{
name|release
argument_list|(
name|m_val
argument_list|)
expr_stmt|;
name|m_val
operator|=
name|copy
argument_list|(
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|max1
parameter_list|(
name|t
parameter_list|)
name|value
name|t
decl_stmt|;
block|{
name|m_char
operator|=
name|Lowchar
expr_stmt|;
name|tlt_func
argument_list|(
name|Vnil
argument_list|,
name|t
argument_list|,
literal|"in max t"
argument_list|,
name|li_max
argument_list|,
name|te_max
argument_list|,
name|ta_max
argument_list|)
expr_stmt|;
return|return
name|m_val
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|te2min
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|m_char
operator|>
name|Charval
argument_list|(
name|pitm
argument_list|)
operator|&&
name|Charval
argument_list|(
name|pitm
argument_list|)
operator|>
name|ce
condition|)
block|{
name|m_char
operator|=
name|Charval
argument_list|(
name|pitm
argument_list|)
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|ta2min
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|compare
argument_list|(
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|,
name|ve
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|m_val
name|EQ
name|Vnil
operator|||
name|compare
argument_list|(
name|m_val
argument_list|,
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|release
argument_list|(
name|m_val
argument_list|)
expr_stmt|;
name|m_val
operator|=
name|copy
argument_list|(
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|min2
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
name|m_char
operator|=
name|Highchar
expr_stmt|;
name|tlt_func
argument_list|(
name|e
argument_list|,
name|t
argument_list|,
literal|"in e min t"
argument_list|,
name|l2min
argument_list|,
name|te2min
argument_list|,
name|ta2min
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_val
name|EQ
name|Vnil
operator|&&
name|still_ok
condition|)
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1710
argument_list|,
literal|"in e min t, no element of t exceeds e"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|m_val
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Hidden
name|bool
name|te2max
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|ce
operator|>
name|Charval
argument_list|(
name|pitm
argument_list|)
operator|&&
name|Charval
argument_list|(
name|pitm
argument_list|)
operator|>
name|m_char
condition|)
block|{
name|m_char
operator|=
name|Charval
argument_list|(
name|pitm
argument_list|)
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|ta2max
parameter_list|(
name|pitm
parameter_list|)
name|itemptr
name|pitm
decl_stmt|;
block|{
if|if
condition|(
name|compare
argument_list|(
name|ve
argument_list|,
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|m_val
name|EQ
name|Vnil
operator|||
name|compare
argument_list|(
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|,
name|m_val
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|release
argument_list|(
name|m_val
argument_list|)
expr_stmt|;
name|m_val
operator|=
name|copy
argument_list|(
name|Ascval
argument_list|(
name|pitm
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|max2
parameter_list|(
name|e
parameter_list|,
name|t
parameter_list|)
name|value
name|e
decl_stmt|,
name|t
decl_stmt|;
block|{
name|m_char
operator|=
name|Lowchar
expr_stmt|;
name|tlt_func
argument_list|(
name|e
argument_list|,
name|t
argument_list|,
literal|"in e max t"
argument_list|,
name|l2max
argument_list|,
name|te2max
argument_list|,
name|ta2max
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_val
name|EQ
name|Vnil
operator|&&
name|still_ok
condition|)
name|reqerr
argument_list|(
name|MESS
argument_list|(
literal|1711
argument_list|,
literal|"in e max t, no element of t is less than e"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|m_val
return|;
block|}
end_function

begin_else
else|#
directive|else
else|INTEGRATION
end_else

begin_function
name|Visible
name|value
name|mk_elt
parameter_list|()
block|{
return|return
name|grab_elt
argument_list|()
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|size
parameter_list|(
name|x
parameter_list|)
name|value
name|x
decl_stmt|;
block|{
comment|/* monadic # operator */
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|x
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1712
argument_list|,
literal|"in #t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mk_integer
argument_list|(
operator|(
name|int
operator|)
name|Length
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Lisent
parameter_list|(
name|tp
parameter_list|,
name|k
parameter_list|)
value|(*(tp+(k)))
end_define

begin_function
name|Visible
name|value
name|size2
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|value
name|v
decl_stmt|,
name|t
decl_stmt|;
block|{
comment|/* Dyadic # operator */
name|intlet
name|len
init|=
name|Length
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
name|value
modifier|*
name|tp
init|=
name|Ats
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|1713
argument_list|,
literal|"in e#t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mk_integer
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
return|;
block|}
switch|switch
condition|(
name|Type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|Tex
case|:
block|{
name|string
name|cp
init|=
operator|(
name|string
operator|)
name|tp
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|v
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1714
argument_list|,
literal|"in e#t, t is a text but e is not"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Length
argument_list|(
name|v
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1715
argument_list|,
literal|"in e#t, e is a text but not a character"
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|Str
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Overall
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
name|c
condition|)
name|n
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ELT
case|:
break|break;
case|case
name|Lis
case|:
block|{
name|intlet
name|lo
init|=
operator|-
literal|1
decl_stmt|,
name|mi
decl_stmt|,
name|xx
decl_stmt|,
name|mm
decl_stmt|,
name|hi
init|=
name|len
decl_stmt|;
name|relation
name|c
decl_stmt|;
name|bins
label|:
if|if
condition|(
name|hi
operator|-
name|lo
operator|<
literal|2
condition|)
break|break;
name|mi
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|compare
argument_list|(
name|v
argument_list|,
name|Lisent
argument_list|(
name|tp
argument_list|,
name|mi
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|some
goto|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|hi
operator|=
name|mi
expr_stmt|;
else|else
name|lo
operator|=
name|mi
expr_stmt|;
goto|goto
name|bins
goto|;
name|some
label|:
name|xx
operator|=
name|mi
expr_stmt|;
while|while
condition|(
name|xx
operator|-
name|lo
operator|>
literal|1
condition|)
block|{
name|mm
operator|=
operator|(
name|lo
operator|+
name|xx
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|v
argument_list|,
name|Lisent
argument_list|(
name|tp
argument_list|,
name|mm
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|xx
operator|=
name|mm
expr_stmt|;
else|else
name|lo
operator|=
name|mm
expr_stmt|;
block|}
name|xx
operator|=
name|mi
expr_stmt|;
while|while
condition|(
name|hi
operator|-
name|xx
operator|>
literal|1
condition|)
block|{
name|mm
operator|=
operator|(
name|xx
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|v
argument_list|,
name|Lisent
argument_list|(
name|tp
argument_list|,
name|mm
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|xx
operator|=
name|mm
expr_stmt|;
else|else
name|hi
operator|=
name|mm
expr_stmt|;
block|}
name|n
operator|=
name|hi
operator|-
name|lo
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|Tab
case|:
name|Overall
if|if
condition|(
name|compare
argument_list|(
name|v
argument_list|,
name|Dts
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|n
operator|++
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1716
argument_list|,
literal|"e#t with non text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|mk_integer
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|less
parameter_list|(
name|r
parameter_list|)
name|relation
name|r
decl_stmt|;
block|{
return|return
name|r
operator|<
literal|0
return|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|greater
parameter_list|(
name|r
parameter_list|)
name|relation
name|r
decl_stmt|;
block|{
return|return
name|r
operator|>
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|Hidden
name|value
name|mm1
argument_list|(
name|t
argument_list|,
name|rel
argument_list|)
name|value
name|t
decl_stmt|;
end_decl_stmt

begin_function_decl
name|bool
function_decl|(
modifier|*
name|rel
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|intlet
name|len
init|=
name|Length
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|value
name|m
decl_stmt|,
modifier|*
name|tp
init|=
name|Ats
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|Type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|Tex
case|:
block|{
name|string
name|cp
init|=
operator|(
name|string
operator|)
name|tp
decl_stmt|;
name|char
name|mc
init|=
literal|'\0'
decl_stmt|,
name|mm
index|[
literal|2
index|]
decl_stmt|;
name|Overall
block|{
if|if
condition|(
name|mc
operator|==
literal|'\0'
operator|||
operator|(
call|(
modifier|*
name|rel
call|)
argument_list|(
operator|*
name|cp
operator|<
name|mc
condition|?
operator|-
literal|1
else|:
operator|(
operator|*
name|cp
operator|>
name|mc
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
operator|)
condition|)
name|mc
operator|=
operator|*
name|cp
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|mm
index|[
literal|0
index|]
operator|=
name|mc
expr_stmt|;
name|mm
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|m
operator|=
name|mk_text
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Lis
case|:
if|if
condition|(
call|(
modifier|*
name|rel
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
comment|/*min*/
name|m
operator|=
name|copy
argument_list|(
operator|*
name|Ats
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|copy
argument_list|(
operator|*
operator|(
name|Ats
argument_list|(
name|t
argument_list|)
operator|+
name|len
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tab
case|:
block|{
name|value
name|dm
init|=
name|Vnil
decl_stmt|;
name|Overall
block|{
if|if
condition|(
name|dm
operator|==
name|Vnil
operator|||
call|(
modifier|*
name|rel
call|)
argument_list|(
name|compare
argument_list|(
name|Dts
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|dm
argument_list|)
argument_list|)
condition|)
name|dm
operator|=
name|Dts
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
name|m
operator|=
name|copy
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1717
argument_list|,
literal|"min or max t, with non text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NO_ABS
end_ifdef

begin_function
name|Hidden
name|int
name|abs
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
return|return
name|i
operator|>=
literal|0
condition|?
name|i
else|:
operator|-
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Hidden
name|value
name|mm2
argument_list|(
name|v
argument_list|,
name|t
argument_list|,
name|rel
argument_list|)
name|value
name|v
decl_stmt|,
name|t
decl_stmt|;
end_decl_stmt

begin_function_decl
name|bool
function_decl|(
modifier|*
name|rel
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|intlet
name|len
init|=
name|Length
argument_list|(
name|t
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|value
name|m
init|=
name|Vnil
decl_stmt|,
modifier|*
name|tp
init|=
name|Ats
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|Type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|Tex
case|:
block|{
name|string
name|cp
init|=
operator|(
name|string
operator|)
name|tp
decl_stmt|;
name|char
name|c
decl_stmt|,
name|mc
init|=
literal|'\0'
decl_stmt|,
name|mm
index|[
literal|2
index|]
decl_stmt|;
name|c
operator|=
operator|*
name|Str
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Overall
block|{
if|if
condition|(
call|(
modifier|*
name|rel
call|)
argument_list|(
name|c
operator|<
operator|*
name|cp
condition|?
operator|-
literal|1
else|:
name|c
operator|>
operator|*
name|cp
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|mc
operator|==
literal|'\0'
operator|||
call|(
modifier|*
name|rel
call|)
argument_list|(
operator|*
name|cp
operator|<
name|mc
condition|?
operator|-
literal|1
else|:
operator|*
name|cp
operator|>
name|mc
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
name|mc
operator|=
operator|*
name|cp
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mc
operator|!=
literal|'\0'
condition|)
block|{
name|mm
index|[
literal|0
index|]
operator|=
name|mc
expr_stmt|;
name|mm
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|m
operator|=
name|mk_text
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|Lis
case|:
block|{
name|intlet
name|lim1
decl_stmt|,
name|mid
decl_stmt|,
name|lim2
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|rel
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/*min*/
name|lim1
operator|=
literal|1
expr_stmt|;
name|lim2
operator|=
name|len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lim2
operator|=
literal|1
expr_stmt|;
name|lim1
operator|=
name|len
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|rel
call|)
argument_list|(
name|compare
argument_list|(
name|v
argument_list|,
name|Lisent
argument_list|(
name|tp
argument_list|,
name|lim2
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|len
operator|==
literal|1
operator|||
call|(
modifier|*
name|rel
call|)
argument_list|(
name|compare
argument_list|(
name|v
argument_list|,
name|Lisent
argument_list|(
name|tp
argument_list|,
name|lim1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|m
operator|=
name|copy
argument_list|(
name|Lisent
argument_list|(
name|tp
argument_list|,
name|lim1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* v rel tp[lim2]&& !(v rel tp[lim1]) */
while|while
condition|(
name|abs
argument_list|(
name|lim2
operator|-
name|lim1
argument_list|)
operator|>
literal|1
condition|)
block|{
name|mid
operator|=
operator|(
name|lim1
operator|+
name|lim2
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|rel
call|)
argument_list|(
name|compare
argument_list|(
name|v
argument_list|,
name|Lisent
argument_list|(
name|tp
argument_list|,
name|mid
argument_list|)
argument_list|)
argument_list|)
condition|)
name|lim2
operator|=
name|mid
expr_stmt|;
else|else
name|lim1
operator|=
name|mid
expr_stmt|;
block|}
name|m
operator|=
name|copy
argument_list|(
name|Lisent
argument_list|(
name|tp
argument_list|,
name|lim2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Tab
case|:
block|{
name|value
name|dm
init|=
name|Vnil
decl_stmt|;
name|Overall
block|{
if|if
condition|(
call|(
modifier|*
name|rel
call|)
argument_list|(
name|compare
argument_list|(
name|v
argument_list|,
name|Dts
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|dm
operator|==
name|Vnil
operator|||
call|(
modifier|*
name|rel
call|)
argument_list|(
name|compare
argument_list|(
name|Dts
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|dm
argument_list|)
argument_list|)
condition|)
name|dm
operator|=
name|Dts
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
block|}
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dm
operator|!=
name|Vnil
condition|)
name|m
operator|=
name|copy
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1718
argument_list|,
literal|"min2 or max2 with non text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|m
return|;
block|}
end_block

begin_function
name|Visible
name|value
name|min1
parameter_list|(
name|t
parameter_list|)
name|value
name|t
decl_stmt|;
block|{
comment|/* Monadic min */
name|value
name|m
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1719
argument_list|,
literal|"in min t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1720
argument_list|,
literal|"in min t, t is empty"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|mm1
argument_list|(
name|t
argument_list|,
name|less
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|min2
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|value
name|v
decl_stmt|,
name|t
decl_stmt|;
block|{
name|value
name|m
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1721
argument_list|,
literal|"in e min t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1722
argument_list|,
literal|"in e min t, t is empty"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Is_text
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1723
argument_list|,
literal|"in e min t, t is a text but e is not"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|v
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1724
argument_list|,
literal|"in e min t, e is a text but not a character"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|still_ok
condition|)
block|{
name|m
operator|=
name|mm2
argument_list|(
name|v
argument_list|,
name|t
argument_list|,
name|less
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|Vnil
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1725
argument_list|,
literal|"in e min t, no element of t exceeds e"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|max1
parameter_list|(
name|t
parameter_list|)
name|value
name|t
decl_stmt|;
block|{
name|value
name|m
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1726
argument_list|,
literal|"in max t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1727
argument_list|,
literal|"in max t, t is empty"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|mm1
argument_list|(
name|t
argument_list|,
name|greater
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|max2
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|value
name|v
decl_stmt|,
name|t
decl_stmt|;
block|{
name|value
name|m
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1728
argument_list|,
literal|"in e max t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1729
argument_list|,
literal|"in e max t, t is empty"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Is_text
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1730
argument_list|,
literal|"in e max t, t is a text but e is not"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|v
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1731
argument_list|,
literal|"in e max t, e is a text but not a character"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|still_ok
condition|)
block|{
name|m
operator|=
name|mm2
argument_list|(
name|v
argument_list|,
name|t
argument_list|,
name|greater
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|Vnil
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1732
argument_list|,
literal|"in e max t, no element of t is less than e"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|th_of
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
name|value
name|n
decl_stmt|,
name|t
decl_stmt|;
block|{
return|return
name|thof
argument_list|(
name|intval
argument_list|(
name|n
argument_list|)
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|thof
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
name|int
name|n
decl_stmt|;
name|value
name|t
decl_stmt|;
block|{
name|intlet
name|len
init|=
name|Length
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|value
name|w
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1733
argument_list|,
literal|"in n th'of t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|n
operator|>
name|len
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1734
argument_list|,
literal|"in n th'of t, n is out of bounds"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|Type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|Tex
case|:
block|{
name|char
name|ww
index|[
literal|2
index|]
decl_stmt|;
name|ww
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|Str
argument_list|(
name|t
argument_list|)
operator|+
name|n
operator|-
literal|1
operator|)
expr_stmt|;
name|ww
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|w
operator|=
name|mk_text
argument_list|(
name|ww
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Lis
case|:
name|w
operator|=
name|copy
argument_list|(
operator|*
operator|(
name|Ats
argument_list|(
name|t
argument_list|)
operator|+
name|n
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tab
case|:
name|w
operator|=
name|copy
argument_list|(
name|Dts
argument_list|(
operator|*
operator|(
name|Ats
argument_list|(
name|t
argument_list|)
operator|+
name|n
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1735
argument_list|,
literal|"th'of with non text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|w
return|;
block|}
end_function

begin_decl_stmt
name|Visible
name|bool
name|found
argument_list|(
name|elem
argument_list|,
name|v
argument_list|,
name|probe
argument_list|,
name|where
argument_list|)
name|value
argument_list|(
operator|*
name|elem
argument_list|)
argument_list|()
decl_stmt|,
name|v
decl_stmt|,
name|probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|intlet
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* think of elem(v,lo-1) as -Infinity and elem(v,hi+1) as +Infinity. 	   found and where at the end satisfy: 	   SELECT: 	       SOME k IN {lo..hi} HAS probe = elem(v,k): 		   found = Yes AND where = k 	       ELSE: found = No AND elem(v,where-1)< probe< elem(v,where). 	*/
end_comment

begin_block
block|{
name|relation
name|c
decl_stmt|;
name|intlet
name|lo
init|=
literal|0
decl_stmt|,
name|hi
init|=
name|Length
argument_list|(
name|v
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|lo
operator|>
name|hi
condition|)
block|{
operator|*
name|where
operator|=
name|lo
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|compare
argument_list|(
name|probe
argument_list|,
call|(
modifier|*
name|elem
call|)
argument_list|(
name|v
argument_list|,
name|lo
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|where
operator|=
name|lo
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
operator|*
name|where
operator|=
name|lo
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
name|lo
operator|==
name|hi
condition|)
block|{
operator|*
name|where
operator|=
name|hi
operator|+
literal|1
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|compare
argument_list|(
name|probe
argument_list|,
call|(
modifier|*
name|elem
call|)
argument_list|(
name|v
argument_list|,
name|hi
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|where
operator|=
name|hi
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
operator|*
name|where
operator|=
name|hi
operator|+
literal|1
expr_stmt|;
return|return
name|No
return|;
block|}
comment|/* elem(lo)< probe< elem(hi) */
while|while
condition|(
name|hi
operator|-
name|lo
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|compare
argument_list|(
name|probe
argument_list|,
call|(
modifier|*
name|elem
call|)
argument_list|(
name|v
argument_list|,
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|where
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|hi
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
else|else
name|lo
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|where
operator|=
name|hi
expr_stmt|;
return|return
name|No
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|in
parameter_list|(
name|v
parameter_list|,
name|t
parameter_list|)
name|value
name|v
decl_stmt|,
name|t
decl_stmt|;
block|{
name|intlet
name|where
decl_stmt|,
name|k
decl_stmt|,
name|len
init|=
name|Length
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|value
modifier|*
name|tp
init|=
name|Ats
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|1736
argument_list|,
literal|"in the test e in t, t is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
switch|switch
condition|(
name|Type
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|Tex
case|:
if|if
condition|(
name|Type
argument_list|(
name|v
argument_list|)
operator|!=
name|Tex
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1737
argument_list|,
literal|"in the test e in t, t is a text but e is not"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Length
argument_list|(
name|v
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|1738
argument_list|,
literal|"in the test e in t, e is a text but not a character"
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|index
argument_list|(
operator|(
name|string
operator|)
name|tp
argument_list|,
operator|*
name|Str
argument_list|(
name|v
argument_list|)
argument_list|)
operator|!=
literal|0
return|;
return|return
name|No
return|;
case|case
name|ELT
case|:
return|return
name|No
return|;
case|case
name|Lis
case|:
return|return
name|found
argument_list|(
name|list_elem
argument_list|,
name|t
argument_list|,
name|v
argument_list|,
operator|&
name|where
argument_list|)
return|;
case|case
name|Tab
case|:
name|Overall
if|if
condition|(
name|compare
argument_list|(
name|v
argument_list|,
name|Dts
argument_list|(
operator|*
name|tp
operator|++
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Yes
return|;
return|return
name|No
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1739
argument_list|,
literal|"e in t with non text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
block|}
end_function

begin_function
name|Visible
name|bool
name|empty
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
switch|switch
condition|(
name|Type
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
name|Tex
case|:
case|case
name|Lis
case|:
case|case
name|Tab
case|:
case|case
name|ELT
case|:
return|return
operator|(
name|Length
argument_list|(
name|v
argument_list|)
operator|==
literal|0
operator|)
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|1740
argument_list|,
literal|"empty() on non tlt value"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|No
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|INTEGRATION
end_endif

end_unit

