begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: edit.c,v 2.5 85/08/22 16:01:43 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Read unit from file.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"feat.h"
end_include

begin_include
include|#
directive|include
file|"erro.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"tabl.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"supr.h"
end_include

begin_include
include|#
directive|include
file|"queu.h"
end_include

begin_function_decl
name|string
name|unixerror
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * TABSIZE sets the number of spaces equivalent to a tab character  * read from the input; INDENT sets the number of spaces for one indentation  * level.  * The definitions here are unrelated to the definition of TABS  * in eval.h (used by show.c and eval.c).  The definition here only  * defines how many spaces must be equivalenced to a tab stop when read  * from a file; tab stops must be caused by editing a unit with another  * editor (vi, ed, ex, emacs), since "save.c" always writes spaces,  * not tabs.  The value '4' is best suited for people at the CWI who  * may have workspaces with units edited with the previous version of  * the B editor, which emitted a tab for each indentation level (and  * assumed 4 spaces for a tab stop on input).  *  * The variables 'spacesused' and 'tabsused' are kept to see if mixed use  * of spaces and tabs was made; this can cause indentation errors.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CWI
end_ifdef

begin_define
define|#
directive|define
name|TABSIZE
value|4
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TABSIZE
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INDENT
value|4
end_define

begin_decl_stmt
name|Hidden
name|bool
name|spacesused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Hidden
name|bool
name|tabsused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read (edit) parse tree from file into the focus.  * Rather ad hoc, we use ins_string for each line  * and do some magic tricks to get the indentation right  * (most of the time).  * If line> 0, position the focus at that line, if possible;  * otherwise the focus is left at the end of the inserted text.  */
end_comment

begin_function
name|Visible
name|bool
name|edit
parameter_list|(
name|ep
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
name|string
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|int
name|lines
init|=
literal|0
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|auto
name|string
name|cp
decl_stmt|;
specifier|auto
name|queue
name|q
init|=
name|Qnil
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
name|unixerror
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|spacesused
operator|=
name|tabsused
operator|=
name|No
expr_stmt|;
do|do
block|{
do|do
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
literal|1
condition|;
operator|++
name|cp
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>=
literal|0177
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>
name|buf
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ins_string
argument_list|(
name|ep
argument_list|,
name|buf
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|emptyqueue
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|qrelease
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|EDIT_BAD
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|qrelease
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
do|;
operator|++
name|lines
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|!
name|editindentation
argument_list|(
name|ep
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
name|EOF
condition|)
do|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mode
operator|==
name|FHOLE
operator|||
name|ep
operator|->
name|mode
operator|==
name|VHOLE
operator|&&
operator|(
name|ep
operator|->
name|s1
operator|&
literal|1
operator|)
condition|)
block|{
name|cp
operator|=
literal|""
expr_stmt|;
name|soften
argument_list|(
name|ep
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lines
operator|>
literal|1
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|gotoyx
argument_list|(
name|ep
argument_list|,
name|line
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oneline
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spacesused
operator|&&
name|tabsused
condition|)
name|error
argument_list|(
name|EDIT_TABS
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the footwork required to get the indentation proper.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|editindentation
parameter_list|(
name|ep
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|tabs
init|=
literal|0
decl_stmt|;
specifier|auto
name|int
name|level
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
name|spacesused
operator|=
name|Yes
expr_stmt|;
operator|++
name|tabs
expr_stmt|;
block|}
else|else
block|{
name|tabsused
operator|=
name|Yes
expr_stmt|;
name|tabs
operator|=
operator|(
name|tabs
operator|/
name|TABSIZE
operator|+
literal|1
operator|)
operator|*
name|TABSIZE
expr_stmt|;
block|}
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
return|return
name|Yes
return|;
name|tabs
operator|=
operator|(
name|tabs
operator|+
operator|(
name|INDENT
operator|/
literal|2
operator|)
operator|)
operator|/
name|INDENT
expr_stmt|;
comment|/* Transform to tab stops */
if|if
condition|(
operator|!
name|ins_newline
argument_list|(
name|ep
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|debug
argument_list|(
literal|"[Burp! Can't insert a newline.]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
return|return
name|No
return|;
block|}
name|level
operator|=
name|Level
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|tabs
operator|<
name|level
condition|;
operator|--
name|level
control|)
block|{
if|if
condition|(
operator|!
name|ins_newline
argument_list|(
name|ep
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|debug
argument_list|(
literal|"[Burp, burp! Can't decrease indentation.]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NDEBUG
return|return
name|No
return|;
block|}
block|}
name|fixit
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SAVEBUF
end_ifdef

begin_comment
comment|/*  * Read the next non-space character.  */
end_comment

begin_function
name|Hidden
name|int
name|skipsp
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|' '
condition|)
do|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Read a text in standard B format when the initial quote has already  * been read.  */
end_comment

begin_function
name|Hidden
name|value
name|readtext
parameter_list|(
name|fp
parameter_list|,
name|quote
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
name|quote
decl_stmt|;
block|{
specifier|auto
name|value
name|v
init|=
name|Vnil
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|string
name|cp
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|auto
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|cp
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|!=
literal|' '
operator|&&
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|debug
argument_list|(
literal|"readtext: EOF"
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
literal|"readtext: bad char (0%02o)"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
comment|/* Bad character or EOF */
block|}
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|quote
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'`'
condition|)
block|{
name|c
operator|=
name|skipsp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|1
operator|||
name|i
operator|==
literal|0
operator|||
operator|!
name|isascii
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"readtext: error in conversion"
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|c
operator|=
name|skipsp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|'`'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'`'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|debug
argument_list|(
literal|"readtext: EOF in conversion"
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
literal|"readtext: bad char in conversion (0%o)"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|c
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|concato
argument_list|(
operator|&
name|v
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|mk_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
return|return
name|mk_text
argument_list|(
name|buf
argument_list|)
return|;
name|concato
argument_list|(
operator|&
name|v
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|Hidden
name|int
name|readsym
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|string
name|bufp
decl_stmt|;
for|for
control|(
name|bufp
operator|=
name|buf
init|;
condition|;
operator|++
name|bufp
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
condition|)
block|{
if|if
condition|(
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|syserr
argument_list|(
literal|"readsym: ungetc failed"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|bufp
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|bufp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|atoi
argument_list|(
name|buf
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"Required"
argument_list|)
operator|==
literal|0
condition|)
comment|/***** Compatibility hack *****/
return|return
name|Hole
return|;
return|return
name|nametosym
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a node in internal format (recursively).  * Return nil pointer if EOF or error.  */
end_comment

begin_function
name|Hidden
name|node
name|readnode
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|nch
decl_stmt|;
name|node
name|ch
index|[
name|MAXCHILD
index|]
decl_stmt|;
name|node
name|n
decl_stmt|;
name|int
name|sym
decl_stmt|;
name|c
operator|=
name|skipsp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
return|return
name|Nnil
return|;
comment|/* EOF hit */
case|case
literal|'('
case|:
name|sym
operator|=
name|readsym
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"readnode: missing symbol"
argument_list|)
expr_stmt|;
return|return
name|Nnil
return|;
comment|/* No number as first item */
block|}
if|if
condition|(
name|sym
operator|<
literal|0
operator|||
name|sym
operator|>
name|Hole
condition|)
block|{
name|debug
argument_list|(
literal|"readnode: bad symbol (%d)"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
return|return
name|Nnil
return|;
block|}
name|nch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|skipsp
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|','
operator|&&
name|nch
operator|<
name|MAXCHILD
condition|)
block|{
name|n
operator|=
name|readnode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
for|for
control|(
init|;
name|nch
operator|>
literal|0
condition|;
operator|--
name|nch
control|)
name|noderelease
argument_list|(
name|ch
index|[
name|nch
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|Nnil
return|;
comment|/* Error encountered in child */
block|}
name|ch
index|[
name|nch
index|]
operator|=
name|n
expr_stmt|;
operator|++
name|nch
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|debug
argument_list|(
literal|"readnode: node too long (sym=%d)"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
literal|"readnode: no ')' where expected (sym=%d)"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nch
operator|>
literal|0
condition|;
operator|--
name|nch
control|)
name|noderelease
argument_list|(
name|ch
index|[
name|nch
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|Nnil
return|;
comment|/* Not terminated with ')' or too many children */
block|}
if|if
condition|(
name|nch
operator|==
literal|0
condition|)
return|return
name|gram
argument_list|(
name|sym
argument_list|)
return|;
comment|/* Saves space for Optional/Hole nodes */
return|return
name|newnode
argument_list|(
name|nch
argument_list|,
name|sym
argument_list|,
name|ch
argument_list|)
return|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
operator|(
name|node
operator|)
name|readtext
argument_list|(
name|fp
argument_list|,
name|c
argument_list|)
return|;
default|default:
name|debug
argument_list|(
literal|"readnode: bad initial character"
argument_list|)
expr_stmt|;
return|return
name|Nnil
return|;
comment|/* Bad initial character */
block|}
block|}
end_function

begin_comment
comment|/*  * Read a node written in a more or less internal format.  */
end_comment

begin_function
name|Visible
name|value
name|editqueue
parameter_list|(
name|filename
parameter_list|)
name|string
name|filename
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
specifier|auto
name|queue
name|q
init|=
name|Qnil
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|Vnil
return|;
do|do
block|{
name|n
operator|=
name|readnode
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
break|break;
comment|/* EOF or error */
name|addtoqueue
argument_list|(
operator|&
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|noderelease
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|skipsp
argument_list|(
name|fp
argument_list|)
operator|==
literal|'\n'
condition|)
do|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
name|q
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|SAVEBUF
end_endif

end_unit

