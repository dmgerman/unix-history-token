begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: save.c,v 2.5 85/08/22 16:07:04 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Save Parse tree on file.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"feat.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_include
include|#
directive|include
file|"queu.h"
end_include

begin_define
define|#
directive|define
name|Indent
value|"    "
end_define

begin_comment
comment|/* Output for each indentation level */
end_comment

begin_decl_stmt
name|Hidden
name|int
name|spaces
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved-up spaces; emitted when non-blank found */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BTOP
end_ifdef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|Hidden
name|bool
name|piping
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if output goes to B interpreter */
end_comment

begin_decl_stmt
name|Hidden
name|jmp_buf
name|alas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to go when no command prompt gotten */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Write the representation of a node.  If it has children,  * they are written by recursive calls.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|savewalk
parameter_list|(
name|n
parameter_list|,
name|level
parameter_list|,
name|file
parameter_list|)
name|node
name|n
decl_stmt|;
name|int
name|level
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|string
modifier|*
name|rp
decl_stmt|;
name|string
name|cp
decl_stmt|;
name|int
name|nch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|)
block|{
for|for
control|(
init|;
name|spaces
operator|>
literal|0
condition|;
operator|--
name|spaces
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|Str
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|nch
operator|=
name|nchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|rp
operator|=
name|noderepr
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nch
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
name|savewalk
argument_list|(
name|child
argument_list|(
name|n
argument_list|,
name|i
argument_list|)
argument_list|,
name|level
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
for|for
control|(
init|;
name|c
operator|=
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BTOP
if|if
condition|(
name|piping
condition|)
block|{
if|if
condition|(
operator|!
name|expect
argument_list|(
literal|">>> "
argument_list|)
condition|)
name|longjmp
argument_list|(
name|alas
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|BTOP
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
for|for
control|(
name|i
operator|=
name|level
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|fputs
argument_list|(
name|Indent
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|spaces
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
operator|--
name|level
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
operator|++
name|level
expr_stmt|;
break|break;
case|case
literal|' '
case|:
operator|++
name|spaces
expr_stmt|;
break|break;
default|default:
for|for
control|(
init|;
name|spaces
operator|>
literal|0
condition|;
operator|--
name|spaces
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Save the entire Parse tree.  */
end_comment

begin_function
name|Visible
name|bool
name|save
parameter_list|(
name|p
parameter_list|,
name|filename
parameter_list|)
name|path
name|p
decl_stmt|;
name|string
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return
name|No
return|;
ifdef|#
directive|ifdef
name|BTOP
name|piping
operator|=
name|No
expr_stmt|;
endif|#
directive|endif
endif|BTOP
name|sendsave
argument_list|(
name|p
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|fclose
argument_list|(
name|file
argument_list|)
operator|!=
name|EOF
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|sendsave
parameter_list|(
name|p
parameter_list|,
name|file
parameter_list|)
name|path
name|p
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|p
operator|=
name|pathcopy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|top
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|spaces
operator|=
literal|0
expr_stmt|;
name|savewalk
argument_list|(
name|tree
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|pathrelease
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BTOP
end_ifdef

begin_comment
comment|/*  * Interface to top level.  */
end_comment

begin_function
name|Visible
name|bool
name|send
parameter_list|(
name|p
parameter_list|,
name|pdown
parameter_list|)
name|path
name|p
decl_stmt|;
name|FILE
modifier|*
name|pdown
decl_stmt|;
block|{
name|piping
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|alas
argument_list|)
condition|)
block|{
name|pathrelease
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|sendsave
argument_list|(
name|p
argument_list|,
name|pdown
argument_list|)
expr_stmt|;
if|if
condition|(
name|expect
argument_list|(
literal|">>> "
argument_list|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pdown
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|BTOP
end_endif

begin_comment
comment|/* ------------------------------------------------------------------ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SAVEBUF
end_ifdef

begin_comment
comment|/*  * Write a node.  */
end_comment

begin_function
name|Hidden
name|Procedure
name|writenode
parameter_list|(
name|n
parameter_list|,
name|fp
parameter_list|)
name|node
name|n
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|nch
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|fputs
argument_list|(
literal|"(0)"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|value
operator|)
name|n
operator|)
operator|->
name|type
operator|==
name|Tex
condition|)
block|{
name|writetext
argument_list|(
operator|(
name|value
operator|)
name|n
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|nch
operator|=
name|nchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(%s"
argument_list|,
name|symname
argument_list|(
name|symbol
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nch
condition|;
operator|++
name|i
control|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|writenode
argument_list|(
name|child
argument_list|(
name|n
argument_list|,
name|i
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|')'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|writetext
parameter_list|(
name|v
parameter_list|,
name|fp
parameter_list|)
name|value
name|v
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|string
name|str
decl_stmt|;
name|int
name|c
decl_stmt|;
name|Assert
argument_list|(
name|v
operator|&&
name|Type
argument_list|(
name|v
argument_list|)
operator|==
name|Tex
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\''
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|str
operator|=
name|Str
argument_list|(
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|str
operator|=
name|Str
argument_list|(
name|v
argument_list|)
init|;
operator|*
name|str
condition|;
operator|++
name|str
control|)
block|{
name|c
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'`'
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"`$%d`"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\''
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|bool
name|savequeue
parameter_list|(
name|v
parameter_list|,
name|filename
parameter_list|)
name|value
name|v
decl_stmt|;
name|string
name|filename
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|auto
name|queue
name|q
init|=
operator|(
name|queue
operator|)
name|v
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
specifier|register
name|bool
name|ok
decl_stmt|;
specifier|register
name|int
name|lines
init|=
literal|0
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|No
return|;
name|q
operator|=
name|qcopy
argument_list|(
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|emptyqueue
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|n
operator|=
name|queuebehead
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|writenode
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|++
name|lines
expr_stmt|;
name|noderelease
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|ok
operator|=
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
expr_stmt|;
if|if
condition|(
operator|!
name|lines
condition|)
comment|/* Try to */
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/***** UNIX! *****/
return|return
name|ok
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|SAVEBUF
end_endif

end_unit

