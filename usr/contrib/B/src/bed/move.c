begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: move.c,v 2.4 85/08/22 16:05:16 timo Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * B editor -- Process arrow keys in four directions, plus TAB.  */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"bobj.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"supr.h"
end_include

begin_include
include|#
directive|include
file|"gram.h"
end_include

begin_define
define|#
directive|define
name|Left
value|(-1)
end_define

begin_define
define|#
directive|define
name|Rite
value|1
end_define

begin_comment
comment|/*  * Common code for PREVIOUS and NEXT commands.  */
end_comment

begin_function
name|Hidden
name|bool
name|prevnext
parameter_list|(
name|ep
parameter_list|,
name|direction
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
name|node
name|n
decl_stmt|;
name|node
name|n1
decl_stmt|;
name|int
name|nch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|sym
decl_stmt|;
name|string
modifier|*
name|rp
decl_stmt|;
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|mode
condition|)
block|{
case|case
name|VHOLE
case|:
case|case
name|FHOLE
case|:
case|case
name|ATBEGIN
case|:
case|case
name|ATEND
case|:
if|if
condition|(
name|direction
operator|==
name|Left
condition|)
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
name|ritevhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|nch
operator|=
name|nchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|rp
operator|=
name|noderepr
argument_list|(
name|n
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|mode
condition|)
block|{
case|case
name|ATBEGIN
case|:
case|case
name|ATEND
case|:
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
continue|continue;
case|case
name|VHOLE
case|:
case|case
name|FHOLE
case|:
if|if
condition|(
name|direction
operator|==
name|Rite
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|s1
operator|&
literal|1
condition|)
name|len
operator|=
name|Fwidth
argument_list|(
name|rp
index|[
name|ep
operator|->
name|s1
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|n1
operator|=
name|child
argument_list|(
name|n
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|width
argument_list|(
name|n1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|direction
operator|==
name|Rite
condition|?
name|ep
operator|->
name|s2
operator|>=
name|len
else|:
name|ep
operator|->
name|s2
operator|<=
literal|0
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|SUBSET
expr_stmt|;
name|ep
operator|->
name|s2
operator|=
name|ep
operator|->
name|s1
expr_stmt|;
return|return
name|nextchar
argument_list|(
name|ep
argument_list|,
name|direction
argument_list|)
return|;
block|}
name|ep
operator|->
name|s2
operator|+=
name|direction
expr_stmt|;
return|return
name|Yes
return|;
case|case
name|SUBRANGE
case|:
if|if
condition|(
name|direction
operator|==
name|Rite
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|s1
operator|&
literal|1
condition|)
name|len
operator|=
name|Fwidth
argument_list|(
name|rp
index|[
name|ep
operator|->
name|s1
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|n1
operator|=
name|child
argument_list|(
name|n
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|width
argument_list|(
name|n1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|direction
operator|==
name|Left
condition|?
name|ep
operator|->
name|s2
operator|<=
literal|0
else|:
name|ep
operator|->
name|s3
operator|>=
name|len
operator|-
literal|1
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|SUBSET
expr_stmt|;
name|ep
operator|->
name|s2
operator|=
name|ep
operator|->
name|s1
expr_stmt|;
return|return
name|nextchar
argument_list|(
name|ep
argument_list|,
name|direction
argument_list|)
return|;
block|}
if|if
condition|(
name|direction
operator|==
name|Rite
condition|)
name|ep
operator|->
name|s2
operator|=
operator|++
name|ep
operator|->
name|s3
expr_stmt|;
else|else
name|ep
operator|->
name|s3
operator|=
operator|--
name|ep
operator|->
name|s2
expr_stmt|;
return|return
name|Yes
return|;
case|case
name|SUBSET
case|:
if|if
condition|(
name|direction
operator|==
name|Rite
condition|?
name|ep
operator|->
name|s2
operator|>
literal|2
operator|*
name|nch
else|:
name|ep
operator|->
name|s1
operator|<=
literal|1
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|direction
operator|==
name|Rite
condition|)
name|ep
operator|->
name|s1
operator|=
operator|++
name|ep
operator|->
name|s2
expr_stmt|;
else|else
name|ep
operator|->
name|s2
operator|=
operator|--
name|ep
operator|->
name|s1
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|s1
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|Fw_positive
argument_list|(
name|rp
index|[
name|ep
operator|->
name|s1
operator|/
literal|2
index|]
argument_list|)
operator|||
name|allspaces
argument_list|(
name|rp
index|[
name|ep
operator|->
name|s1
operator|/
literal|2
index|]
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
name|sym
operator|=
name|symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|downi
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|)
condition|)
block|{
name|n
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|value
operator|)
name|n
operator|)
operator|->
name|type
operator|==
name|Tex
condition|)
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ep
operator|->
name|s1
operator|==
literal|2
operator|*
name|nch
operator|&&
name|direction
operator|==
name|Rite
operator|&&
name|issublist
argument_list|(
name|sym
argument_list|)
operator|&&
name|samelevel
argument_list|(
name|sym
argument_list|,
name|symbol
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|SUBLIST
expr_stmt|;
name|ep
operator|->
name|s3
operator|=
literal|1
expr_stmt|;
return|return
name|Yes
return|;
block|}
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
if|if
condition|(
name|width
argument_list|(
name|n
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
block|}
block|}
return|return
name|Yes
return|;
case|case
name|SUBLIST
case|:
name|sym
operator|=
name|symbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|Left
condition|)
block|{
name|i
operator|=
name|ichild
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|up
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
return|return
name|No
return|;
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|n
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nchildren
argument_list|(
name|n
argument_list|)
operator|&&
name|samelevel
argument_list|(
name|sym
argument_list|,
name|symbol
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|ep
operator|->
name|s3
operator|=
literal|1
expr_stmt|;
return|return
name|Yes
return|;
block|}
name|ep
operator|->
name|mode
operator|=
name|SUBSET
expr_stmt|;
name|ep
operator|->
name|s1
operator|=
name|ep
operator|->
name|s2
operator|=
literal|2
operator|*
name|i
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
name|ep
operator|->
name|s3
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
operator|!
name|downrite
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
return|return
name|No
return|;
comment|/* Sorry... */
if|if
condition|(
name|samelevel
argument_list|(
name|sym
argument_list|,
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
argument_list|)
condition|)
name|ep
operator|->
name|s3
operator|=
literal|1
expr_stmt|;
else|else
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
return|return
name|Yes
return|;
case|case
name|WHOLE
case|:
name|i
operator|=
name|ichild
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|up
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
return|return
name|No
return|;
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|SUBSET
expr_stmt|;
name|ep
operator|->
name|s1
operator|=
name|ep
operator|->
name|s2
operator|=
literal|2
operator|*
name|i
expr_stmt|;
continue|continue;
default|default:
name|Abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Not reached */
block|}
end_function

begin_function
name|Visible
name|bool
name|leftarrow
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|w
decl_stmt|;
name|bool
name|hole
decl_stmt|;
if|if
condition|(
name|narrow
argument_list|(
name|ep
argument_list|)
condition|)
block|{
while|while
condition|(
name|narrow
argument_list|(
name|ep
argument_list|)
condition|)
empty_stmt|;
return|return
name|Yes
return|;
block|}
name|hole
operator|=
name|ep
operator|->
name|mode
operator|==
name|WHOLE
expr_stmt|;
comment|/* Can't narrow and still WHOLE: */
comment|/* a real hole which needs some hacking. */
if|if
condition|(
operator|!
name|previous
argument_list|(
name|ep
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
name|hole
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|w
operator|=
name|focwidth
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>=
literal|0
operator|&&
name|w
operator|<=
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
name|rnarrow
argument_list|(
name|ep
argument_list|)
condition|)
return|return
name|No
return|;
block|}
name|narrow
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|rnarrow
argument_list|(
name|ep
argument_list|)
condition|)
empty_stmt|;
block|}
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|ritearrow
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
while|while
condition|(
name|narrow
argument_list|(
name|ep
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|next
argument_list|(
name|ep
argument_list|)
condition|)
return|return
name|No
return|;
while|while
condition|(
name|narrow
argument_list|(
name|ep
argument_list|)
condition|)
empty_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|previous
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|prevnext
argument_list|(
name|ep
argument_list|,
name|Left
argument_list|)
condition|)
return|return
name|No
return|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|next
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|prevnext
argument_list|(
name|ep
argument_list|,
name|Rite
argument_list|)
condition|)
return|return
name|No
return|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Position focus at next or previous char relative to current position.  * Assume current position given as SUBSET.  */
end_comment

begin_function
name|Hidden
name|bool
name|nextchar
parameter_list|(
name|ep
parameter_list|,
name|direction
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|direction
decl_stmt|;
block|{
specifier|register
name|int
name|ich
decl_stmt|;
specifier|register
name|int
name|nch
decl_stmt|;
specifier|register
name|node
name|n
decl_stmt|;
name|node
name|n1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|string
modifier|*
name|rp
decl_stmt|;
name|Assert
argument_list|(
name|ep
operator|->
name|mode
operator|==
name|SUBSET
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
name|rp
operator|=
name|noderepr
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|nch
operator|=
name|nchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|Left
condition|)
name|ep
operator|->
name|s2
operator|=
operator|--
name|ep
operator|->
name|s1
expr_stmt|;
else|else
name|ep
operator|->
name|s1
operator|=
operator|++
name|ep
operator|->
name|s2
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|Left
condition|?
name|ep
operator|->
name|s1
operator|<
literal|1
else|:
name|ep
operator|->
name|s2
operator|>
literal|2
operator|*
name|nch
operator|+
literal|1
condition|)
block|{
name|ich
operator|=
name|ichild
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|up
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
return|return
name|No
return|;
comment|/* *ep is garbage now! */
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|s1
operator|=
name|ep
operator|->
name|s2
operator|=
literal|2
operator|*
name|ich
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ep
operator|->
name|s1
operator|&
literal|1
condition|)
block|{
name|len
operator|=
name|Fwidth
argument_list|(
name|rp
index|[
name|ep
operator|->
name|s1
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|SUBRANGE
expr_stmt|;
name|ep
operator|->
name|s2
operator|=
name|ep
operator|->
name|s3
operator|=
name|direction
operator|==
name|Left
condition|?
name|len
operator|-
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|Yes
return|;
block|}
continue|continue;
block|}
name|n1
operator|=
name|child
argument_list|(
name|n
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|width
argument_list|(
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|downi
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|,
name|ep
operator|->
name|s1
operator|/
literal|2
argument_list|)
condition|)
return|return
name|No
return|;
comment|/* Sorry... */
name|n
operator|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|value
operator|)
name|n
operator|)
operator|->
name|type
operator|==
name|Tex
condition|)
block|{
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|->
name|mode
operator|=
name|SUBRANGE
expr_stmt|;
name|ep
operator|->
name|s2
operator|=
name|ep
operator|->
name|s3
operator|=
name|direction
operator|==
name|Left
condition|?
name|len
operator|-
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|direction
operator|==
name|Left
condition|)
block|{
name|nch
operator|=
name|nchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ep
operator|->
name|s1
operator|=
name|ep
operator|->
name|s2
operator|=
literal|2
operator|*
operator|(
name|nch
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
name|ep
operator|->
name|s1
operator|=
name|ep
operator|->
name|s2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Not reached */
block|}
end_function

begin_comment
comment|/*  * Up and down arrows.  */
end_comment

begin_function
name|Hidden
name|bool
name|updownarrow
parameter_list|(
name|ep
parameter_list|,
name|yincr
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
name|int
name|yincr
decl_stmt|;
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
while|while
condition|(
name|narrow
argument_list|(
name|ep
argument_list|)
condition|)
empty_stmt|;
name|y
operator|=
name|lineno
argument_list|(
name|ep
argument_list|)
operator|+
name|yincr
expr_stmt|;
name|x
operator|=
name|colno
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotoyx
argument_list|(
name|ep
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
condition|)
return|return
name|No
return|;
name|gotofix
argument_list|(
name|ep
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|narrow
argument_list|(
name|ep
argument_list|)
condition|)
empty_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|uparrow
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
return|return
name|updownarrow
argument_list|(
name|ep
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|downarrow
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
return|return
name|updownarrow
argument_list|(
name|ep
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|upline
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|y
decl_stmt|;
name|y
operator|=
name|lineno
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<=
literal|0
condition|)
return|return
name|No
return|;
if|if
condition|(
operator|!
name|gotoyx
argument_list|(
name|ep
argument_list|,
name|y
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|No
return|;
name|oneline
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|downline
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|w
decl_stmt|;
if|if
condition|(
operator|!
name|parent
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
operator|&&
name|ep
operator|->
name|mode
operator|==
name|ATEND
condition|)
return|return
name|No
return|;
comment|/* Superfluous? */
name|w
operator|=
operator|-
name|focwidth
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
name|w
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|gotoyx
argument_list|(
name|ep
argument_list|,
name|lineno
argument_list|(
name|ep
argument_list|)
operator|+
name|w
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|No
return|;
name|oneline
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * ACCEPT command  * move to next Hole hole or to end of suggestion or to end of line.  */
end_comment

begin_function
name|Visible
name|bool
name|accept
parameter_list|(
name|ep
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|string
name|repr
decl_stmt|;
name|shrink
argument_list|(
name|ep
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|mode
condition|)
block|{
case|case
name|ATBEGIN
case|:
case|case
name|ATEND
case|:
case|case
name|FHOLE
case|:
case|case
name|VHOLE
case|:
name|ritevhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbol
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
operator|==
name|Hole
condition|)
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|mode
condition|)
block|{
case|case
name|ATBEGIN
case|:
case|case
name|SUBLIST
case|:
case|case
name|WHOLE
case|:
name|i
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ATEND
case|:
name|i
operator|=
literal|2
operator|*
name|nchildren
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|SUBRANGE
case|:
case|case
name|VHOLE
case|:
case|case
name|FHOLE
case|:
name|i
operator|=
name|ep
operator|->
name|s1
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|s2
operator|>
literal|0
operator|&&
name|i
operator|>
literal|2
operator|*
name|nchildren
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
comment|/* Kludge so after E?LSE: the focus moves to ELSE: ? */
break|break;
case|case
name|SUBSET
case|:
name|i
operator|=
name|ep
operator|->
name|s1
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|Abort
argument_list|()
expr_stmt|;
block|}
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|/
literal|2
operator|==
name|nchildren
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
condition|)
block|{
name|repr
operator|=
name|noderepr
argument_list|(
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
argument_list|)
index|[
name|i
operator|/
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|Fw_positive
argument_list|(
name|repr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|tabstop
argument_list|(
name|ep
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
return|return
name|Yes
return|;
name|i
operator|=
literal|2
operator|*
name|ichild
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|up
argument_list|(
operator|&
name|ep
operator|->
name|focus
argument_list|)
condition|)
break|break;
name|higher
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|mode
operator|=
name|ATEND
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*  * Find suitable tab stops for accept.  */
end_comment

begin_function
name|Hidden
name|bool
name|tabstop
parameter_list|(
name|ep
parameter_list|,
name|i
parameter_list|)
name|environ
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|node
name|n
init|=
name|tree
argument_list|(
name|ep
operator|->
name|focus
argument_list|)
decl_stmt|;
name|int
name|nch
decl_stmt|;
name|string
name|repr
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|n
argument_list|)
operator|==
name|Tex
condition|)
return|return
name|No
return|;
name|nch
operator|=
name|nchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|/
literal|2
operator|>
name|nch
condition|)
return|return
name|No
return|;
if|if
condition|(
name|symbol
argument_list|(
name|n
argument_list|)
operator|==
name|Hole
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|WHOLE
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|i
operator|<
literal|2
condition|)
block|{
name|i
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|width
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|repr
operator|=
name|noderepr
argument_list|(
name|n
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|Fw_negative
argument_list|(
name|repr
argument_list|)
condition|)
block|{
name|ep
operator|->
name|mode
operator|=
name|ATBEGIN
expr_stmt|;
name|leftvhole
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|/=
literal|2
init|;
name|i
operator|<=
name|nch
condition|;
operator|++
name|i
control|)
block|{
name|s_downi
argument_list|(
name|ep
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabstop
argument_list|(
name|ep
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|Yes
return|;
name|s_up
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
return|return
name|No
return|;
block|}
end_function

end_unit

