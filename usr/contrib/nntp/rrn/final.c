begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: final.c,v 4.3 85/05/01 11:38:08 lwall Exp $  *  * $Log:	final.c,v $  * Revision 4.3  85/05/01  11:38:08  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"last.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_function
name|void
name|final_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGTSTP
name|sigset
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_catcher
argument_list|)
expr_stmt|;
comment|/* job control signals */
name|sigset
argument_list|(
name|SIGCONT
argument_list|,
name|cont_catcher
argument_list|)
expr_stmt|;
comment|/* job control signals */
endif|#
directive|endif
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|int_catcher
argument_list|)
expr_stmt|;
comment|/* always catch interrupts */
name|sigset
argument_list|(
name|SIGHUP
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
comment|/* and hangups */
ifndef|#
directive|ifndef
name|lint
name|sigignore
argument_list|(
name|SIGEMT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
name|sigset
argument_list|(
name|SIGILL
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGTRAP
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGFPE
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGBUS
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGSEGV
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGSYS
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGTERM
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGXCPU
name|sigset
argument_list|(
name|SIGXCPU
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|sigset
argument_list|(
name|SIGXFSZ
argument_list|,
name|sig_catcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
comment|/* very much void */
name|finalize
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|bizarre
condition|)
name|resetty
argument_list|()
expr_stmt|;
name|UNLINK
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER
name|UNLINK
argument_list|(
name|active_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|chdir
argument_list|(
literal|"/usr/tmp"
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* come here on interrupt */
end_comment

begin_function
name|int
name|int_catcher
parameter_list|()
block|{
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|int_catcher
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"int_catcher\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|waiting
condition|)
block|{
if|if
condition|(
name|int_count
condition|)
block|{
comment|/* was there already an interrupt? */
name|write
argument_list|(
literal|2
argument_list|,
literal|"\nBye-bye.\n"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* emulate the other signals */
block|}
name|int_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* come here on signal other than interrupt, stop, or cont */
end_comment

begin_function
name|int
name|sig_catcher
parameter_list|(
name|signo
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
specifier|static
name|char
modifier|*
name|signame
index|[]
init|=
block|{
literal|""
block|,
literal|"HUP"
block|,
literal|"INT"
block|,
literal|"QUIT"
block|,
literal|"ILL"
block|,
literal|"TRAP"
block|,
literal|"IOT"
block|,
literal|"EMT"
block|,
literal|"FPE"
block|,
literal|"KILL"
block|,
literal|"BUS"
block|,
literal|"SEGV"
block|,
literal|"SYS"
block|,
literal|"PIPE"
block|,
literal|"ALRM"
block|,
literal|"TERM"
block|,
literal|"???"
ifdef|#
directive|ifdef
name|SIGTSTP
block|,
literal|"STOP"
block|,
literal|"TSTP"
block|,
literal|"CONT"
block|,
literal|"CHLD"
block|,
literal|"TTIN"
block|,
literal|"TTOU"
block|,
literal|"TINT"
block|,
literal|"XCPU"
block|,
literal|"XFSZ"
ifdef|#
directive|ifdef
name|SIGPROF
block|,
literal|"VTALARM"
block|,
literal|"PROF"
endif|#
directive|endif
endif|#
directive|endif
block|}
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTTOU
ifndef|#
directive|ifndef
name|lint
name|sigignore
argument_list|(
name|SIGTTOU
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"\nSIG%s--.newsrc not restored in debug\n"
argument_list|,
name|signame
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|panic
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|panic
operator|=
name|TRUE
expr_stmt|;
comment|/* disable terminal I/O */
if|if
condition|(
name|doing_ng
condition|)
block|{
comment|/* need we reconstitute rc line? */
name|yankback
argument_list|()
expr_stmt|;
name|restore_ng
argument_list|()
expr_stmt|;
comment|/* then do so (hope this works) */
block|}
name|doing_ng
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rc_changed
condition|)
comment|/* need we write .newsrc out? */
name|write_rc
argument_list|()
expr_stmt|;
comment|/* then do so */
name|rc_changed
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|signo
operator|!=
name|SIGHUP
condition|)
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nCaught %s%s--.newsrc restored\n"
argument_list|,
name|signo
condition|?
literal|"a SIG"
else|:
literal|"an internal error"
argument_list|,
name|signame
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nSignal %d--bye bye\n"
argument_list|,
name|signo
argument_list|)
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGBUS
case|:
case|case
name|SIGILL
case|:
case|case
name|SIGSEGV
case|:
name|finalize
argument_list|(
operator|-
name|signo
argument_list|)
expr_stmt|;
block|}
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* and blow up */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_comment
comment|/* come here on stop signal */
end_comment

begin_function
name|int
name|stop_catcher
parameter_list|()
block|{
if|if
condition|(
operator|!
name|waiting
condition|)
block|{
name|checkpoint_rc
argument_list|()
expr_stmt|;
comment|/* good chance of crash while stopped */
name|resetty
argument_list|()
expr_stmt|;
comment|/* this is the point of all this */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"stop_catcher\n"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigset
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* enable stop */
ifdef|#
directive|ifdef
name|BSD42
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|SIGTSTP
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* and do the stop */
block|}
name|sigset
argument_list|(
name|SIGTSTP
argument_list|,
name|stop_catcher
argument_list|)
expr_stmt|;
comment|/* unenable the stop */
block|}
end_function

begin_comment
comment|/* come here on cont signal */
end_comment

begin_function
name|int
name|cont_catcher
parameter_list|()
block|{
name|sigset
argument_list|(
name|SIGCONT
argument_list|,
name|cont_catcher
argument_list|)
expr_stmt|;
name|savetty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAILCALL
name|;
name|mailcount
operator|=
literal|0
expr_stmt|;
comment|/* force recheck */
endif|#
directive|endif
if|if
condition|(
operator|!
name|panic
condition|)
block|{
if|if
condition|(
operator|!
name|waiting
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"cont_catcher\n"
argument_list|,
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|noecho
argument_list|()
expr_stmt|;
comment|/* set no echo */
name|crmode
argument_list|()
expr_stmt|;
comment|/* set cbreak mode */
name|forceme
argument_list|(
literal|"\f"
argument_list|)
expr_stmt|;
comment|/* cause a refresh */
comment|/* (defined only if TIOCSTI defined) */
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

