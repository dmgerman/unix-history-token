begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: intrp.c,v 4.3.1.5 85/05/23 17:21:24 lwall Exp $  *  * $Log:	intrp.c,v $  * Revision 4.3.1.5  85/05/23  17:21:24  lwall  * Now allows 'r' and 'f' on null articles.  *   * Revision 4.3.1.4  85/05/21  13:35:21  lwall  * Sped up "rn -c" by not doing unnecessary initialization.  *   * Revision 4.3.1.3  85/05/17  10:37:11  lwall  * Fixed& substitution to capitalize last name too.  *   * Revision 4.3.1.2  85/05/15  14:39:45  lwall  * Spelled gecos right.  *   * Revision 4.3.1.1  85/05/10  11:33:51  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:40:54  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"rn.h"
end_include

begin_include
include|#
directive|include
file|"artsrch.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"respond.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_decl_stmt
name|char
name|orgname
index|[]
init|=
name|ORGNAME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of this site */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GETHOSTNAME
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|SITENAME
end_undef

begin_define
define|#
directive|define
name|SITENAME
value|hostname
end_define

begin_else
else|#
directive|else
else|!GETHOSTNAME
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|DOUNAME
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_decl_stmt
name|struct
name|utsname
name|uts
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|SITENAME
end_undef

begin_define
define|#
directive|define
name|SITENAME
value|uts.nodename
end_define

begin_else
else|#
directive|else
else|!DOUNAME
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|PHOSTNAME
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|SITENAME
end_undef

begin_define
define|#
directive|define
name|SITENAME
value|hostname
end_define

begin_else
else|#
directive|else
else|!PHOSTNAME
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|WHOAMI
end_ifdef

begin_undef
undef|#
directive|undef
name|SITENAME
end_undef

begin_define
define|#
directive|define
name|SITENAME
value|sysname
end_define

begin_endif
endif|#
directive|endif
endif|WHOAMI
end_endif

begin_endif
endif|#
directive|endif
endif|PHOSTNAME
end_endif

begin_endif
endif|#
directive|endif
endif|DOUNAME
end_endif

begin_endif
endif|#
directive|endif
endif|GETHOSTNAME
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TILDENAME
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tildename
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tildedir
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|realname
name|INIT
parameter_list|(
name|Nullch
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* real name of sender from /etc/passwd */
end_comment

begin_function_decl
name|char
modifier|*
name|dointerp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getrealname
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CONDSUB
end_ifdef

begin_function_decl
name|char
modifier|*
name|skipinterp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|abort_interp
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|intrp_init
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
block|{
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
name|spool
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
name|SPOOL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* usually /usr/spool/news */
comment|/* get environmental stuff */
comment|/* get home directory */
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
operator|==
name|Nullch
condition|)
name|homedir
operator|=
name|getenv
argument_list|(
literal|"LOGDIR"
argument_list|)
expr_stmt|;
name|dotdir
operator|=
name|getval
argument_list|(
literal|"DOTDIR"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
comment|/* get login name */
name|logname
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logname
operator|==
name|Nullch
condition|)
name|logname
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GETLOGIN
if|if
condition|(
name|logname
operator|==
name|Nullch
condition|)
name|logname
operator|=
name|savestr
argument_list|(
name|getlogin
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|checkflag
condition|)
comment|/* that getwd below takes ~1/3 sec. */
return|return;
comment|/* and we do not need it for -c */
name|getwd
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* find working directory name */
name|origdir
operator|=
name|savestr
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* and remember it */
comment|/* get the real name of the person (%N) */
comment|/* Must be done after logname is read in because BERKNAMES uses that */
name|strcpy
argument_list|(
name|tcbuf
argument_list|,
name|getrealname
argument_list|(
name|getuid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|realname
operator|=
name|savestr
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* name of header file (%h) */
name|headname
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
name|HEADNAME
argument_list|)
argument_list|)
expr_stmt|;
comment|/* name of this site (%H) */
ifdef|#
directive|ifdef
name|GETHOSTNAME
name|gethostname
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|DOUNAME
comment|/* get sysname */
name|uname
argument_list|(
operator|&
name|uts
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PHOSTNAME
block|{
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|pipefp
init|=
name|popen
argument_list|(
name|PHOSTNAME
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pipefp
operator|==
name|Nullfp
condition|)
block|{
name|printf
argument_list|(
literal|"Can't find hostname\n"
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe out newline */
name|hostname
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|sitename
operator|=
name|savestr
argument_list|(
name|SITENAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* expand filename via %, ~, and $ interpretation */
end_comment

begin_comment
comment|/* returns pointer to static area */
end_comment

begin_comment
comment|/* Note that there is a 1-deep cache of ~name interpretation */
end_comment

begin_function
name|char
modifier|*
name|filexp
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|char
name|filename
index|[
name|CBUFLEN
index|]
decl_stmt|;
name|char
name|scrbuf
index|[
name|CBUFLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"< %s\n"
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|interp
argument_list|(
name|filename
argument_list|,
operator|(
sizeof|sizeof
name|filename
operator|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* interpret any % escapes */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"%% %s\n"
argument_list|,
argument|filename
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|filename
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
condition|)
block|{
comment|/* does destination start with ~? */
if|if
condition|(
operator|!
operator|*
operator|(
operator|++
name|s
operator|)
operator|||
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%s%s"
argument_list|,
name|homedir
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* swap $HOME for it */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"~ %s\n"
argument_list|,
argument|scrbuf
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|filename
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TILDENAME
for|for
control|(
name|d
operator|=
name|scrbuf
init|;
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
operator|,
name|d
operator|++
control|)
operator|*
name|d
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tildedir
operator|&&
name|strEQ
argument_list|(
name|tildename
argument_list|,
name|scrbuf
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|scrbuf
argument_list|,
name|tildedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"r %s %s\n"
argument_list|,
argument|tildename
argument_list|,
argument|tildedir
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|tildename
condition|)
block|{
name|free
argument_list|(
name|tildename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tildedir
argument_list|)
expr_stmt|;
block|}
name|tildedir
operator|=
name|Nullch
expr_stmt|;
name|tildename
operator|=
name|savestr
argument_list|(
name|scrbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GETPWENT
comment|/* getpwnam() is not the paragon of efficiency */
block|{
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|getpwnam
argument_list|(
name|tildename
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%s%s"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tildedir
operator|=
name|savestr
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEWSADMIN
if|if
condition|(
name|strEQ
argument_list|(
name|newsadmin
argument_list|,
name|tildename
argument_list|)
condition|)
name|newsuid
operator|=
name|atoi
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|filename
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GETPWENT
name|endpwent
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* this will run faster, and is less D space */
block|{
comment|/* just be sure LOGDIRFIELD is correct */
name|FILE
modifier|*
name|pfp
init|=
name|fopen
argument_list|(
literal|"/etc/passwd"
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pfp
operator|==
name|Nullfp
condition|)
block|{
name|printf
argument_list|(
argument|cantopen
argument_list|,
literal|"passwd"
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|tmpbuf
argument_list|,
literal|512
argument_list|,
name|pfp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|d
operator|=
name|cpytill
argument_list|(
name|scrbuf
argument_list|,
name|tmpbuf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"p %s\n"
argument_list|,
argument|tmpbuf
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strEQ
argument_list|(
name|scrbuf
argument_list|,
name|tildename
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|NEWSADMIN
if|if
condition|(
name|strEQ
argument_list|(
name|newsadmin
argument_list|,
name|tildename
argument_list|)
condition|)
name|newsuid
operator|=
name|atoi
argument_list|(
name|index
argument_list|(
name|d
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|LOGDIRFIELD
operator|-
literal|2
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|=
name|index
argument_list|(
name|d
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
condition|)
block|{
name|cpytill
argument_list|(
name|scrbuf
argument_list|,
name|d
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|tildedir
operator|=
name|savestr
argument_list|(
name|scrbuf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|#
directive|else
else|!TILDENAME
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"~loginname not implemented.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"~login not impl.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
comment|/* starts with some env variable? */
name|d
operator|=
name|scrbuf
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
name|strcpy
argument_list|(
name|d
argument_list|,
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|d
operator|++
operator|=
literal|'{'
expr_stmt|;
for|for
control|(
name|s
operator|++
init|;
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
comment|/* skip over token */
operator|*
name|d
operator|++
operator|=
literal|'}'
expr_stmt|;
name|strcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"$ %s\n"
argument_list|,
argument|scrbuf
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|interp
argument_list|(
name|filename
argument_list|,
operator|(
sizeof|sizeof
name|filename
operator|)
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
comment|/* this might do some extra '%'s but */
comment|/* that is how the Mercedes Benz */
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"> %s\n"
argument_list|,
argument|filename
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
return|return
name|filename
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONDSUB
end_ifdef

begin_comment
comment|/* skip interpolations */
end_comment

begin_function
name|char
modifier|*
name|skipinterp
parameter_list|(
name|pattern
parameter_list|,
name|stoppers
parameter_list|)
specifier|register
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|stoppers
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|pattern
operator|&&
operator|(
operator|!
name|stoppers
operator|||
operator|!
name|index
argument_list|(
name|stoppers
argument_list|,
operator|*
name|pattern
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|printf
argument_list|(
literal|"skipinterp till %s at %s\n"
argument_list|,
name|stoppers
condition|?
name|stoppers
else|:
literal|""
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'%'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|pattern
condition|)
block|{
case|case
literal|'{'
case|:
for|for
control|(
name|pattern
operator|++
init|;
operator|*
name|pattern
operator|&&
operator|*
name|pattern
operator|!=
literal|'}'
condition|;
name|pattern
operator|++
control|)
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
name|pattern
operator|++
expr_stmt|;
break|break;
case|case
literal|'['
case|:
for|for
control|(
name|pattern
operator|++
init|;
operator|*
name|pattern
operator|&&
operator|*
name|pattern
operator|!=
literal|']'
condition|;
name|pattern
operator|++
control|)
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
name|pattern
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CONDSUB
case|case
literal|'('
case|:
block|{
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
goto|goto
name|getout
goto|;
for|for
control|(
name|pattern
operator|++
init|;
operator|*
name|pattern
operator|&&
operator|*
name|pattern
operator|!=
literal|'?'
condition|;
name|pattern
operator|++
control|)
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
goto|goto
name|getout
goto|;
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|":)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|':'
condition|)
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BACKTICK
case|case
literal|'`'
case|:
block|{
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROMPTTTY
case|case
literal|'"'
case|:
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|pattern
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'^'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
name|pattern
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
name|pattern
operator|+=
literal|2
expr_stmt|;
else|else
name|pattern
operator|++
expr_stmt|;
block|}
block|}
name|getout
label|:
return|return
name|pattern
return|;
comment|/* where we left off */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* interpret interpolations */
end_comment

begin_function
name|char
modifier|*
name|dointerp
parameter_list|(
name|dest
parameter_list|,
name|destsize
parameter_list|,
name|pattern
parameter_list|,
name|stoppers
parameter_list|)
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
specifier|register
name|int
name|destsize
decl_stmt|;
specifier|register
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|stoppers
decl_stmt|;
block|{
name|char
modifier|*
name|subj_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|ngs_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|refs_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|artid_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|reply_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|from_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|path_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|follow_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|dist_buf
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|line_buf
init|=
name|Nullch
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|h
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|scrbuf
index|[
literal|512
index|]
decl_stmt|;
name|bool
name|upper
init|=
name|FALSE
decl_stmt|;
name|bool
name|lastcomp
init|=
name|FALSE
decl_stmt|;
name|int
name|metabit
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|pattern
operator|&&
operator|(
operator|!
name|stoppers
operator|||
operator|!
name|index
argument_list|(
name|stoppers
argument_list|,
operator|*
name|pattern
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|printf
argument_list|(
literal|"dointerp till %s at %s\n"
argument_list|,
name|stoppers
condition|?
name|stoppers
else|:
literal|""
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'%'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
name|upper
operator|=
name|FALSE
expr_stmt|;
name|lastcomp
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|Nullch
init|;
operator|!
name|s
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|pattern
condition|)
block|{
case|case
literal|'^'
case|:
name|upper
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
name|lastcomp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
ifdef|#
directive|ifdef
name|ARTSRCH
name|s
operator|=
name|scrbuf
expr_stmt|;
if|if
condition|(
operator|!
name|index
argument_list|(
literal|"/?g"
argument_list|,
name|pattern
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
operator|*
name|s
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|lastpat
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern
index|[
operator|-
literal|2
index|]
operator|!=
literal|'g'
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"/?"
argument_list|,
name|pattern
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
operator|*
name|s
operator|++
operator|=
name|pattern
index|[
operator|-
literal|2
index|]
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|art_howmuch
operator|==
literal|1
condition|)
operator|*
name|s
operator|++
operator|=
literal|'h'
expr_stmt|;
elseif|else
if|if
condition|(
name|art_howmuch
operator|==
literal|2
condition|)
operator|*
name|s
operator|++
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|art_doread
condition|)
operator|*
name|s
operator|++
operator|=
literal|'r'
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|nullstr
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'{'
case|:
name|pattern
operator|=
name|cpytill
argument_list|(
name|scrbuf
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|index
argument_list|(
name|scrbuf
argument_list|,
literal|'-'
argument_list|)
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|else
name|s
operator|=
name|nullstr
expr_stmt|;
name|s
operator|=
name|getval
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|pattern
operator|=
name|cpytill
argument_list|(
name|scrbuf
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
name|i
operator|=
name|set_line_type
argument_list|(
name|scrbuf
argument_list|,
name|scrbuf
operator|+
name|strlen
argument_list|(
name|scrbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_buf
condition|)
name|free
argument_list|(
name|line_buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|line_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CONDSUB
case|case
literal|'('
case|:
block|{
name|COMPEX
modifier|*
name|oldbra_compex
init|=
name|bra_compex
decl_stmt|;
name|COMPEX
name|cond_compex
decl_stmt|;
name|char
name|rch
decl_stmt|;
name|bool
name|matched
decl_stmt|;
name|init_compex
argument_list|(
operator|&
name|cond_compex
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
name|rch
operator|=
operator|*
name|pattern
expr_stmt|;
if|if
condition|(
name|rch
operator|==
literal|'!'
condition|)
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|!=
literal|'='
condition|)
goto|goto
name|getout
goto|;
name|pattern
operator|=
name|cpytill
argument_list|(
name|scrbuf
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
goto|goto
name|getout
goto|;
if|if
condition|(
name|s
operator|=
name|compile
argument_list|(
operator|&
name|cond_compex
argument_list|,
name|scrbuf
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
argument|scrbuf
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
name|pattern
operator|+=
name|strlen
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
goto|goto
name|getout
goto|;
block|}
name|matched
operator|=
operator|(
name|execute
argument_list|(
operator|&
name|cond_compex
argument_list|,
name|dest
argument_list|)
operator|!=
name|Nullch
operator|)
expr_stmt|;
if|if
condition|(
name|cond_compex
operator|.
name|nbra
condition|)
comment|/* were there brackets? */
name|bra_compex
operator|=
operator|&
name|cond_compex
expr_stmt|;
if|if
condition|(
name|matched
operator|==
operator|(
name|rch
operator|==
literal|'='
operator|)
condition|)
block|{
name|pattern
operator|=
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|":)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|':'
condition|)
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|":)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|':'
condition|)
name|pattern
operator|++
expr_stmt|;
name|pattern
operator|=
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|dest
expr_stmt|;
name|bra_compex
operator|=
name|oldbra_compex
expr_stmt|;
name|free_compex
argument_list|(
operator|&
name|cond_compex
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BACKTICK
case|case
literal|'`'
case|:
block|{
name|FILE
modifier|*
name|pipefp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|pattern
operator|=
name|dointerp
argument_list|(
name|scrbuf
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
name|pipefp
operator|=
name|popen
argument_list|(
name|scrbuf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipefp
operator|!=
name|Nullfp
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|fread
argument_list|(
name|scrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
operator|-
literal|1
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
name|scrbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pclose
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nCan't run %s\n"
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
operator|*
name|scrbuf
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|scrbuf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
else|else
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROMPTTTY
case|case
literal|'"'
case|:
name|pattern
operator|=
name|dointerp
argument_list|(
name|scrbuf
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
argument|scrbuf
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
name|gets
argument_list|(
name|scrbuf
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'~'
case|:
name|s
operator|=
name|homedir
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|s
operator|=
name|dotdir
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|s
operator|=
name|scrbuf
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
ifdef|#
directive|ifdef
name|CONDSUB
name|s
operator|=
name|getbracket
argument_list|(
name|bra_compex
argument_list|,
operator|*
name|pattern
operator|-
literal|'0'
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|nullstr
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'a'
case|:
name|s
operator|=
name|scrbuf
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
ifdef|#
directive|ifdef
name|LINKART
name|s
operator|=
name|linkartname
expr_stmt|;
comment|/* so Eunice people get right file */
else|#
directive|else
name|s
operator|=
name|scrbuf
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s/%s/%ld"
argument_list|,
name|spool
argument_list|,
name|ngdir
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'b'
case|:
name|s
operator|=
name|savedest
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|s
operator|=
name|scrbuf
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|savefrom
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|s
operator|=
name|ngdir
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|s
operator|=
name|ngname
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|s
operator|=
name|scrbuf
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s/%s"
argument_list|,
name|spool
argument_list|,
name|ngdir
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|s
operator|=
name|dist_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|DIST_LINE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* from line */
ifdef|#
directive|ifdef
name|ASYNC_PARSE
name|parse_maybe
argument_list|(
name|art
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|REPLY_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
block|{
comment|/* was there a reply line? */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|reply_buf
operator|)
condition|)
name|s
operator|=
name|reply_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|REPLY_LINE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|from_buf
operator|)
condition|)
name|s
operator|=
name|from_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|FROM_LINE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
ifdef|#
directive|ifdef
name|ASYNC_PARSE
name|parse_maybe
argument_list|(
name|art
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|FOLLOW_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
comment|/* is there a Followup-To line? */
name|s
operator|=
name|follow_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|FOLLOW_LINE
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|off
decl_stmt|;
name|s
operator|=
name|ngs_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|NGS_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|=
name|instr
argument_list|(
name|s
argument_list|,
literal|"net.general"
argument_list|)
condition|)
block|{
name|off
operator|=
name|h
operator|-
name|s
expr_stmt|;
name|strncpy
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|,
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scrbuf
operator|+
name|off
operator|+
literal|4
argument_list|,
literal|"followup"
argument_list|)
expr_stmt|;
name|safecpy
argument_list|(
name|scrbuf
operator|+
name|off
operator|+
literal|12
argument_list|,
name|h
operator|+
literal|11
argument_list|,
sizeof|sizeof
argument_list|(
name|scrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
comment|/* header file name */
name|s
operator|=
name|headname
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* host name */
name|s
operator|=
name|sitename
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|artid_buf
operator|)
condition|)
name|s
operator|=
name|artid_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|MESSID_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'<'
condition|)
block|{
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"<%s>"
argument_list|,
name|artid_buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* ref article indicator */
name|s
operator|=
name|scrbuf
expr_stmt|;
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"'%s'"
argument_list|,
name|indstr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* rn library */
ifdef|#
directive|ifdef
name|NEWSADMIN
name|s
operator|=
name|newsadmin
expr_stmt|;
else|#
directive|else
name|s
operator|=
literal|"???"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'L'
case|:
comment|/* login id */
name|s
operator|=
name|logname
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* current mode */
name|s
operator|=
name|scrbuf
expr_stmt|;
operator|*
name|s
operator|=
name|mode
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
ifdef|#
directive|ifdef
name|DELAYMARK
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|dmcount
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|nullstr
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'n'
case|:
comment|/* newsgroups */
name|s
operator|=
name|ngs_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|NGS_LINE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* full name */
name|s
operator|=
name|getval
argument_list|(
literal|"NAME"
argument_list|,
name|realname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* organization */
name|s
operator|=
name|getval
argument_list|(
literal|"ORGANIZATION"
argument_list|,
name|orgname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ORGFILE
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
name|FILE
modifier|*
name|ofp
init|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ofp
condition|)
block|{
name|fgets
argument_list|(
name|scrbuf
argument_list|,
sizeof|sizeof
name|scrbuf
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
literal|'O'
case|:
name|s
operator|=
name|origdir
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|s
operator|=
name|cwd
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|s
operator|=
name|spool
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
ifdef|#
directive|ifdef
name|ASYNC_PARSE
name|parse_maybe
argument_list|(
name|art
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|REFS_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
block|{
name|refs_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|REFS_LINE
argument_list|)
expr_stmt|;
name|refscpy
argument_list|(
name|scrbuf
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|,
name|refs_buf
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|scrbuf
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|rindex
argument_list|(
name|scrbuf
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
ifdef|#
directive|ifdef
name|ASYNC_PARSE
name|parse_maybe
argument_list|(
name|art
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|REFS_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
block|{
name|refs_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|REFS_LINE
argument_list|)
expr_stmt|;
name|refscpy
argument_list|(
name|scrbuf
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|,
name|refs_buf
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|scrbuf
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|artid_buf
condition|)
name|artid_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|MESSID_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|artid_buf
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
name|safecat
argument_list|(
name|scrbuf
argument_list|,
name|artid_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|scrbuf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|artid_buf
index|[
literal|0
index|]
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"<%s>"
argument_list|,
name|artid_buf
argument_list|)
expr_stmt|;
name|safecat
argument_list|(
name|scrbuf
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|scrbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|subj_buf
operator|)
condition|)
name|s
operator|=
name|subj_buf
operator|=
name|fetchsubj
argument_list|(
name|art
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* get subject handy */
while|while
condition|(
operator|(
operator|*
name|s
operator|==
literal|'R'
operator|||
operator|*
name|s
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'E'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'e'
operator|)
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* skip extra Re: */
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|=
name|instr
argument_list|(
name|s
argument_list|,
literal|"- (nf"
argument_list|)
condition|)
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|subj_buf
operator|)
condition|)
name|s
operator|=
name|subj_buf
operator|=
name|fetchsubj
argument_list|(
name|art
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* get subject handy */
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'R'
operator|||
operator|*
name|s
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'E'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'e'
operator|)
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* skip extra Re: */
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
ifdef|#
directive|ifdef
name|ASYNC_PARSE
name|parse_maybe
argument_list|(
name|art
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|REPLY_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
block|{
comment|/* was there a reply line? */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|reply_buf
operator|)
condition|)
name|s
operator|=
name|reply_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|REPLY_LINE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|from_buf
operator|)
condition|)
name|s
operator|=
name|from_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|FROM_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'T'
condition|)
block|{
if|if
condition|(
name|htype
index|[
name|PATH_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
block|{
comment|/* should we substitute path? */
name|s
operator|=
name|path_buf
operator|=
name|fetchlines
argument_list|(
name|art
argument_list|,
name|PATH_LINE
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|sitename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|sitename
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
operator|&&
name|s
index|[
name|i
index|]
operator|==
literal|'!'
condition|)
name|s
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
comment|/* strip garbage from end */
operator|*
operator|(
name|h
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
comment|/* or perhaps from beginning */
name|s
operator|=
name|h
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|toread
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|ART_NUM
operator|)
name|toread
index|[
name|ng
index|]
operator|)
operator|-
literal|1
operator|+
name|was_read
argument_list|(
name|art
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* news library */
name|s
operator|=
name|lib
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* rn library */
name|s
operator|=
name|rnlib
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
ifdef|#
directive|ifdef
name|LINKART
name|s
operator|=
name|linkartname
expr_stmt|;
comment|/* so Eunice people get right file */
else|#
directive|else
name|s
operator|=
name|scrbuf
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|filestat
argument_list|)
operator|<
literal|0
condition|)
name|filestat
operator|.
name|st_size
operator|=
literal|0L
expr_stmt|;
name|sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%5ld"
argument_list|,
operator|(
name|long
operator|)
name|filestat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|pattern
operator||
name|metabit
expr_stmt|;
name|s
operator|=
name|nullstr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|nullstr
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
name|upper
operator|||
name|lastcomp
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|scrbuf
condition|)
block|{
name|safecpy
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
block|}
if|if
condition|(
name|upper
operator|||
operator|!
operator|(
name|t
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|!
name|isalpha
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|*
name|t
operator|=
name|toupper
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|metabit
expr_stmt|;
comment|/* maybe get into register */
if|if
condition|(
name|s
operator|==
name|dest
condition|)
block|{
while|while
condition|(
operator|*
name|dest
condition|)
block|{
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
operator|*
name|dest
operator|++
operator||=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|s
operator|++
operator||
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'^'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
operator|++
name|pattern
expr_stmt|;
comment|/* skip uparrow */
name|i
operator|=
operator|*
name|pattern
expr_stmt|;
comment|/* get char into a register */
if|if
condition|(
name|i
operator|==
literal|'?'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\177'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'('
condition|)
block|{
name|metabit
operator|=
literal|0200
expr_stmt|;
name|destsize
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|')'
condition|)
block|{
name|metabit
operator|=
literal|0
expr_stmt|;
name|destsize
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|dest
operator|++
operator|=
name|i
operator|&
literal|037
operator||
name|metabit
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
operator|++
name|pattern
expr_stmt|;
comment|/* skip backslash */
name|i
operator|=
operator|*
name|pattern
expr_stmt|;
comment|/* get char into a register */
comment|/* this used to be a switch but the if may save space */
if|if
condition|(
name|i
operator|>=
literal|'0'
operator|&&
name|i
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|01000
operator|&&
operator|*
name|pattern
operator|>=
literal|'0'
operator|&&
operator|*
name|pattern
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|<<=
literal|3
expr_stmt|;
name|i
operator|+=
operator|*
name|pattern
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
name|i
operator|&
literal|0377
operator||
name|metabit
expr_stmt|;
operator|--
name|pattern
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|'b'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\b'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'f'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\f'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'n'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\n'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'r'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\r'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'t'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\t'
operator||
name|metabit
expr_stmt|;
else|else
operator|*
name|dest
operator|++
operator|=
name|i
operator||
name|metabit
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|dest
operator|++
operator|=
operator|*
name|pattern
operator|++
operator||
name|metabit
expr_stmt|;
block|}
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
name|getout
label|:
if|if
condition|(
name|subj_buf
operator|!=
name|Nullch
condition|)
comment|/* return any checked out storage */
name|free
argument_list|(
name|subj_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngs_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|ngs_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|refs_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|artid_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|artid_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|reply_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|from_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|path_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|follow_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|follow_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|dist_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|line_buf
argument_list|)
expr_stmt|;
return|return
name|pattern
return|;
comment|/* where we left off */
block|}
end_function

begin_function
name|void
name|interp
parameter_list|(
name|dest
parameter_list|,
name|destsize
parameter_list|,
name|pattern
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|destsize
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|fputs
argument_list|(
name|dest
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* copy a references line, normalizing as we go */
end_comment

begin_function
name|void
name|refscpy
parameter_list|(
name|dest
parameter_list|,
name|destsize
parameter_list|,
name|src
parameter_list|)
specifier|register
name|char
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|destsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|dot
decl_stmt|,
modifier|*
name|at
decl_stmt|,
modifier|*
name|beg
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|64
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|src
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|!=
literal|'<'
condition|)
block|{
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
break|break;
operator|*
name|dest
operator|++
operator|=
literal|'<'
expr_stmt|;
name|at
operator|=
name|dot
operator|=
name|Nullch
expr_stmt|;
name|beg
operator|=
name|src
expr_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
operator|*
name|src
operator|!=
literal|' '
operator|&&
operator|*
name|src
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'.'
condition|)
name|dot
operator|=
name|src
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|src
operator|==
literal|'@'
condition|)
name|at
operator|=
name|src
expr_stmt|;
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
break|break;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|destsize
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|dot
operator|&&
operator|!
name|at
condition|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|dest
operator|=
operator|*
name|dot
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s@%s.UUCP"
argument_list|,
name|dot
argument_list|,
name|beg
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|destsize
operator|>
name|len
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|dest
operator|=
name|dest
operator|+
name|len
expr_stmt|;
name|destsize
operator|-=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
break|break;
operator|*
name|dest
operator|++
operator|=
literal|'>'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|src
operator|&&
operator|--
name|destsize
operator|>
literal|0
operator|&&
operator|(
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'>'
condition|)
empty_stmt|;
if|if
condition|(
name|destsize
operator|<=
literal|0
condition|)
break|break;
block|}
while|while
condition|(
operator|*
name|src
operator|==
literal|' '
operator|||
operator|*
name|src
operator|==
literal|','
condition|)
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|&&
operator|--
name|destsize
operator|>
literal|0
condition|)
operator|*
name|dest
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* get the person's real name from /etc/passwd */
end_comment

begin_comment
comment|/* (string is overwritten, so it must be copied) */
end_comment

begin_function
name|char
modifier|*
name|getrealname
parameter_list|(
name|uid
parameter_list|)
name|int
name|uid
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|PASSNAMES
ifdef|#
directive|ifdef
name|GETPWENT
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
decl_stmt|;
name|s
operator|=
name|pwd
operator|->
name|pw_gecos
expr_stmt|;
else|#
directive|else
name|char
name|tmpbuf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|getpw
argument_list|(
name|uid
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tmpbuf
operator|,
name|i
operator|=
name|GCOSFIELD
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|s
condition|)
name|s
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|nullstr
return|;
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|s
operator|=
name|tmpbuf
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BERKNAMES
ifdef|#
directive|ifdef
name|BERKJUNK
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'&'
condition|)
name|s
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|';'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|cpytill
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'&'
condition|)
block|{
comment|/* whoever thought this one up was */
name|c
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* in the middle of the night */
name|strcat
argument_list|(
name|c
argument_list|,
name|logname
argument_list|)
expr_stmt|;
comment|/* before the morning after */
name|strcat
argument_list|(
name|c
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|c
argument_list|)
condition|)
operator|*
name|c
operator|=
name|toupper
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
comment|/* gack and double gack */
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
name|s
operator|=
name|c
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GETPWENT
name|endpwent
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|buf
return|;
comment|/* return something static */
else|#
directive|else
if|if
condition|(
operator|(
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|FULLNAMEFILE
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|Nullfp
condition|)
block|{
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|tmpfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
literal|"PUT YOUR NAME HERE"
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|abort_interp
parameter_list|()
block|{
name|fputs
argument_list|(
literal|"\n% interp buffer overflow!\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

