begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: sw.c,v 4.3.1.2 85/05/21 13:36:23 lwall Exp $  *  * $Log:	sw.c,v $  * Revision 4.3.1.2  85/05/21  13:36:23  lwall  * Sped up "rn -c" by not doing unnecessary initialization.  *   * Revision 4.3.1.1  85/05/10  11:40:38  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:50:54  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"only.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"sw.h"
end_include

begin_function
name|void
name|sw_init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|tcbufptr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|char
modifier|*
modifier|*
name|tcbufptr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|2
operator|&&
name|strEQ
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-c"
argument_list|)
condition|)
name|checkflag
operator|=
name|TRUE
expr_stmt|;
comment|/* so we can optimize for -c */
name|interp
argument_list|(
operator|*
name|tcbufptr
argument_list|,
literal|1024
argument_list|,
name|GLOBINIT
argument_list|)
expr_stmt|;
name|sw_file
argument_list|(
name|tcbufptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|safecpy
argument_list|(
operator|*
name|tcbufptr
argument_list|,
name|getenv
argument_list|(
literal|"RNINIT"
argument_list|)
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|tcbufptr
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|tcbufptr
operator|==
literal|'/'
condition|)
block|{
name|sw_file
argument_list|(
name|tcbufptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|sw_list
argument_list|(
operator|*
name|tcbufptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|decode_switch
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sw_file
parameter_list|(
name|tcbufptr
parameter_list|,
name|bleat
parameter_list|)
name|char
modifier|*
modifier|*
name|tcbufptr
decl_stmt|;
name|bool
name|bleat
decl_stmt|;
block|{
name|int
name|initfd
init|=
name|open
argument_list|(
operator|*
name|tcbufptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|initfd
operator|>=
literal|0
condition|)
block|{
name|fstat
argument_list|(
name|initfd
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_size
operator|>
literal|1024
condition|)
operator|*
name|tcbufptr
operator|=
name|saferealloc
argument_list|(
operator|*
name|tcbufptr
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|filestat
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_size
condition|)
block|{
name|read
argument_list|(
name|initfd
argument_list|,
operator|*
name|tcbufptr
argument_list|,
operator|(
name|int
operator|)
name|filestat
operator|.
name|st_size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|tcbufptr
operator|)
index|[
name|filestat
operator|.
name|st_size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe out last newline */
name|sw_list
argument_list|(
operator|*
name|tcbufptr
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|*
name|tcbufptr
operator|=
literal|'\0'
expr_stmt|;
name|close
argument_list|(
name|initfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bleat
condition|)
name|printf
argument_list|(
argument|cantopen
argument_list|,
argument|*tcbufptr
argument_list|)
name|FLUSH
expr_stmt|;
operator|*
operator|*
name|tcbufptr
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* decode a list of space separated switches */
end_comment

begin_function
name|void
name|sw_list
parameter_list|(
name|swlist
parameter_list|)
name|char
modifier|*
name|swlist
decl_stmt|;
block|{
name|char
modifier|*
name|tmplist
init|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|strlen
argument_list|(
name|swlist
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|/* semi-automatic string */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
name|inquote
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|tmplist
argument_list|,
name|swlist
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tmplist
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* skip any initial spaces */
while|while
condition|(
operator|*
name|p
condition|)
block|{
comment|/* "String, or nothing" */
if|if
condition|(
operator|!
name|inquote
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* word delimiter? */
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* chop here */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
comment|/* these will be ignored later */
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inquote
operator|==
operator|*
name|p
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* delete trailing quote */
name|inquote
operator|=
literal|0
expr_stmt|;
comment|/* no longer quoting */
block|}
elseif|else
if|if
condition|(
operator|!
name|inquote
operator|&&
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
comment|/* OK, I know when I am not wanted */
name|inquote
operator|=
operator|*
name|p
expr_stmt|;
comment|/* remember single or double */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* delete the quote */
block|}
comment|/* (crude, but effective) */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* quoted something? */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
comment|/* newline? */
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* "I didn't see anything" */
else|else
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* delete the backwhack */
name|p
operator|++
expr_stmt|;
comment|/* leave the whatever alone */
block|}
block|}
else|else
name|p
operator|++
expr_stmt|;
comment|/* normal char, leave it alone */
block|}
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* put an extra null on the end */
if|if
condition|(
name|inquote
condition|)
name|printf
argument_list|(
literal|"Unmatched %c in switch\n"
argument_list|,
argument|inquote
argument_list|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tmplist
init|;
operator|*
name|p
condition|;
comment|/* p += strlen(p)+1 */
control|)
block|{
name|decode_switch
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
comment|/* point at null + 1 */
block|}
name|free
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
comment|/* this oughta be in Ada */
block|}
end_function

begin_comment
comment|/* decode a single switch */
end_comment

begin_function
name|void
name|decode_switch
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
comment|/* ignore leading spaces */
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Switch: %s\n"
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|s
operator|!=
literal|'-'
operator|&&
operator|*
name|s
operator|!=
literal|'+'
condition|)
block|{
comment|/* newsgroup pattern */
name|setngtodo
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* normal switch */
name|bool
name|upordown
init|=
operator|*
name|s
operator|==
literal|'-'
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|char
name|tmpbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMMOD
case|case
literal|'='
case|:
block|{
name|char
modifier|*
name|beg
init|=
name|s
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'-'
operator|&&
operator|*
name|s
operator|!=
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|beg
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|upordown
condition|?
name|strEQ
argument_list|(
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|,
name|tmpbuf
argument_list|)
else|:
name|strNE
argument_list|(
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|,
name|tmpbuf
argument_list|)
condition|)
block|{
name|decode_switch
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BAUDMOD
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|upordown
condition|?
operator|(
name|just_a_sec
operator|*
literal|10
operator|<=
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
else|:
operator|(
name|just_a_sec
operator|*
literal|10
operator|>=
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|decode_switch
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
literal|'/'
case|:
if|if
condition|(
name|checkflag
condition|)
break|break;
ifdef|#
directive|ifdef
name|SETENV
name|setenv
argument_list|(
literal|"SAVEDIR"
argument_list|,
name|upordown
condition|?
literal|"%p/%c"
else|:
literal|"%p"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"SAVENAME"
argument_list|,
name|upordown
condition|?
literal|"%a"
else|:
literal|"%^C"
argument_list|)
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"-/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'c'
case|:
name|checkflag
operator|=
name|upordown
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
name|docheckwhen
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
block|{
if|if
condition|(
name|checkflag
condition|)
break|break;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|cwd
condition|)
block|{
name|chdir
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
block|}
name|cwd
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
case|case
literal|'D'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|upordown
condition|)
name|debug
operator||=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|debug
operator|&=
operator|~
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|upordown
condition|)
name|debug
operator||=
literal|1
expr_stmt|;
else|else
name|debug
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'e'
case|:
name|erase_screen
operator|=
name|upordown
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
ifdef|#
directive|ifdef
name|SETENV
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|index
argument_list|(
name|tmpbuf
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|setenv
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|setenv
argument_list|(
name|tmpbuf
argument_list|,
name|nullstr
argument_list|)
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"-E"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'F'
case|:
name|s
operator|++
expr_stmt|;
name|indstr
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INNERSEARCH
case|case
literal|'g'
case|:
name|gline
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|flag
init|=
operator|(
operator|*
name|s
operator|==
literal|'h'
condition|?
name|HT_HIDE
else|:
name|HT_MAGIC
operator|)
decl_stmt|;
if|if
condition|(
name|checkflag
condition|)
break|break;
name|s
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|*
name|t
operator|=
name|tolower
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HEAD_FIRST
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|len
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
argument_list|,
name|len
argument_list|)
condition|)
if|if
condition|(
name|upordown
condition|)
name|htype
index|[
name|i
index|]
operator|.
name|ht_flags
operator||=
name|flag
expr_stmt|;
else|else
name|htype
index|[
name|i
index|]
operator|.
name|ht_flags
operator|&=
operator|~
name|flag
expr_stmt|;
break|break;
block|}
case|case
literal|'i'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
name|initlines
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|muck_up_clear
operator|=
name|upordown
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
ifdef|#
directive|ifdef
name|CLEAREOL
name|can_home_clear
operator|=
name|upordown
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"-L"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'M'
case|:
name|mbox_always
operator|=
name|upordown
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|upordown
condition|)
name|marking
operator|=
name|NOMARKING
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'u'
condition|)
name|marking
operator|=
name|UNDERLINE
expr_stmt|;
else|else
block|{
name|marking
operator|=
name|STANDOUT
expr_stmt|;
block|}
break|break;
case|case
literal|'N'
case|:
name|norm_always
operator|=
name|upordown
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VERBOSE
case|case
literal|'n'
case|:
name|fputs
argument_list|(
literal|"This isn't readnews.  Don't use -n.\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'r'
case|:
name|findlast
operator|=
name|upordown
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|countdown
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|suppress_cn
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|upordown
condition|)
name|countdown
operator|=
literal|5
expr_stmt|;
name|suppress_cn
operator|=
name|upordown
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
ifdef|#
directive|ifdef
name|ARTSEARCH
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|scanon
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|scanon
operator|=
name|upordown
operator|*
literal|3
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"-S"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'t'
case|:
ifdef|#
directive|ifdef
name|VERBOSE
ifdef|#
directive|ifdef
name|TERSE
name|verbose
operator|=
operator|!
name|upordown
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"+t"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|notincl
argument_list|(
literal|"+t"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'T'
case|:
name|typeahead
operator|=
name|upordown
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
ifdef|#
directive|ifdef
name|VERIFY
name|verify
operator|=
name|upordown
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"-v"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nIgnoring unrecognized switch: -%c\n"
argument_list|,
argument|*s
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nIgnoring -%c\n"
argument_list|,
operator|*
name|s
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* print current switch values */
end_comment

begin_function
name|void
name|pr_switches
parameter_list|()
block|{
specifier|static
name|char
name|mp
index|[
literal|2
index|]
init|=
block|{
literal|'+'
block|,
literal|'-'
block|}
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|fputs
argument_list|(
literal|"\nCurrent switch settings:\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c/ "
argument_list|,
name|mp
index|[
name|strEQ
argument_list|(
name|getval
argument_list|(
literal|"SAVEDIR"
argument_list|,
name|SAVEDIR
argument_list|)
argument_list|,
literal|"%p/%c"
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%cc "
argument_list|,
name|mp
index|[
name|checkflag
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-C%d "
argument_list|,
name|docheckwhen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-d%s "
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"-D%d "
argument_list|,
name|debug
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%ce "
argument_list|,
name|mp
index|[
name|erase_screen
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-F\"%s\" "
argument_list|,
name|indstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INNERSEARCH
name|printf
argument_list|(
literal|"-g%d"
argument_list|,
name|gline
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
block|{
for|for
control|(
name|i
operator|=
name|HEAD_FIRST
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%ch%s%c"
argument_list|,
name|mp
index|[
name|htype
index|[
name|i
index|]
operator|.
name|ht_flags
operator|&
name|HT_HIDE
index|]
argument_list|,
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
argument_list|,
operator|(
operator|!
operator|(
name|i
operator|%
literal|5
operator|)
condition|?
literal|'\n'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"-i%d "
argument_list|,
name|initlines
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%cl "
argument_list|,
name|mp
index|[
name|muck_up_clear
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAREOL
name|printf
argument_list|(
literal|"%cL "
argument_list|,
name|mp
index|[
name|can_home_clear
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CLEAREOL
if|if
condition|(
name|marking
condition|)
name|printf
argument_list|(
literal|"-m%c "
argument_list|,
name|marking
operator|==
name|UNDERLINE
condition|?
literal|'u'
else|:
literal|'s'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"+m "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%cM "
argument_list|,
name|mp
index|[
name|mbox_always
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%cN "
argument_list|,
name|mp
index|[
name|norm_always
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%cr "
argument_list|,
name|mp
index|[
name|findlast
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|countdown
condition|)
name|printf
argument_list|(
literal|"-s%d "
argument_list|,
name|countdown
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%cs "
argument_list|,
name|mp
index|[
name|suppress_cn
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
if|if
condition|(
name|scanon
condition|)
name|printf
argument_list|(
literal|"-S%d "
argument_list|,
name|scanon
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"+S "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"%ct "
argument_list|,
name|mp
index|[
operator|!
name|verbose
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|printf
argument_list|(
literal|"%cT "
argument_list|,
name|mp
index|[
name|typeahead
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printf
argument_list|(
literal|"%cv "
argument_list|,
name|mp
index|[
name|verify
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
ifdef|#
directive|ifdef
name|ONLY
if|if
condition|(
name|maxngtodo
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"Current restriction:"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"Only:"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxngtodo
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ngtodo
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
elseif|else
if|if
condition|(
name|verbose
condition|)
name|fputs
argument_list|(
literal|"No restriction.\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|cwd_check
parameter_list|()
block|{
name|char
name|tmpbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cwd
condition|)
name|cwd
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
literal|"~/News"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|cwd
argument_list|)
condition|)
block|{
name|safecpy
argument_list|(
name|tmpbuf
argument_list|,
name|filexp
argument_list|(
name|cwd
argument_list|)
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|makedir
argument_list|(
name|tmpbuf
argument_list|,
name|MD_DIR
argument_list|)
operator|<
literal|0
operator|||
name|chdir
argument_list|(
name|tmpbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|interp
argument_list|(
name|cmd_buf
argument_list|,
operator|(
sizeof|sizeof
name|cmd_buf
operator|)
argument_list|,
literal|"%~/News"
argument_list|)
expr_stmt|;
if|if
condition|(
name|makedir
argument_list|(
name|cmd_buf
argument_list|,
name|MD_DIR
argument_list|)
operator|<
literal|0
condition|)
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|cmd_buf
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\ Cannot make directory %s--\n\ 	articles will be saved to %s\n\ \n\ "
argument_list|,
argument|cwd
argument_list|,
argument|tmpbuf
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\ Can't make %s--\n\ 	using %s\n\ \n\ "
argument_list|,
name|cwd
argument_list|,
name|tmpbuf
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
name|getwd
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|eaccess
argument_list|(
name|tmpbuf
argument_list|,
literal|2
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\ Current directory %s is not writeable--\n\ 	articles will be saved to home directory\n\n\ "
argument_list|,
argument|tmpbuf
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"%s not writeable--using ~\n\n"
argument_list|,
name|tmpbuf
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
block|}
name|cwd
operator|=
name|savestr
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

