begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* movemail foo bar -- move file foo to file bar,    locking file foo the way /bin/mail respects.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but without any warranty.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the document "GNU Emacs copying permission notice".   An exact copy of the document is supposed to have been given to you along with GNU Emacs so that you can know how you may redistribute it all. It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_define
define|#
directive|define
name|NO_SHORTNAMES
end_define

begin_comment
comment|/* Tell config not to load remap.h */
end_comment

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_comment
comment|/* Cancel substitutions made by config.h for Emacs.  */
end_comment

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|inname
decl_stmt|,
modifier|*
name|outname
decl_stmt|;
name|int
name|indesc
decl_stmt|,
name|outdesc
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
ifndef|#
directive|ifndef
name|MAIL_USE_FLOCK
name|struct
name|stat
name|st
decl_stmt|;
name|long
name|now
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|char
modifier|*
name|lockname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|tempname
index|[
literal|40
index|]
decl_stmt|;
name|int
name|desc
decl_stmt|;
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|fatal
argument_list|(
literal|"two arguments required"
argument_list|)
expr_stmt|;
name|inname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|outname
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|MAIL_USE_FLOCK
comment|/* Use a lock file named /usr/spool/mail/$USER.lock:      If it exists, the mail file is locked.  */
name|lockname
operator|=
name|concat
argument_list|(
name|inname
argument_list|,
literal|".lock"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tempname
argument_list|,
name|inname
argument_list|)
expr_stmt|;
name|p
operator|=
name|tempname
operator|+
name|strlen
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|tempname
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"EXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Create the lock file, but not under the lock file name.  */
comment|/* Give up if cannot do that.  */
name|desc
operator|=
name|open
argument_list|(
name|tempname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|tem
operator|=
name|link
argument_list|(
name|tempname
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|>=
literal|0
condition|)
break|break;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If lock file is a minute old, unlock it.  */
if|if
condition|(
name|stat
argument_list|(
name|lockname
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|now
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_ctime
operator|<
name|now
operator|-
literal|60
condition|)
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
ifdef|#
directive|ifdef
name|MAIL_USE_FLOCK
name|indesc
operator|=
name|open
argument_list|(
name|inname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* if not MAIL_USE_FLOCK */
name|indesc
operator|=
name|open
argument_list|(
name|inname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
if|if
condition|(
name|indesc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|inname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
comment|/* In case movemail is setuid to root, make sure the user can      read the output file.  */
comment|/* This is desirable for all systems      but I don't want to assume all have the umask system call */
name|umask
argument_list|(
name|umask
argument_list|(
literal|0
argument_list|)
operator|&
literal|0333
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
name|outdesc
operator|=
name|open
argument_list|(
name|outname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdesc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|outname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAIL_USE_FLOCK
operator|(
name|void
operator|)
name|flock
argument_list|(
name|indesc
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAIL_USE_FLOCK */
while|while
condition|(
literal|1
condition|)
block|{
name|nread
operator|=
name|read
argument_list|(
name|indesc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
name|write
argument_list|(
name|outdesc
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"error writing to %s"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
sizeof|sizeof
name|buf
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|MAIL_USE_FLOCK
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|indesc
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAIL_USE_FLOCK */
name|close
argument_list|(
name|indesc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|outdesc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAIL_USE_FLOCK
name|unlink
argument_list|(
name|inname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_macro
name|fatal
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"movemail: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pfatal_with_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|" for %s"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

