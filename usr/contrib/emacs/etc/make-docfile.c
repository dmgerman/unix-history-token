begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate doc-string file for GNU Emacs from source files.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but without any warranty.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the document "GNU Emacs copying permission notice".   An exact copy of the document is supposed to have been given to you along with GNU Emacs so that you can know how you may redistribute it all. It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* The arguments given to this program are all the C and Lisp source files  of GNU Emacs.  .elc and .el and .c files are allowed.  A .o file can also be specified; the .c file it was made from is used.  This helps the makefile pass the correct list of files.   The results, printed on standard output, are entries containing  function names and their documentation.  Each entry starts with a ^_ character.  Then comes the function name, terminated with a newline.  Then comes the documentation for that function.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|err_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|err_count
operator|+=
name|scan_file
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* err_count seems to be {mis,un}used */
name|exit
argument_list|(
name|err_count
argument_list|)
expr_stmt|;
comment|/* see below - shane */
block|}
end_function

begin_comment
comment|/* Read file FILENAME and output its doc strings to stdout.  */
end_comment

begin_comment
comment|/* Return 1 if file is not found, 0 if it is found.  */
end_comment

begin_macro
name|scan_file
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".elc"
argument_list|)
condition|)
return|return
name|scan_lisp_file
argument_list|(
name|filename
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".el"
argument_list|)
condition|)
return|return
name|scan_lisp_file
argument_list|(
name|filename
argument_list|)
return|;
else|else
return|return
name|scan_c_file
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Skip a C string from INFILE,  and return the character that follows the closing ".  If printflag is positive, output string contents to stdout.  If it is negative, store contents in buf.  Convert escape sequences \n and \t to newline and tab;  discard \ followed by newline.  */
end_comment

begin_macro
name|read_c_string
argument_list|(
argument|infile
argument_list|,
argument|printflag
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|printflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
name|c
operator|=
literal|'\t'
expr_stmt|;
block|}
if|if
condition|(
name|printflag
operator|>
literal|0
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|printflag
operator|<
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
break|break;
if|if
condition|(
name|printflag
operator|>
literal|0
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|printflag
operator|<
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printflag
operator|<
literal|0
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read through a c file.  If a .o file is named,  the corresponding .c file is read instead.  Looks for DEFUN constructs such as are defined in ../src/lisp.h.  Accepts any word starting DEF... so it finds DEFSIMPLE and DEFPRED.  */
end_comment

begin_macro
name|scan_c_file
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|commas
decl_stmt|;
specifier|register
name|int
name|defunflag
decl_stmt|;
if|if
condition|(
name|filename
index|[
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'o'
condition|)
name|filename
index|[
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'c'
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* No error if non-ex input file */
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'D'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'E'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'F'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|defunflag
operator|=
name|c
operator|==
literal|'U'
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'('
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
continue|continue;
name|c
operator|=
name|read_c_string
argument_list|(
name|infile
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|defunflag
condition|)
name|commas
operator|=
literal|5
expr_stmt|;
else|else
name|commas
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|commas
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|commas
operator|--
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|c
operator|=
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|','
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putchar
argument_list|(
literal|037
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* return 1; /* - This says there was an error to caller - breaks make - shane */
return|return
literal|0
return|;
comment|/* - So I changed it to this instead. */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read a file of Lisp code, compiled or interpreted.  Looks for   (defun NAME ARGS DOCSTRING ...)  or   (autoload 'NAME FILE DOCSTRING ...)  either one starting in column zero.  ARGS or FILE is ignored;  the NAME and DOCSTRING are output.  An entry is output only if DOCSTRING has \ newline just after the opening "  */
end_comment

begin_macro
name|scan_lisp_file
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|commas
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* No error */
block|}
name|c
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'a'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'u'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'t'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'o'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'l'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'o'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'a'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'d'
condition|)
continue|continue;
while|while
condition|(
name|c
operator|!=
literal|'\''
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'e'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'f'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'u'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'n'
condition|)
continue|continue;
comment|/* Recognize anything that starts with "defun" */
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Store name of function being defined. */
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Skip the arguments: either "nil" or a list in parens */
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|c
operator|!=
literal|'('
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|')'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* Skip whitespace */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* " followed by \ and newline means a doc string we should gobble */
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
continue|continue;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
name|putchar
argument_list|(
literal|037
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|read_c_string
argument_list|(
name|infile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* return 1; /* - This says there was an error to caller - breaks make - shane */
return|return
literal|0
return|;
comment|/* - So I changed it to this instead. */
block|}
end_block

end_unit

