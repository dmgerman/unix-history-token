begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Random utility Lisp functions.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* Define two macros KERNEL_FILE (file to find kernel symtab in)    and LDAV_SYMBOL (symbol name to look for), based on system type.    Also define NLIST_STRUCT if the type `nlist' is a structure we    can get from nlist.h; otherwise must use a.out.h and initialize    with strcpy.  Note that config.h may define NLIST_STRUCT    for more modrern USG systems.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_define
define|#
directive|define
name|LDAV_SYMBOL
value|"_avenrun"
end_define

begin_define
define|#
directive|define
name|KERNEL_FILE
value|"/hp-ux"
end_define

begin_define
define|#
directive|define
name|NLIST_STRUCT
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HPUX */
end_comment

begin_define
define|#
directive|define
name|LDAV_SYMBOL
value|"avenrun"
end_define

begin_define
define|#
directive|define
name|KERNEL_FILE
value|"/unix"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HPUX */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_define
define|#
directive|define
name|LDAV_SYMBOL
value|"_avenrun"
end_define

begin_define
define|#
directive|define
name|NLIST_STRUCT
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL_FILE
end_ifndef

begin_define
define|#
directive|define
name|KERNEL_FILE
value|"/vmunix"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no KERNEL_FILE yet */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOAD_AVE_TYPE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|eunice
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NLIST_STRUCT
end_ifndef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NLIST_STRUCT */
end_comment

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NLIST_STRUCT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not eunice */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOAD_AVE_TYPE */
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qstring_lessp
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"identity"
argument_list|,
argument|Fidentity
argument_list|,
argument|Sidentity
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the argument unchanged."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"random"
argument_list|,
argument|Frandom
argument_list|,
argument|Srandom
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a pseudo-random number.\n\ On most systems all integers representable in Lisp are equally likely.\n\   This is 24 bits' worth.\n\ If optional argument is supplied as  t,\n\  the random number seed is set based on the current time and pid."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|long
name|random
parameter_list|()
function_decl|;
extern|extern srandom (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|if
condition|(
name|EQ
argument_list|(
name|arg
argument_list|,
name|Qt
argument_list|)
condition|)
name|srandom
argument_list|(
name|getpid
argument_list|()
operator|+
name|time
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|make_number
argument_list|(
operator|(
name|int
operator|)
name|random
argument_list|()
argument_list|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* Random data-structure functions */
end_comment

begin_expr_stmt
unit|DEFUN
operator|(
literal|"length"
operator|,
name|Flength
operator|,
name|Slength
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Return the length of vector, list or string SEQUENCE."
operator|)
operator|(
name|obj
operator|)
specifier|register
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|val
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|retry
label|:
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Vector
operator|||
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Farray_length
argument_list|(
name|obj
argument_list|)
return|;
elseif|else
if|if
condition|(
name|LISTP
argument_list|(
name|obj
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tail
operator|=
name|obj
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|i
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
else|else
block|{
name|obj
operator|=
name|wrong_type_argument
argument_list|(
name|Qsequencep
argument_list|,
name|obj
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"string-equal"
argument_list|,
name|Fstring_equal
argument_list|,
name|Sstring_equal
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if two strings have identical contents.\n\ Symbols are also allowed; their print names are used instead."
argument_list|)
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|Lisp_Object
name|s1
operator|,
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|s1
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|XSETSTRING
argument_list|(
name|s1
argument_list|,
name|XSYMBOL
argument_list|(
name|s1
argument_list|)
operator|->
name|name
argument_list|)
operator|,
name|XSETTYPE
argument_list|(
name|s1
argument_list|,
name|Lisp_String
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|s2
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|XSETSTRING
argument_list|(
name|s2
argument_list|,
name|XSYMBOL
argument_list|(
name|s2
argument_list|)
operator|->
name|name
argument_list|)
operator|,
name|XSETTYPE
argument_list|(
name|s2
argument_list|,
name|Lisp_String
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|s1
argument_list|)
operator|->
name|size
operator|!=
name|XSTRING
argument_list|(
name|s2
argument_list|)
operator|->
name|size
operator|||
name|bcmp
argument_list|(
name|XSTRING
argument_list|(
name|s1
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|s2
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|s1
argument_list|)
operator|->
name|size
argument_list|)
condition|)
return|return
name|Qnil
return|;
return|return
name|Qt
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"string-lessp"
argument_list|,
name|Fstring_lessp
argument_list|,
name|Sstring_lessp
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if first arg string is less than second in lexicographic order.\n\ Symbols are also allowed; their print names are used instead."
argument_list|)
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|Lisp_Object
name|s1
operator|,
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|end
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|s1
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|XSETSTRING
argument_list|(
name|s1
argument_list|,
name|XSYMBOL
argument_list|(
name|s1
argument_list|)
operator|->
name|name
argument_list|)
operator|,
name|XSETTYPE
argument_list|(
name|s1
argument_list|,
name|Lisp_String
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|s2
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|XSETSTRING
argument_list|(
name|s2
argument_list|,
name|XSYMBOL
argument_list|(
name|s2
argument_list|)
operator|->
name|name
argument_list|)
operator|,
name|XSETTYPE
argument_list|(
name|s2
argument_list|,
name|Lisp_String
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|s1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|s2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p1
operator|=
name|XSTRING
argument_list|(
name|s1
argument_list|)
operator|->
name|data
expr_stmt|;
name|p2
operator|=
name|XSTRING
argument_list|(
name|s2
argument_list|)
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|XSTRING
argument_list|(
name|s1
argument_list|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|XSTRING
argument_list|(
name|s2
argument_list|)
operator|->
name|size
condition|)
name|end
operator|=
name|XSTRING
argument_list|(
name|s2
argument_list|)
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p1
index|[
name|i
index|]
operator|!=
name|p2
index|[
name|i
index|]
condition|)
return|return
name|p1
index|[
name|i
index|]
operator|<
name|p2
index|[
name|i
index|]
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
return|return
name|i
operator|<
name|XSTRING
argument_list|(
name|s2
argument_list|)
operator|->
name|size
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
specifier|static
name|Lisp_Object
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Lisp_Object
name|concat2
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|Lisp_Object
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|s1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|s2
expr_stmt|;
return|return
name|concat
argument_list|(
literal|2
argument_list|,
name|args
argument_list|,
name|Lisp_String
argument_list|,
literal|0
argument_list|)
return|;
else|#
directive|else
return|return
name|concat
argument_list|(
literal|2
argument_list|,
operator|&
name|s1
argument_list|,
name|Lisp_String
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
comment|/* NO_ARG_ARRAY */
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"append"
argument_list|,
argument|Fappend
argument_list|,
argument|Sappend
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Concatenate arguments and make the result a list.\n\ The result is a list whose elements are the elements of all the arguments.\n\ Each argument may be a list, vector or string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|concat
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|Lisp_Cons
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"concat"
argument_list|,
argument|Fconcat
argument_list|,
argument|Sconcat
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Concatenate arguments and make the result a string.\n\ The result is a string whose elements are the elements of all the arguments.\n\ Each argument may be a list, vector or string; but all elements\n\ of a list or vector must be numbers, or an error is signaled."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|concat
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|Lisp_String
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"vconcat"
argument_list|,
argument|Fvconcat
argument_list|,
argument|Svconcat
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Concatenate arguments and make the result a vector.\n\ The result is a list whose elements are the elements of all the arguments.\n\ Each argument may be a list, vector or string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|concat
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|Lisp_Vector
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"copy-sequence"
argument_list|,
argument|Fcopy_sequence
argument_list|,
argument|Scopy_sequence
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a copy of a list, vector or string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|arg
return|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|arg
argument_list|)
operator|&&
name|XTYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|Lisp_Vector
operator|&&
name|XTYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|Lisp_String
condition|)
name|arg
operator|=
name|wrong_type_argument
argument_list|(
name|Qsequencep
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|concat
argument_list|(
literal|1
argument_list|,
operator|&
name|arg
argument_list|,
name|LISTP
argument_list|(
name|arg
argument_list|)
condition|?
name|Lisp_Cons
else|:
name|XTYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|Lisp_Object
name|concat
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|target_type
parameter_list|,
name|last_special
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
name|enum
name|Lisp_Type
name|target_type
decl_stmt|;
name|int
name|last_special
decl_stmt|;
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|Lisp_Object
name|len
decl_stmt|;
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
specifier|register
name|Lisp_Object
name|this
decl_stmt|;
name|int
name|toindex
decl_stmt|;
specifier|register
name|int
name|leni
decl_stmt|;
specifier|register
name|int
name|argnum
decl_stmt|;
name|Lisp_Object
name|last_tail
decl_stmt|;
name|Lisp_Object
name|prev
decl_stmt|;
comment|/* In append, the last arg isn't treated like the others */
if|if
condition|(
name|last_special
operator|&&
name|nargs
operator|>
literal|0
condition|)
block|{
name|nargs
operator|--
expr_stmt|;
name|last_tail
operator|=
name|args
index|[
name|nargs
index|]
expr_stmt|;
block|}
else|else
name|last_tail
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|this
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|LISTP
argument_list|(
name|this
argument_list|)
operator|||
name|NULL
argument_list|(
name|this
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|this
argument_list|)
operator|==
name|Lisp_Vector
operator|||
name|XTYPE
argument_list|(
name|this
argument_list|)
operator|==
name|Lisp_String
operator|)
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|this
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|args
index|[
name|argnum
index|]
operator|=
name|Fint_to_string
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|args
index|[
name|argnum
index|]
operator|=
name|wrong_type_argument
argument_list|(
name|Qsequencep
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|argnum
operator|=
literal|0
operator|,
name|leni
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|this
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
name|len
operator|=
name|Flength
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|leni
operator|+=
name|XFASTINT
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|len
argument_list|)
operator|=
name|leni
expr_stmt|;
if|if
condition|(
name|target_type
operator|==
name|Lisp_Cons
condition|)
name|val
operator|=
name|Fmake_list
argument_list|(
name|len
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|target_type
operator|==
name|Lisp_Vector
condition|)
name|val
operator|=
name|Fmake_vector
argument_list|(
name|len
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|Fmake_string
argument_list|(
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* In append, if all but last arg are nil, return last arg */
if|if
condition|(
name|target_type
operator|==
name|Lisp_Cons
operator|&&
name|EQ
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
condition|)
return|return
name|last_tail
return|;
if|if
condition|(
name|LISTP
argument_list|(
name|val
argument_list|)
condition|)
name|tail
operator|=
name|val
operator|,
name|toindex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1 in toindex is flag we are making a list */
else|else
name|toindex
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|Lisp_Object
name|thislen
decl_stmt|;
name|int
name|thisleni
decl_stmt|;
specifier|register
name|int
name|thisindex
init|=
literal|0
decl_stmt|;
name|this
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|this
argument_list|)
condition|)
name|thislen
operator|=
name|Flength
argument_list|(
name|this
argument_list|)
operator|,
name|thisleni
operator|=
name|XINT
argument_list|(
name|thislen
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|Lisp_Object
name|elt
decl_stmt|;
comment|/* Fetch next element of `this' arg into `elt', or break if `this' is exhausted. */
if|if
condition|(
name|NULL
argument_list|(
name|this
argument_list|)
condition|)
break|break;
if|if
condition|(
name|LISTP
argument_list|(
name|this
argument_list|)
condition|)
name|elt
operator|=
name|Fcar
argument_list|(
name|this
argument_list|)
operator|,
name|this
operator|=
name|Fcdr
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|thisindex
operator|>=
name|thisleni
condition|)
break|break;
if|if
condition|(
name|XTYPE
argument_list|(
name|this
argument_list|)
operator|==
name|Lisp_String
condition|)
name|XFASTINT
argument_list|(
name|elt
argument_list|)
operator|=
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|data
index|[
name|thisindex
operator|++
index|]
expr_stmt|;
else|else
name|elt
operator|=
name|XVECTOR
argument_list|(
name|this
argument_list|)
operator|->
name|contents
index|[
name|thisindex
operator|++
index|]
expr_stmt|;
block|}
comment|/* Store into result */
if|if
condition|(
name|toindex
operator|<
literal|0
condition|)
block|{
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
operator|=
name|elt
expr_stmt|;
name|prev
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|val
argument_list|)
operator|==
name|Lisp_Vector
condition|)
name|XVECTOR
argument_list|(
name|val
argument_list|)
operator|->
name|contents
index|[
name|toindex
operator|++
index|]
operator|=
name|elt
expr_stmt|;
else|else
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|!=
name|Lisp_Int
condition|)
name|elt
operator|=
name|wrong_type_argument
argument_list|(
name|Qintegerp
argument_list|,
name|elt
argument_list|)
expr_stmt|;
else|else
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
index|[
name|toindex
operator|++
index|]
operator|=
name|XINT
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|prev
argument_list|)
condition|)
name|XCONS
argument_list|(
name|prev
argument_list|)
operator|->
name|cdr
operator|=
name|last_tail
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"substring"
argument_list|,
argument|Fsubstring
argument_list|,
argument|Ssubstring
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Return a substring of STRING, starting at index FROM and reaching until TO.\n\ TO may be nil or omitted; then the substring runs to the end of STRING.\n\ If FROM or TO is negative, it counts from the end."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|from
operator|,
name|to
operator|)
name|Lisp_Object
name|string
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|from
decl_stmt|,
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|,
name|len
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|to
argument_list|)
condition|)
name|to
operator|=
name|Flength
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|to
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|from
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|from
argument_list|,
name|XINT
argument_list|(
name|from
argument_list|)
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|to
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|to
argument_list|,
name|XINT
argument_list|(
name|to
argument_list|)
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<=
name|XINT
argument_list|(
name|from
argument_list|)
operator|&&
name|XINT
argument_list|(
name|from
argument_list|)
operator|<=
name|XINT
argument_list|(
name|to
argument_list|)
operator|&&
name|XINT
argument_list|(
name|to
argument_list|)
operator|<=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|)
condition|)
name|args_out_of_range_3
argument_list|(
name|string
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|len
argument_list|)
operator|=
name|XINT
argument_list|(
name|to
argument_list|)
operator|-
name|XINT
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fmake_string
argument_list|(
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
operator|+
name|XINT
argument_list|(
name|from
argument_list|)
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|,
name|XINT
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"nthcdr"
argument_list|,
argument|Fnthcdr
argument_list|,
argument|Snthcdr
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Takes cdr N times on LIST, returns the result."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|list
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"nth"
argument_list|,
argument|Fnth
argument_list|,
argument|Snth
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Returns the Nth element of LIST.\n\ N counts from zero.  If LIST is not that long, nil is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|list
operator|)
name|Lisp_Object
name|n
operator|,
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XTYPE
argument_list|(
name|list
argument_list|)
operator|==
name|Lisp_Cons
operator|||
name|NULL
argument_list|(
name|list
argument_list|)
operator|)
condition|)
name|list
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
name|Fcar
argument_list|(
name|Fnthcdr
argument_list|(
name|n
argument_list|,
name|list
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"elt"
argument_list|,
name|Felt
argument_list|,
name|Selt
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Returns element of SEQUENCE at index N."
argument_list|)
argument_list|(
name|seq
argument_list|,
name|n
argument_list|)
specifier|register
name|Lisp_Object
name|seq
operator|,
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|seq
argument_list|)
operator|==
name|Lisp_Cons
operator|||
name|NULL
argument_list|(
name|seq
argument_list|)
condition|)
return|return
name|Fcar
argument_list|(
name|Fnthcdr
argument_list|(
name|n
argument_list|,
name|seq
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|seq
argument_list|)
operator|==
name|Lisp_String
operator|||
name|XTYPE
argument_list|(
name|seq
argument_list|)
operator|==
name|Lisp_Vector
condition|)
return|return
name|Faref
argument_list|(
name|seq
argument_list|,
name|n
argument_list|)
return|;
else|else
name|seq
operator|=
name|wrong_type_argument
argument_list|(
name|Qsequencep
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"memq"
argument_list|,
name|Fmemq
argument_list|,
name|Smemq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Returns non-nil if ELT is an element of LIST.  Comparison done with EQ.\n\ The value is actually the tail of LIST whose car is ELT."
argument_list|)
argument_list|(
name|elt
argument_list|,
name|list
argument_list|)
specifier|register
name|Lisp_Object
name|elt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|elt
argument_list|,
name|tem
argument_list|)
condition|)
return|return
name|tail
return|;
name|QUIT
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"assq"
argument_list|,
name|Fassq
argument_list|,
name|Sassq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Returns non-nil if ELT is the car of an element of LIST.  Comparison done with eq.\n\ The value is actually the element of LIST whose car is ELT."
argument_list|)
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
specifier|register
name|Lisp_Object
name|key
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|register
name|Lisp_Object
name|elt
decl_stmt|,
name|tem
decl_stmt|;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|elt
argument_list|)
condition|)
continue|continue;
name|tem
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|key
argument_list|,
name|tem
argument_list|)
condition|)
return|return
name|elt
return|;
name|QUIT
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"assoc"
argument_list|,
name|Fassoc
argument_list|,
name|Sassoc
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Returns non-nil if ELT is the car of an element of LIST.  Comparison done with  equal.\n\ The value is actually the element of LIST whose car is ELT."
argument_list|)
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
specifier|register
name|Lisp_Object
name|key
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|register
name|Lisp_Object
name|elt
decl_stmt|,
name|tem
decl_stmt|;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|elt
argument_list|)
condition|)
continue|continue;
name|tem
operator|=
name|Fequal
argument_list|(
name|Fcar
argument_list|(
name|elt
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|elt
return|;
name|QUIT
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"rassq"
argument_list|,
name|Frassq
argument_list|,
name|Srassq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Returns non-nil if ELT is the cdr of an element of LIST.  Comparison done with EQ.\n\ The value is actually the element of LIST whose cdr is ELT."
argument_list|)
argument_list|(
name|key
argument_list|,
name|list
argument_list|)
specifier|register
name|Lisp_Object
name|key
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|list
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
specifier|register
name|Lisp_Object
name|elt
decl_stmt|,
name|tem
decl_stmt|;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|elt
argument_list|)
condition|)
continue|continue;
name|tem
operator|=
name|Fcdr
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|key
argument_list|,
name|tem
argument_list|)
condition|)
return|return
name|elt
return|;
name|QUIT
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"delq"
argument_list|,
name|Fdelq
argument_list|,
name|Sdelq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Deletes by side effect any occurrences of ELT as a member of LIST.\n\ The modified LIST is returned.\n\ If the first member of LIST is ELT, there is no way to remove it by side effect;\n\ therefore, write  (setq foo (delq element foo))  to be sure of changing  foo."
argument_list|)
argument_list|(
name|elt
argument_list|,
name|list
argument_list|)
specifier|register
name|Lisp_Object
name|elt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|prev
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tail
operator|=
name|list
expr_stmt|;
name|prev
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|elt
argument_list|,
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|prev
argument_list|)
condition|)
name|list
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
else|else
name|Fsetcdr
argument_list|(
name|prev
argument_list|,
name|Fcdr
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"nreverse"
argument_list|,
argument|Fnreverse
argument_list|,
argument|Snreverse
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Reverses LIST by modifying cdr pointers.  Returns the beginning of the reversed list."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|list
operator|)
name|Lisp_Object
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|prev
decl_stmt|,
name|tail
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|prev
operator|=
name|Qnil
expr_stmt|;
name|tail
operator|=
name|list
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|next
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|Fsetcdr
argument_list|(
name|tail
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|next
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"reverse"
argument_list|,
argument|Freverse
argument_list|,
argument|Sreverse
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Reverses LIST, copying.  Returns the beginning of the reversed list."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|list
operator|)
name|Lisp_Object
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|length
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|vector
decl_stmt|;
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|length
operator|=
name|Flength
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|vector
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|XINT
argument_list|(
name|length
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XINT
argument_list|(
name|length
argument_list|)
operator|-
literal|1
operator|,
name|tail
operator|=
name|list
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
name|vector
index|[
name|i
index|]
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
return|return
name|Flist
argument_list|(
name|XINT
argument_list|(
name|length
argument_list|)
argument_list|,
name|vector
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
name|Lisp_Object
name|merge
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"sort"
argument_list|,
argument|Fsort
argument_list|,
argument|Ssort
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Sort LIST, stably, comparing elements using PREDICATE.\n\ Returns the sorted list.  LIST is modified by side effects.\n\ PREDICATE is called with two elements of LIST, and should return T\n\ if the first element is \"less\" than the second."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|list
operator|,
name|pred
operator|)
name|Lisp_Object
name|list
operator|,
name|pred
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|front
decl_stmt|,
name|back
decl_stmt|;
specifier|register
name|Lisp_Object
name|len
decl_stmt|,
name|tem
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
name|front
operator|=
name|list
expr_stmt|;
name|len
operator|=
name|Flength
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|length
operator|=
name|XINT
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
name|list
return|;
name|XSETINT
argument_list|(
name|len
argument_list|,
operator|(
name|length
operator|/
literal|2
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fnthcdr
argument_list|(
name|len
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|back
operator|=
name|Fcdr
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fsetcdr
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|GCPRO2
argument_list|(
name|front
argument_list|,
name|back
argument_list|)
expr_stmt|;
name|front
operator|=
name|Fsort
argument_list|(
name|front
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|back
operator|=
name|Fsort
argument_list|(
name|back
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|merge
argument_list|(
name|front
argument_list|,
name|back
argument_list|,
name|pred
argument_list|)
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|merge
parameter_list|(
name|org_l1
parameter_list|,
name|org_l2
parameter_list|,
name|pred
parameter_list|)
name|Lisp_Object
name|org_l1
decl_stmt|,
name|org_l2
decl_stmt|;
name|Lisp_Object
name|pred
decl_stmt|;
block|{
name|Lisp_Object
name|value
decl_stmt|;
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|Lisp_Object
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|,
name|gcpro4
decl_stmt|;
name|l1
operator|=
name|org_l1
expr_stmt|;
name|l2
operator|=
name|org_l2
expr_stmt|;
name|tail
operator|=
name|Qnil
expr_stmt|;
name|value
operator|=
name|Qnil
expr_stmt|;
comment|/* It is sufficient to protect org_l1 and org_l2.      When l1 and l2 are updated, we copy the new values      back into the org_ vars.  */
name|GCPRO4
argument_list|(
name|org_l1
argument_list|,
name|org_l2
argument_list|,
name|pred
argument_list|,
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|l1
argument_list|)
condition|)
block|{
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
return|return
name|l2
return|;
name|Fsetcdr
argument_list|(
name|tail
argument_list|,
name|l2
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|l2
argument_list|)
condition|)
block|{
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
return|return
name|l1
return|;
name|Fsetcdr
argument_list|(
name|tail
argument_list|,
name|l1
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
name|tem
operator|=
name|call2
argument_list|(
name|pred
argument_list|,
name|Fcar
argument_list|(
name|l1
argument_list|)
argument_list|,
name|Fcar
argument_list|(
name|l2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|tem
operator|=
name|l1
expr_stmt|;
name|l1
operator|=
name|Fcdr
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|org_l1
operator|=
name|l1
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|l2
expr_stmt|;
name|l2
operator|=
name|Fcdr
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|org_l2
operator|=
name|l2
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
name|value
operator|=
name|tem
expr_stmt|;
else|else
name|Fsetcdr
argument_list|(
name|tail
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tail
operator|=
name|tem
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"get"
argument_list|,
argument|Fget
argument_list|,
argument|Sget
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the value of SYMBOL's PROPNAME property.\n\ This is the last VALUE stored with  (put SYMBOL PROPNAME VALUE)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sym
operator|,
name|prop
operator|)
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|prop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|Fsymbol_plist
argument_list|(
name|sym
argument_list|)
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|tail
argument_list|)
argument_list|)
control|)
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|prop
argument_list|,
name|tem
argument_list|)
condition|)
return|return
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|tail
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"put"
argument_list|,
argument|Fput
argument_list|,
argument|Sput
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Store SYMBOL's PROPNAME property with value VALUE.\n\ It can be retrieved with  (get SYMBOL PROPNAME)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sym
operator|,
name|prop
operator|,
name|val
operator|)
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|prop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|prev
decl_stmt|;
name|Lisp_Object
name|newcell
decl_stmt|;
name|prev
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Fsymbol_plist
argument_list|(
name|sym
argument_list|)
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|tail
argument_list|)
argument_list|)
control|)
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|prop
argument_list|,
name|tem
argument_list|)
condition|)
return|return
name|Fsetcar
argument_list|(
name|Fcdr
argument_list|(
name|tail
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
name|prev
operator|=
name|tail
expr_stmt|;
block|}
name|newcell
operator|=
name|Fcons
argument_list|(
name|prop
argument_list|,
name|Fcons
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|prev
argument_list|)
condition|)
name|Fsetplist
argument_list|(
name|sym
argument_list|,
name|newcell
argument_list|)
expr_stmt|;
else|else
name|Fsetcdr
argument_list|(
name|Fcdr
argument_list|(
name|prev
argument_list|)
argument_list|,
name|newcell
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"equal"
argument_list|,
name|Fequal
argument_list|,
name|Sequal
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if two Lisp objects have similar structure and contents.\n\ They must have the same data type.\n\ Conses are compared by comparing the cars and the cdrs.\n\ Vectors and strings are compared element by element.\n\ Numbers are compared by value.  Symbols must match exactly."
argument_list|)
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
specifier|register
name|Lisp_Object
name|o1
operator|,
name|o2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|do_cdr
label|:
name|QUIT
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|o1
argument_list|)
operator|!=
name|XTYPE
argument_list|(
name|o2
argument_list|)
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|XINT
argument_list|(
name|o1
argument_list|)
operator|==
name|XINT
argument_list|(
name|o2
argument_list|)
condition|)
return|return
name|Qt
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|o1
argument_list|)
operator|==
name|Lisp_Cons
condition|)
block|{
name|Lisp_Object
name|v1
decl_stmt|;
name|v1
operator|=
name|Fequal
argument_list|(
name|Fcar
argument_list|(
name|o1
argument_list|)
argument_list|,
name|Fcar
argument_list|(
name|o2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|v1
argument_list|)
condition|)
return|return
name|v1
return|;
name|o1
operator|=
name|Fcdr
argument_list|(
name|o1
argument_list|)
operator|,
name|o2
operator|=
name|Fcdr
argument_list|(
name|o2
argument_list|)
expr_stmt|;
goto|goto
name|do_cdr
goto|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|o1
argument_list|)
operator|==
name|Lisp_Marker
condition|)
block|{
return|return
operator|(
name|XMARKER
argument_list|(
name|o1
argument_list|)
operator|->
name|buffer
operator|==
name|XMARKER
argument_list|(
name|o2
argument_list|)
operator|->
name|buffer
operator|&&
name|XMARKER
argument_list|(
name|o1
argument_list|)
operator|->
name|bufpos
operator|==
name|XMARKER
argument_list|(
name|o2
argument_list|)
operator|->
name|bufpos
operator|)
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|o1
argument_list|)
operator|==
name|Lisp_Vector
condition|)
block|{
specifier|register
name|int
name|index
decl_stmt|;
if|if
condition|(
name|XVECTOR
argument_list|(
name|o1
argument_list|)
operator|->
name|size
operator|!=
name|XVECTOR
argument_list|(
name|o2
argument_list|)
operator|->
name|size
condition|)
return|return
name|Qnil
return|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XVECTOR
argument_list|(
name|o1
argument_list|)
operator|->
name|size
condition|;
name|index
operator|++
control|)
block|{
name|Lisp_Object
name|v
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|;
name|v1
operator|=
name|XVECTOR
argument_list|(
name|o1
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
name|v2
operator|=
name|XVECTOR
argument_list|(
name|o2
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
name|v
operator|=
name|Fequal
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|v
argument_list|)
condition|)
return|return
name|v
return|;
block|}
return|return
name|Qt
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|o1
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
if|if
condition|(
name|XSTRING
argument_list|(
name|o1
argument_list|)
operator|->
name|size
operator|!=
name|XSTRING
argument_list|(
name|o2
argument_list|)
operator|->
name|size
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|XSTRING
argument_list|(
name|o1
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|o2
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|o1
argument_list|)
operator|->
name|size
argument_list|)
condition|)
return|return
name|Qnil
return|;
return|return
name|Qt
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"fillarray"
argument_list|,
argument|Ffillarray
argument_list|,
argument|Sfillarray
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Store each element of ARRAY with ITEM.  ARRAY is a vector or string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|array
operator|,
name|item
operator|)
name|Lisp_Object
name|array
operator|,
name|item
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|size
decl_stmt|,
name|index
decl_stmt|,
name|charval
decl_stmt|;
name|retry
label|:
if|if
condition|(
name|XTYPE
argument_list|(
name|array
argument_list|)
operator|==
name|Lisp_Vector
condition|)
block|{
specifier|register
name|Lisp_Object
modifier|*
name|p
init|=
name|XVECTOR
argument_list|(
name|array
argument_list|)
operator|->
name|contents
decl_stmt|;
name|size
operator|=
name|XVECTOR
argument_list|(
name|array
argument_list|)
operator|->
name|size
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|size
condition|;
name|index
operator|++
control|)
name|p
index|[
name|index
index|]
operator|=
name|item
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|array
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|XSTRING
argument_list|(
name|array
argument_list|)
operator|->
name|data
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|item
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|charval
operator|=
name|XINT
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|size
operator|=
name|XSTRING
argument_list|(
name|array
argument_list|)
operator|->
name|size
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|size
condition|;
name|index
operator|++
control|)
name|p
index|[
name|index
index|]
operator|=
name|charval
expr_stmt|;
block|}
else|else
block|{
name|array
operator|=
name|wrong_type_argument
argument_list|(
name|Qarrayp
argument_list|,
name|array
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
name|array
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Lisp_Object
name|nconc2
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|Lisp_Object
name|s1
decl_stmt|,
name|s2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|s1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|s2
expr_stmt|;
return|return
name|Fnconc
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
return|;
else|#
directive|else
return|return
name|Fnconc
argument_list|(
literal|2
argument_list|,
operator|&
name|s1
argument_list|)
return|;
endif|#
directive|endif
comment|/* NO_ARG_ARRAY */
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"nconc"
argument_list|,
argument|Fnconc
argument_list|,
argument|Snconc
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Concatenate any number of lists by altering them.\n\ Only the last argument is not altered, and need not be a list."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|argnum
decl_stmt|;
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|tem
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|argnum
operator|+
literal|1
operator|==
name|nargs
condition|)
break|break;
while|while
condition|(
name|LISTP
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|tail
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
name|tem
operator|=
name|args
index|[
name|argnum
operator|+
literal|1
index|]
expr_stmt|;
name|Fsetcdr
argument_list|(
name|tail
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|args
index|[
name|argnum
operator|+
literal|1
index|]
operator|=
name|tail
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This is the guts of all mapping functions.  Apply fn to each element of seq, one by one,  storing the results into elements of vals, a C vector of Lisp_Objects.  leni is the length of vals, which should also be the length of seq. */
end_comment

begin_function
specifier|static
name|void
name|mapcar1
parameter_list|(
name|leni
parameter_list|,
name|vals
parameter_list|,
name|fn
parameter_list|,
name|seq
parameter_list|)
name|int
name|leni
decl_stmt|;
name|Lisp_Object
modifier|*
name|vals
decl_stmt|;
name|Lisp_Object
name|fn
decl_stmt|,
name|seq
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
name|Lisp_Object
name|dummy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|;
comment|/* Don't let vals contain any garbage when GC happens.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leni
condition|;
name|i
operator|++
control|)
name|vals
index|[
name|i
index|]
operator|=
name|Qnil
expr_stmt|;
name|GCPRO3
argument_list|(
name|dummy
argument_list|,
name|fn
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|gcpro1
operator|.
name|var
operator|=
name|vals
expr_stmt|;
name|gcpro1
operator|.
name|nvars
operator|=
name|leni
expr_stmt|;
comment|/* We need not explicitly protect `tail' because it is used only on lists, and     1) lists are not relocated and 2) the list is marked via `seq' so will not be freed */
if|if
condition|(
name|XTYPE
argument_list|(
name|seq
argument_list|)
operator|==
name|Lisp_Vector
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leni
condition|;
name|i
operator|++
control|)
block|{
name|dummy
operator|=
name|XVECTOR
argument_list|(
name|seq
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|vals
index|[
name|i
index|]
operator|=
name|call1
argument_list|(
name|fn
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|seq
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leni
condition|;
name|i
operator|++
control|)
block|{
name|XFASTINT
argument_list|(
name|dummy
argument_list|)
operator|=
name|XSTRING
argument_list|(
name|seq
argument_list|)
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
name|vals
index|[
name|i
index|]
operator|=
name|call1
argument_list|(
name|fn
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Must be a list, since Flength did not get an error */
block|{
name|tail
operator|=
name|seq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leni
condition|;
name|i
operator|++
control|)
block|{
name|vals
index|[
name|i
index|]
operator|=
name|call1
argument_list|(
name|fn
argument_list|,
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
block|}
name|UNGCPRO
expr_stmt|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"mapconcat"
argument_list|,
argument|Fmapconcat
argument_list|,
argument|Smapconcat
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Apply FN to each element of SEQ, and concat the results as strings.\n\ In between each pair of results, stick in SEP.\n\ Thus, \" \" as SEP results in spaces between the values return by FN."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|fn
operator|,
name|seq
operator|,
name|sep
operator|)
name|Lisp_Object
name|fn
operator|,
name|seq
operator|,
name|sep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|len
decl_stmt|;
specifier|register
name|int
name|leni
decl_stmt|;
name|int
name|nargs
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|len
operator|=
name|Flength
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|leni
operator|=
name|XINT
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|leni
operator|+
name|leni
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nargs
operator|<
literal|0
condition|)
return|return
name|build_string
argument_list|(
literal|""
argument_list|)
return|;
name|args
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|mapcar1
argument_list|(
name|leni
argument_list|,
name|args
argument_list|,
name|fn
argument_list|,
name|seq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|leni
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|args
index|[
name|i
operator|+
name|i
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|+=
literal|2
control|)
name|args
index|[
name|i
index|]
operator|=
name|sep
expr_stmt|;
return|return
name|Fconcat
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"mapcar"
argument_list|,
argument|Fmapcar
argument_list|,
argument|Smapcar
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Apply FUNCTION to each element of LIST, and make a list of the results.\n\ The result is a list just as long as LIST."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|fn
operator|,
name|seq
operator|)
name|Lisp_Object
name|fn
operator|,
name|seq
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|len
decl_stmt|;
specifier|register
name|int
name|leni
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
name|len
operator|=
name|Flength
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|leni
operator|=
name|XFASTINT
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|args
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|leni
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|mapcar1
argument_list|(
name|leni
argument_list|,
name|args
argument_list|,
name|fn
argument_list|,
name|seq
argument_list|)
expr_stmt|;
return|return
name|Flist
argument_list|(
name|leni
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"y-or-n-p"
argument_list|,
argument|Fy_or_n_p
argument_list|,
argument|Sy_or_n_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Ask user a \"y or n\" question.  Return t if answer is \"y\".\n\ No confirmation of the answer is requested; a single character is enough.\n\ Also accepts Space to mean yes, or Delete to mean no."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|ans
decl_stmt|;
specifier|register
name|Lisp_Object
name|xprompt
decl_stmt|;
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xprompt
operator|=
name|prompt
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|message
argument_list|(
literal|"%s(y or n) "
argument_list|,
name|XSTRING
argument_list|(
name|xprompt
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|ans
operator|=
name|get_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"%s(y or n) %c"
argument_list|,
name|XSTRING
argument_list|(
name|xprompt
argument_list|)
operator|->
name|data
argument_list|,
name|ans
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|ans
operator|>=
literal|'A'
operator|&&
name|ans
operator|<=
literal|'Z'
condition|)
name|ans
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|'y'
operator|||
name|ans
operator|==
literal|' '
condition|)
return|return
name|Qt
return|;
if|if
condition|(
name|ans
operator|==
literal|'n'
operator|||
name|ans
operator|==
literal|127
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|EQ
argument_list|(
name|xprompt
argument_list|,
name|prompt
argument_list|)
condition|)
block|{
name|Fdiscard_input
argument_list|()
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|build_string
argument_list|(
literal|"Please answer y or n.  "
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|prompt
expr_stmt|;
name|xprompt
operator|=
name|Fconcat
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"yes-or-no-p"
argument_list|,
argument|Fyes_or_no_p
argument_list|,
argument|Syes_or_no_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Ask user a yes or no question.  Return t if answer is yes.\n\ The user must confirm the answer with a newline, and can rub it out if not confirmed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|ans
decl_stmt|;
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|prompt
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|build_string
argument_list|(
literal|"(yes or no) "
argument_list|)
expr_stmt|;
name|prompt
operator|=
name|Fconcat
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ans
operator|=
name|Fdowncase
argument_list|(
name|read_minibuf_string
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|Qnil
argument_list|,
name|prompt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|ans
argument_list|)
operator|->
name|size
operator|==
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTRING
argument_list|(
name|ans
argument_list|)
operator|->
name|data
argument_list|,
literal|"yes"
argument_list|)
condition|)
return|return
name|Qt
return|;
if|if
condition|(
name|XSTRING
argument_list|(
name|ans
argument_list|)
operator|->
name|size
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTRING
argument_list|(
name|ans
argument_list|)
operator|->
name|data
argument_list|,
literal|"no"
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|Fdiscard_input
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Please answer yes or no."
argument_list|)
expr_stmt|;
name|Fsleep_for
argument_list|(
name|make_number
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Avoid static vars inside a function since in HPUX they dump as pure.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ldav_initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ldav_channel
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOAD_AVE_TYPE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|ldav_nl
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOAD_AVE_TYPE */
end_comment

begin_define
define|#
directive|define
name|channel
value|ldav_channel
end_define

begin_define
define|#
directive|define
name|initialized
value|ldav_initialized
end_define

begin_define
define|#
directive|define
name|nl
value|ldav_nl
end_define

begin_macro
name|DEFUN
argument_list|(
literal|"load-average"
argument_list|,
argument|Fload_average
argument_list|,
argument|Sload_average
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the current 1 minute, 5 minute and 15 minute load averages\n\ in a list (all floating point load average values are multiplied by 100\n\ and then turned into integers)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
ifdef|#
directive|ifdef
name|eunice
include|#
directive|include
file|<vms/iodef.h>
comment|/*    *	VMS/Eunice specific code -- read from the Load Ave driver    */
name|float
name|load_ave
index|[
literal|3
index|]
block|;   struct
block|{
name|int
name|size
block|;
name|char
operator|*
name|ptr
block|;}
name|descriptor
block|;
comment|/* If this fails for any reason, we can return (0 0 0) */
name|load_ave
index|[
literal|0
index|]
operator|=
literal|0.0
block|;
name|load_ave
index|[
literal|1
index|]
operator|=
literal|0.0
block|;
name|load_ave
index|[
literal|2
index|]
operator|=
literal|0.0
block|;
comment|/*    *	Ensure that there is a channel open to the load ave device    */
if|if
condition|(
name|initialized
operator|==
literal|0
condition|)
block|{
comment|/* Attempt to open the channel */
name|descriptor
operator|.
name|size
operator|=
literal|18
expr_stmt|;
name|descriptor
operator|.
name|ptr
operator|=
literal|"$$VMS_LOAD_AVERAGE"
expr_stmt|;
if|if
condition|(
name|sys$assign
argument_list|(
operator|&
name|descriptor
argument_list|,
operator|&
name|channel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
condition|)
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/*    *	Read the load average vector    */
end_comment

begin_if
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sys$qiow
argument_list|(
literal|0
argument_list|,
name|channel
argument_list|,
name|IO$_READVBLK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|load_ave
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
name|sys$dassgn
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not eunice */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LOAD_AVE_TYPE
end_ifndef

begin_expr_stmt
name|error
argument_list|(
literal|"load-average not implemented for this operating system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LOAD_AVE_CVT
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LOAD_AVE_TYPE defined */
end_comment

begin_comment
comment|/*    *	4.2BSD UNIX-specific code -- read _avenrun from /dev/kmem    */
end_comment

begin_decl_stmt
name|LOAD_AVE_TYPE
name|load_ave
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this fails for any reason, we can return (0 0 0) */
end_comment

begin_expr_stmt
name|load_ave
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|load_ave
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|load_ave
index|[
literal|2
index|]
operator|=
literal|0.0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    *	Make sure we have the address of _avenrun    */
end_comment

begin_if
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
block|{
comment|/*        *	Get the address of _avenrun        */
ifndef|#
directive|ifndef
name|NLIST_STRUCT
name|strcpy
argument_list|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_name
argument_list|,
name|LDAV_SYMBOL
argument_list|)
expr_stmt|;
name|nl
index|[
literal|1
index|]
operator|.
name|n_zeroes
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* NLIST_STRUCT */
name|nl
index|[
literal|0
index|]
operator|.
name|n_name
operator|=
name|LDAV_SYMBOL
expr_stmt|;
name|nl
index|[
literal|1
index|]
operator|.
name|n_name
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* NLIST_STRUCT */
name|nlist
argument_list|(
name|KERNEL_FILE
argument_list|,
name|nl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXUP_KERNEL_SYMBOL_ADDR
if|if
condition|(
operator|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_ABS
condition|)
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
operator|=
operator|(
name|nlp
operator|->
name|n_value
operator|>>
literal|2
operator|)
operator||
literal|0xc0000000
expr_stmt|;
endif|#
directive|endif
comment|/* FIXUP_KERNEL_SYMBOL_ADDR */
block|}
end_if

begin_comment
comment|/*    *	Make sure we have /dev/kmem open    */
end_comment

begin_if
if|if
condition|(
name|initialized
operator|==
literal|0
condition|)
block|{
comment|/*        *	Open /dev/kmem        */
name|channel
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|>=
literal|0
condition|)
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_comment
comment|/*    *	If we can, get the load ave values    */
end_comment

begin_if
if|if
condition|(
operator|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|initialized
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/*        *	Seek to the correct address        */
name|lseek
argument_list|(
name|channel
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|channel
argument_list|,
name|load_ave
argument_list|,
sizeof|sizeof
name|load_ave
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|load_ave
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOAD_AVE_TYPE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not eunice */
end_comment

begin_comment
comment|/*    *	Return the list of load average values    */
end_comment

begin_return
return|return
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|LOAD_AVE_CVT
argument_list|(
name|load_ave
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|LOAD_AVE_CVT
argument_list|(
name|load_ave
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|LOAD_AVE_CVT
argument_list|(
name|load_ave
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
return|;
end_return

begin_undef
unit|}
undef|#
directive|undef
name|channel
end_undef

begin_undef
undef|#
directive|undef
name|initialized
end_undef

begin_undef
undef|#
directive|undef
name|nl
end_undef

begin_escape
end_escape

begin_expr_stmt
unit|Lisp_Object
name|Vfeatures
expr_stmt|;
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"featurep"
argument_list|,
argument|Ffeaturep
argument_list|,
argument|Sfeaturep
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Returns t if FEATURE is present in this Emacs.\n\ Use this to conditionalize execution of lisp code based on the presence or\n\ absence of emacs or environment extensions.\n\ Use  provide  to declare that a feature is available.\n\ This function looks at the value of the variable  features."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|feature
operator|)
name|Lisp_Object
name|feature
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|feature
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmemq
argument_list|(
name|feature
argument_list|,
name|Vfeatures
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
condition|?
name|Qnil
else|:
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"provide"
argument_list|,
argument|Fprovide
argument_list|,
argument|Sprovide
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Announce that FEATURE is a feature of the current Emacs."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|feature
operator|)
name|Lisp_Object
name|feature
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|feature
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vautoload_queue
argument_list|)
condition|)
name|Vautoload_queue
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|Vfeatures
argument_list|,
name|Qnil
argument_list|)
argument_list|,
name|Vautoload_queue
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmemq
argument_list|(
name|feature
argument_list|,
name|Vfeatures
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|Vfeatures
operator|=
name|Fcons
argument_list|(
name|feature
argument_list|,
name|Vfeatures
argument_list|)
expr_stmt|;
return|return
name|feature
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"require"
argument_list|,
argument|Frequire
argument_list|,
argument|Srequire
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"If FEATURE is not present in Emacs (ie (featurep FEATURE) is false),\n\ load FILENAME.  FILENAME is optional and defaults to FEATURE."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|feature
operator|,
name|file_name
operator|)
name|Lisp_Object
name|feature
operator|,
name|file_name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|feature
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmemq
argument_list|(
name|feature
argument_list|,
name|Vfeatures
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|Fload
argument_list|(
name|NULL
argument_list|(
name|file_name
argument_list|)
condition|?
name|Fsymbol_name
argument_list|(
name|feature
argument_list|)
else|:
name|file_name
argument_list|,
name|Qnil
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmemq
argument_list|(
name|feature
argument_list|,
name|Vfeatures
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|error
argument_list|(
literal|"Required feature %s was not provided"
argument_list|,
name|XSYMBOL
argument_list|(
name|feature
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|feature
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_fns
argument_list|()
end_macro

begin_block
block|{
name|Qstring_lessp
operator|=
name|intern
argument_list|(
literal|"string-lessp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qstring_lessp
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"features"
argument_list|,
operator|&
name|Vfeatures
argument_list|,
literal|"A list of symbols which are the features of the executing emacs.\n\ Used by  featurep  and  require, and altered by  provide."
argument_list|)
expr_stmt|;
name|Vfeatures
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sidentity
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srandom
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slength
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstring_equal
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstring_lessp
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Sstring_equal
argument_list|,
literal|"string="
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Sstring_lessp
argument_list|,
literal|"string<"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sappend
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sconcat
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Svconcat
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scopy_sequence
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubstring
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snthcdr
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snth
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Selt
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smemq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sassq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sassoc
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srassq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snreverse
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sreverse
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssort
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sput
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sequal
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfillarray
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snconc
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smapcar
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smapconcat
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sy_or_n_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Syes_or_no_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sload_average
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfeaturep
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srequire
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprovide
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

