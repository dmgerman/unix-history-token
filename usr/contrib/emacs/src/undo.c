begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for the undo facility.    Copyright (C) 1985 Fen Labalme and Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"undo.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_comment
comment|/* Access undo records of current buffer */
end_comment

begin_comment
comment|/* These assume that `u' points to the buffer's undodata */
end_comment

begin_define
define|#
directive|define
name|UndoRQ
value|(u->undorecs)
end_define

begin_define
define|#
directive|define
name|UndoCQ
value|(u->undochars)
end_define

begin_define
define|#
directive|define
name|FillRQ
value|(u->nextrec)
end_define

begin_define
define|#
directive|define
name|FillCQ
value|(u->nextchar)
end_define

begin_comment
comment|/* Record last undo record made, and what buffer made in */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|UndoRec
modifier|*
name|LastUndoRec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|LastUndoBuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record progress of undoing */
end_comment

begin_expr_stmt
specifier|static
name|NUndone
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|NCharsLeft
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LastUndoneC
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LastUndone
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|LastUndoneBuf
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|Fundo_boundary
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|make_undo_records
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|UndoData
modifier|*
name|u
decl_stmt|;
name|b
operator|->
name|undodata
operator|=
name|u
operator|=
operator|(
expr|struct
name|UndoData
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|UndoData
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|->
name|undorecs
operator|=
operator|(
expr|struct
name|UndoRec
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|UndoRec
argument_list|)
operator|*
name|InitNUndoR
argument_list|)
expr_stmt|;
name|u
operator|->
name|undochars
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|InitNUndoC
argument_list|)
expr_stmt|;
name|u
operator|->
name|undorecs
index|[
name|InitNUndoR
operator|-
literal|1
index|]
operator|.
name|kind
operator|=
name|Unundoable
expr_stmt|;
name|u
operator|->
name|nextrec
operator|=
literal|0
expr_stmt|;
name|u
operator|->
name|nextchar
operator|=
literal|0
expr_stmt|;
name|u
operator|->
name|num_undorecs
operator|=
name|InitNUndoR
expr_stmt|;
name|u
operator|->
name|num_undochars
operator|=
name|InitNUndoC
expr_stmt|;
block|}
end_block

begin_macro
name|free_undo_records
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|UndoData
modifier|*
name|u
init|=
name|b
operator|->
name|undodata
decl_stmt|;
name|free
argument_list|(
name|u
operator|->
name|undorecs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|u
operator|->
name|undochars
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|struct
name|UndoRec
modifier|*
name|NewUndo
parameter_list|(
name|kind
parameter_list|,
name|pos
parameter_list|,
name|len
parameter_list|)
name|enum
name|Ukinds
name|kind
decl_stmt|;
block|{
specifier|register
name|struct
name|UndoData
modifier|*
name|u
init|=
name|bf_cur
operator|->
name|undodata
decl_stmt|;
specifier|register
name|struct
name|UndoRec
modifier|*
name|p
init|=
operator|&
name|UndoRQ
index|[
name|FillRQ
index|]
decl_stmt|;
specifier|register
name|struct
name|UndoRec
modifier|*
name|np
decl_stmt|;
name|FillRQ
operator|++
expr_stmt|;
if|if
condition|(
name|FillRQ
operator|>=
name|NUndoR
condition|)
name|FillRQ
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|FillRQ
operator|>=
name|u
operator|->
name|num_undorecs
condition|)
block|{
name|np
operator|=
operator|(
expr|struct
name|UndoRec
operator|*
operator|)
name|xrealloc
argument_list|(
name|UndoRQ
argument_list|,
name|NUndoR
operator|*
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|UndoRQ
operator|=
name|np
expr_stmt|;
name|p
operator|=
operator|&
name|UndoRQ
index|[
name|FillRQ
operator|-
literal|1
index|]
expr_stmt|;
name|u
operator|->
name|num_undorecs
operator|=
name|NUndoR
expr_stmt|;
name|np
index|[
name|NUndoR
operator|-
literal|1
index|]
operator|.
name|kind
operator|=
name|Unundoable
expr_stmt|;
block|}
else|else
name|FillRQ
operator|=
literal|0
expr_stmt|;
block|}
name|UndoRQ
index|[
name|FillRQ
index|]
operator|.
name|kind
operator|=
name|Unundoable
expr_stmt|;
name|p
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|p
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|LastUndoRec
operator|=
name|p
expr_stmt|;
name|LastUndoBuf
operator|=
name|bf_cur
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|Uboundary
condition|)
name|LastUndone
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_macro
name|RecordInsert
argument_list|(
argument|pos
argument_list|,
argument|n
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|UndoRec
modifier|*
name|p
init|=
name|LastUndoRec
decl_stmt|;
if|if
condition|(
operator|!
name|bf_cur
operator|->
name|undodata
condition|)
return|return;
if|if
condition|(
name|LastUndoBuf
operator|!=
name|bf_cur
condition|)
block|{
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bf_modified
operator|<=
name|bf_cur
operator|->
name|save_modified
condition|)
name|NewUndo
argument_list|(
name|Uunmod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|kind
operator|==
name|Udelete
operator|&&
name|p
operator|->
name|pos
operator|+
name|p
operator|->
name|len
operator|==
name|pos
condition|)
name|p
operator|->
name|len
operator|+=
name|n
expr_stmt|;
else|else
name|NewUndo
argument_list|(
name|Udelete
argument_list|,
name|pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|RecordDelete
argument_list|(
argument|pos
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pos
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|UndoRec
modifier|*
name|p
init|=
name|LastUndoRec
decl_stmt|;
if|if
condition|(
operator|!
name|bf_cur
operator|->
name|undodata
condition|)
return|return;
if|if
condition|(
name|LastUndoBuf
operator|!=
name|bf_cur
condition|)
block|{
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bf_modified
operator|<=
name|bf_cur
operator|->
name|save_modified
condition|)
name|NewUndo
argument_list|(
name|Uunmod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|kind
operator|==
name|Uinsert
operator|&&
name|p
operator|->
name|pos
operator|==
name|pos
condition|)
name|p
operator|->
name|len
operator|+=
name|n
expr_stmt|;
else|else
name|NewUndo
argument_list|(
name|Uinsert
argument_list|,
name|pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|record_chars
argument_list|(
name|pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|record_chars
argument_list|(
name|pos
argument_list|,
name|n
argument_list|)
specifier|register
name|int
name|pos
operator|,
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|pos
operator|<
name|bf_s1
operator|+
literal|1
operator|&&
name|pos
operator|+
name|n
operator|>
name|bf_s1
operator|+
literal|1
condition|)
block|{
name|record_block
argument_list|(
operator|&
name|CharAt
argument_list|(
name|pos
argument_list|)
argument_list|,
name|bf_s1
operator|+
literal|1
operator|-
name|pos
argument_list|)
expr_stmt|;
name|n
operator|-=
name|bf_s1
operator|+
literal|1
operator|-
name|pos
expr_stmt|;
name|pos
operator|=
name|bf_s1
operator|+
literal|1
expr_stmt|;
block|}
name|record_block
argument_list|(
operator|&
name|CharAt
argument_list|(
name|pos
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|record_block
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|UndoData
modifier|*
name|u
init|=
name|bf_cur
operator|->
name|undodata
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|NCharsLeft
operator|-=
name|n
expr_stmt|;
name|cp
operator|=
operator|&
name|UndoCQ
index|[
name|FillCQ
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|u
operator|->
name|num_undochars
operator|-
name|FillCQ
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
condition|)
name|i
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|p
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
name|cp
operator|+=
name|i
expr_stmt|;
name|FillCQ
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|FillCQ
operator|>=
name|NUndoC
condition|)
block|{
name|FillCQ
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|UndoCQ
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|UndoCQ
argument_list|,
name|NUndoC
argument_list|)
expr_stmt|;
name|UndoCQ
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|FillCQ
expr_stmt|;
name|NCharsLeft
operator|+=
name|NUndoC
operator|-
name|u
operator|->
name|num_undochars
expr_stmt|;
name|u
operator|->
name|num_undochars
operator|=
name|NUndoC
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|RecordChange
argument_list|(
argument|pos
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pos
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|UndoRec
modifier|*
name|p
init|=
name|LastUndoRec
decl_stmt|;
if|if
condition|(
operator|!
name|bf_cur
operator|->
name|undodata
condition|)
return|return;
if|if
condition|(
name|LastUndoBuf
operator|!=
name|bf_cur
condition|)
block|{
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bf_modified
operator|<=
name|bf_cur
operator|->
name|save_modified
condition|)
name|NewUndo
argument_list|(
name|Uunmod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|kind
operator|==
name|Uchange
operator|&&
name|p
operator|->
name|pos
operator|+
name|p
operator|->
name|len
operator|==
name|pos
condition|)
name|p
operator|->
name|len
operator|+=
name|n
expr_stmt|;
else|else
name|NewUndo
argument_list|(
name|Uchange
argument_list|,
name|pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|record_chars
argument_list|(
name|pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|RecordChange1
argument_list|(
argument|pos
argument_list|,
argument|bufp
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|UndoRec
modifier|*
name|p
init|=
name|LastUndoRec
decl_stmt|;
if|if
condition|(
operator|!
name|bf_cur
operator|->
name|undodata
condition|)
return|return;
if|if
condition|(
name|LastUndoBuf
operator|!=
name|bf_cur
condition|)
block|{
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|kind
operator|==
name|Uchange
operator|&&
name|p
operator|->
name|pos
operator|+
name|p
operator|->
name|len
operator|==
name|pos
condition|)
name|p
operator|->
name|len
operator|+=
name|n
expr_stmt|;
else|else
name|NewUndo
argument_list|(
name|Uchange
argument_list|,
name|pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|record_block
argument_list|(
name|bufp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DoneIsDone
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|UndoData
modifier|*
name|u
init|=
name|bf_cur
operator|->
name|undodata
decl_stmt|;
specifier|register
name|struct
name|UndoRec
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|&
name|UndoRQ
index|[
operator|(
name|FillRQ
operator|+
name|u
operator|->
name|num_undorecs
operator|-
literal|1
operator|)
operator|%
name|u
operator|->
name|num_undorecs
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|kind
operator|!=
name|Unundoable
condition|)
name|NewUndo
argument_list|(
name|Unundoable
argument_list|,
name|point
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"undo-boundary"
argument_list|,
argument|Fundo_boundary
argument_list|,
argument|Sundo_boundary
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Mark a boundary between units of undo.\n\ An undo command will stop at this point,\n\ but another undo command will undo to the previous boundary."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
expr|struct
name|UndoData
operator|*
name|u
operator|=
name|bf_cur
operator|->
name|undodata
block|;
specifier|register
expr|struct
name|UndoRec
operator|*
name|p
block|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
name|Qnil
return|;
name|p
operator|=
operator|&
name|UndoRQ
index|[
operator|(
name|FillRQ
operator|+
name|u
operator|->
name|num_undorecs
operator|-
literal|1
operator|)
operator|%
name|u
operator|->
name|num_undorecs
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|p
operator|->
name|kind
operator|!=
name|Uboundary
condition|)
name|NewUndo
argument_list|(
name|Uboundary
argument_list|,
name|point
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"undo-more"
operator|,
name|Fundo_more
operator|,
name|Sundo_more
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Undo back N undo-boundaries beyond what was already undone recently.\n\ Call undo-start to get ready to undo recent changes,\n\ then call undo-more one or more times to undo them."
operator|)
operator|(
name|pfxarg
operator|)
name|Lisp_Object
name|pfxarg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|UndoData
modifier|*
name|u
init|=
name|bf_cur
operator|->
name|undodata
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|chars
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|LastUndone
decl_stmt|;
specifier|register
name|int
name|arg
init|=
name|XINT
argument_list|(
name|pfxarg
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|pos
decl_stmt|;
name|char
name|tembuf
index|[
name|NUndoC
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|LastUndoneBuf
operator|!=
name|bf_cur
operator|||
name|i
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot undo more: changes have been made since the last undo"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|UndoRQ
index|[
name|i
operator|=
operator|(
operator|!
name|i
condition|?
name|u
operator|->
name|num_undorecs
operator|-
literal|1
else|:
name|i
operator|-
literal|1
operator|)
index|]
operator|.
name|kind
operator|!=
name|Uboundary
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|UndoRQ
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|Uinsert
operator|||
name|UndoRQ
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|Uchange
operator|)
operator|&&
operator|(
name|NCharsLeft
operator|-=
name|UndoRQ
index|[
name|i
index|]
operator|.
name|len
operator|)
operator|<
literal|0
operator|)
operator|||
name|UndoRQ
index|[
name|i
index|]
operator|.
name|kind
operator|==
name|Unundoable
operator|||
name|NUndone
operator|>=
name|u
operator|->
name|num_undorecs
condition|)
name|error
argument_list|(
literal|"No further undo information available"
argument_list|)
expr_stmt|;
name|NUndone
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|NUndone
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|arg
operator|<=
literal|0
condition|)
break|break;
block|}
name|i
operator|=
name|LastUndone
expr_stmt|;
name|chars
operator|=
name|LastUndoneC
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|i
condition|)
name|i
operator|=
name|u
operator|->
name|num_undorecs
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|len
operator|=
name|UndoRQ
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|pos
operator|=
name|UndoRQ
index|[
name|i
index|]
operator|.
name|pos
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|UndoRQ
index|[
name|i
index|]
operator|.
name|kind
condition|)
else|#
directive|else
switch|switch
condition|(
name|UndoRQ
index|[
name|i
index|]
operator|.
name|kind
condition|)
endif|#
directive|endif
block|{
case|case
name|Uboundary
case|:
break|break;
case|case
name|Udelete
case|:
if|if
condition|(
name|pos
operator|<
name|FirstCharacter
operator|||
name|pos
operator|+
name|len
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|error
argument_list|(
literal|"Changes to be undone are outside visible portion of buffer"
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|del_range
argument_list|(
name|point
argument_list|,
name|point
operator|+
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|Uchange
case|:
if|if
condition|(
name|pos
operator|<
name|FirstCharacter
operator|||
name|pos
operator|+
name|len
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|error
argument_list|(
literal|"Changes to be undone are outside visible portion of buffer"
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NUndoC
condition|)
comment|/* Should have already said "No more undo info available" */
name|abort
argument_list|()
expr_stmt|;
name|save_undone_chars
argument_list|(
name|pos
argument_list|,
name|len
argument_list|,
name|tembuf
argument_list|)
expr_stmt|;
name|chars
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|chars
operator|<
literal|0
condition|)
block|{
name|replace_chars
argument_list|(
name|point
operator|-
name|chars
argument_list|,
name|len
operator|+
name|chars
argument_list|,
name|UndoCQ
argument_list|)
expr_stmt|;
name|replace_chars
argument_list|(
name|point
argument_list|,
operator|-
name|chars
argument_list|,
name|UndoCQ
operator|+
name|chars
operator|+
name|u
operator|->
name|num_undochars
argument_list|)
expr_stmt|;
name|chars
operator|+=
name|u
operator|->
name|num_undochars
expr_stmt|;
block|}
else|else
name|replace_chars
argument_list|(
name|point
argument_list|,
name|len
argument_list|,
name|UndoCQ
operator|+
name|chars
argument_list|)
expr_stmt|;
name|RecordChange1
argument_list|(
name|point
argument_list|,
name|tembuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|Uinsert
case|:
if|if
condition|(
name|pos
operator|<
name|FirstCharacter
operator|||
name|pos
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|error
argument_list|(
literal|"Changes to be undone are outside visible portion of buffer"
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|chars
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|chars
operator|<
literal|0
condition|)
block|{
name|InsCStr
argument_list|(
name|UndoCQ
operator|+
name|chars
operator|+
name|u
operator|->
name|num_undochars
argument_list|,
operator|-
name|chars
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|UndoCQ
argument_list|,
name|len
operator|+
name|chars
argument_list|)
expr_stmt|;
name|chars
operator|+=
name|u
operator|->
name|num_undochars
expr_stmt|;
block|}
else|else
name|InsCStr
argument_list|(
name|UndoCQ
operator|+
name|chars
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
name|Uunmod
case|:
ifdef|#
directive|ifdef
name|CLASH_DETECTION
name|Funlock_buffer
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|bf_cur
operator|->
name|save_modified
operator|=
name|bf_modified
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Something rotten in undo"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
block|}
name|LastUndone
operator|=
name|i
expr_stmt|;
name|LastUndoneC
operator|=
name|chars
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|replace_chars
argument_list|(
name|pos
argument_list|,
name|n
argument_list|,
name|string
argument_list|)
specifier|register
name|int
name|pos
operator|,
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|modify_region
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|=
operator|*
name|string
operator|++
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|save_undone_chars
argument_list|(
name|pos
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
specifier|register
name|int
name|pos
operator|,
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pos
operator|<
name|bf_s1
operator|+
literal|1
operator|&&
name|pos
operator|+
name|n
operator|>
name|bf_s1
operator|+
literal|1
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|CharAt
argument_list|(
name|pos
argument_list|)
argument_list|,
name|p
argument_list|,
name|bf_s1
operator|+
literal|1
operator|-
name|pos
argument_list|)
expr_stmt|;
name|p
operator|+=
name|bf_s1
operator|+
literal|1
operator|-
name|pos
expr_stmt|;
name|n
operator|-=
name|bf_s1
operator|+
literal|1
operator|-
name|pos
expr_stmt|;
name|pos
operator|=
name|bf_s1
operator|+
literal|1
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
name|CharAt
argument_list|(
name|pos
argument_list|)
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"undo-start"
argument_list|,
argument|Fundo_start
argument_list|,
argument|Sundo_start
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Move undo-pointer to front of undo records.\n\ The next call to undo-more will undo the most recently made change."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
expr|struct
name|UndoData
operator|*
name|u
operator|=
name|bf_cur
operator|->
name|undodata
block|;
if|if
condition|(
operator|!
name|u
condition|)
name|error
argument_list|(
literal|"Undo information not kept for this buffer"
argument_list|)
expr_stmt|;
name|LastUndoneBuf
operator|=
name|bf_cur
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NCharsLeft
operator|=
name|u
operator|->
name|num_undochars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NUndone
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LastUndone
operator|=
name|FillRQ
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LastUndoneC
operator|=
name|FillCQ
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  syms_of_undo
operator|(
operator|)
block|{
name|defsubr
argument_list|(
operator|&
name|Sundo_start
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sundo_boundary
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sundo_more
argument_list|)
block|; }
end_expr_stmt

end_unit

