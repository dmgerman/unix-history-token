begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Buffer manipulation primitives for GNU Emacs.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_comment
comment|/* in 4.1, param.h fails to define this. */
end_comment

begin_define
define|#
directive|define
name|MAXPATHLEN
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MAXPATHLEN */
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|bf_cur
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current buffer */
end_comment

begin_comment
comment|/* This structure contains data describing the text of the current buffer.  Switching buffers swaps their text data in and out of here */
end_comment

begin_decl_stmt
name|struct
name|buffer_text
name|bf_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First buffer in chain of all buffers (in reverse order of creation).    Threaded through ->next.  */
end_comment

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|all_buffers
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|Fset_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Alist of all buffer names vs the buffers. */
end_comment

begin_comment
comment|/* This used to be a variable, but is no longer,  to prevent lossage due to user rplac'ing this alist or its elements.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vbuffer_alist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to install major mode.   nil means use the major mode of the selected buffer.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vdefault_major_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qfundamental_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|QSFundamental
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A string "Fundamental" */
end_comment

begin_comment
comment|/* For debugging; temporary.  See SetBfp.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qlisp_mode
decl_stmt|,
name|Vcheck_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vdefault_mode_line_format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_case_fold_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_tab_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_ctl_arrow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_truncate_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_fill_column
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|default_left_margin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vdefault_abbrev_mode
decl_stmt|;
end_decl_stmt

begin_macro
name|nsberror
argument_list|(
argument|spec
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|spec
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|spec
argument_list|)
operator|==
name|Lisp_String
condition|)
name|error
argument_list|(
literal|"No buffer named %s"
argument_list|,
name|XSTRING
argument_list|(
name|spec
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid buffer argument"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-list"
argument_list|,
argument|Fbuffer_list
argument_list|,
argument|Sbuffer_list
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a list of all buffers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Fmapcar
argument_list|(
name|Qcdr
argument_list|,
name|Vbuffer_alist
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"get-buffer"
argument_list|,
argument|Fget_buffer
argument_list|,
argument|Sget_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer named NAME (a string).\n\ It is found by looking up NAME in  buffer-alist.\n\ If there is no buffer named NAME, nil is returned.\n\ NAME may also be a buffer; it is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|)
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|name
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
return|return
name|name
return|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|Fcdr
argument_list|(
name|Fassoc
argument_list|(
name|name
argument_list|,
name|Vbuffer_alist
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"get-file-buffer"
argument_list|,
argument|Fget_file_buffer
argument_list|,
argument|Sget_file_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer visiting file FILENAME (a string).\n\ If there is no such buffer, nil is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|,
name|tem
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
name|LISTP
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|buf
operator|=
name|Fcdr
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|buf
argument_list|)
operator|!=
name|Lisp_Buffer
condition|)
continue|continue;
if|if
condition|(
name|XTYPE
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|filename
argument_list|)
operator|!=
name|Lisp_String
condition|)
continue|continue;
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|buf
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Incremented for each buffer created, to assign the buffer number. */
end_comment

begin_decl_stmt
name|int
name|buffer_count
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"get-buffer-create"
argument_list|,
argument|Fget_buffer_create
argument_list|,
argument|Sget_buffer_create
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Like get-buffer but creates a buffer named NAME and returns it if none already exists."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|)
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|buf
decl_stmt|,
name|function
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
name|struct
name|buffer
modifier|*
name|bx
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|buf
return|;
name|b
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|b
operator|->
name|text
operator|.
name|gap
operator|=
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|b
operator|->
name|text
operator|.
name|p1
operator|=
name|data
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|text
operator|.
name|p2
operator|=
name|data
operator|-
literal|1
operator|+
name|b
operator|->
name|text
operator|.
name|gap
expr_stmt|;
name|b
operator|->
name|text
operator|.
name|size1
operator|=
name|b
operator|->
name|text
operator|.
name|size2
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|text
operator|.
name|modified
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|text
operator|.
name|pointloc
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|text
operator|.
name|head_clip
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|text
operator|.
name|tail_clip
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|next
operator|=
name|all_buffers
expr_stmt|;
name|all_buffers
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|save_length
operator|=
name|make_number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|b
operator|->
name|last_window_start
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|markers
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|mark
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|number
operator|=
name|make_number
argument_list|(
operator|++
name|buffer_count
argument_list|)
expr_stmt|;
name|b
operator|->
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
name|make_undo_records
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|undodata
operator|=
literal|0
expr_stmt|;
name|reset_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|)
expr_stmt|;
name|bx
operator|=
name|b
expr_stmt|;
comment|/* Use of bx avoids compiler bug on Sun */
name|XSETBUFFER
argument_list|(
name|buf
argument_list|,
name|bx
argument_list|)
expr_stmt|;
name|Vbuffer_alist
operator|=
name|nconc2
argument_list|(
name|Vbuffer_alist
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|name
argument_list|,
name|buf
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|function
operator|=
name|Vdefault_major_mode
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|function
argument_list|)
condition|)
name|function
operator|=
name|bf_cur
operator|->
name|major_mode
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|function
argument_list|)
operator|||
name|EQ
argument_list|(
name|function
argument_list|,
name|Qfundamental_mode
argument_list|)
condition|)
return|return
name|buf
return|;
comment|/* To select a nonfundamental mode,      select the buffer temporarily and then call the mode function. */
name|record_unwind_protect
argument_list|(
name|save_excursion_restore
argument_list|,
name|save_excursion_save
argument_list|()
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Fapply
argument_list|(
name|function
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_function
name|void
name|reset_buffer
parameter_list|(
name|b
parameter_list|)
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
block|{
name|b
operator|->
name|filename
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|directory
operator|=
operator|(
name|bf_cur
operator|)
condition|?
name|bf_cur
operator|->
name|directory
else|:
name|Qnil
expr_stmt|;
name|b
operator|->
name|modtime
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|save_modified
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|backed_up
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|Qnil
expr_stmt|;
name|b
operator|->
name|auto_save_modified
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|auto_save_file_name
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|reset_buffer_local_variables
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|reset_buffer_local_variables
argument_list|(
name|b
argument_list|)
specifier|register
expr|struct
name|buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|b
operator|->
name|keymap
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|abbrev_table
operator|=
name|Vfundamental_mode_abbrev_table
expr_stmt|;
name|b
operator|->
name|tab_width
operator|=
name|make_number
argument_list|(
name|default_tab_width
argument_list|)
expr_stmt|;
name|b
operator|->
name|fill_column
operator|=
name|make_number
argument_list|(
name|default_fill_column
argument_list|)
expr_stmt|;
name|b
operator|->
name|left_margin
operator|=
name|make_number
argument_list|(
name|default_left_margin
argument_list|)
expr_stmt|;
name|b
operator|->
name|case_fold_search
operator|=
name|default_case_fold_search
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
name|b
operator|->
name|syntax_table_v
operator|=
name|XVECTOR
argument_list|(
name|Vstandard_syntax_table
argument_list|)
expr_stmt|;
name|b
operator|->
name|mode_line_format
operator|=
name|Vdefault_mode_line_format
expr_stmt|;
name|b
operator|->
name|auto_fill_hook
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|local_var_alist
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|ctl_arrow
operator|=
name|default_ctl_arrow
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
name|b
operator|->
name|truncate_lines
operator|=
name|default_truncate_lines
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
name|b
operator|->
name|selective_display
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|overwrite_mode
operator|=
name|Qnil
expr_stmt|;
name|b
operator|->
name|abbrev_mode
operator|=
name|Vdefault_abbrev_mode
expr_stmt|;
name|b
operator|->
name|major_mode
operator|=
name|Qfundamental_mode
expr_stmt|;
name|b
operator|->
name|mode_name
operator|=
name|QSFundamental
expr_stmt|;
name|b
operator|->
name|minor_modes
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

begin_comment
comment|/* create-file-buffer moved into lisp code in lisp/files.el */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"generate-new-buffer"
argument_list|,
argument|Fgenerate_new_buffer
argument_list|,
argument|Sgenerate_new_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Creates and returns a buffer named NAME if one does not already exist,\n\ else tries adding successive suffixes to NAME until a new buffer-name is\n\ formed, then creates and returns a new buffer with that new name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|)
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|gentemp
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
name|number
index|[
literal|10
index|]
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Fget_buffer_create
argument_list|(
name|name
argument_list|)
return|;
name|count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|number
argument_list|,
literal|"<%d>"
argument_list|,
operator|++
name|count
argument_list|)
expr_stmt|;
name|gentemp
operator|=
name|concat2
argument_list|(
name|name
argument_list|,
name|build_string
argument_list|(
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fget_buffer
argument_list|(
name|gentemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Fget_buffer_create
argument_list|(
name|gentemp
argument_list|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-name"
argument_list|,
argument|Fbuffer_name
argument_list|,
argument|Sbuffer_name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the name of BUFFER, as a string.\n\ No arg means return name of current buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|bf_cur
operator|->
name|name
return|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-number"
argument_list|,
argument|Fbuffer_number
argument_list|,
argument|Sbuffer_number
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the number of BUFFER.\n\ No arg means return number of current buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|bf_cur
operator|->
name|number
return|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|number
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-file-name"
argument_list|,
argument|Fbuffer_file_name
argument_list|,
argument|Sbuffer_file_name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return name of file BUFFER is visiting, or NIL if none.\n\ No argument means use current buffer as BUFFER."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|bf_cur
operator|->
name|filename
return|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|filename
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-local-variables"
argument_list|,
argument|Fbuffer_local_variables
argument_list|,
argument|Sbuffer_local_variables
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return alist of buffer-local variables of BUFFER.\n\ Each element looks like (SYMBOL . VALUE).\n\ No argument means use current buffer as BUFFER."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|bf_cur
operator|->
name|local_var_alist
return|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|local_var_alist
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-modified-p"
argument_list|,
argument|Fbuffer_modified_p
argument_list|,
argument|Sbuffer_modified_p
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if BUFFER is modified since file last read in or saved.\n\ No argument means use current buffer as BUFFER."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|buf
operator|=
name|bf_cur
expr_stmt|;
else|else
block|{
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|bf_cur
operator|->
name|text
operator|.
name|modified
operator|=
name|bf_modified
expr_stmt|;
return|return
name|buf
operator|->
name|save_modified
operator|<
name|buf
operator|->
name|text
operator|.
name|modified
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-buffer-modified-p"
argument_list|,
argument|Fset_buffer_modified_p
argument_list|,
argument|Sset_buffer_modified_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Mark current buffer as modified or unmodified according to FLAG."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|flag
operator|)
name|Lisp_Object
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|already
decl_stmt|;
specifier|register
name|Lisp_Object
name|fn
decl_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
comment|/* If buffer becoming modified, lock the file.      If buffer becoming unmodified, unlock the file.  */
name|fn
operator|=
name|bf_cur
operator|->
name|filename
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|already
operator|=
name|bf_cur
operator|->
name|save_modified
operator|<
name|bf_modified
expr_stmt|;
if|if
condition|(
operator|!
name|already
operator|&&
operator|!
name|NULL
argument_list|(
name|flag
argument_list|)
condition|)
name|lock_file
argument_list|(
name|fn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|already
operator|&&
name|NULL
argument_list|(
name|flag
argument_list|)
condition|)
name|unlock_file
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CLASH_DETECTION */
name|bf_cur
operator|->
name|save_modified
operator|=
name|NULL
argument_list|(
name|flag
argument_list|)
condition|?
name|bf_modified
else|:
literal|0
expr_stmt|;
name|RedoModes
operator|++
expr_stmt|;
return|return
name|flag
return|;
block|}
end_block

begin_comment
comment|/* Return number of modified buffers that exist now. */
end_comment

begin_function
name|int
name|ModExist
parameter_list|()
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|modcount
init|=
literal|0
decl_stmt|;
name|bf_cur
operator|->
name|text
operator|.
name|modified
operator|=
name|bf_modified
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|buf
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|b
operator|->
name|filename
argument_list|)
operator|&&
name|b
operator|->
name|save_modified
operator|<
name|b
operator|->
name|text
operator|.
name|modified
condition|)
name|modcount
operator|++
expr_stmt|;
block|}
return|return
name|modcount
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"rename-buffer"
argument_list|,
argument|Frename_buffer
argument_list|,
argument|Srename_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sRename buffer (to new name): "
argument_list|,
literal|"Change current buffer's name to NEWNAME (a string)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|)
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|,
name|buf
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fget_buffer
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|error
argument_list|(
literal|"Buffer \"%s\" already exists"
argument_list|,
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|bf_cur
argument_list|)
expr_stmt|;
return|return
name|Fsetcar
argument_list|(
name|Frassq
argument_list|(
name|buf
argument_list|,
name|Vbuffer_alist
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"other-buffer"
argument_list|,
argument|Fother_buffer
argument_list|,
argument|Sother_buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return most recently selected buffer other than BUFFER.\n\ Buffers not visible in windows are preferred to visible buffers.\n\ If no other exists, the buffer *scratch* is returned.\n\ If BUFFER is omitted or nil, some interesting buffer is returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|,
name|notsogood
decl_stmt|,
name|tem
decl_stmt|;
name|notsogood
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|buf
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|buf
argument_list|,
name|buffer
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|XSTRING
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|name
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
continue|continue;
name|tem
operator|=
name|Fget_buffer_window
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|buf
return|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|notsogood
argument_list|)
condition|)
name|notsogood
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|notsogood
argument_list|)
condition|)
return|return
name|notsogood
return|;
return|return
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-flush-undo"
argument_list|,
argument|Fbuffer_flush_undo
argument_list|,
argument|Sbuffer_flush_undo
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make BUFFER stop keeping undo information."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buf
operator|)
name|Lisp_Object
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_BUFFER
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|undodata
condition|)
name|free_undo_records
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|undodata
operator|=
literal|0
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|Fdelete_buffer_internal
parameter_list|(
name|buf
parameter_list|)
name|Lisp_Object
name|buf
decl_stmt|;
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|b
init|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|b
operator|->
name|name
argument_list|)
condition|)
return|return
name|Qnil
return|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
comment|/* Unlock this buffer's file, if it is locked.  */
name|Funlock_buffer
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
comment|/* make this buffer not be current */
if|if
condition|(
name|b
operator|==
name|bf_cur
condition|)
block|{
name|tem
operator|=
name|Fother_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|subprocesses
name|kill_buffer_processes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|subprocesses
name|Vbuffer_alist
operator|=
name|Fdelq
argument_list|(
name|Frassq
argument_list|(
name|buf
argument_list|,
name|Vbuffer_alist
argument_list|)
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|Freplace_buffer_in_windows
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Unchain all markers of this buffer      and leave them pointing nowhere.  */
for|for
control|(
name|tem
operator|=
name|b
operator|->
name|markers
init|;
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
condition|;
control|)
block|{
name|m
operator|=
name|XMARKER
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|m
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|m
operator|->
name|chain
expr_stmt|;
name|m
operator|->
name|chain
operator|=
name|Qnil
expr_stmt|;
block|}
name|b
operator|->
name|name
operator|=
name|Qnil
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|text
operator|.
name|p1
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|undodata
condition|)
name|free_undo_records
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"kill-buffer"
argument_list|,
argument|Fkill_buffer
argument_list|,
argument|Skill_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"bKill buffer: "
argument_list|,
literal|"One arg, a string or a buffer.  Get rid of the specified buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bufname
operator|)
name|Lisp_Object
name|bufname
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|,
name|answer
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bufname
argument_list|)
condition|)
name|buf
operator|=
name|Fcurrent_buffer
argument_list|()
expr_stmt|;
else|else
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
condition|)
name|nsberror
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|bufname
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|name
expr_stmt|;
name|bf_cur
operator|->
name|text
operator|.
name|modified
operator|=
name|bf_modified
expr_stmt|;
if|if
condition|(
name|INTERACTIVE
operator|&&
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|filename
argument_list|)
operator|&&
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|modified
operator|>
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|save_modified
condition|)
block|{
name|answer
operator|=
name|Fyes_or_no_p
argument_list|(
name|format1
argument_list|(
literal|"Buffer %s modified; kill anyway? "
argument_list|,
name|XSTRING
argument_list|(
name|bufname
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|answer
argument_list|)
condition|)
return|return
name|Qnil
return|;
block|}
name|Fdelete_buffer_internal
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Put the element for buffer `buf' at the front of buffer-alist.  This is done when a buffer is selected "visibly".  It keeps buffer-alist in the order of recency of selection  so that other_buffer will return something nice.  */
end_comment

begin_macro
name|record_buffer
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|aelt
decl_stmt|,
name|link
decl_stmt|;
name|aelt
operator|=
name|Frassq
argument_list|(
name|buf
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|link
operator|=
name|Fmemq
argument_list|(
name|aelt
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|link
argument_list|)
operator|->
name|cdr
operator|=
name|Fdelq
argument_list|(
name|aelt
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|Vbuffer_alist
operator|=
name|link
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"switch-to-buffer"
argument_list|,
argument|Fswitch_to_buffer
argument_list|,
argument|Sswitch_to_buffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"BSwitch to buffer: "
argument_list|,
literal|"One arg, a string or buffer.  Select the specified buffer\n\ in the current window.  Optional arg NORECORD non-nil means\n\ do not put this buffer at the front of the list of recently selected ones."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bufname
operator|,
name|norecord
operator|)
name|Lisp_Object
name|bufname
operator|,
name|norecord
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bufname
argument_list|)
condition|)
name|buf
operator|=
name|Fother_buffer
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|Fget_buffer_create
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|norecord
argument_list|)
condition|)
name|record_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
condition|?
name|Fnext_window
argument_list|(
name|minibuf_window
argument_list|,
name|Qnil
argument_list|)
else|:
name|selected_window
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"pop-to-buffer"
argument_list|,
argument|Fpop_to_buffer
argument_list|,
argument|Spop_to_buffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Select buffer BUFFER in some window, preferably a different one.\n\ If  pop-up-windows  is non-nil, windows can be split to do this.\n\ If second arg  OTHER-WINDOW is non-nil, insist on finding another\n\ window even if BUFFER is already visible in the selected window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bufname
operator|,
name|other
operator|)
name|Lisp_Object
name|bufname
operator|,
name|other
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bufname
argument_list|)
condition|)
name|buf
operator|=
name|Fother_buffer
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|Fget_buffer_create
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|record_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Fselect_window
argument_list|(
name|Fdisplay_buffer
argument_list|(
name|buf
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"current-buffer"
argument_list|,
argument|Fcurrent_buffer
argument_list|,
argument|Scurrent_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the current buffer as a Lisp buffer object."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|buf
block|;
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|bf_cur
argument_list|)
block|;
return|return
name|buf
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"set-buffer"
argument_list|,
argument|Fset_buffer
argument_list|,
argument|Sset_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set the current buffer to the buffer or buffer name supplied as argument.\n\ That buffer will then be the default for editing operations and printing.\n\ This function's effect can't last past end of current command\n\ because returning to command level\n\ selects the chosen buffer of the current window,\n\ and this function has no effect on what buffer that is.\n\ Use  switch-to-buffer  or  pop-to-buffer  for interactive buffer selection."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|bufname
operator|)
name|Lisp_Object
name|bufname
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buffer
decl_stmt|;
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|nsberror
argument_list|(
name|bufname
argument_list|)
expr_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"barf-if-buffer-read-only"
argument_list|,
argument|Fbarf_if_buffer_read_only
argument_list|,
argument|Sbarf_if_buffer_read_only
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Signal a  buffer-read-only  error if the current buffer is read-only."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|)
name|Fsignal
argument_list|(
name|Qbuffer_read_only
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"bury-buffer"
operator|,
name|Fbury_buffer
operator|,
name|Sbury_buffer
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Put BUFFER at the end of the list of all buffers.\n\ There it is the least likely candidate for other-buffer to return;\n\ thus, the least likely buffer for \\[switch-to-buffer] to select by default."
operator|)
operator|(
name|buf
operator|)
name|Lisp_Object
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|aelt
decl_stmt|,
name|link
decl_stmt|;
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|aelt
operator|=
name|Frassq
argument_list|(
name|buf
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|link
operator|=
name|Fmemq
argument_list|(
name|aelt
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|Vbuffer_alist
operator|=
name|Fdelq
argument_list|(
name|aelt
argument_list|,
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|link
argument_list|)
operator|->
name|cdr
operator|=
name|Qnil
expr_stmt|;
name|Vbuffer_alist
operator|=
name|nconc2
argument_list|(
name|Vbuffer_alist
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|last_known_column_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set the current buffer to p */
end_comment

begin_expr_stmt
name|SetBfp
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|buffer
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|c
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|swb
decl_stmt|;
name|Lisp_Object
name|tail
decl_stmt|,
name|valcontents
decl_stmt|;
name|enum
name|Lisp_Type
name|tem
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|p
condition|)
return|return;
if|if
condition|(
name|w
condition|)
name|swb
operator|=
name|NULL
argument_list|(
name|selected_window
argument_list|)
condition|?
literal|0
else|:
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|NULL
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Selecting deleted buffer"
argument_list|)
expr_stmt|;
name|windows_or_buffers_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|swb
condition|)
name|Fset_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|FirstCharacter
operator|||
name|point
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|c
operator|->
name|text
operator|=
name|bf_text
expr_stmt|;
block|}
name|bf_cur
operator|=
name|p
expr_stmt|;
name|bf_text
operator|=
name|p
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|swb
condition|)
block|{
name|SetPoint
argument_list|(
name|marker_position
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|FirstCharacter
condition|)
name|point
operator|=
name|FirstCharacter
expr_stmt|;
if|if
condition|(
name|point
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|point
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
block|}
name|last_known_column_point
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* invalidate indentation cache */
comment|/* Vcheck_symbol is set up to the symbol paragraph-start      in order to check for the bug that clobbers it.  */
if|if
condition|(
name|c
operator|&&
name|EQ
argument_list|(
name|c
operator|->
name|major_mode
argument_list|,
name|Qlisp_mode
argument_list|)
operator|&&
name|XFASTINT
argument_list|(
name|Vcheck_symbol
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|NULL
argument_list|(
name|Vcheck_symbol
argument_list|)
condition|)
block|{
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|Vcheck_symbol
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|!=
name|Lisp_Some_Buffer_Local_Value
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|)
operator|&&
operator|(
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|!=
name|Lisp_String
operator|||
name|XSTRING
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|size
operator|!=
literal|6
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Look down buffer's list of local Lisp variables      to find and update any that forward into C variables. */
for|for
control|(
name|tail
operator|=
name|p
operator|->
name|local_var_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|||
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
operator|)
operator|&&
operator|(
name|tem
operator|=
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|,
operator|(
name|tem
operator|==
name|Lisp_Boolfwd
operator|||
name|tem
operator|==
name|Lisp_Intfwd
operator|||
name|tem
operator|==
name|Lisp_Objfwd
operator|)
operator|)
condition|)
comment|/* Just reference the variable 	     to cause it to become set for this buffer.  */
name|Fsymbol_value
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
comment|/* Do the same with any others that were local to the previous buffer */
if|if
condition|(
name|c
condition|)
for|for
control|(
name|tail
operator|=
name|c
operator|->
name|local_var_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|||
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
operator|)
operator|&&
operator|(
name|tem
operator|=
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|,
operator|(
name|tem
operator|==
name|Lisp_Boolfwd
operator|||
name|tem
operator|==
name|Lisp_Intfwd
operator|||
name|tem
operator|==
name|Lisp_Objfwd
operator|)
operator|)
condition|)
comment|/* Just reference the variable                to cause it to become set for this buffer.  */
name|Fsymbol_value
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
block|}
comment|/* Vcheck_symbol is set up to the symbol paragraph-start      in order to check for the bug that clobbers it.  */
if|if
condition|(
name|EQ
argument_list|(
name|p
operator|->
name|major_mode
argument_list|,
name|Qlisp_mode
argument_list|)
operator|&&
name|Vcheck_symbol
operator|&&
operator|!
name|NULL
argument_list|(
name|Vcheck_symbol
argument_list|)
condition|)
block|{
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|Vcheck_symbol
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|!=
name|Lisp_Some_Buffer_Local_Value
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|)
operator|&&
operator|(
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|!=
name|Lisp_String
operator|||
name|XSTRING
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|size
operator|!=
literal|6
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|Fsymbol_value
argument_list|(
name|Vcheck_symbol
argument_list|)
expr_stmt|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|Vcheck_symbol
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|!=
name|Lisp_String
operator|||
name|XSTRING
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|size
operator|!=
literal|6
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* set the current buffer to p "just for redisplay" */
end_comment

begin_expr_stmt
name|SetBfx
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|buffer
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|bf_cur
operator|==
name|p
condition|)
return|return;
name|bf_cur
operator|->
name|text
operator|=
name|bf_text
expr_stmt|;
name|bf_cur
operator|=
name|p
expr_stmt|;
name|bf_text
operator|=
name|p
operator|->
name|text
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"erase-buffer"
argument_list|,
argument|Ferase_buffer
argument_list|,
argument|Serase_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Delete the entire contents of the current buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Fwiden
argument_list|()
block|;
name|del_range
argument_list|(
literal|1
argument_list|,
name|NumCharacters
operator|+
literal|1
argument_list|)
block|;
name|bf_cur
operator|->
name|last_window_start
operator|=
literal|1
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|validate_region
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
specifier|register
name|Lisp_Object
operator|*
name|b
operator|,
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
operator|*
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
operator|*
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
operator|*
name|b
argument_list|)
operator|>
name|XINT
argument_list|(
operator|*
name|e
argument_list|)
condition|)
block|{
name|i
operator|=
name|XFASTINT
argument_list|(
operator|*
name|b
argument_list|)
expr_stmt|;
comment|/* This is legit even if *b is< 0 */
operator|*
name|b
operator|=
operator|*
name|e
expr_stmt|;
name|XFASTINT
argument_list|(
operator|*
name|e
argument_list|)
operator|=
name|i
expr_stmt|;
comment|/* because this is all we do with i.  */
block|}
if|if
condition|(
operator|!
operator|(
name|FirstCharacter
operator|<=
name|XINT
argument_list|(
operator|*
name|b
argument_list|)
operator|&&
name|XINT
argument_list|(
operator|*
name|b
argument_list|)
operator|<=
name|XINT
argument_list|(
operator|*
name|e
argument_list|)
operator|&&
name|XINT
argument_list|(
operator|*
name|e
argument_list|)
operator|<=
literal|1
operator|+
name|NumCharacters
operator|)
condition|)
name|args_out_of_range
argument_list|(
operator|*
name|b
argument_list|,
operator|*
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|list_buffers_1
parameter_list|(
name|files
parameter_list|)
name|Lisp_Object
name|files
decl_stmt|;
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|buf
decl_stmt|,
name|col1
decl_stmt|,
name|col2
decl_stmt|,
name|col3
decl_stmt|,
name|minspace
decl_stmt|,
name|tem
decl_stmt|,
name|mode
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|desired_point
init|=
literal|0
decl_stmt|;
name|bf_cur
operator|->
name|text
operator|.
name|modified
operator|=
name|bf_modified
expr_stmt|;
name|XFASTINT
argument_list|(
name|col1
argument_list|)
operator|=
literal|19
expr_stmt|;
name|XFASTINT
argument_list|(
name|col2
argument_list|)
operator|=
literal|25
expr_stmt|;
name|XFASTINT
argument_list|(
name|col3
argument_list|)
operator|=
literal|40
expr_stmt|;
name|XFASTINT
argument_list|(
name|minspace
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|intern
argument_list|(
literal|"Buffer-menu-mode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|mode
argument_list|,
name|bf_cur
operator|->
name|major_mode
argument_list|)
operator|&&
operator|(
name|tem
operator|=
name|Ffboundp
argument_list|(
name|mode
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
name|Fapply
argument_list|(
name|mode
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Fbuffer_flush_undo
argument_list|(
name|Vstandard_output
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|read_only
operator|=
name|Qnil
expr_stmt|;
name|write_string
argument_list|(
literal|"\  MR Buffer         Size  Mode           File\n\  -- ------         ----  ----           ----\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
control|)
block|{
name|buf
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't mention the minibuffers. */
if|if
condition|(
name|XSTRING
argument_list|(
name|b
operator|->
name|name
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
continue|continue;
comment|/* Optionally don't mention buffers that lack files. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|files
argument_list|)
operator|&&
name|NULL
argument_list|(
name|b
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
comment|/* Identify the current buffer. */
if|if
condition|(
name|b
operator|==
name|old
condition|)
name|desired_point
operator|=
name|point
expr_stmt|;
name|write_string
argument_list|(
name|b
operator|==
name|old
condition|?
literal|"."
else|:
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Identify modified buffers */
name|write_string
argument_list|(
name|b
operator|->
name|text
operator|.
name|modified
operator|>
name|b
operator|->
name|save_modified
condition|?
literal|"*"
else|:
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
name|NULL
argument_list|(
name|b
operator|->
name|read_only
argument_list|)
condition|?
literal|"  "
else|:
literal|"% "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|col1
argument_list|,
name|make_number
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|tem
argument_list|)
operator|=
name|b
operator|->
name|text
operator|.
name|size1
operator|+
name|b
operator|->
name|text
operator|.
name|size2
expr_stmt|;
name|Fprin1
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|col2
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|b
operator|->
name|mode_name
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|col3
argument_list|,
name|minspace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|b
operator|->
name|filename
argument_list|)
condition|)
name|Fprinc
argument_list|(
name|b
operator|->
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|write_string
argument_list|(
literal|"\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bf_cur
operator|->
name|read_only
operator|=
name|Qt
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
comment|/* Foo.  This doesn't work since temp_output_buffer_show sets point to 1 */
if|if
condition|(
name|desired_point
condition|)
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
operator|->
name|text
operator|.
name|pointloc
operator|=
name|desired_point
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"list-buffers"
argument_list|,
argument|Flist_buffers
argument_list|,
argument|Slist_buffers
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Display a list of names of existing buffers.\n\ Inserts it in buffer *Buffer List* and displays that.\n\ Note that buffers with names starting with spaces are omitted.\n\ Non-null optional arg FILES-ONLY means mention only file buffers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|files
operator|)
name|Lisp_Object
name|files
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Buffer List*"
argument_list|,
name|list_buffers_1
argument_list|,
name|files
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* note: this leaves us in fundamental-mode, not default-major-mode    should anything be done about this? */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"kill-all-local-variables"
argument_list|,
argument|Fkill_all_local_variables
argument_list|,
argument|Skill_all_local_variables
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Eliminate all the buffer-local variable values of the current buffer.\n\ This buffer will then see the default values of all variables."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|Lisp_Object
name|alist
block|,
name|sym
block|,
name|tem
block|;
for|for
control|(
name|alist
operator|=
name|bf_cur
operator|->
name|local_var_alist
init|;
operator|!
name|NULL
argument_list|(
name|alist
argument_list|)
condition|;
name|alist
operator|=
name|XCONS
argument_list|(
name|alist
argument_list|)
operator|->
name|cdr
control|)
block|{
name|sym
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|alist
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|car
expr_stmt|;
comment|/* Need not do anything if some other buffer's binding is now encached.  */
name|tem
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|XBUFFER
argument_list|(
name|tem
argument_list|)
operator|==
name|bf_cur
condition|)
block|{
comment|/* Symbol is set up for this buffer's old local value. 	     Set it up for the current buffer with the default value.  */
name|tem
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
operator|=
name|tem
expr_stmt|;
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
operator|=
name|Fcurrent_buffer
argument_list|()
expr_stmt|;
name|store_symval_forwarding
argument_list|(
name|sym
argument_list|,
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|car
argument_list|,
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}    reset_buffer_local_variables
operator|(
name|bf_cur
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_decl_stmt
unit|extern
name|Lisp_Object
name|Vprin1_to_string_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in print.c */
end_comment

begin_macro
name|init_buffer_once
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
comment|/* Must do these before making the first buffer! */
name|Vdefault_mode_line_format
operator|=
name|build_string
argument_list|(
literal|"--%1*%1*-Emacs: %17b   %M   %[(%m)%]----%3p-%-"
argument_list|)
expr_stmt|;
name|Vdefault_abbrev_mode
operator|=
name|Qnil
expr_stmt|;
name|default_case_fold_search
operator|=
literal|1
expr_stmt|;
name|default_tab_width
operator|=
literal|8
expr_stmt|;
name|default_truncate_lines
operator|=
literal|0
expr_stmt|;
name|default_ctl_arrow
operator|=
literal|1
expr_stmt|;
name|default_fill_column
operator|=
literal|70
expr_stmt|;
name|default_left_margin
operator|=
literal|0
expr_stmt|;
name|Vbuffer_alist
operator|=
name|Qnil
expr_stmt|;
name|bf_cur
operator|=
literal|0
expr_stmt|;
name|all_buffers
operator|=
literal|0
expr_stmt|;
name|QSFundamental
operator|=
name|build_string
argument_list|(
literal|"Fundamental"
argument_list|)
expr_stmt|;
name|Qfundamental_mode
operator|=
name|intern
argument_list|(
literal|"fundamental-mode"
argument_list|)
expr_stmt|;
name|Vdefault_major_mode
operator|=
name|Qfundamental_mode
expr_stmt|;
name|Vprin1_to_string_buffer
operator|=
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|" prin1"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* super-magic invisible buffer */
name|Vbuffer_alist
operator|=
name|Qnil
expr_stmt|;
name|tem
operator|=
name|Fset_buffer
argument_list|(
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Want no undo records for *scratch*      until after Emacs is dumped */
name|Fbuffer_flush_undo
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|init_buffer
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|Fset_buffer
argument_list|(
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|getwd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|directory
operator|=
name|build_string
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|make_undo_records
argument_list|(
name|bf_cur
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* initialize the buffer routines */
end_comment

begin_macro
name|syms_of_buffer
argument_list|()
end_macro

begin_block
block|{
name|staticpro
argument_list|(
operator|&
name|Qfundamental_mode
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|QSFundamental
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vbuffer_alist
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qlisp_mode
argument_list|)
expr_stmt|;
name|Qlisp_mode
operator|=
name|intern
argument_list|(
literal|"lisp-mode"
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"default-mode-line-format"
argument_list|,
operator|&
name|Vdefault_mode_line_format
argument_list|,
literal|"Default value of mode-line-format for new buffers."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"mode-line-format"
argument_list|,
operator|&
name|bf_cur
operator|->
name|mode_line_format
argument_list|,
literal|"Template string for displaying mode line for current buffer.\n\ Each buffer has its own value of this variable.\n\ The string is printed verbatim in the mode line\n\ except for %-constructs:\n\   %b -- print buffer name.   %f -- print visited file name.\n\   %* -- print *, % or hyphen.   %m -- print value of mode-name.\n\   %s -- print process status.   %M -- print value of global-mode-string.\n\   %p -- print percent of buffer above top of window, or top, bot or all.\n\   %[ -- print one [ for each recursive editing level.  %] similar.\n\   %% -- print %.   %- -- print infinitely many dashes.\n\ Decimal digits after the % specify field width to pad or truncate to."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"default-abbrev-mode"
argument_list|,
operator|&
name|Vdefault_abbrev_mode
argument_list|,
literal|"Default value of abbrev-mode for new buffers."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"abbrev-mode"
argument_list|,
operator|&
name|bf_cur
operator|->
name|abbrev_mode
argument_list|,
literal|"*Non-nil turns on automatic expansion of abbrevs when inserted."
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"default-case-fold-search"
argument_list|,
operator|&
name|default_case_fold_search
argument_list|,
literal|"*Default value of case-fold-search for new buffers."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"case-fold-search"
argument_list|,
operator|&
name|bf_cur
operator|->
name|case_fold_search
argument_list|,
literal|"*Non-nil if searches should ignore case.\n\ Separate value in each buffer."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"mode-name"
argument_list|,
operator|&
name|bf_cur
operator|->
name|mode_name
argument_list|,
literal|"Pretty name of current buffer's major mode (a string)."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"minor-modes"
argument_list|,
operator|&
name|bf_cur
operator|->
name|minor_modes
argument_list|,
literal|"List of minor modes enabled in current buffer.\n\ Each element is (FUNCTION-SYMBOL . PRETTY-STRING)."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"default-fill-column"
argument_list|,
operator|&
name|default_fill_column
argument_list|,
literal|"*Default value of fill-column for new buffers."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"fill-column"
argument_list|,
operator|&
name|bf_cur
operator|->
name|fill_column
argument_list|,
literal|"*Column beyond which automatic line-wrapping should happen.\n\ Separate value in each buffer."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"default-left-margin"
argument_list|,
operator|&
name|default_left_margin
argument_list|,
literal|"*Default value of left-margin for buffers that don't override it."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"left-margin"
argument_list|,
operator|&
name|bf_cur
operator|->
name|left_margin
argument_list|,
literal|"*Column for the default indent-line-function to indent to.\n\ Linefeed indents to this column in Fundamental mode."
argument_list|)
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"default-tab-width"
argument_list|,
operator|&
name|default_tab_width
argument_list|,
literal|"*Default value of tab-width for new buffers."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"tab-width"
argument_list|,
operator|&
name|bf_cur
operator|->
name|tab_width
argument_list|,
literal|"*Distance between tab stops (for display of tab characters), in columns.\n\ Separate value in each buffer."
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"default-ctl-arrow"
argument_list|,
operator|&
name|default_ctl_arrow
argument_list|,
literal|"*Default value of ctl-arrow for new buffers."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"ctl-arrow"
argument_list|,
operator|&
name|bf_cur
operator|->
name|ctl_arrow
argument_list|,
literal|"*Non-nil means display control chars with uparrow.\n\ Nil means use backslash and octal digits.\n\ Separate value in each buffer."
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"default-truncate-lines"
argument_list|,
operator|&
name|default_truncate_lines
argument_list|,
literal|"*Default value of truncate-lines for new buffers."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"truncate-lines"
argument_list|,
operator|&
name|bf_cur
operator|->
name|truncate_lines
argument_list|,
literal|"*Non-nil means do not display continuation lines;\n\ give each line of text one screen line.\n\ Separate value in each buffer."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"default-directory"
argument_list|,
operator|&
name|bf_cur
operator|->
name|directory
argument_list|,
literal|"*Name of default directory of current buffer.  Should end with slash."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"auto-fill-hook"
argument_list|,
operator|&
name|bf_cur
operator|->
name|auto_fill_hook
argument_list|,
literal|"Function called (if non-nil) after self-inserting a space at column beyond fill-column"
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"buffer-file-name"
argument_list|,
operator|&
name|bf_cur
operator|->
name|filename
argument_list|,
literal|"Name of file visited in current buffer, or nil if not visiting a file."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"buffer-auto-save-file-name"
argument_list|,
operator|&
name|bf_cur
operator|->
name|auto_save_file_name
argument_list|,
literal|"Name of file for auto-saving current buffer,\n\ or nil if buffer should not be auto-saved."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"buffer-read-only"
argument_list|,
operator|&
name|bf_cur
operator|->
name|read_only
argument_list|,
literal|"*Non-nil if this buffer is read-only."
argument_list|)
expr_stmt|;
comment|/* LMCL: Second arg should really be a Lisp_Object but it needs this address.  * A Lisp_Object had better take up only one word! */
name|DefBufferLispVar
argument_list|(
literal|"buffer-backed-up"
argument_list|,
operator|&
name|bf_cur
operator|->
name|backed_up
argument_list|,
literal|"Non-nil if this buffer's file has been backed up.\n\ Backing up is done before the first time the file is saved."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"buffer-saved-size"
argument_list|,
operator|&
name|bf_cur
operator|->
name|save_length
argument_list|,
literal|"Length of current buffer when last read in, saved or auto-saved.\n\ 0 initially."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"selective-display"
argument_list|,
operator|&
name|bf_cur
operator|->
name|selective_display
argument_list|,
literal|"t enables selective display:\n\  after a ^M, all the rest of the line is invisible.\n\  ^M's in the file are written into files as newlines.\n\ Integer n as value means display only lines\n\  that start with less than n columns of space."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"overwrite-mode"
argument_list|,
operator|&
name|bf_cur
operator|->
name|overwrite_mode
argument_list|,
literal|"*Non-nil if self-insertion should replace existing text."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"default-major-mode"
argument_list|,
operator|&
name|Vdefault_major_mode
argument_list|,
literal|"*Major mode for new buffers.  Defaults to fundamental-mode.\n\ nil here means use current buffer's major mode."
argument_list|)
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"major-mode"
argument_list|,
operator|&
name|bf_cur
operator|->
name|major_mode
argument_list|,
literal|"Symbol for buffer's major mode."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"debug-check-symbol"
argument_list|,
operator|&
name|Vcheck_symbol
argument_list|,
literal|"Don't ask."
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_list
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_file_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_buffer_create
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgenerate_new_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_number
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_file_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_local_variables
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_modified_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_buffer_modified_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srename_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sother_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_flush_undo
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skill_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Serase_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sswitch_to_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spop_to_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbarf_if_buffer_read_only
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbury_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slist_buffers
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skill_all_local_variables
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_buffer
argument_list|()
end_macro

begin_block
block|{
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'b'
argument_list|,
literal|"switch-to-buffer"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'k'
argument_list|,
literal|"kill-buffer"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
name|Ctl
argument_list|(
literal|'B'
argument_list|)
argument_list|,
literal|"list-buffers"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

