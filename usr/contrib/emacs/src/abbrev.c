begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Word-abbrev mode.  Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_comment
comment|/* An abbrev table is an obarray.  Each defined abbrev is represented by a symbol in that obarray  whose print name is the abbreviation.  The symbol's value is a string which is the expansion.  If its function definition is non-nil, it is called   after the expansion is done.  The plist slot of the abbrev symbol is its usage count. */
end_comment

begin_comment
comment|/* List of all abbrev-table name symbols:  symbols whose values are abbrev tables.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vabbrev_table_name_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table of global abbrevs.  These are in effect  in any buffer in which abbrev mode is turned on. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vglobal_abbrev_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The local abbrev table used by default (in Fundamental Mode buffers) */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vfundamental_mode_abbrev_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero when an abbrev definition is changed */
end_comment

begin_decl_stmt
name|int
name|abbrevs_changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|abbrev_all_caps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-nil => use this location as the start of abbrev to expand  (rather than taking the word before point as the abbrev) */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vabbrev_start_location
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer that Vabbrev_start_location applies to */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vabbrev_start_location_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The symbol representing the abbrev most recently expanded */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vlast_abbrev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character address of start of last abbrev expanded */
end_comment

begin_decl_stmt
name|int
name|last_abbrev_point
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|Lisp_Object
name|oblookup
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"make-abbrev-table"
argument_list|,
argument|Fmake_abbrev_table
argument_list|,
argument|Smake_abbrev_table
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Create a new, empty abbrev table object."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Fmake_vector
argument_list|(
name|make_number
argument_list|(
literal|59
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"clear-abbrev-table"
argument_list|,
argument|Fclear_abbrev_table
argument_list|,
argument|Sclear_abbrev_table
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Undefine all abbrevs in abbrev table TABLE, leaving it empty."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|table
operator|)
name|Lisp_Object
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|XVECTOR
argument_list|(
name|table
argument_list|)
operator|->
name|size
expr_stmt|;
name|abbrevs_changed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|XVECTOR
argument_list|(
name|table
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|make_number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"define-abbrev"
argument_list|,
argument|Fdefine_abbrev
argument_list|,
argument|Sdefine_abbrev
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Define an abbrev in TABLE named NAME, to expand to EXPANSION or call HOOK.\n\ NAME and EXPANSION are strings.  HOOK is a function or nil.\n\ To undefine an abbrev, define it with EXPANSION = nil"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|table
operator|,
name|name
operator|,
name|expansion
operator|,
name|hook
operator|,
name|count
operator|)
name|Lisp_Object
name|table
operator|,
name|name
operator|,
name|expansion
operator|,
name|hook
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|sym
decl_stmt|,
name|oexp
decl_stmt|,
name|ohook
decl_stmt|,
name|tem
decl_stmt|;
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|expansion
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|count
argument_list|)
condition|)
name|count
operator|=
name|make_number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym
operator|=
name|Fintern
argument_list|(
name|name
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|oexp
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
name|ohook
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|EQ
argument_list|(
name|oexp
argument_list|,
name|expansion
argument_list|)
operator|||
operator|(
name|XTYPE
argument_list|(
name|oexp
argument_list|)
operator|==
name|Lisp_String
operator|&&
operator|(
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|oexp
argument_list|,
name|expansion
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|EQ
argument_list|(
name|ohook
argument_list|,
name|hook
argument_list|)
operator|||
operator|(
name|tem
operator|=
name|Fequal
argument_list|(
name|ohook
argument_list|,
name|hook
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|abbrevs_changed
operator|=
literal|1
expr_stmt|;
name|Fset
argument_list|(
name|sym
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|Ffset
argument_list|(
name|sym
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|Fsetplist
argument_list|(
name|sym
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"define-global-abbrev"
argument_list|,
argument|Fdefine_global_abbrev
argument_list|,
argument|Sdefine_global_abbrev
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"sDefine global abbrev: \nsExpansion for %s: "
argument_list|,
literal|"Define ABBREV as a global abbreviation for EXPANSION."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|expansion
operator|)
name|Lisp_Object
name|name
operator|,
name|expansion
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Fdefine_abbrev
argument_list|(
name|Vglobal_abbrev_table
argument_list|,
name|Fdowncase
argument_list|(
name|name
argument_list|)
argument_list|,
name|expansion
argument_list|,
name|Qnil
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"define-mode-abbrev"
argument_list|,
argument|Fdefine_mode_abbrev
argument_list|,
argument|Sdefine_mode_abbrev
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"sDefine mode abbrev: \nsExpansion for %s: "
argument_list|,
literal|"Define ABBREV as a mode-specific abbreviation for EXPANSION."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|expansion
operator|)
name|Lisp_Object
name|name
operator|,
name|expansion
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|bf_cur
operator|->
name|abbrev_table
argument_list|)
condition|)
name|error
argument_list|(
literal|"No local abbrev table associated with this buffer"
argument_list|)
expr_stmt|;
name|Fdefine_abbrev
argument_list|(
name|bf_cur
operator|->
name|abbrev_table
argument_list|,
name|Fdowncase
argument_list|(
name|name
argument_list|)
argument_list|,
name|expansion
argument_list|,
name|Qnil
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"abbrev-symbol"
argument_list|,
argument|Fabbrev_symbol
argument_list|,
argument|Sabbrev_symbol
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the symbol representing abbrev named ABBREV.\n\ Value is nil if that abbrev is not defined.\n\ Optional second arg TABLE is abbrev table to look it up in.\n\ Default is try buffer's mode-specific abbrev table, then global table."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|abbrev
operator|,
name|table
operator|)
name|Lisp_Object
name|abbrev
operator|,
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|abbrev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|table
argument_list|)
condition|)
name|sym
operator|=
name|Fintern_soft
argument_list|(
name|abbrev
argument_list|,
name|table
argument_list|)
expr_stmt|;
else|else
block|{
name|sym
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|abbrev_table
argument_list|)
condition|)
name|sym
operator|=
name|Fintern_soft
argument_list|(
name|abbrev
argument_list|,
name|bf_cur
operator|->
name|abbrev_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
name|sym
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|sym
argument_list|)
condition|)
name|sym
operator|=
name|Fintern_soft
argument_list|(
name|abbrev
argument_list|,
name|Vglobal_abbrev_table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return
name|Qnil
return|;
return|return
name|sym
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"abbrev-expansion"
argument_list|,
argument|Fabbrev_expansion
argument_list|,
argument|Sabbrev_expansion
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the string that ABBREV expands into in the current buffer.\n\ Optionally specify an abbrev table; then ABBREV is looked up in that table only."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|abbrev
operator|,
name|table
operator|)
name|Lisp_Object
name|abbrev
operator|,
name|table
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|sym
decl_stmt|;
name|sym
operator|=
name|Fabbrev_symbol
argument_list|(
name|abbrev
argument_list|,
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|sym
argument_list|)
condition|)
return|return
name|sym
return|;
return|return
name|Fsymbol_value
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Expand the word before point, if it is an abbrev.   Returns 1 if an expansion is done. */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"expand-abbrev"
argument_list|,
argument|Fexpand_abbrev
argument_list|,
argument|Sexpand_abbrev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Expand the abbrev before point, if it is an abbrev.\n\ Returns t if expansion took place."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|char
name|buffer
index|[
literal|200
index|]
block|;
name|char
operator|*
name|p
operator|=
name|buffer
block|;
name|int
name|wordstart
block|,
name|idx
block|;
name|int
name|uccount
operator|=
literal|0
block|,
name|lccount
operator|=
literal|0
block|;
name|Lisp_Object
name|sym
block|,
name|expansion
block|,
name|hook
block|,
name|tem
block|;
if|if
condition|(
name|XBUFFER
argument_list|(
name|Vabbrev_start_location_buffer
argument_list|)
operator|!=
name|bf_cur
condition|)
name|Vabbrev_start_location
operator|=
name|Qnil
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vabbrev_start_location
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Vabbrev_start_location
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wordstart
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Vabbrev_start_location
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
name|wordstart
operator|=
name|scan_words
argument_list|(
name|point
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|wordstart
operator|||
name|point
operator|-
name|wordstart
operator|>=
sizeof|sizeof
name|buffer
operator|||
name|point
operator|<=
name|wordstart
condition|)
return|return
name|Qnil
return|;
end_if

begin_for
for|for
control|(
name|idx
operator|=
name|wordstart
init|;
name|idx
operator|<
name|point
condition|;
name|idx
operator|++
control|)
block|{
operator|*
name|p
operator|=
name|CharAt
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|)
operator|*
name|p
operator|+=
literal|040
operator|,
name|uccount
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
condition|)
name|lccount
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|bf_cur
operator|->
name|abbrev_table
argument_list|)
operator|==
name|Lisp_Vector
condition|)
name|sym
operator|=
name|oblookup
argument_list|(
name|bf_cur
operator|->
name|abbrev_table
argument_list|,
name|buffer
argument_list|,
name|p
operator|-
name|buffer
argument_list|)
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|Lisp_Int
operator|||
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
name|sym
operator|=
name|oblookup
argument_list|(
name|Vglobal_abbrev_table
argument_list|,
name|buffer
argument_list|,
name|p
operator|-
name|buffer
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|Lisp_Int
operator|||
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return
name|Qnil
return|;
end_if

begin_expr_stmt
name|SetPoint
argument_list|(
name|wordstart
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|del_range
argument_list|(
name|point
argument_list|,
name|point
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Now sym is the abbrev symbol. */
end_comment

begin_expr_stmt
name|Vlast_abbrev
operator|=
name|sym
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|last_abbrev_point
operator|=
name|point
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|XSETINT
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|,
name|XINT
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Increment use count */
end_comment

begin_expr_stmt
name|hook
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|hook
argument_list|)
condition|)
name|Fapply
argument_list|(
name|hook
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
block|{
name|expansion
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|expansion
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|expansion
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|uccount
operator|&&
operator|!
name|lccount
condition|)
block|{
comment|/* Abbrev was all caps */
comment|/* If expansion is multiple words, normally capitalize each word */
comment|/* This used to be if (!...&& ...>= ...) Fcapitalize; else Fupcase 	     but Megatest 68000 compiler can't handle that */
if|if
condition|(
operator|!
name|abbrev_all_caps
condition|)
if|if
condition|(
name|scan_words
argument_list|(
name|point
argument_list|,
operator|-
literal|1
argument_list|)
operator|>
name|scan_words
argument_list|(
name|wordstart
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|upcase_initials_region
argument_list|(
name|make_number
argument_list|(
name|wordstart
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|caped
goto|;
block|}
comment|/* If expansion is one word, or if user says so, upcase it all. */
name|Fupcase_region
argument_list|(
name|make_number
argument_list|(
name|wordstart
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|)
expr_stmt|;
name|caped
label|:
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|uccount
condition|)
block|{
comment|/* Abbrev included some caps.  Cap first initial of expansion */
name|idx
operator|=
name|point
expr_stmt|;
name|SetPoint
argument_list|(
name|wordstart
argument_list|)
expr_stmt|;
name|Fcapitalize_word
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|Qt
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"unexpand-abbrev"
operator|,
name|Funexpand_abbrev
operator|,
name|Sunexpand_abbrev
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Undo the expansion of the last abbrev that expanded."
operator|)
operator|(
operator|)
block|{
name|SetPoint
argument_list|(
name|last_abbrev_point
argument_list|)
block|;
if|if
condition|(
name|NULL
argument_list|(
name|Vlast_abbrev
argument_list|)
condition|)
block|{
name|Fforward_word
argument_list|(
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Fexpand_abbrev
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|Vlast_abbrev
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|del_range
argument_list|(
name|point
argument_list|,
name|point
operator|+
name|XSTRING
argument_list|(
name|XSYMBOL
argument_list|(
name|Vlast_abbrev
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|XSYMBOL
argument_list|(
name|Vlast_abbrev
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|,
name|XSYMBOL
argument_list|(
name|Vlast_abbrev
argument_list|)
operator|->
name|name
operator|->
name|size
argument_list|)
expr_stmt|;
name|Vlast_abbrev
operator|=
name|Qnil
expr_stmt|;
block|}
end_elseif

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"last-abbrev-expansion"
operator|,
name|Flast_abbrev_expansion
operator|,
name|Slast_abbrev_expansion
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return expansion of last abbrev expanded, or nil."
operator|)
operator|(
operator|)
block|{
return|return
name|Fsymbol_value
argument_list|(
name|Vlast_abbrev
argument_list|)
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|write_abbrev
argument_list|(
argument|sym
argument_list|,
argument|stream
argument_list|)
name|Lisp_Object
name|sym
operator|,
name|stream
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|name
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return;
name|InsCStr
argument_list|(
literal|"    ("
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|name
argument_list|,
name|Lisp_String
argument_list|,
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|")\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|describe_abbrev
argument_list|(
argument|sym
argument_list|,
argument|stream
argument_list|)
name|Lisp_Object
name|sym
operator|,
name|stream
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|one
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
condition|)
return|return;
name|one
operator|=
name|make_number
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|Fsymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|15
argument_list|)
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|20
argument_list|)
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|)
condition|)
block|{
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|45
argument_list|)
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|Fterpri
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert-abbrev-table-description"
argument_list|,
argument|Finsert_abbrev_table_description
argument_list|,
argument|Sinsert_abbrev_table_description
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Insert before point a description of abbrev table named NAME.\n\ NAME is a symbol whose value is an abbrev table.\n\ If 2nd arg READABLE is non-nil, a readable description is inserted.\n\ Otherwise description is an expression,\n\ a call to define-abbrev-table which would\n\ define NAME exactly as it is currently defined."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|,
name|readable
operator|)
name|Lisp_Object
name|name
operator|,
name|readable
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|table
decl_stmt|;
name|Lisp_Object
name|stream
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|Fsymbol_value
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|stream
argument_list|,
name|Lisp_Buffer
argument_list|,
name|bf_cur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|readable
argument_list|)
condition|)
block|{
name|InsStr
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|")\n\n"
argument_list|)
expr_stmt|;
name|map_obarray
argument_list|(
name|table
argument_list|,
name|describe_abbrev
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|InsStr
argument_list|(
literal|"(define-abbrev-table '"
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|" '(\n"
argument_list|)
expr_stmt|;
name|map_obarray
argument_list|(
name|table
argument_list|,
name|write_abbrev
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"    ))\n\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"define-abbrev-table"
argument_list|,
argument|Fdefine_abbrev_table
argument_list|,
argument|Sdefine_abbrev_table
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Define TABNAME (a symbol) as an abbrev table name.\n\ Define abbrevs in it according to DEFINITIONS, a list of elements\n\ of the form (ABBREVNAME EXPANSION HOOK USECOUNT)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|tabname
operator|,
name|defns
operator|)
name|Lisp_Object
name|tabname
operator|,
name|defns
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|name
decl_stmt|,
name|exp
decl_stmt|,
name|hook
decl_stmt|,
name|count
decl_stmt|;
name|Lisp_Object
name|table
decl_stmt|,
name|elt
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|tabname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|table
operator|=
name|Fboundp
argument_list|(
name|tabname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|table
argument_list|)
operator|||
operator|(
name|table
operator|=
name|Fsymbol_value
argument_list|(
name|tabname
argument_list|)
operator|,
name|NULL
argument_list|(
name|table
argument_list|)
operator|)
condition|)
block|{
name|table
operator|=
name|Fmake_abbrev_table
argument_list|()
expr_stmt|;
name|Fset
argument_list|(
name|tabname
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|Vabbrev_table_name_list
operator|=
name|Fcons
argument_list|(
name|tabname
argument_list|,
name|Vabbrev_table_name_list
argument_list|)
expr_stmt|;
block|}
name|CHECK_VECTOR
argument_list|(
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|defns
argument_list|)
condition|;
name|defns
operator|=
name|Fcdr
argument_list|(
name|defns
argument_list|)
control|)
block|{
name|elt
operator|=
name|Fcar
argument_list|(
name|defns
argument_list|)
expr_stmt|;
name|name
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|elt
operator|=
name|Fcdr
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|exp
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|elt
operator|=
name|Fcdr
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|hook
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|elt
operator|=
name|Fcdr
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|count
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|Fdefine_abbrev
argument_list|(
name|table
argument_list|,
name|name
argument_list|,
name|exp
argument_list|,
name|hook
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_abbrev
argument_list|()
end_macro

begin_block
block|{
name|DefLispVar
argument_list|(
literal|"abbrev-table-name-list"
argument_list|,
operator|&
name|Vabbrev_table_name_list
argument_list|,
literal|"List of symbols whose values are  abbrev tables."
argument_list|)
expr_stmt|;
name|Vabbrev_table_name_list
operator|=
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"fundamental-mode-abbrev-table"
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|intern
argument_list|(
literal|"global-abbrev-table"
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"global-abbrev-table"
argument_list|,
operator|&
name|Vglobal_abbrev_table
argument_list|,
literal|"The abbrev table whose abbrevs affect all buffers.\n\ Each buffer may also have a local abbrev table.\n\ If it does, the local table overrides the global one\n\ for any particular abbrev defined in both."
argument_list|)
expr_stmt|;
name|Vglobal_abbrev_table
operator|=
name|Fmake_abbrev_table
argument_list|()
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"fundamental-mode-abbrev-table"
argument_list|,
operator|&
name|Vfundamental_mode_abbrev_table
argument_list|,
literal|"The abbrev table of mode-specific abbrevs for Fundamental Mode."
argument_list|)
expr_stmt|;
name|Vfundamental_mode_abbrev_table
operator|=
name|Fmake_abbrev_table
argument_list|()
expr_stmt|;
name|bf_cur
operator|->
name|abbrev_table
operator|=
name|Vfundamental_mode_abbrev_table
expr_stmt|;
comment|/* Avoid need for some error checking this way   DefLispVar ("last-abbrev",&Vlast_abbrev,     "The abbrev-symbol of the last abbrev expanded.");    DefIntVar ("last-abbrev-location",&last_abbrev_point,     "The location of the last abbrev expanded."); */
name|staticpro
argument_list|(
operator|&
name|Vlast_abbrev
argument_list|)
expr_stmt|;
name|Vlast_abbrev
operator|=
name|Qnil
expr_stmt|;
name|last_abbrev_point
operator|=
literal|0
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"abbrev-start-location"
argument_list|,
operator|&
name|Vabbrev_start_location
argument_list|,
literal|"Buffer position for expand-abbrev to use as the start of the abbrev.\n\ nil means use the word before point as the abbrev.\n\ Set to nil each time expand-abbrev is called."
argument_list|)
expr_stmt|;
name|Vabbrev_start_location
operator|=
name|Qnil
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"abbrev-start-location-buffer"
argument_list|,
operator|&
name|Vabbrev_start_location_buffer
argument_list|,
literal|"Buffer that abbrev-start-location has been set for.\n\ Trying to expand an abbrev in any other buffer clears abbrev-start-location."
argument_list|)
expr_stmt|;
name|Vabbrev_start_location_buffer
operator|=
name|Qnil
expr_stmt|;
name|DefBufferLispVar
argument_list|(
literal|"local-abbrev-table"
argument_list|,
operator|&
name|bf_cur
operator|->
name|abbrev_table
argument_list|,
literal|"Local (mode-specific) abbrev table of current buffer."
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"abbrevs-changed"
argument_list|,
operator|&
name|abbrevs_changed
argument_list|,
literal|"Set non-nil by defining or altering any word abbrevs."
argument_list|)
expr_stmt|;
name|abbrevs_changed
operator|=
literal|0
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"abbrev-all-caps"
argument_list|,
operator|&
name|abbrev_all_caps
argument_list|,
literal|"*Set non-nil means expand multi-word abbrevs all caps if abbrev was so."
argument_list|)
expr_stmt|;
name|abbrev_all_caps
operator|=
literal|0
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_abbrev_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sclear_abbrev_table
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_global_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_mode_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sabbrev_expansion
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sabbrev_symbol
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexpand_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sunexpand_abbrev
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slast_abbrev_expansion
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_abbrev_table_description
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_abbrev_table
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

