begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Evaluator for GNU Emacs Lisp interpreter.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INTERACTIVE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* This definition is duplicated in alloc.c and keyboard.c */
end_comment

begin_comment
comment|/* Putting it in lisp.h makes cc bomb out! */
end_comment

begin_struct
struct|struct
name|backtrace
block|{
name|struct
name|backtrace
modifier|*
name|next
decl_stmt|;
name|Lisp_Object
modifier|*
name|function
decl_stmt|;
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
comment|/* Points to vector of args. */
name|int
name|nargs
decl_stmt|;
comment|/* length of vector */
comment|/* if nargs is UNEVALLED, args points to slot holding list of unevalled args */
name|char
name|evalargs
decl_stmt|;
comment|/* Nonzero means call value of debugger when done with this operation. */
name|char
name|debug_on_exit
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|backtrace
modifier|*
name|backtrace_list
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|catchtag
block|{
name|Lisp_Object
name|tag
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|struct
name|catchtag
modifier|*
name|next
decl_stmt|;
name|jmp_buf
name|jmp
decl_stmt|;
name|struct
name|backtrace
modifier|*
name|backlist
decl_stmt|;
name|int
name|lisp_eval_depth
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|catchtag
modifier|*
name|catchlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qautoload
decl_stmt|,
name|Qmacro
decl_stmt|,
name|Qexit
decl_stmt|,
name|Qinteractive
decl_stmt|,
name|Qcommandp
decl_stmt|,
name|Qdefun
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vquit_flag
decl_stmt|,
name|Vinhibit_quit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qmocklisp_arguments
decl_stmt|,
name|Vmocklisp_arguments
decl_stmt|,
name|Qmocklisp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qand_rest
decl_stmt|,
name|Qand_optional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-nil means record all fset's and provide's, to be undone    if the file being autoloaded is not fully loaded.    They are recorded by being consed onto the front of Vautoload_queue:    (FUN . ODEF) for a defun, (OFEATURES . nil) for a provide.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vautoload_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current number of specbindings allocated in specpdl.  */
end_comment

begin_decl_stmt
name|int
name|specpdl_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to beginning of specpdl.  */
end_comment

begin_decl_stmt
name|struct
name|specbinding
modifier|*
name|specpdl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to first unused element in specpdl.  */
end_comment

begin_decl_stmt
name|struct
name|specbinding
modifier|*
name|specpdl_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum size allowed for specpdl allocation */
end_comment

begin_decl_stmt
name|int
name|max_specpdl_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth in Lisp evaluations and function calls.  */
end_comment

begin_decl_stmt
name|int
name|lisp_eval_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum allowed depth in Lisp evaluations and function calls.  */
end_comment

begin_decl_stmt
name|int
name|max_lisp_eval_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means enter debugger before next function call */
end_comment

begin_decl_stmt
name|int
name|debug_on_next_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means display a backtrace if an error  is handled by the command loop's error handler. */
end_comment

begin_decl_stmt
name|int
name|stack_trace_on_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means enter debugger if an error  is handled by the command loop's error handler. */
end_comment

begin_decl_stmt
name|int
name|debug_on_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means enter debugger if a quit signal  is handled by the command loop's error handler. */
end_comment

begin_decl_stmt
name|int
name|debug_on_quit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vdebugger
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|specbind
argument_list|()
decl_stmt|,
name|unbind_to
argument_list|()
decl_stmt|,
name|record_unwind_protect
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
name|funcall_lambda
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|Lisp_Object
name|ml_apply
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Apply a mocklisp function to unevaluated argument list */
end_comment

begin_macro
name|init_eval_once
argument_list|()
end_macro

begin_block
block|{
name|specpdl_size
operator|=
literal|100
expr_stmt|;
name|specpdl
operator|=
operator|(
expr|struct
name|specbinding
operator|*
operator|)
name|malloc
argument_list|(
name|specpdl_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|specbinding
argument_list|)
argument_list|)
expr_stmt|;
name|max_specpdl_size
operator|=
literal|600
expr_stmt|;
name|max_lisp_eval_depth
operator|=
literal|200
expr_stmt|;
block|}
end_block

begin_macro
name|init_eval
argument_list|()
end_macro

begin_block
block|{
name|specpdl_ptr
operator|=
name|specpdl
expr_stmt|;
name|catchlist
operator|=
literal|0
expr_stmt|;
name|handlerlist
operator|=
literal|0
expr_stmt|;
name|backtrace_list
operator|=
literal|0
expr_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|debug_on_next_call
operator|=
literal|0
expr_stmt|;
name|lisp_eval_depth
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|Lisp_Object
name|call_debugger
parameter_list|(
name|arg
parameter_list|)
name|Lisp_Object
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|lisp_eval_depth
operator|+
literal|20
operator|>
name|max_lisp_eval_depth
condition|)
name|max_lisp_eval_depth
operator|=
name|lisp_eval_depth
operator|+
literal|20
expr_stmt|;
if|if
condition|(
name|specpdl_size
operator|+
literal|40
operator|>
name|max_specpdl_size
condition|)
name|max_specpdl_size
operator|=
name|specpdl_size
operator|+
literal|40
expr_stmt|;
return|return
name|Fapply
argument_list|(
name|Vdebugger
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_macro
name|do_debug_on_call
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|debug_on_next_call
operator|=
literal|0
expr_stmt|;
name|backtrace_list
operator|->
name|debug_on_exit
operator|=
literal|1
expr_stmt|;
name|call_debugger
argument_list|(
name|Fcons
argument_list|(
name|code
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* NOTE!!! Every function that can call EVAL must protect its args  and temporaries from garbage collection while it needs them.  The definition of `For' shows what you have to do.  */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"or"
argument_list|,
argument|For
argument_list|,
argument|Sor
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Eval args until one of them yields non-NIL, then return that value.\n\ The remaining args are not evalled at all.\n\ If all args return NIL, return NIL."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|Lisp_Object
name|args_left
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|args_left
operator|=
name|args
expr_stmt|;
name|GCPRO1
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
do|do
block|{
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
break|break;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
do|;
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"and"
argument_list|,
argument|Fand
argument_list|,
argument|Sand
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Eval args until one of them yields NIL, then return NIL.\n\ The remaining args are not evalled at all.\n\ If no arg yields NIL, return the last arg's value."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|Lisp_Object
name|args_left
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|Qt
return|;
name|args_left
operator|=
name|args
expr_stmt|;
name|GCPRO1
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
do|do
block|{
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
break|break;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
do|;
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"if"
argument_list|,
argument|Fif
argument_list|,
argument|Sif
argument_list|,
literal|2
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(if C T E...) if C yields non-NIL do T, else do E...\n\ Returns the value of T or the value of the last of the E's.\n\ There may be no E's; then if C yields NIL, the value is NIL."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|cond
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|cond
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|cond
argument_list|)
condition|)
return|return
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"cond"
argument_list|,
argument|Fcond
argument_list|,
argument|Scond
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(cond CLAUSES...) tries each clause until one succeeds.\n\ Each clause looks like (C BODY...).  C is evaluated\n\ and, if the value is non-nil, this clause succeeds:\n\ then the expressions in BODY are evaluated and the last one's\n\ value is the value of the cond expression.\n\ If a clause looks like (C), C's value if non-nil is returned from cond.\n\ If no clause succeeds, cond returns nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|clause
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|clause
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|clause
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|clause
argument_list|)
operator|->
name|cdr
argument_list|,
name|Qnil
argument_list|)
condition|)
name|val
operator|=
name|Fprogn
argument_list|(
name|XCONS
argument_list|(
name|clause
argument_list|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
break|break;
block|}
name|args
operator|=
name|XCONS
argument_list|(
name|args
argument_list|)
operator|->
name|cdr
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"progn"
argument_list|,
argument|Fprogn
argument_list|,
argument|Sprogn
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Eval arguments in sequence, and return the value of the last one."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|,
name|tem
decl_stmt|;
name|Lisp_Object
name|args_left
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
comment|/* In Mocklisp code, symbols at the front of the progn arglist    are to be bound to zero. */
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|Vmocklisp_arguments
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
name|val
operator|=
name|make_number
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|args
argument_list|)
operator|&&
operator|(
name|tem
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
operator|,
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Symbol
operator|)
condition|)
name|specbind
argument_list|(
name|tem
argument_list|,
name|val
argument_list|)
operator|,
name|args
operator|=
name|Fcdr
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|args_left
operator|=
name|args
expr_stmt|;
name|GCPRO1
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
do|do
block|{
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
do|;
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"prog1"
argument_list|,
argument|Fprog1
argument_list|,
argument|Sprog1
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Eval arguments in sequence, then return the FIRST arg's value.\n\ This value is saved during the evaluation of the remaining args,\n\ whose values are discarded."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|Lisp_Object
name|args_left
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
specifier|register
name|int
name|argnum
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|args_left
operator|=
name|args
expr_stmt|;
name|val
operator|=
name|Qnil
expr_stmt|;
name|GCPRO2
argument_list|(
name|args
argument_list|,
name|val
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|argnum
operator|++
operator|)
condition|)
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
do|;
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"prog2"
argument_list|,
argument|Fprog2
argument_list|,
argument|Sprog2
argument_list|,
literal|2
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Eval arguments in sequence, then return the SECOND arg's value.\n\ This value is saved during the evaluation of the remaining args,\n\ whose values are discarded."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|Lisp_Object
name|args_left
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
specifier|register
name|int
name|argnum
init|=
operator|-
literal|1
decl_stmt|;
name|val
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|args_left
operator|=
name|args
expr_stmt|;
name|val
operator|=
name|Qnil
expr_stmt|;
name|GCPRO2
argument_list|(
name|args
argument_list|,
name|val
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|argnum
operator|++
operator|)
condition|)
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
do|;
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"setq"
argument_list|,
argument|Fsetq
argument_list|,
argument|Ssetq
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(setq SYM VAL SYM VAL ...) sets each SYM to the value of its VAL.\n\ The SYMs are not evaluated.  Thus (setq x y) sets x to the value of y.\n\ Each SYM is set before the next VAL is computed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|args_left
decl_stmt|;
specifier|register
name|Lisp_Object
name|val
decl_stmt|,
name|sym
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|args_left
operator|=
name|args
expr_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
do|do
block|{
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|args_left
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|Fcar
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
name|Fset
argument_list|(
name|sym
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
do|;
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"quote"
argument_list|,
argument|Fquote
argument_list|,
argument|Squote
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Return the argument, without evaluating it.  (quote x)  yields  x."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fcar
argument_list|(
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"function"
argument_list|,
argument|Ffunction
argument_list|,
argument|Sfunction
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Quote a function object.\n\ Equivalent to the quote function in the interpreter,\n\ but causes the compiler to compile the argument as a function\n\ if it is not a symbol."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fcar
argument_list|(
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"interactive-p"
argument_list|,
argument|Finteractive_p
argument_list|,
argument|Sinteractive_p
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Return t if function in which this appears was called interactively.\n\ Also, input must be coming from the terminal."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
expr|struct
name|backtrace
operator|*
name|btp
block|;
specifier|register
name|Lisp_Object
name|fun
block|;
if|if
condition|(
operator|!
name|INTERACTIVE
condition|)
return|return
name|Qnil
return|;
end_expr_stmt

begin_comment
comment|/* Note that interactive-p takes UNEVALLED args      so that its own frame does not terminate this loop.  */
end_comment

begin_for
for|for
control|(
name|btp
operator|=
name|backtrace_list
init|;
name|btp
operator|&&
operator|(
name|btp
operator|->
name|nargs
operator|==
name|UNEVALLED
operator|||
name|EQ
argument_list|(
operator|*
name|btp
operator|->
name|function
argument_list|,
name|Qbytecode
argument_list|)
operator|)
condition|;
name|btp
operator|=
name|btp
operator|->
name|next
control|)
block|{}
end_for

begin_comment
comment|/* btp now points at the frame of the innermost function      that DOES eval its args.      If it is a built-in function (such as load or eval-region)      return nil.  */
end_comment

begin_expr_stmt
name|fun
operator|=
operator|*
name|btp
operator|->
name|function
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|fun
operator|=
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
end_while

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
return|return
name|Qnil
return|;
end_if

begin_comment
comment|/* btp points to the frame of a Lisp function that called interactive-p.      Return t if that function was called interactively.  */
end_comment

begin_if
if|if
condition|(
name|btp
operator|&&
name|btp
operator|->
name|next
operator|&&
name|EQ
argument_list|(
operator|*
name|btp
operator|->
name|next
operator|->
name|function
argument_list|,
name|Qcall_interactively
argument_list|)
condition|)
return|return
name|Qt
return|;
end_if

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"defun"
operator|,
name|Fdefun
operator|,
name|Sdefun
operator|,
literal|2
operator|,
name|UNEVALLED
operator|,
literal|0
operator|,
literal|"(defun NAME ARGLIST [DOCSTRING] BODY...) defines NAME as a function.\n\ The definition is (lambda ARGLIST [DOCSTRING] BODY...).\n\ See also the function  interactive ."
operator|)
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|fn_name
decl_stmt|;
specifier|register
name|Lisp_Object
name|defn
decl_stmt|;
name|fn_name
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|defn
operator|=
name|Fcons
argument_list|(
name|Qlambda
argument_list|,
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|defn
operator|=
name|Fpurecopy
argument_list|(
name|defn
argument_list|)
expr_stmt|;
name|Ffset
argument_list|(
name|fn_name
argument_list|,
name|defn
argument_list|)
expr_stmt|;
return|return
name|fn_name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"defmacro"
argument_list|,
argument|Fdefmacro
argument_list|,
argument|Sdefmacro
argument_list|,
literal|2
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(defmacro NAME ARGLIST [DOCSTRING] BODY...) defines NAME as a macro.\n\ The definition is (macro lambda ARGLIST [DOCSTRING] BODY...).\n\ When the macro is called, as in (NAME ARGS...),\n\ the function (lambda ARGLIST BODY...) is applied to\n\ the list ARGS... as it appears in the expression,\n\ and the result should be a form to be evaluated instead of the original."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|fn_name
decl_stmt|;
specifier|register
name|Lisp_Object
name|defn
decl_stmt|;
name|fn_name
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|defn
operator|=
name|Fcons
argument_list|(
name|Qmacro
argument_list|,
name|Fcons
argument_list|(
name|Qlambda
argument_list|,
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|defn
operator|=
name|Fpurecopy
argument_list|(
name|defn
argument_list|)
expr_stmt|;
name|Ffset
argument_list|(
name|fn_name
argument_list|,
name|defn
argument_list|)
expr_stmt|;
return|return
name|fn_name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"defvar"
argument_list|,
argument|Fdefvar
argument_list|,
argument|Sdefvar
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(defvar SYMBOL INITVALUE DOCSTRING) defines SYMBOL as an advertised variable.\n\ INITVALUE is evaluated, and used to set SYMBOL, only if SYMBOL's value is void.\n\ INITVALUE and DOCSTRING are optional.\n\ If DOCSTRING starts with *, this variable is identified as a user option.\n\ If INITVALUE is missing, SYMBOL's value is not set."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|sym
decl_stmt|,
name|tem
decl_stmt|;
name|sym
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fboundp
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|Fset
argument_list|(
name|sym
argument_list|,
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|tem
operator|=
name|Fpurecopy
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|sym
argument_list|,
name|Qvariable_documentation
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"defconst"
argument_list|,
argument|Fdefconst
argument_list|,
argument|Sdefconst
argument_list|,
literal|2
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(defconst SYMBOL INITVALUE DOCSTRING) defines SYMBOL as an advertised constant.\n\ The intent is that programs do not change this value (but users may).\n\ Always sets the value of SYMBOL to the result of evalling INITVALUE.\n\ DOCSTRING is optional.\n\ If DOCSTRING starts with *, this variable is identified as a user option."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|sym
decl_stmt|,
name|tem
decl_stmt|;
name|sym
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|Fset
argument_list|(
name|sym
argument_list|,
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|tem
operator|=
name|Fpurecopy
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|sym
argument_list|,
name|Qvariable_documentation
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"user-variable-p"
argument_list|,
argument|Fuser_variable_p
argument_list|,
argument|Suser_variable_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Returns t if VARIABLE is intended to be set and modified by users,\n\ as opposed to by programs.\n\ Determined by whether the first character of the documentation\n\ for the variable is \"*\""
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|variable
operator|)
name|Lisp_Object
name|variable
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|documentation
decl_stmt|;
name|documentation
operator|=
name|Fget
argument_list|(
name|variable
argument_list|,
name|Qvariable_documentation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|documentation
argument_list|)
operator|==
name|Lisp_String
operator|)
operator|&&
operator|(
operator|(
name|unsigned
name|char
operator|)
name|XSTRING
argument_list|(
name|documentation
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
condition|)
return|return
name|Qt
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"let*"
argument_list|,
argument|FletX
argument_list|,
argument|SletX
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(let* VARLIST BODY...) binds variables according to VARLIST then executes BODY.\n\ The value of the last form in BODY is returned.\n\ Each element of VARLIST is a symbol (which is bound to NIL)\n\ or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).\n\ Each VALUEFORM can refer to the symbols already bound by this VARLIST."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|varlist
decl_stmt|,
name|val
decl_stmt|,
name|elt
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|;
name|GCPRO3
argument_list|(
name|args
argument_list|,
name|elt
argument_list|,
name|varlist
argument_list|)
expr_stmt|;
name|varlist
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|varlist
argument_list|)
condition|)
block|{
name|elt
operator|=
name|Fcar
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|specbind
argument_list|(
name|elt
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Fcar
argument_list|(
name|elt
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|varlist
operator|=
name|Fcdr
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"let"
argument_list|,
argument|Flet
argument_list|,
argument|Slet
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(let VARLIST BODY...) binds variables according to VARLIST then executes BODY.\n\ The value of the last form in BODY is returned.\n\ Each element of VARLIST is a symbol (which is bound to NIL)\n\ or a list (SYMBOL VALUEFORM) (which binds SYMBOL to the value of VALUEFORM).\n\ All the VALUEFORMs are evalled before any symbols are bound."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
modifier|*
name|temps
decl_stmt|,
name|tem
decl_stmt|;
specifier|register
name|Lisp_Object
name|elt
decl_stmt|,
name|varlist
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|int
name|argnum
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|varlist
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Make space to hold the values to give the bound variables */
name|elt
operator|=
name|Flength
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
name|temps
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|XFASTINT
argument_list|(
name|elt
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the values and store them in `temps' */
name|GCPRO2
argument_list|(
name|args
argument_list|,
operator|*
name|temps
argument_list|)
expr_stmt|;
name|gcpro2
operator|.
name|nvars
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
operator|!
name|NULL
argument_list|(
name|varlist
argument_list|)
condition|;
name|varlist
operator|=
name|Fcdr
argument_list|(
name|varlist
argument_list|)
control|)
block|{
name|elt
operator|=
name|Fcar
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|temps
index|[
name|argnum
operator|++
index|]
operator|=
name|Qnil
expr_stmt|;
else|else
name|temps
index|[
name|argnum
operator|++
index|]
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcpro2
operator|.
name|nvars
operator|=
name|argnum
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
name|varlist
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
operator|!
name|NULL
argument_list|(
name|varlist
argument_list|)
condition|;
name|varlist
operator|=
name|Fcdr
argument_list|(
name|varlist
argument_list|)
control|)
block|{
name|elt
operator|=
name|Fcar
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
name|tem
operator|=
name|temps
index|[
name|argnum
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|specbind
argument_list|(
name|elt
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|else
name|specbind
argument_list|(
name|Fcar
argument_list|(
name|elt
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
name|elt
operator|=
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|elt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"while"
argument_list|,
argument|Fwhile
argument_list|,
argument|Swhile
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(while TEST BODY...) if TEST yields non-NIL, execute the BODY forms and repeat."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|test
decl_stmt|,
name|body
decl_stmt|,
name|tem
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|GCPRO2
argument_list|(
name|test
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|test
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|body
operator|=
name|Fcdr
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
name|tem
operator|=
name|Feval
argument_list|(
name|test
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|Fprogn
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"macroexpand"
argument_list|,
name|Fmacroexpand
argument_list|,
name|Smacroexpand
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"If FORM is a macro call, expand it.\n\ If the result of expansion is another macro call, expand it, etc.\n\ Return the ultimate expansion.\n\ The second optional arg ENVIRONMENT species an environment of macro\n\ definitions to shadow the loaded ones for use in file byte-compilation."
argument_list|)
argument_list|(
name|form
argument_list|,
name|env
argument_list|)
specifier|register
name|Lisp_Object
name|form
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|env
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|expander
decl_stmt|,
name|sym
decl_stmt|,
name|def
decl_stmt|,
name|tem
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Come back here each time we expand a macro call, 	 in case it expands into another macro call.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|form
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
break|break;
name|sym
operator|=
name|XCONS
argument_list|(
name|form
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|sym
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
break|break;
comment|/* Trace symbols aliases to other symbols 	 until we get a symbol that is not an alias.  */
while|while
condition|(
literal|1
condition|)
block|{
name|tem
operator|=
name|Fassq
argument_list|(
name|sym
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|def
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|def
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|EQ
argument_list|(
name|def
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|sym
operator|=
name|def
expr_stmt|;
else|else
break|break;
block|}
else|else
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Cons
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|sym
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* Right now TEM is the result from SYM in ENV, 	 and if TEM is nil then DEF is SYM's function definition.  */
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
comment|/* SYM is not mentioned in ENV. 	     Look at its function definition.  */
if|if
condition|(
name|EQ
argument_list|(
name|def
argument_list|,
name|Qunbound
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|def
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
comment|/* Not defined or definition not suitable */
break|break;
if|if
condition|(
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|def
argument_list|)
operator|->
name|car
argument_list|,
name|Qautoload
argument_list|)
condition|)
block|{
comment|/* Autoloading function: will it be a macro when loaded?  */
name|tem
operator|=
name|Fnth
argument_list|(
name|make_number
argument_list|(
literal|4
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
break|break;
comment|/* Yes, load it and try again.  */
name|do_autoload
argument_list|(
name|def
argument_list|,
name|sym
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|def
argument_list|)
operator|->
name|car
argument_list|,
name|Qmacro
argument_list|)
condition|)
break|break;
else|else
name|expander
operator|=
name|XCONS
argument_list|(
name|def
argument_list|)
operator|->
name|cdr
expr_stmt|;
block|}
else|else
block|{
name|expander
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|expander
argument_list|)
condition|)
break|break;
block|}
name|form
operator|=
name|Fapply
argument_list|(
name|expander
argument_list|,
name|XCONS
argument_list|(
name|form
argument_list|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
block|}
return|return
name|form
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"catch"
argument_list|,
argument|Fcatch
argument_list|,
argument|Scatch
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(catch TAG BODY...) perform BODY allowing nonlocal exits using (throw TAG).\n\ TAG is evalled to get the tag to use.  throw  to that tag exits this catch.\n\ Then the BODY is executed.  If no  throw  happens, the value of the last BODY\n\ form is returned from  catch.  If a  throw  happens, it specifies the value to\n\ return from  catch."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
modifier|*
name|gcpro
init|=
name|gcprolist
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|struct
name|catchtag
name|c
decl_stmt|;
name|struct
name|handler
modifier|*
name|hlist
init|=
name|handlerlist
decl_stmt|;
name|c
operator|.
name|tag
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|Qnil
expr_stmt|;
name|c
operator|.
name|backlist
operator|=
name|backtrace_list
expr_stmt|;
name|c
operator|.
name|lisp_eval_depth
operator|=
name|lisp_eval_depth
expr_stmt|;
if|if
condition|(
name|_setjmp
argument_list|(
name|c
operator|.
name|jmp
argument_list|)
condition|)
block|{
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
name|handlerlist
operator|=
name|hlist
expr_stmt|;
name|backtrace_list
operator|=
name|c
operator|.
name|backlist
expr_stmt|;
name|lisp_eval_depth
operator|=
name|c
operator|.
name|lisp_eval_depth
expr_stmt|;
name|gcprolist
operator|=
name|gcpro
expr_stmt|;
name|GCPRO1
argument_list|(
name|c
operator|.
name|val
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|c
operator|.
name|val
return|;
block|}
name|c
operator|.
name|next
operator|=
name|catchlist
expr_stmt|;
name|catchlist
operator|=
operator|&
name|c
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* Set up a catch, then call C function `func'.  This is how catches are done from within C code. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|internal_catch
argument_list|(
name|tag
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
name|Lisp_Object
name|tag
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Lisp_Object
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
modifier|*
name|gcpro
init|=
name|gcprolist
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|struct
name|catchtag
name|c
decl_stmt|;
name|struct
name|handler
modifier|*
name|hlist
init|=
name|handlerlist
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|c
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|Qnil
expr_stmt|;
name|c
operator|.
name|backlist
operator|=
name|backtrace_list
expr_stmt|;
name|c
operator|.
name|lisp_eval_depth
operator|=
name|lisp_eval_depth
expr_stmt|;
if|if
condition|(
name|_setjmp
argument_list|(
name|c
operator|.
name|jmp
argument_list|)
condition|)
block|{
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
name|handlerlist
operator|=
name|hlist
expr_stmt|;
name|backtrace_list
operator|=
name|c
operator|.
name|backlist
expr_stmt|;
name|lisp_eval_depth
operator|=
name|c
operator|.
name|lisp_eval_depth
expr_stmt|;
name|gcprolist
operator|=
name|gcpro
expr_stmt|;
name|GCPRO1
argument_list|(
name|c
operator|.
name|val
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|c
operator|.
name|val
return|;
block|}
name|c
operator|.
name|next
operator|=
name|catchlist
expr_stmt|;
name|catchlist
operator|=
operator|&
name|c
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"throw"
argument_list|,
name|Fthrow
argument_list|,
name|Sthrow
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"(throw TAG VALUE): throw to the catch for TAG and return VALUE from it.\n\ Both TAG and VALUE are evalled."
argument_list|)
argument_list|(
name|tag
argument_list|,
name|val
argument_list|)
specifier|register
name|Lisp_Object
name|tag
operator|,
name|val
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|catchtag
modifier|*
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tag
argument_list|)
condition|)
for|for
control|(
name|c
operator|=
name|catchlist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|c
operator|->
name|tag
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|c
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|_longjmp
argument_list|(
name|c
operator|->
name|jmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|tag
operator|=
name|Fsignal
argument_list|(
name|Qno_catch
argument_list|,
name|Fcons
argument_list|(
name|tag
argument_list|,
name|Fcons
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"unwind-protect"
argument_list|,
argument|Funwind_protect
argument_list|,
argument|Sunwind_protect
argument_list|,
literal|1
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"(unwind-protect BODYFORM UNWINDFORMS...) do BODYFORM, protecting with UNWINDFORMS.\n\ If BODYFORM completes normally, its value is returned\n\ after executing the UNWINDFORMS.\n\ If BODYFORM exits nonlocally, the UNWINDFORMS are executed anyway."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|record_unwind_protect
argument_list|(
literal|0
argument_list|,
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|specpdl_ptr
operator|-
literal|1
operator|)
operator|->
name|symbol
operator|=
name|Qnil
expr_stmt|;
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|GCPRO1
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|struct
name|handler
modifier|*
name|handlerlist
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"condition-case"
argument_list|,
argument|Fcondition_case
argument_list|,
argument|Scondition_case
argument_list|,
literal|2
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Regain control when an error is signaled.\n\  (condition-case VAR BODYFORM HANDLERS...)\n\ executes BODYFORM and returns its value if no error happens.\n\ Each element of HANDLERS looks like (CONDITION-NAME BODY...)\n\ where the BODY is made of Lisp expressions.\n\ The handler is applicable to an error\n\ if CONDITION-NAME is one of the error's condition names.\n\ When a handler handles an error,\n\ control returns to the condition-case and the handler BODY... is executed\n\ with VAR bound to (SIGNALED-CONDITIONS . SIGNAL-DATA).\n\ The value of the last BODY form is returned from the condition-case.\n\ See SIGNAL for more info."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
modifier|*
name|gcpro
init|=
name|gcprolist
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|struct
name|catchtag
name|c
decl_stmt|;
name|struct
name|handler
name|h
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|.
name|tag
operator|=
name|Qnil
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|Qnil
expr_stmt|;
name|c
operator|.
name|backlist
operator|=
name|backtrace_list
expr_stmt|;
name|c
operator|.
name|lisp_eval_depth
operator|=
name|lisp_eval_depth
expr_stmt|;
if|if
condition|(
name|_setjmp
argument_list|(
name|c
operator|.
name|jmp
argument_list|)
condition|)
block|{
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
name|handlerlist
operator|=
name|h
operator|.
name|next
expr_stmt|;
name|backtrace_list
operator|=
name|c
operator|.
name|backlist
expr_stmt|;
name|lisp_eval_depth
operator|=
name|c
operator|.
name|lisp_eval_depth
expr_stmt|;
name|gcprolist
operator|=
name|gcpro
expr_stmt|;
name|GCPRO2
argument_list|(
name|c
operator|.
name|val
argument_list|,
name|h
operator|.
name|var
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|h
operator|.
name|var
argument_list|)
condition|)
name|specbind
argument_list|(
name|h
operator|.
name|var
argument_list|,
name|Fcdr
argument_list|(
name|c
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|c
operator|.
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|c
operator|.
name|next
operator|=
name|catchlist
expr_stmt|;
name|catchlist
operator|=
operator|&
name|c
expr_stmt|;
name|h
operator|.
name|var
operator|=
name|Fcar
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|h
operator|.
name|handler
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|val
operator|=
name|h
operator|.
name|handler
init|;
name|NULL
argument_list|(
name|val
argument_list|)
condition|;
name|val
operator|=
name|Fcdr
argument_list|(
name|val
argument_list|)
control|)
block|{
name|tem
operator|=
name|Fcar
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|LISTP
argument_list|(
name|tem
argument_list|)
operator|||
operator|(
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|!=
name|Lisp_Symbol
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"Illegal condition handler"
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
name|h
operator|.
name|next
operator|=
name|handlerlist
expr_stmt|;
name|h
operator|.
name|tag
operator|=
operator|&
name|c
expr_stmt|;
name|handlerlist
operator|=
operator|&
name|h
expr_stmt|;
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
name|handlerlist
operator|=
name|h
operator|.
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_decl_stmt
name|Lisp_Object
name|internal_condition_case
argument_list|(
name|bfun
argument_list|,
name|handlers
argument_list|,
name|hfun
argument_list|)
name|Lisp_Object
argument_list|(
operator|*
name|bfun
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|handlers
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Lisp_Object
function_decl|(
modifier|*
name|hfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|struct
name|gcpro
modifier|*
name|gcpro
init|=
name|gcprolist
decl_stmt|;
name|struct
name|catchtag
name|c
decl_stmt|;
name|struct
name|handler
name|h
decl_stmt|;
name|c
operator|.
name|tag
operator|=
name|Qnil
expr_stmt|;
name|c
operator|.
name|val
operator|=
name|Qnil
expr_stmt|;
name|c
operator|.
name|backlist
operator|=
name|backtrace_list
expr_stmt|;
name|c
operator|.
name|lisp_eval_depth
operator|=
name|lisp_eval_depth
expr_stmt|;
if|if
condition|(
name|_setjmp
argument_list|(
name|c
operator|.
name|jmp
argument_list|)
condition|)
block|{
name|backtrace_list
operator|=
name|c
operator|.
name|backlist
expr_stmt|;
name|catchlist
operator|=
operator|&
name|c
expr_stmt|;
name|handlerlist
operator|=
operator|&
name|h
expr_stmt|;
comment|/* Unbind with handler still in effect. 	 This is so that errors in unwind-protect unwind forms 	 do first not escape this contour. 	 But remove any handlers established within this one, 	 since their stack frames no longer exist.  */
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
name|handlerlist
operator|=
name|h
operator|.
name|next
expr_stmt|;
name|lisp_eval_depth
operator|=
name|c
operator|.
name|lisp_eval_depth
expr_stmt|;
name|gcprolist
operator|=
name|gcpro
expr_stmt|;
return|return
call|(
modifier|*
name|hfun
call|)
argument_list|(
name|Fcdr
argument_list|(
name|c
operator|.
name|val
argument_list|)
argument_list|)
return|;
block|}
name|c
operator|.
name|next
operator|=
name|catchlist
expr_stmt|;
name|catchlist
operator|=
operator|&
name|c
expr_stmt|;
name|h
operator|.
name|handler
operator|=
name|handlers
expr_stmt|;
name|h
operator|.
name|var
operator|=
name|Qnil
expr_stmt|;
name|h
operator|.
name|next
operator|=
name|handlerlist
expr_stmt|;
name|h
operator|.
name|tag
operator|=
operator|&
name|c
expr_stmt|;
name|handlerlist
operator|=
operator|&
name|h
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|bfun
call|)
argument_list|()
expr_stmt|;
name|catchlist
operator|=
name|c
operator|.
name|next
expr_stmt|;
name|handlerlist
operator|=
name|h
operator|.
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_function_decl
specifier|static
name|Lisp_Object
name|find_handler_clause
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"signal"
argument_list|,
argument|Fsignal
argument_list|,
argument|Ssignal
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Signal an error.  Args are SIGNAL-NAME, and associated DATA.\n\ A signal name is a symbol with an  error-conditions  property\n\ that is a list of condition names.\n\ A handler for any of those names will get to handle this signal.\n\ The symbol  error  should always be one of them.\n\ \n\ DATA should be a list.  Its elements are printed as part of the error message.\n\ If the signal is handled, DATA is made available to the handler.\n\ See  condition-case."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sig
operator|,
name|data
operator|)
name|Lisp_Object
name|sig
operator|,
name|data
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|handler
modifier|*
name|allhandlers
init|=
name|handlerlist
decl_stmt|;
name|Lisp_Object
name|conditions
decl_stmt|;
specifier|extern
name|int
name|gc_in_progress
decl_stmt|;
specifier|extern
name|int
name|waiting_for_input
decl_stmt|;
name|Lisp_Object
name|debugger_value
decl_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gc_in_progress
operator|||
name|waiting_for_input
condition|)
name|abort
argument_list|()
expr_stmt|;
name|conditions
operator|=
name|Fget
argument_list|(
name|sig
argument_list|,
name|Qerror_conditions
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|handlerlist
condition|;
name|handlerlist
operator|=
name|handlerlist
operator|->
name|next
control|)
block|{
specifier|register
name|Lisp_Object
name|clause
decl_stmt|;
name|clause
operator|=
name|find_handler_clause
argument_list|(
name|handlerlist
operator|->
name|handler
argument_list|,
name|conditions
argument_list|,
name|sig
argument_list|,
name|data
argument_list|,
operator|&
name|debugger_value
argument_list|)
expr_stmt|;
comment|/* If have called debugger and user wants to continue, 	 just return nil.  */
if|if
condition|(
name|EQ
argument_list|(
name|clause
argument_list|,
name|Qlambda
argument_list|)
condition|)
return|return
name|debugger_value
return|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|clause
argument_list|)
condition|)
block|{
name|struct
name|handler
modifier|*
name|h
init|=
name|handlerlist
decl_stmt|;
name|handlerlist
operator|=
name|allhandlers
expr_stmt|;
name|h
operator|->
name|tag
operator|->
name|val
operator|=
name|Fcons
argument_list|(
name|clause
argument_list|,
name|Fcons
argument_list|(
name|sig
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|_longjmp
argument_list|(
name|h
operator|->
name|tag
operator|->
name|jmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|handlerlist
operator|=
name|allhandlers
expr_stmt|;
name|debugger
argument_list|(
name|sig
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Value of Qlambda means we have called debugger and    user has continued.  Store value returned fromdebugger    into *debugger_value_ptr */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|find_handler_clause
parameter_list|(
name|handlers
parameter_list|,
name|conditions
parameter_list|,
name|sig
parameter_list|,
name|data
parameter_list|,
name|debugger_value_ptr
parameter_list|)
name|Lisp_Object
name|handlers
decl_stmt|,
name|conditions
decl_stmt|,
name|sig
decl_stmt|,
name|data
decl_stmt|;
name|Lisp_Object
modifier|*
name|debugger_value_ptr
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|h
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem1
decl_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|handlers
argument_list|,
name|Qt
argument_list|)
condition|)
comment|/* t is used by handlers for all conditions, set up by C code.  */
return|return
name|Qt
return|;
if|if
condition|(
name|EQ
argument_list|(
name|handlers
argument_list|,
name|Qerror
argument_list|)
condition|)
comment|/* error is used similarly, but means display a backtrace too */
block|{
if|if
condition|(
name|stack_trace_on_error
condition|)
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Backtrace*"
argument_list|,
name|Fbacktrace
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|sig
argument_list|,
name|Qquit
argument_list|)
condition|?
name|debug_on_quit
else|:
name|debug_on_error
condition|)
block|{
operator|*
name|debugger_value_ptr
operator|=
name|call_debugger
argument_list|(
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|sig
argument_list|,
name|data
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qlambda
return|;
block|}
return|return
name|Qt
return|;
block|}
for|for
control|(
name|h
operator|=
name|handlers
init|;
name|LISTP
argument_list|(
name|h
argument_list|)
condition|;
name|h
operator|=
name|Fcdr
argument_list|(
name|h
argument_list|)
control|)
block|{
name|tem1
operator|=
name|Fcar
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|tem1
argument_list|)
condition|)
continue|continue;
name|tem
operator|=
name|Fmemq
argument_list|(
name|Fcar
argument_list|(
name|tem1
argument_list|)
argument_list|,
name|conditions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|tem1
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_function

begin_comment
comment|/* dump an error message; called like printf */
end_comment

begin_comment
comment|/* VARARGS 1 */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|m
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
name|char
modifier|*
name|m
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|m
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qerror
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|buf
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"commandp"
argument_list|,
argument|Fcommandp
argument_list|,
argument|Scommandp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if FUNCTION makes provisions for interactive calling.\n\ This means it contains a description for how to read arguments to give it.\n\ The value is nil for an invalid function or a symbol with no function definition.\n\ \n\ Interactively callable functions include strings (treated as keyboard macros),\n\ lambda-expressions that contain a top-level call to  interactive ,\n\ autoload definitions made by  autoload  with non-nil fourth argument,\n\ and some of the built-in functions of Lisp.\n\ \n\ Also, a symbol is commandp if its function definition is commandp."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|function
operator|)
name|Lisp_Object
name|function
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|fun
decl_stmt|;
specifier|register
name|Lisp_Object
name|funcar
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|fun
operator|=
name|function
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
literal|10
condition|)
return|return
name|Qnil
return|;
name|tem
operator|=
name|Ffboundp
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|fun
operator|=
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|prompt
condition|)
return|return
name|Qt
return|;
else|else
return|return
name|Qnil
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Vector
operator|||
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Qt
return|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|fun
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|funcar
operator|=
name|Fcar
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|funcar
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qlambda
argument_list|)
condition|)
return|return
name|Fassq
argument_list|(
name|Qinteractive
argument_list|,
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qmocklisp
argument_list|)
condition|)
return|return
name|Qt
return|;
comment|/* All mocklisp functions can be called interactively */
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qautoload
argument_list|)
condition|)
return|return
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"autoload"
argument_list|,
argument|Fautoload
argument_list|,
argument|Sautoload
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Define FUNCTION to autoload from FILE.\n\ FUNCTION is a symbol; FILE is a file name string to pass to  load.\n\ Third arg DOCSTRING is documentation for the function.\n\ Fourth arg INTERACTIVE if non-nil says function can be called interactively.\n\ Fifth arg MACRO if non-nil says the function is really a macro.\n\ Third through fifth args give info about the real definition.\n\ They default to nil.\n\ If FUNCTION is already defined, this does nothing and returns nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|function
operator|,
name|file
operator|,
name|docstring
operator|,
name|interactive
operator|,
name|macro
operator|)
name|Lisp_Object
name|function
operator|,
name|file
operator|,
name|docstring
operator|,
name|interactive
operator|,
name|macro
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|4
index|]
decl_stmt|;
endif|#
directive|endif
name|CHECK_SYMBOL
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If function is defined and not as an autoload, don't override */
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|XSYMBOL
argument_list|(
name|function
argument_list|)
operator|->
name|function
argument_list|,
name|Qunbound
argument_list|)
operator|&&
operator|!
operator|(
name|XTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|function
argument_list|)
operator|->
name|function
argument_list|)
operator|==
name|Lisp_Cons
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|function
argument_list|)
operator|->
name|function
argument_list|)
operator|->
name|car
argument_list|,
name|Qautoload
argument_list|)
operator|)
condition|)
return|return
name|Qnil
return|;
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|args
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|docstring
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|interactive
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|macro
expr_stmt|;
return|return
name|Ffset
argument_list|(
name|function
argument_list|,
name|Fcons
argument_list|(
name|Qautoload
argument_list|,
name|Flist
argument_list|(
literal|4
argument_list|,
operator|&
name|args
argument_list|)
argument_list|)
argument_list|)
return|;
else|#
directive|else
comment|/* NO_ARG_ARRAY */
return|return
name|Ffset
argument_list|(
name|function
argument_list|,
name|Fcons
argument_list|(
name|Qautoload
argument_list|,
name|Flist
argument_list|(
literal|4
argument_list|,
operator|&
name|file
argument_list|)
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
comment|/* not NO_ARG_ARRAY */
block|}
end_block

begin_function
name|Lisp_Object
name|un_autoload
parameter_list|(
name|oldqueue
parameter_list|)
name|Lisp_Object
name|oldqueue
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|queue
decl_stmt|,
name|first
decl_stmt|,
name|second
decl_stmt|;
comment|/* Queue to unwind is current value of Vautoload_queue.      oldqueue is the shadowed value to leave in Vautoload_queue.  */
name|queue
operator|=
name|Vautoload_queue
expr_stmt|;
name|Vautoload_queue
operator|=
name|oldqueue
expr_stmt|;
while|while
condition|(
name|LISTP
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|first
operator|=
name|Fcar
argument_list|(
name|queue
argument_list|)
expr_stmt|;
name|second
operator|=
name|Fcdr
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
name|Fcar
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|second
argument_list|,
name|Qnil
argument_list|)
condition|)
name|Vfeatures
operator|=
name|first
expr_stmt|;
else|else
name|Ffset
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|queue
operator|=
name|Fcdr
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|do_autoload
argument_list|(
argument|fundef
argument_list|,
argument|funname
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|fundef
decl_stmt|,
name|funname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|fun
decl_stmt|,
name|val
decl_stmt|;
name|fun
operator|=
name|funname
expr_stmt|;
comment|/* Value saved here is to be restored into Vautoload_queue */
name|record_unwind_protect
argument_list|(
name|un_autoload
argument_list|,
name|Vautoload_queue
argument_list|)
expr_stmt|;
name|Vautoload_queue
operator|=
name|Qt
expr_stmt|;
name|Fload
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|fundef
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|,
name|noninteractive
condition|?
name|Qt
else|:
name|Qnil
argument_list|)
expr_stmt|;
comment|/* Once loading finishes, don't undo it.  */
name|Vautoload_queue
operator|=
name|Qt
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|val
operator|=
name|XSYMBOL
argument_list|(
name|fun
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
comment|/* Get the right kind of error! */
name|fun
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Cons
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|fun
argument_list|)
operator|->
name|car
argument_list|,
name|Qautoload
argument_list|)
condition|)
name|error
argument_list|(
literal|"Autoloading failed to define function %s"
argument_list|,
name|XSYMBOL
argument_list|(
name|funname
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"eval"
argument_list|,
argument|Feval
argument_list|,
argument|Seval
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Evaluate FORM and return its value."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|form
operator|)
name|Lisp_Object
name|form
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|fun
decl_stmt|,
name|val
decl_stmt|,
name|original_fun
decl_stmt|,
name|original_args
decl_stmt|;
name|Lisp_Object
name|funcar
decl_stmt|;
name|struct
name|backtrace
name|backtrace
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|form
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|Vmocklisp_arguments
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Fsymbol_value
argument_list|(
name|form
argument_list|)
return|;
name|val
operator|=
name|Fsymbol_value
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qt
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|form
argument_list|)
condition|)
return|return
name|form
return|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|consing_since_gc
operator|>
name|gc_cons_threshold
condition|)
block|{
name|GCPRO1
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Fgarbage_collect
argument_list|()
expr_stmt|;
name|UNGCPRO
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|lisp_eval_depth
operator|>
name|max_lisp_eval_depth
condition|)
block|{
if|if
condition|(
name|max_lisp_eval_depth
operator|<
literal|100
condition|)
name|max_lisp_eval_depth
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|lisp_eval_depth
operator|>
name|max_lisp_eval_depth
condition|)
name|error
argument_list|(
literal|"Lisp nesting exceeds max-lisp-eval-depth"
argument_list|)
expr_stmt|;
block|}
name|original_fun
operator|=
name|Fcar
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|original_args
operator|=
name|Fcdr
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|backtrace
operator|.
name|next
operator|=
name|backtrace_list
expr_stmt|;
name|backtrace_list
operator|=
operator|&
name|backtrace
expr_stmt|;
name|backtrace
operator|.
name|function
operator|=
operator|&
name|original_fun
expr_stmt|;
comment|/* This also protects them from gc */
name|backtrace
operator|.
name|args
operator|=
operator|&
name|original_args
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
name|UNEVALLED
expr_stmt|;
name|backtrace
operator|.
name|evalargs
operator|=
literal|1
expr_stmt|;
name|backtrace
operator|.
name|debug_on_exit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_on_next_call
condition|)
name|do_debug_on_call
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
comment|/* At this point, only original_fun and original_args      have values that will be used below */
name|retry
label|:
name|fun
operator|=
name|original_fun
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|val
operator|=
name|XSYMBOL
argument_list|(
name|fun
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
comment|/* Get the right kind of error! */
name|fun
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
name|Lisp_Object
name|numargs
decl_stmt|;
name|Lisp_Object
name|argvals
index|[
literal|5
index|]
decl_stmt|;
name|Lisp_Object
name|args_left
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|maxargs
decl_stmt|;
name|args_left
operator|=
name|original_args
expr_stmt|;
name|numargs
operator|=
name|Flength
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|<
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|min_args
operator|||
operator|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|>=
literal|0
operator|&&
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|<
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Fcons
argument_list|(
name|numargs
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|==
name|UNEVALLED
condition|)
block|{
name|backtrace
operator|.
name|evalargs
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|args_left
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|==
name|MANY
condition|)
block|{
comment|/* Pass a vector of evaluated arguments */
name|Lisp_Object
modifier|*
name|vals
decl_stmt|;
specifier|register
name|int
name|argnum
init|=
literal|0
decl_stmt|;
name|vals
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|GCPRO3
argument_list|(
name|args_left
argument_list|,
name|fun
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|gcpro3
operator|.
name|var
operator|=
name|vals
expr_stmt|;
name|gcpro3
operator|.
name|nvars
operator|=
name|XINT
argument_list|(
name|numargs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
block|{
name|vals
index|[
name|argnum
operator|++
index|]
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
name|backtrace
operator|.
name|args
operator|=
name|vals
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
name|XINT
argument_list|(
name|numargs
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|,
name|vals
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|GCPRO3
argument_list|(
name|args_left
argument_list|,
name|fun
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|gcpro3
operator|.
name|var
operator|=
name|argvals
expr_stmt|;
name|gcpro3
operator|.
name|nvars
operator|=
literal|5
expr_stmt|;
name|maxargs
operator|=
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxargs
condition|;
name|i
operator|++
operator|,
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
control|)
name|argvals
index|[
name|i
index|]
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args_left
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
name|backtrace
operator|.
name|args
operator|=
name|argvals
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
name|XINT
argument_list|(
name|numargs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|1
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|2
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|3
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|,
name|argvals
index|[
literal|2
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|4
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|,
name|argvals
index|[
literal|2
index|]
operator|,
name|argvals
index|[
literal|3
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|5
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|,
name|argvals
index|[
literal|2
index|]
operator|,
name|argvals
index|[
literal|3
index|]
operator|,
name|argvals
index|[
literal|4
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|fun
argument_list|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|funcar
operator|=
name|Fcar
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|funcar
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qautoload
argument_list|)
condition|)
block|{
name|do_autoload
argument_list|(
name|fun
argument_list|,
name|original_fun
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qmacro
argument_list|)
condition|)
name|val
operator|=
name|Feval
argument_list|(
name|Fapply
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|,
name|original_args
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qlambda
argument_list|)
condition|)
name|val
operator|=
name|apply_lambda
argument_list|(
name|fun
argument_list|,
name|original_args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qmocklisp
argument_list|)
condition|)
name|val
operator|=
name|ml_apply
argument_list|(
name|fun
argument_list|,
name|original_args
argument_list|)
expr_stmt|;
else|else
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|done
label|:
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|Vmocklisp_arguments
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qt
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|lisp_eval_depth
operator|--
expr_stmt|;
if|if
condition|(
name|backtrace
operator|.
name|debug_on_exit
condition|)
name|val
operator|=
name|call_debugger
argument_list|(
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|backtrace_list
operator|=
name|backtrace
operator|.
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"apply"
argument_list|,
argument|Fapply
argument_list|,
argument|Sapply
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Call FUNCTION with arguments being the elements of ARGS."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|original_fun
operator|,
name|original_args
operator|)
name|Lisp_Object
name|original_fun
operator|,
name|original_args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|fun
decl_stmt|;
name|Lisp_Object
name|funcar
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|struct
name|backtrace
name|backtrace
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|consing_since_gc
operator|>
name|gc_cons_threshold
condition|)
block|{
name|GCPRO2
argument_list|(
name|original_fun
argument_list|,
name|original_args
argument_list|)
expr_stmt|;
name|Fgarbage_collect
argument_list|()
expr_stmt|;
name|UNGCPRO
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|lisp_eval_depth
operator|>
name|max_lisp_eval_depth
condition|)
block|{
if|if
condition|(
name|max_lisp_eval_depth
operator|<
literal|100
condition|)
name|max_lisp_eval_depth
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|lisp_eval_depth
operator|>
name|max_lisp_eval_depth
condition|)
name|error
argument_list|(
literal|"Lisp nesting exceeds max-lisp-eval-depth"
argument_list|)
expr_stmt|;
block|}
name|backtrace
operator|.
name|next
operator|=
name|backtrace_list
expr_stmt|;
name|backtrace_list
operator|=
operator|&
name|backtrace
expr_stmt|;
name|backtrace
operator|.
name|function
operator|=
operator|&
name|original_fun
expr_stmt|;
comment|/* This also protects them */
name|backtrace
operator|.
name|args
operator|=
operator|&
name|original_args
expr_stmt|;
comment|/* from gc */
name|backtrace
operator|.
name|nargs
operator|=
name|MANY
expr_stmt|;
name|backtrace
operator|.
name|evalargs
operator|=
literal|0
expr_stmt|;
name|backtrace
operator|.
name|debug_on_exit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_on_next_call
condition|)
name|do_debug_on_call
argument_list|(
name|Qlambda
argument_list|)
expr_stmt|;
name|retry
label|:
name|fun
operator|=
name|original_fun
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|val
operator|=
name|XSYMBOL
argument_list|(
name|fun
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
comment|/* Get the right kind of error! */
name|fun
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
name|Lisp_Object
name|numargs
decl_stmt|;
name|Lisp_Object
name|argvals
index|[
literal|5
index|]
decl_stmt|;
specifier|register
name|Lisp_Object
name|args_left
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|maxargs
decl_stmt|;
name|args_left
operator|=
name|original_args
expr_stmt|;
name|numargs
operator|=
name|Flength
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|<
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|min_args
operator|||
operator|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|>=
literal|0
operator|&&
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|<
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Fcons
argument_list|(
name|numargs
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|==
name|UNEVALLED
condition|)
block|{
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|original_args
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|==
name|MANY
condition|)
block|{
comment|/* Pass a vector of evaluated arguments */
specifier|register
name|Lisp_Object
modifier|*
name|vals
decl_stmt|;
specifier|register
name|int
name|argnum
init|=
literal|0
decl_stmt|;
name|vals
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|args_left
argument_list|)
condition|)
block|{
name|vals
index|[
name|argnum
operator|++
index|]
operator|=
name|Fcar
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
block|}
name|backtrace
operator|.
name|args
operator|=
name|vals
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
name|argnum
expr_stmt|;
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|,
name|vals
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|maxargs
operator|=
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxargs
condition|;
name|i
operator|++
operator|,
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
control|)
name|argvals
index|[
name|i
index|]
operator|=
name|Fcar
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
name|backtrace
operator|.
name|args
operator|=
name|argvals
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
name|XINT
argument_list|(
name|numargs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|1
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|2
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|3
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|,
name|argvals
index|[
literal|2
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|4
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|,
name|argvals
index|[
literal|2
index|]
operator|,
name|argvals
index|[
literal|3
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|5
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|argvals
index|[
literal|0
index|]
operator|,
name|argvals
index|[
literal|1
index|]
operator|,
name|argvals
index|[
literal|2
index|]
operator|,
name|argvals
index|[
literal|3
index|]
operator|,
name|argvals
index|[
literal|4
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|fun
argument_list|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|funcar
operator|=
name|Fcar
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|funcar
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qautoload
argument_list|)
condition|)
block|{
name|do_autoload
argument_list|(
name|fun
argument_list|,
name|original_fun
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qlambda
argument_list|)
condition|)
name|val
operator|=
name|apply_lambda
argument_list|(
name|fun
argument_list|,
name|original_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qmocklisp
argument_list|)
condition|)
name|val
operator|=
name|ml_apply
argument_list|(
name|fun
argument_list|,
name|original_args
argument_list|)
expr_stmt|;
else|else
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|done
label|:
name|lisp_eval_depth
operator|--
expr_stmt|;
if|if
condition|(
name|backtrace
operator|.
name|debug_on_exit
condition|)
name|val
operator|=
name|call_debugger
argument_list|(
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|backtrace_list
operator|=
name|backtrace
operator|.
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Call function fn with argument arg */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Lisp_Object
name|call1
parameter_list|(
name|fn
parameter_list|,
name|arg
parameter_list|)
name|Lisp_Object
name|fn
decl_stmt|,
name|arg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|2
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|fn
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
return|return
name|Ffuncall
argument_list|(
literal|2
argument_list|,
name|args
argument_list|)
return|;
else|#
directive|else
comment|/* not NO_ARG_ARRAY */
return|return
name|Ffuncall
argument_list|(
literal|2
argument_list|,
operator|&
name|fn
argument_list|)
return|;
endif|#
directive|endif
comment|/* not NO_ARG_ARRAY */
block|}
end_function

begin_comment
comment|/* Call function fn with arguments arg, arg1 */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Lisp_Object
name|call2
parameter_list|(
name|fn
parameter_list|,
name|arg
parameter_list|,
name|arg1
parameter_list|)
name|Lisp_Object
name|fn
decl_stmt|,
name|arg
decl_stmt|,
name|arg1
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|3
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|fn
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg1
expr_stmt|;
return|return
name|Ffuncall
argument_list|(
literal|3
argument_list|,
name|args
argument_list|)
return|;
else|#
directive|else
comment|/* not NO_ARG_ARRAY */
return|return
name|Ffuncall
argument_list|(
literal|3
argument_list|,
operator|&
name|fn
argument_list|)
return|;
endif|#
directive|endif
comment|/* not NO_ARG_ARRAY */
block|}
end_function

begin_comment
comment|/* Call function fn with arguments arg, arg1, arg2 */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|Lisp_Object
name|call3
parameter_list|(
name|fn
parameter_list|,
name|arg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|Lisp_Object
name|fn
decl_stmt|,
name|arg
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|4
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|fn
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|arg2
expr_stmt|;
return|return
name|Ffuncall
argument_list|(
literal|4
argument_list|,
name|args
argument_list|)
return|;
else|#
directive|else
comment|/* not NO_ARG_ARRAY */
return|return
name|Ffuncall
argument_list|(
literal|4
argument_list|,
operator|&
name|fn
argument_list|)
return|;
endif|#
directive|endif
comment|/* not NO_ARG_ARRAY */
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"funcall"
argument_list|,
argument|Ffuncall
argument_list|,
argument|Sfuncall
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Call first argument as a function, passing remaining arguments to it.\n\ Thus,  (funcall 'cons 'x 'y)  returns  (x . y)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|fun
decl_stmt|;
name|Lisp_Object
name|funcar
decl_stmt|;
name|int
name|numargs
init|=
name|nargs
operator|-
literal|1
decl_stmt|;
name|Lisp_Object
name|lisp_numargs
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|struct
name|backtrace
name|backtrace
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|internal_args
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|consing_since_gc
operator|>
name|gc_cons_threshold
condition|)
block|{
name|GCPRO1
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
name|gcpro1
operator|.
name|nvars
operator|=
name|nargs
expr_stmt|;
name|Fgarbage_collect
argument_list|()
expr_stmt|;
name|UNGCPRO
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|lisp_eval_depth
operator|>
name|max_lisp_eval_depth
condition|)
block|{
if|if
condition|(
name|max_lisp_eval_depth
operator|<
literal|100
condition|)
name|max_lisp_eval_depth
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|lisp_eval_depth
operator|>
name|max_lisp_eval_depth
condition|)
name|error
argument_list|(
literal|"Lisp nesting exceeds max-lisp-eval-depth"
argument_list|)
expr_stmt|;
block|}
name|backtrace
operator|.
name|next
operator|=
name|backtrace_list
expr_stmt|;
name|backtrace_list
operator|=
operator|&
name|backtrace
expr_stmt|;
name|backtrace
operator|.
name|function
operator|=
operator|&
name|args
index|[
literal|0
index|]
expr_stmt|;
name|backtrace
operator|.
name|args
operator|=
operator|&
name|args
index|[
literal|1
index|]
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
name|nargs
operator|-
literal|1
expr_stmt|;
name|backtrace
operator|.
name|evalargs
operator|=
literal|0
expr_stmt|;
name|backtrace
operator|.
name|debug_on_exit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_on_next_call
condition|)
name|do_debug_on_call
argument_list|(
name|Qlambda
argument_list|)
expr_stmt|;
name|retry
label|:
name|fun
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|val
operator|=
name|XSYMBOL
argument_list|(
name|fun
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
comment|/* Get the right kind of error! */
name|fun
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
if|if
condition|(
name|numargs
operator|<
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|min_args
operator|||
operator|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|>=
literal|0
operator|&&
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|<
name|numargs
operator|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|lisp_numargs
argument_list|)
operator|=
name|numargs
expr_stmt|;
return|return
name|Fsignal
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Fcons
argument_list|(
name|lisp_numargs
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|==
name|UNEVALLED
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|==
name|MANY
condition|)
block|{
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|numargs
operator|,
name|args
operator|+
literal|1
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|>
name|numargs
condition|)
block|{
name|internal_args
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|args
operator|+
literal|1
argument_list|,
name|internal_args
argument_list|,
name|numargs
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|numargs
init|;
name|i
operator|<
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
condition|;
name|i
operator|++
control|)
name|internal_args
index|[
name|i
index|]
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
name|internal_args
operator|=
name|args
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|max_args
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|1
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|internal_args
index|[
literal|0
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|2
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|internal_args
index|[
literal|0
index|]
operator|,
name|internal_args
index|[
literal|1
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|3
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|internal_args
index|[
literal|0
index|]
operator|,
name|internal_args
index|[
literal|1
index|]
operator|,
name|internal_args
index|[
literal|2
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|4
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|internal_args
index|[
literal|0
index|]
operator|,
name|internal_args
index|[
literal|1
index|]
operator|,
name|internal_args
index|[
literal|2
index|]
operator|,
name|internal_args
index|[
literal|3
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|5
case|:
name|val
operator|=
operator|(
operator|*
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|function
operator|)
operator|(
name|internal_args
index|[
literal|0
index|]
operator|,
name|internal_args
index|[
literal|1
index|]
operator|,
name|internal_args
index|[
literal|2
index|]
operator|,
name|internal_args
index|[
literal|3
index|]
operator|,
name|internal_args
index|[
literal|4
index|]
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|fun
argument_list|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|funcar
operator|=
name|Fcar
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|funcar
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qlambda
argument_list|)
condition|)
name|val
operator|=
name|funcall_lambda
argument_list|(
name|fun
argument_list|,
name|numargs
argument_list|,
name|args
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qmocklisp
argument_list|)
condition|)
name|val
operator|=
name|ml_apply
argument_list|(
name|fun
argument_list|,
name|Flist
argument_list|(
name|numargs
argument_list|,
name|args
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|funcar
argument_list|,
name|Qautoload
argument_list|)
condition|)
block|{
name|do_autoload
argument_list|(
name|fun
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|done
label|:
name|lisp_eval_depth
operator|--
expr_stmt|;
if|if
condition|(
name|backtrace
operator|.
name|debug_on_exit
condition|)
name|val
operator|=
name|call_debugger
argument_list|(
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|backtrace_list
operator|=
name|backtrace
operator|.
name|next
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|apply_lambda
parameter_list|(
name|fun
parameter_list|,
name|args
parameter_list|,
name|eval_flag
parameter_list|)
name|Lisp_Object
name|fun
decl_stmt|,
name|args
decl_stmt|;
name|int
name|eval_flag
decl_stmt|;
block|{
name|Lisp_Object
name|args_left
decl_stmt|;
name|Lisp_Object
name|numargs
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|arg_vector
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|,
name|gcpro3
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|numargs
operator|=
name|Flength
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|arg_vector
operator|=
operator|(
name|Lisp_Object
operator|*
operator|)
name|alloca
argument_list|(
name|XINT
argument_list|(
name|numargs
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
expr_stmt|;
name|args_left
operator|=
name|args
expr_stmt|;
name|GCPRO3
argument_list|(
operator|*
name|arg_vector
argument_list|,
name|args_left
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|gcpro1
operator|.
name|nvars
operator|=
name|XINT
argument_list|(
name|numargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XINT
argument_list|(
name|numargs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|Fcar
argument_list|(
name|args_left
argument_list|)
operator|,
name|args_left
operator|=
name|Fcdr
argument_list|(
name|args_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval_flag
condition|)
name|tem
operator|=
name|Feval
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|arg_vector
index|[
name|i
index|]
operator|=
name|tem
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|eval_flag
condition|)
block|{
name|backtrace_list
operator|->
name|args
operator|=
name|arg_vector
expr_stmt|;
name|backtrace_list
operator|->
name|nargs
operator|=
name|i
expr_stmt|;
block|}
name|backtrace_list
operator|->
name|evalargs
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|funcall_lambda
argument_list|(
name|fun
argument_list|,
name|XINT
argument_list|(
name|numargs
argument_list|)
argument_list|,
name|arg_vector
argument_list|)
expr_stmt|;
comment|/* Do the debug-on-exit now, while arg_vector still exists.  */
if|if
condition|(
name|backtrace_list
operator|->
name|debug_on_exit
condition|)
name|tem
operator|=
name|call_debugger
argument_list|(
name|Fcons
argument_list|(
name|Qexit
argument_list|,
name|Fcons
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't do it again when we return to eval.  */
name|backtrace_list
operator|->
name|debug_on_exit
operator|=
literal|0
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|funcall_lambda
parameter_list|(
name|fun
parameter_list|,
name|nargs
parameter_list|,
name|arg_vector
parameter_list|)
name|Lisp_Object
name|fun
decl_stmt|;
name|int
name|nargs
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|arg_vector
decl_stmt|;
block|{
name|Lisp_Object
name|val
decl_stmt|,
name|tem
decl_stmt|;
specifier|register
name|Lisp_Object
name|syms_left
decl_stmt|;
name|Lisp_Object
name|numargs
decl_stmt|;
specifier|register
name|Lisp_Object
name|next
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|optional
init|=
literal|0
decl_stmt|,
name|rest
init|=
literal|0
decl_stmt|;
name|specbind
argument_list|(
name|Qmocklisp_arguments
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
comment|/* t means NOT mocklisp! */
name|XFASTINT
argument_list|(
name|numargs
argument_list|)
operator|=
name|nargs
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|syms_left
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
init|;
operator|!
name|NULL
argument_list|(
name|syms_left
argument_list|)
condition|;
name|syms_left
operator|=
name|Fcdr
argument_list|(
name|syms_left
argument_list|)
control|)
block|{
name|next
operator|=
name|Fcar
argument_list|(
name|syms_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|next
argument_list|,
name|Qand_rest
argument_list|)
condition|)
name|rest
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|next
argument_list|,
name|Qand_optional
argument_list|)
condition|)
name|optional
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rest
condition|)
block|{
name|specbind
argument_list|(
name|Fcar
argument_list|(
name|syms_left
argument_list|)
argument_list|,
name|Flist
argument_list|(
name|nargs
operator|-
name|i
argument_list|,
operator|&
name|arg_vector
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|nargs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
name|tem
operator|=
name|arg_vector
index|[
name|i
operator|++
index|]
expr_stmt|;
name|specbind
argument_list|(
name|next
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optional
condition|)
return|return
name|Fsignal
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Fcons
argument_list|(
name|numargs
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
name|specbind
argument_list|(
name|next
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
return|return
name|Fsignal
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Fcons
argument_list|(
name|numargs
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
return|;
name|val
operator|=
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|grow_specpdl
parameter_list|()
block|{
specifier|register
name|struct
name|specbinding
modifier|*
name|old
init|=
name|specpdl
decl_stmt|;
if|if
condition|(
name|specpdl_size
operator|>=
name|max_specpdl_size
condition|)
block|{
if|if
condition|(
name|max_specpdl_size
operator|<
literal|400
condition|)
name|max_specpdl_size
operator|=
literal|400
expr_stmt|;
if|if
condition|(
name|specpdl_size
operator|>=
name|max_specpdl_size
condition|)
block|{
name|Fsignal
argument_list|(
name|Qerror
argument_list|,
name|build_string
argument_list|(
literal|"Variable binding depth exceeds max-specpdl-size"
argument_list|)
argument_list|)
expr_stmt|;
name|max_specpdl_size
operator|*=
literal|2
expr_stmt|;
block|}
block|}
name|specpdl_size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|specpdl_size
operator|>
name|max_specpdl_size
condition|)
name|specpdl_size
operator|=
name|max_specpdl_size
expr_stmt|;
name|specpdl
operator|=
operator|(
expr|struct
name|specbinding
operator|*
operator|)
name|xrealloc
argument_list|(
name|specpdl
argument_list|,
name|specpdl_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|specbinding
argument_list|)
argument_list|)
expr_stmt|;
name|specpdl_ptr
operator|+=
name|specpdl
operator|-
name|old
expr_stmt|;
block|}
end_function

begin_function
name|void
name|specbind
parameter_list|(
name|symbol
parameter_list|,
name|value
parameter_list|)
name|Lisp_Object
name|symbol
decl_stmt|,
name|value
decl_stmt|;
block|{
if|if
condition|(
name|specpdl_ptr
operator|==
name|specpdl
operator|+
name|specpdl_size
condition|)
name|grow_specpdl
argument_list|()
expr_stmt|;
name|specpdl_ptr
operator|->
name|symbol
operator|=
name|symbol
expr_stmt|;
name|specpdl_ptr
operator|->
name|old_value
operator|=
name|EQ
argument_list|(
name|XSYMBOL
argument_list|(
name|symbol
argument_list|)
operator|->
name|value
argument_list|,
name|Qunbound
argument_list|)
condition|?
name|Qunbound
else|:
name|Fsymbol_value
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
name|specpdl_ptr
operator|++
expr_stmt|;
name|Fset
argument_list|(
name|symbol
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|record_unwind_protect
argument_list|(
name|function
argument_list|,
name|arg
argument_list|)
name|Lisp_Object
argument_list|(
operator|*
name|function
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|specpdl_ptr
operator|==
name|specpdl
operator|+
name|specpdl_size
condition|)
name|grow_specpdl
argument_list|()
expr_stmt|;
name|XSETTYPE
argument_list|(
name|specpdl_ptr
operator|->
name|symbol
argument_list|,
name|Lisp_Internal_Function
argument_list|)
expr_stmt|;
name|XSETFUNCTION
argument_list|(
name|specpdl_ptr
operator|->
name|symbol
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|specpdl_ptr
operator|->
name|old_value
operator|=
name|arg
expr_stmt|;
name|specpdl_ptr
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|void
name|unbind_to
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|struct
name|specbinding
modifier|*
name|downto
init|=
name|specpdl
operator|+
name|count
decl_stmt|;
name|int
name|quitf
init|=
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
decl_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
name|specpdl_ptr
operator|!=
name|downto
condition|)
block|{
operator|--
name|specpdl_ptr
expr_stmt|;
comment|/* Note that a "binding" of nil is really an unwind protect, 	so in that case the "old value" is a list of forms to evaluate.  */
if|if
condition|(
name|NULL
argument_list|(
name|specpdl_ptr
operator|->
name|symbol
argument_list|)
condition|)
name|Fprogn
argument_list|(
name|specpdl_ptr
operator|->
name|old_value
argument_list|)
expr_stmt|;
comment|/* a "binding" of a Lisp_Internal_Function (rather than a symbol) 	means to call that function. 	This is used when C code makes an unwind-protect.  */
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|specpdl_ptr
operator|->
name|symbol
argument_list|)
operator|==
name|Lisp_Internal_Function
condition|)
operator|(
operator|*
name|XFUNCTION
argument_list|(
name|specpdl_ptr
operator|->
name|symbol
argument_list|)
operator|)
operator|(
name|specpdl_ptr
operator|->
name|old_value
operator|)
expr_stmt|;
else|else
name|Fset
argument_list|(
name|specpdl_ptr
operator|->
name|symbol
argument_list|,
name|specpdl_ptr
operator|->
name|old_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
operator|&&
name|quitf
condition|)
name|Vquit_flag
operator|=
name|Qt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the value of symbol's global binding, even if that binding  is not now dynamically visible.  This is used in turning per-buffer bindings on and off */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"global-value"
argument_list|,
argument|Fglobal_value
argument_list|,
argument|Sglobal_value
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the global value of VARIABLE, even if other bindings of it exist currently.\n\ Normal evaluation of VARIABLE would get the innermost binding."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|symbol
operator|)
name|Lisp_Object
name|symbol
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|specbinding
modifier|*
name|ptr
init|=
name|specpdl
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ptr
operator|!=
name|specpdl_ptr
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|ptr
operator|->
name|symbol
argument_list|,
name|symbol
argument_list|)
condition|)
return|return
name|ptr
operator|->
name|old_value
return|;
block|}
return|return
name|Fsymbol_value
argument_list|(
name|symbol
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"global-set"
argument_list|,
argument|Fglobal_set
argument_list|,
argument|Sglobal_set
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set the global binding of VARIABLE to VALUE, ignoring other bindings.\n\ Normal setting of VARIABLE with  set  would set the innermost binding."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|symbol
operator|,
name|newval
operator|)
name|Lisp_Object
name|symbol
operator|,
name|newval
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|specbinding
modifier|*
name|ptr
init|=
name|specpdl
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ptr
operator|!=
name|specpdl_ptr
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|ptr
operator|->
name|symbol
argument_list|,
name|symbol
argument_list|)
condition|)
block|{
name|ptr
operator|->
name|old_value
operator|=
name|newval
expr_stmt|;
return|return
name|newval
return|;
block|}
block|}
return|return
name|Fset
argument_list|(
name|symbol
argument_list|,
name|newval
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"backtrace-debug"
argument_list|,
argument|Fbacktrace_debug
argument_list|,
argument|Sbacktrace_debug
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set the debug-on-exit flag of eval frame LEVEL levels down to FLAG.\n\ The debugger is entered when that frame exits, if the flag is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|level
operator|,
name|flag
operator|)
name|Lisp_Object
name|level
operator|,
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|backtrace
modifier|*
name|backlist
init|=
name|backtrace_list
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|backlist
operator|&&
name|i
operator|<
name|XINT
argument_list|(
name|level
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|backlist
operator|=
name|backlist
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|backlist
condition|)
name|backlist
operator|->
name|debug_on_exit
operator|=
operator|!
name|NULL
argument_list|(
name|flag
argument_list|)
expr_stmt|;
return|return
name|flag
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"backtrace"
argument_list|,
argument|Fbacktrace
argument_list|,
argument|Sbacktrace
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Print a trace of Lisp function calls currently active.\n\ Output stream used is value of standard-output."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
expr|struct
name|backtrace
operator|*
name|backlist
operator|=
name|backtrace_list
block|;
specifier|register
name|int
name|i
block|;
specifier|register
name|Lisp_Object
name|tail
block|;
name|Lisp_Object
name|tem
block|;
while|while
condition|(
name|backlist
condition|)
block|{
name|write_string
argument_list|(
name|backlist
operator|->
name|debug_on_exit
condition|?
literal|"* "
else|:
literal|"  "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlist
operator|->
name|nargs
operator|==
name|UNEVALLED
condition|)
name|write_string
argument_list|(
literal|"("
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|*
name|backlist
operator|->
name|function
expr_stmt|;
name|Fprin1
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlist
operator|->
name|nargs
operator|==
name|UNEVALLED
condition|)
block|{
if|if
condition|(
name|backlist
operator|->
name|evalargs
condition|)
name|write_string
argument_list|(
literal|" ...computing arguments..."
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|write_string
argument_list|(
literal|" ..."
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|backlist
operator|->
name|nargs
operator|==
name|MANY
condition|)
block|{
name|write_string
argument_list|(
literal|"("
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
operator|*
name|backlist
operator|->
name|args
operator|,
name|i
operator|=
literal|0
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|write_string
argument_list|(
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
block|}
end_elseif

begin_else
else|else
block|{
name|write_string
argument_list|(
literal|"("
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|backlist
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|write_string
argument_list|(
literal|" "
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|backlist
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
block|}
end_else

begin_expr_stmt
name|write_string
argument_list|(
literal|")\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|backlist
operator|=
name|backlist
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   return
name|Qnil
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_expr_stmt
unit|syms_of_eval
operator|(
operator|)
block|{
name|DefIntVar
argument_list|(
literal|"max-specpdl-size"
argument_list|,
operator|&
name|max_specpdl_size
argument_list|,
literal|"Limit on number of Lisp variable bindings& unwind-protects before error."
argument_list|)
block|;
name|DefIntVar
argument_list|(
literal|"max-lisp-eval-depth"
argument_list|,
operator|&
name|max_lisp_eval_depth
argument_list|,
literal|"Limit on depth in eval, apply and funcall before error."
argument_list|)
block|;
name|DefLispVar
argument_list|(
literal|"quit-flag"
argument_list|,
operator|&
name|Vquit_flag
argument_list|,
literal|"Non-nil causes  eval  to abort, unless  inhibit-quit  is non-nil.\n\ Typing C-G sets  quit-flag  non-nil, regardless of  inhibit-quit."
argument_list|)
block|;
name|Vquit_flag
operator|=
name|Qnil
block|;
name|DefLispVar
argument_list|(
literal|"inhibit-quit"
argument_list|,
operator|&
name|Vinhibit_quit
argument_list|,
literal|"Non-nil inhibits C-g quitting from happening immediately.\n\ Note that  quit-flag  will still be set by typing C-g,\n\ so a quit will be signalled as soon as  inhibit-quit  is nil.\n\ To prevent this happening, set  quit-flag  to nil\n\ before making  inhibit-quit  nil."
argument_list|)
block|;
name|Vinhibit_quit
operator|=
name|Qnil
block|;
name|Qautoload
operator|=
name|intern
argument_list|(
literal|"autoload"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qautoload
argument_list|)
block|;
name|Qmacro
operator|=
name|intern
argument_list|(
literal|"macro"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qmacro
argument_list|)
block|;
name|Qexit
operator|=
name|intern
argument_list|(
literal|"exit"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qexit
argument_list|)
block|;
name|Qinteractive
operator|=
name|intern
argument_list|(
literal|"interactive"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qinteractive
argument_list|)
block|;
name|Qcommandp
operator|=
name|intern
argument_list|(
literal|"commandp"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qcommandp
argument_list|)
block|;
name|Qdefun
operator|=
name|intern
argument_list|(
literal|"defun"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qdefun
argument_list|)
block|;
name|Qand_rest
operator|=
name|intern
argument_list|(
literal|"&rest"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qand_rest
argument_list|)
block|;
name|Qand_optional
operator|=
name|intern
argument_list|(
literal|"&optional"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qand_optional
argument_list|)
block|;
name|DefBoolVar
argument_list|(
literal|"stack-trace-on-error"
argument_list|,
operator|&
name|stack_trace_on_error
argument_list|,
literal|"*Non-nil means automatically display a backtrace buffer\n\ after any error that is handled by the editor command loop."
argument_list|)
block|;
name|stack_trace_on_error
operator|=
literal|0
block|;
name|DefBoolVar
argument_list|(
literal|"debug-on-error"
argument_list|,
operator|&
name|debug_on_error
argument_list|,
literal|"*Non-nil means enter debugger if an error is signaled.\n\ Does not apply to errors handled by condition-case.\n\ See also variable debug-on-quit."
argument_list|)
block|;
name|debug_on_error
operator|=
literal|0
block|;
name|DefBoolVar
argument_list|(
literal|"debug-on-quit"
argument_list|,
operator|&
name|debug_on_quit
argument_list|,
literal|"*Non-nil means enter debugger if quit is signaled (C-G, for example).\n\ Does not apply if quit is handled by a condition-case."
argument_list|)
block|;
name|debug_on_quit
operator|=
literal|0
block|;
name|DefBoolVar
argument_list|(
literal|"debug-on-next-call"
argument_list|,
operator|&
name|debug_on_next_call
argument_list|,
literal|"Non-nil means enter debugger before next eval, apply or funcall."
argument_list|)
block|;
name|DefLispVar
argument_list|(
literal|"debugger"
argument_list|,
operator|&
name|Vdebugger
argument_list|,
literal|"Function to call to invoke debugger.\n\ If due to frame exit, args are 'exit and value being returned;\n\  this function's value will be returned instead of that.\n\ If due to error, args are 'error and list of signal's args.\n\ If due to apply or funcall entry, one arg, 'lambda.\n\ If due to eval entry, one arg, 't."
argument_list|)
block|;
name|Vdebugger
operator|=
name|Qnil
block|;
name|Qmocklisp_arguments
operator|=
name|intern
argument_list|(
literal|"mocklisp-arguments"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qmocklisp_arguments
argument_list|)
block|;
name|DefLispVar
argument_list|(
literal|"mocklisp-arguments"
argument_list|,
operator|&
name|Vmocklisp_arguments
argument_list|,
literal|"While in a mocklisp function, the list of its unevaluated args."
argument_list|)
block|;
name|Vmocklisp_arguments
operator|=
name|Qt
block|;
name|staticpro
argument_list|(
operator|&
name|Vautoload_queue
argument_list|)
block|;
name|Vautoload_queue
operator|=
name|Qnil
block|;
name|defsubr
argument_list|(
operator|&
name|Sor
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sand
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sif
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Scond
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sprogn
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sprog1
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sprog2
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Ssetq
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sglobal_set
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sglobal_value
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Squote
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sfunction
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sdefun
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sdefmacro
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sdefvar
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sdefconst
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Suser_variable_p
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Slet
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|SletX
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Swhile
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Smacroexpand
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Scatch
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sthrow
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sunwind_protect
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Scondition_case
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Ssignal
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sinteractive_p
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Scommandp
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sautoload
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Seval
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sapply
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sfuncall
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sbacktrace_debug
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sbacktrace
argument_list|)
block|; }
end_expr_stmt

end_unit

