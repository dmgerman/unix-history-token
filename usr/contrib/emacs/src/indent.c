begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Indentation functions.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_define
define|#
directive|define
name|CR
value|'\015'
end_define

begin_decl_stmt
name|int
name|indent_tabs_mode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* These three values memoize the current column to avoid recalculation */
end_comment

begin_comment
comment|/* Some things in buflow.c set last_known_column_point to -1   to mark the memoized value as invalid */
end_comment

begin_comment
comment|/* Last value returned by current_column */
end_comment

begin_decl_stmt
name|int
name|last_known_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of point when current_column was called */
end_comment

begin_decl_stmt
name|int
name|last_known_column_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of bf_modified when current_column was called */
end_comment

begin_decl_stmt
name|int
name|last_known_column_modified
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|minibuf_prompt_width
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"current-column"
argument_list|,
argument|Fcurrent_column
argument_list|,
argument|Scurrent_column
argument_list|,
literal|"Return the horizontal position of point.  The left margin is column 0.\n\ Ignores finite width of screen,"
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|current_column ()
argument_list|)
end_macro

begin_macro
name|current_column
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|col
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|stop
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|tab_seen
decl_stmt|;
specifier|register
name|int
name|post_tab
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|bf_cur
operator|->
name|tab_width
argument_list|)
decl_stmt|;
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
if|if
condition|(
name|point
operator|==
name|last_known_column_point
operator|&&
name|bf_modified
operator|==
name|last_known_column_modified
condition|)
return|return
name|last_known_column
return|;
name|ptr
operator|=
operator|&
name|CharAt
argument_list|(
name|point
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|stop
operator|=
name|point
operator|<=
name|bf_s1
operator|+
literal|1
condition|?
name|bf_p1
operator|+
literal|1
else|:
name|bf_p2
operator|+
name|bf_s1
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
condition|)
name|tab_width
operator|=
literal|1
expr_stmt|;
name|col
operator|=
literal|0
operator|,
name|tab_seen
operator|=
literal|0
operator|,
name|post_tab
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|stop
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|bf_p1
operator|+
literal|1
condition|)
break|break;
name|stop
operator|=
name|bf_p1
operator|+
literal|1
expr_stmt|;
name|ptr
operator|=
name|stop
operator|+
name|bf_s1
expr_stmt|;
if|if
condition|(
operator|!
name|bf_s1
condition|)
break|break;
block|}
name|c
operator|=
operator|*
operator|--
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|col
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|tab_seen
condition|)
name|col
operator|=
operator|(
operator|(
name|col
operator|+
name|tab_width
operator|)
operator|/
name|tab_width
operator|)
operator|*
name|tab_width
expr_stmt|;
name|post_tab
operator|+=
name|col
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
name|tab_seen
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|col
operator|+=
operator|(
name|ctl_arrow
operator|&&
name|c
operator|<
literal|0200
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|tab_seen
condition|)
block|{
name|col
operator|=
operator|(
operator|(
name|col
operator|+
name|tab_width
operator|)
operator|/
name|tab_width
operator|)
operator|*
name|tab_width
expr_stmt|;
name|col
operator|+=
name|post_tab
expr_stmt|;
block|}
name|last_known_column
operator|=
name|col
expr_stmt|;
name|last_known_column_point
operator|=
name|point
expr_stmt|;
name|last_known_column_modified
operator|=
name|bf_modified
expr_stmt|;
return|return
name|col
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|ToCol
argument_list|(
argument|col
argument_list|)
end_macro

begin_decl_stmt
name|int
name|col
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fromcol
init|=
name|current_column
argument_list|()
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|bf_cur
operator|->
name|tab_width
argument_list|)
decl_stmt|;
if|if
condition|(
name|fromcol
operator|>
name|col
condition|)
return|return;
if|if
condition|(
name|tab_width
operator|<=
literal|0
condition|)
name|tab_width
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|indent_tabs_mode
condition|)
block|{
name|n
operator|=
name|col
operator|/
name|tab_width
operator|-
name|fromcol
operator|/
name|tab_width
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|InsCStr
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fromcol
operator|=
operator|(
name|col
operator|/
name|tab_width
operator|)
operator|*
name|tab_width
expr_stmt|;
block|}
block|}
while|while
condition|(
name|fromcol
operator|<
name|col
condition|)
block|{
name|InsCStr
argument_list|(
literal|"        "
argument_list|,
name|min
argument_list|(
literal|8
argument_list|,
name|col
operator|-
name|fromcol
argument_list|)
argument_list|)
expr_stmt|;
name|fromcol
operator|+=
name|min
argument_list|(
literal|8
argument_list|,
name|col
operator|-
name|fromcol
argument_list|)
expr_stmt|;
block|}
name|last_known_column
operator|=
name|col
expr_stmt|;
name|last_known_column_point
operator|=
name|point
expr_stmt|;
name|last_known_column_modified
operator|=
name|bf_modified
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"indent-to"
argument_list|,
argument|Findent_to
argument_list|,
argument|Sindent_to
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"nIndent to column: "
argument_list|,
literal|"Indent from point with tabs and spaces until COLUMN is reached.\n\ Always do at least MIN spaces even if that goes past COLUMN;\n\ by default, MIN is zero."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|col
operator|,
name|minimum
operator|)
name|Lisp_Object
name|col
operator|,
name|minimum
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|mincol
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|minimum
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|minimum
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|minimum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mincol
operator|=
name|current_column
argument_list|()
operator|+
name|XINT
argument_list|(
name|minimum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mincol
operator|<
name|XINT
argument_list|(
name|col
argument_list|)
condition|)
name|mincol
operator|=
name|XINT
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|ToCol
argument_list|(
name|mincol
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|col
argument_list|,
name|mincol
argument_list|)
expr_stmt|;
return|return
name|col
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"current-indentation"
argument_list|,
argument|Fcurrent_indentation
argument_list|,
argument|Scurrent_indentation
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the indentation of the current line.\n\ This is the horizontal position of the character\n\ following any initial whitespace."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|val
block|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|position_indentation
argument_list|(
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|point
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
block|;
return|return
name|val
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|position_indentation
argument_list|(
name|pos
argument_list|)
specifier|register
name|int
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|col
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|end
init|=
name|NumCharacters
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|bf_cur
operator|->
name|tab_width
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
condition|)
name|tab_width
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
operator|&&
operator|(
name|c
operator|=
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|,
name|c
operator|==
literal|'\t'
condition|?
operator|(
name|col
operator|+=
name|tab_width
operator|-
name|col
operator|%
name|tab_width
operator|)
else|:
operator|(
name|c
operator|==
literal|' '
condition|?
operator|++
name|col
else|:
literal|0
operator|)
operator|)
condition|)
name|pos
operator|++
expr_stmt|;
return|return
name|col
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"move-to-column"
argument_list|,
argument|Fmove_to_column
argument_list|,
argument|Smove_to_column
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Move point to column COLUMN in the current line.\n\ Does not change the text, only point.\n\ Ignores finite width of screen."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|column
operator|)
name|Lisp_Object
name|column
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|pos
init|=
name|point
decl_stmt|;
specifier|register
name|int
name|col
init|=
name|current_column
argument_list|()
decl_stmt|;
specifier|register
name|int
name|goal
decl_stmt|;
specifier|register
name|int
name|end
init|=
name|NumCharacters
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XINT
argument_list|(
name|bf_cur
operator|->
name|tab_width
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
condition|)
name|tab_width
operator|=
literal|1
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|goal
operator|=
name|XINT
argument_list|(
name|column
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|>
name|goal
condition|)
block|{
name|pos
operator|=
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|pos
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|col
operator|<
name|goal
operator|&&
name|pos
operator|<=
name|end
condition|)
block|{
name|char
name|c
init|=
name|CharAt
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|pos
operator|++
expr_stmt|;
name|col
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|col
operator|+=
name|tab_width
operator|-
literal|1
expr_stmt|;
name|col
operator|=
name|col
operator|/
name|tab_width
operator|*
name|tab_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctl_arrow
operator|&&
operator|(
name|c
operator|<
literal|040
operator|||
name|c
operator|==
literal|0177
operator|)
condition|)
name|col
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|040
operator|||
name|c
operator|>=
literal|0177
condition|)
name|col
operator|+=
literal|3
expr_stmt|;
block|}
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|last_known_column
operator|=
name|col
expr_stmt|;
name|last_known_column_point
operator|=
name|point
expr_stmt|;
name|last_known_column_modified
operator|=
name|bf_modified
expr_stmt|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|col
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|struct
name|position
name|val_compute_motion
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|position
modifier|*
name|compute_motion
parameter_list|(
name|from
parameter_list|,
name|fromvpos
parameter_list|,
name|fromhpos
parameter_list|,
name|to
parameter_list|,
name|tovpos
parameter_list|,
name|tohpos
parameter_list|,
name|width
parameter_list|,
name|hscroll
parameter_list|,
name|tab_offset
parameter_list|)
name|int
name|from
decl_stmt|,
name|fromvpos
decl_stmt|,
name|fromhpos
decl_stmt|,
name|to
decl_stmt|,
name|tovpos
decl_stmt|,
name|tohpos
decl_stmt|;
specifier|register
name|int
name|width
decl_stmt|;
name|int
name|hscroll
decl_stmt|,
name|tab_offset
decl_stmt|;
block|{
comment|/* Note that cpos is CURRENT_VPOS<< SHORTBITS + CURRENT_HPOS,      and the CURRENT_HPOS may be negative.  Use these macros      to extract the hpos or the vpos from cpos or anything like it.  */
ifdef|#
directive|ifdef
name|celerity
comment|/* On the Celerity, the usual definition fails to work.    This definition (which ought to be equivalent) does work.  */
define|#
directive|define
name|HPOS
parameter_list|(
name|VAR
parameter_list|)
value|(((VAR)& 0x8000 ? 0xffff0000 : 0) | ((VAR)& 0xffff))
else|#
directive|else
define|#
directive|define
name|HPOS
parameter_list|(
name|VAR
parameter_list|)
value|(short) (VAR)
endif|#
directive|endif
define|#
directive|define
name|VPOS
parameter_list|(
name|VAR
parameter_list|)
value|(((VAR)>> SHORTBITS) + (HPOS (VAR)< 0))
ifndef|#
directive|ifndef
name|TAHOE_REGISTER_BUG
specifier|register
endif|#
directive|endif
comment|/* TAHOE_REGISTER_BUG */
name|int
name|cpos
init|=
name|fromhpos
operator|+
operator|(
name|fromvpos
operator|<<
name|SHORTBITS
operator|)
decl_stmt|;
specifier|register
name|int
name|target
init|=
name|tohpos
operator|+
operator|(
name|tovpos
operator|<<
name|SHORTBITS
operator|)
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|tab_width
init|=
name|XFASTINT
argument_list|(
name|bf_cur
operator|->
name|tab_width
argument_list|)
decl_stmt|;
specifier|register
name|int
name|ctl_arrow
init|=
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|ctl_arrow
argument_list|)
decl_stmt|;
name|int
name|selective
init|=
name|XTYPE
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
operator|==
name|Lisp_Int
condition|?
name|XINT
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
else|:
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|prevpos
decl_stmt|;
name|struct
name|position
name|val
decl_stmt|;
if|if
condition|(
name|tab_width
operator|<=
literal|0
condition|)
name|tab_width
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|from
init|;
name|pos
operator|<
name|to
operator|&&
name|cpos
operator|<
name|target
condition|;
name|pos
operator|++
control|)
block|{
name|prevpos
operator|=
name|cpos
expr_stmt|;
name|c
operator|=
name|CharAt
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|cpos
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|cpos
operator|+=
name|tab_width
operator|-
name|HPOS
argument_list|(
name|cpos
operator|+
name|tab_offset
operator|+
name|hscroll
operator|-
operator|(
name|hscroll
operator|>
literal|0
operator|)
comment|/* Add tab_width here to make sure positive. 		       cpos can be negative after continuation 		       but can't be less than -tab_width.  */
operator|+
name|tab_width
argument_list|)
operator|%
name|tab_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|selective
operator|>
literal|0
operator|&&
name|position_indentation
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|>=
name|selective
condition|)
block|{
comment|/* Skip any number of invisible lines all at once */
do|do
block|{
while|while
condition|(
operator|++
name|pos
operator|<
name|to
operator|&&
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
do|while
condition|(
name|selective
operator|>
literal|0
operator|&&
name|position_indentation
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|>=
name|selective
condition|)
do|;
name|pos
operator|--
expr_stmt|;
comment|/* Allow for the " ..." that is displayed for them. */
name|cpos
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|>=
name|width
condition|)
name|cpos
operator|-=
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|-
name|width
expr_stmt|;
block|}
else|else
name|cpos
operator|+=
operator|(
literal|1
operator|<<
name|SHORTBITS
operator|)
operator|-
name|HPOS
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
name|cpos
operator|-=
name|hscroll
expr_stmt|;
if|if
condition|(
name|hscroll
operator|>
literal|0
condition|)
name|cpos
operator|++
expr_stmt|;
comment|/* Count the ! on column 0 */
name|tab_offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|CR
operator|&&
name|selective
operator|<
literal|0
condition|)
block|{
comment|/* In selective display mode, 	     everything from a ^M to the end of the line is invisible */
while|while
condition|(
name|pos
operator|<
name|to
operator|&&
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pos
operator|++
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
else|else
name|cpos
operator|+=
operator|(
name|ctl_arrow
operator|&&
name|c
operator|<
literal|0200
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|>=
name|width
operator|&&
operator|(
name|HPOS
argument_list|(
name|cpos
argument_list|)
operator|>
name|width
operator|||
operator|(
name|pos
operator|<
name|NumCharacters
operator|&&
name|CharAt
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|!=
literal|'\n'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cpos
operator|>=
name|target
condition|)
break|break;
if|if
condition|(
name|hscroll
operator|||
operator|(
name|truncate_partial_width_windows
operator|&&
name|width
operator|+
literal|1
operator|<
name|screen_width
operator|)
operator|||
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|truncate_lines
argument_list|)
condition|)
block|{
while|while
condition|(
name|pos
operator|<
name|to
operator|&&
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pos
operator|++
expr_stmt|;
name|pos
operator|--
expr_stmt|;
block|}
else|else
block|{
name|cpos
operator|+=
operator|(
literal|1
operator|<<
name|SHORTBITS
operator|)
operator|-
name|width
expr_stmt|;
name|tab_offset
operator|+=
name|width
expr_stmt|;
block|}
block|}
block|}
name|val_compute_motion
operator|.
name|bufpos
operator|=
name|pos
expr_stmt|;
name|val_compute_motion
operator|.
name|hpos
operator|=
name|HPOS
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
name|val_compute_motion
operator|.
name|vpos
operator|=
name|VPOS
argument_list|(
name|cpos
argument_list|)
expr_stmt|;
name|val_compute_motion
operator|.
name|prevhpos
operator|=
name|HPOS
argument_list|(
name|prevpos
argument_list|)
expr_stmt|;
comment|/* Nonzero if have just continued a line */
name|val_compute_motion
operator|.
name|contin
operator|=
name|pos
operator|!=
name|from
operator|&&
operator|(
name|val_compute_motion
operator|.
name|vpos
operator|!=
name|VPOS
argument_list|(
name|prevpos
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
expr_stmt|;
return|return
operator|&
name|val_compute_motion
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|pos_tab_offset
argument_list|(
argument|w
argument_list|,
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|opoint
init|=
name|point
decl_stmt|;
name|int
name|col
decl_stmt|;
if|if
condition|(
name|pos
operator|==
name|FirstCharacter
operator|||
name|CharAt
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|col
operator|=
name|current_column
argument_list|()
expr_stmt|;
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
return|return
name|col
operator|-
operator|(
name|col
operator|%
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* start_hpos is the hpos of the first character of the buffer:    zero except for the minibuffer window,    where it is the width of the prompt.  */
end_comment

begin_decl_stmt
name|struct
name|position
name|val_vmotion
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|position
modifier|*
name|vmotion
parameter_list|(
name|from
parameter_list|,
name|vtarget
parameter_list|,
name|width
parameter_list|,
name|hscroll
parameter_list|,
name|window
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|,
name|vtarget
decl_stmt|,
name|width
decl_stmt|;
name|int
name|hscroll
decl_stmt|;
name|Lisp_Object
name|window
decl_stmt|;
block|{
name|struct
name|position
name|pos
decl_stmt|;
comment|/* vpos is cumulative vertical position, changed as from is changed */
specifier|register
name|int
name|vpos
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|prevline
decl_stmt|;
specifier|register
name|int
name|first
decl_stmt|;
name|int
name|lmargin
init|=
name|hscroll
operator|>
literal|0
condition|?
literal|1
operator|-
name|hscroll
else|:
literal|0
decl_stmt|;
name|int
name|selective
init|=
name|XTYPE
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
operator|==
name|Lisp_Int
condition|?
name|XINT
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
else|:
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|selective_display
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|0
decl_stmt|;
name|int
name|start_hpos
init|=
operator|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|?
name|minibuf_prompt_width
else|:
literal|0
operator|)
decl_stmt|;
name|retry
label|:
if|if
condition|(
name|vtarget
operator|>
name|vpos
condition|)
block|{
comment|/* Moving downward is simple, but must calculate from beg of line  	 to determine hpos of starting point */
if|if
condition|(
name|from
operator|>
name|FirstCharacter
operator|&&
name|CharAt
argument_list|(
name|from
operator|-
literal|1
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
name|prevline
operator|=
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|from
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|selective
operator|>
literal|0
operator|&&
name|prevline
operator|>
name|FirstCharacter
operator|&&
name|position_indentation
argument_list|(
name|prevline
argument_list|)
operator|>=
name|selective
condition|)
name|prevline
operator|=
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|prevline
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|prevline
argument_list|,
literal|0
argument_list|,
name|lmargin
operator|+
operator|(
name|prevline
operator|==
literal|1
condition|?
name|start_hpos
else|:
literal|0
operator|)
argument_list|,
name|from
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|hpos
operator|=
name|lmargin
operator|+
operator|(
name|from
operator|==
literal|1
condition|?
name|start_hpos
else|:
literal|0
operator|)
expr_stmt|;
name|pos
operator|.
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|compute_motion
argument_list|(
name|from
argument_list|,
name|vpos
argument_list|,
name|pos
operator|.
name|hpos
argument_list|,
literal|1
operator|+
name|NumCharacters
argument_list|,
name|vtarget
argument_list|,
operator|-
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
name|pos
operator|.
name|vpos
operator|*
name|width
argument_list|)
return|;
block|}
comment|/* To move upward, go a line at a time until      we have gone at least far enough */
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|vpos
operator|>
name|vtarget
operator|||
name|first
operator|)
operator|&&
name|from
operator|>
name|FirstCharacter
condition|)
block|{
name|prevline
operator|=
name|from
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|prevline
operator|=
name|ScanBf
argument_list|(
literal|'\n'
argument_list|,
name|prevline
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevline
operator|==
name|FirstCharacter
operator|||
name|selective
operator|<=
literal|0
operator|||
name|position_indentation
argument_list|(
name|prevline
argument_list|)
operator|<
name|selective
condition|)
break|break;
block|}
name|pos
operator|=
operator|*
name|compute_motion
argument_list|(
name|prevline
argument_list|,
literal|0
argument_list|,
name|lmargin
operator|+
operator|(
name|prevline
operator|==
literal|1
condition|?
name|start_hpos
else|:
literal|0
operator|)
argument_list|,
name|from
argument_list|,
literal|10000
argument_list|,
literal|10000
argument_list|,
name|width
argument_list|,
name|hscroll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vpos
operator|-=
name|pos
operator|.
name|vpos
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|from
operator|=
name|prevline
expr_stmt|;
block|}
comment|/* If we made exactly the desired vertical distance,      or if we hit beginning of buffer,      return point found */
if|if
condition|(
name|vpos
operator|>=
name|vtarget
condition|)
block|{
name|val_vmotion
operator|.
name|bufpos
operator|=
name|from
expr_stmt|;
name|val_vmotion
operator|.
name|vpos
operator|=
name|vpos
expr_stmt|;
name|val_vmotion
operator|.
name|hpos
operator|=
name|lmargin
expr_stmt|;
name|val_vmotion
operator|.
name|contin
operator|=
literal|0
expr_stmt|;
name|val_vmotion
operator|.
name|prevhpos
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|val_vmotion
return|;
block|}
comment|/* Otherwise find the correct spot by moving down */
goto|goto
name|retry
goto|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"vertical-motion"
argument_list|,
argument|Fvertical_motion
argument_list|,
argument|Svertical_motion
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Move to start of screen line LINES lines down.\n\ If LINES is negative, this is moving up.\n\ Sets point to position found; this may be start of line\n\  or just the start of a continuation line.\n\ Returns number of lines moved; may be closer to zero than LINES\n\  if end of buffer was reached."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|lines
operator|)
name|Lisp_Object
name|lines
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|position
name|pos
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|lines
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|*
name|vmotion
argument_list|(
name|point
argument_list|,
name|XINT
argument_list|(
name|lines
argument_list|)
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|width
argument_list|)
operator|)
argument_list|,
comment|/* Not XFASTINT since perhaps could be negative */
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
argument_list|,
name|selected_window
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|pos
operator|.
name|bufpos
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|pos
operator|.
name|vpos
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_indent
argument_list|()
end_macro

begin_block
block|{
name|DefBoolVar
argument_list|(
literal|"indent-tabs-mode"
argument_list|,
operator|&
name|indent_tabs_mode
argument_list|,
literal|"*Indentation can insert tabs if this is non-nil."
argument_list|)
expr_stmt|;
name|indent_tabs_mode
operator|=
literal|1
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_indentation
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sindent_to
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_column
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smove_to_column
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Svertical_motion
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

