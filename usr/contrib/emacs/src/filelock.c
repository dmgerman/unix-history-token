begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1985 Richard M. Stallman and Dick King  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLASH_DETECTION
end_ifdef

begin_comment
comment|/* lock_file locks file fn,    meaning it serves notice on the world that you intend to edit that file.    This should be done only when about to modify a file-visiting    buffer previously unmodified.    Do not (normally) call lock_buffer for a buffer already modified,    as either the file is already locked, or the user has already    decided to go ahead without locking.     When lock_buffer returns, either the lock is locked for us,    or the user has said to go ahead without locking.     If the file is locked by someone else, lock_buffer calls    ask-user-about-lock (a Lisp function) with two arguments,    the file name and the name of the user who did the locking.    This function can signal an error, or return t meaning    take away the lock, or return nil meaning ignore the lock.  */
end_comment

begin_comment
comment|/* The lock file name is the file name with "/" replaced by "!"    and put in the Emacs lock directory.  */
end_comment

begin_comment
comment|/* (ie., /ka/king/junk.tex -> /!/!ka!king!junk.tex). */
end_comment

begin_function
name|void
name|lock_file
parameter_list|(
name|fn
parameter_list|)
specifier|register
name|Lisp_Object
name|fn
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|Lisp_Object
name|attack
decl_stmt|;
specifier|register
name|char
modifier|*
name|lfname
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|struct
name|passwd
modifier|*
name|the_pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
comment|/* Create the name of the lock-file for file fn */
name|lfname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|fn
argument_list|)
operator|->
name|size
operator|+
name|strlen
argument_list|(
name|PATH_LOCK
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fill_in_lock_file_name
argument_list|(
name|lfname
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* Try to lock the lock. */
if|if
condition|(
name|lock_if_free
argument_list|(
name|lfname
argument_list|)
operator|<=
literal|0
condition|)
comment|/* Return now if we have locked it, or if lock dir does not exist */
return|return;
comment|/* Else consider breaking the lock */
name|the_pw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|lfname
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
name|the_pw
operator|=
name|getpwuid
argument_list|(
name|s
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|attack
operator|=
name|call2
argument_list|(
name|intern
argument_list|(
literal|"ask-user-about-lock"
argument_list|)
argument_list|,
name|fn
argument_list|,
name|the_pw
operator|==
literal|0
condition|?
name|Qnil
else|:
name|build_string
argument_list|(
name|the_pw
operator|->
name|pw_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|attack
argument_list|)
condition|)
comment|/* User says take the lock */
block|{
name|lock_superlock
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
name|lock_file_1
argument_list|(
name|lfname
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|PATH_SUPERLOCK
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* User says ignore the lock */
block|}
end_function

begin_expr_stmt
name|fill_in_lock_file_name
argument_list|(
name|lockfile
argument_list|,
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|lockfile
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|lockfile
argument_list|,
name|PATH_LOCK
argument_list|)
expr_stmt|;
name|p
operator|=
name|lockfile
operator|+
name|strlen
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|XSTRING
argument_list|(
name|fn
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'!'
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Lock the lock file named LFNAME.    If MODE is O_WRONLY, we do so even if it is already locked.    If MODE is O_WRONLY | O_EXCL | O_CREAT, we do so only if it is free.    Return 1 if successful, 0 if not.  */
end_comment

begin_function
name|int
name|lock_file_1
parameter_list|(
name|lfname
parameter_list|,
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
name|char
modifier|*
name|lfname
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|lfname
argument_list|,
name|mode
argument_list|,
literal|0666
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|fchmod
argument_list|(
name|fd
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lock the lock named LFNAME if possible.    Return 0 in that case.    Return 1 if lock is really locked by someone else.    Return -1 if cannot lock for any other reason.  */
end_comment

begin_function
name|int
name|lock_if_free
parameter_list|(
name|lfname
parameter_list|)
specifier|register
name|char
modifier|*
name|lfname
decl_stmt|;
block|{
specifier|register
name|int
name|clasher
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
while|while
condition|(
name|lock_file_1
argument_list|(
name|lfname
argument_list|,
name|O_WRONLY
operator||
name|O_EXCL
operator||
name|O_CREAT
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
name|clasher
operator|=
name|current_lock_owner
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|clasher
operator|==
literal|0
operator|||
operator|(
name|kill
argument_list|(
name|clasher
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ESRCH
operator|)
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|lfname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we delete the lock successfully, try again to lock.  */
block|}
else|else
return|return
operator|(
name|clasher
operator|!=
name|getpid
argument_list|()
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|current_lock_owner
parameter_list|(
name|lfname
parameter_list|)
name|char
modifier|*
name|lfname
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|lfname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|atoi
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|unlock_file
parameter_list|(
name|fn
parameter_list|)
specifier|register
name|Lisp_Object
name|fn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|lfname
decl_stmt|;
name|lfname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|fn
argument_list|)
operator|->
name|size
operator|+
name|strlen
argument_list|(
name|PATH_LOCK
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fill_in_lock_file_name
argument_list|(
name|lfname
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|lock_superlock
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_lock_owner
argument_list|(
name|lfname
argument_list|)
operator|==
name|getpid
argument_list|()
condition|)
name|unlink
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|PATH_SUPERLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|lock_superlock
argument_list|(
argument|lfname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lfname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|20
init|;
name|i
operator|<
literal|0
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|PATH_SUPERLOCK
argument_list|,
name|O_WRONLY
operator||
name|O_EXCL
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|fchmod
argument_list|(
name|fd
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|lfname
argument_list|,
name|strlen
argument_list|(
name|lfname
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|unlock_all_files
parameter_list|()
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|Vbuffer_alist
init|;
name|XGCTYPE
argument_list|(
name|tail
argument_list|)
operator|==
name|Lisp_Cons
condition|;
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
control|)
block|{
name|b
operator|=
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
argument_list|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|b
operator|->
name|filename
argument_list|)
operator|&&
name|b
operator|->
name|save_modified
operator|<
name|b
operator|->
name|text
operator|.
name|modified
condition|)
name|unlock_file
argument_list|(
name|b
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"lock-buffer"
argument_list|,
argument|Flock_buffer
argument_list|,
argument|Slock_buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Locks FILE, if current buffer is modified.\n\ FILE defaults to current buffer's visited file,\n\ or else nothing is done if current buffer isn't visiting a file."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|fn
operator|)
name|Lisp_Object
name|fn
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|bf_cur
operator|->
name|filename
expr_stmt|;
else|else
name|CHECK_STRING
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf_cur
operator|->
name|save_modified
operator|<
name|bf_modified
operator|&&
operator|!
name|NULL
argument_list|(
name|fn
argument_list|)
condition|)
name|lock_file
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"unlock-buffer"
argument_list|,
argument|Funlock_buffer
argument_list|,
argument|Sunlock_buffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Unlocks the file visited in the current buffer,\n\ if it should normally be locked."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|bf_cur
operator|->
name|save_modified
operator|<
name|bf_modified
operator|&&
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
condition|)
name|unlock_file
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  syms_of_filelock
operator|(
operator|)
block|{
name|defsubr
argument_list|(
operator|&
name|Sunlock_buffer
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Slock_buffer
argument_list|)
block|; }
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLASH_DETECTION */
end_comment

end_unit

