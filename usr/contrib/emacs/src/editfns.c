begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lisp functions pertaining to editing.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_function_decl
name|Lisp_Object
name|ml_apply
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Some static data, and a function to initialize it for each run */
end_comment

begin_decl_stmt
specifier|static
name|char
name|user_real_name
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* login ID of current user */
end_comment

begin_decl_stmt
specifier|static
name|char
name|user_full_name
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* full name of current user */
end_comment

begin_decl_stmt
specifier|static
name|char
name|system_name
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user_name
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_editfns
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|first
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* password entry for the current user */
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
comment|/* Don't bother with this on initial start when just dumping out */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
return|return;
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|user_real_name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
sizeof|sizeof
name|user_real_name
argument_list|)
expr_stmt|;
name|user_name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
if|if
condition|(
operator|!
name|user_name
condition|)
name|user_name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
comment|/* USG equivalent */
endif|#
directive|endif
if|if
condition|(
operator|!
name|user_name
condition|)
name|user_name
operator|=
name|user_real_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|user_name
argument_list|,
name|user_real_name
argument_list|)
condition|)
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AMPERSAND_FULL_NAME
if|if
condition|(
name|pw
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|user_full_name
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|user_full_name
argument_list|,
name|USER_FULL_NAME
argument_list|,
sizeof|sizeof
name|user_full_name
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|user_full_name
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pw
operator|==
literal|0
condition|)
name|p
operator|=
literal|"unknown"
expr_stmt|;
else|else
name|p
operator|=
name|USER_FULL_NAME
expr_stmt|;
name|q
operator|=
name|user_full_name
expr_stmt|;
name|r
operator|=
name|user_name
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|p
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|','
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
operator|*
name|r
operator|!=
literal|0
condition|)
block|{
operator|*
name|q
operator|=
operator|*
name|r
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|q
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|q
operator|<=
literal|'z'
operator|)
condition|)
operator|*
name|q
operator|-=
literal|32
expr_stmt|;
for|for
control|(
name|q
operator|++
init|;
operator|*
name|r
operator|!=
literal|0
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|==
operator|&
name|user_full_name
index|[
sizeof|sizeof
name|user_full_name
operator|-
literal|1
index|]
condition|)
break|break;
operator|*
name|q
operator|++
operator|=
operator|*
name|r
expr_stmt|;
block|}
block|}
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|q
operator|==
operator|&
name|user_full_name
index|[
sizeof|sizeof
name|user_full_name
operator|-
literal|2
index|]
condition|)
break|break;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* AMPERSAND_FULL_NAME */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|get_system_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|0
condition|)
name|p
operator|=
literal|"Bogus System Name"
expr_stmt|;
name|strncpy
argument_list|(
name|system_name
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|system_name
argument_list|)
expr_stmt|;
name|p
operator|=
name|system_name
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|' '
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|*
name|p
operator|=
literal|'-'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"char-to-string"
argument_list|,
argument|Fchar_to_string
argument_list|,
argument|Schar_to_string
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Convert arg CHAR to a string containing that character."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"string-to-char"
argument_list|,
argument|Fstring_to_char
argument_list|,
argument|Sstring_to_char
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Convert arg STRING to a character, the first character of that string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
condition|)
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
operator|)
index|[
literal|0
index|]
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|Lisp_Object
name|buildmark
parameter_list|(
name|val
parameter_list|)
block|{
name|Lisp_Object
name|mark
decl_stmt|;
name|mark
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|mark
argument_list|,
name|make_number
argument_list|(
name|val
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|mark
return|;
block|}
end_function

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"point"
argument_list|,
argument|Fpoint
argument_list|,
argument|Spoint
argument_list|,
literal|"Return value of point, as an integer.\n\ Beginning of buffer is position (point-min)"
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|point
argument_list|)
end_macro

begin_macro
name|DEFUN
argument_list|(
literal|"point-marker"
argument_list|,
argument|Fpoint_marker
argument_list|,
argument|Spoint_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return value of point, as a marker object."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|buildmark
argument_list|(
name|point
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"goto-char"
argument_list|,
argument|Fgoto_char
argument_list|,
argument|Sgoto_char
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"nGoto char: "
argument_list|,
literal|"One arg, a number.  Set point to that number.\n\ Beginning of buffer is position (point-min), end is (point-max)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|charno
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|charno
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|charno
operator|<
name|FirstCharacter
condition|)
name|charno
operator|=
name|FirstCharacter
expr_stmt|;
if|if
condition|(
name|charno
operator|>
name|NumCharacters
condition|)
name|charno
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
name|SetPoint
argument_list|(
name|charno
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"region-beginning"
argument_list|,
argument|Fregion_beginning
argument_list|,
argument|Sregion_beginning
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return position of beginning of region, as an integer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|int
name|tem
block|;
if|if
condition|(
name|NULL
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
condition|)
name|error
argument_list|(
literal|"There is no region now"
argument_list|)
expr_stmt|;
name|tem
operator|=
name|marker_position
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|make_number
argument_list|(
name|min
argument_list|(
name|point
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"region-end"
operator|,
name|Fregion_end
operator|,
name|Sregion_end
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return position of end of region, as an integer."
operator|)
operator|(
operator|)
block|{
specifier|register
name|int
name|tem
block|;
if|if
condition|(
name|NULL
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
condition|)
name|error
argument_list|(
literal|"There is no region now"
argument_list|)
expr_stmt|;
name|tem
operator|=
name|marker_position
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|make_number
argument_list|(
name|max
argument_list|(
name|point
argument_list|,
name|tem
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"mark"
operator|,
name|Fmark
operator|,
name|Smark
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return this buffer's mark value as integer, or nil if no mark."
operator|)
operator|(
operator|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
condition|)
return|return
name|Fmarker_position
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"mark-marker"
operator|,
name|Fmark_marker
operator|,
name|Smark_marker
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return this buffer's mark, as a marker object, or nil if no mark.\n\ Watch out!  Moving this marker changes the buffer's mark."
operator|)
operator|(
operator|)
block|{
return|return
name|bf_cur
operator|->
name|mark
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"set-mark"
argument_list|,
argument|Fset_mark
argument_list|,
argument|Sset_mark
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Set this buffer's mark to POS;\n\ Argument is character position, or nil to clear out the mark."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|pos
operator|)
name|Lisp_Object
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|bf_cur
operator|->
name|mark
operator|=
name|Qnil
expr_stmt|;
return|return
name|Qnil
return|;
block|}
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
condition|)
name|bf_cur
operator|->
name|mark
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|,
name|pos
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|save_excursion_save
parameter_list|()
block|{
name|Lisp_Object
name|oldpoint
decl_stmt|,
name|oldmark
decl_stmt|;
name|int
name|visible
init|=
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
operator|==
name|bf_cur
decl_stmt|;
name|oldpoint
operator|=
name|Fpoint_marker
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
condition|)
name|oldmark
operator|=
name|Fcopy_marker
argument_list|(
name|bf_cur
operator|->
name|mark
argument_list|)
expr_stmt|;
else|else
name|oldmark
operator|=
name|Qnil
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|oldpoint
argument_list|,
name|Fcons
argument_list|(
name|oldmark
argument_list|,
name|visible
condition|?
name|Qt
else|:
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|save_excursion_restore
parameter_list|(
name|info
parameter_list|)
name|Lisp_Object
name|info
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fmarker_buffer
argument_list|(
name|Fcar
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If buffer being returned to is now deleted, avoid error */
comment|/* Otherwise could get error here while unwinding to top level      and crash */
comment|/* In that case, Fmarker_buffer returns nil now.  */
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|Fset_buffer
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fgoto_char
argument_list|(
name|Fcar
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|unchain_marker
argument_list|(
name|Fcar
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|Fset_mark
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|unchain_marker
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|&&
name|bf_cur
operator|!=
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
name|Fswitch_to_buffer
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"save-excursion"
argument_list|,
argument|Fsave_excursion
argument_list|,
argument|Ssave_excursion
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Save point (and mark), execute BODY, then restore point and mark.\n\ Executes BODY just like PROGN.  Point and mark values are restored\n\ even in case of abnormal exit (throw or error)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|record_unwind_protect
argument_list|(
name|save_excursion_restore
argument_list|,
name|save_excursion_save
argument_list|()
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"buffer-size"
argument_list|,
argument|Fbufsize
argument_list|,
argument|Sbufsize
argument_list|,
literal|"Return the number of characters in the current buffer."
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|bf_s1 + bf_s2
argument_list|)
end_macro

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"point-min"
argument_list|,
argument|Fpoint_min
argument_list|,
argument|Spoint_min
argument_list|,
literal|"Return the minimum permissible value of point in the current buffer.\n\ This is 1, unless a clipping restriction is in effect."
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|FirstCharacter
argument_list|)
end_macro

begin_macro
name|DEFUN
argument_list|(
literal|"point-min-marker"
argument_list|,
argument|Fpoint_min_marker
argument_list|,
argument|Spoint_min_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a marker to the beginning of the currently visible part of the buffer.\n\ This is the beginning, unless a clipping restriction is in effect."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|buildmark
argument_list|(
name|FirstCharacter
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"point-max"
argument_list|,
argument|Fpoint_max
argument_list|,
argument|Spoint_max
argument_list|,
literal|"Return the maximum permissible value of point in the current buffer.\n\ This is (1+ (buffer-size)), unless a clipping restriction is in effect,\n\ in which case it is less."
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|NumCharacters+
literal|1
argument_list|)
end_macro

begin_macro
name|DEFUN
argument_list|(
literal|"point-max-marker"
argument_list|,
argument|Fpoint_max_marker
argument_list|,
argument|Spoint_max_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a marker to the end of the currently visible part of the buffer.\n\ This is the actual end, unless a clipping restriction is in effect."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|buildmark
argument_list|(
name|NumCharacters
operator|+
literal|1
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"following-char"
argument_list|,
argument|Ffollchar
argument_list|,
argument|Sfollchar
argument_list|,
literal|"Return the character following point, as a number."
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|point>NumCharacters ?
literal|0
argument|: CharAt(point)
argument_list|)
end_macro

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"preceding-char"
argument_list|,
argument|Fprevchar
argument_list|,
argument|Sprevchar
argument_list|,
literal|"Return the character preceding point, as a number."
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|point<=FirstCharacter ?
literal|0
argument|: CharAt(point-
literal|1
argument|)
argument_list|)
end_macro

begin_macro
name|DEFPRED
argument_list|(
literal|"bobp"
argument_list|,
argument|Fbobp
argument_list|,
argument|Sbobp
argument_list|,
literal|"Return T if point is at the beginning of the buffer.\n\ If the buffer is narrowed, this means the beginning of the narrowed part."
argument_list|,
argument|point<=FirstCharacter
argument_list|)
end_macro

begin_macro
name|DEFPRED
argument_list|(
literal|"eobp"
argument_list|,
argument|Feobp
argument_list|,
argument|Seobp
argument_list|,
literal|"Return T if point is at the end of the buffer.\n\ If the buffer is narrowed, this means the end of the narrowed part."
argument_list|,
argument|point>NumCharacters
argument_list|)
end_macro

begin_macro
name|DEFPRED
argument_list|(
literal|"bolp"
argument_list|,
argument|Fbolp
argument_list|,
argument|Sbolp
argument_list|,
literal|"Return T if point is at the beginning of a line."
argument_list|,
argument|point<=FirstCharacter || CharAt(point-
literal|1
argument|)==
literal|'\n'
argument_list|)
end_macro

begin_macro
name|DEFPRED
argument_list|(
literal|"eolp"
argument_list|,
argument|Feolp
argument_list|,
argument|Seolp
argument_list|,
literal|"Return T if point is at the end of a line.\n\ `End of a line' includes point being at the end of the buffer."
argument_list|,
argument|point>NumCharacters || CharAt(point)==
literal|'\n'
argument_list|)
end_macro

begin_macro
name|DEFUN
argument_list|(
literal|"char-after"
argument_list|,
argument|Fchar_after
argument_list|,
argument|Schar_after
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg, POS, a number.  Return the character in the current buffer\n\ at position POS.\n\ If POS is out of range, the value is NIL."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|pos
operator|)
name|Lisp_Object
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|pos
argument_list|)
operator|<
name|FirstCharacter
operator|||
name|XINT
argument_list|(
name|pos
argument_list|)
operator|>
name|NumCharacters
condition|)
return|return
name|Qnil
return|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|CharAt
argument_list|(
name|XINT
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"user-login-name"
argument_list|,
argument|Fuser_login_name
argument_list|,
argument|Suser_login_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Return the name under which user logged in, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|build_string
argument_list|(
name|user_name
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"user-real-login-name"
argument_list|,
argument|Fuser_real_login_name
argument_list|,
argument|Suser_real_login_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Return the name of the user's real uid, as a string.\n\ Differs from user-login-name when running under su."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|build_string
argument_list|(
name|user_real_name
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"user-full-name"
argument_list|,
argument|Fuser_full_name
argument_list|,
argument|Suser_full_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Return the full name of the user logged in, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|build_string
argument_list|(
name|user_full_name
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"system-name"
argument_list|,
argument|Fsystem_name
argument_list|,
argument|Ssystem_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Return the name of the machine you are running on, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|build_string
argument_list|(
name|system_name
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"current-time-string"
argument_list|,
argument|Fcurrent_time_string
argument_list|,
argument|Scurrent_time_string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the current time, as a human-readable string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|long
name|now
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
block|;
name|char
operator|*
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
block|;
name|tem
index|[
literal|24
index|]
operator|=
literal|0
block|;
return|return
name|build_string
argument_list|(
name|tem
argument_list|)
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"insert"
argument_list|,
argument|Finsert
argument_list|,
argument|Sinsert
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Any number of args, strings or chars.  Insert them after point, moving point forward."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|argnum
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|char
name|str
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|wrong_type_argument
argument_list|(
name|Qchar_or_string_p
argument_list|,
name|tem
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert-before-markers"
argument_list|,
argument|Finsert_before_markers
argument_list|,
argument|Sinsert_before_markers
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Any number of args, strings or chars.  Insert them after point,\n\ moving point forward.  Also, any markers pointing at the insertion point\n\ get relocated to point after the newly inserted text."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|argnum
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|char
name|str
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|insert_before_markers
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|insert_before_markers
argument_list|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|wrong_type_argument
argument_list|(
name|Qchar_or_string_p
argument_list|,
name|tem
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return a string with the contents of the current region */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-substring"
argument_list|,
argument|Fbuffer_substring
argument_list|,
argument|Sbuffer_substring
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the contents of part of the current buffer as a string.\n\ The two arguments specify the start and end, as character numbers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|beg
decl_stmt|,
name|end
decl_stmt|;
name|validate_region
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XINT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|end
operator|=
name|XINT
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|beg
operator|<=
name|bf_s1
operator|&&
name|end
operator|>
name|bf_s1
condition|)
name|GapTo
argument_list|(
name|beg
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
operator|&
name|CharAt
argument_list|(
name|beg
argument_list|)
argument_list|,
name|end
operator|-
name|beg
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-string"
argument_list|,
argument|Fbuffer_string
argument_list|,
argument|Sbuffer_string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the contents of the current buffer as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|FirstCharacter
operator|<=
name|bf_s1
operator|&&
name|NumCharacters
operator|+
literal|1
operator|>
name|bf_s1
condition|)
name|GapTo
argument_list|(
name|FirstCharacter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|make_string
argument_list|(
operator|&
name|CharAt
argument_list|(
name|FirstCharacter
argument_list|)
argument_list|,
name|NumCharacters
operator|+
literal|1
operator|-
name|FirstCharacter
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"insert-buffer-substring"
operator|,
name|Finsert_buffer_substring
operator|,
name|Sinsert_buffer_substring
operator|,
literal|1
operator|,
literal|3
operator|,
literal|0
operator|,
literal|"Insert before point a substring of the contents buffer BUFFER.\n\ BUFFER may be a buffer or a buffer name.\n\ Arguments START and END are character numbers specifying the substring.\n\ They default to the beginning and the end of BUFFER."
operator|)
operator|(
name|buf
operator|,
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|buf
operator|,
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|exch
decl_stmt|;
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|==
name|bf_cur
condition|)
name|error
argument_list|(
literal|"Cannot insert buffer into itself"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|b
argument_list|)
condition|)
name|beg
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|head_clip
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XINT
argument_list|(
name|b
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|e
argument_list|)
condition|)
name|end
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|size1
operator|+
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|size2
operator|-
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|tail_clip
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
operator|=
name|XINT
argument_list|(
name|e
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|beg
operator|>
name|end
condition|)
name|exch
operator|=
name|beg
operator|,
name|beg
operator|=
name|end
operator|,
name|end
operator|=
name|exch
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|head_clip
operator|-
literal|1
operator|<=
name|beg
operator|&&
name|beg
operator|<=
name|end
operator|&&
name|end
operator|<=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|size1
operator|+
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|size2
operator|-
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|tail_clip
operator|)
condition|)
name|args_out_of_range
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|beg
operator|<
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|size1
condition|)
block|{
name|InsCStr
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|p1
operator|+
literal|1
operator|+
name|beg
argument_list|,
name|min
argument_list|(
name|end
argument_list|,
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|size1
argument_list|)
operator|-
name|beg
argument_list|)
expr_stmt|;
name|beg
operator|=
name|min
argument_list|(
name|end
argument_list|,
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|size1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|beg
operator|<
name|end
condition|)
name|InsCStr
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|p2
operator|+
literal|1
operator|+
name|beg
argument_list|,
name|end
operator|-
name|beg
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"subst-char-in-region"
argument_list|,
argument|Fsubst_char_in_region
argument_list|,
argument|Ssubst_char_in_region
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|"From START to END, replace FROMCHAR with TOCHAR each time it occurs.\n\ If optional arg NOUNDO is non-nil, don't record this change for undo\n\ and don't mark the buffer as really changed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|start
operator|,
name|end
operator|,
name|fromchar
operator|,
name|tochar
operator|,
name|noundo
operator|)
name|Lisp_Object
name|start
operator|,
name|end
operator|,
name|fromchar
operator|,
name|tochar
operator|,
name|noundo
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|pos
decl_stmt|,
name|stop
decl_stmt|,
name|look
decl_stmt|;
name|validate_region
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|fromchar
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|tochar
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|stop
operator|=
name|XINT
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|)
name|Fbarf_if_buffer_read_only
argument_list|()
expr_stmt|;
name|look
operator|=
name|XINT
argument_list|(
name|fromchar
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|stop
condition|)
block|{
if|if
condition|(
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|==
name|look
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|noundo
argument_list|)
condition|)
name|RecordChange
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CharAt
argument_list|(
name|pos
argument_list|)
operator|=
name|XINT
argument_list|(
name|tochar
argument_list|)
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
name|modify_region
argument_list|(
name|pos
argument_list|,
name|stop
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-region"
argument_list|,
argument|Fdelete_region
argument_list|,
argument|Sdelete_region
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"r"
argument_list|,
literal|"Delete the text between point and mark.\n\ When called from a program, expects two arguments,\n\ character numbers specifying the stretch to be deleted."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|validate_region
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|del_range
argument_list|(
name|XINT
argument_list|(
name|b
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"widen"
argument_list|,
argument|Fwiden
argument_list|,
argument|Swiden
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Remove restrictions from current buffer, allowing full text to be seen and edited."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|bf_cur
operator|->
name|text
operator|.
name|head_clip
operator|=
name|bf_head_clip
operator|=
literal|1
block|;
name|bf_cur
operator|->
name|text
operator|.
name|tail_clip
operator|=
name|bf_tail_clip
operator|=
literal|0
block|;
name|clip_changed
operator|=
literal|1
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"narrow-to-region"
argument_list|,
argument|Fnarrow_to_region
argument_list|,
argument|Snarrow_to_region
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"r"
argument_list|,
literal|"Restrict editing in current buffer to text between present values of point and mark.\n\ Use  widen  to undo the effects of this command.\n\ Called non-interactively, takes two arguments; character numbers which\n\ specify the stretch to which to restrict."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|b
argument_list|)
operator|>
name|XINT
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|i
operator|=
name|XFASTINT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|e
expr_stmt|;
name|XFASTINT
argument_list|(
name|e
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
literal|1
operator|<=
name|XINT
argument_list|(
name|b
argument_list|)
operator|&&
name|XINT
argument_list|(
name|b
argument_list|)
operator|<=
name|XINT
argument_list|(
name|e
argument_list|)
operator|&&
name|XINT
argument_list|(
name|e
argument_list|)
operator|<=
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|)
condition|)
name|args_out_of_range
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|text
operator|.
name|head_clip
operator|=
name|bf_head_clip
operator|=
name|XFASTINT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|text
operator|.
name|tail_clip
operator|=
name|bf_tail_clip
operator|=
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|XFASTINT
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|XFASTINT
argument_list|(
name|b
argument_list|)
condition|)
name|SetPoint
argument_list|(
name|XFASTINT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|>
name|XFASTINT
argument_list|(
name|e
argument_list|)
condition|)
name|SetPoint
argument_list|(
name|XFASTINT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|clip_changed
operator|=
literal|1
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|save_restriction_save
parameter_list|()
block|{
name|Lisp_Object
name|ml
decl_stmt|,
name|mh
decl_stmt|;
comment|/* Note: I tried using markers here, but it does not win      because insertion at the end of the saved region      does not advance mh and is considered "outside" the saved region. */
name|XFASTINT
argument_list|(
name|ml
argument_list|)
operator|=
name|bf_head_clip
expr_stmt|;
name|XFASTINT
argument_list|(
name|mh
argument_list|)
operator|=
name|bf_tail_clip
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|Fcons
argument_list|(
name|ml
argument_list|,
name|mh
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|save_restriction_restore
parameter_list|(
name|data
parameter_list|)
name|Lisp_Object
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|int
name|newhead
decl_stmt|,
name|newtail
decl_stmt|;
name|Fset_buffer
argument_list|(
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
name|data
operator|=
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|newhead
operator|=
name|XINT
argument_list|(
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
name|newtail
operator|=
name|XINT
argument_list|(
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|cdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|newhead
operator|+
name|newtail
operator|>
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
condition|)
block|{
name|newhead
operator|=
literal|1
expr_stmt|;
name|newtail
operator|=
literal|0
expr_stmt|;
block|}
name|bf_cur
operator|->
name|text
operator|.
name|head_clip
operator|=
name|bf_head_clip
operator|=
name|newhead
expr_stmt|;
name|bf_cur
operator|->
name|text
operator|.
name|tail_clip
operator|=
name|bf_tail_clip
operator|=
name|newtail
expr_stmt|;
name|clip_changed
operator|=
literal|1
expr_stmt|;
comment|/* If point is outside the new visible range, move it inside. */
if|if
condition|(
name|point
operator|<
name|FirstCharacter
condition|)
name|SetPoint
argument_list|(
name|FirstCharacter
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|SetPoint
argument_list|(
name|NumCharacters
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"save-restriction"
argument_list|,
argument|Fsave_restriction
argument_list|,
argument|Ssave_restriction
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Execute the body, undoing at the end any changes to current buffer's restrictions.\n\ Changes to restrictions are made by narrow-to-region or by widen.\n\ Thus, the restrictions are the same after this function as they were before it.\n\ The value returned is that returned by the last form in the body.\n\ \n\ This function can be confused if, within the body, you widen\n\ and then make changes outside the area within the saved restrictions.\n\ \n\ Note: if you are using both save-excursion and save-restriction,\n\ use save-excursion outermost."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|body
operator|)
name|Lisp_Object
name|body
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|record_unwind_protect
argument_list|(
name|save_restriction_restore
argument_list|,
name|save_restriction_save
argument_list|()
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"message"
argument_list|,
argument|Fmessage
argument_list|,
argument|Smessage
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Print a one-line message at the bottom of the screen.\n\ The first argument is a control string.\n\ It may contain %s or %d or %c to print successive following arguments.\n\ %s means print an argument as a string, %d means print as number in decimal,\n\ %c means print a number as a single character.\n\ The argument used by %s must be a string or a symbol;\n\ the argument used by %d or %c must be a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|Fformat
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"%s"
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"format"
argument_list|,
argument|Fformat
argument_list|,
argument|Sformat
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Format a string out of a control-string and arguments.\n\ The first argument is a control string.\n\ It, and subsequent arguments substituted into it, become the value, which is a string.\n\ It may contain %s or %d or %c to substitute successive following arguments.\n\ %s means print an argument as a string, %d means print as number in decimal,\n\ %c means print a number as a single character.\n\ The argument used by %s must be a string or a symbol;\n\ the argument used by %d, %b, %o, %x or %c must be a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|total
init|=
literal|5
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|strings
init|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|strings
index|[
name|i
index|]
operator|=
name|XSYMBOL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|->
name|name
operator|->
name|data
expr_stmt|;
name|total
operator|+=
name|XSYMBOL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|->
name|name
operator|->
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|strings
index|[
name|i
index|]
operator|=
name|XSTRING
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
name|total
operator|+=
name|XSTRING
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|strings
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XINT
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|total
operator|+=
literal|10
expr_stmt|;
block|}
else|else
block|{
name|strings
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"??"
expr_stmt|;
name|total
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Format it in bigger and bigger buf's until it all fits. */
while|while
condition|(
literal|1
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|total
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|total
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|doprnt
argument_list|(
name|buf
argument_list|,
name|total
operator|+
literal|1
argument_list|,
name|strings
index|[
literal|0
index|]
argument_list|,
name|strings
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|total
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
name|total
operator|*=
literal|2
expr_stmt|;
block|}
return|return
name|build_string
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* VARARGS 1 */
end_comment

begin_function
name|Lisp_Object
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|format1
parameter_list|(
name|string1
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|Lisp_Object
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|;
else|#
directive|else
function|format1
parameter_list|(
name|string1
parameter_list|)
endif|#
directive|endif
name|char
modifier|*
name|string1
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|Lisp_Object
name|args
index|[
literal|5
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|arg3
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|arg4
expr_stmt|;
name|doprnt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|string1
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|doprnt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|string1
argument_list|,
operator|&
name|string1
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|build_string
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"char-equal"
argument_list|,
argument|Fchar_equal
argument_list|,
argument|Schar_equal
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if args (both characters (numbers)) match.  May ignore case.\n\ Case is ignored if the current buffer specifies to do so."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|c1
operator|,
name|c2
operator|)
name|Lisp_Object
name|c1
operator|,
name|c2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|char
name|downcase_table
index|[]
decl_stmt|;
comment|/* From search.c */
name|CHECK_NUMBER
argument_list|(
name|c1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|c2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|case_fold_search
argument_list|)
condition|?
name|downcase_table
index|[
name|XINT
argument_list|(
name|c1
argument_list|)
index|]
operator|==
name|downcase_table
index|[
name|XINT
argument_list|(
name|c2
argument_list|)
index|]
else|:
name|XINT
argument_list|(
name|c1
argument_list|)
operator|==
name|XINT
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"getenv"
argument_list|,
argument|Fgetenv
argument_list|,
argument|Sgetenv
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"sEnvironment variable: "
argument_list|,
literal|"One arg VAR, a string. Return the value of environment variable VAR, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|Qnil
return|;
return|return
name|build_string
argument_list|(
name|val
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|void
name|syms_of_editfns
parameter_list|()
block|{
name|defsubr
argument_list|(
operator|&
name|Schar_equal
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgoto_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstring_to_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Schar_to_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_substring
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_marker
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Spoint_marker
argument_list|,
literal|"dot-marker"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smark_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Spoint
argument_list|,
literal|"dot"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sregion_beginning
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sregion_end
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smark
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_mark
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssave_excursion
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbufsize
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_max
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_min
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Spoint_max
argument_list|,
literal|"dot-max"
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Spoint_min
argument_list|,
literal|"dot-min"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_min_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_max_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbobp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seobp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbolp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seolp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfollchar
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprevchar
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Schar_after
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_before_markers
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_login_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_real_login_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_full_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_time_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgetenv
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssystem_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smessage
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sformat
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_buffer_substring
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubst_char_in_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swiden
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snarrow_to_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssave_restriction
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

