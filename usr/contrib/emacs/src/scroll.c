begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate what ins/del line to do, and do it, for Emacs redisplay.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* All costs measured in characters.  Therefore, no cost    can exceed MScreenLength * MScreenWidth (or so).    That is about 10000, which fits in a short.  */
end_comment

begin_define
define|#
directive|define
name|INFINITY
value|15000
end_define

begin_struct
struct|struct
name|matrix_elt
block|{
comment|/* Cost of outputting through this line        if no insert/delete is done just above it.  */
name|short
name|writecost
decl_stmt|;
comment|/* Cost of outputting through this line        if an insert is done just above it.  */
name|short
name|insertcost
decl_stmt|;
comment|/* Cost of outputting through this line        if a delete is done just above it.  */
name|short
name|deletecost
decl_stmt|;
comment|/* Number of inserts so far in this run of inserts,        for the cost in insertcost.  */
name|char
name|insertcount
decl_stmt|;
comment|/* Number of deletes so far in this run of deletes,        for the cost in deletecost.  */
name|char
name|deletecount
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* See CalcIDCosts for on the arrays below */
end_comment

begin_decl_stmt
name|int
name|ILcost
index|[
name|MScreenLength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ov(n) + 1*mf(n) */
end_comment

begin_decl_stmt
name|int
name|DLcost
index|[
name|MScreenLength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ov(n) + 1*mf(n) */
end_comment

begin_decl_stmt
name|int
name|ILncost
index|[
name|MScreenLength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mf(n) */
end_comment

begin_decl_stmt
name|int
name|DLncost
index|[
name|MScreenLength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mf(n) */
end_comment

begin_escape
end_escape

begin_macro
name|scrolling_1
argument_list|(
argument|window_size
argument_list|,
argument|unchanged_at_top
argument_list|,
argument|unchanged_at_bottom
argument_list|,
argument|draw_cost
argument_list|,
argument|old_hash
argument_list|,
argument|new_hash
argument_list|,
argument|free_at_end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|window_size
decl_stmt|,
name|unchanged_at_top
decl_stmt|,
name|unchanged_at_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|draw_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|old_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|new_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_at_end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|matrix_elt
modifier|*
name|matrix
decl_stmt|;
name|matrix
operator|=
operator|(
operator|(
expr|struct
name|matrix_elt
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|*
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|matrix
argument_list|)
operator|)
expr_stmt|;
name|calculate_scrolling
argument_list|(
name|matrix
argument_list|,
name|window_size
argument_list|,
name|unchanged_at_bottom
argument_list|,
name|draw_cost
argument_list|,
name|old_hash
argument_list|,
name|new_hash
argument_list|,
name|free_at_end
argument_list|)
expr_stmt|;
name|do_scrolling
argument_list|(
name|matrix
argument_list|,
name|window_size
argument_list|,
name|unchanged_at_top
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Determine, in matrix[i,j], the cost of updating the first j old lines    into the first i new lines.    This involves using insert or delete somewhere if i != j.    For each matrix elements, three kinds of costs are recorded:    the smallest cost that ends with an insert, the smallest    cost that ends with a delete, and the smallest cost that    ends with neither one.  These are kept separate because    on some terminals the cost of doing an insert varies    depending on whether one was just done, etc.  */
end_comment

begin_comment
comment|/* draw_cost[VPOS] is the cost of outputting new line at VPOS.    old_hash[VPOS] is the hash code of the old line at VPOS.    new_hash[VPOS] is the hash code of the new line at VPOS.    Note that these are not true screen vpos's, but relative    to the place at which the first mismatch between old and    new contents appears.  */
end_comment

begin_macro
name|calculate_scrolling
argument_list|(
argument|matrix
argument_list|,
argument|window_size
argument_list|,
argument|lines_below
argument_list|,
argument|draw_cost
argument_list|,
argument|old_hash
argument_list|,
argument|new_hash
argument_list|,
argument|free_at_end
argument_list|)
end_macro

begin_comment
comment|/* matrix is of size window_size + 1 on each side.  */
end_comment

begin_decl_stmt
name|struct
name|matrix_elt
modifier|*
name|matrix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|window_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|draw_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|old_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|new_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_at_end
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|matrix_elt
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|cost
decl_stmt|,
name|cost1
decl_stmt|;
name|int
name|lines_moved
init|=
name|window_size
operator|+
operator|(
name|scroll_region_ok
condition|?
literal|0
else|:
name|lines_below
operator|)
decl_stmt|;
name|int
modifier|*
name|first_insert_cost
init|=
operator|&
name|ILcost
index|[
name|screen_height
operator|-
name|lines_moved
index|]
decl_stmt|;
name|int
modifier|*
name|first_delete_cost
init|=
operator|&
name|DLcost
index|[
name|screen_height
operator|-
name|lines_moved
index|]
decl_stmt|;
name|int
modifier|*
name|next_insert_cost
init|=
operator|&
name|ILncost
index|[
name|screen_height
operator|-
name|lines_moved
index|]
decl_stmt|;
name|int
modifier|*
name|next_delete_cost
init|=
operator|&
name|DLncost
index|[
name|screen_height
operator|-
name|lines_moved
index|]
decl_stmt|;
comment|/* initialize the top left corner of the matrix */
name|matrix
operator|->
name|writecost
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|insertcost
operator|=
name|INFINITY
expr_stmt|;
name|matrix
operator|->
name|deletecost
operator|=
name|INFINITY
expr_stmt|;
name|matrix
operator|->
name|insertcount
operator|=
literal|0
expr_stmt|;
name|matrix
operator|->
name|deletecount
operator|=
literal|0
expr_stmt|;
comment|/* initialize the left edge of the matrix */
name|cost
operator|=
name|first_insert_cost
index|[
literal|1
index|]
operator|-
name|next_insert_cost
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|window_size
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|matrix
operator|+
name|i
operator|*
operator|(
name|window_size
operator|+
literal|1
operator|)
expr_stmt|;
name|cost
operator|+=
name|draw_cost
index|[
name|i
index|]
operator|+
name|next_insert_cost
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|insertcost
operator|=
name|cost
expr_stmt|;
name|p
operator|->
name|writecost
operator|=
name|INFINITY
expr_stmt|;
name|p
operator|->
name|deletecost
operator|=
name|INFINITY
expr_stmt|;
name|p
operator|->
name|insertcount
operator|=
name|i
expr_stmt|;
name|p
operator|->
name|deletecount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* initialize the top edge of the matrix */
name|cost
operator|=
name|first_delete_cost
index|[
literal|1
index|]
operator|-
name|next_delete_cost
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|window_size
condition|;
name|j
operator|++
control|)
block|{
name|cost
operator|+=
name|next_delete_cost
index|[
name|j
index|]
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|deletecost
operator|=
name|cost
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|writecost
operator|=
name|INFINITY
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|insertcost
operator|=
name|INFINITY
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|deletecount
operator|=
name|j
expr_stmt|;
name|matrix
index|[
name|j
index|]
operator|.
name|insertcount
operator|=
name|j
expr_stmt|;
block|}
comment|/* `i' represents the vpos among new screen contents.      `j' represents the vpos among the old screen contents.  */
name|p
operator|=
name|matrix
operator|+
name|window_size
operator|+
literal|2
expr_stmt|;
comment|/* matrix [1, 1] */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|window_size
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|window_size
condition|;
name|j
operator|++
operator|,
name|p
operator|++
control|)
block|{
comment|/* p contains the address of matrix [i, j] */
comment|/* First calculate the cost assuming we do 	   not insert or delete above this line. 	   That is, if we update through line i-1 	   based on old lines through j-1, 	   and then just change old line j to new line i.  */
name|p1
operator|=
name|p
operator|-
name|window_size
operator|-
literal|2
expr_stmt|;
comment|/* matrix [i-1, j-1] */
name|cost
operator|=
name|p1
operator|->
name|writecost
expr_stmt|;
if|if
condition|(
name|cost
operator|>
name|p1
operator|->
name|insertcost
condition|)
name|cost
operator|=
name|p1
operator|->
name|insertcost
expr_stmt|;
if|if
condition|(
name|cost
operator|>
name|p1
operator|->
name|deletecost
condition|)
name|cost
operator|=
name|p1
operator|->
name|deletecost
expr_stmt|;
if|if
condition|(
name|old_hash
index|[
name|j
index|]
operator|!=
name|new_hash
index|[
name|i
index|]
condition|)
name|cost
operator|+=
name|draw_cost
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|writecost
operator|=
name|cost
expr_stmt|;
comment|/* Calculate the cost if we do an insert-line 	   before outputting this line. 	   That is, we update through line i-1 	   based on old lines through j, 	   do an insert-line on line i, 	   and then output line i from scratch, 	   leaving old lines starting from j for reuse below.  */
name|p1
operator|=
name|p
operator|-
name|window_size
operator|-
literal|1
expr_stmt|;
comment|/* matrix [i-1, j] */
comment|/* No need to think about doing a delete followed 	   immediately by an insert.  It cannot be as good 	   as not doing either of them.  */
if|if
condition|(
name|free_at_end
operator|==
name|i
condition|)
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|insertcost
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
operator|+
name|first_insert_cost
index|[
name|i
index|]
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|insertcost
operator|+
name|next_insert_cost
index|[
name|i
operator|-
name|p1
operator|->
name|insertcount
index|]
expr_stmt|;
block|}
name|p
operator|->
name|insertcost
operator|=
name|min
argument_list|(
name|cost
argument_list|,
name|cost1
argument_list|)
operator|+
name|draw_cost
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|insertcount
operator|=
operator|(
name|cost
operator|<
name|cost1
operator|)
condition|?
literal|1
else|:
name|p1
operator|->
name|insertcount
operator|+
literal|1
expr_stmt|;
comment|/* Calculate the cost if we do a delete line after 	   outputting this line. 	   That is, we update through line i 	   based on old lines through j-1, 	   and throw away old line j.  */
name|p1
operator|=
name|p
operator|-
literal|1
expr_stmt|;
comment|/* matrix [i, j-1] */
comment|/* No need to think about doing an insert followed 	   immediately by a delete.  */
if|if
condition|(
name|free_at_end
operator|==
name|i
condition|)
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|deletecost
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
name|p1
operator|->
name|writecost
operator|+
name|first_delete_cost
index|[
name|i
index|]
expr_stmt|;
name|cost1
operator|=
name|p1
operator|->
name|deletecost
operator|+
name|next_delete_cost
index|[
name|i
index|]
expr_stmt|;
block|}
name|p
operator|->
name|deletecost
operator|=
name|min
argument_list|(
name|cost
argument_list|,
name|cost1
argument_list|)
expr_stmt|;
name|p
operator|->
name|deletecount
operator|=
operator|(
name|cost
operator|<
name|cost1
operator|)
condition|?
literal|1
else|:
name|p1
operator|->
name|deletecount
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Perform insert-lines and delete-lines operations  according to the costs in the matrix.  Updates the contents of PhysScreen to record what was done. */
end_comment

begin_macro
name|do_scrolling
argument_list|(
argument|matrix
argument_list|,
argument|window_size
argument_list|,
argument|unchanged_at_top
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|matrix_elt
modifier|*
name|matrix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|window_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unchanged_at_top
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|matrix_elt
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
struct|struct
block|{
name|int
name|count
decl_stmt|,
name|pos
decl_stmt|;
block|}
name|queue
index|[
name|MScreenLength
index|]
struct|;
name|int
name|offset
init|=
name|unchanged_at_top
decl_stmt|;
name|int
name|qi
init|=
literal|0
decl_stmt|;
name|int
name|window
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|;
specifier|extern
name|struct
name|display_line
modifier|*
name|PhysScreen
index|[
name|MScreenLength
operator|+
literal|1
index|]
decl_stmt|;
specifier|extern
name|struct
name|display_line
modifier|*
name|OPhysScreen
index|[
name|MScreenLength
operator|+
literal|1
index|]
decl_stmt|;
comment|/* First do all deletions of lines; queue up insertions.   Also move lines to correct slots in PhysScreen */
name|i
operator|=
name|j
operator|=
name|window_size
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|||
name|j
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|matrix
operator|+
name|i
operator|*
operator|(
name|window_size
operator|+
literal|1
operator|)
operator|+
name|j
expr_stmt|;
name|tem
operator|=
name|p
operator|->
name|insertcost
expr_stmt|;
if|if
condition|(
name|tem
operator|<
name|p
operator|->
name|writecost
operator|&&
name|tem
operator|<
name|p
operator|->
name|deletecost
condition|)
block|{
comment|/* Insert should be done at vpos i-1, plus maybe some before */
name|queue
index|[
name|qi
index|]
operator|.
name|count
operator|=
name|p
operator|->
name|insertcount
expr_stmt|;
name|i
operator|-=
name|p
operator|->
name|insertcount
expr_stmt|;
name|queue
index|[
name|qi
operator|++
index|]
operator|.
name|pos
operator|=
name|i
operator|+
name|unchanged_at_top
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|deletecost
operator|<
name|p
operator|->
name|writecost
condition|)
block|{
comment|/* Old line at vpos j-1, and maybe some before it, 	     should be deleted */
name|j
operator|-=
name|p
operator|->
name|deletecount
expr_stmt|;
if|if
condition|(
operator|!
name|window
condition|)
block|{
name|set_terminal_window
argument_list|(
name|window_size
operator|+
name|unchanged_at_top
argument_list|)
expr_stmt|;
name|window
operator|=
literal|1
expr_stmt|;
block|}
name|ins_del_lines
argument_list|(
name|j
operator|+
name|unchanged_at_top
argument_list|,
operator|-
name|p
operator|->
name|deletecount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Best thing done here is no insert or delete */
comment|/* Old line at vpos j-1 ends up at vpos i-1 */
name|PhysScreen
index|[
name|i
operator|+
name|offset
index|]
operator|=
name|OPhysScreen
index|[
name|j
operator|+
name|offset
index|]
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|window
operator|&&
name|qi
condition|)
block|{
name|set_terminal_window
argument_list|(
name|window_size
operator|+
name|unchanged_at_top
argument_list|)
expr_stmt|;
name|window
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now do all insertions */
for|for
control|(
name|i
operator|=
name|qi
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ins_del_lines
argument_list|(
name|queue
index|[
name|i
index|]
operator|.
name|pos
argument_list|,
name|queue
index|[
name|i
index|]
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* mark the inserted lines as clear */
name|tem
operator|=
name|queue
index|[
name|i
index|]
operator|.
name|pos
expr_stmt|;
for|for
control|(
name|j
operator|=
name|tem
operator|+
name|queue
index|[
name|i
index|]
operator|.
name|count
init|;
name|j
operator|>
name|tem
condition|;
name|j
operator|--
control|)
name|PhysScreen
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|window
condition|)
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return number of lines in common between PhysScreen and DesiredScreen,    considering only vpos range START to END (not including END).    Ignores short lines (length< 20) on the assumption that    avoiding redrawing such a line will have little weight.  */
end_comment

begin_function
name|int
name|scrolling_max_lines_saved
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|oldhash
parameter_list|,
name|newhash
parameter_list|,
name|cost
parameter_list|)
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
modifier|*
name|oldhash
decl_stmt|,
decl|*
name|newhash
decl_stmt|,
modifier|*
name|cost
decl_stmt|;
end_function

begin_block
block|{
struct|struct
block|{
name|int
name|hash
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
name|lines
index|[
literal|01000
index|]
struct|;
specifier|register
name|int
name|i
decl_stmt|,
name|h
decl_stmt|;
specifier|register
name|int
name|matchcount
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|lines
argument_list|,
sizeof|sizeof
name|lines
argument_list|)
expr_stmt|;
comment|/* Put new lines' hash codes in hash table.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cost
index|[
name|i
index|]
operator|>
literal|20
condition|)
block|{
name|h
operator|=
name|newhash
index|[
name|i
index|]
operator|&
literal|0777
expr_stmt|;
name|lines
index|[
name|h
index|]
operator|.
name|hash
operator|=
name|newhash
index|[
name|i
index|]
expr_stmt|;
name|lines
index|[
name|h
index|]
operator|.
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Look up old line hash codes in the hash table.      Count number of matches between old lines and new.  */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|oldhash
index|[
name|i
index|]
operator|&
literal|0777
expr_stmt|;
if|if
condition|(
name|oldhash
index|[
name|i
index|]
operator|==
name|lines
index|[
name|h
index|]
operator|.
name|hash
condition|)
block|{
name|matchcount
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|lines
index|[
name|h
index|]
operator|.
name|count
operator|==
literal|0
condition|)
name|lines
index|[
name|h
index|]
operator|.
name|hash
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|matchcount
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Calculate the insert and delete line costs.     We keep the ID costs in a precomputed array based on the position    at which the I or D is performed.  Also, there are two kinds of ID    costs: the "once-only" and the "repeated".  This is to handle both    those terminals that are able to insert N lines at a time (once-    only) and those that must repeatedly insert one line.     The cost to insert N lines at line L is    	    [tt.t_ILov  + (screen_height + 1 - L) * tt.t_ILpf] + 	N * [tt.t_ILnov + (screen_height + 1 - L) * tt.t_ILnpf]     ILov represents the basic insert line overhead.  ILpf is the padding    required to allow the terminal time to move a line: insertion at line    L changes (screen_height + 1 - L) lines.     The first bracketed expression above is the overhead; the second is    the multiply factor.  Both are dependent only on the position at    which the insert is performed.  We store the overhead in ILcost and    the multiply factor in ILncost.  Note however that any insertion    must include at least one multiply factor.  Rather than compute this    as ILcost[line]+ILncost[line], we add ILncost into ILcost.  This is    reasonable because of the particular algorithm used in calcM.     Deletion is essentially the same as insertion.  */
end_comment

begin_macro
name|CalcIDCosts
argument_list|(
argument|ins_line_string
argument_list|,
argument|multi_ins_string
argument_list|,
argument|del_line_string
argument_list|,
argument|multi_del_string
argument_list|,
argument|setup_string
argument_list|,
argument|cleanup_string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ins_line_string
decl_stmt|,
modifier|*
name|multi_ins_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|del_line_string
decl_stmt|,
modifier|*
name|multi_del_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|setup_string
decl_stmt|,
modifier|*
name|cleanup_string
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Discourage long scrolls slightly on fast lines.      This says that scrolling nearly the full length of the screen      is not worth it if reprinting takes less than 1/4 second.  */
name|int
name|extra
init|=
name|baud_rate
operator|/
operator|(
literal|10
operator|*
literal|4
operator|*
name|screen_height
operator|)
decl_stmt|;
name|CalcIDCosts1
argument_list|(
name|ins_line_string
argument_list|,
name|multi_ins_string
argument_list|,
name|setup_string
argument_list|,
name|cleanup_string
argument_list|,
name|ILcost
argument_list|,
name|ILncost
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|CalcIDCosts1
argument_list|(
name|del_line_string
argument_list|,
name|multi_del_string
argument_list|,
name|setup_string
argument_list|,
name|cleanup_string
argument_list|,
name|DLcost
argument_list|,
name|DLncost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|CalcIDCosts1
argument_list|(
argument|one_line_string
argument_list|,
argument|multi_string
argument_list|,
argument|setup_string
argument_list|,
argument|cleanup_string
argument_list|,
argument|costvec
argument_list|,
argument|ncostvec
argument_list|,
argument|extra
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|one_line_string
decl_stmt|,
modifier|*
name|multi_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|setup_string
decl_stmt|,
modifier|*
name|cleanup_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|costvec
decl_stmt|,
modifier|*
name|ncostvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|multi_string
condition|)
name|CalcLID
argument_list|(
name|string_cost
argument_list|(
name|multi_string
argument_list|)
argument_list|,
name|per_line_cost
argument_list|(
name|multi_string
argument_list|)
argument_list|,
name|extra
argument_list|,
literal|0
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|one_line_string
condition|)
name|CalcLID
argument_list|(
name|string_cost
argument_list|(
name|setup_string
argument_list|)
operator|+
name|string_cost
argument_list|(
name|cleanup_string
argument_list|)
argument_list|,
literal|0
argument_list|,
name|string_cost
argument_list|(
name|one_line_string
argument_list|)
operator|+
name|extra
argument_list|,
name|per_line_cost
argument_list|(
name|one_line_string
argument_list|)
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
else|else
name|CalcLID
argument_list|(
literal|9999
argument_list|,
literal|0
argument_list|,
literal|9999
argument_list|,
literal|0
argument_list|,
name|costvec
argument_list|,
name|ncostvec
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Calculate the line ID overhead and multiply factor values */
end_comment

begin_macro
name|CalcLID
argument_list|(
argument|ov1
argument_list|,
argument|pf1
argument_list|,
argument|ovn
argument_list|,
argument|pfn
argument_list|,
argument|ov
argument_list|,
argument|mf
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ov1
decl_stmt|,
name|ovn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pf1
decl_stmt|,
name|pfn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|ov
decl_stmt|,
modifier|*
name|mf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|insert_overhead
init|=
name|ov1
operator|*
literal|10
operator|+
name|screen_height
operator|*
name|pf1
decl_stmt|;
specifier|register
name|int
name|next_insert_cost
init|=
name|ovn
operator|*
literal|10
operator|+
name|screen_height
operator|*
name|pfn
decl_stmt|;
for|for
control|(
name|i
operator|=
name|screen_height
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|mf
operator|++
operator|=
name|next_insert_cost
operator|/
literal|10
expr_stmt|;
name|next_insert_cost
operator|-=
name|pfn
expr_stmt|;
operator|*
name|ov
operator|++
operator|=
operator|(
name|insert_overhead
operator|+
name|next_insert_cost
operator|)
operator|/
literal|10
expr_stmt|;
name|insert_overhead
operator|-=
name|pf1
expr_stmt|;
block|}
block|}
end_block

end_unit

