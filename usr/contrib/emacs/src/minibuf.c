begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Minibuffer input and completion.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* List of buffers for use as minibuffers.   The first element of the list is used for the outermost minibuffer invocation,   the next element is used for a recursive minibuffer invocation, etc.   The list is extended at the end as deeped minibuffer recursions are encountered. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_list
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|minibuf_save_data
block|{
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|prompt_width
decl_stmt|;
name|Lisp_Object
name|help_form
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|minibuf_save_vector_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|minibuf_save_data
modifier|*
name|minibuf_save_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|auto_help
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means display completion help for invalid input */
end_comment

begin_comment
comment|/* Fread_minibuffer leaves the input, as a string, here */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_minibuf_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means let functions called when within a minibuffer     invoke recursive minibuffers (to read arguments, or whatever) */
end_comment

begin_decl_stmt
name|int
name|enable_recursive_minibuffers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* help-form is bound to this while in the minibuffer.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_help_form
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means completion ignores case.  */
end_comment

begin_decl_stmt
name|int
name|completion_ignore_case
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Quser_variable_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width in columns of current minibuffer prompt.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|minibuf_prompt_width
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Actual minibuffer invocation. */
end_comment

begin_function_decl
name|void
name|read_minibuf_string_unwind
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|get_minibuffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|read_minibuf
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|Lisp_Object
name|read_minibuf_string
parameter_list|(
name|map
parameter_list|,
name|prefix
parameter_list|,
name|prompt
parameter_list|)
name|Lisp_Object
name|map
decl_stmt|;
name|Lisp_Object
name|prefix
decl_stmt|;
name|Lisp_Object
name|prompt
decl_stmt|;
block|{
return|return
name|read_minibuf
argument_list|(
name|map
argument_list|,
name|prefix
argument_list|,
name|prompt
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|read_minibuf
parameter_list|(
name|map
parameter_list|,
name|prefix
parameter_list|,
name|prompt
parameter_list|,
name|expflag
parameter_list|)
name|Lisp_Object
name|map
decl_stmt|;
name|Lisp_Object
name|prefix
decl_stmt|;
name|Lisp_Object
name|prompt
decl_stmt|;
name|int
name|expflag
decl_stmt|;
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
if|if
condition|(
operator|!
name|enable_recursive_minibuffers
operator|&&
operator|(
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Command attempted to use minibuffer while in minibuffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MinibufDepth
operator|==
name|minibuf_save_vector_size
condition|)
name|minibuf_save_vector
operator|=
operator|(
expr|struct
name|minibuf_save_data
operator|*
operator|)
name|xrealloc
argument_list|(
name|minibuf_save_vector
argument_list|,
operator|(
name|minibuf_save_vector_size
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minibuf_save_data
argument_list|)
argument_list|)
expr_stmt|;
name|minibuf_save_vector
index|[
name|MinibufDepth
index|]
operator|.
name|prompt
operator|=
name|minibuf_prompt
expr_stmt|;
name|minibuf_save_vector
index|[
name|MinibufDepth
index|]
operator|.
name|help_form
operator|=
name|Vhelp_form
expr_stmt|;
name|minibuf_save_vector
index|[
name|MinibufDepth
index|]
operator|.
name|prompt_width
operator|=
name|minibuf_prompt_width
expr_stmt|;
name|minibuf_prompt_width
operator|=
literal|0
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|save_window_restore
argument_list|,
name|save_window_save
argument_list|()
argument_list|)
expr_stmt|;
name|val
operator|=
name|bf_cur
operator|->
name|directory
expr_stmt|;
name|Fset_buffer
argument_list|(
name|get_minibuffer
argument_list|(
name|MinibufDepth
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|directory
operator|=
name|val
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|minibuf_window
argument_list|,
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
name|Fselect_window
argument_list|(
name|minibuf_window
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|hscroll
argument_list|)
operator|=
literal|0
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|MinibufDepth
operator|++
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|read_minibuf_string_unwind
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|prefix
argument_list|)
condition|)
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|prefix
argument_list|)
expr_stmt|;
name|minibuf_prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|data
argument_list|,
name|minibuf_prompt
argument_list|,
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|minibuf_message
operator|=
literal|0
expr_stmt|;
name|Vhelp_form
operator|=
name|Vminibuffer_help_form
expr_stmt|;
name|bf_cur
operator|->
name|keymap
operator|=
name|map
expr_stmt|;
name|Frecursive_edit
argument_list|()
expr_stmt|;
comment|/* If cursor is on the minibuffer line,      show the user we have exited by putting it in column 0.  */
if|if
condition|(
name|cursY
operator|>=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|top
argument_list|)
operator|&&
operator|!
name|noninteractive
condition|)
block|{
name|cursX
operator|=
literal|0
expr_stmt|;
name|update_screen
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make minibuffer contents into a string */
name|val
operator|=
name|make_string
argument_list|(
operator|&
name|CharAt
argument_list|(
literal|1
argument_list|)
argument_list|,
name|bf_s1
operator|+
name|bf_s2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bf_p2
operator|+
name|bf_s1
operator|+
literal|1
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
operator|+
name|bf_s1
argument_list|,
name|bf_s2
argument_list|)
expr_stmt|;
name|last_minibuf_string
operator|=
name|val
expr_stmt|;
comment|/* If Lisp form desired instead of string, read buffer contents */
if|if
condition|(
name|expflag
condition|)
block|{
name|SetPoint
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fread
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a buffer to be used as the minibuffer at depth `depth'.  depth = 0 is the lowest allowed argument, and that is the value  used for nonrecursive minibuffer invocations */
end_comment

begin_function
name|Lisp_Object
name|get_minibuffer
parameter_list|(
name|depth
parameter_list|)
name|int
name|depth
decl_stmt|;
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|num
decl_stmt|,
name|buf
decl_stmt|;
name|char
name|name
index|[
literal|14
index|]
decl_stmt|;
specifier|extern
name|Lisp_Object
name|nconc2
parameter_list|()
function_decl|;
name|XFASTINT
argument_list|(
name|num
argument_list|)
operator|=
name|depth
expr_stmt|;
name|tail
operator|=
name|Fnthcdr
argument_list|(
name|num
argument_list|,
name|Vminibuffer_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|tail
operator|=
name|Fcons
argument_list|(
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Vminibuffer_list
operator|=
name|nconc2
argument_list|(
name|Vminibuffer_list
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buf
argument_list|)
operator|||
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|name
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|" *Minibuf-%d*"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
operator|=
name|buf
expr_stmt|;
block|}
else|else
name|reset_buffer
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* This function is called on exiting minibuffer, whether normally or not,  and it restores the current window, buffer, etc. */
end_comment

begin_function
name|void
name|read_minibuf_string_unwind
parameter_list|()
block|{
name|Ferase_buffer
argument_list|()
expr_stmt|;
comment|/* If this was a recursive minibuffer,      tie the minibuffer window back to the outer level minibuffer buffer */
name|MinibufDepth
operator|--
expr_stmt|;
comment|/* Make sure minibuffer window is erased, not ignored */
name|windows_or_buffers_changed
operator|++
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Restore prompt from outer minibuffer */
name|minibuf_prompt
operator|=
name|minibuf_save_vector
index|[
name|MinibufDepth
index|]
operator|.
name|prompt
expr_stmt|;
name|minibuf_prompt_width
operator|=
name|minibuf_save_vector
index|[
name|MinibufDepth
index|]
operator|.
name|prompt_width
expr_stmt|;
name|Vhelp_form
operator|=
name|minibuf_save_vector
index|[
name|MinibufDepth
index|]
operator|.
name|help_form
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"read-from-minibuffer"
argument_list|,
argument|Fread_from_minibuffer
argument_list|,
argument|Sread_from_minibuffer
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Read a string from the minibuffer, prompting with string PROMPT.\n\ If optional second arg INITIAL-CONTENTS is non-nil, it is a string\n\   to be inserted into the minibuffer before reading input.\n\ Third arg KEYMAP is a keymap to use whilst reading; the default is\n\   minibuffer-local-map.\n\ If fourth arg READ is non-nil, then interpret the result as a lisp object\n\   and return that object  (ie  (car (read-from-string<input-string>)))"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_input
operator|,
name|keymap
operator|,
name|read
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_input
operator|,
name|keymap
operator|,
name|read
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|initial_input
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
name|initial_input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|keymap
argument_list|)
condition|)
name|keymap
operator|=
name|Vminibuffer_local_map
expr_stmt|;
else|else
name|keymap
operator|=
name|get_keymap
argument_list|(
name|keymap
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|read_minibuf
argument_list|(
name|keymap
argument_list|,
name|initial_input
argument_list|,
name|prompt
argument_list|,
operator|!
name|NULL
argument_list|(
name|read
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-minibuffer"
argument_list|,
argument|Fread_minibuffer
argument_list|,
argument|Sread_minibuffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a Lisp object read using the minibuffer.\n\ Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS\n\ is a string to insert in the minibuffer before reading."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_contents
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_contents
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|initial_contents
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
argument|initial_contents
argument_list|,
literal|1
argument_list|)
return|return
name|read_minibuf
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|initial_contents
argument_list|,
name|prompt
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"eval-minibuffer"
argument_list|,
argument|Feval_minibuffer
argument_list|,
argument|Seval_minibuffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return value of Lisp expression read using the minibuffer.\n\ Prompt with PROMPT.  If non-nil, optional second arg INITIAL-CONTENTS\n\ is a string to insert in the minibuffer before reading."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_contents
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_contents
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Feval
argument_list|(
name|Fread_minibuffer
argument_list|(
name|prompt
argument_list|,
name|initial_contents
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Functions that use the minibuffer to read various things. */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"read-string"
argument_list|,
argument|Fread_string
argument_list|,
argument|Sread_string
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Read a string from the minibuffer, prompting with string PROMPT.\n\ If non-nil second arg INITIAL-INPUT is a string to insert before reading."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|initial_input
operator|)
name|Lisp_Object
name|prompt
operator|,
name|initial_input
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fread_from_minibuffer
argument_list|(
name|prompt
argument_list|,
name|initial_input
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-no-blanks-input"
argument_list|,
argument|Fread_no_blanks_input
argument_list|,
argument|Sread_no_blanks_input
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Args PROMPT and INIT, strings.  Read a string from the terminal, not allowing blanks.\n\ Prompt with PROMPT, and provide INIT as an initial value of the input string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|init
operator|)
name|Lisp_Object
name|prompt
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|read_minibuf_string
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|init
argument_list|,
name|prompt
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-command"
argument_list|,
argument|Fread_command
argument_list|,
argument|Sread_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a command and return as a symbol.\n\ Prompts with PROMPT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fintern
argument_list|(
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vobarray
argument_list|,
name|Qcommandp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"read-function"
argument_list|,
argument|Fread_function
argument_list|,
argument|Sread_function
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a function and return as a symbol.\n\ Prompts with PROMPT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fintern
argument_list|(
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vobarray
argument_list|,
name|Qfboundp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"read-variable"
argument_list|,
argument|Fread_variable
argument_list|,
argument|Sread_variable
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a user variable and return\n\ it as a symbol.  Prompts with PROMPT.\n\ A user variable is one whose documentation starts with a \"*\" character."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fintern
argument_list|(
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vobarray
argument_list|,
name|Quser_variable_p
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"read-buffer"
argument_list|,
argument|Fread_buffer
argument_list|,
argument|Sread_buffer
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"One arg PROMPT, a string.  Read the name of a buffer and return as a string.\n\ Prompts with PROMPT.\n\ Optional second arg is value to return if user enters an empty line.\n\ If optional third arg REQUIRE-MATCH is non-nil, only existing buffer names are allowed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|def
operator|,
name|require_match
operator|)
name|Lisp_Object
name|prompt
operator|,
name|def
operator|,
name|require_match
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|args
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|def
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
name|def
operator|=
name|XBUFFER
argument_list|(
name|def
argument_list|)
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|def
argument_list|)
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|build_string
argument_list|(
literal|"%s(default %s) "
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|prompt
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|def
expr_stmt|;
name|prompt
operator|=
name|Fformat
argument_list|(
literal|3
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|GCPRO1
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcompleting_read
argument_list|(
name|prompt
argument_list|,
name|Vbuffer_alist
argument_list|,
name|Qnil
argument_list|,
name|require_match
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
condition|)
return|return
name|tem
return|;
return|return
name|def
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"try-completion"
argument_list|,
argument|Ftry_completion
argument_list|,
argument|Stry_completion
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Return common substring of all completions of STRING in ALIST.\n\ Each car of each element of ALIST is tested to see if it begins with STRING.\n\ All that match are compared together; the longest initial sequence\n\ common to all matches is returned as a string.\n\ If there is no match at all, nil is returned.\n\ For an exact match, t is returned.\n\ \n\ ALIST can be an obarray instead of an alist.\n\ Then the print names of all symbols in the obarray are the possible matches.\n\ \n\ If optional third argument PREDICATE is non-nil,\n\ it is used to test each possible match.\n\ The match is a candidate only if PREDICATE returns non-nil.\n\ The argument given to PREDICATE is the alist element or the symbol from the obarray."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|alist
operator|,
name|pred
operator|)
name|Lisp_Object
name|string
operator|,
name|alist
operator|,
name|pred
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|bestmatch
decl_stmt|,
name|tail
decl_stmt|,
name|elt
decl_stmt|,
name|eltstring
decl_stmt|;
name|int
name|bestmatchsize
decl_stmt|;
name|int
name|compare
decl_stmt|,
name|matchsize
decl_stmt|;
name|int
name|list
init|=
name|LISTP
argument_list|(
name|alist
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|,
name|obsize
decl_stmt|;
name|int
name|matchcount
init|=
literal|0
decl_stmt|;
name|Lisp_Object
name|bucket
decl_stmt|,
name|zero
decl_stmt|,
name|end
decl_stmt|,
name|tem
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|&&
name|XTYPE
argument_list|(
name|alist
argument_list|)
operator|!=
name|Lisp_Vector
condition|)
return|return
name|call3
argument_list|(
name|alist
argument_list|,
name|string
argument_list|,
name|pred
argument_list|,
name|Qnil
argument_list|)
return|;
name|bestmatch
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|tail
operator|=
name|alist
expr_stmt|;
else|else
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|obsize
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|size
expr_stmt|;
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get the next element of the alist or obarray. */
comment|/* Exit the loop if the elements are all used up. */
comment|/* elt gets the alist element or symbol. 	 eltstring gets the name to check as a completion. */
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
break|break;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|eltstring
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
condition|)
block|{
name|elt
operator|=
name|bucket
expr_stmt|;
name|eltstring
operator|=
name|Fsymbol_name
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|XSETSYMBOL
argument_list|(
name|bucket
argument_list|,
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|index
operator|>=
name|obsize
condition|)
break|break;
else|else
block|{
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Is this element a possible completion? */
if|if
condition|(
name|XTYPE
argument_list|(
name|eltstring
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|<=
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
operator|&&
operator|-
literal|1
operator|==
name|scmp
argument_list|(
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
condition|)
block|{
comment|/* Yes. */
comment|/* Ignore this element if there is a predicate and the predicate doesn't like it. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|pred
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|pred
argument_list|,
name|Qcommandp
argument_list|)
condition|)
name|tem
operator|=
name|Fcommandp
argument_list|(
name|elt
argument_list|)
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|call1
argument_list|(
name|pred
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Update computation of how much all possible completions match */
name|matchcount
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
name|bestmatch
operator|=
name|eltstring
operator|,
name|bestmatchsize
operator|=
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
expr_stmt|;
else|else
block|{
name|compare
operator|=
name|min
argument_list|(
name|bestmatchsize
argument_list|,
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|matchsize
operator|=
name|scmp
argument_list|(
name|XSTRING
argument_list|(
name|bestmatch
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
argument_list|,
name|compare
argument_list|)
expr_stmt|;
name|bestmatchsize
operator|=
operator|(
name|matchsize
operator|>=
literal|0
operator|)
condition|?
name|matchsize
else|:
name|compare
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
return|return
name|Qnil
return|;
comment|/* No completions found */
if|if
condition|(
name|matchcount
operator|==
literal|1
operator|&&
name|bestmatchsize
operator|==
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
condition|)
return|return
name|Qt
return|;
name|XFASTINT
argument_list|(
name|zero
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Else extract the part in which */
name|XFASTINT
argument_list|(
name|end
argument_list|)
operator|=
name|bestmatchsize
expr_stmt|;
comment|/* all completions agree */
return|return
name|Fsubstring
argument_list|(
name|bestmatch
argument_list|,
name|zero
argument_list|,
name|end
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Like strncmp but ignores case differences if appropriate.    Also return value is different:    -1 if strings match,    else number of chars that match at the beginning.  */
end_comment

begin_define
define|#
directive|define
name|cvt
parameter_list|(
name|c
parameter_list|)
value|(islower (c) ? c + 'A' - 'a' : c)
end_define

begin_expr_stmt
name|scmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
init|=
name|len
decl_stmt|;
if|if
condition|(
name|completion_ignore_case
condition|)
block|{
while|while
condition|(
name|l
operator|&&
operator|*
name|s1
operator|&&
name|cvt
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|cvt
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|s1
operator|++
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|l
operator|&&
operator|*
name|s1
operator|&&
operator|*
name|s1
operator|==
operator|*
name|s2
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|s1
operator|++
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l
operator|==
literal|0
operator|||
operator|(
operator|*
name|s1
operator|==
literal|0
operator|&&
operator|*
name|s2
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|len
operator|-
name|l
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"all-completions"
argument_list|,
argument|Fall_completions
argument_list|,
argument|Sall_completions
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Search for partial matches to STRING in ALIST.\n\ Each car of each element of ALIST is tested to see if it begins with STRING.\n\ The value is a list of all the strings from ALIST that match.\n\ ALIST can be an obarray instead of an alist.\n\ Then the print names of all symbols in the obarray are the possible matches.\n\ \n\ If optional third argument PREDICATE is non-nil,\n\ it is used to test each possible match.\n\ The match is a candidate only if PREDICATE returns non-nil.\n\ The argument given to PREDICATE is the alist element or the symbol from the obarray."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|alist
operator|,
name|pred
operator|)
name|Lisp_Object
name|string
operator|,
name|alist
operator|,
name|pred
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tail
decl_stmt|,
name|elt
decl_stmt|,
name|eltstring
decl_stmt|;
name|Lisp_Object
name|allmatches
decl_stmt|;
name|int
name|list
init|=
name|LISTP
argument_list|(
name|alist
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|,
name|obsize
decl_stmt|;
name|Lisp_Object
name|bucket
decl_stmt|,
name|tem
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
operator|&&
name|XTYPE
argument_list|(
name|alist
argument_list|)
operator|!=
name|Lisp_Vector
condition|)
block|{
return|return
name|call3
argument_list|(
name|alist
argument_list|,
name|string
argument_list|,
name|pred
argument_list|,
name|Qt
argument_list|)
return|;
block|}
name|allmatches
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|tail
operator|=
name|alist
expr_stmt|;
else|else
block|{
name|index
operator|=
literal|0
expr_stmt|;
name|obsize
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|size
expr_stmt|;
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get the next element of the alist or obarray. */
comment|/* Exit the loop if the elements are all used up. */
comment|/* elt gets the alist element or symbol. 	 eltstring gets the name to check as a completion. */
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
break|break;
name|elt
operator|=
name|Fcar
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|eltstring
operator|=
name|Fcar
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
condition|)
block|{
name|elt
operator|=
name|bucket
expr_stmt|;
name|eltstring
operator|=
name|Fsymbol_name
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|XSETSYMBOL
argument_list|(
name|bucket
argument_list|,
name|XSYMBOL
argument_list|(
name|bucket
argument_list|)
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|index
operator|>=
name|obsize
condition|)
break|break;
else|else
block|{
name|bucket
operator|=
name|XVECTOR
argument_list|(
name|alist
argument_list|)
operator|->
name|contents
index|[
name|index
index|]
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Is this element a possible completion? */
if|if
condition|(
name|XTYPE
argument_list|(
name|eltstring
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|<=
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|size
operator|&&
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
index|[
literal|0
index|]
operator|!=
literal|' '
operator|&&
operator|-
literal|1
operator|==
name|scmp
argument_list|(
name|XSTRING
argument_list|(
name|eltstring
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
condition|)
block|{
comment|/* Yes. */
comment|/* Ignore this element if there is a predicate and the predicate doesn't like it. */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|pred
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|pred
argument_list|,
name|Qcommandp
argument_list|)
condition|)
name|tem
operator|=
name|Fcommandp
argument_list|(
name|elt
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|call1
argument_list|(
name|pred
argument_list|,
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
continue|continue;
block|}
comment|/* Ok => put it on the list. */
name|allmatches
operator|=
name|Fcons
argument_list|(
name|eltstring
argument_list|,
name|allmatches
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Fnreverse
argument_list|(
name|allmatches
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_completion_table
decl_stmt|,
name|Qminibuffer_completion_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_completion_predicate
decl_stmt|,
name|Qminibuffer_completion_predicate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_completion_confirm
decl_stmt|,
name|Qminibuffer_completion_confirm
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"completing-read"
argument_list|,
argument|Fcompleting_read
argument_list|,
argument|Scompleting_read
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Read a string in the minibuffer, with completion.\n\ Args are PROMPT, TABLE, PREDICATE, REQUIRE-MATCH and INITIAL-INPUT.\n\ PROMPT is a string to prompt with; normally it ends in a colon and a space.\n\ TABLE is an alist whose elements' cars are strings, or an obarray (see try-completion).\n\ PREDICATE limits completion to a subset of TABLE; see try-completion for details.\n\ If REQUIRE-MATCH is non-nil, the user is not allowed to exit unless\n\  the input is (or completes to) an element of TABLE.\n\  If it is also not t, Return does not exit if it does non-null completion.\n\ If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.\n\ Case is ignored if ambient value of  completion-ignore-case  is non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|,
name|table
operator|,
name|pred
operator|,
name|require_match
operator|,
name|init
operator|)
name|Lisp_Object
name|prompt
operator|,
name|table
operator|,
name|pred
operator|,
name|require_match
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|specbind
argument_list|(
name|Qminibuffer_completion_table
argument_list|,
name|table
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Qminibuffer_completion_predicate
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Qminibuffer_completion_confirm
argument_list|,
name|EQ
argument_list|(
name|require_match
argument_list|,
name|Qt
argument_list|)
condition|?
name|Qnil
else|:
name|Qt
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_minibuf_string
argument_list|(
name|NULL
argument_list|(
name|require_match
argument_list|)
condition|?
name|Vminibuffer_local_completion_map
else|:
name|Vminibuffer_local_must_match_map
argument_list|,
name|init
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|temp_minibuf_message
argument_list|(
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|osize
init|=
name|NumCharacters
operator|+
literal|1
decl_stmt|;
name|Lisp_Object
name|oinhibit
decl_stmt|;
name|oinhibit
operator|=
name|Vinhibit_quit
expr_stmt|;
name|SetPoint
argument_list|(
name|osize
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|osize
argument_list|)
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qt
expr_stmt|;
name|Fsit_for
argument_list|(
name|make_number
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|del_range
argument_list|(
name|point
argument_list|,
name|NumCharacters
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
block|{
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|unread_command_char
operator|=
name|Ctl
argument_list|(
literal|'g'
argument_list|)
expr_stmt|;
block|}
name|Vinhibit_quit
operator|=
name|oinhibit
expr_stmt|;
block|}
end_block

begin_function_decl
name|Lisp_Object
name|Fminibuffer_completion_help
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* returns:  * 0 no possible completion  * 1 was already an exact and unique completion  * 3 was already an exact completion  * 4 completed to an exact completion  * 5 some completion happened  * 6 no completion happened  */
end_comment

begin_function
name|int
name|do_completion
parameter_list|()
block|{
name|Lisp_Object
name|completion
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|completedp
init|=
literal|0
decl_stmt|;
name|completion
operator|=
name|Ftry_completion
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|completion
argument_list|)
condition|)
block|{
name|Ding
argument_list|()
expr_stmt|;
name|temp_minibuf_message
argument_list|(
literal|" [No match]"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|completion
argument_list|,
name|Qt
argument_list|)
condition|)
comment|/* exact and unique match */
return|return
literal|1
return|;
comment|/* compiler bug */
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|completion
argument_list|,
name|Fbuffer_string
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|completedp
operator|=
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|Ferase_buffer
argument_list|()
expr_stmt|;
comment|/* Some completion happened */
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|completion
argument_list|)
expr_stmt|;
block|}
comment|/* It did find a match.  Do we match some possibility exactly now? */
if|if
condition|(
name|LISTP
argument_list|(
name|Vminibuffer_completion_table
argument_list|)
condition|)
name|tem
operator|=
name|Fassoc
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|Vminibuffer_completion_table
argument_list|)
operator|==
name|Lisp_Vector
condition|)
block|{
comment|/* the primitive used by Fintern_soft */
specifier|extern
name|Lisp_Object
name|oblookup
parameter_list|()
function_decl|;
name|tem
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
comment|/* Bypass intern-soft as that loses for nil */
name|tem
operator|=
name|oblookup
argument_list|(
name|Vminibuffer_completion_table
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
name|tem
operator|=
name|Qnil
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vminibuffer_completion_predicate
argument_list|)
condition|)
name|tem
operator|=
name|call1
argument_list|(
name|Vminibuffer_completion_predicate
argument_list|,
name|tem
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|Qt
expr_stmt|;
block|}
else|else
name|tem
operator|=
name|call3
argument_list|(
name|Vminibuffer_completion_table
argument_list|,
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|,
name|Qlambda
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
comment|/* not an exact match */
if|if
condition|(
name|completedp
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|auto_help
condition|)
name|Fminibuffer_completion_help
argument_list|()
expr_stmt|;
else|else
name|temp_minibuf_message
argument_list|(
literal|" [Next char not unique]"
argument_list|)
expr_stmt|;
return|return
literal|6
return|;
block|}
else|else
return|return
operator|(
name|completedp
condition|?
literal|4
else|:
literal|3
operator|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"minibuffer-complete"
argument_list|,
argument|Fminibuffer_complete
argument_list|,
argument|Sminibuffer_complete
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Complete the minibuffer contents as far as possible."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
specifier|register
name|int
name|i
operator|=
name|do_completion
argument_list|()
block|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
return|return
name|Qnil
return|;
case|case
literal|1
case|:
name|temp_minibuf_message
argument_list|(
literal|" [Sole completion]"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|temp_minibuf_message
argument_list|(
literal|" [Complete, but not unique]"
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_return
return|return
name|Qt
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"minibuffer-complete-and-exit"
operator|,
name|Fminibuffer_complete_and_exit
operator|,
name|Sminibuffer_complete_and_exit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Complete the minibuffer contents, and maybe exit.\n\ Exit if the name is valid with no completion needed.\n\ If name was completed to a valid match,\n\ a repetition of this command will exit."
operator|)
operator|(
operator|)
block|{
specifier|register
name|int
name|i
block|;
comment|/* Allow user to specify null string */
if|if
condition|(
name|NumCharacters
operator|==
literal|0
condition|)
goto|goto
name|exit
goto|;
name|i
operator|=
name|do_completion
argument_list|()
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|3
case|:
goto|goto
name|exit
goto|;
case|case
literal|4
case|:
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vminibuffer_completion_confirm
argument_list|)
condition|)
block|{
name|temp_minibuf_message
argument_list|(
literal|" [Confirm]"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
else|else
goto|goto
name|exit
goto|;
default|default:
return|return
name|Qnil
return|;
block|}
end_switch

begin_label
name|exit
label|:
end_label

begin_expr_stmt
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* NOTREACHED */
end_comment

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"minibuffer-complete-word"
operator|,
name|Fminibuffer_complete_word
operator|,
name|Sminibuffer_complete_word
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Complete the minibuffer contents at most a single word."
operator|)
operator|(
operator|)
block|{
name|Lisp_Object
name|completion
block|,
name|tem
block|;
specifier|register
name|unsigned
name|char
operator|*
name|b
block|;
specifier|register
name|unsigned
name|char
operator|*
name|p
block|;
specifier|register
name|int
name|i
block|;
comment|/* We keep calling Fbuffer_string      rather than arrange for GC to hold onto a pointer to      one of the strings thus made.  */
name|completion
operator|=
name|Ftry_completion
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
block|;
if|if
condition|(
name|NULL
argument_list|(
name|completion
argument_list|)
condition|)
block|{
name|Ding
argument_list|()
expr_stmt|;
name|temp_minibuf_message
argument_list|(
literal|" [No match]"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|EQ
argument_list|(
name|completion
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Qnil
return|;
end_if

begin_expr_stmt
name|tem
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|i
operator|=
name|NumCharacters
operator|-
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|=
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|data
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|>
literal|0
operator|||
literal|0
operator|<=
name|scmp
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|NumCharacters
argument_list|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
comment|/* Set buffer to longest match of buffer tail and completion head. */
while|while
condition|(
literal|0
operator|<=
name|scmp
argument_list|(
name|b
operator|+
name|i
argument_list|,
name|p
argument_list|,
name|NumCharacters
operator|-
name|i
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|del_range
argument_list|(
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|NumCharacters
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|i
operator|=
name|NumCharacters
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If completion finds next char not unique,      consider adding a space or a hyphen */
end_comment

begin_if
if|if
condition|(
name|i
operator|==
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
condition|)
block|{
name|tem
operator|=
name|Ftry_completion
argument_list|(
name|concat2
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|build_string
argument_list|(
literal|" "
argument_list|)
argument_list|)
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|completion
operator|=
name|tem
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|Ftry_completion
argument_list|(
name|concat2
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|build_string
argument_list|(
literal|"-"
argument_list|)
argument_list|)
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|completion
operator|=
name|tem
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* Now find first word-break in the stuff found by completion.      i gets index in string of where to stop completing.  */
end_comment

begin_expr_stmt
name|p
operator|=
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|data
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|i
operator|<
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|!=
name|Sword
condition|)
break|break;
end_for

begin_if
if|if
condition|(
name|i
operator|<
name|XSTRING
argument_list|(
name|completion
argument_list|)
operator|->
name|size
condition|)
name|i
operator|=
name|i
operator|+
literal|1
expr_stmt|;
end_if

begin_comment
comment|/* If got no characters, print help for user.  */
end_comment

begin_if
if|if
condition|(
name|i
operator|==
name|NumCharacters
condition|)
block|{
if|if
condition|(
name|auto_help
condition|)
name|Fminibuffer_completion_help
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_if

begin_comment
comment|/* Otherwise insert in minibuffer the chars we got */
end_comment

begin_expr_stmt
name|Ferase_buffer
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|InsCStr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qt
return|;
end_return

begin_escape
unit|}
end_escape

begin_macro
unit|Lisp_Object
name|minibuffer_completion_help_1
argument_list|(
argument|completions
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|completions
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|completions
argument_list|)
condition|)
name|InsStr
argument_list|(
literal|"There are no possible completions of what you have typed."
argument_list|)
expr_stmt|;
else|else
block|{
name|InsStr
argument_list|(
literal|"Possible completions are:"
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|completions
operator|,
name|i
operator|=
literal|0
init|;
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
comment|/* this needs fixing for the case of long completions 	     and/or narrow windows */
comment|/* Sadly, the window it will appear in is not known 	     until after the text has been made. */
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|Findent_to
argument_list|(
name|make_number
argument_list|(
literal|35
argument_list|)
argument_list|,
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Fterpri
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
block|}
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"minibuffer-completion-help"
argument_list|,
argument|Fminibuffer_completion_help
argument_list|,
argument|Sminibuffer_completion_help
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Display a list of possible completions of the current minibuffer contents."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|completions
block|;
name|message
argument_list|(
literal|"Making completion list..."
argument_list|)
block|;
name|completions
operator|=
name|Fall_completions
argument_list|(
name|Fbuffer_string
argument_list|()
argument_list|,
name|Vminibuffer_completion_table
argument_list|,
name|Vminibuffer_completion_predicate
argument_list|)
block|;
name|minibuf_message
operator|=
literal|0
block|;
if|if
condition|(
name|NULL
argument_list|(
name|completions
argument_list|)
condition|)
block|{
name|Ding
argument_list|()
expr_stmt|;
name|temp_minibuf_message
argument_list|(
literal|" [No completions]"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|internal_with_output_to_temp_buffer
argument_list|(
literal|" *Completions*"
argument_list|,
name|minibuffer_completion_help_1
argument_list|,
name|Fsort
argument_list|(
name|completions
argument_list|,
name|Qstring_lessp
argument_list|)
argument_list|)
expr_stmt|;
end_else

begin_return
return|return
name|Qnil
return|;
end_return

begin_escape
unit|}
end_escape

begin_expr_stmt
unit|DEFUN
operator|(
literal|"self-insert-and-exit"
operator|,
name|Fself_insert_and_exit
operator|,
name|Sself_insert_and_exit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Terminate minibuffer input."
operator|)
operator|(
operator|)
block|{
name|SelfInsert
argument_list|(
name|last_command_char
argument_list|)
block|;
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
block|; }
name|DEFUN
argument_list|(
literal|"exit-minibuffer"
argument_list|,
argument|Fexit_minibuffer
argument_list|,
argument|Sexit_minibuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Terminate this minibuffer argument."
argument_list|)
operator|(
operator|)
block|{
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
block|; }
name|init_minibuf_once
argument_list|()
block|{
name|Vminibuffer_list
operator|=
name|Qnil
block|;
name|staticpro
argument_list|(
operator|&
name|Vminibuffer_list
argument_list|)
block|; }
name|syms_of_minibuf
argument_list|()
block|{
name|MinibufDepth
operator|=
literal|0
block|;
name|minibuf_prompt
operator|=
literal|0
block|;
name|minibuf_save_vector_size
operator|=
literal|5
block|;
name|minibuf_save_vector
operator|=
operator|(
expr|struct
name|minibuf_save_data
operator|*
operator|)
name|malloc
argument_list|(
literal|5
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minibuf_save_data
argument_list|)
argument_list|)
block|;
name|Qminibuffer_completion_table
operator|=
name|intern
argument_list|(
literal|"minibuffer-completion-table"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qminibuffer_completion_table
argument_list|)
block|;
name|Qminibuffer_completion_confirm
operator|=
name|intern
argument_list|(
literal|"minibuffer-completion-confirm"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qminibuffer_completion_confirm
argument_list|)
block|;
name|Qminibuffer_completion_predicate
operator|=
name|intern
argument_list|(
literal|"minibuffer-completion-predicate"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Qminibuffer_completion_predicate
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|last_minibuf_string
argument_list|)
block|;
name|last_minibuf_string
operator|=
name|Qnil
block|;
name|Quser_variable_p
operator|=
name|intern
argument_list|(
literal|"user-variable-p"
argument_list|)
block|;
name|staticpro
argument_list|(
operator|&
name|Quser_variable_p
argument_list|)
block|;
name|DefBoolVar
argument_list|(
literal|"completion-auto-help"
argument_list|,
operator|&
name|auto_help
argument_list|,
literal|"*Non-nil means automatically provide help for invalid completion input."
argument_list|)
block|;
name|auto_help
operator|=
literal|1
block|;
name|DefBoolVar
argument_list|(
literal|"completion-ignore-case"
argument_list|,
operator|&
name|completion_ignore_case
argument_list|,
literal|"Non-nil means don't consider case significant in completion."
argument_list|)
block|;
name|completion_ignore_case
operator|=
literal|0
block|;
name|DefBoolVar
argument_list|(
literal|"enable-recursive-minibuffers"
argument_list|,
operator|&
name|enable_recursive_minibuffers
argument_list|,
literal|"*Non-nil means to allow minibuffers to invoke commands which use\n\ recursive minibuffers."
argument_list|)
block|;
name|enable_recursive_minibuffers
operator|=
literal|0
block|;
name|DefLispVar
argument_list|(
literal|"minibuffer-completion-table"
argument_list|,
operator|&
name|Vminibuffer_completion_table
argument_list|,
literal|"Alist or obarray used for completion in the minibuffer."
argument_list|)
block|;
name|Vminibuffer_completion_table
operator|=
name|Qnil
block|;
name|DefLispVar
argument_list|(
literal|"minibuffer-completion-predicate"
argument_list|,
operator|&
name|Vminibuffer_completion_predicate
argument_list|,
literal|"Holds PREDICATE argument to completing-read."
argument_list|)
block|;
name|Vminibuffer_completion_predicate
operator|=
name|Qnil
block|;
name|DefLispVar
argument_list|(
literal|"minibuffer-completion-confirm"
argument_list|,
operator|&
name|Vminibuffer_completion_confirm
argument_list|,
literal|"Non-nil => demand confirmation of completion before exiting minibuffer."
argument_list|)
block|;
name|Vminibuffer_completion_confirm
operator|=
name|Qnil
block|;
name|DefLispVar
argument_list|(
literal|"minibuffer-help-form"
argument_list|,
operator|&
name|Vminibuffer_help_form
argument_list|,
literal|"Value that help-form takes on inside the minibuffer."
argument_list|)
block|;
name|Vminibuffer_help_form
operator|=
name|Qnil
block|;
name|defsubr
argument_list|(
operator|&
name|Sread_from_minibuffer
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Seval_minibuffer
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sread_minibuffer
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sread_string
argument_list|)
block|;
name|defalias
argument_list|(
operator|&
name|Sread_string
argument_list|,
literal|"read-input"
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sread_command
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sread_variable
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sread_buffer
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sread_no_blanks_input
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Stry_completion
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sall_completions
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Scompleting_read
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_complete
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_complete_word
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_complete_and_exit
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sminibuffer_completion_help
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sself_insert_and_exit
argument_list|)
block|;
name|defsubr
argument_list|(
operator|&
name|Sexit_minibuffer
argument_list|)
block|;  }
name|keys_of_minibuf
argument_list|()
block|{
name|ndefkey
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
literal|' '
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
literal|'\t'
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_ns_map
argument_list|,
literal|'?'
argument_list|,
literal|"self-insert-and-exit"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"exit-minibuffer"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
literal|'\t'
argument_list|,
literal|"minibuffer-complete"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
literal|' '
argument_list|,
literal|"minibuffer-complete-word"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_completion_map
argument_list|,
literal|'?'
argument_list|,
literal|"minibuffer-completion-help"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
name|Ctl
argument_list|(
literal|'g'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
name|Ctl
argument_list|(
literal|'m'
argument_list|)
argument_list|,
literal|"minibuffer-complete-and-exit"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
name|Ctl
argument_list|(
literal|'j'
argument_list|)
argument_list|,
literal|"minibuffer-complete-and-exit"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
literal|'\t'
argument_list|,
literal|"minibuffer-complete"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
literal|' '
argument_list|,
literal|"minibuffer-complete-word"
argument_list|)
block|;
name|ndefkey
argument_list|(
name|Vminibuffer_local_must_match_map
argument_list|,
literal|'?'
argument_list|,
literal|"minibuffer-completion-help"
argument_list|)
block|; }
end_expr_stmt

end_unit

