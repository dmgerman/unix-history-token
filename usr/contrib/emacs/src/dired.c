begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lisp functions for making directory listings.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NONSYSTEM_DIR_LIBRARY
end_ifdef

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not NONSYSTEM_DIR_LIBRARY */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NONSYSTEM_DIR_LIBRARY */
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* if system does not have symbolic links, it does not have lstat.    In that case, use ordinary stat instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|S_IFLNK
end_ifndef

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|DIR
modifier|*
name|opendir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|direct
modifier|*
name|readdir
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Lisp_Object
name|Vcompletion_ignored_extensions
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"directory-files"
argument_list|,
argument|Fdirectory_files
argument_list|,
argument|Sdirectory_files
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a list of names of files in DIRECTORY.\n\ If FULL is non-NIL, absolute pathnames of the files are returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|dirname
operator|,
name|full
operator|)
name|Lisp_Object
name|dirname
operator|,
name|full
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|char
name|slashfilename
index|[
name|MAXNAMLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|slashfilename
decl_stmt|;
name|int
name|length
decl_stmt|;
name|Lisp_Object
name|list
decl_stmt|,
name|name
decl_stmt|;
name|dirname
operator|=
name|Fexpand_file_name
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|data
argument_list|)
operator|)
condition|)
name|report_file_error
argument_list|(
literal|"Opening directory"
argument_list|,
name|Fcons
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|Qnil
expr_stmt|;
name|length
operator|=
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|data
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|filename
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Loop reading blocks */
while|while
condition|(
literal|1
condition|)
block|{
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
break|break;
if|if
condition|(
name|dp
operator|->
name|d_ino
condition|)
block|{
name|strncpy
argument_list|(
name|filename
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
name|filename
index|[
name|dp
operator|->
name|d_namlen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|full
argument_list|)
condition|)
name|name
operator|=
name|concat2
argument_list|(
name|dirname
argument_list|,
name|build_string
argument_list|(
name|slashfilename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|build_string
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|list
operator|=
name|Fcons
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|Fsort
argument_list|(
name|Fnreverse
argument_list|(
name|list
argument_list|)
argument_list|,
name|Qstring_lessp
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
name|Lisp_Object
name|file_name_completion
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-completion"
argument_list|,
argument|Ffile_name_completion
argument_list|,
argument|Sfile_name_completion
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Complete file name FILE in directory DIR.\n\ Returns the longest string common to all filenames in DIR\n\ that start with FILE.\n\ If there is only one and FILE matches it exactly, returns t.\n\ Returns nil if DIR contains no name starting with FILE."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|,
name|dirname
operator|)
name|Lisp_Object
name|file
operator|,
name|dirname
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* Don't waste time trying to complete a null string.      Besides, this case happens when user is being asked for      a directory name and has supplied one ending in a /.      We would not want to add anything in that case      even if there are some unique characters in that directory.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|file
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|file
return|;
return|return
name|file_name_completion
argument_list|(
name|file
argument_list|,
name|dirname
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-all-completions"
argument_list|,
argument|Ffile_name_all_completions
argument_list|,
argument|Sfile_name_all_completions
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a list of all completions of file name FILE in directory DIR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|,
name|dirname
operator|)
name|Lisp_Object
name|file
operator|,
name|dirname
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|file_name_completion
argument_list|(
name|file
argument_list|,
name|dirname
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|file_name_completion
parameter_list|(
name|file
parameter_list|,
name|dirname
parameter_list|,
name|all_flag
parameter_list|)
name|Lisp_Object
name|file
decl_stmt|,
name|dirname
decl_stmt|;
name|int
name|all_flag
decl_stmt|;
block|{
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|int
name|bestmatchsize
decl_stmt|,
name|skip
decl_stmt|;
specifier|register
name|int
name|compare
decl_stmt|,
name|matchsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|matchcount
init|=
literal|0
decl_stmt|;
name|Lisp_Object
name|bestmatch
decl_stmt|,
name|tem
decl_stmt|,
name|elt
decl_stmt|,
name|name
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|directoryp
decl_stmt|;
name|int
name|passcount
decl_stmt|;
name|dirname
operator|=
name|Fexpand_file_name
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|bestmatch
operator|=
name|Qnil
expr_stmt|;
comment|/* passcount = 0, ignore files that end in an ignored extension.      If nothing found then try again with passcount = 1, don't ignore them.      If looking for all completions, start with passcount = 1,      so always take even the ignored ones.  */
for|for
control|(
name|passcount
operator|=
operator|!
operator|!
name|all_flag
init|;
name|NULL
argument_list|(
name|bestmatch
argument_list|)
operator|&&
name|passcount
operator|<
literal|2
condition|;
name|passcount
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|data
argument_list|)
operator|)
condition|)
name|report_file_error
argument_list|(
literal|"Opening directory"
argument_list|,
name|Fcons
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop reading blocks */
while|while
condition|(
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
operator|&&
name|NULL
argument_list|(
name|Vinhibit_quit
argument_list|)
condition|)
goto|goto
name|quit
goto|;
if|if
condition|(
operator|!
name|dp
operator|->
name|d_ino
operator|||
name|dp
operator|->
name|d_namlen
operator|<
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
operator|||
name|bcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
argument_list|)
condition|)
continue|continue;
name|tem
operator|=
name|Qnil
expr_stmt|;
comment|/* Compare extensions-to-be-ignored against end of this file name */
comment|/* if name is not an exact match against specified string */
if|if
condition|(
operator|!
name|passcount
operator|&&
name|dp
operator|->
name|d_namlen
operator|>
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
condition|)
comment|/* and exit this for loop if a match is found */
for|for
control|(
name|tem
operator|=
name|Vcompletion_ignored_extensions
init|;
name|LISTP
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
block|{
name|elt
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|!=
name|Lisp_String
condition|)
continue|continue;
name|skip
operator|=
name|dp
operator|->
name|d_namlen
operator|-
name|XSTRING
argument_list|(
name|elt
argument_list|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|dp
operator|->
name|d_name
operator|+
name|skip
argument_list|,
name|XSTRING
argument_list|(
name|elt
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|elt
argument_list|)
operator|->
name|size
argument_list|)
condition|)
continue|continue;
break|break;
block|}
comment|/* Unless a match was found, process this name as a completion */
if|if
condition|(
operator|(
name|passcount
operator|||
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|&&
name|file_name_completion_stat
argument_list|(
name|dirname
argument_list|,
name|dp
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Update computation of how much all possible completions match */
name|matchcount
operator|++
expr_stmt|;
name|directoryp
operator|=
operator|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
expr_stmt|;
if|if
condition|(
name|all_flag
operator|||
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
block|{
comment|/* This is a possible completion */
if|if
condition|(
name|directoryp
condition|)
block|{
comment|/* This completion is a directory; make it end with '/' */
name|name
operator|=
name|make_string
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|data
index|[
name|dp
operator|->
name|d_namlen
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
name|name
operator|=
name|make_string
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_flag
condition|)
block|{
name|bestmatch
operator|=
name|Fcons
argument_list|(
name|name
argument_list|,
name|bestmatch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bestmatch
operator|=
name|name
expr_stmt|;
name|bestmatchsize
operator|=
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
block|}
else|else
block|{
name|compare
operator|=
name|min
argument_list|(
name|bestmatchsize
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
name|p1
operator|=
name|XSTRING
argument_list|(
name|bestmatch
argument_list|)
operator|->
name|data
expr_stmt|;
name|p2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dp
operator|->
name|d_name
expr_stmt|;
for|for
control|(
name|matchsize
operator|=
literal|0
init|;
name|matchsize
operator|<
name|compare
condition|;
name|matchsize
operator|++
control|)
if|if
condition|(
name|p1
index|[
name|matchsize
index|]
operator|!=
name|p2
index|[
name|matchsize
index|]
condition|)
break|break;
comment|/* If this dirname all matches, 		     see if implicit following slash does too.  */
if|if
condition|(
name|directoryp
operator|&&
name|compare
operator|==
name|matchsize
operator|&&
name|bestmatchsize
operator|>
name|matchsize
operator|&&
name|p1
index|[
name|matchsize
index|]
operator|==
literal|'/'
condition|)
name|matchsize
operator|++
expr_stmt|;
name|bestmatchsize
operator|=
name|min
argument_list|(
name|matchsize
argument_list|,
name|bestmatchsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|all_flag
operator|||
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
return|return
name|bestmatch
return|;
if|if
condition|(
name|matchcount
operator|==
literal|1
operator|&&
name|bestmatchsize
operator|==
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
condition|)
return|return
name|Qt
return|;
return|return
name|Fsubstring
argument_list|(
name|bestmatch
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|bestmatchsize
argument_list|)
argument_list|)
return|;
name|quit
label|:
if|if
condition|(
name|d
condition|)
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
return|return
name|Fsignal
argument_list|(
name|Qquit
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_function

begin_macro
name|file_name_completion_stat
argument_list|(
argument|dirname
argument_list|,
argument|dp
argument_list|,
argument|st_addr
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|dirname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
modifier|*
name|st_addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fullname
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|dp
operator|->
name|d_namlen
operator|+
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|size
operator|+
literal|2
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|size
decl_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|data
argument_list|,
name|fullname
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
index|[
name|pos
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|fullname
index|[
name|pos
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|bcopy
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|fullname
operator|+
name|pos
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
name|fullname
index|[
name|pos
operator|+
name|dp
operator|->
name|d_namlen
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|stat
argument_list|(
name|fullname
argument_list|,
name|st_addr
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|make_time
parameter_list|(
name|time
parameter_list|)
name|int
name|time
decl_stmt|;
block|{
return|return
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|time
operator|>>
literal|16
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|time
operator|&
literal|0177777
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"file-attributes"
argument_list|,
argument|Ffile_attributes
argument_list|,
argument|Sfile_attributes
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a list of attributes of file FILENAME.\n\ Elements are:\n\  0. t for directory, string (name linked to) for symbolic link, or nil.\n\  1. Number of links to file.\n\  2. File uid.\n\  3. File gid.\n\  4. Last access time, as a list of two integers.\n\   First integer has high-order 16 bits of time, second has low 16 bits.\n\  5. Last modification time, likewise.\n\  6. Last status change time, likewise.\n\  7. Size in bytes.\n\  8. File modes, as a string of nine letters or dashes as in ls -l."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|values
index|[
literal|9
index|]
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|char
name|modes
index|[
literal|10
index|]
decl_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
name|values
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
name|values
index|[
literal|0
index|]
operator|=
name|Ffile_symlink_p
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|XFASTINT
argument_list|(
name|values
index|[
literal|1
index|]
argument_list|)
operator|=
name|s
operator|.
name|st_nlink
expr_stmt|;
name|XFASTINT
argument_list|(
name|values
index|[
literal|2
index|]
argument_list|)
operator|=
name|s
operator|.
name|st_uid
expr_stmt|;
name|XFASTINT
argument_list|(
name|values
index|[
literal|3
index|]
argument_list|)
operator|=
name|s
operator|.
name|st_gid
expr_stmt|;
name|values
index|[
literal|4
index|]
operator|=
name|make_time
argument_list|(
name|s
operator|.
name|st_atime
argument_list|)
expr_stmt|;
name|values
index|[
literal|5
index|]
operator|=
name|make_time
argument_list|(
name|s
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|values
index|[
literal|6
index|]
operator|=
name|make_time
argument_list|(
name|s
operator|.
name|st_ctime
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|values
index|[
literal|7
index|]
argument_list|)
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
name|filemodestring
argument_list|(
operator|&
name|s
argument_list|,
name|modes
argument_list|)
expr_stmt|;
name|values
index|[
literal|8
index|]
operator|=
name|make_string
argument_list|(
name|modes
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
name|Flist
argument_list|(
literal|9
argument_list|,
name|values
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_dired
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Sdirectory_files
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_completion
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_all_completions
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_attributes
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"completion-ignored-extensions"
argument_list|,
operator|&
name|Vcompletion_ignored_extensions
argument_list|,
literal|"*Completion ignores filenames ending in any string in this list."
argument_list|)
expr_stmt|;
name|Vcompletion_ignored_extensions
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

end_unit

