begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Window creation, deletion and examination for GNU Emacs.    Does not include redisplay.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_decl_stmt
name|Lisp_Object
name|Qwindowp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Fnext_window
argument_list|()
decl_stmt|,
name|Fdelete_window
argument_list|()
decl_stmt|,
name|Fselect_window
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Fshow_buffer
argument_list|()
decl_stmt|,
name|Fsplit_window
argument_list|()
decl_stmt|,
name|Frecenter
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the window which displays the minibuffer. It is always the same window.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|minibuf_window
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the window in which the terminal's cursor should  be left when nothing is being done with it.  This must  always be a leaf window, and its buffer is selected by  the top level editing loop at the end of each command.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|selected_window
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If a window gets smaller than either of these, it is removed. */
end_comment

begin_decl_stmt
name|int
name|window_min_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|window_min_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero implies pop_to_buffer should create windows. */
end_comment

begin_decl_stmt
name|int
name|pop_up_windows
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display-buffer always splits the largest window   if that window is more than this high */
end_comment

begin_decl_stmt
name|int
name|split_height_threshold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines of continuity in scrolling by screenfuls.  */
end_comment

begin_decl_stmt
name|int
name|next_screen_context_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented for each window created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sequence_number
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"windowp"
argument_list|,
argument|Fwindowp
argument_list|,
argument|Swindowp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Returns t if OBJ is a window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Window
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|make_window
parameter_list|()
block|{
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|p
decl_stmt|;
name|val
operator|=
name|Fmake_vector
argument_list|(
name|make_number
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|window
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
name|val
argument_list|,
name|Lisp_Window
argument_list|)
expr_stmt|;
name|p
operator|=
name|XWINDOW
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|top
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|height
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|width
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|hscroll
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|last_point_x
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|p
operator|->
name|last_point_y
argument_list|)
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|p
operator|->
name|pointm
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|sequence_number
argument_list|)
operator|=
operator|++
name|sequence_number
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|use_time
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"selected-window"
argument_list|,
argument|Fselected_window
argument_list|,
argument|Sselected_window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the window that the cursor appears in and commands apply to."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|selected_window
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"pos-visible-in-window-p"
argument_list|,
argument|Fpos_visible_in_window_p
argument_list|,
argument|Spos_visible_in_window_p
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return t if position POS is currently on the screen in WINDOW.\n\ Returns nil if that position is scrolled vertically out of view.\n\ POS defaults to point; WINDOW, to the selected window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|pos
operator|,
name|window
operator|)
name|Lisp_Object
name|pos
operator|,
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
decl_stmt|;
specifier|register
name|int
name|top
decl_stmt|;
specifier|register
name|int
name|height
decl_stmt|;
specifier|register
name|int
name|posint
decl_stmt|;
specifier|register
name|struct
name|buffer_text
modifier|*
name|text
decl_stmt|;
name|struct
name|position
name|posval
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|pos
argument_list|)
condition|)
name|posint
operator|=
name|point
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|posint
operator|=
name|XINT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|window
argument_list|)
condition|)
name|window
operator|=
name|selected_window
expr_stmt|;
else|else
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|w
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|top
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|posint
operator|<
name|top
condition|)
return|return
name|Qnil
return|;
name|height
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|-
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|text
operator|=
name|bf_text
expr_stmt|;
name|text
operator|=
operator|&
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|>=
name|text
operator|->
name|modified
condition|)
block|{
comment|/* If screen is up to date, 	 use the info recorded about how much text fit on it. */
if|if
condition|(
name|posint
operator|<
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|size2
operator|+
literal|1
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_pos
argument_list|)
operator|||
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|window_end_vpos
argument_list|)
operator|<
name|height
operator|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
else|else
block|{
if|if
condition|(
name|posint
operator|>
name|text
operator|->
name|size1
operator|+
name|text
operator|->
name|size2
operator|+
literal|1
condition|)
return|return
name|Qnil
return|;
comment|/* If that info is not correct, calculate afresh */
name|posval
operator|=
operator|*
name|compute_motion
argument_list|(
name|top
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|posint
argument_list|,
name|height
argument_list|,
literal|0
argument_list|,
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|!=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|width
argument_list|)
operator|)
argument_list|,
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|posval
operator|.
name|vpos
operator|<
name|height
condition|?
name|Qt
else|:
name|Qnil
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|struct
name|window
modifier|*
name|decode_window
parameter_list|(
name|window
parameter_list|)
name|Lisp_Object
name|window
decl_stmt|;
block|{
if|if
condition|(
name|NULL
argument_list|(
name|window
argument_list|)
condition|)
return|return
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
return|;
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XWINDOW
argument_list|(
name|window
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"window-buffer"
argument_list|,
argument|Fwindow_buffer
argument_list|,
argument|Swindow_buffer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer that WINDOW is displaying."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|decode_window
argument_list|(
name|window
argument_list|)
operator|->
name|buffer
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"window-height"
argument_list|,
argument|Fwindow_height
argument_list|,
argument|Swindow_height
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the number of lines in WINDOW (including its mode line)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|decode_window
argument_list|(
name|window
argument_list|)
operator|->
name|height
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"window-width"
argument_list|,
argument|Fwindow_width
argument_list|,
argument|Swindow_width
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the number of columns in WINDOW."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|decode_window
argument_list|(
name|window
argument_list|)
operator|->
name|width
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"window-hscroll"
argument_list|,
argument|Fwindow_hscroll
argument_list|,
argument|Swindow_hscroll
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the number of columns by which WINDOW is scrolled from left margin."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|decode_window
argument_list|(
name|window
argument_list|)
operator|->
name|hscroll
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-window-hscroll"
argument_list|,
argument|Fset_window_hscroll
argument_list|,
argument|Sset_window_hscroll
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set number of columns WINDOW is scrolled from left margin to NCOL.\n\ NCOL should be zero or positive."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|,
name|ncol
operator|)
name|Lisp_Object
name|window
operator|,
name|ncol
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|ncol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|ncol
argument_list|)
operator|<
literal|0
condition|)
name|XFASTINT
argument_list|(
name|ncol
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|ncol
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
operator|(
name|SHORTBITS
operator|-
literal|1
operator|)
operator|)
condition|)
name|args_out_of_range
argument_list|(
name|ncol
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|clip_changed
operator|=
literal|1
expr_stmt|;
comment|/* Prevent redisplay shortcuts */
name|decode_window
argument_list|(
name|window
argument_list|)
operator|->
name|hscroll
operator|=
name|ncol
expr_stmt|;
return|return
name|ncol
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"window-edges"
argument_list|,
argument|Fwindow_edges
argument_list|,
argument|Swindow_edges
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a list of the edge coordinates of WINDOW.\n\ \(LEFT TOP RIGHT BOTTOM), all relative to 0, 0 at top left corner of screen."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|decode_window
argument_list|(
name|window
argument_list|)
decl_stmt|;
return|return
name|Fcons
argument_list|(
name|w
operator|->
name|left
argument_list|,
name|Fcons
argument_list|(
name|w
operator|->
name|top
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"window-point"
argument_list|,
argument|Fwindow_point
argument_list|,
argument|Swindow_point
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return current value of point in WINDOW."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fmarker_position
argument_list|(
name|decode_window
argument_list|(
name|window
argument_list|)
operator|->
name|pointm
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"window-start"
argument_list|,
argument|Fwindow_start
argument_list|,
argument|Swindow_start
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return position at which display currently starts in WINDOW."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fmarker_position
argument_list|(
name|decode_window
argument_list|(
name|window
argument_list|)
operator|->
name|start
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-window-point"
argument_list|,
argument|Fset_window_point
argument_list|,
argument|Sset_window_point
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Make point value in WINDOW be at position POS in WINDOW's buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|,
name|pos
operator|)
name|Lisp_Object
name|window
operator|,
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|window
modifier|*
name|w
init|=
name|decode_window
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|,
name|pos
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-window-start"
argument_list|,
argument|Fset_window_start
argument_list|,
argument|Sset_window_start
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Make display in WINDOW start at position POS in WINDOW's buffer.\n\ Optional third arg NOFORCE non-nil inhibits next redisplay\n\ from overriding motion of point in order to display at this exact start."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|,
name|pos
operator|,
name|noforce
operator|)
name|Lisp_Object
name|window
operator|,
name|pos
operator|,
name|noforce
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|window
modifier|*
name|w
init|=
name|decode_window
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|pos
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|noforce
argument_list|)
condition|)
name|w
operator|->
name|force_start
operator|=
name|Qt
expr_stmt|;
name|w
operator|->
name|redo_mode_line
operator|=
name|Qt
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|pos
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"delete-window"
argument_list|,
argument|Fdelete_window
argument_list|,
argument|Sdelete_window
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Remove WINDOW from the display.  Default is selected window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|osize
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|,
name|parent
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|window
argument_list|)
condition|)
name|window
operator|=
name|selected_window
expr_stmt|;
else|else
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|parent
operator|=
name|p
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|parent
argument_list|)
condition|)
name|error
argument_list|(
literal|"Attempt to delete minibuffer or sole ordinary window"
argument_list|)
expr_stmt|;
name|windows_or_buffers_changed
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|Fselect_window
argument_list|(
name|Fnext_window
argument_list|(
name|window
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
comment|/* tem is null for dummy parent windows      (which have inferiors but not any contents themselves) */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|unshow_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|unchain_marker
argument_list|(
name|p
operator|->
name|pointm
argument_list|)
expr_stmt|;
name|unchain_marker
argument_list|(
name|p
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|tem
operator|=
name|p
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|hchild
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|hchild
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|vchild
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|vchild
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* Stretch the siblings to use all the available space */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|vchild
argument_list|)
condition|)
block|{
comment|/* It's a vertical combination */
name|osize
operator|=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|height
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|height
argument_list|)
operator|-=
name|XFASTINT
argument_list|(
name|p
operator|->
name|height
argument_list|)
expr_stmt|;
name|set_window_height
argument_list|(
name|parent
argument_list|,
name|osize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|hchild
argument_list|)
condition|)
block|{
comment|/* It's a horizontal combination */
name|osize
operator|=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|width
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|width
argument_list|)
operator|-=
name|XFASTINT
argument_list|(
name|p
operator|->
name|width
argument_list|)
expr_stmt|;
name|set_window_width
argument_list|(
name|parent
argument_list|,
name|osize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If parent now has only one child,      put the child into the parent's place.  */
name|tem
operator|=
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|hchild
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|vchild
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|next
argument_list|)
condition|)
name|replace_window
argument_list|(
name|parent
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Put replacement into the window structure in place of old. */
end_comment

begin_macro
name|replace_window
argument_list|(
argument|old
argument_list|,
argument|replacement
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|old
decl_stmt|,
name|replacement
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|o
init|=
name|XWINDOW
argument_list|(
name|old
argument_list|)
decl_stmt|,
modifier|*
name|p
init|=
name|XWINDOW
argument_list|(
name|replacement
argument_list|)
decl_stmt|;
name|p
operator|->
name|left
operator|=
name|o
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|top
operator|=
name|o
operator|->
name|top
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|o
operator|->
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|o
operator|->
name|height
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|tem
operator|=
name|o
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|prev
operator|=
name|replacement
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|tem
operator|=
name|o
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|next
operator|=
name|replacement
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|tem
operator|=
name|o
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|vchild
argument_list|,
name|old
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|vchild
operator|=
name|replacement
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|hchild
argument_list|,
name|old
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|tem
argument_list|)
operator|->
name|hchild
operator|=
name|replacement
expr_stmt|;
block|}
comment|/*** Here, if replacement is a vertical combination and so is its new parent, we should make replacement's children be children of that parent instead.  ***/
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"next-window"
argument_list|,
argument|Fnext_window
argument_list|,
argument|Snext_window
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return next window after WINDOW in canonical ordering of windows."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|,
name|yesmini
operator|)
name|Lisp_Object
name|window
operator|,
name|yesmini
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|window
argument_list|)
condition|)
name|window
operator|=
name|selected_window
expr_stmt|;
else|else
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
while|while
condition|(
name|tem
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|next
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
if|if
condition|(
name|tem
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|parent
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|window
operator|=
name|tem
expr_stmt|;
else|else
comment|/* window must be minibuf_window now */
block|{
name|tem
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|prev
expr_stmt|;
break|break;
block|}
name|window
operator|=
name|tem
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|hchild
argument_list|)
condition|)
name|window
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|hchild
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|vchild
argument_list|)
condition|)
name|window
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|vchild
expr_stmt|;
else|else
break|break;
block|}
block|}
do|while
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|NULL
argument_list|(
name|yesmini
argument_list|)
operator|&&
operator|!
name|MinibufDepth
condition|)
do|;
return|return
name|window
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"previous-window"
argument_list|,
argument|Fprevious_window
argument_list|,
argument|Sprevious_window
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return previous window before WINDOW in canonical ordering of windows."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|window
argument_list|)
condition|)
name|window
operator|=
name|selected_window
expr_stmt|;
else|else
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
comment|/* at least once, and until not the minibuffer */
block|{
while|while
condition|(
name|tem
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|prev
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
if|if
condition|(
name|tem
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|parent
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|window
operator|=
name|tem
expr_stmt|;
else|else
comment|/* window must be the root window now */
block|{
name|tem
operator|=
name|minibuf_window
expr_stmt|;
break|break;
block|}
name|window
operator|=
name|tem
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|hchild
argument_list|)
condition|)
name|window
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|hchild
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|vchild
argument_list|)
condition|)
name|window
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|vchild
expr_stmt|;
else|else
break|break;
while|while
condition|(
name|tem
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|next
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|window
operator|=
name|tem
expr_stmt|;
block|}
block|}
do|while
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
operator|!
name|MinibufDepth
condition|)
do|;
return|return
name|window
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"other-window"
argument_list|,
argument|Fother_window
argument_list|,
argument|Sother_window
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Select the ARG'th different window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|Lisp_Object
name|w
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|w
operator|=
name|selected_window
expr_stmt|;
name|i
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|w
operator|=
name|Fnext_window
argument_list|(
name|w
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|w
operator|=
name|Fprevious_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|Fselect_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|window_loop
parameter_list|(
name|type
parameter_list|,
name|obj
parameter_list|)
name|int
name|type
decl_stmt|;
name|Lisp_Object
name|obj
decl_stmt|;
block|{
name|Lisp_Object
name|w
decl_stmt|,
name|w1
decl_stmt|,
name|ret_w
decl_stmt|,
name|tem
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|w
operator|=
name|minibuf_window
expr_stmt|;
name|ret_w
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|XWINDOW
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w1
operator|=
name|Fnext_window
argument_list|(
name|w
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|w
argument_list|,
name|minibuf_window
argument_list|)
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|==
name|XBUFFER
argument_list|(
name|obj
argument_list|)
condition|)
return|return
name|w
return|;
break|break;
case|case
literal|2
case|:
comment|/* t as arg means consider only full-width windows */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|obj
argument_list|)
operator|&&
name|XFASTINT
argument_list|(
name|p
operator|->
name|width
argument_list|)
operator|!=
name|screen_width
condition|)
break|break;
if|if
condition|(
name|NULL
argument_list|(
name|ret_w
argument_list|)
operator|||
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|ret_w
argument_list|)
operator|->
name|use_time
argument_list|)
operator|>
name|XFASTINT
argument_list|(
name|p
operator|->
name|use_time
argument_list|)
condition|)
name|ret_w
operator|=
name|w
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|p
operator|!=
name|XWINDOW
argument_list|(
name|obj
argument_list|)
condition|)
name|Fdelete_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|EQ
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
name|obj
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|parent
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fother_buffer
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|w
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|Fdelete_window
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
name|q
operator|=
name|XWINDOW
argument_list|(
name|ret_w
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|ret_w
argument_list|)
operator|||
operator|(
name|XFASTINT
argument_list|(
name|p
operator|->
name|height
argument_list|)
operator|*
name|XFASTINT
argument_list|(
name|p
operator|->
name|width
argument_list|)
operator|)
operator|>
operator|(
name|XFASTINT
argument_list|(
name|q
operator|->
name|height
argument_list|)
operator|*
name|XFASTINT
argument_list|(
name|q
operator|->
name|width
argument_list|)
operator|)
condition|)
name|ret_w
operator|=
name|w
expr_stmt|;
break|break;
case|case
literal|6
case|:
if|if
condition|(
name|EQ
argument_list|(
name|p
operator|->
name|buffer
argument_list|,
name|obj
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fother_buffer
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|Fget_buffer_create
argument_list|(
name|build_string
argument_list|(
literal|"*scratch*"
argument_list|)
argument_list|)
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|w
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|w
operator|=
name|w1
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|w
argument_list|,
name|minibuf_window
argument_list|)
condition|)
return|return
name|ret_w
return|;
block|}
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"get-lru-window"
argument_list|,
argument|Fget_lru_window
argument_list|,
argument|Sget_lru_window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the window least recently selected or used for display."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|w
block|;
comment|/* First try for a window that is full-width */
name|w
operator|=
name|window_loop
argument_list|(
literal|2
argument_list|,
name|Qt
argument_list|)
block|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|w
argument_list|,
name|selected_window
argument_list|)
condition|)
return|return
name|w
return|;
end_expr_stmt

begin_comment
comment|/* If none of them, try the rest */
end_comment

begin_return
return|return
name|window_loop
argument_list|(
literal|2
argument_list|,
name|Qnil
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"get-largest-window"
operator|,
name|Fget_largest_window
operator|,
name|Sget_largest_window
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return the largest window in area."
operator|)
operator|(
operator|)
block|{
return|return
name|window_loop
argument_list|(
literal|5
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"get-buffer-window"
argument_list|,
argument|Fget_buffer_window
argument_list|,
argument|Sget_buffer_window
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a window currently displaying BUFFER, or nil if none."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|buffer
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
return|return
name|window_loop
argument_list|(
literal|1
argument_list|,
name|buffer
argument_list|)
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-other-windows"
argument_list|,
argument|Fdelete_other_windows
argument_list|,
argument|Sdelete_other_windows
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Make WINDOW (or the selected window) fill the screen."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|w
operator|)
name|Lisp_Object
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|window_loop
argument_list|(
literal|3
argument_list|,
operator|!
name|NULL
argument_list|(
name|w
argument_list|)
condition|?
name|w
else|:
name|selected_window
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-windows-on"
argument_list|,
argument|Fdelete_windows_on
argument_list|,
argument|Sdelete_windows_on
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"bDelete windows on (buffer): "
argument_list|,
literal|"Delete all windows showing BUFFER."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|window_loop
argument_list|(
literal|4
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"replace-buffer-in-windows"
argument_list|,
argument|Freplace_buffer_in_windows
argument_list|,
argument|Sreplace_buffer_in_windows
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"bReplace buffer in windows: "
argument_list|,
literal|"Replace BUFFER with some other buffer in all windows showing it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|)
name|Lisp_Object
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|window_loop
argument_list|(
literal|6
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Set the height of WINDOW and all its inferiors.  */
end_comment

begin_comment
comment|/* Normally the window is deleted if it gets too small.    nodelete nonzero means do not do this.    (The caller should check later and do so if appropriate)  */
end_comment

begin_macro
name|set_window_height
argument_list|(
argument|window
argument_list|,
argument|height
argument_list|,
argument|nodelete
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nodelete
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|c
decl_stmt|;
name|int
name|oheight
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
decl_stmt|;
name|int
name|top
decl_stmt|,
name|pos
decl_stmt|,
name|lastbot
decl_stmt|,
name|opos
decl_stmt|,
name|lastobot
decl_stmt|;
name|Lisp_Object
name|child
decl_stmt|;
if|if
condition|(
name|window_min_height
operator|<
literal|2
condition|)
name|window_min_height
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|nodelete
operator|&&
name|height
operator|<
operator|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|?
literal|1
else|:
name|window_min_height
operator|)
condition|)
block|{
name|Fdelete_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
return|return;
block|}
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
name|windows_or_buffers_changed
operator|++
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|=
name|height
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
condition|)
block|{
for|for
control|(
name|child
operator|=
name|w
operator|->
name|hchild
init|;
operator|!
name|NULL
argument_list|(
name|child
argument_list|)
condition|;
name|child
operator|=
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|next
control|)
block|{
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|top
operator|=
name|w
operator|->
name|top
expr_stmt|;
name|set_window_height
argument_list|(
name|child
argument_list|,
name|height
argument_list|,
name|nodelete
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
condition|)
block|{
name|lastbot
operator|=
name|top
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
expr_stmt|;
name|lastobot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|child
operator|=
name|w
operator|->
name|vchild
init|;
operator|!
name|NULL
argument_list|(
name|child
argument_list|)
condition|;
name|child
operator|=
name|c
operator|->
name|next
control|)
block|{
name|c
operator|=
name|XWINDOW
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|opos
operator|=
name|lastobot
operator|+
name|XFASTINT
argument_list|(
name|c
operator|->
name|height
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|c
operator|->
name|top
argument_list|)
operator|=
name|lastbot
expr_stmt|;
name|pos
operator|=
operator|(
operator|(
operator|(
name|opos
operator|*
name|height
operator|)
operator|<<
literal|1
operator|)
operator|+
name|oheight
operator|)
operator|/
operator|(
name|oheight
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* Avoid confusion: inhibit deletion of child if becomes too small */
name|set_window_height
argument_list|(
name|child
argument_list|,
name|pos
operator|+
name|top
operator|-
name|lastbot
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now advance child to next window, 	     and set lastbot if child was not just deleted.  */
name|lastbot
operator|=
name|pos
operator|+
name|top
operator|,
name|lastobot
operator|=
name|opos
expr_stmt|;
block|}
comment|/* Now delete any children that became too small.  */
if|if
condition|(
operator|!
name|nodelete
condition|)
for|for
control|(
name|child
operator|=
name|w
operator|->
name|vchild
init|;
operator|!
name|NULL
argument_list|(
name|child
argument_list|)
condition|;
name|child
operator|=
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|next
control|)
block|{
name|set_window_height
argument_list|(
name|child
argument_list|,
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|height
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Recursively set width of WINDOW and its inferiors. */
end_comment

begin_macro
name|set_window_width
argument_list|(
argument|window
argument_list|,
argument|width
argument_list|,
argument|nodelete
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nodelete
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|c
decl_stmt|;
name|int
name|owidth
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
decl_stmt|;
name|int
name|left
decl_stmt|,
name|pos
decl_stmt|,
name|lastright
decl_stmt|,
name|opos
decl_stmt|,
name|lastoright
decl_stmt|;
name|Lisp_Object
name|child
decl_stmt|;
if|if
condition|(
operator|!
name|nodelete
operator|&&
name|width
operator|<
name|window_min_width
condition|)
block|{
name|Fdelete_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
return|return;
block|}
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
operator|=
name|width
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
condition|)
block|{
for|for
control|(
name|child
operator|=
name|w
operator|->
name|vchild
init|;
operator|!
name|NULL
argument_list|(
name|child
argument_list|)
condition|;
name|child
operator|=
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|next
control|)
block|{
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|left
operator|=
name|w
operator|->
name|left
expr_stmt|;
name|set_window_width
argument_list|(
name|child
argument_list|,
name|width
argument_list|,
name|nodelete
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
condition|)
block|{
name|lastright
operator|=
name|left
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
expr_stmt|;
name|lastoright
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|child
operator|=
name|w
operator|->
name|hchild
init|;
operator|!
name|NULL
argument_list|(
name|child
argument_list|)
condition|;
name|child
operator|=
name|c
operator|->
name|next
control|)
block|{
name|c
operator|=
name|XWINDOW
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|opos
operator|=
name|lastoright
operator|+
name|XFASTINT
argument_list|(
name|c
operator|->
name|width
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|c
operator|->
name|left
argument_list|)
operator|=
name|lastright
expr_stmt|;
name|pos
operator|=
operator|(
operator|(
operator|(
name|opos
operator|*
name|width
operator|)
operator|<<
literal|1
operator|)
operator|+
name|owidth
operator|)
operator|/
operator|(
name|owidth
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* Inhibit deletion for becoming too small */
name|set_window_width
argument_list|(
name|child
argument_list|,
name|pos
operator|+
name|left
operator|-
name|lastright
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now advance child to next window, 	     and set lastright if child was not just deleted.  */
name|lastright
operator|=
name|pos
operator|+
name|left
operator|,
name|lastoright
operator|=
name|opos
expr_stmt|;
block|}
comment|/* Delete children that became too small */
if|if
condition|(
operator|!
name|nodelete
condition|)
for|for
control|(
name|child
operator|=
name|w
operator|->
name|hchild
init|;
operator|!
name|NULL
argument_list|(
name|child
argument_list|)
condition|;
name|child
operator|=
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|next
control|)
block|{
name|set_window_width
argument_list|(
name|child
argument_list|,
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|child
argument_list|)
operator|->
name|width
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|window_select_count
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"show-buffer"
argument_list|,
argument|Fshow_buffer
argument_list|,
argument|Sshow_buffer
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Make WINDOW display BUFFER as its contents.\n\ BUFFER can be a buffer or buffer name."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|,
name|buffer
operator|)
name|Lisp_Object
name|window
operator|,
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|struct
name|window
modifier|*
name|w
init|=
name|decode_window
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Attempt to display deleted buffer"
argument_list|)
expr_stmt|;
name|tem
operator|=
name|w
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|unshow_buffer
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|==
name|bf_cur
condition|?
name|point
else|:
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|text
operator|.
name|pointloc
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
operator|->
name|last_window_start
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
name|windows_or_buffers_changed
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|Fset_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Record info on buffer window w is displaying  when it is about to cease to display that buffer.  */
end_comment

begin_macro
name|unshow_buffer
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|buf
decl_stmt|;
name|buf
operator|=
name|w
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|!=
name|XMARKER
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
operator|->
name|buffer
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|&&
name|EQ
argument_list|(
name|buf
argument_list|,
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
return|return;
if|if
condition|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|==
name|bf_cur
condition|)
block|{
if|if
condition|(
name|w
operator|!=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
condition|)
name|point
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
expr_stmt|;
block|}
else|else
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|text
operator|.
name|pointloc
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
expr_stmt|;
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|last_window_start
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"select-window"
argument_list|,
argument|Fselect_window
argument_list|,
argument|Sselect_window
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Select WINDOW.  Most editing will apply to WINDOW's buffer.\n\ The main editor command loop selects the buffer of the selected window\n\ before each command."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|ow
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
condition|)
name|error
argument_list|(
literal|"Trying to select window with no buffer"
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|use_time
argument_list|)
operator|=
operator|++
name|window_select_count
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
return|return
name|window
return|;
if|if
condition|(
name|bf_cur
operator|==
name|XBUFFER
argument_list|(
name|ow
operator|->
name|buffer
argument_list|)
condition|)
name|Fset_marker
argument_list|(
name|ow
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|ow
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|selected_window
operator|=
name|window
expr_stmt|;
name|record_buffer
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf_cur
operator|==
name|XBUFFER
argument_list|(
name|ow
operator|->
name|buffer
argument_list|)
condition|)
block|{
comment|/* If the new and old windows show the same buffer, 	 Fset_buffer did nothing.  So we must switch to 	 the new buffer's value of point.  */
name|SetPoint
argument_list|(
name|marker_position
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|FirstCharacter
condition|)
name|point
operator|=
name|FirstCharacter
expr_stmt|;
if|if
condition|(
name|point
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
name|point
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
block|}
name|windows_or_buffers_changed
operator|++
expr_stmt|;
return|return
name|window
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"display-buffer"
argument_list|,
argument|Fdisplay_buffer
argument_list|,
argument|Sdisplay_buffer
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Make BUFFER appear in some window but don't select it.\n\ BUFFER can be a buffer or a buffer name.\n\ If BUFFER is shown already in some window, just uses that one,\n\ unless the window is the selected window and NOTTHISWINDOW is non-nil.\n\ Returns the window displaying BUFFER."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|buffer
operator|,
name|notthiswindow
operator|)
name|Lisp_Object
name|buffer
operator|,
name|notthiswindow
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|window
decl_stmt|;
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|notthiswindow
argument_list|)
operator|&&
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
operator|==
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|selected_window
return|;
name|window
operator|=
name|Fget_buffer_window
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|window
argument_list|)
operator|&&
operator|(
name|NULL
argument_list|(
name|notthiswindow
argument_list|)
operator|||
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
operator|)
condition|)
return|return
name|window
return|;
if|if
condition|(
name|pop_up_windows
condition|)
block|{
comment|/* Don't try to create a window if would get an error */
if|if
condition|(
name|window_min_height
operator|<
literal|2
condition|)
name|window_min_height
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|split_height_threshold
operator|<
name|window_min_height
operator|<<
literal|1
condition|)
name|split_height_threshold
operator|=
name|window_min_height
operator|<<
literal|1
expr_stmt|;
name|window
operator|=
name|Fget_largest_window
argument_list|()
expr_stmt|;
if|if
condition|(
name|window_height
argument_list|(
name|window
argument_list|)
operator|>=
name|split_height_threshold
operator|&&
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|width
argument_list|)
operator|!=
name|screen_width
condition|)
name|window
operator|=
name|Fsplit_window
argument_list|(
name|window
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
else|else
block|{
name|window
operator|=
name|Fget_lru_window
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
operator|||
operator|(
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|EQ
argument_list|(
name|window
argument_list|,
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|)
operator|)
operator|)
operator|&&
name|window_height
argument_list|(
name|window
argument_list|)
operator|>=
name|window_min_height
operator|<<
literal|1
condition|)
name|window
operator|=
name|Fsplit_window
argument_list|(
name|window
argument_list|,
name|Qnil
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|window
operator|=
name|Fget_lru_window
argument_list|()
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|window
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|window
return|;
block|}
end_block

begin_macro
name|temp_output_buffer_show
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|Lisp_Object
name|window
decl_stmt|;
name|Fset_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|save_modified
operator|=
name|bf_modified
expr_stmt|;
name|SetPoint
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bf_head_clip
operator|=
literal|1
expr_stmt|;
name|bf_tail_clip
operator|=
literal|0
expr_stmt|;
name|clip_changed
operator|=
literal|1
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|window
operator|=
name|Fdisplay_buffer
argument_list|(
name|buf
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|hscroll
argument_list|)
operator|=
literal|0
expr_stmt|;
name|Fset_marker
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
literal|1
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|make_dummy_parent
argument_list|(
argument|window
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|old
decl_stmt|,
name|new
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|o
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|old
operator|=
name|window
expr_stmt|;
name|XSETTYPE
argument_list|(
name|old
argument_list|,
name|Lisp_Vector
argument_list|)
expr_stmt|;
name|new
operator|=
name|Fcopy_sequence
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
name|new
argument_list|,
name|Lisp_Window
argument_list|)
expr_stmt|;
name|o
operator|=
name|XWINDOW
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|p
operator|=
name|XWINDOW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|sequence_number
argument_list|)
operator|=
operator|++
name|sequence_number
expr_stmt|;
comment|/* Put new into window structure in place of window */
name|replace_window
argument_list|(
name|window
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|Qnil
expr_stmt|;
name|o
operator|->
name|prev
operator|=
name|Qnil
expr_stmt|;
name|o
operator|->
name|vchild
operator|=
name|Qnil
expr_stmt|;
name|o
operator|->
name|hchild
operator|=
name|Qnil
expr_stmt|;
name|o
operator|->
name|parent
operator|=
name|new
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|pointm
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"split-window"
argument_list|,
argument|Fsplit_window
argument_list|,
argument|Ssplit_window
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|""
argument_list|,
literal|"Split WINDOW, putting SIZE lines in the first of the pair.\n\ WINDOW defaults to selected one and SIZE to half its size.\n\ If optional third arg HOR-FLAG is non-nil, split side by side\n\ and put SIZE columns in the first of the pair."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|window
operator|,
name|chsize
operator|,
name|horflag
operator|)
name|Lisp_Object
name|window
operator|,
name|chsize
operator|,
name|horflag
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|new
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|o
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|window
argument_list|)
condition|)
name|window
operator|=
name|selected_window
expr_stmt|;
else|else
name|CHECK_WINDOW
argument_list|(
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|chsize
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|horflag
argument_list|)
condition|)
name|size
operator|=
name|XFASTINT
argument_list|(
name|o
operator|->
name|width
argument_list|)
operator|>>
literal|1
expr_stmt|;
else|else
name|size
operator|=
name|XFASTINT
argument_list|(
name|o
operator|->
name|height
argument_list|)
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
name|CHECK_NUMBER
argument_list|(
name|chsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|XINT
argument_list|(
name|chsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
name|error
argument_list|(
literal|"Attempt to split minibuffer window"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|horflag
argument_list|)
condition|)
block|{
if|if
condition|(
name|window_min_height
operator|<
literal|2
condition|)
name|window_min_height
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|window_min_height
operator|||
name|size
operator|+
name|window_min_height
operator|>
name|XFASTINT
argument_list|(
name|o
operator|->
name|height
argument_list|)
condition|)
name|args_out_of_range_3
argument_list|(
name|window
argument_list|,
name|chsize
argument_list|,
name|horflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|o
operator|->
name|parent
argument_list|)
operator|||
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|o
operator|->
name|parent
argument_list|)
operator|->
name|vchild
argument_list|)
condition|)
block|{
name|make_dummy_parent
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|new
operator|=
name|o
operator|->
name|parent
expr_stmt|;
name|XWINDOW
argument_list|(
name|new
argument_list|)
operator|->
name|vchild
operator|=
name|window
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
name|window_min_width
operator|||
name|size
operator|+
name|window_min_width
operator|>
name|XFASTINT
argument_list|(
name|o
operator|->
name|width
argument_list|)
condition|)
name|args_out_of_range_3
argument_list|(
name|window
argument_list|,
name|chsize
argument_list|,
name|horflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|o
operator|->
name|parent
argument_list|)
operator|||
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|o
operator|->
name|parent
argument_list|)
operator|->
name|hchild
argument_list|)
condition|)
block|{
name|make_dummy_parent
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|new
operator|=
name|o
operator|->
name|parent
expr_stmt|;
name|XWINDOW
argument_list|(
name|new
argument_list|)
operator|->
name|hchild
operator|=
name|window
expr_stmt|;
block|}
block|}
comment|/* Now we know that window's parent is a vertical combination      if we are dividing vertically, or a horizontal combination      if we are making side-by-side windows */
name|windows_or_buffers_changed
operator|++
expr_stmt|;
name|new
operator|=
name|make_window
argument_list|()
expr_stmt|;
name|p
operator|=
name|XWINDOW
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|o
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|next
argument_list|)
condition|)
name|XWINDOW
argument_list|(
name|p
operator|->
name|next
argument_list|)
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|window
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|o
operator|->
name|parent
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|new
argument_list|,
name|o
operator|->
name|buffer
argument_list|)
expr_stmt|;
comment|/* Apportion the available screen space among the two new windows */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|horflag
argument_list|)
condition|)
block|{
name|p
operator|->
name|height
operator|=
name|o
operator|->
name|height
expr_stmt|;
name|p
operator|->
name|top
operator|=
name|o
operator|->
name|top
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|width
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|o
operator|->
name|width
argument_list|)
operator|-
name|size
expr_stmt|;
name|XFASTINT
argument_list|(
name|o
operator|->
name|width
argument_list|)
operator|=
name|size
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|o
operator|->
name|left
argument_list|)
operator|+
name|size
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|left
operator|=
name|o
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|o
operator|->
name|width
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|height
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|o
operator|->
name|height
argument_list|)
operator|-
name|size
expr_stmt|;
name|XFASTINT
argument_list|(
name|o
operator|->
name|height
argument_list|)
operator|=
name|size
expr_stmt|;
name|XFASTINT
argument_list|(
name|p
operator|->
name|top
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|o
operator|->
name|top
argument_list|)
operator|+
name|size
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"enlarge-window"
argument_list|,
argument|Fenlarge_window
argument_list|,
argument|Senlarge_window
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"p"
argument_list|,
literal|"Make current window ARG lines bigger.\n\ From program, optional second arg non-nil means grow sideways ARG columns."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|side
operator|)
name|Lisp_Object
name|n
operator|,
name|side
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_window_height
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
operator|!
name|NULL
argument_list|(
name|side
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"shrink-window"
argument_list|,
argument|Fshrink_window
argument_list|,
argument|Sshrink_window
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"p"
argument_list|,
literal|"Make current window ARG lines smaller.\n\ From program, optional second arg non-nil means shrink sideways ARG columns."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|side
operator|)
name|Lisp_Object
name|n
operator|,
name|side
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_window_height
argument_list|(
operator|-
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
operator|!
name|NULL
argument_list|(
name|side
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|int
name|window_height
parameter_list|(
name|window
parameter_list|)
name|Lisp_Object
name|window
decl_stmt|;
block|{
specifier|register
name|struct
name|window
modifier|*
name|p
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
return|return
name|XFASTINT
argument_list|(
name|p
operator|->
name|height
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|window_width
parameter_list|(
name|window
parameter_list|)
name|Lisp_Object
name|window
decl_stmt|;
block|{
specifier|register
name|struct
name|window
modifier|*
name|p
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
return|return
name|XFASTINT
argument_list|(
name|p
operator|->
name|width
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MINSIZE
parameter_list|(
name|window
parameter_list|)
define|\
value|(widthflag ? window_min_width  \    : (EQ (window, minibuf_window) ? 1 : window_min_height))
end_define

begin_define
define|#
directive|define
name|CURBEG
parameter_list|(
name|w
parameter_list|)
define|\
value|*(widthflag ? (int *)&w->left : (int *)&w->top)
end_define

begin_define
define|#
directive|define
name|CURSIZE
parameter_list|(
name|w
parameter_list|)
define|\
value|*(widthflag ? (int *)&w->width : (int *)&w->height)
end_define

begin_comment
comment|/* Unlike set_window_height, this function  also changes the heights of the siblings so as to  keep everything consistent. */
end_comment

begin_macro
name|change_window_height
argument_list|(
argument|delta
argument_list|,
argument|widthflag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|delta
decl_stmt|,
name|widthflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|window
decl_stmt|,
name|parent
decl_stmt|,
name|tem
decl_stmt|;
specifier|register
name|struct
name|window
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|sizep
decl_stmt|;
name|int
function_decl|(
modifier|*
name|sizefun
function_decl|)
parameter_list|()
init|=
name|widthflag
condition|?
name|window_width
operator|:
name|window_height
function_decl|;
name|int
function_decl|(
modifier|*
name|setsizefun
function_decl|)
parameter_list|()
init|=
name|widthflag
condition|?
name|set_window_width
operator|:
name|set_window_height
function_decl|;
name|int
name|opht
decl_stmt|,
name|maxdelta
decl_stmt|;
name|window
operator|=
name|selected_window
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|parent
operator|=
name|p
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|parent
argument_list|)
condition|)
block|{
if|if
condition|(
name|widthflag
condition|)
name|error
argument_list|(
literal|"No other window to side of this one"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|widthflag
condition|?
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|hchild
argument_list|)
else|:
operator|!
name|NULL
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
operator|->
name|vchild
argument_list|)
condition|)
break|break;
name|window
operator|=
name|parent
expr_stmt|;
block|}
name|sizep
operator|=
operator|&
name|CURSIZE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sizep
operator|+
name|delta
operator|<
name|MINSIZE
argument_list|(
name|window
argument_list|)
condition|)
block|{
name|Fdelete_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
return|return;
block|}
name|maxdelta
operator|=
operator|(
operator|!
name|NULL
argument_list|(
name|parent
argument_list|)
condition|?
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|parent
argument_list|)
operator|-
operator|*
name|sizep
else|:
operator|(
name|tem
operator|=
operator|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|next
argument_list|)
condition|?
name|p
operator|->
name|next
else|:
name|p
operator|->
name|prev
operator|)
operator|,
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|tem
argument_list|)
operator|-
name|MINSIZE
argument_list|(
name|tem
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|maxdelta
condition|)
comment|/* This case traps trying to make the minibuffer        the full screen, or make the only window aside from the        minibuffer the full screen.  */
name|delta
operator|=
name|maxdelta
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|next
argument_list|)
operator|&&
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|p
operator|->
name|next
argument_list|)
operator|-
name|delta
operator|>=
name|MINSIZE
argument_list|(
name|p
operator|->
name|next
argument_list|)
condition|)
block|{
call|(
modifier|*
name|setsizefun
call|)
argument_list|(
name|p
operator|->
name|next
argument_list|,
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|p
operator|->
name|next
argument_list|)
operator|-
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|setsizefun
call|)
argument_list|(
name|window
argument_list|,
operator|*
name|sizep
operator|+
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CURBEG
argument_list|(
name|XWINDOW
argument_list|(
name|p
operator|->
name|next
argument_list|)
argument_list|)
operator|+=
name|delta
expr_stmt|;
comment|/* This does not change size of p->next, 	 but it propagates the new top edge to its children */
call|(
modifier|*
name|setsizefun
call|)
argument_list|(
name|p
operator|->
name|next
argument_list|,
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|p
operator|->
name|next
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|prev
argument_list|)
operator|&&
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|p
operator|->
name|prev
argument_list|)
operator|-
name|delta
operator|>=
name|MINSIZE
argument_list|(
name|p
operator|->
name|prev
argument_list|)
condition|)
block|{
call|(
modifier|*
name|setsizefun
call|)
argument_list|(
name|p
operator|->
name|prev
argument_list|,
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|p
operator|->
name|prev
argument_list|)
operator|-
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CURBEG
argument_list|(
name|p
argument_list|)
operator|-=
name|delta
expr_stmt|;
call|(
modifier|*
name|setsizefun
call|)
argument_list|(
name|window
argument_list|,
operator|*
name|sizep
operator|+
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opht
operator|=
call|(
modifier|*
name|sizefun
call|)
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
call|(
name|float
call|)
argument_list|(
name|delta
operator|*
name|opht
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|opht
operator|-
operator|*
name|sizep
operator|-
name|delta
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add delta lines or columns to this window, and to the parent, 	 keeping things consistent while not affecting siblings.  */
name|CURSIZE
argument_list|(
name|XWINDOW
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|=
name|opht
operator|+
name|delta
expr_stmt|;
call|(
modifier|*
name|setsizefun
call|)
argument_list|(
name|window
argument_list|,
operator|*
name|sizep
operator|+
name|delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Squeeze out delta lines or columns from our parent, 	 shriking this window and siblings proportionately. 	 This brings parent back to correct size. 	 Delta was calculated so this makes this window the desired size, 	 taking it all out of the siblings.  */
call|(
modifier|*
name|setsizefun
call|)
argument_list|(
name|parent
argument_list|,
name|opht
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|p
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|window_scroll
argument_list|(
argument|window
argument_list|,
argument|n
argument_list|)
name|Lisp_Object
name|window
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|opoint
init|=
name|point
decl_stmt|;
specifier|register
name|int
name|ht
decl_stmt|,
name|pos
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|ht
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
operator|-
operator|!
name|EQ
argument_list|(
name|window
argument_list|,
name|minibuf_window
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|tem
argument_list|)
operator|=
name|point
expr_stmt|;
name|tem
operator|=
name|Fpos_visible_in_window_p
argument_list|(
name|tem
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|Fvertical_motion
argument_list|(
name|make_number
argument_list|(
operator|-
name|ht
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|tem
argument_list|)
operator|=
name|point
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|tem
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|w
operator|->
name|force_start
operator|=
name|Qt
expr_stmt|;
block|}
name|SetPoint
argument_list|(
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|lose
operator|=
name|n
operator|<
literal|0
operator|&&
name|point
operator|==
name|FirstCharacter
expr_stmt|;
name|Fvertical_motion
argument_list|(
name|make_number
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|point
expr_stmt|;
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|lose
condition|)
name|Fsignal
argument_list|(
name|Qbeginning_of_buffer
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|NumCharacters
operator|+
literal|1
condition|)
block|{
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|pos
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|w
operator|->
name|redo_mode_line
operator|=
name|Qt
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|opoint
condition|)
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|SetPoint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fvertical_motion
argument_list|(
name|make_number
argument_list|(
name|ht
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|>
name|opoint
operator|||
name|XFASTINT
argument_list|(
name|tem
argument_list|)
operator|<
name|ht
condition|)
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
else|else
name|Fvertical_motion
argument_list|(
name|make_number
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|Fsignal
argument_list|(
name|Qend_of_buffer
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|scroll_command
argument_list|(
argument|n
argument_list|,
argument|direction
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|direction
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|defalt
init|=
name|direction
operator|*
operator|(
name|window_height
argument_list|(
name|selected_window
argument_list|)
operator|-
literal|1
operator|-
name|next_screen_context_lines
operator|)
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
name|window_scroll
argument_list|(
name|selected_window
argument_list|,
name|defalt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|n
argument_list|,
name|Qminus
argument_list|)
condition|)
name|window_scroll
argument_list|(
name|selected_window
argument_list|,
operator|-
name|defalt
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|Fprefix_numeric_value
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|window_scroll
argument_list|(
name|selected_window
argument_list|,
name|XINT
argument_list|(
name|n
argument_list|)
operator|*
name|direction
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"scroll-up"
argument_list|,
argument|Fscroll_up
argument_list|,
argument|Sscroll_up
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Scroll text of current window upward ARG lines; or near full screen if no ARG.\n\ When calling from a program, supply a number as argument or nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|scroll_command
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"scroll-down"
argument_list|,
argument|Fscroll_down
argument_list|,
argument|Sscroll_down
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Scroll text of current window downward ARG lines; or near full screen if no ARG.\n\ When calling from a program, supply a number as argument or nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|scroll_command
argument_list|(
name|n
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"scroll-left"
argument_list|,
argument|Fscroll_left
argument_list|,
argument|Sscroll_left
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Scroll selected window display ARG columns left.\n\ Default for ARG is window width minus 2."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|width
argument_list|)
operator|-
literal|2
expr_stmt|;
else|else
name|arg
operator|=
name|Fprefix_numeric_value
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|Fset_window_hscroll
argument_list|(
name|selected_window
argument_list|,
name|make_number
argument_list|(
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|hscroll
argument_list|)
operator|+
name|XINT
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"scroll-right"
argument_list|,
argument|Fscroll_right
argument_list|,
argument|Sscroll_right
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Scroll selected window display ARG columns right.\n\ Default for ARG is window width minus 2."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|=
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|width
argument_list|)
operator|-
literal|2
expr_stmt|;
else|else
name|arg
operator|=
name|Fprefix_numeric_value
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|Fset_window_hscroll
argument_list|(
name|selected_window
argument_list|,
name|make_number
argument_list|(
name|XINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|hscroll
argument_list|)
operator|-
name|XINT
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"scroll-other-window"
argument_list|,
argument|Fscroll_other_window
argument_list|,
argument|Sscroll_other_window
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Scroll text of next window upward ARG lines; or near full screen if no ARG.\n\ The next window is the one below the current one; or the one at the top\n\ if the current one is at the bottom.\n\ When calling from a program, supply a number as argument or nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|window
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|int
name|ht
decl_stmt|;
specifier|register
name|int
name|opoint
init|=
name|point
decl_stmt|;
name|window
operator|=
name|Fnext_window
argument_list|(
name|selected_window
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|ht
operator|=
name|window_height
argument_list|(
name|window
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
condition|)
name|error
argument_list|(
literal|"There is no other window"
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|marker_position
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|pointm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
name|window_scroll
argument_list|(
name|window
argument_list|,
name|ht
operator|-
name|next_screen_context_lines
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|n
argument_list|,
name|Qminus
argument_list|)
condition|)
name|window_scroll
argument_list|(
name|window
argument_list|,
name|next_screen_context_lines
operator|-
name|ht
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|n
argument_list|)
operator|==
name|Lisp_Cons
condition|)
name|n
operator|=
name|Fcar
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|window_scroll
argument_list|(
name|window
argument_list|,
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Fset_marker
argument_list|(
name|XWINDOW
argument_list|(
name|window
argument_list|)
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"recenter"
argument_list|,
argument|Frecenter
argument_list|,
argument|Srecenter
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Center point in window and redisplay screen.  With ARG, put point on line ARG.\n\ The desired position of point is always relative to the current window.\n\ If there is no ARG (i.e., it is nil) then the entire screen is redisplayed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ht
init|=
name|window_height
argument_list|(
name|selected_window
argument_list|)
operator|-
operator|!
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
decl_stmt|;
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
specifier|register
name|int
name|opoint
init|=
name|point
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|n
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|screen_garbaged
decl_stmt|;
name|screen_garbaged
operator|++
expr_stmt|;
name|XFASTINT
argument_list|(
name|n
argument_list|)
operator|=
name|ht
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|Fprefix_numeric_value
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XINT
argument_list|(
name|n
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|n
argument_list|,
name|XINT
argument_list|(
name|n
argument_list|)
operator|+
name|ht
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|n
argument_list|,
operator|-
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|Fvertical_motion
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|opoint
argument_list|)
expr_stmt|;
name|w
operator|->
name|force_start
operator|=
name|Qt
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"move-to-window-line"
argument_list|,
argument|Fmove_to_window_line
argument_list|,
argument|Smove_to_window_line
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Position point relative to window.\n\ With no argument, position at text at center of window.\n\ An argument specifies screen line; zero means top of window,\n\ negative means relative to bottom of window."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
name|int
name|height
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
decl_stmt|;
specifier|register
name|int
name|start
decl_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
condition|)
name|height
operator|--
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|arg
argument_list|)
operator|=
name|height
operator|/
literal|2
expr_stmt|;
else|else
block|{
name|arg
operator|=
name|Fprefix_numeric_value
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|arg
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|arg
argument_list|,
name|XINT
argument_list|(
name|arg
argument_list|)
operator|+
name|height
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|marker_position
argument_list|(
name|w
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|FirstCharacter
operator|||
name|start
operator|>
name|NumCharacters
operator|+
literal|1
condition|)
block|{
name|Fvertical_motion
argument_list|(
name|make_number
argument_list|(
operator|-
name|height
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|w
operator|->
name|force_start
operator|=
name|Qt
expr_stmt|;
name|start
operator|=
name|point
expr_stmt|;
block|}
else|else
name|SetPoint
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
name|Fvertical_motion
argument_list|(
name|arg
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_struct
struct|struct
name|saved_window
block|{
name|Lisp_Object
name|window
decl_stmt|;
name|Lisp_Object
name|buffer
decl_stmt|,
name|start
decl_stmt|,
name|pointm
decl_stmt|,
name|mark
decl_stmt|;
name|Lisp_Object
name|left
decl_stmt|,
name|top
decl_stmt|,
name|width
decl_stmt|,
name|height
decl_stmt|,
name|hscroll
decl_stmt|;
name|Lisp_Object
name|parent
decl_stmt|,
name|prev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|save_window_data
block|{
name|long
name|size
decl_stmt|;
name|struct
name|Lisp_Vector
modifier|*
name|unused
decl_stmt|;
name|Lisp_Object
name|nsaved
decl_stmt|;
name|Lisp_Object
name|current_window
decl_stmt|;
name|Lisp_Object
name|current_buffer
decl_stmt|;
name|struct
name|saved_window
name|info
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|Lisp_Object
name|save_window_restore
parameter_list|(
name|arg
parameter_list|)
name|Lisp_Object
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
decl_stmt|;
specifier|register
name|struct
name|save_window_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|save_window_data
operator|*
operator|)
name|XINTPTR
argument_list|(
name|arg
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|saved_window
modifier|*
name|p
init|=
name|data
operator|->
name|info
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|windows_or_buffers_changed
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|XFASTINT
argument_list|(
name|data
operator|->
name|nsaved
argument_list|)
condition|;
name|k
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|w
operator|=
name|XWINDOW
argument_list|(
name|p
operator|->
name|window
argument_list|)
expr_stmt|;
name|w
operator|->
name|next
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|parent
argument_list|)
condition|)
name|w
operator|->
name|parent
operator|=
name|data
operator|->
name|info
index|[
name|XFASTINT
argument_list|(
name|p
operator|->
name|parent
argument_list|)
index|]
operator|.
name|window
expr_stmt|;
else|else
name|w
operator|->
name|parent
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|p
operator|->
name|prev
argument_list|)
condition|)
block|{
name|w
operator|->
name|prev
operator|=
name|data
operator|->
name|info
index|[
name|XFASTINT
argument_list|(
name|p
operator|->
name|prev
argument_list|)
index|]
operator|.
name|window
expr_stmt|;
name|XWINDOW
argument_list|(
name|w
operator|->
name|prev
argument_list|)
operator|->
name|next
operator|=
name|p
operator|->
name|window
expr_stmt|;
block|}
else|else
block|{
name|w
operator|->
name|prev
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|parent
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|p
operator|->
name|width
argument_list|,
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|width
argument_list|)
condition|)
block|{
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|vchild
operator|=
name|p
operator|->
name|window
expr_stmt|;
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|hchild
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
block|{
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|hchild
operator|=
name|p
operator|->
name|window
expr_stmt|;
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|vchild
operator|=
name|Qnil
expr_stmt|;
block|}
block|}
block|}
name|w
operator|->
name|left
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|w
operator|->
name|top
operator|=
name|p
operator|->
name|top
expr_stmt|;
name|w
operator|->
name|width
operator|=
name|p
operator|->
name|width
expr_stmt|;
name|w
operator|->
name|height
operator|=
name|p
operator|->
name|height
expr_stmt|;
name|w
operator|->
name|hscroll
operator|=
name|p
operator|->
name|hscroll
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Reinstall the saved buffer and pointers into it.  */
if|if
condition|(
name|NULL
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
condition|)
name|w
operator|->
name|buffer
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
comment|/* If saved buffer is alive, install it.  */
block|{
name|w
operator|->
name|buffer
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|Fmarker_position
argument_list|(
name|p
operator|->
name|start
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|,
name|Fmarker_position
argument_list|(
name|p
operator|->
name|pointm
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|name
argument_list|)
condition|)
comment|/* Else if window's old buffer is dead too, get a live one.  */
block|{
name|w
operator|->
name|buffer
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|Vbuffer_alist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set window markers at start of buffer. 		 Rely on Fset_marker to put them within the restriction.  */
name|Fset_marker
argument_list|(
name|w
operator|->
name|start
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|unchain_marker
argument_list|(
name|p
operator|->
name|start
argument_list|)
expr_stmt|;
name|unchain_marker
argument_list|(
name|p
operator|->
name|pointm
argument_list|)
expr_stmt|;
name|tem
operator|=
name|p
operator|->
name|mark
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|mark
operator|=
name|Qnil
expr_stmt|;
else|else
block|{
if|if
condition|(
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|mark
argument_list|)
condition|)
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|mark
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|mark
argument_list|,
name|Fmarker_position
argument_list|(
name|p
operator|->
name|mark
argument_list|)
argument_list|,
name|w
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|unchain_marker
argument_list|(
name|p
operator|->
name|mark
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Fselect_window
argument_list|(
name|data
operator|->
name|current_window
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|data
operator|->
name|current_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|count_windows
argument_list|(
argument|window
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|window
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|window
operator|->
name|next
argument_list|)
condition|)
name|count
operator|+=
name|count_windows
argument_list|(
name|XWINDOW
argument_list|(
name|window
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|window
operator|->
name|vchild
argument_list|)
condition|)
name|count
operator|+=
name|count_windows
argument_list|(
name|XWINDOW
argument_list|(
name|window
operator|->
name|vchild
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|window
operator|->
name|hchild
argument_list|)
condition|)
name|count
operator|+=
name|count_windows
argument_list|(
name|XWINDOW
argument_list|(
name|window
operator|->
name|hchild
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_define
define|#
directive|define
name|SAVE_DATA_SIZE
parameter_list|(
name|n_windows
parameter_list|)
define|\
value|((n_windows - 1) * sizeof (struct saved_window) \    + sizeof (struct save_window_data))
end_define

begin_function
name|Lisp_Object
name|save_window_save
parameter_list|()
block|{
name|Lisp_Object
name|root
decl_stmt|;
name|int
name|n_windows
decl_stmt|;
name|struct
name|save_window_data
modifier|*
name|data
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|int
name|size
decl_stmt|;
name|root
operator|=
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
expr_stmt|;
name|n_windows
operator|=
name|count_windows
argument_list|(
name|XWINDOW
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|SAVE_DATA_SIZE
argument_list|(
name|n_windows
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|save_window_data
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|data
operator|->
name|size
operator|=
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|Lisp_Vector
operator|*
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Lisp_Object
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|data
operator|->
name|nsaved
argument_list|)
operator|=
name|n_windows
expr_stmt|;
name|data
operator|->
name|current_window
operator|=
name|selected_window
expr_stmt|;
name|XSET
argument_list|(
name|data
operator|->
name|current_buffer
argument_list|,
name|Lisp_Buffer
argument_list|,
name|bf_cur
argument_list|)
expr_stmt|;
name|save_window_save_1
argument_list|(
name|root
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|tem
argument_list|,
name|Lisp_Temp_Vector
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_macro
name|save_window_save_1
argument_list|(
argument|window
argument_list|,
argument|data
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|save_window_data
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|saved_window
modifier|*
name|p
decl_stmt|;
name|struct
name|window
modifier|*
name|w
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|window
argument_list|)
condition|;
name|window
operator|=
name|w
operator|->
name|next
control|)
block|{
name|p
operator|=
operator|&
name|data
operator|->
name|info
index|[
name|i
index|]
expr_stmt|;
name|w
operator|=
name|XWINDOW
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|temslot
argument_list|)
operator|=
name|i
operator|++
expr_stmt|;
name|p
operator|->
name|window
operator|=
name|window
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|w
operator|->
name|buffer
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|w
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|top
operator|=
name|w
operator|->
name|top
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|w
operator|->
name|width
expr_stmt|;
name|p
operator|->
name|height
operator|=
name|w
operator|->
name|height
expr_stmt|;
name|p
operator|->
name|hscroll
operator|=
name|w
operator|->
name|hscroll
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|window
argument_list|,
name|selected_window
argument_list|)
operator|&&
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|==
name|bf_cur
condition|)
name|p
operator|->
name|pointm
operator|=
name|Fpoint_marker
argument_list|()
expr_stmt|;
else|else
name|p
operator|->
name|pointm
operator|=
name|Fcopy_marker
argument_list|(
name|w
operator|->
name|pointm
argument_list|)
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|Fcopy_marker
argument_list|(
name|w
operator|->
name|start
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XBUFFER
argument_list|(
name|w
operator|->
name|buffer
argument_list|)
operator|->
name|mark
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|p
operator|->
name|mark
operator|=
name|Fcopy_marker
argument_list|(
name|tem
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|mark
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|pointm
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|Qnil
expr_stmt|;
name|p
operator|->
name|mark
operator|=
name|Qnil
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|w
operator|->
name|parent
argument_list|)
condition|)
name|p
operator|->
name|parent
operator|=
name|Qnil
expr_stmt|;
else|else
name|p
operator|->
name|parent
operator|=
name|XWINDOW
argument_list|(
name|w
operator|->
name|parent
argument_list|)
operator|->
name|temslot
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|w
operator|->
name|prev
argument_list|)
condition|)
name|p
operator|->
name|prev
operator|=
name|Qnil
expr_stmt|;
else|else
name|p
operator|->
name|prev
operator|=
name|XWINDOW
argument_list|(
name|w
operator|->
name|prev
argument_list|)
operator|->
name|temslot
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|vchild
argument_list|)
condition|)
name|i
operator|=
name|save_window_save_1
argument_list|(
name|w
operator|->
name|vchild
argument_list|,
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|w
operator|->
name|hchild
argument_list|)
condition|)
name|i
operator|=
name|save_window_save_1
argument_list|(
name|w
operator|->
name|hchild
argument_list|,
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"save-window-excursion"
argument_list|,
argument|Fsave_window_excursion
argument_list|,
argument|Ssave_window_excursion
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Execute body, preserving window sizes and contents.\n\ Restores which buffer appears in which window, where display starts,\n\ as well as the current buffer.\n\ Does not restore the value of point in that buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|tem
operator|=
name|save_window_save
argument_list|()
expr_stmt|;
name|GCPRO1
argument_list|(
operator|*
name|XOBJFWD
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|gcpro1
operator|.
name|nvars
operator|=
name|SAVE_DATA_SIZE
argument_list|(
name|XFASTINT
argument_list|(
operator|(
operator|(
expr|struct
name|save_window_data
operator|*
operator|)
name|XINTPTR
argument_list|(
name|tem
argument_list|)
operator|)
operator|->
name|nsaved
argument_list|)
argument_list|)
operator|/
literal|4
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|save_window_restore
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_window_once
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|Lisp_Object
name|get_minibuffer
parameter_list|()
function_decl|;
name|Lisp_Object
name|root_window
decl_stmt|;
name|root_window
operator|=
name|make_window
argument_list|()
expr_stmt|;
name|minibuf_window
operator|=
name|make_window
argument_list|()
expr_stmt|;
name|XWINDOW
argument_list|(
name|root_window
argument_list|)
operator|->
name|next
operator|=
name|minibuf_window
expr_stmt|;
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
operator|=
name|root_window
expr_stmt|;
comment|/* These values 9 and 10 are arbitrary,      just so that there is "something there."      Correct values are put in in init_xdisp */
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|root_window
argument_list|)
operator|->
name|width
argument_list|)
operator|=
literal|10
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|width
argument_list|)
operator|=
literal|10
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|root_window
argument_list|)
operator|->
name|height
argument_list|)
operator|=
literal|9
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|top
argument_list|)
operator|=
literal|9
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|height
argument_list|)
operator|=
literal|1
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|root_window
argument_list|,
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
name|Fshow_buffer
argument_list|(
name|minibuf_window
argument_list|,
name|get_minibuffer
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|selected_window
operator|=
name|root_window
expr_stmt|;
block|}
end_block

begin_macro
name|syms_of_window
argument_list|()
end_macro

begin_block
block|{
name|Qwindowp
operator|=
name|intern
argument_list|(
literal|"windowp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qwindowp
argument_list|)
expr_stmt|;
comment|/* Make sure all windows get marked */
name|staticpro
argument_list|(
operator|&
name|minibuf_window
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"pop-up-windows"
argument_list|,
operator|&
name|pop_up_windows
argument_list|,
literal|"*Non-nil means display-buffer should make new windows."
argument_list|)
expr_stmt|;
name|pop_up_windows
operator|=
literal|1
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"next-screen-context-lines"
argument_list|,
operator|&
name|next_screen_context_lines
argument_list|,
literal|"*Number of lines of continuity when scrolling by screenfuls."
argument_list|)
expr_stmt|;
name|next_screen_context_lines
operator|=
literal|2
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"split-height-threshold"
argument_list|,
operator|&
name|split_height_threshold
argument_list|,
literal|"*display-buffer would prefer to split the largest window if this large.\n\ If there is only one window, it is split regardless of this value."
argument_list|)
expr_stmt|;
name|split_height_threshold
operator|=
literal|500
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"window-min-height"
argument_list|,
operator|&
name|window_min_height
argument_list|,
literal|"*Delete any window less than this tall (including its mode line)."
argument_list|)
expr_stmt|;
name|window_min_height
operator|=
literal|4
expr_stmt|;
name|DefIntVar
argument_list|(
literal|"window-min-width"
argument_list|,
operator|&
name|window_min_width
argument_list|,
literal|"*Delete any window less than this wide."
argument_list|)
expr_stmt|;
name|window_min_width
operator|=
literal|10
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sselected_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindowp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spos_visible_in_window_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindow_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindow_height
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindow_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindow_hscroll
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_window_hscroll
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindow_edges
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindow_point
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Swindow_point
argument_list|,
literal|"window-dot"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swindow_start
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_window_point
argument_list|)
expr_stmt|;
name|defalias
argument_list|(
operator|&
name|Sset_window_point
argument_list|,
literal|"set-window-dot"
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_window_start
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snext_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprevious_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sother_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_lru_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_largest_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sget_buffer_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_other_windows
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_windows_on
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sreplace_buffer_in_windows
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sshow_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sselect_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdisplay_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssplit_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Senlarge_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sshrink_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscroll_up
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscroll_down
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscroll_left
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscroll_right
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscroll_other_window
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecenter
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smove_to_window_line
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssave_window_excursion
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_window
argument_list|()
end_macro

begin_block
block|{
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'1'
argument_list|,
literal|"delete-other-windows"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'2'
argument_list|,
literal|"split-window"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'0'
argument_list|,
literal|"delete-window"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'o'
argument_list|,
literal|"other-window"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'^'
argument_list|,
literal|"enlarge-window"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'<'
argument_list|,
literal|"scroll-left"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
literal|'>'
argument_list|,
literal|"scroll-right"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'V'
argument_list|)
argument_list|,
literal|"scroll-up"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
name|Ctl
argument_list|(
literal|'V'
argument_list|)
argument_list|,
literal|"scroll-other-window"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
literal|'v'
argument_list|,
literal|"scroll-down"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'L'
argument_list|)
argument_list|,
literal|"recenter"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
literal|'r'
argument_list|,
literal|"move-to-window-line"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

