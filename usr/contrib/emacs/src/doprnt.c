begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output like sprintf to a buffer of specified size.    Also takes args differently: pass one pointer to an array of strings    in addition to the format string which is separate.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_macro
name|doprnt
argument_list|(
argument|buffer
argument_list|,
argument|bufsize
argument_list|,
argument|format
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|bufsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Number of arg to gobble next */
specifier|register
name|char
modifier|*
name|fmt
init|=
name|format
decl_stmt|;
comment|/* Pointer into format string */
specifier|register
name|char
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
comment|/* Pointer into output buffer.. */
name|char
name|tembuf
index|[
literal|80
index|]
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|char
name|fmtcpy
index|[
literal|20
index|]
decl_stmt|;
name|int
name|minlen
decl_stmt|;
name|bufsize
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|&&
name|bufsize
operator|>
literal|0
condition|)
comment|/* Loop until end of format string or buffer full */
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
comment|/* Check for a '%' character */
block|{
name|fmt
operator|++
expr_stmt|;
comment|/* Copy this one %-spec into fmtcopy.  */
name|string
operator|=
name|fmtcpy
expr_stmt|;
operator|*
name|string
operator|++
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|*
name|string
operator|++
operator|=
operator|*
name|fmt
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|fmt
operator|>=
literal|'0'
operator|&&
operator|*
name|fmt
operator|<=
literal|'9'
operator|)
operator|&&
operator|*
name|fmt
operator|!=
literal|'-'
operator|&&
operator|*
name|fmt
operator|!=
literal|' '
condition|)
break|break;
name|fmt
operator|++
expr_stmt|;
block|}
operator|*
name|string
operator|=
literal|0
expr_stmt|;
name|minlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Invalid format operation %%%c"
argument_list|,
name|fmt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
name|sprintf
argument_list|(
name|tembuf
argument_list|,
name|fmtcpy
argument_list|,
name|args
index|[
name|cnt
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* Now copy tembuf into final output, truncating as nec.  */
name|string
operator|=
name|tembuf
expr_stmt|;
goto|goto
name|doit
goto|;
case|case
literal|'s'
case|:
name|string
operator|=
name|args
index|[
name|cnt
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|fmtcpy
index|[
literal|1
index|]
operator|!=
literal|'s'
condition|)
name|minlen
operator|=
name|atoi
argument_list|(
operator|&
name|fmtcpy
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Copy string into final output, truncating if no room.  */
name|doit
label|:
name|tem
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|minlen
operator|-=
name|tem
expr_stmt|;
while|while
condition|(
name|minlen
operator|>
literal|0
operator|&&
name|bufsize
operator|>
literal|0
condition|)
block|{
operator|*
name|bufptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|bufsize
operator|--
expr_stmt|;
name|minlen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|tem
operator|>
name|bufsize
condition|)
name|tem
operator|=
name|bufsize
expr_stmt|;
name|strncpy
argument_list|(
name|bufptr
argument_list|,
name|string
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
name|tem
expr_stmt|;
name|bufsize
operator|-=
name|tem
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
operator|*
name|bufptr
operator|++
operator|=
operator|(
name|int
operator|)
name|args
index|[
name|cnt
operator|++
index|]
expr_stmt|;
name|bufsize
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
name|fmt
operator|--
expr_stmt|;
comment|/* Drop thru and this % will be treated as normal */
block|}
block|}
operator|*
name|bufptr
operator|++
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
comment|/* Just some characters; Copy 'em */
name|bufsize
operator|--
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|bufptr
operator|=
literal|0
expr_stmt|;
comment|/* Make sure our string end with a '\0' */
return|return
name|bufptr
operator|-
name|buffer
return|;
block|}
end_block

end_unit

