begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Cursor motion subroutines for GNU Emacs.    Copyright (C) 1985 Richard M. Stallman.     based primarily on public domain code written by Chris Torek  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cm.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_define
define|#
directive|define
name|BIG
value|9999
end_define

begin_comment
comment|/* 9999 good on VAXen.  For 16 bit machines 				   use about 2000.... */
end_comment

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|tgoto
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sums up costs */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|evalcost
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cost
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|void
name|cmputc
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|termscript
condition|)
name|fputc
argument_list|(
name|c
operator|&
literal|0177
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NEXT TWO ARE DONE WITH MACROS */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Assume the cursor is at row row, column col.  Normally used only after  * clearing the screen, when the cursor is at (0, 0), but what the heck,  * let's let the guy put it anywhere.  */
end_comment

begin_comment
unit|static at (row, col) {     curY = row;     curX = col; }
comment|/*  * Add n columns to the current cursor position.  */
end_comment

begin_comment
unit|static addcol (n) {     curX += n;
comment|/*      * If cursor hit edge of screen, what happened?      * N.B.: DO NOT!! write past edge of screen.  If you do, you      * deserve what you get.  Furthermore, on terminals with      * autowrap (but not magicwrap), don't write in the last column      * of the last line.      */
end_comment

begin_comment
unit|if (curX == Wcm.cm_cols) {
comment|/* 	 * Well, if magicwrap, still there, past the edge of the 	 * screen (!).  If autowrap, on the col 0 of the next line. 	 * Otherwise on last column. 	 */
end_comment

begin_comment
unit|if (Wcm.cm_magicwrap) 	    ;
comment|/* "limbo" */
end_comment

begin_comment
unit|else if (Wcm.cm_autowrap) { 	    curX = 0; 	    curY++;
comment|/* Beware end of screen! */
end_comment

begin_endif
unit|} 	else 	    curX--;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * (Re)Initialize the cost factors, given the output speed of the terminal  * in the variable ospeed.  (Note: this holds B300, B9600, etc -- ie stuff  * out of<sgtty.h>.)  */
end_comment

begin_macro
name|cmcostinit
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|COST
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
value|(x ? (cost = 0, tputs (x, 1, e), cost) : BIG)
define|#
directive|define
name|CMCOST
parameter_list|(
name|x
parameter_list|,
name|e
parameter_list|)
value|((x == 0) ? BIG : (p = tgoto(x, 0, 0), COST(p ,e)))
name|Wcm
operator|.
name|cc_up
operator|=
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_up
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_down
operator|=
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_down
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_left
operator|=
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_left
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_right
operator|=
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_right
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_home
operator|=
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_home
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_cr
operator|=
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_cr
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_ll
operator|=
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_ll
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_tab
operator|=
name|Wcm
operator|.
name|cm_tabwidth
condition|?
name|COST
argument_list|(
name|Wcm
operator|.
name|cm_tab
argument_list|,
name|evalcost
argument_list|)
else|:
name|BIG
expr_stmt|;
comment|/*      * These last three are actually minimum costs.  When (if) they are      * candidates for the least-cost motion, the real cost is computed.      * (Note that "0" is the assumed to generate the minimum cost.      * While this is not necessarily true, I have yet to see a terminal      * for which is not; all the terminals that have variable-cost      * cursor motion seem to take straight numeric values.  --ACT)      */
name|Wcm
operator|.
name|cc_abs
operator|=
name|CMCOST
argument_list|(
name|Wcm
operator|.
name|cm_abs
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_habs
operator|=
name|CMCOST
argument_list|(
name|Wcm
operator|.
name|cm_habs
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|Wcm
operator|.
name|cc_vabs
operator|=
name|CMCOST
argument_list|(
name|Wcm
operator|.
name|cm_vabs
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CMCOST
undef|#
directive|undef
name|COST
block|}
end_block

begin_comment
comment|/*  * Calculate the cost to move from (srcy, srcx) to (dsty, dstx) using  * up and down, and left and right, motions, and tabs.  If doit is set  * actually perform the motion.  */
end_comment

begin_expr_stmt
specifier|static
name|calccost
argument_list|(
argument|srcy
argument_list|,
argument|srcx
argument_list|,
argument|dsty
argument_list|,
argument|dstx
argument_list|,
argument|doit
argument_list|)
block|{
specifier|register
name|int
name|deltay
block|,
name|deltax
block|,
name|c
block|,
name|totalcost
block|;
name|int
name|ntabs
block|,
name|n2tabs
block|,
name|tabx
block|,
name|tab2x
block|,
name|tabcost
block|;
specifier|register
name|char
operator|*
name|p
block|;
comment|/* If have just wrapped on a terminal with xn,        don't believe the cursor position: give up here        and force use of absolute positioning.  */
if|if
condition|(
name|curX
operator|==
name|Wcm
operator|.
name|cm_cols
condition|)
goto|goto
name|fail
goto|;
name|totalcost
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|deltay
operator|=
name|dsty
operator|-
name|srcy
operator|)
operator|==
literal|0
condition|)
goto|goto
name|x
goto|;
end_if

begin_if
if|if
condition|(
name|deltay
operator|<
literal|0
condition|)
name|p
operator|=
name|Wcm
operator|.
name|cm_up
operator|,
name|c
operator|=
name|Wcm
operator|.
name|cc_up
operator|,
name|deltay
operator|=
operator|-
name|deltay
expr_stmt|;
else|else
name|p
operator|=
name|Wcm
operator|.
name|cm_down
operator|,
name|c
operator|=
name|Wcm
operator|.
name|cc_down
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|c
operator|==
name|BIG
condition|)
block|{
comment|/* caint get thar from here */
if|if
condition|(
name|doit
condition|)
name|printf
argument_list|(
literal|"OOPS"
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_if

begin_expr_stmt
name|totalcost
operator|=
name|c
operator|*
name|deltay
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|doit
condition|)
while|while
condition|(
operator|--
name|deltay
operator|>=
literal|0
condition|)
name|tputs
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
end_if

begin_label
name|x
label|:
end_label

begin_if
if|if
condition|(
operator|(
name|deltax
operator|=
name|dstx
operator|-
name|srcx
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
end_if

begin_if
if|if
condition|(
name|deltax
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|Wcm
operator|.
name|cm_left
operator|,
name|c
operator|=
name|Wcm
operator|.
name|cc_left
operator|,
name|deltax
operator|=
operator|-
name|deltax
expr_stmt|;
goto|goto
name|dodelta
goto|;
comment|/* skip all the tab junk */
block|}
end_if

begin_comment
comment|/* Tabs (the toughie) */
end_comment

begin_if
if|if
condition|(
name|Wcm
operator|.
name|cc_tab
operator|>=
name|BIG
operator|||
operator|!
name|Wcm
operator|.
name|cm_usetabs
condition|)
goto|goto
name|olddelta
goto|;
end_if

begin_comment
comment|/* forget it! */
end_comment

begin_comment
comment|/*       * ntabs is # tabs towards but not past dstx; n2tabs is one more      * (ie past dstx), but this is only valid if that is not past the      * right edge of the screen.  We can check that at the same time      * as we figure out where we would be if we use the tabs (which      * we will put into tabx (for ntabs) and tab2x (for n2tabs)).      */
end_comment

begin_expr_stmt
name|ntabs
operator|=
name|deltax
operator|/
name|Wcm
operator|.
name|cm_tabwidth
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|n2tabs
operator|=
name|ntabs
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tabx
operator|=
operator|(
name|srcx
operator|/
name|Wcm
operator|.
name|cm_tabwidth
operator|+
name|ntabs
operator|)
operator|*
name|Wcm
operator|.
name|cm_tabwidth
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tab2x
operator|=
name|tabx
operator|+
name|Wcm
operator|.
name|cm_tabwidth
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|tab2x
operator|>=
name|Wcm
operator|.
name|cm_cols
condition|)
comment|/* too far (past edge) */
name|n2tabs
operator|=
literal|0
expr_stmt|;
end_if

begin_comment
comment|/*       * Now set tabcost to the cost for using ntabs, and c to the cost      * for using n2tabs, then pick the minimum.      */
end_comment

begin_comment
comment|/* cost for ntabs     +    cost for right motion */
end_comment

begin_expr_stmt
name|tabcost
operator|=
name|ntabs
condition|?
name|ntabs
operator|*
name|Wcm
operator|.
name|cc_tab
operator|+
operator|(
name|dstx
operator|-
name|tabx
operator|)
operator|*
name|Wcm
operator|.
name|cc_right
else|:
name|BIG
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* cost for n2tabs    +    cost for left motion */
end_comment

begin_expr_stmt
name|c
operator|=
name|n2tabs
condition|?
name|n2tabs
operator|*
name|Wcm
operator|.
name|cc_tab
operator|+
operator|(
name|tab2x
operator|-
name|dstx
operator|)
operator|*
name|Wcm
operator|.
name|cc_left
else|:
name|BIG
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|<
name|tabcost
condition|)
comment|/* then cheaper to overshoot& back up */
name|ntabs
operator|=
name|n2tabs
operator|,
name|tabcost
operator|=
name|c
operator|,
name|tabx
operator|=
name|tab2x
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|tabcost
operator|>=
name|BIG
condition|)
comment|/* caint use tabs */
goto|goto
name|newdelta
goto|;
end_if

begin_comment
comment|/*       * See if tabcost is less than just moving right      */
end_comment

begin_if
if|if
condition|(
name|tabcost
operator|<
operator|(
name|deltax
operator|*
name|Wcm
operator|.
name|cc_right
operator|)
condition|)
block|{
name|totalcost
operator|+=
name|tabcost
expr_stmt|;
comment|/* use the tabs */
if|if
condition|(
name|doit
condition|)
while|while
condition|(
operator|--
name|ntabs
operator|>=
literal|0
condition|)
name|tputs
argument_list|(
name|Wcm
operator|.
name|cm_tab
argument_list|,
literal|1
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
name|srcx
operator|=
name|tabx
expr_stmt|;
block|}
end_if

begin_comment
comment|/*       * Now might as well just recompute the delta.      */
end_comment

begin_label
name|newdelta
label|:
end_label

begin_if
if|if
condition|(
operator|(
name|deltax
operator|=
name|dstx
operator|-
name|srcx
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
end_if

begin_label
name|olddelta
label|:
end_label

begin_if
if|if
condition|(
name|deltax
operator|>
literal|0
condition|)
name|p
operator|=
name|Wcm
operator|.
name|cm_right
operator|,
name|c
operator|=
name|Wcm
operator|.
name|cc_right
expr_stmt|;
else|else
name|p
operator|=
name|Wcm
operator|.
name|cm_left
operator|,
name|c
operator|=
name|Wcm
operator|.
name|cc_left
operator|,
name|deltax
operator|=
operator|-
name|deltax
expr_stmt|;
end_if

begin_label
name|dodelta
label|:
end_label

begin_if
if|if
condition|(
name|c
operator|==
name|BIG
condition|)
block|{
comment|/* caint get thar from here */
name|fail
label|:
if|if
condition|(
name|doit
condition|)
name|printf
argument_list|(
literal|"OOPS"
argument_list|)
expr_stmt|;
return|return
name|BIG
return|;
block|}
end_if

begin_expr_stmt
name|totalcost
operator|+=
name|c
operator|*
name|deltax
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|doit
condition|)
while|while
condition|(
operator|--
name|deltax
operator|>=
literal|0
condition|)
name|tputs
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
end_if

begin_label
name|done
label|:
end_label

begin_return
return|return
name|totalcost
return|;
end_return

begin_expr_stmt
unit|}  losecursor
operator|(
operator|)
block|{
name|curY
operator|=
operator|-
literal|1
block|; }
define|#
directive|define
name|USEREL
value|0
define|#
directive|define
name|USEHOME
value|1
define|#
directive|define
name|USELL
value|2
define|#
directive|define
name|USECR
value|3
name|cmgoto
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|)
block|{
name|int
name|homecost
block|,
name|crcost
block|,
name|llcost
block|,
name|relcost
block|,
name|directcost
block|;
name|int
name|use
block|;
name|char
operator|*
name|p
block|,
operator|*
name|dcm
block|;
comment|/* First the degenerate case */
if|if
condition|(
name|row
operator|==
name|curY
operator|&&
name|col
operator|==
name|curX
condition|)
comment|/* already there */
return|return;
end_expr_stmt

begin_if
if|if
condition|(
name|curY
operator|>=
literal|0
operator|&&
name|curX
operator|>=
literal|0
condition|)
block|{
comment|/*         * Pick least-cost motions        */
name|relcost
operator|=
name|calccost
argument_list|(
name|curY
argument_list|,
name|curX
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|use
operator|=
name|USEREL
expr_stmt|;
if|if
condition|(
operator|(
name|homecost
operator|=
name|Wcm
operator|.
name|cc_home
operator|)
operator|<
name|BIG
condition|)
name|homecost
operator|+=
name|calccost
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|homecost
operator|<
name|relcost
condition|)
name|relcost
operator|=
name|homecost
operator|,
name|use
operator|=
name|USEHOME
expr_stmt|;
if|if
condition|(
operator|(
name|llcost
operator|=
name|Wcm
operator|.
name|cc_ll
operator|)
operator|<
name|BIG
condition|)
name|llcost
operator|+=
name|calccost
argument_list|(
name|Wcm
operator|.
name|cm_rows
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|llcost
operator|<
name|relcost
condition|)
name|relcost
operator|=
name|llcost
operator|,
name|use
operator|=
name|USELL
expr_stmt|;
if|if
condition|(
operator|(
name|crcost
operator|=
name|Wcm
operator|.
name|cc_cr
operator|)
operator|<
name|BIG
condition|)
block|{
if|if
condition|(
name|Wcm
operator|.
name|cm_autolf
condition|)
if|if
condition|(
name|curY
operator|+
literal|1
operator|>=
name|Wcm
operator|.
name|cm_rows
condition|)
name|crcost
operator|=
name|BIG
expr_stmt|;
else|else
name|crcost
operator|+=
name|calccost
argument_list|(
name|curY
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|crcost
operator|+=
name|calccost
argument_list|(
name|curY
argument_list|,
literal|0
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crcost
operator|<
name|relcost
condition|)
name|relcost
operator|=
name|crcost
operator|,
name|use
operator|=
name|USECR
expr_stmt|;
name|directcost
operator|=
name|Wcm
operator|.
name|cc_abs
operator|,
name|dcm
operator|=
name|Wcm
operator|.
name|cm_abs
expr_stmt|;
if|if
condition|(
name|row
operator|==
name|curY
operator|&&
name|Wcm
operator|.
name|cc_habs
operator|<
name|BIG
condition|)
name|directcost
operator|=
name|Wcm
operator|.
name|cc_habs
operator|,
name|dcm
operator|=
name|Wcm
operator|.
name|cm_habs
expr_stmt|;
elseif|else
if|if
condition|(
name|col
operator|==
name|curX
operator|&&
name|Wcm
operator|.
name|cc_vabs
operator|<
name|BIG
condition|)
name|directcost
operator|=
name|Wcm
operator|.
name|cc_vabs
operator|,
name|dcm
operator|=
name|Wcm
operator|.
name|cm_vabs
expr_stmt|;
block|}
else|else
block|{
name|directcost
operator|=
literal|0
operator|,
name|relcost
operator|=
literal|100000
expr_stmt|;
name|dcm
operator|=
name|Wcm
operator|.
name|cm_abs
expr_stmt|;
block|}
end_if

begin_comment
comment|/*     * In the following comparison, the = in<= is because when the costs    * are the same, it looks nicer (I think) to move directly there.    */
end_comment

begin_if
if|if
condition|(
name|directcost
operator|<=
name|relcost
condition|)
block|{
comment|/* compute REAL direct cost */
name|cost
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|dcm
operator|==
name|Wcm
operator|.
name|cm_habs
condition|?
name|tgoto
argument_list|(
name|dcm
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
else|:
name|tgoto
argument_list|(
name|dcm
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
if|if
condition|(
name|cost
operator|<=
name|relcost
condition|)
block|{
comment|/* really is cheaper */
name|tputs
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
name|curY
operator|=
name|row
operator|,
name|curX
operator|=
name|col
expr_stmt|;
return|return;
block|}
block|}
end_if

begin_switch
switch|switch
condition|(
name|use
condition|)
block|{
case|case
name|USEHOME
case|:
name|tputs
argument_list|(
name|Wcm
operator|.
name|cm_home
argument_list|,
literal|1
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
name|curY
operator|=
literal|0
operator|,
name|curX
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USELL
case|:
name|tputs
argument_list|(
name|Wcm
operator|.
name|cm_ll
argument_list|,
literal|1
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
name|curY
operator|=
name|Wcm
operator|.
name|cm_rows
operator|-
literal|1
operator|,
name|curX
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|USECR
case|:
name|tputs
argument_list|(
name|Wcm
operator|.
name|cm_cr
argument_list|,
literal|1
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
if|if
condition|(
name|Wcm
operator|.
name|cm_autolf
condition|)
name|curY
operator|++
expr_stmt|;
name|curX
operator|=
literal|0
expr_stmt|;
break|break;
block|}
end_switch

begin_expr_stmt
operator|(
name|void
operator|)
name|calccost
argument_list|(
name|curY
argument_list|,
name|curX
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curY
operator|=
name|row
operator|,
name|curX
operator|=
name|col
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Clear out all terminal info.    Used before copying into it the info on the actual terminal.  */
end_comment

begin_expr_stmt
unit|Wcm_clear
operator|(
operator|)
block|{
name|bzero
argument_list|(
operator|&
name|Wcm
argument_list|,
sizeof|sizeof
name|Wcm
argument_list|)
block|;
name|UP
operator|=
literal|0
block|;
name|BC
operator|=
literal|0
block|; }
comment|/*  * Initialized stuff  * Return 0 if can do CM.  */
name|Wcm_init
argument_list|()
block|{
comment|/* Check that we know the size of the screen.... */
if|if
condition|(
name|Wcm
operator|.
name|cm_rows
operator|<=
literal|0
operator|||
name|Wcm
operator|.
name|cm_cols
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|Wcm
operator|.
name|cm_abs
operator|&&
operator|!
name|Wcm
operator|.
name|cm_ds
condition|)
return|return
literal|0
return|;
end_if

begin_comment
comment|/* Require up and left, and, if no absolute, down and right */
end_comment

begin_if
if|if
condition|(
operator|!
name|Wcm
operator|.
name|cm_up
operator|||
operator|!
name|Wcm
operator|.
name|cm_left
condition|)
return|return
operator|-
literal|1
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|Wcm
operator|.
name|cm_abs
operator|&&
operator|(
operator|!
name|Wcm
operator|.
name|cm_down
operator|||
operator|!
name|Wcm
operator|.
name|cm_right
operator|)
condition|)
return|return
operator|-
literal|1
return|;
end_if

begin_return
return|return
literal|0
return|;
end_return

unit|}
end_unit

