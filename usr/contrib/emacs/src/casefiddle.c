begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Emacs case conversion functions.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_define
define|#
directive|define
name|UPCASE
value|0
end_define

begin_define
define|#
directive|define
name|DOWNCASE
value|1
end_define

begin_define
define|#
directive|define
name|CAPITALIZE
value|2
end_define

begin_define
define|#
directive|define
name|CAPITALIZE_UP
value|3
end_define

begin_escape
end_escape

begin_function
name|Lisp_Object
name|casify_object
parameter_list|(
name|flag
parameter_list|,
name|obj
parameter_list|)
name|int
name|flag
decl_stmt|;
name|Lisp_Object
name|obj
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|int
name|inword
init|=
name|flag
operator|==
name|DOWNCASE
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|c
operator|=
name|XINT
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|inword
condition|?
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
else|:
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
name|XFASTINT
argument_list|(
name|obj
argument_list|)
operator|=
name|c
operator|^
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
return|return
name|obj
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|obj
operator|=
name|Fcopy_sequence
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|inword
condition|?
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
else|:
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
name|XSTRING
argument_list|(
name|obj
argument_list|)
operator|->
name|data
index|[
name|i
index|]
operator|=
name|c
operator|^
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|CAPITALIZE
condition|)
name|inword
operator|=
name|SYNTAX
argument_list|(
name|c
argument_list|)
operator|==
name|Sword
expr_stmt|;
block|}
return|return
name|obj
return|;
block|}
name|obj
operator|=
name|wrong_type_argument
argument_list|(
name|Qchar_or_string_p
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"upcase"
argument_list|,
argument|Fupcase
argument_list|,
argument|Supcase
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg, a character or string.  Convert it to upper case and return that."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|casify_object
argument_list|(
name|UPCASE
argument_list|,
name|obj
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"downcase"
argument_list|,
argument|Fdowncase
argument_list|,
argument|Sdowncase
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg, a character or string.  Convert it to lower case and return that."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|casify_object
argument_list|(
name|DOWNCASE
argument_list|,
name|obj
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"capitalize"
argument_list|,
argument|Fcapitalize
argument_list|,
argument|Scapitalize
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"One arg, a character or string.  Convert it to capitalized form and return that.\n\ This means that each word's first character is upper case and the rest is lower case."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|casify_object
argument_list|(
name|CAPITALIZE
argument_list|,
name|obj
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* flag is UPCASE, DOWNCASE or CAPITALIZE or CAPITALIZE_UP.    b and e specify range of buffer to operate on. */
end_comment

begin_macro
name|casify_region
argument_list|(
argument|flag
argument_list|,
argument|b
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|b
decl_stmt|,
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|inword
init|=
name|flag
operator|==
name|DOWNCASE
decl_stmt|;
name|validate_region
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|)
name|Fbarf_if_buffer_read_only
argument_list|()
expr_stmt|;
name|RecordChange
argument_list|(
name|XFASTINT
argument_list|(
name|b
argument_list|)
argument_list|,
name|XFASTINT
argument_list|(
name|e
argument_list|)
operator|-
name|XFASTINT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|modify_region
argument_list|(
name|XFASTINT
argument_list|(
name|b
argument_list|)
argument_list|,
name|XFASTINT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|XFASTINT
argument_list|(
name|b
argument_list|)
init|;
name|i
operator|<
name|XFASTINT
argument_list|(
name|e
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|CharAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|inword
condition|?
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|&&
name|flag
operator|!=
name|CAPITALIZE_UP
operator|)
else|:
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
name|CharAt
argument_list|(
name|i
argument_list|)
operator|=
name|c
operator|^
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
if|if
condition|(
name|flag
operator|>=
name|CAPITALIZE
condition|)
name|inword
operator|=
name|SYNTAX
argument_list|(
name|c
argument_list|)
operator|==
name|Sword
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"upcase-region"
argument_list|,
argument|Fupcase_region
argument_list|,
argument|Supcase_region
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"r"
argument_list|,
literal|"Convert the region to upper case.  In programs, wants two arguments.\n\ These arguments specify the starting and ending character numbers of\n\ the region to operate on.  When used as a command, the text between\n\ point and the mark is operated on."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|casify_region
argument_list|(
name|UPCASE
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"downcase-region"
argument_list|,
argument|Fdowncase_region
argument_list|,
argument|Sdowncase_region
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"r"
argument_list|,
literal|"Convert the region to lower case.  In programs, wants two arguments.\n\ These arguments specify the starting and ending character numbers of\n\ the region to operate on.  When used as a command, the text between\n\ point and the mark is operated on."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|casify_region
argument_list|(
name|DOWNCASE
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"capitalize-region"
argument_list|,
argument|Fcapitalize_region
argument_list|,
argument|Scapitalize_region
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"r"
argument_list|,
literal|"Convert the region to upper case.  In programs, wants two arguments.\n\ These arguments specify the starting and ending character numbers of\n\ the region to operate on.  When used as a command, the text between\n\ point and the mark is operated on.\n\ Capitalized form means each word's first character is upper case\n\ and the rest of it is lower case."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|casify_region
argument_list|(
name|CAPITALIZE
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Like Fcapitalize but change only the initials.  */
end_comment

begin_function
name|Lisp_Object
name|upcase_initials_region
parameter_list|(
name|b
parameter_list|,
name|e
parameter_list|)
name|Lisp_Object
name|b
decl_stmt|,
name|e
decl_stmt|;
block|{
name|casify_region
argument_list|(
name|CAPITALIZE_UP
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|operate_on_word
parameter_list|(
name|flag
parameter_list|,
name|arg
parameter_list|)
name|int
name|flag
decl_stmt|;
name|Lisp_Object
name|arg
decl_stmt|;
block|{
name|Lisp_Object
name|beg
decl_stmt|,
name|end
decl_stmt|;
name|int
name|farend
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|farend
operator|=
name|scan_words
argument_list|(
name|point
argument_list|,
name|XINT
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|farend
condition|)
name|farend
operator|=
name|XINT
argument_list|(
name|arg
argument_list|)
operator|>
literal|0
condition|?
name|NumCharacters
operator|+
literal|1
else|:
name|FirstCharacter
expr_stmt|;
name|XFASTINT
argument_list|(
name|beg
argument_list|)
operator|=
name|point
operator|<
name|farend
condition|?
name|point
else|:
name|farend
expr_stmt|;
name|XFASTINT
argument_list|(
name|end
argument_list|)
operator|=
name|point
operator|>
name|farend
condition|?
name|point
else|:
name|farend
expr_stmt|;
name|casify_region
argument_list|(
name|flag
argument_list|,
name|beg
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|SetPoint
argument_list|(
name|XFASTINT
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"upcase-word"
argument_list|,
argument|Fupcase_word
argument_list|,
argument|Supcase_word
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Convert following word (or ARG words) to upper case, moving over.\n\ With negative argument, convert previous words but do not move."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|operate_on_word
argument_list|(
name|UPCASE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"downcase-word"
argument_list|,
argument|Fdowncase_word
argument_list|,
argument|Sdowncase_word
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Convert following word (or ARG words) to lower case, moving over.\n\ With negative argument, convert previous words but do not move."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|operate_on_word
argument_list|(
name|DOWNCASE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"capitalize-word"
argument_list|,
argument|Fcapitalize_word
argument_list|,
argument|Scapitalize_word
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"p"
argument_list|,
literal|"Capitalize the following word (or ARG words), moving over.\n\ This gives the word(s) a first character in upper case\n\ and the rest lower case.\n\ With negative argument, capitalize previous words but do not move."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|operate_on_word
argument_list|(
name|CAPITALIZE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_casefiddle
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Supcase
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdowncase
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scapitalize
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Supcase_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdowncase_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scapitalize_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Supcase_word
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdowncase_word
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scapitalize_word
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_casefiddle
argument_list|()
end_macro

begin_block
block|{
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
name|Ctl
argument_list|(
literal|'U'
argument_list|)
argument_list|,
literal|"upcase-region"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|CtlXmap
argument_list|,
name|Ctl
argument_list|(
literal|'L'
argument_list|)
argument_list|,
literal|"downcase-region"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
literal|'u'
argument_list|,
literal|"upcase-word"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
literal|'l'
argument_list|,
literal|"downcase-word"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
literal|'c'
argument_list|,
literal|"capitalize-word"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

