begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Buffer insertion/deletion and gap motion for GNU Emacs.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_comment
comment|/* Move gap to position `pos'. */
end_comment

begin_macro
name|GapTo
argument_list|(
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bf_p2
operator|!=
name|bf_gap
operator|+
name|bf_p1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|<=
name|bf_s1
condition|)
name|gap_left
argument_list|(
name|pos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pos
operator|>
name|bf_s1
operator|+
literal|1
condition|)
name|gap_right
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|gap_left
argument_list|(
name|pos
argument_list|)
specifier|register
name|int
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pos
operator|--
expr_stmt|;
if|if
condition|(
name|unchanged_modified
operator|==
name|bf_modified
condition|)
block|{
name|beg_unchanged
operator|=
name|pos
expr_stmt|;
name|end_unchanged
operator|=
name|bf_s1
operator|+
name|bf_s2
operator|-
name|pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bf_s2
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|bf_s2
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|pos
expr_stmt|;
block|}
name|adjust_markers
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|bf_s1
operator|+
literal|1
argument_list|,
name|bf_gap
argument_list|)
expr_stmt|;
name|to
operator|=
name|bf_p2
expr_stmt|;
name|from
operator|=
name|bf_p1
expr_stmt|;
name|i
operator|=
name|bf_s1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
name|pos
condition|)
name|to
index|[
name|i
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
name|bf_s2
operator|+=
name|bf_s1
operator|-
name|pos
expr_stmt|;
name|bf_s1
operator|=
name|pos
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|gap_right
argument_list|(
name|pos
argument_list|)
specifier|register
name|int
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|pos
operator|--
expr_stmt|;
if|if
condition|(
name|unchanged_modified
operator|==
name|bf_modified
condition|)
block|{
name|beg_unchanged
operator|=
name|pos
expr_stmt|;
name|end_unchanged
operator|=
name|bf_s1
operator|+
name|bf_s2
operator|-
name|pos
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bf_s1
operator|+
name|bf_s2
operator|-
name|pos
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|bf_s1
operator|+
name|bf_s2
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|bf_s1
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|bf_s1
expr_stmt|;
block|}
name|adjust_markers
argument_list|(
name|bf_s1
operator|+
name|bf_gap
operator|+
literal|1
argument_list|,
name|pos
operator|+
name|bf_gap
operator|+
literal|1
argument_list|,
operator|-
name|bf_gap
argument_list|)
expr_stmt|;
name|from
operator|=
name|bf_p2
expr_stmt|;
name|to
operator|=
name|bf_p1
expr_stmt|;
name|i
operator|=
name|bf_s1
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<=
name|pos
condition|)
name|to
index|[
name|i
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
name|bf_s2
operator|+=
name|bf_s1
operator|-
name|pos
expr_stmt|;
name|bf_s1
operator|=
name|pos
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add `amount' to the position of every marker in the current buffer    whose current position is between `from' (exclusive) and `to' (inclusive).    Also, any markers past the outside of that interval, in the direction    of adjustment, are first moved back to the near end of the interval    and then adjusted by `amount'.  */
end_comment

begin_expr_stmt
name|adjust_markers
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|amount
argument_list|)
specifier|register
name|int
name|from
operator|,
name|to
operator|,
name|amount
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|marker
decl_stmt|;
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|mpos
decl_stmt|;
name|marker
operator|=
name|bf_cur
operator|->
name|markers
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|marker
argument_list|)
condition|)
block|{
name|m
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|mpos
operator|=
name|m
operator|->
name|bufpos
expr_stmt|;
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mpos
operator|>
name|to
operator|&&
name|mpos
operator|<
name|to
operator|+
name|amount
condition|)
name|mpos
operator|=
name|to
operator|+
name|amount
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mpos
operator|>
name|from
operator|+
name|amount
operator|&&
name|mpos
operator|<=
name|from
condition|)
name|mpos
operator|=
name|from
operator|+
name|amount
expr_stmt|;
block|}
if|if
condition|(
name|mpos
operator|>
name|from
operator|&&
name|mpos
operator|<=
name|to
condition|)
name|mpos
operator|+=
name|amount
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|bufpos
operator|!=
name|mpos
condition|)
name|m
operator|->
name|bufpos
operator|=
name|mpos
operator|,
name|m
operator|->
name|modified
operator|++
expr_stmt|;
name|marker
operator|=
name|m
operator|->
name|chain
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* make sure that the gap in the current buffer is at least k    characters wide */
end_comment

begin_macro
name|make_gap
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
if|if
condition|(
name|bf_gap
operator|>=
name|k
condition|)
return|return;
name|k
operator|+=
literal|2000
expr_stmt|;
comment|/* Get more than just enough */
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|bf_p1
operator|+
literal|1
argument_list|,
name|bf_s1
operator|+
name|bf_s2
operator|+
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
literal|0
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|k
operator|-=
name|bf_gap
expr_stmt|;
comment|/* Amount of increase.  */
comment|/* Record new location of text */
name|bf_p1
operator|=
name|p1
operator|-
literal|1
expr_stmt|;
comment|/* Transfer the new free space from the end to the gap      by shifting the second segment upward */
name|p2
operator|=
name|bf_p1
operator|+
literal|1
operator|+
name|bf_s1
operator|+
name|bf_s2
operator|+
name|bf_gap
expr_stmt|;
name|p1
operator|=
name|p2
operator|+
name|k
expr_stmt|;
name|lim
operator|=
name|p2
operator|-
name|bf_s2
expr_stmt|;
while|while
condition|(
name|lim
operator|<
name|p2
condition|)
operator|*
operator|--
name|p1
operator|=
operator|*
operator|--
name|p2
expr_stmt|;
comment|/* Finish updating text location data */
name|bf_gap
operator|+=
name|k
expr_stmt|;
name|bf_p2
operator|=
name|bf_p1
operator|+
name|bf_gap
expr_stmt|;
comment|/* Don't wait for next SetBfp; make it permanent now. */
name|bf_cur
operator|->
name|text
operator|=
name|bf_text
expr_stmt|;
comment|/* adjust markers */
name|adjust_markers
argument_list|(
name|bf_s1
operator|+
literal|1
argument_list|,
name|bf_s1
operator|+
name|bf_s2
operator|+
name|bf_gap
operator|+
literal|1
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Insert the character c before point */
end_comment

begin_macro
name|insert_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|InsCStr
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert the null-terminated string s before point */
end_comment

begin_macro
name|InsStr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|InsCStr
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert a string of specified length before point */
end_comment

begin_expr_stmt
name|InsCStr
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
specifier|register
name|unsigned
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|length
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|length
operator|<
literal|1
condition|)
return|return;
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
name|RecordInsert
argument_list|(
name|point
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bf_modified
operator|++
expr_stmt|;
if|if
condition|(
name|point
operator|!=
name|bf_s1
operator|+
literal|1
condition|)
name|GapTo
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf_gap
operator|<
name|length
condition|)
name|make_gap
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|bf_p1
operator|+
name|point
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bf_gap
operator|-=
name|length
expr_stmt|;
name|bf_p2
operator|-=
name|length
expr_stmt|;
name|bf_s1
operator|+=
name|length
expr_stmt|;
name|point
operator|+=
name|length
expr_stmt|;
block|}
end_block

begin_comment
comment|/* like InsCStr except that all markers pointing at the place where    the insertion happens are adjusted to point after it.  */
end_comment

begin_macro
name|insert_before_markers
argument_list|(
argument|string
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|opoint
init|=
name|point
decl_stmt|;
name|InsCStr
argument_list|(
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|adjust_markers
argument_list|(
name|opoint
operator|-
literal|1
argument_list|,
name|opoint
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Delete characters in current buffer   from `from' up to (but not incl) `to' */
end_comment

begin_expr_stmt
name|del_range
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|int
name|from
operator|,
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|numdel
decl_stmt|;
comment|/* Make args be valid */
if|if
condition|(
name|from
operator|<
name|FirstCharacter
condition|)
name|from
operator|=
name|FirstCharacter
expr_stmt|;
if|if
condition|(
name|to
operator|>
name|NumCharacters
condition|)
name|to
operator|=
name|NumCharacters
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|numdel
operator|=
name|to
operator|-
name|from
operator|)
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|from
operator|<
name|point
condition|)
block|{
if|if
condition|(
name|point
operator|<
name|to
condition|)
name|point
operator|=
name|from
expr_stmt|;
else|else
name|point
operator|-=
name|numdel
expr_stmt|;
block|}
comment|/* Make sure the gap is somewhere in or next to what we are deleting */
if|if
condition|(
name|from
operator|-
literal|1
operator|>
name|bf_s1
condition|)
name|gap_right
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|-
literal|1
operator|<
name|bf_s1
condition|)
name|gap_left
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
name|RecordDelete
argument_list|(
name|from
argument_list|,
name|numdel
argument_list|)
expr_stmt|;
name|bf_modified
operator|++
expr_stmt|;
comment|/* All markers pointing between from and to, inclusive,      should now point at from.  */
name|adjust_markers
argument_list|(
name|to
argument_list|,
name|to
argument_list|,
operator|-
name|numdel
argument_list|)
expr_stmt|;
name|bf_gap
operator|+=
name|numdel
expr_stmt|;
name|bf_p2
operator|+=
name|numdel
expr_stmt|;
name|bf_s2
operator|-=
name|to
operator|-
literal|1
operator|-
name|bf_s1
expr_stmt|;
name|bf_s1
operator|=
name|from
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bf_s1
operator|<
name|beg_unchanged
condition|)
name|beg_unchanged
operator|=
name|bf_s1
expr_stmt|;
if|if
condition|(
name|bf_s2
operator|<
name|end_unchanged
condition|)
name|end_unchanged
operator|=
name|bf_s2
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|modify_region
argument_list|(
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prepare_to_modify_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|start
operator|-
literal|1
operator|<
name|beg_unchanged
operator|||
name|unchanged_modified
operator|==
name|bf_modified
condition|)
name|beg_unchanged
operator|=
name|start
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|end
operator|<
name|end_unchanged
operator|||
name|unchanged_modified
operator|==
name|bf_modified
condition|)
name|end_unchanged
operator|=
name|bf_s1
operator|+
name|bf_s2
operator|+
literal|1
operator|-
name|end
expr_stmt|;
name|bf_modified
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|prepare_to_modify_buffer
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|read_only
argument_list|)
condition|)
name|Fbarf_if_buffer_read_only
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASH_DETECTION
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
operator|&&
name|bf_cur
operator|->
name|save_modified
operator|>=
name|bf_modified
condition|)
name|lock_file
argument_list|(
name|bf_cur
operator|->
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLASH_DETECTION */
block|}
end_block

end_unit

