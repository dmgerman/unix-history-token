begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Manipulation of keymaps    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_comment
comment|/* Actually allocate storage for these variables */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_decl_stmt
name|struct
name|Lisp_Vector
modifier|*
name|MouseMap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keymap for mouse commands */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_X_WINDOWS */
end_comment

begin_decl_stmt
name|struct
name|Lisp_Vector
modifier|*
name|CurrentGlobalMap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current global keymap */
end_comment

begin_decl_stmt
name|struct
name|Lisp_Vector
modifier|*
name|GlobalMap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default global key bindings */
end_comment

begin_decl_stmt
name|struct
name|Lisp_Vector
modifier|*
name|ESCmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The keymap used for globally 					   bound ESC-prefixed default 					   commands */
end_comment

begin_decl_stmt
name|struct
name|Lisp_Vector
modifier|*
name|CtlXmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The keymap used for globally 					   bound C-x-prefixed default 					   commands */
end_comment

begin_comment
comment|/* was MinibufLocalMap */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_local_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The keymap used by the minibuf for local 				   bindings when spaces are allowed in the 				   minibuf */
end_comment

begin_comment
comment|/* was MinibufLocalNSMap */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_local_ns_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The keymap used by the minibuf for local 				   bindings when spaces are not encouraged 				   in the minibuf */
end_comment

begin_comment
comment|/* keymap used for minibuffers when doing completion */
end_comment

begin_comment
comment|/* was MinibufLocalCompletionMap */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_local_completion_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keymap used for minibuffers when doing completion and require a match */
end_comment

begin_comment
comment|/* was MinibufLocalMustMatchMap */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vminibuffer_local_must_match_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qkeymapp
decl_stmt|,
name|Qkeymap
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"make-keymap"
argument_list|,
argument|Fmake_keymap
argument_list|,
argument|Smake_keymap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Construct and return a new keymap, a vector of length 128.\n\ All entries in it are nil, meaning \"command undefined\"."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|val
block|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0200
block|;
return|return
name|Fmake_vector
argument_list|(
name|val
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"make-sparse-keymap"
argument_list|,
argument|Fmake_sparse_keymap
argument_list|,
argument|Smake_sparse_keymap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Construct and return a new sparse-keymap list.\n\ Its car is 'keymap and its cdr is an alist of (CHAR . DEFINITION).\n\ Initially the alist is nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Fcons
argument_list|(
name|Qkeymap
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/* This is used for installing the standard key bindings at initialization time.  For example,  defkey (CtlXmap, Ctl('X'), "exchange-point-and-mark");  */
end_comment

begin_function
name|void
name|defkey
parameter_list|(
name|keymap
parameter_list|,
name|key
parameter_list|,
name|defname
parameter_list|)
name|struct
name|Lisp_Vector
modifier|*
name|keymap
decl_stmt|;
name|int
name|key
decl_stmt|;
name|char
modifier|*
name|defname
decl_stmt|;
block|{
name|keymap
operator|->
name|contents
index|[
name|key
index|]
operator|=
name|intern
argument_list|(
name|defname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ndefkey
parameter_list|(
name|keymap
parameter_list|,
name|key
parameter_list|,
name|defname
parameter_list|)
name|Lisp_Object
name|keymap
decl_stmt|;
name|int
name|key
decl_stmt|;
name|char
modifier|*
name|defname
decl_stmt|;
block|{
name|store_in_keymap
argument_list|(
name|keymap
argument_list|,
name|key
argument_list|,
name|intern
argument_list|(
name|defname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define character fromchar in map frommap as an alias for character tochar in map tomap.  Subsequent redefinitions of the latter WILL affect the former. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_function
name|void
name|synkey
parameter_list|(
name|frommap
parameter_list|,
name|fromchar
parameter_list|,
name|tomap
parameter_list|,
name|tochar
parameter_list|)
name|struct
name|Lisp_Vector
modifier|*
name|frommap
decl_stmt|,
decl|*
name|tomap
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|fromchar
decl_stmt|,
name|tochar
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|v
decl_stmt|,
name|c
decl_stmt|;
name|XSET
argument_list|(
name|v
argument_list|,
name|Lisp_Vector
argument_list|,
name|tomap
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|c
argument_list|)
operator|=
name|tochar
expr_stmt|;
name|frommap
operator|->
name|contents
index|[
name|fromchar
index|]
operator|=
name|Fcons
argument_list|(
name|v
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"keymapp"
argument_list|,
argument|Fkeymapp
argument_list|,
argument|Skeymapp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return t if ARG is a keymap.\n\ A keymap is a vector of length 128, or a list (keymap . ALIST),\n\ where alist elements look like (CHAR . DEFN)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|object
operator|)
name|Lisp_Object
name|object
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|object
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|tem
operator|=
name|XSYMBOL
argument_list|(
name|tem
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qunbound
argument_list|)
condition|)
return|return
name|Qnil
return|;
block|}
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Vector
operator|&&
name|XVECTOR
argument_list|(
name|tem
argument_list|)
operator|->
name|size
operator|==
literal|0200
operator|)
operator|||
operator|(
name|LISTP
argument_list|(
name|tem
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|get_keymap
parameter_list|(
name|object
parameter_list|,
name|argnumber
parameter_list|)
name|Lisp_Object
name|object
decl_stmt|;
name|int
name|argnumber
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tem
operator|=
name|object
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|tem
operator|=
name|XSYMBOL
argument_list|(
name|tem
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Vector
operator|&&
name|XVECTOR
argument_list|(
name|tem
argument_list|)
operator|->
name|size
operator|==
literal|0200
operator|)
operator|||
operator|(
name|LISTP
argument_list|(
name|tem
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|argnumber
operator|>=
literal|0
condition|)
name|object
operator|=
name|wrong_type_argument
argument_list|(
name|Qkeymapp
argument_list|,
name|object
argument_list|)
expr_stmt|;
else|else
return|return
name|Qnil
return|;
block|}
block|}
end_function

begin_function
name|Lisp_Object
name|get_keyelt
parameter_list|(
name|object
parameter_list|)
name|Lisp_Object
name|object
decl_stmt|;
block|{
name|Lisp_Object
name|map
decl_stmt|,
name|tem
decl_stmt|;
while|while
condition|(
name|map
operator|=
name|get_keymap
argument_list|(
name|Fcar_safe
argument_list|(
name|object
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
operator|,
name|tem
operator|=
name|Fkeymapp
argument_list|(
name|map
argument_list|)
operator|,
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
comment|/*(XTYPE (object) == Lisp_Cons&& !EQ (XCONS (object)->car, Qkeymap))*/
block|{
name|object
operator|=
name|Fcdr
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|LISTP
argument_list|(
name|map
argument_list|)
condition|)
name|object
operator|=
name|Fcdr
argument_list|(
name|Fassq
argument_list|(
name|object
argument_list|,
name|Fcdr
argument_list|(
name|map
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|object
operator|=
name|Faref
argument_list|(
name|map
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
return|return
name|object
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|access_keymap
parameter_list|(
name|map
parameter_list|,
name|idx
parameter_list|)
name|Lisp_Object
name|map
decl_stmt|;
specifier|register
name|int
name|idx
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
literal|0200
condition|)
name|error
argument_list|(
literal|"Command key out of range 0-127"
argument_list|)
expr_stmt|;
comment|/* Get definition for character `idx' proper.  */
if|if
condition|(
name|LISTP
argument_list|(
name|map
argument_list|)
condition|)
name|val
operator|=
name|Fcdr
argument_list|(
name|Fassq
argument_list|(
name|make_number
argument_list|(
name|idx
argument_list|)
argument_list|,
name|Fcdr
argument_list|(
name|map
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|XVECTOR
argument_list|(
name|map
argument_list|)
operator|->
name|contents
index|[
name|idx
index|]
expr_stmt|;
comment|/* If nothing there, and `idx' is upper case,      look under corresponding lower case character.  */
if|if
condition|(
name|NULL
argument_list|(
name|val
argument_list|)
operator|&&
name|idx
operator|>=
literal|'A'
operator|&&
name|idx
operator|<=
literal|'Z'
condition|)
block|{
if|if
condition|(
name|LISTP
argument_list|(
name|map
argument_list|)
condition|)
name|val
operator|=
name|Fcdr
argument_list|(
name|Fassq
argument_list|(
name|make_number
argument_list|(
name|idx
operator|+
literal|'a'
operator|-
literal|'A'
argument_list|)
argument_list|,
name|Fcdr
argument_list|(
name|map
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|XVECTOR
argument_list|(
name|map
argument_list|)
operator|->
name|contents
index|[
name|idx
operator|+
literal|'a'
operator|-
literal|'A'
index|]
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|store_in_keymap
parameter_list|(
name|keymap
parameter_list|,
name|idx
parameter_list|,
name|def
parameter_list|)
name|Lisp_Object
name|keymap
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|Lisp_Object
name|def
decl_stmt|;
block|{
name|Lisp_Object
name|tem
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
literal|0200
condition|)
name|error
argument_list|(
literal|"Command key out of range 0-127"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LISTP
argument_list|(
name|keymap
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fassq
argument_list|(
name|make_number
argument_list|(
name|idx
argument_list|)
argument_list|,
name|Fcdr
argument_list|(
name|keymap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|Fsetcdr
argument_list|(
name|tem
argument_list|,
name|def
argument_list|)
expr_stmt|;
else|else
name|Fsetcdr
argument_list|(
name|keymap
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|idx
argument_list|)
argument_list|,
name|def
argument_list|)
argument_list|,
name|Fcdr
argument_list|(
name|keymap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|XVECTOR
argument_list|(
name|keymap
argument_list|)
operator|->
name|contents
index|[
name|idx
index|]
operator|=
name|def
expr_stmt|;
return|return
name|def
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"define-key"
argument_list|,
argument|Fdefine_key
argument_list|,
argument|Sdefine_key
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Args KEYMAP, KEYS, DEF.  Define key sequence KEYS, in KEYMAP, as DEF.\n\ KEYMAP is a keymap.  KEYS is a string meaning a sequence of keystrokes.\n\ DEF is usually a symbol with a function definition, suitable for use as a command."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keymap
operator|,
name|keys
operator|,
name|def
operator|)
name|Lisp_Object
name|keymap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|keys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|level
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|cmd
decl_stmt|;
name|keymap
operator|=
name|get_keymap
argument_list|(
name|keymap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|keys
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|keys
argument_list|)
operator|->
name|data
expr_stmt|;
name|level
operator|=
name|XSTRING
argument_list|(
name|keys
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|level
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|level
condition|)
return|return
name|store_in_keymap
argument_list|(
name|keymap
argument_list|,
operator|*
name|p
argument_list|,
name|def
argument_list|)
return|;
name|cmd
operator|=
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|keymap
argument_list|,
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|Fmake_sparse_keymap
argument_list|()
expr_stmt|;
name|store_in_keymap
argument_list|(
name|keymap
argument_list|,
operator|*
name|p
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|Fkeymapp
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|error
argument_list|(
literal|"Key sequence %s uses invalid prefix characters"
argument_list|,
name|XSTRING
argument_list|(
name|keys
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|keymap
operator|=
name|get_keymap
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Value is T if `keys' is too long; NIL if valid but has no definition. */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"lookup-key"
argument_list|,
argument|Flookup_key
argument_list|,
argument|Slookup_key
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"In keymap KEYMAP, look up key sequence KEYS.  Return the definition.\n\ nil means undefined.\n\ Number as value means KEYS is \"too long\";\n\ that is, characters in it except for the last one\n\ fail to be a valid sequence of prefix characters in KEYMAP.\n\ The number is how many characters at the front of KEYS\n\ it takes to reach a non-prefix command."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keymap
operator|,
name|keys
operator|)
name|Lisp_Object
name|keymap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|keys
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|level
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|cmd
decl_stmt|;
name|keymap
operator|=
name|get_keymap
argument_list|(
name|keymap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|keys
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|keys
argument_list|)
operator|->
name|data
expr_stmt|;
name|level
operator|=
name|XSTRING
argument_list|(
name|keys
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|level
operator|--
expr_stmt|;
name|cmd
operator|=
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|keymap
argument_list|,
operator|*
name|p
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|level
condition|)
return|return
name|cmd
return|;
name|tem
operator|=
name|Fkeymapp
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|make_number
argument_list|(
name|XSTRING
argument_list|(
name|keys
argument_list|)
operator|->
name|size
operator|-
name|level
argument_list|)
return|;
name|keymap
operator|=
name|get_keymap
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"key-binding"
argument_list|,
argument|Fkey_binding
argument_list|,
argument|Skey_binding
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the definition for command KEYS in current keymaps.\n\ KEYS is a string, a sequence of keystrokes.\n\ The definition is probably a symbol with a function definition."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|)
name|Lisp_Object
name|keys
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|map
decl_stmt|,
name|value
decl_stmt|,
name|value1
decl_stmt|;
name|map
operator|=
name|bf_cur
operator|->
name|keymap
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|value
operator|=
name|Flookup_key
argument_list|(
name|map
argument_list|,
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|XSET
argument_list|(
name|map
argument_list|,
name|Lisp_Vector
argument_list|,
name|CurrentGlobalMap
argument_list|)
expr_stmt|;
name|value1
operator|=
name|Flookup_key
argument_list|(
name|map
argument_list|,
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|value1
argument_list|)
operator|==
name|Lisp_Int
condition|)
return|return
name|Qnil
return|;
return|return
name|value1
return|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|value
argument_list|)
operator|!=
name|Lisp_Int
condition|)
return|return
name|value
return|;
block|}
name|XSET
argument_list|(
name|map
argument_list|,
name|Lisp_Vector
argument_list|,
name|CurrentGlobalMap
argument_list|)
expr_stmt|;
return|return
name|Flookup_key
argument_list|(
name|map
argument_list|,
name|keys
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"local-key-binding"
argument_list|,
argument|Flocal_key_binding
argument_list|,
argument|Slocal_key_binding
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the definition for command KEYS in current local keymap only.\n\ KEYS is a string, a sequence of keystrokes.\n\ The definition is probably a symbol with a function definition."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|)
name|Lisp_Object
name|keys
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|map
decl_stmt|;
name|map
operator|=
name|bf_cur
operator|->
name|keymap
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|map
argument_list|)
condition|)
return|return
name|Qnil
return|;
return|return
name|Flookup_key
argument_list|(
name|map
argument_list|,
name|keys
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"global-key-binding"
argument_list|,
argument|Fglobal_key_binding
argument_list|,
argument|Sglobal_key_binding
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the definition for command KEYS in current global keymap only.\n\ KEYS is a string, a sequence of keystrokes.\n\ The definition is probably a symbol with a function definition."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|)
name|Lisp_Object
name|keys
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|map
decl_stmt|;
name|XSET
argument_list|(
name|map
argument_list|,
name|Lisp_Vector
argument_list|,
name|CurrentGlobalMap
argument_list|)
expr_stmt|;
return|return
name|Flookup_key
argument_list|(
name|map
argument_list|,
name|keys
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"global-set-key"
argument_list|,
argument|Fglobal_set_key
argument_list|,
argument|Sglobal_set_key
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"kSet key globally: \nCSet key %s to command: "
argument_list|,
literal|"Give KEY a definition of COMMAND.\n\ COMMAND is a symbol naming an interactively-callable function.\n\ KEY is a string representing a sequence of keystrokes.\n\ Note that if KEY has a local definition in the current buffer\n\ that local definition will continue to shadow any global definition."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|,
name|function
operator|)
name|Lisp_Object
name|keys
operator|,
name|function
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|map
decl_stmt|;
name|XSET
argument_list|(
name|map
argument_list|,
name|Lisp_Vector
argument_list|,
name|CurrentGlobalMap
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|keys
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fdefine_key
argument_list|(
name|map
argument_list|,
name|keys
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"local-set-key"
argument_list|,
argument|Flocal_set_key
argument_list|,
argument|Slocal_set_key
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"kSet key locally: \nCSet key %s locally to command: "
argument_list|,
literal|"Give KEY a local definition of COMMAND.\n\ COMMAND is a symbol naming an interactively-callable function.\n\ KEY is a string representing a sequence of keystrokes.\n\ The definition goes in the current buffer's local map,\n\ which is shared with other buffers in the same major mode."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|,
name|function
operator|)
name|Lisp_Object
name|keys
operator|,
name|function
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|map
decl_stmt|;
name|map
operator|=
name|bf_cur
operator|->
name|keymap
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|map
argument_list|)
condition|)
block|{
name|map
operator|=
name|Fmake_sparse_keymap
argument_list|()
expr_stmt|;
name|bf_cur
operator|->
name|keymap
operator|=
name|map
expr_stmt|;
block|}
name|CHECK_STRING
argument_list|(
name|keys
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Fdefine_key
argument_list|(
name|map
argument_list|,
name|keys
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"global-unset-key"
argument_list|,
argument|Fglobal_unset_key
argument_list|,
argument|Sglobal_unset_key
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"kUnset key globally: "
argument_list|,
literal|"Remove global definition of KEY.\n\ KEY is a string representing a sequence of keystrokes."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|)
name|Lisp_Object
name|keys
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fglobal_set_key
argument_list|(
name|keys
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"local-unset-key"
argument_list|,
argument|Flocal_unset_key
argument_list|,
argument|Slocal_unset_key
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"kUnset key locally: "
argument_list|,
literal|"Remove local definition of KEY.\n\ KEY is a string representing a sequence of keystrokes."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|)
name|Lisp_Object
name|keys
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|bf_cur
operator|->
name|keymap
argument_list|)
condition|)
name|Flocal_set_key
argument_list|(
name|keys
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"define-prefix-command"
argument_list|,
argument|Fdefine_prefix_command
argument_list|,
argument|Sdefine_prefix_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Define SYMBOL as a prefix command.\n\ A keymap is created and stored as SYMBOL's function definition."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|name
operator|)
name|Lisp_Object
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Fset
argument_list|(
name|name
argument_list|,
name|Fmake_keymap
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"use-global-map"
argument_list|,
argument|Fuse_global_map
argument_list|,
argument|Suse_global_map
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Selects KEYMAP as the global keymap."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keymap
operator|)
name|Lisp_Object
name|keymap
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|keymap
operator|=
name|get_keymap
argument_list|(
name|keymap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_VECTOR
argument_list|(
name|keymap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CurrentGlobalMap
operator|=
name|XVECTOR
argument_list|(
name|keymap
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"use-local-map"
argument_list|,
argument|Fuse_local_map
argument_list|,
argument|Suse_local_map
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Selects KEYMAP as the local keymap.\n\ nil for KEYMAP means no local keymap."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keymap
operator|)
name|Lisp_Object
name|keymap
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|keymap
argument_list|)
condition|)
name|keymap
operator|=
name|get_keymap
argument_list|(
name|keymap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bf_cur
operator|->
name|keymap
operator|=
name|keymap
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"current-local-map"
argument_list|,
argument|Fcurrent_local_map
argument_list|,
argument|Scurrent_local_map
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return current buffer's local keymap, or nil if it has none."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|bf_cur
operator|->
name|keymap
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"accessible-keymaps"
argument_list|,
argument|Faccessible_keymaps
argument_list|,
argument|Saccessible_keymaps
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Find all keymaps accessible via prefix characters from KEYMAP.\n\ Returns a list of elements of the form (KEYS . MAP), where the sequence\n\ KEYS starting from KEYMAP gets you to MAP.  These elements are ordered\n\ so that the KEYS increase in length.  The first element is (\"\" . KEYMAP)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|startmap
operator|)
name|Lisp_Object
name|startmap
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|maps
decl_stmt|,
name|tail
decl_stmt|;
name|Lisp_Object
name|thismap
decl_stmt|,
name|thisseq
decl_stmt|;
name|Lisp_Object
name|dummy
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|maps
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|build_string
argument_list|(
literal|""
argument_list|)
argument_list|,
name|get_keymap
argument_list|(
name|startmap
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|tail
operator|=
name|maps
expr_stmt|;
comment|/* For each map in the list maps,      look at any other maps it points to      and stick them at the end if they are not already in the list */
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|tail
argument_list|)
condition|)
block|{
name|thisseq
operator|=
name|Fcar
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|thismap
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0200
condition|;
name|i
operator|++
control|)
block|{
name|cmd
operator|=
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|thismap
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|cmd
argument_list|)
condition|)
continue|continue;
name|tem
operator|=
name|Fkeymapp
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|get_keymap
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Frassq
argument_list|(
name|cmd
argument_list|,
name|maps
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|XFASTINT
argument_list|(
name|dummy
argument_list|)
operator|=
name|i
expr_stmt|;
name|dummy
operator|=
name|concat2
argument_list|(
name|thisseq
argument_list|,
name|Fchar_to_string
argument_list|(
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
name|nconc2
argument_list|(
name|tail
argument_list|,
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|dummy
argument_list|,
name|cmd
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
return|return
name|maps
return|;
block|}
end_block

begin_decl_stmt
name|Lisp_Object
name|Qsingle_key_description
decl_stmt|,
name|Qkey_description
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"key-description"
argument_list|,
argument|Fkey_description
argument_list|,
argument|Skey_description
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a pretty description of key-sequence KEYS.\n\ Control characters turn into \"C-foo\" sequences, meta into \"M-foo\"\n\ spaces are put between sequence elements, etc."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|keys
operator|)
name|Lisp_Object
name|keys
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|Fmapconcat
argument_list|(
name|Qsingle_key_description
argument_list|,
name|keys
argument_list|,
name|build_string
argument_list|(
literal|" "
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|push_key_description
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|)
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>=
literal|0200
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|-=
literal|0200
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|040
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|033
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'C'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|Ctl
argument_list|(
literal|'I'
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'A'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'B'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|Ctl
argument_list|(
literal|'J'
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'F'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'D'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|Ctl
argument_list|(
literal|'M'
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'R'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'T'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'C'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<=
name|Ctl
argument_list|(
literal|'Z'
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
name|c
operator|+
literal|0140
expr_stmt|;
else|else
operator|*
name|p
operator|++
operator|=
name|c
operator|+
literal|0100
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'P'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'C'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"single-key-description"
argument_list|,
argument|Fsingle_key_description
argument_list|,
argument|Ssingle_key_description
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a pretty description of command character KEY.\n\ Control characters turn into C-whatever, etc."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|key
operator|)
name|Lisp_Object
name|key
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|char
name|tem
index|[
literal|6
index|]
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|XINT
argument_list|(
name|key
argument_list|)
operator|&
literal|0377
expr_stmt|;
operator|*
name|push_key_description
argument_list|(
name|c
argument_list|,
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|build_string
argument_list|(
name|tem
argument_list|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|push_text_char_description
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|)
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>=
literal|0200
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|-=
literal|0200
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|040
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|+
literal|64
expr_stmt|;
comment|/* 'A' - 1 */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"text-char-description"
argument_list|,
argument|Ftext_char_description
argument_list|,
argument|Stext_char_description
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a pretty description of file-character CHAR.\n\ Control characters turn into \"C-char\", etc."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|chr
operator|)
name|Lisp_Object
name|chr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|tem
index|[
literal|6
index|]
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|chr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|push_text_char_description
argument_list|(
name|XINT
argument_list|(
name|chr
argument_list|)
operator|&
literal|0377
argument_list|,
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|build_string
argument_list|(
name|tem
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
name|Lisp_Object
name|where_is_in_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"where-is-internal"
argument_list|,
argument|Fwhere_is_internal
argument_list|,
argument|Swhere_is_internal
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return list of key sequences that currently invoke command DEFINITION."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|definition
operator|)
name|Lisp_Object
name|definition
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|where_is_in_buffer
argument_list|(
name|definition
argument_list|,
name|bf_cur
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|where_is_in_buffer
parameter_list|(
name|definition
parameter_list|,
name|buf
parameter_list|,
name|firstonly
parameter_list|)
name|Lisp_Object
name|definition
decl_stmt|;
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|firstonly
decl_stmt|;
comment|/* if true, return after finding one */
block|{
name|Lisp_Object
name|start1
decl_stmt|,
name|start2
decl_stmt|;
name|Lisp_Object
name|maps
decl_stmt|;
name|Lisp_Object
name|this
decl_stmt|,
name|map
decl_stmt|;
name|Lisp_Object
name|dummy
decl_stmt|;
name|Lisp_Object
name|found
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|XSET
argument_list|(
name|start1
argument_list|,
name|Lisp_Vector
argument_list|,
name|CurrentGlobalMap
argument_list|)
expr_stmt|;
name|start2
operator|=
name|buf
operator|->
name|keymap
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|start2
argument_list|)
condition|)
name|maps
operator|=
name|nconc2
argument_list|(
name|Faccessible_keymaps
argument_list|(
name|start2
argument_list|)
argument_list|,
name|Faccessible_keymaps
argument_list|(
name|start1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|maps
operator|=
name|Faccessible_keymaps
argument_list|(
name|start1
argument_list|)
expr_stmt|;
name|found
operator|=
name|Qnil
expr_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|maps
argument_list|)
condition|;
name|maps
operator|=
name|Fcdr
argument_list|(
name|maps
argument_list|)
control|)
block|{
name|this
operator|=
name|Fcar
argument_list|(
name|Fcar
argument_list|(
name|maps
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Key sequence to reach map */
name|map
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|maps
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The map that it reaches */
if|if
condition|(
name|LISTP
argument_list|(
name|map
argument_list|)
condition|)
for|for
control|(
name|map
operator|=
name|Fcdr
argument_list|(
name|map
argument_list|)
init|;
operator|!
name|NULL
argument_list|(
name|map
argument_list|)
condition|;
name|map
operator|=
name|Fcdr
argument_list|(
name|map
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|definition
argument_list|)
condition|)
block|{
name|dummy
operator|=
name|Fcar
argument_list|(
name|Fcar
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|concat2
argument_list|(
name|this
argument_list|,
name|Fchar_to_string
argument_list|(
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstonly
condition|)
return|return
name|dummy
return|;
name|found
operator|=
name|Fcons
argument_list|(
name|dummy
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0200
condition|;
name|i
operator|++
control|)
comment|/* Search that map for a match */
block|{
name|QUIT
expr_stmt|;
name|tem
operator|=
name|XVECTOR
argument_list|(
name|map
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|definition
argument_list|)
condition|)
comment|/* Match found: record key sequence */
block|{
name|XFASTINT
argument_list|(
name|dummy
argument_list|)
operator|=
name|i
expr_stmt|;
comment|/* which is `this' followed by character i */
name|dummy
operator|=
name|concat2
argument_list|(
name|this
argument_list|,
name|Fchar_to_string
argument_list|(
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstonly
condition|)
return|return
name|dummy
return|;
name|found
operator|=
name|Fcons
argument_list|(
name|dummy
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|Fnreverse
argument_list|(
name|found
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"where-is"
argument_list|,
argument|Fwhere_is
argument_list|,
argument|Swhere_is
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"CWhere is command: "
argument_list|,
literal|"Print message listing key sequences that invoke specified command.\n\ Argument is a command definition, usually a symbol with a function definition."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|definition
operator|)
name|Lisp_Object
name|definition
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|definition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmapconcat
argument_list|(
name|Qkey_description
argument_list|,
name|Fwhere_is_internal
argument_list|(
name|definition
argument_list|)
argument_list|,
name|build_string
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
condition|)
name|message
argument_list|(
literal|"%s is on %s"
argument_list|,
name|XSYMBOL
argument_list|(
name|definition
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"%s is not on any keys"
argument_list|,
name|XSYMBOL
argument_list|(
name|definition
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
name|Lisp_Object
name|describe_buffer_bindings
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"describe-bindings"
argument_list|,
argument|Fdescribe_bindings
argument_list|,
argument|Sdescribe_bindings
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Show a list of all defined keys, and their definitions.\n\ The list is put in a buffer, which is displayed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|thisbuf
block|;
name|XSETTYPE
argument_list|(
name|thisbuf
argument_list|,
name|Lisp_Buffer
argument_list|)
block|,
name|XSETBUFFER
argument_list|(
name|thisbuf
argument_list|,
name|bf_cur
argument_list|)
block|;
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Help*"
argument_list|,
name|describe_buffer_bindings
argument_list|,
name|thisbuf
argument_list|)
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_function
name|Lisp_Object
name|describe_buffer_bindings
parameter_list|(
name|descbuf
parameter_list|)
name|Lisp_Object
name|descbuf
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|start1
decl_stmt|;
name|char
modifier|*
name|heading
init|=
literal|"key		binding\n---		-------\n"
decl_stmt|;
name|Fset_buffer
argument_list|(
name|Vstandard_output
argument_list|)
expr_stmt|;
name|start1
operator|=
name|XBUFFER
argument_list|(
name|descbuf
argument_list|)
operator|->
name|keymap
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|start1
argument_list|)
condition|)
block|{
name|InsStr
argument_list|(
literal|"Local Bindings:\n"
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
name|heading
argument_list|)
expr_stmt|;
name|heading
operator|=
literal|0
expr_stmt|;
name|describe_map_tree
argument_list|(
name|start1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|InsStr
argument_list|(
literal|"Global Bindings:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|heading
condition|)
name|InsStr
argument_list|(
name|heading
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|start1
argument_list|,
name|Lisp_Vector
argument_list|,
name|CurrentGlobalMap
argument_list|)
expr_stmt|;
name|describe_map_tree
argument_list|(
name|start1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Fset_buffer
argument_list|(
name|descbuf
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_comment
comment|/* Insert a desription of the key bindings in STARTMAP,    followed by those of all maps reachable through STARTMAP.    If PARTIAL is nonzero, omit certain "uninteresting" commands    (such as `undefined').  */
end_comment

begin_macro
name|describe_map_tree
argument_list|(
argument|startmap
argument_list|,
argument|partial
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|startmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|maps
decl_stmt|,
name|elt
decl_stmt|;
name|maps
operator|=
name|Faccessible_keymaps
argument_list|(
name|startmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|!
name|NULL
argument_list|(
name|maps
argument_list|)
condition|;
name|maps
operator|=
name|Fcdr
argument_list|(
name|maps
argument_list|)
control|)
block|{
name|elt
operator|=
name|Fcar
argument_list|(
name|maps
argument_list|)
expr_stmt|;
name|describe_map
argument_list|(
name|Fcdr
argument_list|(
name|elt
argument_list|)
argument_list|,
name|Fcar
argument_list|(
name|elt
argument_list|)
argument_list|,
name|partial
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|describe_command
argument_list|(
argument|definition
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|definition
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem1
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|definition
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|XSETSTRING
argument_list|(
name|tem1
argument_list|,
name|XSYMBOL
argument_list|(
name|definition
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|tem1
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem1
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem1
operator|=
name|Fkeymapp
argument_list|(
name|definition
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem1
argument_list|)
condition|)
name|InsStr
argument_list|(
literal|"Prefix Command"
argument_list|)
expr_stmt|;
else|else
name|InsStr
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Describe the contents of map MAP, assuming that this map    itself is reached by the sequence of prefix keys KEYS (a string).    PARTIAL is the same as in `describe_map_tree', above.  */
end_comment

begin_macro
name|describe_map
argument_list|(
argument|map
argument_list|,
argument|keys
argument_list|,
argument|partial
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|map
decl_stmt|,
name|keys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|keysdesc
decl_stmt|;
name|InsStr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|keys
argument_list|)
operator|&&
name|XSTRING
argument_list|(
name|keys
argument_list|)
operator|->
name|size
operator|>
literal|0
condition|)
name|keysdesc
operator|=
name|Fkey_description
argument_list|(
name|keys
argument_list|)
expr_stmt|;
else|else
name|keysdesc
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|LISTP
argument_list|(
name|map
argument_list|)
condition|)
name|describe_alist
argument_list|(
name|Fcdr
argument_list|(
name|map
argument_list|)
argument_list|,
name|keysdesc
argument_list|,
name|describe_command
argument_list|,
name|partial
argument_list|)
expr_stmt|;
else|else
name|describe_vector
argument_list|(
name|map
argument_list|,
name|keysdesc
argument_list|,
name|describe_command
argument_list|,
name|partial
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|describe_alist
argument_list|(
name|alist
argument_list|,
name|elt_prefix
argument_list|,
name|elt_describer
argument_list|,
name|partial
argument_list|)
specifier|register
name|Lisp_Object
name|alist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|elt_prefix
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|elt_describer
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|this
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem1
decl_stmt|,
name|tem2
decl_stmt|;
name|int
name|indent
decl_stmt|;
name|Lisp_Object
name|suppress
decl_stmt|;
if|if
condition|(
name|partial
condition|)
name|suppress
operator|=
name|intern
argument_list|(
literal|"suppress-keymap"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|LISTP
argument_list|(
name|alist
argument_list|)
condition|;
name|alist
operator|=
name|Fcdr
argument_list|(
name|alist
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
name|tem1
operator|=
name|Fcar
argument_list|(
name|Fcar
argument_list|(
name|alist
argument_list|)
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|Fcdr
argument_list|(
name|Fcar
argument_list|(
name|alist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem2
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
name|partial
condition|)
block|{
name|this
operator|=
name|Fget
argument_list|(
name|tem2
argument_list|,
name|suppress
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|this
argument_list|)
condition|)
continue|continue;
block|}
name|indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|elt_prefix
argument_list|)
condition|)
block|{
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indent
operator|+=
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|size
operator|+
literal|1
expr_stmt|;
block|}
name|this
operator|=
name|Fsingle_key_description
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|indent
operator|+=
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|size
expr_stmt|;
name|InsCStr
argument_list|(
literal|"                    "
argument_list|,
name|indent
operator|<
literal|16
condition|?
literal|16
operator|-
name|indent
else|:
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|elt_describer
call|)
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|describe_vector
argument_list|(
name|vector
argument_list|,
name|elt_prefix
argument_list|,
name|elt_describer
argument_list|,
name|partial
argument_list|)
specifier|register
name|Lisp_Object
name|vector
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
name|elt_prefix
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|elt_describer
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|partial
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|this
decl_stmt|;
name|Lisp_Object
name|dummy
decl_stmt|;
name|Lisp_Object
name|tem1
decl_stmt|,
name|tem2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|size
init|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|size
decl_stmt|;
name|int
name|indent
decl_stmt|;
name|Lisp_Object
name|suppress
decl_stmt|;
if|if
condition|(
name|partial
condition|)
name|suppress
operator|=
name|intern
argument_list|(
literal|"suppress-keymap"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|tem1
operator|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem1
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem1
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
name|partial
condition|)
block|{
name|this
operator|=
name|Fget
argument_list|(
name|tem1
argument_list|,
name|suppress
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|this
argument_list|)
condition|)
continue|continue;
block|}
name|indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|elt_prefix
argument_list|)
condition|)
block|{
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indent
operator|+=
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|size
operator|+
literal|1
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|dummy
argument_list|)
operator|=
name|i
expr_stmt|;
name|this
operator|=
name|Fsingle_key_description
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|indent
operator|+=
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|size
operator|&&
operator|(
name|tem2
operator|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|EQ
argument_list|(
name|tem2
argument_list|,
name|tem1
argument_list|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|XINT
argument_list|(
name|dummy
argument_list|)
condition|)
block|{
name|InsCStr
argument_list|(
literal|" .. "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|elt_prefix
argument_list|)
condition|)
block|{
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indent
operator|+=
name|XSTRING
argument_list|(
name|elt_prefix
argument_list|)
operator|->
name|size
operator|+
literal|1
expr_stmt|;
block|}
name|XFASTINT
argument_list|(
name|dummy
argument_list|)
operator|=
name|i
expr_stmt|;
name|this
operator|=
name|Fsingle_key_description
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|indent
operator|+=
name|XSTRING
argument_list|(
name|this
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
name|InsCStr
argument_list|(
literal|"                    "
argument_list|,
name|indent
operator|<
literal|16
condition|?
literal|16
operator|-
name|indent
else|:
literal|1
argument_list|)
expr_stmt|;
name|tem1
operator|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
call|(
modifier|*
name|elt_describer
call|)
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Apropos */
end_comment

begin_decl_stmt
name|Lisp_Object
name|apropos_predicate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|apropos_accumulate
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|apropos_accum
argument_list|(
argument|symbol
argument_list|,
argument|string
argument_list|)
name|Lisp_Object
name|symbol
operator|,
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fstring_match
argument_list|(
name|string
argument_list|,
name|Fsymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|apropos_predicate
argument_list|)
condition|)
name|tem
operator|=
name|call1
argument_list|(
name|apropos_predicate
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|apropos_accumulate
operator|=
name|Fcons
argument_list|(
name|symbol
argument_list|,
name|apropos_accumulate
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|Lisp_Object
name|apropos1
parameter_list|(
name|list
parameter_list|)
specifier|register
name|Lisp_Object
name|list
decl_stmt|;
block|{
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
specifier|register
name|Lisp_Object
name|symbol
decl_stmt|,
name|col
decl_stmt|,
name|tem
decl_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|symbol
operator|=
name|Fcar
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|tem
operator|=
name|where_is_in_buffer
argument_list|(
name|symbol
argument_list|,
name|bf_cur
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmapconcat
argument_list|(
name|Qkey_description
argument_list|,
name|tem
argument_list|,
name|build_string
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|col
argument_list|)
operator|=
literal|30
expr_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|Vstandard_output
argument_list|)
argument_list|)
expr_stmt|;
name|Fprin1
argument_list|(
name|symbol
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Findent_to
argument_list|(
name|col
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Fprinc
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Fterpri
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Ffboundp
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|Fdocumentation
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|insert_first_line
argument_list|(
literal|"  Function: "
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fget
argument_list|(
name|symbol
argument_list|,
name|Qvariable_documentation
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|insert_first_line
argument_list|(
literal|"  Variable: "
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|insert_first_line
argument_list|(
argument|prefix
argument_list|,
argument|str
argument_list|)
name|char
operator|*
name|prefix
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p2
decl_stmt|;
name|InsStr
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|retry
label|:
name|p
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
expr_stmt|;
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|p2
operator|=
name|p
init|;
operator|*
name|p2
operator|&&
name|p2
operator|!=
name|p1
condition|;
name|p2
operator|++
control|)
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p2
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
name|str
operator|=
name|Fsubstitute_command_keys
argument_list|(
name|str
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|InsCStr
argument_list|(
name|p
argument_list|,
name|p1
condition|?
name|p1
operator|-
name|p
else|:
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"apropos"
argument_list|,
argument|Fapropos
argument_list|,
argument|Sapropos
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|"sApropos: "
argument_list|,
literal|"Show all symbols whose names contain match for REGEXP.\n\ If optional arg PRED is non-nil, (funcall PRED SYM) is done\n\ for each symbol and a symbol is mentioned if that returns non-nil.\n\ Returns list of symbols found; if third arg NOPRINT is non-nil,\n\ does not display them, just returns the list."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|pred
operator|,
name|noprint
operator|)
name|Lisp_Object
name|string
operator|,
name|pred
operator|,
name|noprint
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|gcpro
name|gcpro1
decl_stmt|,
name|gcpro2
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|apropos_predicate
operator|=
name|pred
expr_stmt|;
name|GCPRO2
argument_list|(
name|apropos_predicate
argument_list|,
name|apropos_accumulate
argument_list|)
expr_stmt|;
name|apropos_accumulate
operator|=
name|Qnil
expr_stmt|;
name|map_obarray
argument_list|(
name|Vobarray
argument_list|,
name|apropos_accum
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|apropos_accumulate
operator|=
name|Fsort
argument_list|(
name|apropos_accumulate
argument_list|,
name|Qstring_lessp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|noprint
argument_list|)
condition|)
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Help*"
argument_list|,
name|apropos1
argument_list|,
name|apropos_accumulate
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|apropos_accumulate
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"execute-extended-command"
argument_list|,
argument|Fexecute_extended_command
argument_list|,
argument|Sexecute_extended_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Read function name, then read its arguments and call it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prefixarg
operator|)
name|Lisp_Object
name|prefixarg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|function
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|prefixarg
argument_list|,
name|Qminus
argument_list|)
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"- "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LISTP
argument_list|(
name|prefixarg
argument_list|)
operator|&&
name|XINT
argument_list|(
name|XCONS
argument_list|(
name|prefixarg
argument_list|)
operator|->
name|car
argument_list|)
operator|==
literal|4
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"C-u "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LISTP
argument_list|(
name|prefixarg
argument_list|)
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|prefixarg
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|XINT
argument_list|(
name|XCONS
argument_list|(
name|prefixarg
argument_list|)
operator|->
name|car
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|prefixarg
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|XINT
argument_list|(
name|prefixarg
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"M-x "
argument_list|)
expr_stmt|;
name|function
operator|=
name|Fcompleting_read
argument_list|(
name|build_string
argument_list|(
name|buf
argument_list|)
argument_list|,
name|Vobarray
argument_list|,
name|Qcommandp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|Vprefix_arg
operator|=
name|prefixarg
expr_stmt|;
return|return
name|Fcommand_execute
argument_list|(
name|Fintern
argument_list|(
name|function
argument_list|,
name|Vobarray
argument_list|)
argument_list|,
name|Qt
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_keymap
argument_list|()
end_macro

begin_block
block|{
name|Lisp_Object
name|tem
decl_stmt|;
name|Qkeymap
operator|=
name|intern
argument_list|(
literal|"keymap"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qkeymap
argument_list|)
expr_stmt|;
comment|/* Initialize the keymaps standardly used.    Each one is the value of a Lisp variable, and is also    pointed to by a C variable */
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
name|tem
operator|=
name|Fmake_keymap
argument_list|()
expr_stmt|;
name|MouseMap
operator|=
name|XVECTOR
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fset
argument_list|(
name|intern
argument_list|(
literal|"mouse-map"
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_X_WINDOWS */
name|tem
operator|=
name|Fmake_keymap
argument_list|()
expr_stmt|;
name|GlobalMap
operator|=
name|XVECTOR
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fset
argument_list|(
name|intern
argument_list|(
literal|"global-map"
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmake_keymap
argument_list|()
expr_stmt|;
name|ESCmap
operator|=
name|XVECTOR
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fset
argument_list|(
name|intern
argument_list|(
literal|"esc-map"
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|Ffset
argument_list|(
name|intern
argument_list|(
literal|"ESC-prefix"
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fmake_keymap
argument_list|()
expr_stmt|;
name|CtlXmap
operator|=
name|XVECTOR
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|Fset
argument_list|(
name|intern
argument_list|(
literal|"ctl-x-map"
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|Ffset
argument_list|(
name|intern
argument_list|(
literal|"Control-X-prefix"
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"minibuffer-local-map"
argument_list|,
operator|&
name|Vminibuffer_local_map
argument_list|,
literal|"Default keymap to use when reading from the minibuffer."
argument_list|)
expr_stmt|;
name|Vminibuffer_local_map
operator|=
name|Fmake_sparse_keymap
argument_list|()
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"minibuffer-local-ns-map"
argument_list|,
operator|&
name|Vminibuffer_local_ns_map
argument_list|,
literal|"The keymap used by the minibuf for local bindings when spaces are not\n\ to be allowed in input string."
argument_list|)
expr_stmt|;
name|Vminibuffer_local_ns_map
operator|=
name|Fmake_sparse_keymap
argument_list|()
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"minibuffer-local-completion-map"
argument_list|,
operator|&
name|Vminibuffer_local_completion_map
argument_list|,
literal|"Keymap to use when reading from the minibuffer with completion."
argument_list|)
expr_stmt|;
name|Vminibuffer_local_completion_map
operator|=
name|Fmake_sparse_keymap
argument_list|()
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"minibuffer-local-must-match-map"
argument_list|,
operator|&
name|Vminibuffer_local_must_match_map
argument_list|,
literal|"Keymap to use when reading from the minibuffer with completion and\n\ an exact match of one of the completions is required."
argument_list|)
expr_stmt|;
name|Vminibuffer_local_must_match_map
operator|=
name|Fmake_sparse_keymap
argument_list|()
expr_stmt|;
name|CurrentGlobalMap
operator|=
name|GlobalMap
expr_stmt|;
name|Qsingle_key_description
operator|=
name|intern
argument_list|(
literal|"single-key-description"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsingle_key_description
argument_list|)
expr_stmt|;
name|Qkey_description
operator|=
name|intern
argument_list|(
literal|"key-description"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qkey_description
argument_list|)
expr_stmt|;
name|Qkeymapp
operator|=
name|intern
argument_list|(
literal|"keymapp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qkeymapp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skeymapp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_keymap
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_sparse_keymap
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skey_binding
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slocal_key_binding
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sglobal_key_binding
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sglobal_set_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slocal_set_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefine_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slookup_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sglobal_unset_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slocal_unset_key
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suse_global_map
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suse_local_map
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_local_map
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Saccessible_keymaps
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skey_description
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssingle_key_description
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Stext_char_description
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swhere_is_internal
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swhere_is
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdescribe_bindings
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sapropos
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexecute_extended_command
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_keymap
argument_list|()
end_macro

begin_block
block|{
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
literal|033
argument_list|,
literal|"ESC-prefix"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|GlobalMap
argument_list|,
name|Ctl
argument_list|(
literal|'X'
argument_list|)
argument_list|,
literal|"Control-X-prefix"
argument_list|)
expr_stmt|;
name|defkey
argument_list|(
name|ESCmap
argument_list|,
literal|'x'
argument_list|,
literal|"execute-extended-command"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

