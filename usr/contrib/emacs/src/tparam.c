begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Merge parameters into a termcap entry string.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* Assuming `string' is the value of a termcap string entry    containing `%' constructs to expand parameters,    merge in parameter values and store result in block `outstring' points to.    No check is made for overflowing `outstring';    the caller is wise to allocate space for it based on the size of    `string', knowing that the size can increase by at most a couple    of characters per parameter.    The third and following args to tparam serve as the parameter values.  */
end_comment

begin_comment
comment|/* VARARGS 2 */
end_comment

begin_macro
name|tparam
argument_list|(
argument|string
argument_list|,
argument|outstring
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tparam1
argument_list|(
name|string
argument_list|,
name|outstring
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tgoto_buf
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|tgoto
parameter_list|(
name|cm
parameter_list|,
name|hpos
parameter_list|,
name|vpos
parameter_list|)
name|char
modifier|*
name|cm
decl_stmt|;
name|int
name|hpos
decl_stmt|,
name|vpos
decl_stmt|;
block|{
name|int
name|args
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cm
condition|)
return|return
literal|0
return|;
name|args
index|[
literal|0
index|]
operator|=
name|vpos
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|hpos
expr_stmt|;
name|tparam1
argument_list|(
name|cm
argument_list|,
name|tgoto_buf
argument_list|,
name|BC
argument_list|,
name|UP
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|tgoto_buf
return|;
block|}
end_function

begin_macro
name|tparam1
argument_list|(
argument|string
argument_list|,
argument|outstring
argument_list|,
argument|up
argument_list|,
argument|left
argument_list|,
argument|argp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|outstring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|up
decl_stmt|,
modifier|*
name|left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|;
name|int
modifier|*
name|oargp
init|=
name|argp
decl_stmt|;
name|char
modifier|*
name|oleft
init|=
name|left
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|tem
operator|=
operator|*
name|argp
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* %d means output in decimal */
if|if
condition|(
name|tem
operator|<
literal|10
condition|)
goto|goto
name|onedigit
goto|;
if|if
condition|(
name|tem
operator|<
literal|100
condition|)
goto|goto
name|twodigit
goto|;
case|case
literal|'3'
case|:
comment|/* %3 means output in decimal, 3 digits. */
operator|*
name|outstring
operator|++
operator|=
name|tem
operator|/
literal|100
operator|+
literal|'0'
expr_stmt|;
case|case
literal|'2'
case|:
comment|/* %2 means output in decimal, 2 digits. */
name|twodigit
label|:
name|tem
operator|%=
literal|100
expr_stmt|;
operator|*
name|outstring
operator|++
operator|=
name|tem
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|onedigit
label|:
operator|*
name|outstring
operator|++
operator|=
name|tem
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|argp
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* For c-100: print quotient of value by 96, if nonzero, 		 then do like %+ */
if|if
condition|(
name|tem
operator|>=
literal|96
condition|)
block|{
operator|*
name|outstring
operator|++
operator|=
name|tem
operator|/
literal|96
expr_stmt|;
name|tem
operator|%=
literal|96
expr_stmt|;
block|}
case|case
literal|'+'
case|:
comment|/* %+x means add character code of char x */
name|tem
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
case|case
literal|'.'
case|:
comment|/* %. means output as character */
if|if
condition|(
name|oleft
condition|)
block|{
comment|/* If want to forbid output of 0 and \n, 		     and this is one, increment it.  */
if|if
condition|(
name|tem
operator|==
literal|0
operator|||
name|tem
operator|==
literal|'\n'
condition|)
name|tem
operator|++
expr_stmt|;
comment|/* If this isn't one, cancel the compensation string 		     that would otherwise compensate for 		     the incrementation that we are not going to do.  */
else|else
block|{
if|if
condition|(
name|argp
operator|==
name|oargp
condition|)
name|left
operator|=
literal|0
expr_stmt|;
else|else
name|up
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|outstring
operator|++
operator|=
name|tem
operator||
literal|0200
expr_stmt|;
case|case
literal|'f'
case|:
comment|/* %f means discard next arg */
name|argp
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* %b means back up one arg (and re-use it) */
name|argp
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* %r means interchange following two args */
name|argp
index|[
literal|0
index|]
operator|=
name|argp
index|[
literal|1
index|]
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|=
name|tem
expr_stmt|;
name|oargp
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
comment|/* %>xy means if arg is> char code of x, */
if|if
condition|(
name|argp
index|[
literal|0
index|]
operator|>
operator|*
name|p
operator|++
condition|)
comment|/* then add char code of y to the arg, */
name|argp
index|[
literal|0
index|]
operator|+=
operator|*
name|p
expr_stmt|;
comment|/* and in any case don't output. */
name|p
operator|++
expr_stmt|;
comment|/* Leave the arg to be output later. */
break|break;
case|case
literal|'a'
case|:
comment|/* %a means arithmetic */
comment|/* Next character says what operation. 		 Add or subtract either a constant or some other arg */
comment|/* First following character is + to add or - to subtract 		 or = to assign.  */
comment|/* Next following char is 'p' and an arg spec 		 (0100 plus position of that arg relative to this one) 		 or 'c' and a constant stored in a character */
name|tem
operator|=
name|p
index|[
literal|2
index|]
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
name|tem
operator|=
name|argp
index|[
name|tem
operator|-
literal|0100
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|argp
index|[
literal|0
index|]
operator|-=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|argp
index|[
literal|0
index|]
operator|+=
name|tem
expr_stmt|;
else|else
name|argp
index|[
literal|0
index|]
operator|=
name|tem
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* %i means add one to arg, */
name|argp
index|[
literal|0
index|]
operator|++
expr_stmt|;
comment|/* and leave it to be output later. */
name|argp
index|[
literal|1
index|]
operator|++
expr_stmt|;
comment|/* Increment the following arg, too!  */
break|break;
case|case
literal|'%'
case|:
comment|/* %% means output %; no arg. */
goto|goto
name|ordinary
goto|;
case|case
literal|'n'
case|:
comment|/* %n means xor each of next two args with 140 */
name|argp
index|[
literal|0
index|]
operator|^=
literal|0140
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|^=
literal|0140
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* %m means xor each of next two args with 177 */
name|argp
index|[
literal|0
index|]
operator|^=
literal|0177
expr_stmt|;
name|argp
index|[
literal|1
index|]
operator|^=
literal|0177
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* %B means express arg as BCD char code. */
name|argp
index|[
literal|0
index|]
operator|+=
literal|6
operator|*
operator|(
name|tem
operator|/
literal|10
operator|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* %D means weird Delta Data transformation */
name|argp
index|[
literal|0
index|]
operator|-=
literal|2
operator|*
operator|(
name|tem
operator|%
literal|16
operator|)
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* Ordinary character in the argument string.  */
name|ordinary
label|:
operator|*
name|outstring
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|outstring
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|left
condition|)
name|strcat
argument_list|(
name|outstring
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
condition|)
name|strcat
argument_list|(
name|outstring
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|args
index|[
literal|3
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|tparam1
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
literal|"LEFT"
argument_list|,
literal|"UP"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

