begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* terminal control module for terminals described by TERMCAP    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"cm.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|OUTPUT
parameter_list|(
name|a
parameter_list|)
value|tputs (a, screen_height - curY, cmputc)
end_define

begin_define
define|#
directive|define
name|OUTPUT1
parameter_list|(
name|a
parameter_list|)
value|tputs (a, 1, cmputc)
end_define

begin_define
define|#
directive|define
name|OUTPUTL
parameter_list|(
name|a
parameter_list|,
name|lines
parameter_list|)
value|tputs (a, lines, cmputc)
end_define

begin_define
define|#
directive|define
name|OUTPUT_IF
parameter_list|(
name|a
parameter_list|)
value|{ if (a) tputs (a, screen_height - curY, cmputc); }
end_define

begin_define
define|#
directive|define
name|OUTPUT1_IF
parameter_list|(
name|a
parameter_list|)
value|{ if (a) tputs (a, 1, cmputc); }
end_define

begin_comment
comment|/* Terminal charateristics that higher levels want to look at.    These are all extern'd in termchar.h */
end_comment

begin_decl_stmt
name|int
name|screen_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of usable columns */
end_comment

begin_decl_stmt
name|int
name|screen_height
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines */
end_comment

begin_decl_stmt
name|int
name|must_write_spaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means spaces in the text 				   must actually be output; can't just skip 				   over some columns to leave them blank.  */
end_comment

begin_decl_stmt
name|int
name|min_padding_speed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Speed below which no padding necessary */
end_comment

begin_decl_stmt
name|int
name|line_ins_del_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal can insert and delete lines */
end_comment

begin_decl_stmt
name|int
name|char_ins_del_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal can insert and delete chars */
end_comment

begin_decl_stmt
name|int
name|scroll_region_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal supports setting the scroll window */
end_comment

begin_decl_stmt
name|int
name|memory_below_screen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal remembers lines scrolled off bottom */
end_comment

begin_decl_stmt
name|int
name|fast_clear_end_of_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal has a `ce' string */
end_comment

begin_decl_stmt
name|int
name|dont_calculate_costs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't bother computing */
end_comment

begin_comment
comment|/* various cost tables; we won't use them.  */
end_comment

begin_comment
comment|/* DCICcost[n] is cost of inserting N characters.    DCICcost[-n] is cost of deleting N characters. */
end_comment

begin_define
define|#
directive|define
name|DCICcost
value|(&DC_ICcost[MScreenWidth])
end_define

begin_decl_stmt
name|int
name|DC_ICcost
index|[
literal|1
operator|+
literal|2
operator|*
name|MScreenWidth
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook functions that you can set to snap out the functions in this file.    These are all extern'd in termhooks.h  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|topos_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|raw_topos_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|clear_to_end_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|clear_screen_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|clear_end_of_line_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|ins_del_lines_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|change_line_highlight_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|reassert_line_highlight_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|insert_chars_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|write_chars_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|delete_chars_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|ring_bell_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|reset_terminal_modes_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|set_terminal_modes_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|update_begin_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|update_end_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|set_terminal_window_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|read_socket_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|fix_screen_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Strings, numbers and flags taken from the termcap entry.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_ins_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap "al" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_ins_multi_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "AL" (one parameter, # lines to insert) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "bl" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_clr_to_bottom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "cd" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_clr_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ce", clear to end of line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_clr_screen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "cl" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_set_scroll_region
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "cs" (2 params, first line and last line) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_set_scroll_region_1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "cS" (4 params: total lines, 				   lines above scroll region, lines below it, 				   total lines again) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_del_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "dc" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_del_multi_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "DC" (one parameter, # chars to delete) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_del_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "dl" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_del_multi_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "DL" (one parameter, # lines to delete) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_delete_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "dm", enter character-delete mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_end_delete_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ed", leave character-delete mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_end_insert_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ei", leave character-insert mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_ins_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ic" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_ins_multi_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "IC" (one parameter, # chars to insert) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_insert_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "im", enter character-insert mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_pad_inserted_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ip".  Just padding, no commands.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_end_keypad_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ke" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_keypad_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ks" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_pad_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "pc", char to use as padding */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_repeat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "rp" (2 params, # times to repeat 				   and character to be repeated) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_end_standout_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "se" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_fwd_scroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "sf" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_standout_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "so" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_rev_scroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "sr" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_end_termcap_modes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "te" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_termcap_modes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ti" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "vb" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_end_visual_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "ve" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_visual_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "vi" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TS_set_window
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "wi" (4 params, start and end of window, 				   each as vpos and hpos) */
end_comment

begin_decl_stmt
name|int
name|TF_hazeltine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap hz flag. */
end_comment

begin_decl_stmt
name|int
name|TF_insmode_motion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap mi flag: can move while in insert mode. */
end_comment

begin_decl_stmt
name|int
name|TF_standout_motion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap mi flag: can move while in standout mode. */
end_comment

begin_decl_stmt
name|int
name|TF_underscore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap ul flag: _ underlines if overstruck on 				   nonblank position.  Must clear before writing _.  */
end_comment

begin_decl_stmt
name|int
name|TF_teleray
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap xt flag: many weird consequences.  For t1061. */
end_comment

begin_decl_stmt
name|int
name|TN_standout_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap sg number: width occupied by standout markers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|RPov
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # chars to start a TS_repeat */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delete_in_insert_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delete mode == insert mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|se_is_so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if same string both enters and leaves standout mode */
end_comment

begin_comment
comment|/* internal state */
end_comment

begin_comment
comment|/* Number of chars of space used for standout marker at beginning of line,    or'd with 0100.  Zero if no standout marker at all.  */
end_comment

begin_comment
comment|/* used iff TN_standout_width>= 0. */
end_comment

begin_decl_stmt
name|char
name|chars_wasted
index|[
name|MScreenLength
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero means supposed to write text in standout mode.  */
end_comment

begin_decl_stmt
name|int
name|standout_requested
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insert_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when in insert mode.  */
end_comment

begin_decl_stmt
name|int
name|standout_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when in standout mode.  */
end_comment

begin_comment
comment|/* Size of window specified by higher levels.    This is the number of lines, starting from top of screen,    to participate in ins/del line operations.    Effectively it excludes the bottom       screen_height - specified_window_size    lines from those operations.  */
end_comment

begin_decl_stmt
name|int
name|specified_window
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|ring_bell
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|ring_bell_hook
condition|)
block|{
call|(
modifier|*
name|ring_bell_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
name|OUTPUT
argument_list|(
name|TS_visible_bell
operator|&&
name|visible_bell
condition|?
name|TS_visible_bell
else|:
name|TS_bell
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_terminal_modes
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|set_terminal_modes_hook
condition|)
block|{
call|(
modifier|*
name|set_terminal_modes_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
name|OUTPUT_IF
argument_list|(
name|TS_termcap_modes
argument_list|)
expr_stmt|;
name|OUTPUT_IF
argument_list|(
name|TS_visual_mode
argument_list|)
expr_stmt|;
name|OUTPUT_IF
argument_list|(
name|TS_keypad_mode
argument_list|)
expr_stmt|;
name|losecursor
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|reset_terminal_modes
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|reset_terminal_modes_hook
condition|)
block|{
call|(
modifier|*
name|reset_terminal_modes_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TN_standout_width
operator|<
literal|0
condition|)
name|turn_off_highlight
argument_list|()
expr_stmt|;
name|turn_off_insert
argument_list|()
expr_stmt|;
name|OUTPUT_IF
argument_list|(
name|TS_end_keypad_mode
argument_list|)
expr_stmt|;
name|OUTPUT_IF
argument_list|(
name|TS_end_visual_mode
argument_list|)
expr_stmt|;
name|OUTPUT_IF
argument_list|(
name|TS_end_termcap_modes
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|update_begin
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|update_begin_hook
condition|)
call|(
modifier|*
name|update_begin_hook
call|)
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|update_end
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|update_end_hook
condition|)
block|{
call|(
modifier|*
name|update_end_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
name|turn_off_insert
argument_list|()
expr_stmt|;
name|background_highlight
argument_list|()
expr_stmt|;
name|standout_requested
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|set_terminal_window
argument_list|(
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|set_terminal_window_hook
condition|)
block|{
call|(
modifier|*
name|set_terminal_window_hook
call|)
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|specified_window
operator|=
name|size
condition|?
name|size
else|:
name|screen_height
expr_stmt|;
if|if
condition|(
operator|!
name|scroll_region_ok
condition|)
return|return;
name|set_scroll_region
argument_list|(
literal|0
argument_list|,
name|specified_window
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_scroll_region
argument_list|(
argument|start
argument_list|,
argument|stop
argument_list|)
end_macro

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|stop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|TS_set_scroll_region
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|TS_set_scroll_region
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|tparam
argument_list|(
name|TS_set_scroll_region
argument_list|,
name|buf
argument_list|,
name|start
argument_list|,
name|stop
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TS_set_scroll_region_1
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|TS_set_scroll_region_1
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|tparam
argument_list|(
name|TS_set_scroll_region_1
argument_list|,
name|buf
argument_list|,
name|screen_height
argument_list|,
name|start
argument_list|,
name|screen_height
operator|-
name|stop
argument_list|,
name|screen_height
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|TS_set_window
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|tparam
argument_list|(
name|TS_set_window
argument_list|,
name|buf
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|stop
argument_list|,
name|screen_width
argument_list|)
expr_stmt|;
block|}
name|OUTPUT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|losecursor
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|turn_on_insert
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|insert_mode
condition|)
name|OUTPUT
argument_list|(
name|TS_insert_mode
argument_list|)
expr_stmt|;
name|insert_mode
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|turn_off_insert
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|insert_mode
condition|)
name|OUTPUT
argument_list|(
name|TS_end_insert_mode
argument_list|)
expr_stmt|;
name|insert_mode
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Handle highlighting when TN_standout_width (termcap sg) is not specified.    In these terminals, output is affected by the value of standout    mode when the output is written.     These functions are called on all terminals, but do nothing    on terminals whose standout mode does not work that way.  */
end_comment

begin_macro
name|turn_off_highlight
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|TN_standout_width
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|standout_mode
condition|)
name|OUTPUT_IF
argument_list|(
name|TS_end_standout_mode
argument_list|)
expr_stmt|;
name|standout_mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|turn_on_highlight
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|TN_standout_width
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|standout_mode
condition|)
name|OUTPUT_IF
argument_list|(
name|TS_standout_mode
argument_list|)
expr_stmt|;
name|standout_mode
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Set standout mode to the state it should be in for    empty space inside windows.  What this is,    depends on the user option inverse-video.  */
end_comment

begin_macro
name|background_highlight
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|TN_standout_width
operator|>=
literal|0
condition|)
return|return;
if|if
condition|(
name|inverse_video
condition|)
name|turn_on_highlight
argument_list|()
expr_stmt|;
else|else
name|turn_off_highlight
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Set standout mode to the mode specified for the text to be output.  */
end_comment

begin_expr_stmt
specifier|static
name|highlight_if_desired
argument_list|()
block|{
if|if
condition|(
name|TN_standout_width
operator|>=
literal|0
condition|)
return|return;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|inverse_video
operator|==
operator|!
name|standout_requested
condition|)
name|turn_off_highlight
argument_list|()
expr_stmt|;
else|else
name|turn_on_highlight
argument_list|()
expr_stmt|;
end_if

begin_escape
unit|}
end_escape

begin_comment
comment|/* Handle standout mode for terminals in which TN_standout_width>= 0.    On these terminals, standout is controlled by markers that    live inside the screen memory.  TN_standout_width is the width    that the marker occupies in memory.  Standout runs from the marker    to the end of the line on some terminals, or to the next    turn-off-standout marker (TS_end_standout_mode) string    on other terminals.  */
end_comment

begin_comment
comment|/* Write a standout marker or end-standout marker at the front of the line    at vertical position vpos.  */
end_comment

begin_expr_stmt
unit|write_standout_marker
operator|(
name|flag
operator|,
name|vpos
operator|)
name|int
name|flag
operator|,
name|vpos
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|flag
operator|||
operator|(
name|TS_end_standout_mode
operator|&&
operator|!
name|TF_teleray
operator|&&
operator|!
name|se_is_so
operator|)
condition|)
block|{
name|cmgoto
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmplus
argument_list|(
name|TN_standout_width
argument_list|)
expr_stmt|;
name|OUTPUT
argument_list|(
name|flag
condition|?
name|TS_standout_mode
else|:
name|TS_end_standout_mode
argument_list|)
expr_stmt|;
name|chars_wasted
index|[
name|curY
index|]
operator|=
name|TN_standout_width
operator||
literal|0100
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* External interface to control of standout mode.    Call this when about to modify line at position VPOS    and not change whether it is highlighted.  */
end_comment

begin_macro
name|reassert_line_highlight
argument_list|(
argument|highlight
argument_list|,
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|highlight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|reassert_line_highlight_hook
condition|)
block|{
call|(
modifier|*
name|reassert_line_highlight_hook
call|)
argument_list|(
name|highlight
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TN_standout_width
operator|<
literal|0
condition|)
comment|/* Handle terminals where standout takes affect at output time */
name|standout_requested
operator|=
name|highlight
expr_stmt|;
elseif|else
if|if
condition|(
name|chars_wasted
index|[
name|vpos
index|]
operator|==
literal|0
condition|)
comment|/* For terminals with standout markers, write one on this line        if there isn't one already.  */
name|write_standout_marker
argument_list|(
name|highlight
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Call this when about to modify line at position VPOS    and change whether it is highlighted.  */
end_comment

begin_macro
name|change_line_highlight
argument_list|(
argument|new_highlight
argument_list|,
argument|vpos
argument_list|,
argument|first_unused_hpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new_highlight
decl_stmt|,
name|vpos
decl_stmt|,
name|first_unused_hpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|standout_requested
operator|=
name|new_highlight
expr_stmt|;
if|if
condition|(
name|change_line_highlight_hook
condition|)
block|{
call|(
modifier|*
name|change_line_highlight_hook
call|)
argument_list|(
name|new_highlight
argument_list|,
name|vpos
argument_list|,
name|first_unused_hpos
argument_list|)
expr_stmt|;
return|return;
block|}
name|topos
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TN_standout_width
operator|<
literal|0
condition|)
name|background_highlight
argument_list|()
expr_stmt|;
comment|/* If line starts with a marker, delete the marker */
elseif|else
if|if
condition|(
name|TS_clr_line
operator|&&
name|chars_wasted
index|[
name|curY
index|]
condition|)
block|{
name|turn_off_insert
argument_list|()
expr_stmt|;
comment|/* On Teleray, make sure to erase the SO marker.  */
if|if
condition|(
name|TF_teleray
condition|)
block|{
name|cmgoto
argument_list|(
name|curY
operator|-
literal|1
argument_list|,
name|screen_width
operator|-
literal|4
argument_list|)
expr_stmt|;
name|OUTPUT
argument_list|(
literal|"\033S"
argument_list|)
expr_stmt|;
name|curY
operator|++
expr_stmt|;
comment|/* ESC S moves to next line where the TS_standout_mode was */
name|curX
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cmgoto
argument_list|(
name|curY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reposition to kill standout marker */
block|}
name|clear_end_of_line_raw
argument_list|(
name|first_unused_hpos
argument_list|)
expr_stmt|;
name|reassert_line_highlight
argument_list|(
name|new_highlight
argument_list|,
name|curY
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Move to absolute position, specified origin 0 */
end_comment

begin_macro
name|topos
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|)
end_macro

begin_block
block|{
name|col
operator|+=
name|chars_wasted
index|[
name|row
index|]
operator|&
literal|077
expr_stmt|;
if|if
condition|(
name|topos_hook
condition|)
block|{
call|(
modifier|*
name|topos_hook
call|)
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|curY
operator|==
name|row
operator|&&
name|curX
operator|==
name|col
condition|)
return|return;
if|if
condition|(
operator|!
name|TF_standout_motion
condition|)
name|background_highlight
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TF_insmode_motion
condition|)
name|turn_off_insert
argument_list|()
expr_stmt|;
name|cmgoto
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Similar but don't take any account of the wasted characters.  */
end_comment

begin_macro
name|raw_topos
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|raw_topos_hook
condition|)
block|{
call|(
modifier|*
name|raw_topos_hook
call|)
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|curY
operator|==
name|row
operator|&&
name|curX
operator|==
name|col
condition|)
return|return;
if|if
condition|(
operator|!
name|TF_standout_motion
condition|)
name|background_highlight
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TF_insmode_motion
condition|)
name|turn_off_insert
argument_list|()
expr_stmt|;
name|cmgoto
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Erase operations */
end_comment

begin_comment
comment|/* clear from cursor to end of screen */
end_comment

begin_macro
name|clear_to_end
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clear_to_end_hook
condition|)
block|{
call|(
modifier|*
name|clear_to_end_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TS_clr_to_bottom
condition|)
block|{
name|background_highlight
argument_list|()
expr_stmt|;
name|OUTPUT
argument_list|(
name|TS_clr_to_bottom
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|chars_wasted
operator|+
name|curY
argument_list|,
name|screen_height
operator|-
name|curY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|curY
init|;
name|i
operator|<
name|screen_height
condition|;
name|i
operator|++
control|)
block|{
name|topos
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clear_end_of_line_raw
argument_list|(
name|screen_width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Clear entire screen */
end_comment

begin_macro
name|clear_screen
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|clear_screen_hook
condition|)
block|{
call|(
modifier|*
name|clear_screen_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TS_clr_screen
condition|)
block|{
name|background_highlight
argument_list|()
expr_stmt|;
name|OUTPUT
argument_list|(
name|TS_clr_screen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|chars_wasted
argument_list|,
name|screen_height
argument_list|)
expr_stmt|;
name|cmat
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|topos
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clear_to_end
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Clear to end of line, but do not clear any standout marker.    Assumes that the cursor is positioned at a character of real text,    which implies it cannot be before a standout marker    unless the marker has zero width.     Note that the cursor may be moved.  */
end_comment

begin_macro
name|clear_end_of_line
argument_list|(
argument|first_unused_hpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|first_unused_hpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|TN_standout_width
operator|==
literal|0
operator|&&
name|curX
operator|==
literal|0
operator|&&
name|chars_wasted
index|[
name|curY
index|]
operator|!=
literal|0
condition|)
name|write_chars
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clear_end_of_line_raw
argument_list|(
name|first_unused_hpos
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clear from cursor to end of line.    Assume that the line is already clear starting at column first_unused_hpos.    If the cursor is at a standout marker, erase the marker.     Note that the cursor may be moved, on terminals lacking a `ce' string.  */
end_comment

begin_macro
name|clear_end_of_line_raw
argument_list|(
argument|first_unused_hpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|first_unused_hpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|first_unused_hpos
operator|+=
name|chars_wasted
index|[
name|curY
index|]
operator|&
literal|077
expr_stmt|;
if|if
condition|(
name|clear_end_of_line_hook
condition|)
block|{
call|(
modifier|*
name|clear_end_of_line_hook
call|)
argument_list|(
name|first_unused_hpos
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|curX
operator|>=
name|first_unused_hpos
condition|)
return|return;
comment|/* Notice if we are erasing a magic cookie */
if|if
condition|(
name|curX
operator|==
literal|0
condition|)
name|chars_wasted
index|[
name|curY
index|]
operator|=
literal|0
expr_stmt|;
name|background_highlight
argument_list|()
expr_stmt|;
if|if
condition|(
name|TS_clr_line
condition|)
block|{
name|OUTPUT1
argument_list|(
name|TS_clr_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* have to do it the hard way */
name|turn_off_insert
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|curX
init|;
name|i
operator|<
name|first_unused_hpos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|termscript
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|cmplus
argument_list|(
name|first_unused_hpos
operator|-
name|curX
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|write_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|write_chars_hook
condition|)
block|{
call|(
modifier|*
name|write_chars_hook
call|)
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|highlight_if_desired
argument_list|()
expr_stmt|;
name|turn_off_insert
argument_list|()
expr_stmt|;
comment|/* Don't dare write in last column of bottom line, if AutoWrap,      since that would scroll the whole screen on some terminals.  */
if|if
condition|(
name|AutoWrap
operator|&&
name|curY
operator|+
literal|1
operator|==
name|screen_height
operator|&&
name|curX
operator|+
name|len
operator|==
name|screen_width
condition|)
name|len
operator|--
expr_stmt|;
name|cmplus
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RPov
operator|>
name|len
operator|&&
operator|!
name|TF_underscore
operator|&&
operator|!
name|TF_hazeltine
condition|)
block|{
name|fwrite
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|clearerr
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|termscript
condition|)
name|fwrite
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|RPov
operator|+
literal|1
operator|<
name|len
operator|&&
operator|*
name|start
operator|==
name|start
index|[
literal|1
index|]
condition|)
block|{
name|p
operator|=
name|start
operator|+
literal|1
expr_stmt|;
comment|/* Now, len is number of chars left starting at p */
while|while
condition|(
operator|*
name|p
operator|++
operator|==
operator|*
name|start
condition|)
empty_stmt|;
comment|/* n is number of identical chars in this run */
name|n
operator|=
name|p
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|RPov
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|TS_repeat
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|tparam
argument_list|(
name|TS_repeat
argument_list|,
name|buf
argument_list|,
operator|*
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|cmputc
argument_list|)
expr_stmt|;
name|start
operator|=
name|p
expr_stmt|;
name|len
operator|-=
name|n
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|c
operator|=
operator|*
name|start
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
operator|&&
name|TF_underscore
condition|)
block|{
if|if
condition|(
name|termscript
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|OUTPUT
argument_list|(
name|Left
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TF_hazeltine
operator|&&
name|c
operator|==
literal|'~'
condition|)
name|c
operator|=
literal|'`'
expr_stmt|;
if|if
condition|(
name|termscript
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* If start is zero, insert blanks instead of a string at start */
end_comment

begin_expr_stmt
name|insert_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|start
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|insert_chars_hook
condition|)
block|{
call|(
modifier|*
name|insert_chars_hook
call|)
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|highlight_if_desired
argument_list|()
expr_stmt|;
if|if
condition|(
name|TS_ins_multi_chars
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|TS_ins_multi_chars
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|tparam
argument_list|(
name|TS_ins_multi_chars
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|OUTPUT1
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|write_chars
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|turn_on_insert
argument_list|()
expr_stmt|;
name|cmplus
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TF_underscore
operator|&&
operator|!
name|TF_hazeltine
operator|&&
name|start
operator|&&
name|TS_pad_inserted_char
operator|==
literal|0
operator|&&
name|TS_ins_char
operator|==
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|termscript
condition|)
name|fwrite
argument_list|(
name|start
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|OUTPUT1_IF
argument_list|(
name|TS_ins_char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
else|else
block|{
name|c
operator|=
operator|*
name|start
operator|++
expr_stmt|;
if|if
condition|(
name|TF_hazeltine
operator|&&
name|c
operator|==
literal|'~'
condition|)
name|c
operator|=
literal|'`'
expr_stmt|;
block|}
if|if
condition|(
name|termscript
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|OUTPUT1_IF
argument_list|(
name|TS_pad_inserted_char
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|delete_chars
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|delete_chars_hook
condition|)
block|{
call|(
modifier|*
name|delete_chars_hook
call|)
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|delete_in_insert_mode
condition|)
block|{
name|turn_on_insert
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|turn_off_insert
argument_list|()
expr_stmt|;
name|OUTPUT_IF
argument_list|(
name|TS_delete_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TS_del_multi_chars
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|TS_del_multi_chars
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|tparam
argument_list|(
name|TS_del_multi_chars
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|OUTPUT1
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|OUTPUT1
argument_list|(
name|TS_del_char
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delete_in_insert_mode
condition|)
name|OUTPUT_IF
argument_list|(
name|TS_end_delete_mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Insert N lines at vpos VPOS.  If N is negative, delete -N lines.  */
end_comment

begin_macro
name|ins_del_lines
argument_list|(
argument|vpos
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vpos
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|multi
init|=
name|n
operator|>
literal|0
condition|?
name|TS_ins_multi_lines
else|:
name|TS_del_multi_lines
decl_stmt|;
name|char
modifier|*
name|single
init|=
name|n
operator|>
literal|0
condition|?
name|TS_ins_line
else|:
name|TS_del_line
decl_stmt|;
name|char
modifier|*
name|scroll
init|=
name|n
operator|>
literal|0
condition|?
name|TS_rev_scroll
else|:
name|TS_fwd_scroll
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|n
operator|>
literal|0
condition|?
name|n
else|:
operator|-
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|copybuf
index|[
name|MScreenWidth
index|]
decl_stmt|;
if|if
condition|(
name|ins_del_lines_hook
condition|)
block|{
call|(
modifier|*
name|ins_del_lines_hook
call|)
argument_list|(
name|vpos
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the lines below the insertion are being pushed      into the end of the window, this is the same as clearing;      and we know the lines are already clear, since the matching      deletion has already been done.  So can ignore this.  */
comment|/* If the lines below the deletion are blank lines coming      out of the end of the window, don't bother,      as there will be a matching inslines later that will flush them. */
if|if
condition|(
name|scroll_region_ok
operator|&&
name|vpos
operator|+
name|i
operator|>=
name|specified_window
condition|)
return|return;
if|if
condition|(
operator|!
name|memory_below_screen
operator|&&
name|vpos
operator|+
name|i
operator|>=
name|screen_height
condition|)
return|return;
if|if
condition|(
name|multi
condition|)
block|{
name|raw_topos
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|background_highlight
argument_list|()
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|multi
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|tparam
argument_list|(
name|multi
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|OUTPUT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|single
condition|)
block|{
name|raw_topos
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|background_highlight
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|OUTPUT
argument_list|(
name|single
argument_list|)
expr_stmt|;
if|if
condition|(
name|TF_teleray
condition|)
name|curX
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|set_scroll_region
argument_list|(
name|vpos
argument_list|,
name|specified_window
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|raw_topos
argument_list|(
name|specified_window
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|raw_topos
argument_list|(
name|vpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|background_highlight
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|OUTPUTL
argument_list|(
name|scroll
argument_list|,
name|specified_window
operator|-
name|vpos
argument_list|)
expr_stmt|;
name|set_scroll_region
argument_list|(
literal|0
argument_list|,
name|specified_window
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TN_standout_width
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|chars_wasted
index|[
name|curY
operator|-
name|n
index|]
argument_list|,
operator|&
name|chars_wasted
index|[
name|curY
index|]
argument_list|,
name|screen_height
operator|-
name|curY
operator|+
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|chars_wasted
index|[
name|screen_height
operator|+
name|n
index|]
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|chars_wasted
index|[
name|curY
index|]
argument_list|,
operator|&
name|copybuf
index|[
name|curY
index|]
argument_list|,
name|screen_height
operator|-
name|curY
operator|-
name|n
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|copybuf
index|[
name|curY
index|]
argument_list|,
operator|&
name|chars_wasted
index|[
name|curY
operator|+
name|n
index|]
argument_list|,
name|screen_height
operator|-
name|curY
operator|-
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|chars_wasted
index|[
name|curY
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|scroll_region_ok
operator|&&
name|memory_below_screen
operator|&&
name|n
operator|<
literal|0
condition|)
block|{
name|topos
argument_list|(
name|screen_height
operator|+
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clear_to_end
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In cm.c */
end_comment

begin_extern
extern|extern evalcost (
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Compute cost of sending "str", in characters,    not counting any line-dependent padding.  */
end_comment

begin_macro
name|string_cost
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_block

begin_comment
comment|/* Compute cost of sending "str", in characters,    counting any line-dependent padding at one line.  */
end_comment

begin_macro
name|string_cost_one_line
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_block

begin_comment
comment|/* Compute per line amount of line-dependent padding,    in tenths of characters.  */
end_comment

begin_expr_stmt
name|per_line_cost
argument_list|(
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|cost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
name|cost
operator|=
operator|-
name|cost
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
literal|10
argument_list|,
name|evalcost
argument_list|)
expr_stmt|;
return|return
name|cost
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|calculate_ins_del_char_costs
argument_list|()
end_macro

begin_block
block|{
name|int
name|ins_startup_cost
decl_stmt|,
name|del_startup_cost
decl_stmt|;
name|int
name|ins_cost_per_char
decl_stmt|,
name|del_cost_per_char
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|TS_ins_multi_chars
condition|)
block|{
name|ins_cost_per_char
operator|=
literal|0
expr_stmt|;
name|ins_startup_cost
operator|=
name|string_cost_one_line
argument_list|(
name|TS_ins_multi_chars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TS_ins_char
operator|||
name|TS_pad_inserted_char
operator|||
operator|(
name|TS_insert_mode
operator|&&
name|TS_end_insert_mode
operator|)
condition|)
block|{
name|ins_startup_cost
operator|=
literal|0.3
operator|*
operator|(
name|string_cost
argument_list|(
name|TS_insert_mode
argument_list|)
operator|+
name|string_cost
argument_list|(
name|TS_end_insert_mode
argument_list|)
operator|)
expr_stmt|;
name|ins_cost_per_char
operator|=
operator|(
name|string_cost_one_line
argument_list|(
name|TS_ins_char
argument_list|)
operator|+
name|string_cost_one_line
argument_list|(
name|TS_pad_inserted_char
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ins_startup_cost
operator|=
literal|9999
expr_stmt|;
name|ins_cost_per_char
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TS_del_multi_chars
condition|)
block|{
name|del_cost_per_char
operator|=
literal|0
expr_stmt|;
name|del_startup_cost
operator|=
name|string_cost_one_line
argument_list|(
name|TS_del_multi_chars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TS_del_char
condition|)
block|{
name|del_startup_cost
operator|=
operator|(
name|string_cost
argument_list|(
name|TS_delete_mode
argument_list|)
operator|+
name|string_cost
argument_list|(
name|TS_end_delete_mode
argument_list|)
operator|)
operator|*
operator|(
name|delete_in_insert_mode
condition|?
literal|0.5
else|:
literal|1.0
operator|)
expr_stmt|;
name|del_cost_per_char
operator|=
name|string_cost_one_line
argument_list|(
name|TS_del_char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|del_startup_cost
operator|=
literal|9999
expr_stmt|;
name|del_cost_per_char
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Delete costs are at negative offsets */
name|p
operator|=
operator|&
name|DCICcost
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|screen_width
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
operator|--
name|p
operator|=
operator|(
name|del_startup_cost
operator|+=
name|del_cost_per_char
operator|)
expr_stmt|;
comment|/* Doing nothing is free */
name|p
operator|=
operator|&
name|DCICcost
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Insert costs are at positive offsets */
for|for
control|(
name|i
operator|=
name|screen_width
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|(
name|ins_startup_cost
operator|+=
name|ins_cost_per_char
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|calculate_costs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|TS_set_scroll_region
condition|?
name|TS_set_scroll_region
else|:
name|TS_set_scroll_region_1
decl_stmt|;
if|if
condition|(
name|dont_calculate_costs
condition|)
return|return;
if|if
condition|(
name|s
operator|&&
operator|(
operator|!
name|TS_ins_line
operator|&&
operator|!
name|TS_del_line
operator|)
condition|)
name|CalcIDCosts
argument_list|(
name|TS_rev_scroll
argument_list|,
name|TS_ins_multi_lines
argument_list|,
name|TS_fwd_scroll
argument_list|,
name|TS_del_multi_lines
argument_list|,
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|CalcIDCosts
argument_list|(
name|TS_ins_line
argument_list|,
name|TS_ins_multi_lines
argument_list|,
name|TS_del_line
argument_list|,
name|TS_del_multi_lines
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calculate_ins_del_char_costs
argument_list|()
expr_stmt|;
comment|/* Don't use TS_repeat if its padding is worse than sending the chars */
if|if
condition|(
name|TS_repeat
operator|&&
name|per_line_cost
argument_list|(
name|TS_repeat
argument_list|)
operator|*
name|baud_rate
operator|<
literal|9000
condition|)
name|RPov
operator|=
name|string_cost
argument_list|(
name|TS_repeat
argument_list|)
expr_stmt|;
else|else
name|RPov
operator|=
name|MScreenWidth
expr_stmt|;
name|cmcostinit
argument_list|()
expr_stmt|;
comment|/* set up cursor motion costs */
block|}
end_block

begin_escape
end_escape

begin_macro
name|term_init
argument_list|(
argument|terminal_type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|terminal_type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|combuf
decl_stmt|;
name|char
modifier|*
name|fill
decl_stmt|;
name|char
name|tbuf
index|[
literal|2044
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
name|Wcm_clear
argument_list|()
expr_stmt|;
name|dont_calculate_costs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tgetent
argument_list|(
name|tbuf
argument_list|,
name|terminal_type
argument_list|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Terminal type %s is not defined.\n"
argument_list|,
name|terminal_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMINFO
name|combuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|2044
argument_list|)
expr_stmt|;
else|#
directive|else
name|combuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not TERMINFO */
if|if
condition|(
name|combuf
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fill
operator|=
name|combuf
expr_stmt|;
name|TS_ins_line
operator|=
name|tgetstr
argument_list|(
literal|"al"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_ins_multi_lines
operator|=
name|tgetstr
argument_list|(
literal|"AL"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|Left
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_bell
operator|=
name|tgetstr
argument_list|(
literal|"bl"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_clr_to_bottom
operator|=
name|tgetstr
argument_list|(
literal|"cd"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_clr_line
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_clr_screen
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|ColPosition
operator|=
name|tgetstr
argument_list|(
literal|"ch"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|AbsPosition
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|CR
operator|=
name|tgetstr
argument_list|(
literal|"cr"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_set_scroll_region
operator|=
name|tgetstr
argument_list|(
literal|"cs"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_set_scroll_region_1
operator|=
name|tgetstr
argument_list|(
literal|"cS"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|RowPosition
operator|=
name|tgetstr
argument_list|(
literal|"cv"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_del_char
operator|=
name|tgetstr
argument_list|(
literal|"dc"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_del_multi_chars
operator|=
name|tgetstr
argument_list|(
literal|"DC"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_del_line
operator|=
name|tgetstr
argument_list|(
literal|"dl"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_del_multi_lines
operator|=
name|tgetstr
argument_list|(
literal|"DL"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_delete_mode
operator|=
name|tgetstr
argument_list|(
literal|"dm"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_end_delete_mode
operator|=
name|tgetstr
argument_list|(
literal|"ed"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_end_insert_mode
operator|=
name|tgetstr
argument_list|(
literal|"ei"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|Home
operator|=
name|tgetstr
argument_list|(
literal|"ho"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_ins_char
operator|=
name|tgetstr
argument_list|(
literal|"ic"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_ins_multi_chars
operator|=
name|tgetstr
argument_list|(
literal|"IC"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_insert_mode
operator|=
name|tgetstr
argument_list|(
literal|"im"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_pad_inserted_char
operator|=
name|tgetstr
argument_list|(
literal|"ip"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_end_keypad_mode
operator|=
name|tgetstr
argument_list|(
literal|"ke"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_keypad_mode
operator|=
name|tgetstr
argument_list|(
literal|"ks"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|LastLine
operator|=
name|tgetstr
argument_list|(
literal|"ll"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|Right
operator|=
name|tgetstr
argument_list|(
literal|"nd"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|Down
operator|=
name|tgetstr
argument_list|(
literal|"nl"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_pad_char
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_repeat
operator|=
name|tgetstr
argument_list|(
literal|"rp"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_end_standout_mode
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_fwd_scroll
operator|=
name|tgetstr
argument_list|(
literal|"sf"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_standout_mode
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_rev_scroll
operator|=
name|tgetstr
argument_list|(
literal|"sr"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|Tab
operator|=
name|tgetstr
argument_list|(
literal|"ta"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_end_termcap_modes
operator|=
name|tgetstr
argument_list|(
literal|"te"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_termcap_modes
operator|=
name|tgetstr
argument_list|(
literal|"ti"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|Up
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_visible_bell
operator|=
name|tgetstr
argument_list|(
literal|"vb"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_end_visual_mode
operator|=
name|tgetstr
argument_list|(
literal|"ve"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_visual_mode
operator|=
name|tgetstr
argument_list|(
literal|"vs"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_set_window
operator|=
name|tgetstr
argument_list|(
literal|"wi"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|AutoWrap
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|memory_below_screen
operator|=
name|tgetflag
argument_list|(
literal|"db"
argument_list|)
expr_stmt|;
name|TF_hazeltine
operator|=
name|tgetflag
argument_list|(
literal|"hz"
argument_list|)
expr_stmt|;
name|must_write_spaces
operator|=
name|tgetflag
argument_list|(
literal|"in"
argument_list|)
expr_stmt|;
name|MetaFlag
operator|=
name|tgetflag
argument_list|(
literal|"km"
argument_list|)
operator|||
name|tgetflag
argument_list|(
literal|"MT"
argument_list|)
expr_stmt|;
name|TF_insmode_motion
operator|=
name|tgetflag
argument_list|(
literal|"mi"
argument_list|)
expr_stmt|;
name|TF_standout_motion
operator|=
name|tgetflag
argument_list|(
literal|"ms"
argument_list|)
expr_stmt|;
name|TF_underscore
operator|=
name|tgetflag
argument_list|(
literal|"ul"
argument_list|)
expr_stmt|;
name|MagicWrap
operator|=
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
expr_stmt|;
name|TF_teleray
operator|=
name|tgetflag
argument_list|(
literal|"xt"
argument_list|)
expr_stmt|;
comment|/* Get screen size fro system, or else from termcap.  */
name|get_screen_size
argument_list|(
operator|&
name|screen_width
argument_list|,
operator|&
name|screen_height
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen_width
operator|<=
literal|0
condition|)
name|screen_width
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen_height
operator|<=
literal|0
condition|)
name|screen_height
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|min_padding_speed
operator|=
name|tgetnum
argument_list|(
literal|"pb"
argument_list|)
expr_stmt|;
name|TN_standout_width
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
expr_stmt|;
name|TabWidth
operator|=
name|tgetnum
argument_list|(
literal|"tw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|Left
operator|=
literal|"\b"
expr_stmt|;
comment|/* can't possibly be longer! */
elseif|else
if|if
condition|(
operator|!
name|Left
condition|)
name|Left
operator|=
name|tgetstr
argument_list|(
literal|"le"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Down
condition|)
name|Down
operator|=
name|tgetstr
argument_list|(
literal|"do"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TS_bell
condition|)
name|TS_bell
operator|=
literal|"\07"
expr_stmt|;
if|if
condition|(
operator|!
name|TS_fwd_scroll
condition|)
name|TS_fwd_scroll
operator|=
name|Down
expr_stmt|;
name|PC
operator|=
name|TS_pad_char
condition|?
operator|*
name|TS_pad_char
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|TabWidth
operator|<
literal|0
condition|)
name|TabWidth
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|Tab
condition|)
name|Tab
operator|=
literal|"\t"
expr_stmt|;
if|if
condition|(
name|TS_standout_mode
operator|==
literal|0
condition|)
block|{
name|TN_standout_width
operator|=
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
expr_stmt|;
name|TS_end_standout_mode
operator|=
name|tgetstr
argument_list|(
literal|"ue"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
name|TS_standout_mode
operator|=
name|tgetstr
argument_list|(
literal|"us"
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TF_teleray
condition|)
block|{
name|Tab
operator|=
literal|0
expr_stmt|;
comment|/* Teleray: most programs want a space in front of TS_standout_mode, 	   but Emacs can do without it (and give one extra column).  */
name|TS_standout_mode
operator|=
literal|"\033RD"
expr_stmt|;
name|TN_standout_width
operator|=
literal|1
expr_stmt|;
comment|/* But that means we cannot rely on ^M to go to column zero! */
name|CR
operator|=
literal|0
expr_stmt|;
comment|/* LF can't be trusted either -- can alter hpos */
comment|/* if move at column 0 thru a line with TS_standout_mode */
name|Down
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Special handling for certain terminal types known to need it */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|terminal_type
argument_list|,
literal|"supdup"
argument_list|)
condition|)
block|{
name|memory_below_screen
operator|=
literal|1
expr_stmt|;
name|Wcm
operator|.
name|cm_losewrap
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|terminal_type
argument_list|,
literal|"c10"
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|terminal_type
argument_list|,
literal|"perq"
argument_list|)
condition|)
block|{
comment|/* Supply a makeshift :wi string. 	 This string is not valid in general since it works only 	 for windows starting at the upper left corner; 	 but that is all Emacs uses.  	 This string works only if the screen is using 	 the top of the video memory, because addressing is memory-relative. 	 So first check the :ti string to see if that is true.  	 It would be simpler if the :wi string could go in the termcap 	 entry, but it can't because it is not fully valid. 	 If it were in the termcap entry, it would confuse other programs.  */
if|if
condition|(
operator|!
name|TS_set_window
condition|)
block|{
name|p
operator|=
name|TS_termcap_modes
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"\033v  "
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|TS_set_window
operator|=
literal|"\033v%C %C %C %C "
expr_stmt|;
block|}
comment|/* Termcap entry often fails to have :in: flag */
name|must_write_spaces
operator|=
literal|1
expr_stmt|;
comment|/* :ti string typically fails to have \E^G! in it */
comment|/* This limits scope of insert-char to one line.  */
name|strcpy
argument_list|(
name|fill
argument_list|,
name|TS_termcap_modes
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fill
argument_list|,
literal|"\033\007!"
argument_list|)
expr_stmt|;
name|TS_termcap_modes
operator|=
name|fill
expr_stmt|;
name|fill
operator|+=
name|strlen
argument_list|(
name|fill
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|combuf
expr_stmt|;
comment|/* Change all %+ parameters to %C, to handle 	 values above 96 correctly for the C100.  */
while|while
condition|(
name|p
operator|!=
name|fill
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
name|p
index|[
literal|1
index|]
operator|=
literal|'C'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|screen_height
operator|=
name|min
argument_list|(
name|screen_height
argument_list|,
name|MScreenLength
argument_list|)
expr_stmt|;
name|screen_width
operator|=
name|min
argument_list|(
name|screen_width
argument_list|,
name|MScreenWidth
argument_list|)
expr_stmt|;
name|ScreenRows
operator|=
name|screen_height
expr_stmt|;
name|ScreenCols
operator|=
name|screen_width
expr_stmt|;
name|specified_window
operator|=
name|screen_height
expr_stmt|;
if|if
condition|(
name|Wcm_init
argument_list|()
condition|)
comment|/* can't do cursor motion */
name|fatal
argument_list|(
literal|"Terminal type \"%s\" is not powerful enough to run Emacs.\n\ It lacks the ability to position the cursor.\n\ If that is not the actual type of terminal you have,\n\ use the C-shell command `setenv TERM ...' to specify the correct type.\n"
argument_list|,
name|terminal_type
argument_list|)
expr_stmt|;
name|delete_in_insert_mode
operator|=
name|TS_delete_mode
operator|&&
name|TS_insert_mode
operator|&&
operator|!
name|strcmp
argument_list|(
name|TS_delete_mode
argument_list|,
name|TS_insert_mode
argument_list|)
expr_stmt|;
name|se_is_so
operator|=
name|TS_standout_mode
operator|&&
name|TS_end_standout_mode
operator|&&
operator|!
name|strcmp
argument_list|(
name|TS_standout_mode
argument_list|,
name|TS_end_standout_mode
argument_list|)
expr_stmt|;
comment|/* Remove width of standout marker from usable width of line */
if|if
condition|(
name|TN_standout_width
operator|>
literal|0
condition|)
name|screen_width
operator|-=
name|TN_standout_width
expr_stmt|;
name|UseTabs
operator|=
name|tabs_safe_p
argument_list|()
operator|&&
name|TabWidth
operator|==
literal|8
expr_stmt|;
name|scroll_region_ok
operator|=
name|TS_set_window
operator|||
name|TS_set_scroll_region
operator|||
name|TS_set_scroll_region_1
expr_stmt|;
name|line_ins_del_ok
operator|=
operator|(
operator|(
operator|(
name|TS_ins_line
operator|||
name|TS_ins_multi_lines
operator|)
operator|&&
operator|(
name|TS_del_line
operator|||
name|TS_del_multi_lines
operator|)
operator|)
operator|||
operator|(
name|scroll_region_ok
operator|&&
name|TS_fwd_scroll
operator|&&
name|TS_rev_scroll
operator|)
operator|)
expr_stmt|;
name|char_ins_del_ok
operator|=
operator|(
operator|(
name|TS_ins_char
operator|||
name|TS_ins_multi_chars
operator|)
operator|&&
operator|(
name|TS_del_char
operator|||
name|TS_del_multi_chars
operator|)
operator|)
expr_stmt|;
name|fast_clear_end_of_line
operator|=
name|TS_clr_line
operator|!=
literal|0
expr_stmt|;
name|init_baud_rate
argument_list|()
expr_stmt|;
if|if
condition|(
name|read_socket_hook
condition|)
comment|/* Baudrate is somewhat */
comment|/* meaningless in this case */
name|baud_rate
operator|=
literal|9600
expr_stmt|;
name|calculate_costs
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS 1 */
end_comment

begin_macro
name|fatal
argument_list|(
argument|str
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

