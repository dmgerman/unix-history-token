begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Newly written part of redisplay code.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"cm.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* Nonzero means do not assume anything about current  contents of actual terminal screen */
end_comment

begin_decl_stmt
name|int
name|screen_garbaged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Desired terminal cursor position (to show position of point),  origin zero */
end_comment

begin_decl_stmt
name|int
name|cursX
decl_stmt|,
name|cursY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means last display completed and cursor is really at cursX, cursY.  Zero means it was preempted. */
end_comment

begin_decl_stmt
name|int
name|display_completed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If true and the terminal will support it 			   then the screen will flash instead of 			   feeping when an error occurs */
end_comment

begin_decl_stmt
name|int
name|inverse_video
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If true and the terminal will support it 			   then we will use inverse video */
end_comment

begin_decl_stmt
name|int
name|baud_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal speed, so we can calculate 			   the number of characters required to 			   make the cursor sit still for n secs. */
end_comment

begin_comment
comment|/* the current (physical) screen */
end_comment

begin_decl_stmt
name|struct
name|display_line
modifier|*
name|PhysScreen
index|[
name|MScreenLength
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary Copy of PhysScreen made in update_screen */
end_comment

begin_decl_stmt
name|struct
name|display_line
modifier|*
name|OPhysScreen
index|[
name|MScreenLength
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the desired (virtual) screen */
end_comment

begin_decl_stmt
name|struct
name|display_line
modifier|*
name|DesiredScreen
index|[
name|MScreenLength
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record here all the display line objects, for debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|display_line
modifier|*
name|all_lines
index|[
literal|2
operator|*
name|MScreenLength
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|termscript
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stdio stream being used for copy of all kbdinput.  */
end_comment

begin_decl_stmt
name|struct
name|cm
name|Wcm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for info on cursor positioning */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output speed (from sg_ospeed) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Use these to chain together free lines */
end_comment

begin_define
define|#
directive|define
name|LINE_NEXT
parameter_list|(
name|l
parameter_list|)
value|(*(struct display_line **) l)
end_define

begin_define
define|#
directive|define
name|SET_LINE_NEXT
parameter_list|(
name|l
parameter_list|,
name|next
parameter_list|)
value|(*((struct display_line **) l) = next)
end_define

begin_comment
comment|/* Chain of free display_line structures, chained thru LINE_NEXT.  */
end_comment

begin_decl_stmt
name|struct
name|display_line
modifier|*
name|free_display_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines now free.  */
end_comment

begin_decl_stmt
name|int
name|free_line_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate as many display_line structures    as we are ever supposed to need.    Called at startup, and also if screen size is changed.  */
end_comment

begin_macro
name|make_display_lines
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
comment|/* First, free any that are already allocated */
for|for
control|(
name|p
operator|=
name|free_display_lines
init|;
name|p
condition|;
control|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|LINE_NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|free_display_lines
operator|=
literal|0
expr_stmt|;
name|free_line_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MScreenLength
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|PhysScreen
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|PhysScreen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PhysScreen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|screen_garbaged
operator|=
literal|1
expr_stmt|;
comment|/* Now allocate as many as we can possibly validly need */
for|for
control|(
name|i
operator|=
operator|-
name|screen_height
init|;
name|i
operator|<
name|screen_height
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|(
expr|struct
name|display_line
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|display_line
argument_list|)
operator|+
name|screen_width
operator|-
name|MScreenWidth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_LINE_NEXT
argument_list|(
name|p
argument_list|,
name|free_display_lines
argument_list|)
expr_stmt|;
name|free_display_lines
operator|=
name|p
expr_stmt|;
name|all_lines
index|[
name|i
operator|+
name|screen_height
index|]
operator|=
name|p
expr_stmt|;
block|}
name|free_line_count
operator|=
literal|2
operator|*
name|screen_height
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Get one of the previously malloc'd display_line structures    from the free pool.  */
end_comment

begin_function
name|struct
name|display_line
modifier|*
name|new_display_line
parameter_list|()
block|{
specifier|register
name|struct
name|display_line
modifier|*
name|p
init|=
name|free_display_lines
decl_stmt|;
comment|/* If we ever use up all the display lines that have been      allocated, it indicates a bug, since we are supposed      to need at most two for each line on the screen.  */
if|if
condition|(
operator|!
name|p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free_display_lines
operator|=
name|LINE_NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|body
operator|-
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|SET_LINE_NEXT
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|display_line
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark as in use.  */
name|free_line_count
operator|--
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Put a display_line back in the free pool.  */
end_comment

begin_macro
name|return_display_line
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|display_line
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
operator|(
name|int
operator|)
name|LINE_NEXT
argument_list|(
name|p
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Already free.  */
name|SET_LINE_NEXT
argument_list|(
name|p
argument_list|,
name|free_display_lines
argument_list|)
expr_stmt|;
name|free_display_lines
operator|=
name|p
expr_stmt|;
name|free_line_count
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|clear_screen_records
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|screen_height
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|PhysScreen
index|[
name|i
index|]
condition|)
name|return_display_line
argument_list|(
name|PhysScreen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|PhysScreen
argument_list|,
operator|(
name|screen_height
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|PhysScreen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return the hash code of display_line p.  */
end_comment

begin_expr_stmt
name|line_hash_code
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|display_line
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|body
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|h
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
comment|/* Give all lighlighted lines the same hash code      so as to encourage scrolling to leave them in place.  */
if|if
condition|(
name|p
operator|->
name|highlighted
condition|)
return|return
operator|-
literal|1
return|;
name|body
operator|=
name|p
operator|->
name|body
expr_stmt|;
name|end
operator|=
name|body
operator|+
name|p
operator|->
name|length
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|must_write_spaces
condition|)
block|{
while|while
condition|(
operator|*
name|body
operator|++
operator|==
literal|' '
condition|)
empty_stmt|;
name|body
operator|--
expr_stmt|;
if|if
condition|(
name|body
operator|==
name|end
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|end
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|body
operator|!=
name|end
condition|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|5
operator|)
operator|+
name|h
operator|+
operator|*
name|body
operator|++
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Return number of characters in display_line p,    except don't count leading and trailing spaces    unless the terminal requires those to be explicitly output.  */
end_comment

begin_macro
name|line_draw_cost
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|display_line
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|body
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|must_write_spaces
condition|)
return|return
name|p
operator|->
name|length
return|;
name|body
operator|=
name|p
operator|->
name|body
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|->
name|length
init|;
name|i
operator|>
literal|0
operator|&&
name|body
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|' '
condition|;
name|i
operator|--
control|)
empty_stmt|;
name|i
operator|-=
name|count_blanks
argument_list|(
name|p
operator|->
name|body
argument_list|)
expr_stmt|;
return|return
name|max
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The functions on this page are the interface from xdisp.c to redisplay.  They take cursor position arguments in origin 0.   The only other interface into redisplay is through setting  cursX and cursY (in xdisp.c) and setting screen_garbaged. */
end_comment

begin_comment
comment|/* cancel_line eliminates any request to display a line at position `vpos' */
end_comment

begin_macro
name|cancel_line
argument_list|(
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|return_display_line
argument_list|(
name|DesiredScreen
index|[
name|vpos
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|DesiredScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Get a display_line for displaying on line `vpos'  and set it up for outputting starting at `hpos' within it.  */
end_comment

begin_function
name|struct
name|display_line
modifier|*
name|get_display_line
parameter_list|(
name|vpos
parameter_list|,
name|hpos
parameter_list|)
name|int
name|vpos
decl_stmt|;
specifier|register
name|int
name|hpos
decl_stmt|;
block|{
specifier|register
name|struct
name|display_line
modifier|*
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|vpos
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|line
operator|=
name|DesiredScreen
index|[
name|vpos
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|line
operator|&&
name|line
operator|->
name|length
operator|>
name|hpos
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
name|line
operator|=
name|new_display_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|hpos
operator|>
name|line
operator|->
name|length
condition|)
block|{
name|p
operator|=
name|line
operator|->
name|body
operator|+
name|line
operator|->
name|length
expr_stmt|;
name|hpos
operator|-=
name|line
operator|->
name|length
expr_stmt|;
name|line
operator|->
name|length
operator|+=
name|hpos
expr_stmt|;
while|while
condition|(
operator|--
name|hpos
operator|>=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|DesiredScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|=
name|line
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_comment
comment|/* Scroll lines from vpos `from' up to but not including vpos `end'  down by `amount' lines (`amount' may be negative).  Returns nonzero if done, zero if terminal cannot scroll them. */
end_comment

begin_function
name|int
name|scroll_screen_lines
parameter_list|(
name|from
parameter_list|,
name|end
parameter_list|,
name|amount
parameter_list|)
name|int
name|from
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|line_ins_del_ok
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
name|set_terminal_window
argument_list|(
name|end
operator|+
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scroll_region_ok
condition|)
name|ins_del_lines
argument_list|(
name|end
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|ins_del_lines
argument_list|(
name|from
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|end
operator|+
name|amount
init|;
name|i
operator|>=
name|end
operator|+
literal|1
condition|;
name|i
operator|--
control|)
name|return_display_line
argument_list|(
name|PhysScreen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|end
init|;
name|i
operator|>=
name|from
operator|+
literal|1
condition|;
name|i
operator|--
control|)
name|PhysScreen
index|[
name|i
operator|+
name|amount
index|]
operator|=
name|PhysScreen
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
operator|+
name|amount
init|;
name|i
operator|>=
name|from
operator|+
literal|1
condition|;
name|i
operator|--
control|)
name|PhysScreen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|set_terminal_window
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|ins_del_lines
argument_list|(
name|from
operator|+
name|amount
argument_list|,
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scroll_region_ok
condition|)
name|ins_del_lines
argument_list|(
name|end
operator|+
name|amount
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
operator|+
name|amount
operator|+
literal|1
init|;
name|i
operator|<=
name|from
condition|;
name|i
operator|++
control|)
name|return_display_line
argument_list|(
name|PhysScreen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
operator|+
literal|1
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|i
operator|+
name|amount
index|]
operator|=
name|PhysScreen
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|end
operator|+
name|amount
operator|+
literal|1
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* After updating a window w that isn't the full screen wide,  copy all the columns that w does not occupy  into the DesiredScreen lines from the PhysScreen lines  so that update_screen will not change those columns.  */
end_comment

begin_macro
name|preserve_other_columns
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|vpos
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|int
name|start
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
decl_stmt|;
name|int
name|bot
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
decl_stmt|;
for|for
control|(
name|vpos
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
init|;
name|vpos
operator|<
name|bot
condition|;
name|vpos
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l1
operator|=
name|DesiredScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|l2
operator|=
name|PhysScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|l2
operator|->
name|body
argument_list|,
name|l1
operator|->
name|body
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|->
name|length
operator|<
name|start
operator|&&
name|l1
operator|->
name|length
operator|<
name|l2
operator|->
name|length
condition|)
name|l1
operator|->
name|length
operator|=
name|min
argument_list|(
name|start
argument_list|,
name|l2
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l2
operator|->
name|length
operator|>
name|end
operator|&&
name|l1
operator|->
name|length
operator|<
name|l2
operator|->
name|length
condition|)
block|{
while|while
condition|(
name|l1
operator|->
name|length
operator|<
name|end
condition|)
name|l1
operator|->
name|body
index|[
name|l1
operator|->
name|length
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|l2
operator|->
name|body
operator|+
name|end
argument_list|,
name|l1
operator|->
name|body
operator|+
name|end
argument_list|,
name|l2
operator|->
name|length
operator|-
name|end
argument_list|)
expr_stmt|;
name|l1
operator|->
name|length
operator|=
name|l2
operator|->
name|length
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_comment
comment|/* If window w does not need to be updated and isn't the full screen wide,  copy all the columns that w does occupy  into the DesiredScreen lines from the PhysScreen lines  so that update_screen will not change those columns.   Have not been able to figure out how to use this correctly.  */
end_comment

begin_macro
name|preserve_my_columns
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|vpos
decl_stmt|,
name|fin
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|int
name|start
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
decl_stmt|;
name|int
name|bot
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
decl_stmt|;
for|for
control|(
name|vpos
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
init|;
name|vpos
operator|<
name|bot
condition|;
name|vpos
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l1
operator|=
name|DesiredScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|l2
operator|=
name|PhysScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|l2
operator|->
name|length
operator|>
name|start
operator|&&
name|l1
operator|->
name|length
operator|<
name|l2
operator|->
name|length
condition|)
block|{
name|fin
operator|=
name|l2
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|fin
operator|>
name|end
condition|)
name|fin
operator|=
name|end
expr_stmt|;
while|while
condition|(
name|l1
operator|->
name|length
operator|<
name|start
condition|)
name|l1
operator|->
name|body
index|[
name|l1
operator|->
name|length
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|l2
operator|->
name|body
operator|+
name|start
argument_list|,
name|l1
operator|->
name|body
operator|+
name|start
argument_list|,
name|fin
operator|-
name|start
argument_list|)
expr_stmt|;
name|l1
operator|->
name|length
operator|=
name|fin
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTDEF */
end_comment

begin_escape
end_escape

begin_comment
comment|/* On discovering that the redisplay for a window was no good,  cancel the columns of that window,  so that when the window is displayed over again  get_display_line will not complain. */
end_comment

begin_macro
name|cancel_my_columns
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|vpos
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|start
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
decl_stmt|;
specifier|register
name|int
name|bot
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
decl_stmt|;
for|for
control|(
name|vpos
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
init|;
name|vpos
operator|<
name|bot
condition|;
name|vpos
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|DesiredScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|)
operator|&&
name|l
operator|->
name|length
operator|>=
name|start
condition|)
name|l
operator|->
name|length
operator|=
name|start
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|direct_output_for_insert
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|display_line
modifier|*
name|p
init|=
name|PhysScreen
index|[
name|cursY
operator|+
literal|1
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILER_REGISTER_BUG
specifier|register
endif|#
directive|endif
endif|COMPILER_REGISTER_BUG
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILER_REGISTER_BUG
specifier|register
endif|#
directive|endif
endif|COMPILER_REGISTER_BUG
name|int
name|hpos
init|=
name|cursX
decl_stmt|;
comment|/* Give up if about to continue line */
if|if
condition|(
name|hpos
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|+
literal|1
operator|+
literal|1
operator|>=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
condition|)
return|return;
comment|/* Avoid losing if cursor is in invisible text off left margin */
if|if
condition|(
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
operator|&&
name|hpos
operator|==
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
condition|)
return|return;
comment|/* Give up if cursor outside window (in minibuf, probably) */
if|if
condition|(
name|cursY
operator|<
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|||
name|cursY
operator|>=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
condition|)
return|return;
comment|/* Give up if cursor not really at cursX, cursY */
if|if
condition|(
operator|!
name|display_completed
condition|)
return|return;
comment|/* Give up if w is minibuffer and a message is being displayed there */
if|if
condition|(
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|minibuf_message
condition|)
return|return;
name|p
operator|->
name|body
index|[
name|hpos
index|]
operator|=
name|c
expr_stmt|;
name|unchanged_modified
operator|=
name|bf_modified
expr_stmt|;
name|beg_unchanged
operator|=
name|bf_s1
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
operator|=
name|point
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_x
argument_list|)
operator|=
name|cursX
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
name|bf_modified
expr_stmt|;
name|reassert_line_highlight
argument_list|(
literal|0
argument_list|,
name|cursY
argument_list|)
expr_stmt|;
name|write_chars
argument_list|(
name|p
operator|->
name|body
operator|+
name|hpos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|cursX
expr_stmt|;
name|p
operator|->
name|length
operator|=
name|max
argument_list|(
name|p
operator|->
name|length
argument_list|,
name|cursX
argument_list|)
expr_stmt|;
name|p
operator|->
name|body
index|[
name|p
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|direct_output_forward_char
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
comment|/* Avoid losing if cursor is in invisible text off left margin */
if|if
condition|(
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
operator|&&
name|cursX
operator|==
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
condition|)
return|return;
name|cursX
operator|+=
name|n
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_x
argument_list|)
operator|=
name|cursX
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
operator|=
name|point
expr_stmt|;
name|topos
argument_list|(
name|cursY
argument_list|,
name|cursX
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* At the time this function is called,  no line is common to PhysScreen and DesiredScreen.  That is true again when this function returns. */
end_comment

begin_comment
comment|/* `force' nonzero means do not stop for pending input */
end_comment

begin_comment
comment|/* Value is nonzero if redisplay stopped due to pending input */
end_comment

begin_macro
name|update_screen
argument_list|(
argument|force
argument_list|,
argument|inhibit_hairy_id
argument_list|)
end_macro

begin_decl_stmt
name|int
name|force
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inhibit_hairy_id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|display_line
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|l
decl_stmt|,
modifier|*
name|lnew
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pause
decl_stmt|;
name|int
name|preempt_count
decl_stmt|;
name|int
name|outq
decl_stmt|;
extern|extern input_pending;
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Some bug zeros some core */
name|bcopy
argument_list|(
name|PhysScreen
argument_list|,
name|OPhysScreen
argument_list|,
sizeof|sizeof
name|PhysScreen
argument_list|)
expr_stmt|;
name|detect_input_pending
argument_list|()
expr_stmt|;
if|if
condition|(
name|input_pending
operator|&&
operator|!
name|force
condition|)
block|{
name|pause
operator|=
literal|1
expr_stmt|;
goto|goto
name|do_pause
goto|;
block|}
name|update_begin
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|line_ins_del_ok
condition|)
name|inhibit_hairy_id
operator|=
literal|1
expr_stmt|;
comment|/* Don't compute for i/d line if just want cursor motion. */
for|for
control|(
name|p
operator|=
operator|&
name|DesiredScreen
index|[
name|screen_height
index|]
init|;
name|p
operator|!=
name|DesiredScreen
operator|&&
operator|*
name|p
operator|==
literal|0
condition|;
name|p
operator|--
control|)
empty_stmt|;
comment|/* Try doing i/d line, if not yet inhibited.  */
if|if
condition|(
operator|!
name|inhibit_hairy_id
operator|&&
name|p
operator|!=
name|DesiredScreen
condition|)
name|force
operator||=
name|scrolling
argument_list|()
expr_stmt|;
comment|/* Update the individual lines as needed.  Do bottom line first.  */
name|l
operator|=
name|DesiredScreen
index|[
name|screen_height
index|]
expr_stmt|;
if|if
condition|(
name|l
operator|&&
name|l
operator|!=
name|PhysScreen
index|[
name|screen_height
index|]
condition|)
name|update_line
argument_list|(
name|PhysScreen
index|[
name|screen_height
index|]
argument_list|,
name|l
argument_list|,
name|screen_height
operator|-
literal|1
argument_list|)
expr_stmt|;
name|preempt_count
operator|=
name|baud_rate
operator|/
literal|2400
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|screen_height
operator|&&
operator|(
name|force
operator|||
operator|!
name|input_pending
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|PhysScreen
index|[
name|i
index|]
expr_stmt|;
name|lnew
operator|=
name|DesiredScreen
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lnew
operator|&&
name|lnew
operator|!=
name|l
condition|)
block|{
comment|/* Flush out every so many lines. 	       Also flush out if likely to have more than 1k buffered otherwise. 	       I'm told that telnet connections get really screwed by more 	       than 1k output at once.  */
name|outq
operator|=
name|stdout
operator|->
name|_ptr
operator|-
name|stdout
operator|->
name|_base
expr_stmt|;
if|if
condition|(
name|outq
operator|>
operator|(
operator|(
operator|--
name|preempt_count
operator|<
literal|0
operator|)
condition|?
literal|20
else|:
literal|900
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|<
literal|2400
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCOUTQ
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCOUTQ
argument_list|,
operator|&
name|outq
argument_list|)
operator|<
literal|0
condition|)
comment|/* Probably not a tty.  Ignore the error and reset 		       * the outq count. */
name|outq
operator|=
name|stdout
operator|->
name|_ptr
operator|-
name|stdout
operator|->
name|_base
expr_stmt|;
endif|#
directive|endif
name|outq
operator|*=
literal|10
expr_stmt|;
name|outq
operator|/=
name|baud_rate
expr_stmt|;
comment|/* outq is now in seconds */
if|if
condition|(
name|outq
condition|)
name|sleep
argument_list|(
name|outq
argument_list|)
expr_stmt|;
block|}
name|detect_input_pending
argument_list|()
expr_stmt|;
name|preempt_count
operator|=
name|baud_rate
operator|/
literal|2400
expr_stmt|;
block|}
comment|/* Now update this line.  */
name|update_line
argument_list|(
name|l
argument_list|,
name|lnew
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|pause
operator|=
operator|(
name|i
operator|<
name|screen_height
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
comment|/* Now just clean up termcap drivers and set cursor, etc.  */
if|if
condition|(
operator|!
name|pause
condition|)
name|topos
argument_list|(
name|cursY
argument_list|,
name|max
argument_list|(
name|min
argument_list|(
name|cursX
argument_list|,
name|screen_width
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|update_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|termscript
condition|)
name|fflush
argument_list|(
name|termscript
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|do_pause
label|:
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Some bug zeros some core */
name|display_completed
operator|=
operator|!
name|pause
expr_stmt|;
comment|/* Free any lines still in desired screen but not in phys screen */
comment|/* Free any lines that used to be in phys screen but are no longer */
for|for
control|(
name|p
operator|=
operator|&
name|PhysScreen
index|[
name|screen_height
index|]
init|;
name|p
operator|!=
name|PhysScreen
condition|;
name|p
operator|--
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
condition|)
name|p
index|[
literal|0
index|]
operator|->
name|physical
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|DesiredScreen
index|[
name|screen_height
index|]
init|;
name|p
operator|!=
name|DesiredScreen
condition|;
name|p
operator|--
control|)
block|{
if|if
condition|(
name|l
operator|=
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|l
operator|->
name|physical
condition|)
block|{
name|return_display_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* Prevent line in both DesiredScreen and OPhysScreen 		   from being freed twice.  */
name|l
operator|->
name|physical
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
operator|&
name|OPhysScreen
index|[
name|screen_height
index|]
init|;
name|p
operator|!=
name|OPhysScreen
condition|;
name|p
operator|--
control|)
block|{
if|if
condition|(
name|l
operator|=
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|l
operator|->
name|physical
condition|)
name|return_display_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|PhysScreen
index|[
name|screen_height
index|]
init|;
name|p
operator|!=
name|PhysScreen
condition|;
name|p
operator|--
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|->
name|physical
operator|=
literal|0
expr_stmt|;
block|}
block|{
specifier|extern
name|int
name|debug_end_pos
decl_stmt|;
if|if
condition|(
name|debug_end_pos
operator|&&
name|i
operator|+
name|free_line_count
operator|!=
literal|2
operator|*
name|screen_height
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|bzero
argument_list|(
name|OPhysScreen
argument_list|,
operator|(
name|screen_height
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|OPhysScreen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|DesiredScreen
argument_list|,
operator|(
name|screen_height
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|DesiredScreen
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|pause
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Decide what insert/delete line to do, and do it */
end_comment

begin_macro
name|scrolling
argument_list|()
end_macro

begin_block
block|{
name|int
name|unchanged_at_top
decl_stmt|,
name|unchanged_at_bottom
decl_stmt|;
name|int
name|window_size
decl_stmt|;
name|int
name|changed_lines
decl_stmt|;
name|int
modifier|*
name|old_hash
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|new_hash
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|draw_cost
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|free_at_end_vpos
init|=
name|screen_height
decl_stmt|;
comment|/* Compute hash codes of all the lines.      Also calculate number of changed lines,      number of unchanged lines at the beginning,      and number of unchanged lines at the end.  */
name|changed_lines
operator|=
literal|0
expr_stmt|;
name|unchanged_at_top
operator|=
literal|0
expr_stmt|;
name|unchanged_at_bottom
operator|=
name|screen_height
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_height
condition|;
name|i
operator|++
control|)
block|{
name|old_hash
index|[
name|i
index|]
operator|=
name|line_hash_code
argument_list|(
name|PhysScreen
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DesiredScreen
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|DesiredScreen
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|PhysScreen
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|PhysScreen
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|DesiredScreen
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|new_hash
index|[
name|i
index|]
operator|=
name|old_hash
index|[
name|i
index|]
expr_stmt|;
else|else
name|new_hash
index|[
name|i
index|]
operator|=
name|line_hash_code
argument_list|(
name|DesiredScreen
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_hash
index|[
name|i
index|]
operator|!=
name|new_hash
index|[
name|i
index|]
condition|)
block|{
name|changed_lines
operator|++
expr_stmt|;
name|unchanged_at_bottom
operator|=
name|screen_height
operator|-
name|i
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|unchanged_at_top
condition|)
name|unchanged_at_top
operator|++
expr_stmt|;
name|draw_cost
index|[
name|i
index|]
operator|=
name|line_draw_cost
argument_list|(
name|DesiredScreen
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If changed lines are few, don't allow preemption, don't scroll.  */
if|if
condition|(
name|changed_lines
operator|<
name|baud_rate
operator|/
literal|2400
operator|||
name|unchanged_at_bottom
operator|==
name|screen_height
condition|)
return|return
literal|1
return|;
name|window_size
operator|=
name|screen_height
operator|-
name|unchanged_at_top
operator|-
name|unchanged_at_bottom
expr_stmt|;
if|if
condition|(
name|scroll_region_ok
condition|)
name|free_at_end_vpos
operator|-=
name|unchanged_at_bottom
expr_stmt|;
elseif|else
if|if
condition|(
name|memory_below_screen
condition|)
name|free_at_end_vpos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If large window, fast terminal and few lines in common between      PhysScreen and DesiredScreen, don't bother with i/d calc.  */
if|if
condition|(
name|window_size
operator|>=
literal|18
operator|&&
name|baud_rate
operator|>
literal|2400
operator|&&
operator|(
name|window_size
operator|>=
literal|10
operator|*
name|scrolling_max_lines_saved
argument_list|(
name|unchanged_at_top
argument_list|,
name|screen_height
operator|-
name|unchanged_at_bottom
argument_list|,
name|old_hash
argument_list|,
name|new_hash
argument_list|,
name|draw_cost
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|scrolling_1
argument_list|(
name|window_size
argument_list|,
name|unchanged_at_top
argument_list|,
name|unchanged_at_bottom
argument_list|,
name|draw_cost
operator|+
name|unchanged_at_top
operator|-
literal|1
argument_list|,
name|old_hash
operator|+
name|unchanged_at_top
operator|-
literal|1
argument_list|,
name|new_hash
operator|+
name|unchanged_at_top
operator|-
literal|1
argument_list|,
name|free_at_end_vpos
operator|-
name|unchanged_at_top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|update_line
argument_list|(
argument|old
argument_list|,
argument|new
argument_list|,
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|display_line
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|obody
decl_stmt|,
modifier|*
name|nbody
decl_stmt|,
modifier|*
name|op1
decl_stmt|,
modifier|*
name|op2
decl_stmt|,
modifier|*
name|np1
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|int
name|osp
decl_stmt|,
name|nsp
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|olen
decl_stmt|,
name|nlen
decl_stmt|;
name|int
name|save
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
return|return;
comment|/* Mark physical screen as containing the line `new' */
name|PhysScreen
index|[
name|vpos
operator|+
literal|1
index|]
operator|=
name|new
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|&&
name|new
operator|->
name|highlighted
operator|)
operator|!=
operator|(
name|old
operator|&&
name|old
operator|->
name|highlighted
operator|)
condition|)
block|{
name|change_line_highlight
argument_list|(
name|new
operator|&&
name|new
operator|->
name|highlighted
argument_list|,
name|vpos
argument_list|,
name|old
condition|?
name|old
operator|->
name|length
else|:
literal|0
argument_list|)
expr_stmt|;
name|old
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|reassert_line_highlight
argument_list|(
name|new
operator|&&
name|new
operator|->
name|highlighted
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
block|{
name|olen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|obody
operator|=
name|old
operator|->
name|body
expr_stmt|;
name|olen
operator|=
name|old
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|must_write_spaces
condition|)
while|while
condition|(
name|obody
index|[
name|olen
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|olen
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|nlen
operator|=
literal|0
expr_stmt|;
goto|goto
name|just_erase
goto|;
block|}
name|nbody
operator|=
name|new
operator|->
name|body
expr_stmt|;
name|nlen
operator|=
name|new
operator|->
name|length
expr_stmt|;
comment|/* We know that the previous character is the `physical' field      and it is zero or one.  */
if|if
condition|(
operator|!
name|must_write_spaces
condition|)
while|while
condition|(
name|nbody
index|[
name|nlen
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|nlen
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|olen
condition|)
block|{
name|nsp
operator|=
operator|(
name|must_write_spaces
operator|||
name|new
operator|->
name|highlighted
operator|)
condition|?
literal|0
else|:
name|count_blanks
argument_list|(
name|nbody
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlen
operator|>
name|nsp
condition|)
block|{
name|topos
argument_list|(
name|vpos
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
name|write_chars
argument_list|(
name|nbody
operator|+
name|nsp
argument_list|,
name|nlen
operator|-
name|nsp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|obody
index|[
name|olen
index|]
operator|=
literal|1
expr_stmt|;
name|save
operator|=
name|nbody
index|[
name|nlen
index|]
expr_stmt|;
name|nbody
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Compute number of leading blanks in old and new contents.  */
name|osp
operator|=
name|count_blanks
argument_list|(
name|obody
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|->
name|highlighted
condition|)
name|nsp
operator|=
name|count_blanks
argument_list|(
name|nbody
argument_list|)
expr_stmt|;
else|else
name|nsp
operator|=
literal|0
expr_stmt|;
comment|/* Compute number of matching chars starting with first nonblank.  */
name|m1
operator|=
name|count_match
argument_list|(
name|obody
operator|+
name|osp
argument_list|,
name|nbody
operator|+
name|nsp
argument_list|)
expr_stmt|;
comment|/* Spaces in new match implicit space past the end of old.  */
comment|/* This isn't really doing anything; osp should be osp + m1.      I don't dare fix it now since maybe if it does anything      it will do something bad.  */
if|if
condition|(
operator|!
name|must_write_spaces
operator|&&
name|osp
operator|==
name|olen
condition|)
block|{
name|np1
operator|=
name|nbody
operator|+
name|nsp
expr_stmt|;
while|while
condition|(
name|np1
index|[
name|m1
index|]
operator|==
literal|' '
condition|)
name|m1
operator|++
expr_stmt|;
block|}
comment|/* Avoid doing insert/delete char      just cause number of leading spaces differs      when the following text does not match. */
if|if
condition|(
name|m1
operator|==
literal|0
operator|&&
name|osp
operator|!=
name|nsp
condition|)
name|osp
operator|=
name|nsp
operator|=
name|min
argument_list|(
name|osp
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
comment|/* Find matching characters at end of line */
name|op1
operator|=
name|obody
operator|+
name|olen
expr_stmt|;
name|np1
operator|=
name|nbody
operator|+
name|nlen
expr_stmt|;
name|op2
operator|=
name|op1
operator|+
name|m1
operator|-
name|min
argument_list|(
name|olen
operator|-
name|osp
argument_list|,
name|nlen
operator|-
name|nsp
argument_list|)
expr_stmt|;
while|while
condition|(
name|op1
operator|>
name|op2
operator|&&
name|op1
index|[
operator|-
literal|1
index|]
operator|==
name|np1
index|[
operator|-
literal|1
index|]
condition|)
block|{
name|op1
operator|--
expr_stmt|;
name|np1
operator|--
expr_stmt|;
block|}
name|m2
operator|=
name|obody
operator|+
name|olen
operator|-
name|op1
expr_stmt|;
comment|/* Put correct value back in nbody[nlen].      This is important because direct_output_for_insert      can write into the line at a later point.  */
name|nbody
index|[
name|nlen
index|]
operator|=
name|save
expr_stmt|;
comment|/* tem gets the distance to insert or delete.      m2 is how many characters we save by doing so.      Is it worth it?  */
name|tem
operator|=
operator|(
name|nlen
operator|-
name|nsp
operator|)
operator|-
operator|(
name|olen
operator|-
name|osp
operator|)
expr_stmt|;
if|if
condition|(
name|m2
operator|&&
name|tem
operator|&&
name|m2
operator|<=
name|DCICcost
index|[
name|tem
index|]
condition|)
name|m2
operator|=
literal|0
expr_stmt|;
comment|/* nsp - osp is the distance to insert or delete.      m1 + m2 is how much we save by doing so.      Is it worth it?  */
if|if
condition|(
name|m1
operator|+
name|m2
operator|&&
name|nsp
operator|!=
name|osp
operator|&&
name|m1
operator|+
name|m2
operator|<=
name|DCICcost
index|[
name|nsp
operator|-
name|osp
index|]
condition|)
block|{
name|m1
operator|=
literal|0
expr_stmt|;
name|m2
operator|=
literal|0
expr_stmt|;
name|osp
operator|=
name|nsp
operator|=
name|min
argument_list|(
name|osp
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
block|}
comment|/* Now go through the line, inserting, writing and deleting as appropriate.  */
if|if
condition|(
name|osp
operator|>
name|nsp
condition|)
block|{
name|topos
argument_list|(
name|vpos
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
name|delete_chars
argument_list|(
name|osp
operator|-
name|nsp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsp
operator|>
name|osp
condition|)
block|{
comment|/* If going to delete chars later in line 	 and insert earlier in the line, 	 must delete first to avoid losing data in the insert */
if|if
condition|(
name|m2
operator|&&
name|nlen
operator|<
name|olen
operator|+
name|nsp
operator|-
name|osp
condition|)
block|{
name|topos
argument_list|(
name|vpos
argument_list|,
name|nlen
operator|-
name|m2
operator|+
name|osp
operator|-
name|nsp
argument_list|)
expr_stmt|;
name|delete_chars
argument_list|(
name|olen
operator|+
name|nsp
operator|-
name|osp
operator|-
name|nlen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|nlen
operator|-
operator|(
name|nsp
operator|-
name|osp
operator|)
expr_stmt|;
block|}
name|topos
argument_list|(
name|vpos
argument_list|,
name|osp
argument_list|)
expr_stmt|;
name|insert_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|nsp
operator|-
name|osp
argument_list|)
expr_stmt|;
block|}
name|olen
operator|+=
name|nsp
operator|-
name|osp
expr_stmt|;
name|osp
operator|=
name|nsp
expr_stmt|;
name|tem
operator|=
name|nsp
operator|+
name|m1
operator|+
name|m2
expr_stmt|;
if|if
condition|(
name|nlen
operator|!=
name|tem
operator|||
name|olen
operator|!=
name|tem
condition|)
block|{
name|topos
argument_list|(
name|vpos
argument_list|,
name|nsp
operator|+
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m2
operator|||
name|nlen
operator|==
name|olen
condition|)
block|{
comment|/* If new text being written reaches right margin, 	     there is no need to do clear-to-eol at the end. 	     (and it would not be safe, since cursor is not 	     going to be "at the margin" after the text is done) */
if|if
condition|(
name|nlen
operator|==
name|screen_width
condition|)
name|olen
operator|=
literal|0
expr_stmt|;
name|write_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|m1
argument_list|,
name|nlen
operator|-
name|tem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|obsolete
comment|/* the following code loses disastrously if tem == nlen.    Rather than trying to fix that case, I am trying the simpler    solution found above.  */
comment|/* If the text reaches to the right margin, 	     it will lose one way or another (depending on AutoWrap) 	     to clear to end of line after outputting all the text. 	     So pause with one character to go and clear the line then.  */
if|if
condition|(
name|nlen
operator|==
name|screen_width
operator|&&
name|fast_clear_end_of_line
operator|&&
name|olen
operator|>
name|nlen
condition|)
block|{
comment|/* m2 must be zero, and tem must equal nsp + m1 */
name|write_chars
argument_list|(
name|nbody
operator|+
name|tem
argument_list|,
name|nlen
operator|-
name|tem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clear_end_of_line
argument_list|(
name|olen
argument_list|)
expr_stmt|;
name|olen
operator|=
literal|0
expr_stmt|;
comment|/* Don't let it be cleared again later */
name|write_chars
argument_list|(
name|nbody
operator|+
name|nlen
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|write_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|m1
argument_list|,
name|nlen
operator|-
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|nlen
operator|>
name|olen
condition|)
block|{
name|write_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|m1
argument_list|,
name|olen
operator|-
name|tem
argument_list|)
expr_stmt|;
name|insert_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|m1
operator|+
name|olen
operator|-
name|tem
argument_list|,
name|nlen
operator|-
name|olen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|nlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|olen
operator|>
name|nlen
condition|)
block|{
name|write_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|m1
argument_list|,
name|nlen
operator|-
name|tem
argument_list|)
expr_stmt|;
name|delete_chars
argument_list|(
name|olen
operator|-
name|nlen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|nlen
expr_stmt|;
block|}
block|}
name|just_erase
label|:
comment|/* If any unerased characters remain after the new line, erase them.  */
if|if
condition|(
name|olen
operator|>
name|nlen
condition|)
block|{
name|topos
argument_list|(
name|vpos
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|clear_end_of_line
argument_list|(
name|olen
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|count_blanks
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
while|while
condition|(
operator|*
name|str
operator|++
operator|==
literal|' '
condition|)
empty_stmt|;
return|return
name|str
operator|-
name|p
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|count_match
argument_list|(
argument|str1
argument_list|,
argument|str2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|str1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|str2
decl_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|==
operator|*
name|p2
operator|++
condition|)
empty_stmt|;
return|return
name|p1
operator|-
name|str1
operator|-
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"open-termscript"
argument_list|,
argument|Fopen_termscript
argument_list|,
argument|Sopen_termscript
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"FOpen termscript file: "
argument_list|,
literal|"Start writing all terminal output to FILE as well."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|file
operator|=
name|Fexpand_file_name
argument_list|(
name|file
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|termscript
operator|=
name|fopen
argument_list|(
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"set-screen-height"
argument_list|,
argument|Fset_screen_height
argument_list|,
argument|Sset_screen_height
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set number of lines on screen available for use in windows."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_screen_size
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-screen-width"
argument_list|,
argument|Fset_screen_width
argument_list|,
argument|Sset_screen_width
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set number of columns on screen available for display."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_screen_size
argument_list|(
literal|0
argument_list|,
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"screen-height"
argument_list|,
argument|Fscreen_height
argument_list|,
argument|Sscreen_height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return number of lines on screen available for use in windows."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|make_number
argument_list|(
name|screen_height
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"screen-width"
argument_list|,
argument|Fscreen_width
argument_list|,
argument|Sscreen_width
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return number of columns on screen available for display."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|make_number
argument_list|(
name|screen_width
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/* Change the screen height and/or width.  Values may be given as zero to    indicate no change is to take place. */
end_comment

begin_expr_stmt
name|change_screen_size
argument_list|(
name|newlength
argument_list|,
name|newwidth
argument_list|)
specifier|register
name|int
name|newlength
operator|,
name|newwidth
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|newlength
operator|==
literal|0
operator|||
name|newlength
operator|==
name|screen_height
operator|)
operator|&&
operator|(
name|newwidth
operator|==
literal|0
operator|||
name|newwidth
operator|==
name|screen_width
operator|)
condition|)
return|return;
if|if
condition|(
name|newlength
operator|&&
name|newlength
operator|!=
name|screen_height
condition|)
block|{
if|if
condition|(
name|newlength
operator|>
name|MScreenLength
condition|)
name|newlength
operator|=
name|MScreenLength
expr_stmt|;
name|set_window_height
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
name|newlength
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|top
argument_list|)
operator|=
name|newlength
operator|-
literal|1
expr_stmt|;
name|set_window_height
argument_list|(
name|minibuf_window
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screen_height
operator|=
name|newlength
expr_stmt|;
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newwidth
operator|&&
name|newwidth
operator|!=
name|screen_width
condition|)
block|{
if|if
condition|(
name|newwidth
operator|>
name|MScreenWidth
condition|)
name|newwidth
operator|=
name|MScreenWidth
expr_stmt|;
name|set_window_width
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
name|newwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_window_width
argument_list|(
name|minibuf_window
argument_list|,
name|newwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screen_width
operator|=
name|newwidth
expr_stmt|;
block|}
name|make_display_lines
argument_list|()
expr_stmt|;
name|calculate_costs
argument_list|()
expr_stmt|;
name|DoDsp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFSIMPLE
argument_list|(
literal|"baud-rate"
argument_list|,
argument|Fbaud_rate
argument_list|,
argument|Sbaud_rate
argument_list|,
literal|"Return the output baud rate of the terminal."
argument_list|,
argument|Lisp_Int
argument_list|,
argument|XSETINT
argument_list|,
argument|baud_rate
argument_list|)
end_macro

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"send-string-to-terminal"
argument_list|,
argument|Fsend_string_to_terminal
argument_list|,
argument|Ssend_string_to_terminal
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Send STRING to the terminal without alteration.\n\ Control characters in STRING will have terminal-dependent effects."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
literal|1
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|termscript
condition|)
block|{
name|fwrite
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
literal|1
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|termscript
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"ding"
argument_list|,
argument|Fding
argument_list|,
argument|Sding
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Beep, or flash the screen.\n\ Terminates any keyboard macro currently executing."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Ding
argument_list|()
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_macro
name|Ding
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
name|putchar
argument_list|(
literal|07
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|INTERACTIVE
condition|)
comment|/* Stop executing a keyboard macro. */
name|error
argument_list|(
literal|"Keyboard macro terminated by a command ringing the bell"
argument_list|)
expr_stmt|;
else|else
name|ring_bell
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"sleep-for"
argument_list|,
argument|Fsleep_for
argument_list|,
argument|Ssleep_for
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Pause, without updating display, for ARG seconds."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
ifndef|#
directive|ifndef
name|subprocesses
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|struct
name|timeval
name|timeout
decl_stmt|,
name|end_time
decl_stmt|,
name|garbage1
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIMEVAL */
endif|#
directive|endif
comment|/* no subprocesses */
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<=
literal|0
condition|)
return|return
name|Qnil
return|;
ifdef|#
directive|ifdef
name|subprocesses
name|wait_reading_process_input
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* No subprocesses */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_TIMEVAL
argument_list|)
name|gettimeofday
argument_list|(
operator|&
name|end_time
argument_list|,
operator|&
name|garbage1
argument_list|)
expr_stmt|;
name|end_time
operator|.
name|tv_sec
operator|+=
name|t
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|garbage1
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|end_time
operator|.
name|tv_sec
operator|-
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|end_time
operator|.
name|tv_usec
operator|-
name|timeout
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_usec
operator|<
literal|0
condition|)
name|timeout
operator|.
name|tv_usec
operator|+=
literal|1000000
operator|,
name|timeout
operator|.
name|tv_sec
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|select
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
break|break;
block|}
else|#
directive|else
comment|/* not both HAVE_SELECT and HAVE_TIMEVAL */
comment|/* Is it safe to quit out of `sleep'?  I'm afraid to trust it.  */
name|sleep
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not both HAVE_SELECT and HAVE_TIMEVAL */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* no subprocesses */
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"sit-for"
argument_list|,
argument|Fsit_for
argument_list|,
argument|Ssit_for
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Perform redisplay, then wait for ARG seconds or until input is available"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|subprocesses
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|struct
name|timeval
name|timeout
decl_stmt|;
else|#
directive|else
name|int
name|timeout_sec
decl_stmt|;
endif|#
directive|endif
name|int
name|waitchannels
decl_stmt|;
endif|#
directive|endif
comment|/* no subprocesses */
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|detect_input_pending
argument_list|()
condition|)
return|return
name|Qnil
return|;
name|DoDsp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Make the screen correct */
if|if
condition|(
name|XINT
argument_list|(
name|n
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|Qnil
return|;
ifdef|#
directive|ifdef
name|subprocesses
ifdef|#
directive|ifdef
name|SIGIO
name|gobble_input
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SIGIO */
name|wait_reading_process_input
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no subprocesses */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
name|waitchannels
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_TIMEVAL
name|timeout_sec
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|waitchannels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout_sec
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_TIMEVAL */
name|timeout
operator|.
name|tv_sec
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|waitchannels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIMEVAL */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* no subprocesses */
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|char
modifier|*
name|terminal_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization done when Emacs fork is started, before doing stty. */
end_comment

begin_comment
comment|/* Determine terminal type and set terminal_driver */
end_comment

begin_comment
comment|/* Then invoke its decoding routine to set up variables   in the terminal package */
end_comment

begin_macro
name|init_display
argument_list|()
end_macro

begin_block
block|{
name|MetaFlag
operator|=
literal|0
expr_stmt|;
name|inverse_video
operator|=
literal|0
expr_stmt|;
comment|/* Look at the TERM variable and set terminal_driver.  */
name|terminal_type
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|terminal_type
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Please set the environment variable TERM; see tset(1).\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|terminal_type
argument_list|,
literal|"xterm"
argument_list|,
literal|5
argument_list|)
condition|)
name|x_term_init
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_X_WINDOWS */
name|term_init
argument_list|(
name|terminal_type
argument_list|)
expr_stmt|;
name|make_display_lines
argument_list|()
expr_stmt|;
name|cursX
operator|=
literal|0
expr_stmt|;
comment|/* X and Y coordinates of the cursor */
name|cursY
operator|=
literal|0
expr_stmt|;
comment|/* between updates. */
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_display
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Sopen_termscript
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sding
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssit_for
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscreen_height
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscreen_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_screen_height
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_screen_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssleep_for
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbaud_rate
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssend_string_to_terminal
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"inverse-video"
argument_list|,
operator|&
name|inverse_video
argument_list|,
literal|"*Non-nil means use inverse-video."
argument_list|)
expr_stmt|;
name|DefBoolVar
argument_list|(
literal|"visible-bell"
argument_list|,
operator|&
name|visible_bell
argument_list|,
literal|"*Non-nil means try to flash the screen to represent a bell."
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

