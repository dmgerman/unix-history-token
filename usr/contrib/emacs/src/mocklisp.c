begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Mocklisp compatibility functions for GNU Emacs Lisp interpreter.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* Compatibility for mocklisp */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_comment
comment|/* Now in lisp code ("macrocode...") * DEFUN ("ml-defun", Fml_defun, Sml_defun, 0, UNEVALLED, 0, *  "Define mocklisp functions") *  (args) *     Lisp_Object args; * { *  Lisp_Object elt; * *   while (!NULL (args)) *     { *       elt = Fcar (args); *       Ffset (Fcar (elt), Fcons (Qmocklisp, Fcdr (elt))); *       args = Fcdr (args); *     } *   return Qnil; * } */
end_comment

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"ml-if"
argument_list|,
argument|Fml_if
argument_list|,
argument|Sml_if
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"if  for mocklisp programs"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|=
name|Fcdr
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|args
argument_list|)
condition|)
break|break;
if|if
condition|(
name|XINT
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|args
operator|=
name|Fcdr
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* Now converted to regular "while" by hairier conversion code. * DEFUN ("ml-while", Fml_while, Sml_while, 1, UNEVALLED, 0, "while  for mocklisp programs") *   (args) *      Lisp_Object args; * { *   Lisp_Object test, body, tem; *   struct gcpro gcpro1, gcpro2; * *   GCPRO2 (test, body); * *   test = Fcar (args); *   body = Fcdr (args); *   while (tem = Feval (test), XINT (tem)) *     { *       QUIT; *       Fprogn (body); *    } * *   UNGCPRO; *   return Qnil; *}
comment|/* This is the main entry point to mocklisp execution.  When eval sees a mocklisp function being called, it calls here  with the unevaluated argument list */
end_comment

begin_function
name|Lisp_Object
name|ml_apply
parameter_list|(
name|function
parameter_list|,
name|args
parameter_list|)
name|Lisp_Object
name|function
decl_stmt|,
name|args
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|specbind
argument_list|(
name|Qmocklisp_arguments
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|Fcdr
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"ml-nargs"
argument_list|,
argument|Fml_nargs
argument_list|,
argument|Sml_nargs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"# arguments to this mocklisp function"
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|Vmocklisp_arguments
argument_list|,
name|Qinteractive
argument_list|)
condition|)
return|return
name|make_number
argument_list|(
literal|0
argument_list|)
return|;
end_expr_stmt

begin_return
return|return
name|Flength
argument_list|(
name|Vmocklisp_arguments
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"ml-arg"
operator|,
name|Fml_arg
operator|,
name|Sml_arg
operator|,
literal|1
operator|,
literal|2
operator|,
literal|0
operator|,
literal|"Argument #N to this mocklisp function."
operator|)
operator|(
name|n
operator|,
name|prompt
operator|)
name|Lisp_Object
name|n
operator|,
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|EQ
argument_list|(
name|Vmocklisp_arguments
argument_list|,
name|Qinteractive
argument_list|)
condition|)
return|return
name|Fread_string
argument_list|(
name|prompt
argument_list|,
name|Qnil
argument_list|)
return|;
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|n
argument_list|,
name|XINT
argument_list|(
name|n
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Mocklisp likes to be origin-1 */
return|return
name|Fcar
argument_list|(
name|Fnthcdr
argument_list|(
name|n
argument_list|,
name|Vmocklisp_arguments
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"ml-interactive"
argument_list|,
argument|Fml_interactive
argument_list|,
argument|Sml_interactive
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"True if this mocklisp function was called interactively."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
operator|(
name|EQ
argument_list|(
name|Vmocklisp_arguments
argument_list|,
name|Qinteractive
argument_list|)
operator|)
operator|?
name|Qt
operator|:
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"ml-provide-prefix-argument"
argument_list|,
argument|Fml_provide_prefix_argument
argument_list|,
argument|Sml_provide_prefix_argument
argument_list|,
literal|2
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Evaluate second argument, using first argument as prefix arg value."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|Vcurrent_prefix_arg
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"ml-prefix-argument-loop"
argument_list|,
argument|Fml_prefix_argument_loop
argument_list|,
argument|Sml_prefix_argument_loop
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
comment|/* Set `arg' in case we call a built-in function that looks at it.  Still are a few. */
if|if
condition|(
name|NULL
argument_list|(
name|Vcurrent_prefix_arg
argument_list|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|Vcurrent_prefix_arg
expr_stmt|;
if|if
condition|(
name|LISTP
argument_list|(
name|tem
argument_list|)
condition|)
name|tem
operator|=
name|Fcar
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qminus
argument_list|)
condition|)
name|i
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|i
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|Fprogn
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"ml-substr"
argument_list|,
argument|Fml_substr
argument_list|,
argument|Sml_substr
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Return a substring of STRING, starting at index FROM and of length LENGTH.\n\ If either FROM or LENGTH is negative, the length of STRING is added to it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|from
operator|,
name|to
operator|)
name|Lisp_Object
name|string
operator|,
name|from
operator|,
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|to
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|from
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|from
argument_list|,
name|XINT
argument_list|(
name|from
argument_list|)
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|to
argument_list|)
operator|<
literal|0
condition|)
name|XSETINT
argument_list|(
name|to
argument_list|,
name|XINT
argument_list|(
name|to
argument_list|)
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|to
argument_list|,
name|XINT
argument_list|(
name|to
argument_list|)
operator|+
name|XINT
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Fsubstring
argument_list|(
name|string
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert-string"
argument_list|,
argument|Finsert_string
argument_list|,
argument|Sinsert_string
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Insert the arguments (all strings) into the buffer, moving point forward.\n\ Any argument that is a number is converted to a string by printing it in decimal."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|argnum
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|tem
operator|=
name|Fint_to_string
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|wrong_type_argument
argument_list|(
name|Qstringp
argument_list|,
name|tem
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_mocklisp
argument_list|()
end_macro

begin_block
block|{
name|Qmocklisp
operator|=
name|intern
argument_list|(
literal|"mocklisp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qmocklisp
argument_list|)
expr_stmt|;
comment|/*defsubr (&Sml_defun);*/
name|defsubr
argument_list|(
operator|&
name|Sml_if
argument_list|)
expr_stmt|;
comment|/*defsubr (&Sml_while);*/
name|defsubr
argument_list|(
operator|&
name|Sml_arg
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sml_nargs
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sml_interactive
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sml_provide_prefix_argument
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sml_prefix_argument_loop
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sml_substr
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_string
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

