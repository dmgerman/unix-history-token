begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Synchronous subprocess invocation for GNU Emacs.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_define
define|#
directive|define
name|PRIO_PROCESS
value|0
end_define

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_decl_stmt
name|Lisp_Object
name|Vexec_path
decl_stmt|,
name|Vexec_directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Vshell_file_name
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_comment
comment|/* Set nonzero when a synchronous subprocess is made,    and set to zero again when it is observed to die.    We wait for this to be zero in order to wait for termination.  */
end_comment

begin_decl_stmt
name|int
name|synch_process_pid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_1 */
end_comment

begin_escape
end_escape

begin_function
name|Lisp_Object
name|call_process_cleanup
parameter_list|(
name|fdpid
parameter_list|)
name|Lisp_Object
name|fdpid
decl_stmt|;
block|{
name|Lisp_Object
name|fd
decl_stmt|,
name|pid
decl_stmt|;
name|fd
operator|=
name|Fcar
argument_list|(
name|fdpid
argument_list|)
expr_stmt|;
name|pid
operator|=
name|Fcdr
argument_list|(
name|fdpid
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|XFASTINT
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|XFASTINT
argument_list|(
name|pid
argument_list|)
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"call-process"
argument_list|,
argument|Fcall_process
argument_list|,
argument|Scall_process
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Call PROGRAM in separate process.\n\ Program's input comes from file INFILE (nil means /dev/null).\n\ Insert output in BUFFER before point; t means current buffer;\n\  nil for BUFFER means discard it; 0 means discard and don't wait.\n\ Fourth arg DISPLAY non-nil means redisplay buffer as output is inserted.\n\ Remaining arguments are strings passed as command arguments to PROGRAM.\n\ This function waits for PROGRAM to terminate;\n\ if you quit, the process is killed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|display
decl_stmt|,
name|buffer
decl_stmt|,
name|tem
decl_stmt|,
name|tem1
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
name|int
name|filefd
decl_stmt|;
name|int
name|pid
decl_stmt|;
specifier|register
name|int
name|nread
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|new_argv
init|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max
argument_list|(
literal|2
argument_list|,
name|nargs
operator|-
literal|2
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|buffer
modifier|*
name|old
init|=
name|bf_cur
decl_stmt|;
name|tem
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|<=
literal|1
operator|||
name|NULL
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
condition|)
name|args
index|[
literal|1
index|]
operator|=
name|build_string
argument_list|(
literal|"/dev/null"
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|args
index|[
literal|1
index|]
operator|,
name|args
index|[
literal|1
index|]
operator|=
name|Fexpand_file_name
argument_list|(
name|tem
argument_list|,
name|bf_cur
operator|->
name|directory
argument_list|)
expr_stmt|;
name|tem
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|<=
literal|2
operator|||
name|NULL
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
condition|)
name|buffer
operator|=
name|Qnil
expr_stmt|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|,
name|Qt
argument_list|)
condition|)
name|buffer
operator|=
name|Qt
expr_stmt|;
elseif|else
if|if
condition|(
name|XFASTINT
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
name|buffer
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|tem
operator|=
name|args
index|[
literal|2
index|]
expr_stmt|;
name|buffer
operator|=
name|Fget_buffer
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|display
operator|=
name|nargs
operator|>=
literal|3
condition|?
name|args
index|[
literal|3
index|]
else|:
name|Qnil
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|tem
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|new_argv
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|XSTRING
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
comment|/* Program name is first command arg */
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
name|new_argv
index|[
name|i
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|filefd
operator|=
name|open
argument_list|(
name|XSTRING
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
operator|->
name|data
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|filefd
operator|<
literal|0
condition|)
block|{
name|tem
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Opening process input file"
argument_list|,
name|Fcons
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Search for program; barf if not found.  */
name|tem1
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|openp
argument_list|(
name|Vexec_path
argument_list|,
name|tem1
argument_list|,
literal|""
argument_list|,
operator|&
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|filefd
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Searching for program"
argument_list|,
name|Fcons
argument_list|(
name|tem1
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_argv
index|[
literal|0
index|]
operator|=
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|buffer
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|fd
index|[
literal|1
index|]
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
operator|,
name|fd
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|pipe
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|set_exclusive_use
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
comment|/* cause SIGCHLD interrupts to look for this pid. */
name|synch_process_pid
operator|=
name|pid
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
if|if
condition|(
operator|!
name|pid
condition|)
name|child_setup
argument_list|(
name|filefd
argument_list|,
name|fd
index|[
literal|1
index|]
argument_list|,
name|fd
index|[
literal|1
index|]
argument_list|,
name|new_argv
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|filefd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|report_file_error
argument_list|(
literal|"Doing vfork"
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|buffer
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
ifndef|#
directive|ifndef
name|subprocesses
name|wait_without_blocking
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|subprocesses
return|return
name|Qnil
return|;
block|}
name|record_unwind_protect
argument_list|(
name|call_process_cleanup
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|buffer
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
name|Fset_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
while|while
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|InsCStr
argument_list|(
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|display
argument_list|)
operator|&&
name|INTERACTIVE
condition|)
name|DoDsp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
comment|/* Wait for it to terminate, unless it already has.  */
name|wait_for_termination
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|SetBfp
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|child_setup
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|err
argument_list|,
argument|new_argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|temp
decl_stmt|;
name|child_setup_tty
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|temp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|data
argument_list|,
name|temp
argument_list|,
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|i
operator|=
name|XSTRING
argument_list|(
name|bf_cur
operator|->
name|directory
argument_list|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|temp
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp
index|[
name|i
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|temp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|chdir
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|err
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|setpgrp
argument_list|()
expr_stmt|;
comment|/* No arguments but equivalent in this case */
else|#
directive|else
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
name|setpgrp_of_tty
argument_list|(
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vipc
name|something
name|missing
name|here
decl_stmt|;
endif|#
directive|endif
endif|vipc
name|execvp
argument_list|(
name|new_argv
index|[
literal|0
index|]
argument_list|,
name|new_argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
literal|"Couldn't exec the program "
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|new_argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|new_argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"call-process-region"
argument_list|,
argument|Fcall_process_region
argument_list|,
argument|Scall_process_region
argument_list|,
literal|3
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Send text from START to END to a process running PROGRAM.\n\ Delete the text if DELETE is non-nil.\n\ Put output in BUFFER, before point.  nil => discard it, t => current buffer.\n\ Sixth arg DISPLAY non-nil means redisplay buffer as output is inserted.\n\ Remaining args are passed to PROGRAM at startup as command args.\n\ This function normally waits for the process to terminate;\n\ if you quit, the process is killed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Lisp_Object
name|filename_string
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
name|tempfile
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tempfile
argument_list|,
literal|"/tmp/emacsXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|filename_string
operator|=
name|build_string
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|start
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
name|end
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
name|Fwrite_region
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|filename_string
argument_list|,
name|Qnil
argument_list|,
name|Qlambda
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|args
index|[
literal|3
index|]
argument_list|)
condition|)
name|Fdelete_region
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|filename_string
expr_stmt|;
name|Fcall_process
argument_list|(
name|nargs
operator|-
literal|2
argument_list|,
name|args
operator|+
literal|2
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_callproc
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|sh
decl_stmt|;
name|Vexec_path
operator|=
name|nconc2
argument_list|(
name|decode_env_path
argument_list|(
literal|"PATH"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|decode_env_path
argument_list|(
literal|"%$&*#"
argument_list|,
name|PATH_EXEC
argument_list|)
argument_list|)
expr_stmt|;
name|Vexec_directory
operator|=
name|build_string
argument_list|(
name|PATH_EXEC
argument_list|)
expr_stmt|;
name|Vexec_directory
operator|=
name|concat2
argument_list|(
name|Vexec_directory
argument_list|,
name|build_string
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
name|sh
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
name|Vshell_file_name
operator|=
name|build_string
argument_list|(
name|sh
condition|?
name|sh
else|:
literal|"/bin/sh"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|syms_of_callproc
argument_list|()
end_macro

begin_block
block|{
name|DefLispVar
argument_list|(
literal|"shell-file-name"
argument_list|,
operator|&
name|Vshell_file_name
argument_list|,
literal|"*File name to load inferior shells from.\n\ Initialized from the SHELL environment variable."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"exec-path"
argument_list|,
operator|&
name|Vexec_path
argument_list|,
literal|"*List of directories to search programs to run in subprocesses.\n\ Each element is a string (directory name) or nil (try default directory)."
argument_list|)
expr_stmt|;
name|DefLispVar
argument_list|(
literal|"exec-directory"
argument_list|,
operator|&
name|Vexec_directory
argument_list|,
literal|"Directory that holds programs that come with GNU Emacs,\n\ intended for Emacs to invoke."
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scall_process
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scall_process_region
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

