begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Record indices of function doc strings stored in a file.    Copyright (C) 1985 Richard M. Stallman.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU Emacs General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the GNU Emacs General Public License.   A copy of this license is supposed to have been given to you along with GNU Emacs so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Must be after sys/types.h for USG and BSD4_1*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Lisp_Object
name|Vdoc_file_name
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|get_doc_string
parameter_list|(
name|filepos
parameter_list|)
name|long
name|filepos
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|512
operator|*
literal|32
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
name|XTYPE
argument_list|(
name|Vexec_directory
argument_list|)
operator|!=
name|Lisp_String
operator|||
name|XTYPE
argument_list|(
name|Vdoc_file_name
argument_list|)
operator|!=
name|Lisp_String
condition|)
return|return
name|Qnil
return|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|Vexec_directory
argument_list|)
operator|->
name|size
operator|+
name|XSTRING
argument_list|(
name|Vdoc_file_name
argument_list|)
operator|->
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|XSTRING
argument_list|(
name|Vexec_directory
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|XSTRING
argument_list|(
name|Vdoc_file_name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot open doc string file \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|lseek
argument_list|(
name|fd
argument_list|,
name|filepos
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Position %ld out of range in doc string file \"%s\""
argument_list|,
name|filepos
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
literal|1
condition|)
block|{
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|p
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
break|break;
name|p1
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\037'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
block|{
operator|*
name|p1
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|count
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"documentation"
argument_list|,
argument|Fdocumentation
argument_list|,
argument|Sdocumentation
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the documentation string of FUNCTION."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|fun1
operator|)
name|Lisp_Object
name|fun1
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|fun
decl_stmt|;
name|Lisp_Object
name|funcar
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|fun
operator|=
name|fun1
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
name|fun
operator|=
name|Fsymbol_function
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
if|if
condition|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
operator|==
literal|0
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
operator|>=
literal|0
condition|)
return|return
name|Fsubstitute_command_keys
argument_list|(
name|build_string
argument_list|(
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
argument_list|)
argument_list|)
return|;
return|return
name|Fsubstitute_command_keys
argument_list|(
name|get_doc_string
argument_list|(
operator|-
operator|(
name|int
operator|)
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Vector
condition|)
return|return
name|build_string
argument_list|(
literal|"Prefix command (definition is a Lisp vector of subcommands)."
argument_list|)
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|build_string
argument_list|(
literal|"Keyboard macro."
argument_list|)
return|;
if|if
condition|(
operator|!
name|LISTP
argument_list|(
name|fun
argument_list|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|funcar
operator|=
name|Fcar
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|funcar
argument_list|)
operator|!=
name|Lisp_Symbol
condition|)
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qkeymap
argument_list|)
condition|)
return|return
name|build_string
argument_list|(
literal|"Prefix command (definition is a list whose cdr is an alist of subcommands.)"
argument_list|)
return|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qlambda
argument_list|)
operator|||
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qautoload
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Fsubstitute_command_keys
argument_list|(
name|tem
argument_list|)
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|XINT
argument_list|(
name|tem
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|Fsubstitute_command_keys
argument_list|(
name|get_doc_string
argument_list|(
name|XFASTINT
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|Qnil
return|;
block|}
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qmocklisp
argument_list|)
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|XSYMBOL
argument_list|(
name|funcar
argument_list|)
operator|==
name|XSYMBOL
argument_list|(
name|Qmacro
argument_list|)
condition|)
return|return
name|Fdocumentation
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
return|;
else|else
return|return
name|Fsignal
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|fun
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"Snarf-documentation"
argument_list|,
argument|Fsnarf_documentation
argument_list|,
argument|Ssnarf_documentation
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Used during Emacs initialization, before dumping runnable Emacs,\n\ to find pointers to doc strings stored in etc/DOC... and\n\ record them in function definitions.\n\ One arg, FILENAME, a string which does not include a directory.\n\ The file is found in ../etc now; found in the exec-directory\n\ when doc strings are referred to later in the dumped Emacs."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|char
name|buf
index|[
literal|1024
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|filled
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|Lisp_Object
name|sym
decl_stmt|,
name|fun
decl_stmt|,
name|tem
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|CHECK_STRING
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CANNOT_DUMP
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|size
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"../etc/"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CANNOT_DUMP */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|size
operator|+
sizeof|sizeof
argument_list|(
name|PATH_EXEC
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|PATH_EXEC
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CANNOT_DUMP */
name|strcat
argument_list|(
name|name
argument_list|,
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/*** Add this line ***/
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening doc string file"
argument_list|,
name|Fcons
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|Vdoc_file_name
operator|=
name|filename
expr_stmt|;
name|filled
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|filled
operator|<
literal|512
condition|)
name|filled
operator|+=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
index|[
name|filled
index|]
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
operator|-
name|filled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filled
condition|)
break|break;
name|buf
index|[
name|filled
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
operator|(
name|filled
operator|<
literal|512
condition|?
name|filled
else|:
name|filled
operator|-
literal|128
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|*
name|p
operator|!=
literal|'\037'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|end
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|sym
operator|=
name|oblookup
argument_list|(
name|Vobarray
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|end
operator|-
name|p
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|fun
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|fun
argument_list|)
operator|==
name|Lisp_Subr
condition|)
name|XSUBR
argument_list|(
name|fun
argument_list|)
operator|->
name|doc
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
operator|(
name|pos
operator|+
name|end
operator|+
literal|1
operator|-
name|buf
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LISTP
argument_list|(
name|fun
argument_list|)
condition|)
block|{
name|tem
operator|=
name|XCONS
argument_list|(
name|fun
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qlambda
argument_list|)
operator|||
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qautoload
argument_list|)
condition|)
block|{
name|tem
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|fun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LISTP
argument_list|(
name|tem
argument_list|)
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|XFASTINT
argument_list|(
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
argument_list|)
operator|=
operator|(
name|pos
operator|+
name|end
operator|+
literal|1
operator|-
name|buf
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|pos
operator|+=
name|end
operator|-
name|buf
expr_stmt|;
name|filled
operator|-=
name|end
operator|-
name|buf
expr_stmt|;
name|bcopy
argument_list|(
name|end
argument_list|,
name|buf
argument_list|,
name|filled
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
specifier|extern
name|Lisp_Object
name|where_is_in_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"substitute-command-keys"
argument_list|,
argument|Fsubstitute_command_keys
argument_list|,
argument|Ssubstitute_command_keys
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the STRING with substrings of the form \\=\\[COMMAND]\n\ replaced by either:  a keystroke sequence that will invoke COMMAND,\n\ or \"M-x COMMAND\" if COMMAND is not on any keys.\n\ Substrings of the form \\=\\{MAPVAR} are replaced by summaries\n\ \(made by describe-bindings) of the value of MAPVAR, taken as a keymap.\n\ \\=\\= quotes the following character and is discarded;\n\ thus, \\=\\=\\=\\= puts \\=\\= into the output, and \\=\\=\\=\\[ puts \\=\\[ into the output."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|didone
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|send
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|new
decl_stmt|;
name|Lisp_Object
name|key
decl_stmt|,
name|tem
decl_stmt|;
name|unsigned
name|char
modifier|*
name|funp
decl_stmt|;
name|int
name|func
decl_stmt|;
name|struct
name|buffer
modifier|*
name|oldbuf
decl_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|str
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
expr_stmt|;
name|send
operator|=
name|strp
operator|+
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
expr_stmt|;
name|bsize
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
expr_stmt|;
name|bufp
operator|=
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
while|while
condition|(
name|strp
operator|<
name|send
condition|)
block|{
if|if
condition|(
name|strp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|strp
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* \= quotes the next character; 	     thus, to put in \[ without its special meaning, use \=\[.  */
name|didone
operator|=
literal|1
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|strp
index|[
literal|2
index|]
expr_stmt|;
name|strp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|strp
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
name|didone
operator|=
literal|1
expr_stmt|;
name|strp
operator|+=
literal|2
expr_stmt|;
comment|/* skip \[ */
name|funp
operator|=
name|strp
expr_stmt|;
while|while
condition|(
name|strp
operator|<
name|send
operator|&&
operator|*
name|strp
operator|!=
literal|']'
condition|)
name|strp
operator|++
expr_stmt|;
name|func
operator|=
name|strp
operator|-
name|funp
expr_stmt|;
name|key
operator|=
name|Fintern
argument_list|(
name|make_string
argument_list|(
name|funp
argument_list|,
name|func
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|key
operator|=
name|where_is_in_buffer
argument_list|(
name|key
argument_list|,
name|bf_cur
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strp
operator|++
expr_stmt|;
comment|/* skip ] */
if|if
condition|(
name|NULL
argument_list|(
name|key
argument_list|)
condition|)
comment|/* but not on any keys */
block|{
name|new
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bsize
operator|+=
literal|4
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|new
operator|-
name|buf
expr_stmt|;
name|buf
operator|=
name|new
expr_stmt|;
name|strcpy
argument_list|(
name|bufp
argument_list|,
literal|"M-x "
argument_list|)
expr_stmt|;
name|bufp
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* function is on a key */
name|key
operator|=
name|Fkey_description
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|funp
operator|=
name|XSTRING
argument_list|(
name|key
argument_list|)
operator|->
name|data
expr_stmt|;
name|func
operator|=
name|XSTRING
argument_list|(
name|key
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
name|subst
label|:
name|new
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bsize
operator|+=
name|func
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|new
operator|-
name|buf
expr_stmt|;
name|buf
operator|=
name|new
expr_stmt|;
name|bcopy
argument_list|(
name|funp
argument_list|,
name|bufp
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|func
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|strp
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
name|didone
operator|=
literal|1
expr_stmt|;
name|strp
operator|+=
literal|2
expr_stmt|;
comment|/* skip \( */
name|funp
operator|=
name|strp
expr_stmt|;
while|while
condition|(
name|strp
operator|<
name|send
operator|&&
operator|*
name|strp
operator|!=
literal|'}'
condition|)
name|strp
operator|++
expr_stmt|;
name|func
operator|=
name|strp
operator|-
name|funp
expr_stmt|;
name|strp
operator|++
expr_stmt|;
comment|/* skip } */
name|oldbuf
operator|=
name|bf_cur
expr_stmt|;
name|SetBfp
argument_list|(
name|XBUFFER
argument_list|(
name|Vprin1_to_string_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|Fintern
argument_list|(
name|make_string
argument_list|(
name|funp
argument_list|,
name|func
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tem
operator|=
operator|(
name|Fboundp
argument_list|(
name|key
argument_list|)
operator|)
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
operator|||
operator|(
name|tem
operator|=
operator|(
name|Fsymbol_value
argument_list|(
name|key
argument_list|)
operator|)
operator|,
name|NULL
argument_list|(
name|tem
argument_list|)
operator|)
condition|)
block|{
name|key
operator|=
name|Fsymbol_name
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\nUses keymap \""
argument_list|)
expr_stmt|;
name|InsCStr
argument_list|(
name|XSTRING
argument_list|(
name|key
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|key
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
literal|"\", which is not currently defined.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|=
name|Fsymbol_value
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|describe_map_tree
argument_list|(
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|key
operator|=
name|Fbuffer_string
argument_list|()
expr_stmt|;
name|Ferase_buffer
argument_list|()
expr_stmt|;
name|SetBfp
argument_list|(
name|oldbuf
argument_list|)
expr_stmt|;
name|funp
operator|=
name|XSTRING
argument_list|(
name|key
argument_list|)
operator|->
name|data
expr_stmt|;
name|func
operator|=
name|XSTRING
argument_list|(
name|key
argument_list|)
operator|->
name|size
expr_stmt|;
goto|goto
name|subst
goto|;
block|}
else|else
comment|/* just copy other chars */
operator|*
name|bufp
operator|++
operator|=
operator|*
name|strp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|didone
condition|)
comment|/* don't bother if nothing substituted */
name|key
operator|=
name|make_string
argument_list|(
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|)
expr_stmt|;
else|else
name|key
operator|=
name|str
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_doc
argument_list|()
end_macro

begin_block
block|{
name|staticpro
argument_list|(
operator|&
name|Vdoc_file_name
argument_list|)
expr_stmt|;
name|Vdoc_file_name
operator|=
name|Qnil
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdocumentation
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssnarf_documentation
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubstitute_command_keys
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

