begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_comment
comment|/*  * The Sun X drivers are a product of Sun Microsystems, Inc. and are provided  * for unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify these drivers without charge, but are not authorized  * to license or distribute them to anyone else except as part of a product or  * program developed by the user.  *   * THE SUN X DRIVERS ARE PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND  * INCLUDING THE WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A  * PARTICULAR PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE  * PRACTICE.  *  * The Sun X Drivers are provided with no support and without any obligation  * on the part of Sun Microsystems, Inc. to assist in their use, correction,  * modification or enhancement.  *   * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THE SUN X  * DRIVERS OR ANY PART THEREOF.  *   * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *   * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)text.c 2.1 86/01/28 Copyright 1986 Sun Micro"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * Copyright (c) 1986 by Sun Microsystems,  Inc.  */
end_comment

begin_comment
comment|/*  *	ToDo:  *		Color  */
end_comment

begin_include
include|#
directive|include
file|"Xsun.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|stdin
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pixrect/memreg.h>
end_include

begin_include
include|#
directive|include
file|<pixrect/cg2reg.h>
end_include

begin_comment
comment|/* I've put in some rather ugly hacks, in the name of performance.  The    global variables private_* are really extra parameters to the batchrop    routines.  I did this, rather than adding parameters, because I wanted to    do the least violence to the "official" specs of batchrop -- this way X    will vaguely work on displays that don't use one of the tuned batchrops. 	JAG */
end_comment

begin_decl_stmt
name|int
name|private_fgcolor
decl_stmt|,
name|private_bgcolor
decl_stmt|,
name|private_czmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pixrect
modifier|*
name|PixRect
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PrintText
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|,
name|font
argument_list|,
name|fore
argument_list|,
name|back
argument_list|,
name|charpad
argument_list|,
name|spacepad
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|clips
argument_list|,
name|clipcount
argument_list|,
name|func
argument_list|,
name|zmask
argument_list|)
specifier|register
name|unsigned
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strlen
decl_stmt|,
name|fore
decl_stmt|,
name|back
decl_stmt|,
name|charpad
decl_stmt|,
name|spacepad
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIP
modifier|*
name|clips
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clipcount
decl_stmt|,
name|zmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|CURSOR
modifier|*
name|CurrentCursor
decl_stmt|;
extern|extern      CursorDisplayed;
name|int
name|cleft
decl_stmt|,
name|ctop
decl_stmt|,
name|cwidth
decl_stmt|,
name|cheight
decl_stmt|;
name|int
name|op
decl_stmt|;
specifier|extern
name|char
name|FBMap
index|[]
decl_stmt|;
define|#
directive|define
name|CHUNK
value|400
name|unsigned
name|char
modifier|*
name|limit
init|=
name|string
operator|+
operator|(
name|strlen
operator|<
name|CHUNK
condition|?
name|strlen
else|:
name|CHUNK
operator|)
decl_stmt|;
specifier|register
name|w
operator|=
literal|0
expr_stmt|;
specifier|static
name|struct
name|pr_prpos
name|bat
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
name|bsize
init|=
literal|0
decl_stmt|;
name|int
name|lheight
decl_stmt|;
name|int
name|sbot
decl_stmt|,
name|sright
decl_stmt|;
name|private_czmask
operator|=
name|zmask
expr_stmt|;
name|private_fgcolor
operator|=
name|fore
expr_stmt|;
name|private_bgcolor
operator|=
name|back
expr_stmt|;
if|if
condition|(
name|fore
operator|&
literal|1
condition|)
name|func
operator|+=
literal|0x20
expr_stmt|;
if|if
condition|(
name|back
operator|&
literal|1
condition|)
name|func
operator|+=
literal|0x10
expr_stmt|;
name|func
operator|=
name|FBMap
index|[
name|func
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|op
operator|=
name|SUN_FROM_X_OP
argument_list|(
name|func
argument_list|)
comment|/* | PIX_COLOR(fore) */
expr_stmt|;
else|#
directive|else
name|op
operator|=
name|SUN_FROM_X_OP
argument_list|(
name|func
argument_list|)
operator||
name|PIX_COLOR
argument_list|(
name|fore
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|struct
name|pixfont
modifier|*
name|pf
init|=
operator|(
expr|struct
name|pixfont
operator|*
operator|)
name|font
operator|->
name|data
decl_stmt|;
specifier|register
name|struct
name|pr_prpos
modifier|*
name|p
init|=
name|bat
decl_stmt|;
name|lheight
operator|=
name|pf
operator|->
name|pf_defaultsize
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|charpad
operator|==
literal|0
operator|&&
name|spacepad
operator|==
literal|0
condition|)
while|while
condition|(
name|string
operator|<
name|limit
condition|)
block|{
specifier|register
name|struct
name|pixchar
modifier|*
name|pc
init|=
operator|&
operator|(
name|pf
operator|->
name|pf_char
index|[
operator|*
name|string
operator|++
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
operator|||
name|pc
operator|->
name|pc_pr
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|->
name|pr
operator|=
name|pc
operator|->
name|pc_pr
expr_stmt|;
name|p
operator|->
name|pos
operator|.
name|x
operator|=
name|pc
operator|->
name|pc_adv
operator|.
name|x
expr_stmt|;
name|w
operator|+=
name|p
operator|->
name|pos
operator|.
name|x
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|bsize
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|pixchar
modifier|*
name|space
init|=
operator|&
name|pf
operator|->
name|pf_char
index|[
name|font
operator|->
name|space
index|]
decl_stmt|;
while|while
condition|(
name|string
operator|<
name|limit
condition|)
block|{
specifier|register
name|struct
name|pixchar
modifier|*
name|pc
init|=
operator|&
operator|(
name|pf
operator|->
name|pf_char
index|[
operator|*
name|string
operator|++
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
operator|||
name|pc
operator|->
name|pc_pr
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|->
name|pr
operator|=
name|pc
operator|->
name|pc_pr
expr_stmt|;
name|p
operator|->
name|pos
operator|.
name|x
operator|=
name|pc
operator|->
name|pc_adv
operator|.
name|x
operator|+
name|charpad
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|space
condition|)
name|p
operator|->
name|pos
operator|.
name|x
operator|+=
name|spacepad
expr_stmt|;
name|w
operator|+=
name|p
operator|->
name|pos
operator|.
name|x
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|bsize
operator|++
expr_stmt|;
block|}
block|}
block|}
name|sbot
operator|=
name|dsty
operator|+
name|lheight
expr_stmt|;
name|sright
operator|=
name|dstx
operator|+
name|w
expr_stmt|;
if|if
condition|(
name|CursorDisplayed
condition|)
block|{
specifier|extern
name|DEVICE
modifier|*
name|CurrentDevice
decl_stmt|;
specifier|register
name|vsCursor
modifier|*
name|ms
init|=
name|CurrentDevice
operator|->
name|mouse
decl_stmt|;
specifier|register
name|CURSOR
modifier|*
name|cs
init|=
name|CurrentCursor
decl_stmt|;
if|if
condition|(
name|ms
operator|->
name|y
operator|<
name|sbot
operator|&&
name|ms
operator|->
name|x
operator|<
name|sright
operator|&&
name|ms
operator|->
name|y
operator|+
name|cs
operator|->
name|height
operator|>
name|dsty
operator|&&
name|ms
operator|->
name|x
operator|+
name|cs
operator|->
name|width
operator|>
name|dstx
condition|)
name|DisplayCursor
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|GetNextClip
argument_list|(
name|clips
argument_list|,
name|cleft
argument_list|,
name|ctop
argument_list|,
name|cwidth
argument_list|,
name|cheight
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsty
operator|>=
name|ctop
operator|&&
name|sbot
operator|<=
name|ctop
operator|+
name|cheight
operator|&&
name|dstx
operator|>=
name|cleft
operator|&&
name|sright
operator|<=
name|cleft
operator|+
name|cwidth
condition|)
name|pr_batchrop
argument_list|(
name|PixRect
argument_list|,
name|dstx
operator|-
name|bat
index|[
literal|0
index|]
operator|.
name|pos
operator|.
name|x
argument_list|,
name|dsty
argument_list|,
name|op
operator||
name|PIX_DONTCLIP
argument_list|,
name|bat
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|pixrect
modifier|*
name|region
decl_stmt|;
if|if
condition|(
name|dsty
operator|>
name|ctop
operator|+
name|cheight
condition|)
continue|continue;
if|if
condition|(
name|dsty
operator|+
name|lheight
operator|<=
name|ctop
condition|)
continue|continue;
name|region
operator|=
name|pr_region
argument_list|(
name|PixRect
argument_list|,
name|cleft
argument_list|,
name|ctop
argument_list|,
name|cwidth
argument_list|,
name|cheight
argument_list|)
expr_stmt|;
name|pr_batchrop
argument_list|(
name|region
argument_list|,
name|dstx
operator|-
name|cleft
operator|-
name|bat
index|[
literal|0
index|]
operator|.
name|pos
operator|.
name|x
argument_list|,
name|dsty
operator|-
name|ctop
argument_list|,
name|op
argument_list|,
name|bat
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|pr_destroy
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|clipcount
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|!
name|CursorDisplayed
condition|)
name|DisplayCursor
argument_list|(
name|CurrentCursor
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|PrintTextMask
argument_list|(
argument|string
argument_list|,
argument|strlen
argument_list|,
argument|font
argument_list|,
argument|srcpix
argument_list|,
argument|charpad
argument_list|,
argument|spacepad
argument_list|,
argument|dstx
argument_list|,
argument|dsty
argument_list|,
argument|clips
argument_list|,
argument|clipcount
argument_list|,
argument|func
argument_list|,
argument|zmask
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strlen
decl_stmt|,
name|srcpix
decl_stmt|,
name|charpad
decl_stmt|,
name|spacepad
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIP
modifier|*
name|clips
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clipcount
decl_stmt|,
name|zmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|CURSOR
modifier|*
name|CurrentCursor
decl_stmt|;
extern|extern      CursorDisplayed;
name|int
name|cleft
decl_stmt|,
name|ctop
decl_stmt|,
name|cwidth
decl_stmt|,
name|cheight
decl_stmt|;
name|int
name|op
decl_stmt|;
specifier|extern
name|char
name|SSMap
index|[]
decl_stmt|;
define|#
directive|define
name|CHUNK
value|400
name|unsigned
name|char
modifier|*
name|limit
init|=
name|string
operator|+
operator|(
name|strlen
operator|<
name|CHUNK
condition|?
name|strlen
else|:
name|CHUNK
operator|)
decl_stmt|;
specifier|register
name|w
operator|=
literal|0
expr_stmt|;
specifier|static
name|struct
name|pr_prpos
name|bat
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
name|bsize
init|=
literal|0
decl_stmt|;
name|int
name|lheight
decl_stmt|;
name|int
name|sbot
decl_stmt|,
name|sright
decl_stmt|;
name|SetZmask
argument_list|(
name|PixRect
argument_list|,
operator|&
name|zmask
argument_list|)
expr_stmt|;
name|private_bgcolor
operator|=
operator|-
literal|1
expr_stmt|;
name|private_fgcolor
operator|=
name|srcpix
expr_stmt|;
if|if
condition|(
name|PixRect
operator|->
name|pr_depth
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|srcpix
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|func
operator|+=
literal|0x10
expr_stmt|;
name|op
operator|=
name|SUN_FROM_X_OP
argument_list|(
name|SSMap
index|[
name|func
index|]
argument_list|)
operator|&
name|PIX_SRC
operator||
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
operator|&
name|PIX_DST
expr_stmt|;
block|}
else|else
name|op
operator|=
name|SUN_FROM_X_OP
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|PixRect
operator|->
name|pr_depth
operator|>
literal|1
condition|)
name|op
operator||=
name|PIX_COLOR
argument_list|(
name|srcpix
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|pixfont
modifier|*
name|pf
init|=
operator|(
expr|struct
name|pixfont
operator|*
operator|)
name|font
operator|->
name|data
decl_stmt|;
specifier|register
name|struct
name|pr_prpos
modifier|*
name|p
init|=
name|bat
decl_stmt|;
name|lheight
operator|=
name|pf
operator|->
name|pf_defaultsize
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|charpad
operator|==
literal|0
operator|&&
name|spacepad
operator|==
literal|0
condition|)
while|while
condition|(
name|string
operator|<
name|limit
condition|)
block|{
specifier|register
name|struct
name|pixchar
modifier|*
name|pc
init|=
operator|&
operator|(
name|pf
operator|->
name|pf_char
index|[
operator|*
name|string
operator|++
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|->
name|pr
operator|=
name|pc
operator|->
name|pc_pr
expr_stmt|;
name|p
operator|->
name|pos
operator|.
name|x
operator|=
name|pc
operator|->
name|pc_adv
operator|.
name|x
expr_stmt|;
name|w
operator|+=
name|p
operator|->
name|pos
operator|.
name|x
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|bsize
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|pixchar
modifier|*
name|space
init|=
operator|&
name|pf
operator|->
name|pf_char
index|[
name|font
operator|->
name|space
index|]
decl_stmt|;
while|while
condition|(
name|string
operator|<
name|limit
condition|)
block|{
specifier|register
name|struct
name|pixchar
modifier|*
name|pc
init|=
operator|&
operator|(
name|pf
operator|->
name|pf_char
index|[
operator|*
name|string
operator|++
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|->
name|pr
operator|=
name|pc
operator|->
name|pc_pr
expr_stmt|;
name|p
operator|->
name|pos
operator|.
name|x
operator|=
name|pc
operator|->
name|pc_adv
operator|.
name|x
operator|+
name|charpad
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|space
condition|)
name|p
operator|->
name|pos
operator|.
name|x
operator|+=
name|spacepad
expr_stmt|;
name|w
operator|+=
name|p
operator|->
name|pos
operator|.
name|x
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|bsize
operator|++
expr_stmt|;
block|}
block|}
block|}
name|sbot
operator|=
name|dsty
operator|+
name|lheight
expr_stmt|;
name|sright
operator|=
name|dstx
operator|+
name|w
expr_stmt|;
if|if
condition|(
name|CursorDisplayed
condition|)
block|{
specifier|extern
name|DEVICE
modifier|*
name|CurrentDevice
decl_stmt|;
specifier|register
name|vsCursor
modifier|*
name|ms
init|=
name|CurrentDevice
operator|->
name|mouse
decl_stmt|;
specifier|register
name|CURSOR
modifier|*
name|cs
init|=
name|CurrentCursor
decl_stmt|;
if|if
condition|(
name|ms
operator|->
name|y
operator|<
name|sbot
operator|&&
name|ms
operator|->
name|x
operator|<
name|sright
operator|&&
name|ms
operator|->
name|y
operator|+
name|cs
operator|->
name|height
operator|>
name|dsty
operator|&&
name|ms
operator|->
name|x
operator|+
name|cs
operator|->
name|width
operator|>
name|dstx
condition|)
name|DisplayCursor
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|GetNextClip
argument_list|(
name|clips
argument_list|,
name|cleft
argument_list|,
name|ctop
argument_list|,
name|cwidth
argument_list|,
name|cheight
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsty
operator|>=
name|ctop
operator|&&
name|sbot
operator|<=
name|ctop
operator|+
name|cheight
operator|&&
name|dstx
operator|>=
name|cleft
operator|&&
name|sright
operator|<=
name|cleft
operator|+
name|cwidth
condition|)
name|pr_batchrop
argument_list|(
name|PixRect
argument_list|,
name|dstx
operator|-
name|bat
index|[
literal|0
index|]
operator|.
name|pos
operator|.
name|x
argument_list|,
name|dsty
argument_list|,
name|op
operator||
name|PIX_DONTCLIP
argument_list|,
name|bat
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|pixrect
modifier|*
name|region
decl_stmt|;
if|if
condition|(
name|dsty
operator|>
name|ctop
operator|+
name|cheight
condition|)
continue|continue;
if|if
condition|(
name|dsty
operator|+
name|lheight
operator|<=
name|ctop
condition|)
continue|continue;
name|region
operator|=
name|pr_region
argument_list|(
name|PixRect
argument_list|,
name|cleft
argument_list|,
name|ctop
argument_list|,
name|cwidth
argument_list|,
name|cheight
argument_list|)
expr_stmt|;
name|pr_batchrop
argument_list|(
name|region
argument_list|,
name|dstx
operator|-
name|cleft
operator|-
name|bat
index|[
literal|0
index|]
operator|.
name|pos
operator|.
name|x
argument_list|,
name|dsty
operator|-
name|ctop
argument_list|,
name|op
argument_list|,
name|bat
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|pr_destroy
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|clipcount
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|!
name|CursorDisplayed
condition|)
name|DisplayCursor
argument_list|(
name|CurrentCursor
argument_list|)
expr_stmt|;
block|{
specifier|static
name|allmask
operator|=
operator|-
literal|1
expr_stmt|;
name|SetZmask
argument_list|(
name|PixRect
argument_list|,
operator|&
name|allmask
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Copyright (c) 1983 by Sun Microsystems, Inc.  */
end_comment

begin_comment
comment|/*  * Memory batchrop  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|pr_reversedst
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pixrectops
name|mem_ops
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MEMBATCH
parameter_list|(
name|IfClip
parameter_list|,
name|IfMask
parameter_list|,
name|op
parameter_list|,
name|IfReverse
parameter_list|)
define|\
value|for (; --count>= 0; src++) {					\ 	dst.pos.x += src->pos.x;					\ 	dp = dp0 + (((dskew = xoff0 + dst.pos.x)>> 3)& ~1);		\ 	dskew&= 0xF;							\ 	spr = src->pr;							\ 	sizex = spr->pr_size.x;						\ 	sizey = spr->pr_size.y;						\ 	sprd = mpr_d(spr);						\ 	if (sprd->md_linebytes != 2)					\ 	    goto hard;							\ 	sp = (u_short *) sprd->md_image;				\ 	IfClip(	if (dst.pos.x + sizex> limx)				\ 		    goto hard;						\ 		if (dst.pos.y + sizey> limy)				\ 		sizey = limy - dst.pos.y;				\ 		if (dst.pos.x< 0)					\ 		    goto hard;						\ 		if (dst.pos.y< 0) {					\ 		    sizey += dst.pos.y;					\ 		    sp -= dst.pos.y;					\ 		    dp -= pr_product(dst.pos.y, vert);			\ 		}							\ 		if (sizex<= 0)						\ 		    continue;						\ 	,)								\ 	if (--sizey>=0)							\ 	if (dskew + sizex<= 16) {					\ 	    IfMask(	register short mask;				\ 			mask = 0x8000;					\ 			sizex -= 1;					\ 			mask>>= sizex;					\ 			((unsigned short) mask)>>= dskew;		\ 			IfReverse(mask = ~mask;,),)			\ 	    do {							\ 		IfMask(*(u_short *) dp IfReverse(&,|)= mask;,)		\ 		    *(u_short *) dp op (*sp++>> dskew);		\ 		dp += vert;						\ 	    } while (--sizey != -1);					\ 	}								\ 	else {								\ 	    IfMask(	register long mask;				\ 			mask = 0x80000000;				\ 			sizex -= 1;					\ 			mask>>= sizex;					\ 			((unsigned long) mask)>>= dskew;		\ 			IfReverse(mask = ~mask;,),)			\ 	    dskew = 16 - dskew;						\ 	    do {							\ 		IfMask(*(u_int *) dp IfReverse(&,|)= mask;,)		\ 		*(u_int *) dp op (*sp++<< dskew);			\ 		dp += vert;						\ 	    } while (--sizey != -1);					\ 	}								\     }
end_define

begin_define
define|#
directive|define
name|MTRUE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a
end_define

begin_define
define|#
directive|define
name|MFALSE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|b
end_define

begin_define
define|#
directive|define
name|ClippedOp
parameter_list|(
name|mask
parameter_list|,
name|op
parameter_list|,
name|revmask
parameter_list|)
define|\
value|if(clip) MEMBATCH(MTRUE,mask,op,revmask) \     else MEMBATCH(MFALSE,mask,op,revmask)
end_define

begin_macro
name|mem_batchrop
argument_list|(
argument|dst
argument_list|,
argument|op
argument_list|,
argument|src
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pr_prpos
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pr_prpos
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|dp0
decl_stmt|;
specifier|register
name|char
modifier|*
name|handy
decl_stmt|;
specifier|register
name|short
name|sizex
decl_stmt|,
name|sizey
decl_stmt|;
specifier|register
name|vert
operator|,
name|dskew
expr_stmt|;
name|int
name|dskew0
decl_stmt|,
name|xoff0
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|int
name|clip
decl_stmt|,
name|limx
decl_stmt|,
name|limy
decl_stmt|;
name|int
name|oppassed
init|=
name|op
decl_stmt|;
comment|/*      * Preliminaries: get pixrect data and image pointers; decide whether      * clipping.  If not clipping, normalize op, else compute limits for      * cursors for later comparisons.       */
name|clip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|&
name|PIX_DONTCLIP
operator|)
condition|)
block|{
name|clip
operator|=
literal|1
expr_stmt|;
name|limx
operator|=
name|dst
operator|.
name|pr
operator|->
name|pr_size
operator|.
name|x
expr_stmt|;
name|limy
operator|=
name|dst
operator|.
name|pr
operator|->
name|pr_size
operator|.
name|y
expr_stmt|;
block|}
name|op
operator|=
operator|(
name|op
operator|>>
literal|1
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|/* Kill dontclip, just keep useful */
comment|/*      * If destination is reverse video, invert function. FIXME: we dont      * deal with a reverse video source. Admittedly its unlikely that      * anyone will call batchrop with a device pixrect as source (since we      * copy the whole pixrect), but this is a bug.       */
if|if
condition|(
name|mpr_d
argument_list|(
name|dst
operator|.
name|pr
argument_list|)
operator|->
name|md_flags
operator|&
name|MP_REVERSEVIDEO
condition|)
name|op
operator|=
name|pr_reversedst
index|[
name|op
index|]
expr_stmt|;
name|vert
operator|=
name|mpr_d
argument_list|(
name|dst
operator|.
name|pr
argument_list|)
operator|->
name|md_linebytes
expr_stmt|;
define|#
directive|define
name|dprd
value|((struct mpr_data *)handy)
name|dprd
operator|=
name|mpr_d
argument_list|(
name|dst
operator|.
name|pr
argument_list|)
expr_stmt|;
name|xoff0
operator|=
name|dprd
operator|->
name|md_offset
operator|.
name|x
expr_stmt|;
name|dp0
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|dprd
operator|->
name|md_image
operator|+
name|pr_product
argument_list|(
name|dprd
operator|->
name|md_linebytes
argument_list|,
name|dst
operator|.
name|pos
operator|.
name|y
operator|+
name|dprd
operator|->
name|md_offset
operator|.
name|y
argument_list|)
operator|)
expr_stmt|;
undef|#
directive|undef
name|dprd
name|restart
label|:
define|#
directive|define
name|spr
value|((struct pixrect *)handy)
define|#
directive|define
name|sprd
value|((struct mpr_data *)handy)
switch|switch
condition|(
name|op
condition|)
block|{
case|case
operator|(
name|PIX_SRC
operator|^
name|PIX_DST
operator|)
operator|>>
literal|1
case|:
name|ClippedOp
argument_list|(
name|MFALSE
argument_list|,
operator|^=
argument_list|,
name|MTRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIX_SRC
operator|>>
literal|1
case|:
name|ClippedOp
argument_list|(
name|MTRUE
argument_list|,
operator||=
argument_list|,
name|MTRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
operator|>>
literal|1
case|:
name|ClippedOp
argument_list|(
name|MTRUE
argument_list|,
operator|^=
argument_list|,
name|MFALSE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|PIX_SRC
operator||
name|PIX_DST
operator|)
operator|>>
literal|1
case|:
name|ClippedOp
argument_list|(
name|MFALSE
argument_list|,
operator||=
argument_list|,
name|MTRUE
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
operator|&
name|PIX_DST
operator|)
operator|>>
literal|1
case|:
name|ClippedOp
argument_list|(
name|MFALSE
argument_list|,
operator|&=
operator|~
argument_list|,
name|MTRUE
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
init|;
operator|--
name|count
operator|>=
literal|0
condition|;
name|src
operator|++
control|)
block|{
name|dst
operator|.
name|pos
operator|.
name|x
operator|+=
name|src
operator|->
name|pos
operator|.
name|x
expr_stmt|;
name|errors
operator||=
name|mem_rop
argument_list|(
name|dst
operator|.
name|pr
argument_list|,
name|dst
operator|.
name|pos
argument_list|,
name|src
operator|->
name|pr
operator|->
name|pr_size
argument_list|,
name|oppassed
argument_list|,
name|src
operator|->
name|pr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|errors
return|;
name|hard
label|:
if|if
condition|(
name|dst
operator|.
name|pos
operator|.
name|x
operator|+
name|sizex
operator|<=
literal|0
condition|)
comment|/* 	 * Completely clipped on left...  	 */
empty_stmt|;
else|else
block|{
name|errors
operator||=
name|mem_rop
argument_list|(
name|dst
operator|.
name|pr
argument_list|,
name|dst
operator|.
name|pos
argument_list|,
name|src
operator|->
name|pr
operator|->
name|pr_size
argument_list|,
name|oppassed
argument_list|,
name|src
operator|->
name|pr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|src
operator|++
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
end_block

begin_comment
comment|/*  * cg2batch.c: Sun2 Color batchrop  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pixrectops
name|mem_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|mrc_lmasktable
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|mrc_rmasktable
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|resolution
value|unused, 0
end_define

begin_macro
name|cg2_batchrop
argument_list|(
argument|dst
argument_list|,
argument|op
argument_list|,
argument|src
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pr_prpos
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pr_prpos
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|sizey
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|,
name|w
decl_stmt|,
name|prime
decl_stmt|,
name|linebytes
decl_stmt|;
specifier|register
name|short
modifier|*
name|bx
decl_stmt|,
modifier|*
name|leftx
decl_stmt|,
modifier|*
name|ma
decl_stmt|;
specifier|register
name|struct
name|memropc
modifier|*
name|ropregs
decl_stmt|;
name|short
name|sizex
decl_stmt|;
name|int
name|clip
decl_stmt|;
name|struct
name|pixrect
modifier|*
name|pr
decl_stmt|;
name|short
modifier|*
name|ma_homey
decl_stmt|;
name|short
name|homex
decl_stmt|,
name|homey
decl_stmt|,
name|limx
decl_stmt|,
name|limy
decl_stmt|,
name|dstx
decl_stmt|,
name|dsty
decl_stmt|,
name|by
decl_stmt|;
name|struct
name|cg2fb
modifier|*
name|fb
decl_stmt|;
name|struct
name|mpr_data
modifier|*
name|md
decl_stmt|;
name|int
name|oppassed
init|=
name|op
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|short
name|color
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * Preliminaries: get pixrect data and frame buffer pointers; decide      * whether clipping.  If not clipping, normalize op, else compute      * limits for cursors for later comparisons.       */
define|#
directive|define
name|dbd
value|((struct cg2pr *)leftx)
name|dbd
operator|=
name|cg2_d
argument_list|(
name|dst
operator|.
name|pr
argument_list|)
expr_stmt|;
name|homex
operator|=
name|dbd
operator|->
name|cgpr_offset
operator|.
name|x
expr_stmt|;
name|homey
operator|=
name|dbd
operator|->
name|cgpr_offset
operator|.
name|y
expr_stmt|;
define|#
directive|define
name|FB
value|((struct cg2fb *)leftx)
name|FB
operator|=
name|dbd
operator|->
name|cgpr_va
expr_stmt|;
name|fb
operator|=
name|FB
expr_stmt|;
undef|#
directive|undef
name|dbd
name|ropregs
operator|=
operator|&
name|FB
operator|->
name|ropcontrol
index|[
name|CG2_ALLROP
index|]
operator|.
name|ropregs
expr_stmt|;
if|if
condition|(
name|op
operator|&
name|PIX_DONTCLIP
condition|)
block|{
name|op
operator|&=
operator|~
name|PIX_DONTCLIP
expr_stmt|;
name|clip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|clip
operator|=
literal|1
expr_stmt|;
name|limx
operator|=
name|homex
operator|+
name|dst
operator|.
name|pr
operator|->
name|pr_size
operator|.
name|x
expr_stmt|;
name|limy
operator|=
name|homey
operator|+
name|dst
operator|.
name|pr
operator|->
name|pr_size
operator|.
name|y
expr_stmt|;
block|}
name|dstx
operator|=
name|homex
operator|+
name|dst
operator|.
name|pos
operator|.
name|x
expr_stmt|;
name|dsty
operator|=
name|homey
operator|+
name|dst
operator|.
name|pos
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|private_bgcolor
operator|<
literal|0
condition|)
block|{
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
name|private_fgcolor
expr_stmt|;
comment|/* set colored text */
name|ropregs
operator|->
name|mrc_pattern
operator|=
operator|-
literal|1
expr_stmt|;
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
operator|~
name|private_fgcolor
expr_stmt|;
name|ropregs
operator|->
name|mrc_pattern
operator|=
literal|0
expr_stmt|;
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
name|private_czmask
expr_stmt|;
switch|switch
condition|(
name|op
operator|&
literal|0x1E
condition|)
block|{
case|case
name|PIX_SRC
operator|^
name|PIX_DST
case|:
name|ropregs
operator|->
name|mrc_op
operator|=
name|CG_SRC
operator|&
operator|(
name|CG_MASK
operator|^
name|CG_DEST
operator|)
operator||
operator|~
name|CG_SRC
operator|&
name|CG_DEST
expr_stmt|;
break|break;
case|case
name|PIX_NOT
argument_list|(
name|PIX_DST
argument_list|)
case|:
name|ropregs
operator|->
name|mrc_op
operator|=
name|CG_SRC
operator|&
operator|(
operator|~
name|CG_DEST
operator|)
operator||
operator|~
name|CG_SRC
operator|&
name|CG_DEST
expr_stmt|;
break|break;
default|default:
name|ropregs
operator|->
name|mrc_op
operator|=
name|CG_SRC
operator|&
name|CG_MASK
operator||
operator|~
name|CG_SRC
operator|&
name|CG_DEST
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
name|private_fgcolor
operator|&
name|private_bgcolor
expr_stmt|;
name|ropregs
operator|->
name|mrc_op
operator|=
operator|~
literal|0
expr_stmt|;
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
operator|~
operator|(
name|private_fgcolor
operator||
name|private_bgcolor
operator|)
expr_stmt|;
name|ropregs
operator|->
name|mrc_op
operator|=
literal|0
expr_stmt|;
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
name|private_fgcolor
operator|&
operator|~
name|private_bgcolor
expr_stmt|;
name|ropregs
operator|->
name|mrc_op
operator|=
name|CG_SRC
expr_stmt|;
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
operator|~
name|private_fgcolor
operator|&
name|private_bgcolor
expr_stmt|;
name|ropregs
operator|->
name|mrc_op
operator|=
operator|~
name|CG_SRC
expr_stmt|;
name|FB
operator|->
name|ppmask
operator|.
name|reg
operator|=
name|private_czmask
expr_stmt|;
block|}
name|FB
operator|->
name|status
operator|.
name|reg
operator|.
name|ropmode
operator|=
name|PWWWRD
expr_stmt|;
name|linebytes
operator|=
name|cg2_linebytes
argument_list|(
name|FB
argument_list|,
name|PWWWRD
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FB
for|for
control|(
init|;
operator|--
name|count
operator|>=
literal|0
condition|;
name|src
operator|++
control|)
block|{
comment|/* 	 * Update destination x and y by pre-advance amount. If no pixrect 	 * for this, then skip to next.  	 */
name|dstx
operator|+=
name|src
operator|->
name|pos
operator|.
name|x
expr_stmt|;
name|pr
operator|=
name|src
operator|->
name|pr
expr_stmt|;
if|if
condition|(
name|pr
operator|==
literal|0
condition|)
continue|continue;
name|sizex
operator|=
name|pr
operator|->
name|pr_size
operator|.
name|x
expr_stmt|;
name|sizey
operator|=
name|pr
operator|->
name|pr_size
operator|.
name|y
expr_stmt|;
name|md
operator|=
name|mpr_d
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|ma
operator|=
name|md
operator|->
name|md_image
expr_stmt|;
comment|/* 	 * Grab sizes and address of image.  If clipping (rare case 	 * hopefully) compare cursors against limits.  	 */
name|by
operator|=
name|dsty
expr_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clip
condition|)
block|{
if|if
condition|(
name|dstx
operator|+
name|sizex
operator|>
name|limx
condition|)
name|sizex
operator|=
name|limx
operator|-
name|dstx
expr_stmt|;
if|if
condition|(
name|dsty
operator|+
name|sizey
operator|>
name|limy
condition|)
name|sizey
operator|=
name|limy
operator|-
name|dsty
expr_stmt|;
if|if
condition|(
name|dsty
operator|<
name|homey
condition|)
block|{
comment|/* works if pr_depth = 1! */
name|tem
operator|=
name|homey
operator|-
name|dsty
expr_stmt|;
name|by
operator|+=
name|tem
expr_stmt|;
name|ma
operator|+=
name|pr_product
argument_list|(
name|tem
argument_list|,
operator|(
name|md
operator|->
name|md_linebytes
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sizey
operator|-=
name|tem
expr_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dstx
operator|<
name|homex
condition|)
block|{
name|tem
operator|=
name|homex
operator|-
name|dstx
expr_stmt|;
name|ma
operator|+=
name|tem
operator|>>
literal|4
expr_stmt|;
name|sizex
operator|-=
name|tem
expr_stmt|;
block|}
if|if
condition|(
name|sizex
operator|<=
literal|0
condition|)
continue|continue;
block|}
comment|/* 	 * Hard case: characters greater than 16 wide.  	 */
name|ma_homey
operator|=
name|ma
expr_stmt|;
comment|/* set the ROP chip word width and opcount */
name|w
operator|=
name|cg2_prskew
argument_list|(
name|dstx
argument_list|)
expr_stmt|;
comment|/* source skew is 0 */
name|ropregs
operator|->
name|mrc_shift
operator|=
operator|(
name|w
operator|&
literal|0xF
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|prime
operator|=
operator|!
name|w
expr_stmt|;
name|w
operator|=
operator|(
name|sizex
operator|+
name|w
operator|+
operator|(
name|tem
operator|&
literal|0xF
operator|)
operator|-
literal|1
operator|)
operator|>>
literal|4
expr_stmt|;
name|ropregs
operator|->
name|mrc_width
operator|=
name|w
expr_stmt|;
name|ropregs
operator|->
name|mrc_opcount
operator|=
name|w
expr_stmt|;
comment|/* set the ROP chip end masks */
name|ropregs
operator|->
name|mrc_mask1
operator|=
name|mrc_lmasktable
index|[
operator|(
name|tem
operator|+=
name|dstx
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|ropregs
operator|->
name|mrc_mask2
operator|=
name|mrc_rmasktable
index|[
operator|(
name|sizex
operator|+
name|tem
operator|-
literal|1
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|leftx
operator|=
name|cg2_ropwordaddr
argument_list|(
name|fb
argument_list|,
literal|0
argument_list|,
name|tem
argument_list|,
name|by
argument_list|)
expr_stmt|;
name|tem
operator|=
name|md
operator|->
name|md_linebytes
expr_stmt|;
if|if
condition|(
operator|--
name|sizey
operator|>=
literal|0
condition|)
if|if
condition|(
name|w
condition|)
block|{
name|w
operator|++
expr_stmt|;
do|do
block|{
specifier|register
name|short
name|i
init|=
name|w
decl_stmt|;
name|ma
operator|=
name|ma_homey
expr_stmt|;
name|bx
operator|=
name|leftx
expr_stmt|;
if|if
condition|(
name|prime
condition|)
name|ropregs
operator|->
name|mrc_source1
operator|=
operator|*
name|ma
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|bx
operator|++
operator|=
operator|*
name|ma
operator|++
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|ma_homey
operator|+=
name|tem
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|leftx
operator|+=
name|linebytes
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|sizey
operator|!=
operator|-
literal|1
condition|)
do|;
block|}
else|else
block|{
name|bx
operator|=
name|leftx
expr_stmt|;
name|ma
operator|=
name|ma_homey
expr_stmt|;
if|if
condition|(
name|prime
condition|)
block|{
name|ma
operator|++
expr_stmt|;
do|do
block|{
name|ma
operator|--
expr_stmt|;
name|ropregs
operator|->
name|mrc_source1
operator|=
operator|*
name|ma
operator|++
expr_stmt|;
operator|*
name|bx
operator|=
operator|*
name|ma
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|ma
operator|+=
name|tem
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|bx
operator|+=
name|linebytes
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|sizey
operator|!=
operator|-
literal|1
condition|)
do|;
block|}
else|else
do|do
block|{
operator|*
name|bx
operator|=
operator|*
name|ma
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|ma
operator|+=
name|tem
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|bx
operator|+=
name|linebytes
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|sizey
operator|!=
operator|-
literal|1
condition|)
do|;
block|}
block|}
return|return
operator|(
name|errors
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|sun
end_endif

end_unit

