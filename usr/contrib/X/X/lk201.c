begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_comment
comment|/* This file is device dependent, but is common to several devices */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_lk201_c
init|=
literal|"$Header: lk201.c,v 10.6 86/02/01 15:16:27 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"vsinput.h"
end_include

begin_define
define|#
directive|define
name|KEYDOWN_ERROR
value|0x3d
end_define

begin_define
define|#
directive|define
name|POWERUP_ERROR
value|0x3e
end_define

begin_define
define|#
directive|define
name|BASEKEY
value|0x41
end_define

begin_define
define|#
directive|define
name|MINSPECIAL
value|0xb3
end_define

begin_define
define|#
directive|define
name|ALLUPS
value|0xb3
end_define

begin_define
define|#
directive|define
name|METRONOME
value|0xb4
end_define

begin_define
define|#
directive|define
name|OUTPUT_ERROR
value|0xb5
end_define

begin_define
define|#
directive|define
name|INPUT_ERROR
value|0xb6
end_define

begin_define
define|#
directive|define
name|MAXSPECIAL
value|0xba
end_define

begin_decl_stmt
specifier|static
name|u_char
name|lastkey
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMDIVS
value|14
end_define

begin_decl_stmt
specifier|static
name|u_char
name|divbeg
index|[
name|NUMDIVS
index|]
init|=
block|{
literal|0xbf
block|,
literal|0x91
block|,
literal|0xbc
block|,
literal|0xbd
block|,
literal|0xb0
block|,
literal|0xad
block|,
literal|0xa6
block|,
literal|0xa9
block|,
literal|0x88
block|,
literal|0x56
block|,
literal|0x63
block|,
literal|0x6f
block|,
literal|0x7b
block|,
literal|0x7e
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|divend
index|[
name|NUMDIVS
index|]
init|=
block|{
literal|0xff
block|,
literal|0xa5
block|,
literal|0xbc
block|,
literal|0xbe
block|,
literal|0xb2
block|,
literal|0xaf
block|,
literal|0xa8
block|,
literal|0xac
block|,
literal|0x90
block|,
literal|0x62
block|,
literal|0x6e
block|,
literal|0x7a
block|,
literal|0x7d
block|,
literal|0x87
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initially set for keyboard defaults */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keymodes
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x0000c000
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* down/up keys */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keys
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* down/up keys that are currently down */
end_comment

begin_comment
comment|/* Handle keyboard/button input from LK201/mouse */
end_comment

begin_expr_stmt
name|ProcessInput
argument_list|(
name|ev
argument_list|)
specifier|register
name|vsEvent
operator|*
name|ev
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|idx
decl_stmt|,
name|key
decl_stmt|,
name|bits
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|vse_direction
operator|!=
name|VSE_KBTRAW
condition|)
block|{
name|Deal_with_input
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|key
operator|=
name|ev
operator|->
name|vse_key
expr_stmt|;
if|if
condition|(
name|key
operator|>
name|MAXSPECIAL
operator|||
operator|(
name|key
operator|>=
name|BASEKEY
operator|&&
name|key
operator|<
name|MINSPECIAL
operator|)
condition|)
block|{
name|lastkey
operator|=
name|key
expr_stmt|;
name|idx
operator|=
name|key
operator|>>
literal|5
expr_stmt|;
name|key
operator|&=
literal|0x1f
expr_stmt|;
name|key
operator|=
literal|1
operator|<<
name|key
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|keymodes
index|[
name|idx
index|]
operator|&
name|key
operator|)
operator|||
operator|(
operator|(
name|keys
index|[
name|idx
index|]
operator|^=
name|key
operator|)
operator|&
name|key
operator|)
condition|)
name|ev
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
else|else
name|ev
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
name|Deal_with_input
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|METRONOME
case|:
name|ev
operator|->
name|vse_direction
operator|=
name|VSE_KBTDOWN
expr_stmt|;
name|ev
operator|->
name|vse_key
operator|=
name|lastkey
expr_stmt|;
name|Deal_with_input
argument_list|(
name|ev
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALLUPS
case|:
name|idx
operator|=
literal|7
expr_stmt|;
name|ev
operator|->
name|vse_direction
operator|=
name|VSE_KBTUP
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bits
operator|=
name|keys
index|[
name|idx
index|]
condition|)
block|{
name|keys
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bits
operator|&
literal|1
condition|)
block|{
name|ev
operator|->
name|vse_key
operator|=
operator|(
name|idx
operator|<<
literal|5
operator|)
operator||
name|key
expr_stmt|;
name|Deal_with_input
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
name|key
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|bits
operator|>>=
literal|1
condition|)
do|;
block|}
block|}
do|while
condition|(
operator|--
name|idx
operator|>=
literal|0
condition|)
do|;
break|break;
case|case
name|POWERUP_ERROR
case|:
case|case
name|KEYDOWN_ERROR
case|:
case|case
name|OUTPUT_ERROR
case|:
case|case
name|INPUT_ERROR
case|:
name|DeviceError
argument_list|(
literal|"keyboard error"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Put keyboard in autorepeat mode and return control command string.  * autorepeat/down: main keyboard, numeric keypad, delete, cursors  * up/down: all others  */
end_comment

begin_function
name|char
modifier|*
name|AutoRepeatLKMode
parameter_list|()
block|{
name|ResetLKModes
argument_list|(
literal|0x3f38
argument_list|)
expr_stmt|;
return|return
operator|(
literal|"\212\222\232\246\256\266\272\302\316\326\336\346\356\366"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Put all of keyboard in down/up mode and return control command string */
end_comment

begin_function
name|char
modifier|*
name|UpDownLKMode
parameter_list|()
block|{
name|ResetLKModes
argument_list|(
literal|0x3fff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|"\216\226\236\246\256\266\276\306\316\326\336\346\356\366"
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|ResetLKModes
argument_list|(
name|modes
argument_list|)
specifier|register
name|int
name|modes
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|key
decl_stmt|,
name|last
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|keymodes
argument_list|,
sizeof|sizeof
argument_list|(
name|keymodes
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|modes
operator|&
literal|1
condition|)
block|{
for|for
control|(
name|key
operator|=
name|divbeg
index|[
name|i
index|]
operator|,
name|last
operator|=
name|divend
index|[
name|i
index|]
init|;
name|key
operator|<=
name|last
condition|;
name|key
operator|++
control|)
name|keymodes
index|[
name|key
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|key
operator|&
literal|0x1f
operator|)
expr_stmt|;
block|}
name|modes
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|NUMDIVS
condition|)
do|;
block|}
end_block

end_unit

