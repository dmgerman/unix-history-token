begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_comment
comment|/*	Routines to manage various kinds of resources:  *  *	Add_resource, Free_resource, Free_client_resources,  *	Bit_size, Pix_size,  *	Get_font, Store_cursor,  *	Define_self, Reset_hosts, Add_host, Remove_host, Invalid_host,  *	Store_cut, Fetch_cut, Rotate_cuts, Reset_cuts,  *	Init_colormap,  *	Get_color, Get_cells, Free_colors, Store_colors, Query_color,  *	Alloc_rectangle, Free_rectangles, Free_rectangle_storage,  *	Xalloc, Xrealloc  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_resource_c
init|=
literal|"$Header: resource.c,v 10.11 86/02/01 15:17:05 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"Xint.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_include
include|#
directive|include
file|<netdnet/dnetdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|Xstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DEVICE
name|device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Xalloc
argument_list|()
decl_stmt|,
modifier|*
name|Xrealloc
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FONT
modifier|*
name|GetFont
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|CURSOR
modifier|*
name|StoreCursor
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|resalloc
value|50
end_define

begin_comment
comment|/* Each resource is indexed (by the low bits of the resource id) through  * Resources, and chained through ClientResources.  */
end_comment

begin_decl_stmt
name|RESOURCE
modifier|*
modifier|*
name|Resources
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RESOURCE
modifier|*
name|ClientResources
index|[
name|maxsocks
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|MaxResource
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RESOURCE
modifier|*
name|FreeResource
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ridinc
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|ridmask
value|((1<< 29) - 1)
end_define

begin_decl_stmt
specifier|static
name|long
name|ridseed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_host
block|{
name|short
name|family
decl_stmt|;
name|short
name|len
decl_stmt|;
name|char
name|addr
index|[
literal|4
index|]
decl_stmt|;
comment|/* will need to be bigger eventually */
name|struct
name|_host
modifier|*
name|next
decl_stmt|;
block|}
name|HOST
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|HOST
modifier|*
name|selfhosts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST
modifier|*
name|validhosts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_cmentry
block|{
name|short
name|refcnt
decl_stmt|;
comment|/* reference count (-1 means writable) */
name|ushort
name|red
decl_stmt|;
comment|/* color value */
name|ushort
name|green
decl_stmt|;
name|ushort
name|blue
decl_stmt|;
block|}
name|CMENTRY
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CMENTRY
modifier|*
name|colormap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the color map */
end_comment

begin_decl_stmt
specifier|static
name|int
name|free_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of unallocated entries */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numpixels
index|[
name|maxsocks
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pixel held by each client */
end_comment

begin_decl_stmt
specifier|static
name|ushort
modifier|*
name|clientpixels
index|[
name|maxsocks
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lists of pixels held by each client */
end_comment

begin_define
define|#
directive|define
name|NUMCUTS
value|8
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cutbuf
index|[
name|NUMCUTS
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cutbuflen
index|[
name|NUMCUTS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|base_cut
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base cut buffer */
end_comment

begin_decl_stmt
name|RECTANGLE
modifier|*
name|free_rectangles
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define a client visible resource */
end_comment

begin_function
name|long
name|Add_resource
parameter_list|(
name|type
parameter_list|,
name|client
parameter_list|,
name|value
parameter_list|)
name|int
name|type
decl_stmt|,
name|client
decl_stmt|;
name|caddr_t
name|value
decl_stmt|;
block|{
specifier|register
name|RESOURCE
modifier|*
name|rptr
decl_stmt|,
modifier|*
modifier|*
name|res
decl_stmt|;
specifier|register
name|int
name|ridx
decl_stmt|;
if|if
condition|(
operator|(
name|rptr
operator|=
name|FreeResource
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no room, expand the resource table */
name|rptr
operator|=
operator|(
name|RESOURCE
operator|*
operator|)
name|Xalloc
argument_list|(
name|resalloc
operator|*
sizeof|sizeof
argument_list|(
name|RESOURCE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ridx
operator|=
name|MaxResource
condition|)
block|{
name|res
operator|=
operator|(
name|RESOURCE
operator|*
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|caddr_t
operator|)
name|Resources
argument_list|,
operator|(
name|ridx
operator|+
name|resalloc
operator|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
operator|(
name|RESOURCE
operator|*
operator|*
operator|)
name|Xalloc
argument_list|(
name|resalloc
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|ridx
operator|++
expr_stmt|;
name|rptr
operator|++
expr_stmt|;
block|}
name|Resources
operator|=
name|res
expr_stmt|;
name|res
operator|+=
name|ridx
expr_stmt|;
name|MaxResource
operator|+=
name|resalloc
expr_stmt|;
comment|/* initialize the spares */
while|while
condition|(
name|ridx
operator|<
name|MaxResource
condition|)
block|{
operator|*
name|res
operator|++
operator|=
name|rptr
expr_stmt|;
name|rptr
operator|->
name|type
operator|=
name|RT_FREE
expr_stmt|;
name|rptr
operator|->
name|id
operator|=
name|ridx
expr_stmt|;
name|rptr
operator|->
name|next
operator|=
name|FreeResource
expr_stmt|;
name|FreeResource
operator|=
name|rptr
expr_stmt|;
name|ridx
operator|++
expr_stmt|;
name|rptr
operator|++
expr_stmt|;
block|}
name|rptr
operator|=
name|FreeResource
expr_stmt|;
block|}
name|FreeResource
operator|=
name|rptr
operator|->
name|next
expr_stmt|;
name|rptr
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rptr
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|res
operator|=
operator|&
name|ClientResources
index|[
name|client
index|]
expr_stmt|;
name|rptr
operator|->
name|prev
operator|=
operator|(
name|RESOURCE
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|next
operator|=
operator|*
name|res
condition|)
operator|(
operator|*
name|res
operator|)
operator|->
name|prev
operator|=
name|rptr
expr_stmt|;
operator|*
name|res
operator|=
name|rptr
expr_stmt|;
name|ridseed
operator|+=
name|ridinc
expr_stmt|;
name|ridseed
operator|&=
name|ridmask
expr_stmt|;
return|return
operator|(
name|rptr
operator|->
name|id
operator|=
name|ridseed
operator|+
name|RESIDX
argument_list|(
name|rptr
operator|->
name|id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free a client visible resource */
end_comment

begin_expr_stmt
name|Free_resource
argument_list|(
name|rptr
argument_list|)
specifier|register
name|RESOURCE
operator|*
name|rptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|rptr
operator|->
name|type
condition|)
block|{
case|case
name|RT_WINDOW
case|:
name|Destroy_window
argument_list|(
operator|(
name|WINDOW
operator|*
operator|)
name|rptr
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_FONT
case|:
if|if
condition|(
operator|--
operator|(
operator|(
name|FONT
operator|*
operator|)
name|rptr
operator|->
name|value
operator|)
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreeFont
argument_list|(
operator|(
name|FONT
operator|*
operator|)
name|rptr
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_BITMAP
case|:
if|if
condition|(
operator|--
operator|(
operator|(
name|BITMAP
operator|*
operator|)
name|rptr
operator|->
name|value
operator|)
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreeBitmap
argument_list|(
operator|(
name|BITMAP
operator|*
operator|)
name|rptr
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_PIXMAP
case|:
if|if
condition|(
operator|--
operator|(
operator|(
name|PIXMAP
operator|*
operator|)
name|rptr
operator|->
name|value
operator|)
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreePixmap
argument_list|(
operator|(
name|PIXMAP
operator|*
operator|)
name|rptr
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|RT_CURSOR
case|:
if|if
condition|(
operator|--
operator|(
operator|(
name|CURSOR
operator|*
operator|)
name|rptr
operator|->
name|value
operator|)
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|FreeCursor
argument_list|(
operator|(
name|CURSOR
operator|*
operator|)
name|rptr
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* unchain from client and put on free list */
name|rptr
operator|->
name|type
operator|=
name|RT_FREE
expr_stmt|;
if|if
condition|(
operator|(
name|rptr
operator|->
name|prev
operator|)
operator|->
name|next
operator|=
name|rptr
operator|->
name|next
condition|)
operator|(
name|rptr
operator|->
name|next
operator|)
operator|->
name|prev
operator|=
name|rptr
operator|->
name|prev
expr_stmt|;
name|rptr
operator|->
name|next
operator|=
name|FreeResource
expr_stmt|;
name|FreeResource
operator|=
name|rptr
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free all resources owned by a client */
end_comment

begin_expr_stmt
name|Free_client_resources
argument_list|(
name|client
argument_list|)
specifier|register
name|int
name|client
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|RESOURCE
modifier|*
name|rptr
decl_stmt|,
modifier|*
modifier|*
name|res
decl_stmt|;
specifier|register
name|int
name|rval
decl_stmt|;
specifier|register
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|Ungrab_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|Free_client_colors
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* this is slightly expensive in time, but cheap in space */
name|res
operator|=
name|Resources
operator|+
literal|1
expr_stmt|;
name|rval
operator|=
name|MaxResource
expr_stmt|;
while|while
condition|(
operator|--
name|rval
operator|>
literal|0
condition|)
block|{
name|rptr
operator|=
operator|*
name|res
operator|++
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|type
operator|!=
name|RT_WINDOW
condition|)
continue|continue;
name|w
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|rptr
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|client
operator|==
name|client
condition|)
block|{
name|w
operator|->
name|mask
operator|=
name|NoEvent
expr_stmt|;
name|w
operator|->
name|client
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|res
operator|=
operator|&
name|ClientResources
index|[
name|client
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rptr
operator|=
operator|*
name|res
operator|)
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|rptr
operator|->
name|next
condition|)
name|rptr
operator|=
name|rptr
operator|->
name|next
expr_stmt|;
comment|/* freeing in creation order avoids destroying subwindows one by one */
for|for
control|(
init|;
name|rptr
operator|!=
operator|(
name|RESOURCE
operator|*
operator|)
name|res
condition|;
name|rptr
operator|=
name|rptr
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|rptr
operator|->
name|type
operator|!=
name|RT_FREE
condition|)
name|Free_resource
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Determine the number of bytes in a bitmap (including padding) */
end_comment

begin_expr_stmt
name|Bit_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|)
specifier|register
name|int
name|height
operator|,
name|width
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|height
operator|>
literal|0
operator|&&
name|width
operator|>
literal|0
condition|)
return|return
operator|(
name|WordPad
argument_list|(
name|BitmapSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|)
return|;
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Determine the number of bytes in a pixmap (including padding) */
end_comment

begin_expr_stmt
name|Pix_size
argument_list|(
name|format
argument_list|,
name|height
argument_list|,
name|width
argument_list|)
specifier|register
name|int
name|format
operator|,
name|height
operator|,
name|width
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|height
operator|>
literal|0
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|format
operator|==
name|XYFormat
condition|)
return|return
operator|(
name|WordPad
argument_list|(
name|XYPixmapSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|device
operator|.
name|planes
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|format
operator|==
name|ZFormat
condition|)
block|{
if|if
condition|(
name|device
operator|.
name|planes
operator|>
literal|8
condition|)
return|return
operator|(
name|WordPad
argument_list|(
name|WZPixmapSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|device
operator|.
name|planes
operator|>
literal|1
condition|)
return|return
operator|(
name|BytePad
argument_list|(
name|BZPixmapSize
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Create a font */
end_comment

begin_function
name|FONT
modifier|*
name|Get_font
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|RESOURCE
modifier|*
name|rptr
decl_stmt|,
modifier|*
modifier|*
name|res
decl_stmt|;
specifier|register
name|int
name|rval
decl_stmt|;
specifier|register
name|FONT
modifier|*
name|f
decl_stmt|;
comment|/* First see if the font already exists somewhere */
comment|/* Could have a separate font list, but probably not worth it */
name|res
operator|=
name|Resources
operator|+
literal|1
expr_stmt|;
name|rval
operator|=
name|MaxResource
expr_stmt|;
while|while
condition|(
operator|--
name|rval
operator|>
literal|0
condition|)
block|{
name|rptr
operator|=
operator|*
name|res
operator|++
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|type
operator|==
name|RT_FONT
condition|)
block|{
name|f
operator|=
operator|(
name|FONT
operator|*
operator|)
name|rptr
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
block|}
block|}
comment|/* Try to create it */
if|if
condition|(
operator|(
name|f
operator|=
name|GetFont
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Xstatus
operator|=
name|BadFont
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a cursor */
end_comment

begin_function
name|CURSOR
modifier|*
name|Store_cursor
parameter_list|(
name|image
parameter_list|,
name|mask
parameter_list|,
name|fore
parameter_list|,
name|back
parameter_list|,
name|xoff
parameter_list|,
name|yoff
parameter_list|,
name|func
parameter_list|)
specifier|register
name|BITMAP
modifier|*
name|image
decl_stmt|,
decl|*
name|mask
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|back
decl_stmt|,
name|fore
decl_stmt|,
name|xoff
decl_stmt|,
name|yoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|CURSOR
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|func
operator|>=
literal|16
operator|||
name|xoff
operator|<
literal|0
operator|||
name|yoff
operator|<
literal|0
operator|||
name|xoff
operator|>=
name|image
operator|->
name|width
operator|||
name|yoff
operator|>=
name|image
operator|->
name|height
operator|||
name|fore
operator|<
literal|0
operator|||
operator|(
name|fore
operator|>
name|WhitePixel
operator|&&
name|fore
operator|>=
name|device
operator|.
name|entries
operator|)
operator|||
name|back
operator|<
literal|0
operator|||
operator|(
name|back
operator|>
name|WhitePixel
operator|&&
name|back
operator|>=
name|device
operator|.
name|entries
operator|)
condition|)
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&&
operator|(
name|mask
operator|->
name|width
operator|!=
name|image
operator|->
name|width
operator|||
name|mask
operator|->
name|height
operator|!=
name|image
operator|->
name|height
operator|)
condition|)
name|Xstatus
operator|=
name|BadMatch
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|StoreCursor
argument_list|(
operator|(
name|int
operator|)
name|func
argument_list|,
name|image
argument_list|,
name|fore
argument_list|,
name|back
argument_list|,
name|mask
argument_list|,
name|xoff
argument_list|,
name|yoff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Xstatus
operator|=
name|BadAlloc
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Define this host for access control */
end_comment

begin_macro
name|Define_self
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|short
name|family
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|int
operator|)
name|SIOCGIFCONF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
name|Error
argument_list|(
literal|"Getting interface configuration"
argument_list|)
expr_stmt|;
for|for
control|(
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
operator|,
name|n
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|ifr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|family
operator|=
name|Convert_addr
argument_list|(
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|<=
literal|0
condition|)
continue|continue;
for|for
control|(
name|host
operator|=
name|selfhosts
init|;
name|host
operator|&&
operator|(
name|family
operator|!=
name|host
operator|->
name|family
operator|||
name|bcmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
operator|)
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|host
condition|)
continue|continue;
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|family
operator|=
name|family
expr_stmt|;
name|host
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|host
operator|->
name|next
operator|=
name|selfhosts
expr_stmt|;
name|selfhosts
operator|=
name|host
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Reset access control list to initial hosts */
end_comment

begin_macro
name|Reset_hosts
argument_list|(
argument|display
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|,
modifier|*
name|self
decl_stmt|;
name|char
name|hostname
index|[
literal|120
index|]
decl_stmt|;
name|char
name|fname
index|[
literal|32
index|]
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
name|in
decl_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|sockaddr_dn
name|dn
decl_stmt|;
endif|#
directive|endif
block|}
name|saddr
union|;
ifdef|#
directive|ifdef
name|DNETCONN
name|struct
name|nodeent
modifier|*
name|np
decl_stmt|;
name|struct
name|dn_naddr
name|dnaddr
decl_stmt|,
modifier|*
name|dnaddrp
decl_stmt|,
modifier|*
name|dnet_addr
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|short
name|family
decl_stmt|;
name|int
name|len
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
while|while
condition|(
name|host
operator|=
name|validhosts
condition|)
block|{
name|validhosts
operator|=
name|host
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|host
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|self
operator|=
name|selfhosts
init|;
name|self
condition|;
name|self
operator|=
name|self
operator|->
name|next
control|)
block|{
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|host
operator|=
operator|*
name|self
expr_stmt|;
name|host
operator|->
name|next
operator|=
name|validhosts
expr_stmt|;
name|validhosts
operator|=
name|host
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|fname
argument_list|,
literal|"/etc/X"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|".hosts"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|,
name|fd
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|=
name|index
argument_list|(
name|hostname
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|hostname
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* node name (DECnet names end in "::") */
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dnaddrp
operator|=
name|dnet_addr
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
comment|/* allow nodes to be specified by address */
name|Add_host
argument_list|(
operator|-
literal|1
argument_list|,
name|XAF_DECnet
argument_list|,
operator|(
name|caddr_t
operator|)
name|dnaddrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
comment|/* node was specified by name */
name|saddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|np
operator|->
name|n_addrtype
expr_stmt|;
if|if
condition|(
operator|(
name|family
operator|=
name|Convert_addr
argument_list|(
operator|&
name|saddr
operator|.
name|sa
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|==
name|XAF_DECnet
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|dnaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|dnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|dnaddr
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|bcopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|dnaddr
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
name|Add_host
argument_list|(
operator|-
literal|1
argument_list|,
name|family
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dnaddr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* host name */
if|if
condition|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
condition|)
block|{
name|saddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
if|if
condition|(
operator|(
name|family
operator|=
name|Convert_addr
argument_list|(
operator|&
name|saddr
operator|.
name|sa
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|Add_host
argument_list|(
operator|-
literal|1
argument_list|,
name|family
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DNETCONN
block|}
endif|#
directive|endif
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Add a host to the access control list */
end_comment

begin_macro
name|Add_host
argument_list|(
argument|client
argument_list|,
argument|family
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|client
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|family
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|Check_family
argument_list|(
name|client
argument_list|,
name|family
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|bcmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
condition|)
return|return;
block|}
name|host
operator|=
operator|(
name|HOST
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HOST
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|->
name|family
operator|=
name|family
expr_stmt|;
name|host
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|host
operator|->
name|next
operator|=
name|validhosts
expr_stmt|;
name|validhosts
operator|=
name|host
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remove a host from the access control list */
end_comment

begin_macro
name|Remove_host
argument_list|(
argument|client
argument_list|,
argument|family
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|client
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|family
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|Check_family
argument_list|(
name|client
argument_list|,
name|family
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
for|for
control|(
name|prev
operator|=
operator|&
name|validhosts
init|;
operator|(
name|host
operator|=
operator|*
name|prev
operator|)
operator|&&
operator|(
name|family
operator|!=
name|host
operator|->
name|family
operator|||
name|bcmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
operator|)
condition|;
name|prev
operator|=
operator|&
name|host
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|host
condition|)
block|{
operator|*
name|prev
operator|=
name|host
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|host
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Get all hosts in the access control list */
end_comment

begin_macro
name|Get_hosts
argument_list|(
argument|family
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|short
name|family
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|caddr_t
name|ptr
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|Check_family
argument_list|(
operator|-
literal|1
argument_list|,
name|family
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
if|if
condition|(
name|host
operator|->
name|family
operator|==
name|family
condition|)
name|n
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
operator|*
name|data
operator|=
name|ptr
operator|=
name|Xalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
if|if
condition|(
name|host
operator|->
name|family
operator|==
name|family
condition|)
block|{
name|bcopy
argument_list|(
name|host
operator|->
name|addr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Check for valid address family, and for local host if client modification.  * Return address length.  */
end_comment

begin_macro
name|Check_family
argument_list|(
argument|client
argument_list|,
argument|family
argument_list|)
end_macro

begin_decl_stmt
name|int
name|client
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|family
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr
name|from
decl_stmt|;
name|int
name|alen
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|XAF_INET
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DNETCONN
case|case
name|XAF_DECnet
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_naddr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|client
operator|<
literal|0
condition|)
return|return
operator|(
name|len
operator|)
return|;
name|alen
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getpeername
argument_list|(
name|client
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|family
operator|=
name|Convert_addr
argument_list|(
operator|&
name|from
argument_list|,
operator|&
name|alen
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|family
operator|==
literal|0
condition|)
return|return
operator|(
name|len
operator|)
return|;
for|for
control|(
name|host
operator|=
name|selfhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|bcmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|alen
argument_list|)
condition|)
return|return
operator|(
name|len
operator|)
return|;
block|}
block|}
block|}
name|Xstatus
operator|=
name|BadAccess
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Check if a host is not in the access control list */
end_comment

begin_expr_stmt
name|Invalid_host
argument_list|(
name|saddr
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|sockaddr
operator|*
name|saddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|family
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|HOST
modifier|*
name|host
decl_stmt|;
if|if
condition|(
operator|(
name|family
operator|=
name|Convert_addr
argument_list|(
name|saddr
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|family
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|host
operator|=
name|validhosts
init|;
name|host
condition|;
name|host
operator|=
name|host
operator|->
name|next
control|)
block|{
if|if
condition|(
name|family
operator|==
name|host
operator|->
name|family
operator|&&
operator|!
name|bcmp
argument_list|(
name|addr
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|Convert_addr
argument_list|(
name|saddr
argument_list|,
name|len
argument_list|,
name|addr
argument_list|)
specifier|register
expr|struct
name|sockaddr
operator|*
name|saddr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|saddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
case|case
name|AF_UNIX
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|AF_INET
case|:
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|saddr
operator|)
operator|->
name|sin_addr
operator|)
expr_stmt|;
return|return
operator|(
name|XAF_INET
operator|)
return|;
ifdef|#
directive|ifdef
name|DNETCONN
case|case
name|AF_DECnet
case|:
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_naddr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_dn
operator|*
operator|)
name|saddr
operator|)
operator|->
name|sdn_add
operator|)
expr_stmt|;
return|return
operator|(
name|XAF_DECnet
operator|)
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Place data in a cut buffer, discarding previous contents */
end_comment

begin_expr_stmt
name|Store_cut
argument_list|(
name|n
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
specifier|register
name|unsigned
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>=
name|NUMCUTS
condition|)
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
else|else
block|{
name|n
operator|=
operator|(
name|base_cut
operator|+
name|n
operator|)
operator|&
operator|(
name|NUMCUTS
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cutbuf
index|[
name|n
index|]
condition|)
block|{
name|free
argument_list|(
name|cutbuf
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|cutbuf
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cutbuflen
index|[
name|n
index|]
operator|=
name|len
condition|)
block|{
name|cutbuf
index|[
name|n
index|]
operator|=
name|Xalloc
argument_list|(
name|BytePad
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|cutbuf
index|[
name|n
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Copy the data from a cut buffer */
end_comment

begin_expr_stmt
name|Fetch_cut
argument_list|(
name|n
argument_list|,
name|data
argument_list|)
specifier|register
name|unsigned
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>=
name|NUMCUTS
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
operator|(
name|base_cut
operator|+
name|n
operator|)
operator|&
operator|(
name|NUMCUTS
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|data
operator|=
name|cutbuf
index|[
name|n
index|]
expr_stmt|;
return|return
operator|(
name|cutbuflen
index|[
name|n
index|]
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Rotate the cut buffers */
end_comment

begin_expr_stmt
name|Rotate_cuts
argument_list|(
name|n
argument_list|)
specifier|register
name|unsigned
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>=
name|NUMCUTS
condition|)
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
else|else
name|base_cut
operator|=
operator|(
name|base_cut
operator|+
name|n
operator|)
operator|&
operator|(
name|NUMCUTS
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Delete the data from all cut buffers */
end_comment

begin_macro
name|Reset_cuts
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
operator|++
name|i
operator|<
name|NUMCUTS
condition|;
control|)
block|{
if|if
condition|(
name|cutbuf
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|cutbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cutbuf
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|cutbuflen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|base_cut
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Create and initialize the color map */
end_comment

begin_macro
name|Init_colormap
argument_list|()
end_macro

begin_block
block|{
name|colormap
operator|=
operator|(
name|CMENTRY
operator|*
operator|)
name|Xalloc
argument_list|(
operator|(
name|int
operator|)
name|device
operator|.
name|entries
operator|*
sizeof|sizeof
argument_list|(
name|CMENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|colormap
argument_list|,
name|device
operator|.
name|entries
operator|*
sizeof|sizeof
argument_list|(
name|CMENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|free_entries
operator|=
name|device
operator|.
name|entries
expr_stmt|;
if|if
condition|(
name|device
operator|.
name|entries
operator|>
name|WhitePixel
condition|)
block|{
name|free_entries
operator|-=
literal|2
expr_stmt|;
name|colormap
index|[
name|BlackPixel
index|]
operator|.
name|refcnt
operator|=
operator|-
literal|1
expr_stmt|;
name|colormap
index|[
name|WhitePixel
index|]
operator|.
name|refcnt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Get a read-only color (probably slow for large maps) */
end_comment

begin_expr_stmt
name|Get_color
argument_list|(
name|client
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
specifier|register
name|int
name|client
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ushort
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|CMENTRY
modifier|*
name|ent
decl_stmt|;
specifier|register
name|int
name|pixel
decl_stmt|;
name|int
name|free
init|=
literal|0
decl_stmt|;
specifier|register
name|ushort
modifier|*
name|list
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|ColorDef
name|def
decl_stmt|;
name|ResolveColor
argument_list|(
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
comment|/* see if there is a match, and also look for a free entry */
name|entries
operator|=
name|device
operator|.
name|entries
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|colormap
operator|,
name|pixel
operator|=
operator|-
literal|1
init|;
operator|++
name|pixel
operator|<
name|entries
condition|;
name|ent
operator|++
control|)
block|{
if|if
condition|(
name|ent
operator|->
name|refcnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|red
operator|==
name|red
operator|&&
name|ent
operator|->
name|green
operator|==
name|green
operator|&&
name|ent
operator|->
name|blue
operator|==
name|blue
condition|)
block|{
name|ent
operator|->
name|refcnt
operator|++
expr_stmt|;
goto|goto
name|addit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|free
operator|==
literal|0
operator|&&
name|ent
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|free
operator|=
name|pixel
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pixel
operator|=
name|free
operator|)
operator|==
literal|0
condition|)
block|{
name|Xstatus
operator|=
name|BadAlloc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free_entries
operator|--
expr_stmt|;
comment|/* fill in the entry */
name|ent
operator|=
operator|&
name|colormap
index|[
name|pixel
index|]
expr_stmt|;
name|ent
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|ent
operator|->
name|red
operator|=
name|red
expr_stmt|;
name|ent
operator|->
name|green
operator|=
name|green
expr_stmt|;
name|ent
operator|->
name|blue
operator|=
name|blue
expr_stmt|;
name|def
operator|.
name|pixel
operator|=
name|pixel
expr_stmt|;
name|def
operator|.
name|red
operator|=
name|red
expr_stmt|;
name|def
operator|.
name|green
operator|=
name|green
expr_stmt|;
name|def
operator|.
name|blue
operator|=
name|blue
expr_stmt|;
name|StoreColors
argument_list|(
literal|1
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
name|addit
label|:
comment|/* add pixel to client list */
name|list
operator|=
operator|(
name|ushort
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|,
operator|(
name|numpixels
index|[
name|client
index|]
operator|+
literal|1
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|clientpixels
index|[
name|client
index|]
operator|=
name|list
expr_stmt|;
name|list
index|[
name|numpixels
index|[
name|client
index|]
index|]
operator|=
name|pixel
expr_stmt|;
name|numpixels
index|[
name|client
index|]
operator|++
expr_stmt|;
return|return
operator|(
name|pixel
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Allocate writeable color cells (probably slow for large maps) */
end_comment

begin_macro
name|Get_cells
argument_list|(
argument|client
argument_list|,
argument|contig
argument_list|,
argument|count
argument_list|,
argument|planes
argument_list|,
argument|pixels
argument_list|)
end_macro

begin_decl_stmt
name|int
name|client
decl_stmt|,
name|contig
decl_stmt|,
name|planes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ushort
modifier|*
modifier|*
name|pixels
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ushort
modifier|*
name|pptr
decl_stmt|;
specifier|register
name|CMENTRY
modifier|*
name|ent
decl_stmt|;
specifier|register
name|int
name|pixel
decl_stmt|;
specifier|register
name|int
name|maxp
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|entries
decl_stmt|,
name|dplanes
decl_stmt|,
name|base
decl_stmt|,
name|found
decl_stmt|,
name|save
decl_stmt|;
name|dplanes
operator|=
name|device
operator|.
name|planes
expr_stmt|;
if|if
condition|(
name|planes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|count
operator|>
name|free_entries
condition|)
goto|goto
name|bad
goto|;
name|free_entries
operator|-=
name|count
expr_stmt|;
comment|/* make room for new pixels */
name|pptr
operator|=
operator|(
name|ushort
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|,
operator|(
name|numpixels
index|[
name|client
index|]
operator|+
name|count
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|clientpixels
index|[
name|client
index|]
operator|=
name|pptr
expr_stmt|;
name|pptr
operator|+=
name|numpixels
index|[
name|client
index|]
expr_stmt|;
operator|*
name|pixels
operator|=
name|pptr
expr_stmt|;
name|numpixels
index|[
name|client
index|]
operator|+=
name|count
expr_stmt|;
comment|/* allocate writable entries */
name|ent
operator|=
name|colormap
expr_stmt|;
name|pixel
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|ent
operator|->
name|refcnt
condition|)
block|{
name|ent
operator|++
expr_stmt|;
name|pixel
operator|++
expr_stmt|;
block|}
name|ent
operator|->
name|refcnt
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|pptr
operator|++
operator|=
name|pixel
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|planes
operator|>=
name|dplanes
condition|)
goto|goto
name|bad
goto|;
name|entries
operator|=
name|device
operator|.
name|entries
expr_stmt|;
name|base
operator|=
literal|1
operator|<<
operator|(
name|dplanes
operator|-
name|planes
operator|)
expr_stmt|;
comment|/* make sure all are free */
for|for
control|(
name|pixel
operator|=
name|base
operator|-
literal|1
operator|,
name|ent
operator|=
operator|&
name|colormap
index|[
name|base
index|]
init|;
operator|++
name|pixel
operator|<
name|entries
condition|;
name|ent
operator|++
control|)
block|{
if|if
condition|(
name|ent
operator|->
name|refcnt
condition|)
goto|goto
name|bad
goto|;
block|}
name|count
operator|=
name|entries
operator|-
name|base
expr_stmt|;
comment|/* make room for new pixels */
name|pptr
operator|=
operator|(
name|ushort
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|,
operator|(
name|numpixels
index|[
name|client
index|]
operator|+
name|count
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|clientpixels
index|[
name|client
index|]
operator|=
name|pptr
expr_stmt|;
name|pptr
operator|+=
name|numpixels
index|[
name|client
index|]
expr_stmt|;
name|numpixels
index|[
name|client
index|]
operator|+=
name|count
expr_stmt|;
name|free_entries
operator|-=
name|count
expr_stmt|;
comment|/* allocate them */
for|for
control|(
name|pixel
operator|=
name|base
operator|-
literal|1
operator|,
name|ent
operator|=
operator|&
name|colormap
index|[
name|base
index|]
init|;
operator|++
name|pixel
operator|<
name|entries
condition|;
name|ent
operator|++
control|)
block|{
name|ent
operator|->
name|refcnt
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|pptr
operator|++
operator|=
name|pixel
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
literal|1
operator|<<
name|planes
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|dplanes
operator|-
name|planes
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|planes
operator|>=
name|dplanes
operator|||
operator|(
name|count
operator|<<
name|planes
operator|)
operator|>
name|free_entries
condition|)
goto|goto
name|bad
goto|;
comment|/* make room for new pixels */
name|pptr
operator|=
operator|(
name|ushort
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|,
operator|(
name|numpixels
index|[
name|client
index|]
operator|+
operator|(
name|count
operator|<<
name|planes
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|clientpixels
index|[
name|client
index|]
operator|=
name|pptr
expr_stmt|;
operator|*
name|pixels
operator|=
name|pptr
operator|+
name|numpixels
index|[
name|client
index|]
expr_stmt|;
name|ent
operator|=
name|colormap
expr_stmt|;
comment|/* first try for contiguous planes, since its fastest */
for|for
control|(
name|mask
operator|=
operator|(
literal|1
operator|<<
name|planes
operator|)
operator|-
literal|1
operator|,
name|base
operator|=
literal|1
operator|,
name|dplanes
operator|-=
operator|(
name|planes
operator|-
literal|1
operator|)
init|;
operator|--
name|dplanes
operator|>=
literal|0
condition|;
name|mask
operator|+=
name|mask
operator|,
name|base
operator|+=
name|base
control|)
block|{
name|pptr
operator|=
operator|*
name|pixels
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|pixel
operator|=
literal|0
expr_stmt|;
name|entries
operator|=
name|device
operator|.
name|entries
operator|-
name|mask
expr_stmt|;
while|while
condition|(
name|pixel
operator|<
name|entries
condition|)
block|{
name|save
operator|=
name|pixel
expr_stmt|;
name|maxp
operator|=
name|pixel
operator|+
name|mask
operator|+
name|base
expr_stmt|;
comment|/* check if all are free */
while|while
condition|(
name|pixel
operator|!=
name|maxp
operator|&&
name|ent
index|[
name|pixel
index|]
operator|.
name|refcnt
operator|==
literal|0
condition|)
name|pixel
operator|+=
name|base
expr_stmt|;
if|if
condition|(
name|pixel
operator|==
name|maxp
condition|)
block|{
comment|/* this one works */
operator|*
name|pptr
operator|++
operator|=
name|save
expr_stmt|;
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|count
condition|)
block|{
comment|/* found enough, allocate them all */
name|numpixels
index|[
name|client
index|]
operator|+=
name|count
operator|<<
name|planes
expr_stmt|;
name|free_entries
operator|-=
name|count
operator|<<
name|planes
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|pixel
operator|=
operator|(
operator|*
name|pixels
operator|)
index|[
name|count
index|]
expr_stmt|;
name|maxp
operator|=
name|pixel
operator|+
name|mask
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ent
index|[
name|pixel
index|]
operator|.
name|refcnt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pixel
operator|==
name|maxp
condition|)
break|break;
name|pixel
operator|+=
name|base
expr_stmt|;
operator|*
name|pptr
operator|++
operator|=
name|pixel
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mask
operator|)
return|;
block|}
block|}
name|pixel
operator|=
name|save
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pixel
operator|&
name|mask
condition|)
name|pixel
operator|+=
name|mask
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contig
operator|||
name|planes
operator|==
literal|1
condition|)
goto|goto
name|fail
goto|;
comment|/* this will be very slow for large maps, need a better algorithm */
name|dplanes
operator|=
operator|(
literal|1
operator|<<
name|device
operator|.
name|planes
operator|)
operator|-
operator|(
literal|1
operator|<<
name|planes
operator|)
expr_stmt|;
for|for
control|(
name|mask
operator|=
literal|0
init|;
name|mask
operator|<=
name|dplanes
condition|;
name|mask
operator|++
control|)
block|{
comment|/* next 3 magic statements count number of ones (HAKMEM #169) */
name|pixel
operator|=
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|&
literal|03333333333
expr_stmt|;
name|pixel
operator|=
name|mask
operator|-
name|pixel
operator|-
operator|(
operator|(
name|pixel
operator|>>
literal|1
operator|)
operator|&
literal|03333333333
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|pixel
operator|+
operator|(
name|pixel
operator|>>
literal|3
operator|)
operator|)
operator|&
literal|0707070707
operator|)
operator|%
literal|077
operator|)
operator|!=
name|planes
condition|)
continue|continue;
name|pptr
operator|=
operator|*
name|pixels
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|entries
operator|=
name|device
operator|.
name|entries
operator|-
name|mask
expr_stmt|;
name|base
operator|=
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|mask
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|pixel
operator|=
literal|0
init|;
name|pixel
operator|<
name|entries
condition|;
name|pixel
operator|++
control|)
block|{
if|if
condition|(
name|pixel
operator|&
name|mask
condition|)
continue|continue;
name|maxp
operator|=
literal|0
expr_stmt|;
comment|/* check if all are free */
while|while
condition|(
name|ent
index|[
name|pixel
operator|+
name|maxp
index|]
operator|.
name|refcnt
operator|==
literal|0
condition|)
block|{
name|maxp
operator|+=
name|base
expr_stmt|;
if|if
condition|(
name|maxp
operator|>
name|mask
condition|)
break|break;
while|while
condition|(
name|maxp
operator|&
operator|~
name|mask
condition|)
name|maxp
operator|+=
operator|(
name|maxp
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|maxp
operator|<=
name|mask
condition|)
continue|continue;
comment|/* this one works */
operator|*
name|pptr
operator|++
operator|=
name|pixel
expr_stmt|;
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|found
operator|<
name|count
condition|)
continue|continue;
comment|/* found enough, allocate them all */
name|numpixels
index|[
name|client
index|]
operator|+=
name|count
operator|<<
name|planes
expr_stmt|;
name|free_entries
operator|-=
name|count
operator|<<
name|planes
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|pixel
operator|=
operator|(
operator|*
name|pixels
operator|)
index|[
name|count
index|]
expr_stmt|;
name|maxp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ent
index|[
name|pixel
operator|+
name|maxp
index|]
operator|.
name|refcnt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|maxp
operator|==
name|mask
condition|)
break|break;
name|maxp
operator|+=
name|base
expr_stmt|;
while|while
condition|(
name|maxp
operator|&
operator|~
name|mask
condition|)
name|maxp
operator|+=
operator|(
name|maxp
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
operator|*
name|pptr
operator|++
operator|=
name|pixel
operator|+
name|maxp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mask
operator|)
return|;
block|}
block|}
name|fail
label|:
comment|/* failed to get them, back out of the allocation */
if|if
condition|(
name|count
operator|=
name|numpixels
index|[
name|client
index|]
condition|)
name|clientpixels
index|[
name|client
index|]
operator|=
operator|(
name|ushort
operator|*
operator|)
name|Xrealloc
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|,
name|count
operator|<<
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|)
expr_stmt|;
name|clientpixels
index|[
name|client
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|bad
label|:
name|Xstatus
operator|=
name|BadAlloc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Free colors and/or cells (probably slow for large numbers) */
end_comment

begin_macro
name|Free_colors
argument_list|(
argument|client
argument_list|,
argument|count
argument_list|,
argument|pixels
argument_list|,
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|client
decl_stmt|,
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ushort
modifier|*
name|pixels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ushort
modifier|*
name|pptr
decl_stmt|,
modifier|*
name|cptr
decl_stmt|;
name|unsigned
name|bits
decl_stmt|,
name|bit
decl_stmt|;
name|ushort
name|pixel
decl_stmt|;
specifier|register
name|CMENTRY
modifier|*
name|ent
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|z
decl_stmt|;
name|int
name|zapped
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|bits
operator|=
literal|0
expr_stmt|;
name|zapped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* go through pixel list */
for|for
control|(
name|pptr
operator|=
name|pixels
operator|,
name|n
operator|=
name|count
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|pptr
operator|++
control|)
block|{
name|pixel
operator|=
operator|*
name|pptr
operator||
name|bits
expr_stmt|;
comment|/* find match in client list */
for|for
control|(
name|cptr
operator|=
name|clientpixels
index|[
name|client
index|]
operator|,
name|z
operator|=
name|numpixels
index|[
name|client
index|]
init|;
operator|--
name|z
operator|>=
literal|0
operator|&&
operator|*
name|cptr
operator|!=
name|pixel
condition|;
name|cptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|z
operator|>=
literal|0
operator|&&
name|pixel
condition|)
block|{
name|ent
operator|=
operator|&
name|colormap
index|[
name|pixel
index|]
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|refcnt
operator|<
literal|0
condition|)
name|ent
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
else|else
name|ent
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|free_entries
operator|++
expr_stmt|;
operator|*
name|cptr
operator|=
literal|0
expr_stmt|;
name|zapped
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pixel
operator|>=
name|device
operator|.
name|entries
condition|)
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
else|else
name|Xstatus
operator|=
name|BadAccess
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|==
name|mask
condition|)
break|break;
comment|/* generate next bits value */
name|bit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|mask
operator|&
name|bit
operator|)
condition|)
name|bit
operator|+=
name|bit
expr_stmt|;
name|bits
operator|^=
name|bit
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|bit
condition|)
break|break;
name|bit
operator|+=
name|bit
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zapped
condition|)
block|{
comment|/* delete zeroes from list */
name|n
operator|=
name|numpixels
index|[
name|client
index|]
operator|-
name|zapped
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|pixels
operator|=
operator|(
name|ushort
operator|*
operator|)
name|Xalloc
argument_list|(
name|n
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|pptr
operator|=
name|pixels
expr_stmt|;
name|cptr
operator|=
name|clientpixels
index|[
name|client
index|]
expr_stmt|;
name|z
operator|=
name|n
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|cptr
condition|)
block|{
operator|*
name|pptr
operator|++
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
operator|--
name|z
operator|==
literal|0
condition|)
break|break;
block|}
name|cptr
operator|++
expr_stmt|;
block|}
block|}
else|else
name|pixels
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|)
expr_stmt|;
name|clientpixels
index|[
name|client
index|]
operator|=
name|pixels
expr_stmt|;
name|numpixels
index|[
name|client
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Free all of a client's colors and cells */
end_comment

begin_expr_stmt
name|Free_client_colors
argument_list|(
name|client
argument_list|)
specifier|register
name|int
name|client
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ushort
modifier|*
name|pptr
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|CMENTRY
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
operator|(
name|pptr
operator|=
name|clientpixels
index|[
name|client
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
name|n
operator|=
name|numpixels
index|[
name|client
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|ent
operator|=
operator|&
name|colormap
index|[
operator|*
name|pptr
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|refcnt
operator|<
literal|0
condition|)
name|ent
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
else|else
name|ent
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|free_entries
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|clientpixels
index|[
name|client
index|]
argument_list|)
expr_stmt|;
name|clientpixels
index|[
name|client
index|]
operator|=
name|NULL
expr_stmt|;
name|numpixels
index|[
name|client
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Redefine color values */
end_comment

begin_macro
name|Store_colors
argument_list|(
argument|count
argument_list|,
argument|defs
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ColorDef
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|ColorDef
modifier|*
name|def
decl_stmt|;
specifier|register
name|CMENTRY
modifier|*
name|ent
decl_stmt|;
comment|/* first make sure all are writable */
for|for
control|(
name|def
operator|=
name|defs
operator|,
name|n
operator|=
name|count
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|def
operator|++
control|)
block|{
if|if
condition|(
name|def
operator|->
name|pixel
operator|>=
name|device
operator|.
name|entries
condition|)
block|{
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|colormap
index|[
name|def
operator|->
name|pixel
index|]
operator|.
name|refcnt
operator|>=
literal|0
condition|)
block|{
name|Xstatus
operator|=
name|BadAccess
expr_stmt|;
return|return;
block|}
block|}
comment|/* update them */
for|for
control|(
name|def
operator|=
name|defs
operator|,
name|n
operator|=
name|count
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|def
operator|++
control|)
block|{
name|ResolveColor
argument_list|(
operator|&
name|def
operator|->
name|red
argument_list|,
operator|&
name|def
operator|->
name|green
argument_list|,
operator|&
name|def
operator|->
name|blue
argument_list|)
expr_stmt|;
name|ent
operator|=
operator|&
name|colormap
index|[
name|def
operator|->
name|pixel
index|]
expr_stmt|;
name|ent
operator|->
name|red
operator|=
name|def
operator|->
name|red
expr_stmt|;
name|ent
operator|->
name|green
operator|=
name|def
operator|->
name|green
expr_stmt|;
name|ent
operator|->
name|blue
operator|=
name|def
operator|->
name|blue
expr_stmt|;
block|}
name|StoreColors
argument_list|(
name|count
argument_list|,
name|defs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read the color value of a cell */
end_comment

begin_expr_stmt
name|Query_color
argument_list|(
name|pixel
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
specifier|register
name|unsigned
name|pixel
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ushort
modifier|*
name|red
decl_stmt|,
modifier|*
name|green
decl_stmt|,
modifier|*
name|blue
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|CMENTRY
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|pixel
operator|>=
name|device
operator|.
name|entries
condition|)
name|Xstatus
operator|=
name|BadValue
expr_stmt|;
else|else
block|{
name|ent
operator|=
operator|&
name|colormap
index|[
name|pixel
index|]
expr_stmt|;
operator|*
name|red
operator|=
name|ent
operator|->
name|red
expr_stmt|;
operator|*
name|green
operator|=
name|ent
operator|->
name|green
expr_stmt|;
operator|*
name|blue
operator|=
name|ent
operator|->
name|blue
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|alloc_at_once
value|50
end_define

begin_comment
comment|/* Called from the rectangle macros when the free list is empty.  * We allocate in chunks to minimize fragmentation.  */
end_comment

begin_function
name|RECTANGLE
modifier|*
name|Alloc_rectangle
parameter_list|()
block|{
specifier|register
name|RECTANGLE
modifier|*
name|r
decl_stmt|,
modifier|*
name|rec
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rec
operator|=
operator|(
name|RECTANGLE
operator|*
operator|)
name|Xalloc
argument_list|(
name|alloc_at_once
operator|*
sizeof|sizeof
argument_list|(
name|RECTANGLE
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|rec
expr_stmt|;
name|rec
operator|->
name|internal
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|alloc_at_once
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|r
operator|+
literal|1
expr_stmt|;
name|r
operator|++
expr_stmt|;
name|r
operator|->
name|internal
operator|=
literal|1
expr_stmt|;
block|}
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rec
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Put all the rectangles back on the free list. */
end_comment

begin_expr_stmt
name|Free_rectangles
argument_list|(
name|rlist
argument_list|)
specifier|register
name|RECTANGLE
operator|*
name|rlist
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
name|rlist
expr_stmt|;
while|while
condition|(
name|rec
operator|->
name|next
condition|)
name|rec
operator|=
name|rec
operator|->
name|next
expr_stmt|;
name|rec
operator|->
name|next
operator|=
name|free_rectangles
expr_stmt|;
name|free_rectangles
operator|=
name|rlist
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free storage associated with unused rectangles */
end_comment

begin_macro
name|Free_rectangle_storage
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|RECTANGLE
modifier|*
name|r
decl_stmt|,
modifier|*
modifier|*
name|pr
decl_stmt|;
comment|/* drop the "internal" rectangles */
name|pr
operator|=
operator|&
name|free_rectangles
expr_stmt|;
while|while
condition|(
name|r
operator|=
operator|*
name|pr
condition|)
block|{
if|if TRUE
condition|(
name|r
operator|->
name|internal
condition|)
operator|*
name|pr
operator|=
name|r
operator|->
name|next
expr_stmt|;
else|else
name|pr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
block|}
comment|/* now free the "head" rectangles */
while|while
condition|(
name|r
operator|=
name|free_rectangles
condition|)
block|{
name|free_rectangles
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* malloc wrap-around, to take care of the "no memory" case, since  * it would be difficult in many places to "back out" on failure.  */
end_comment

begin_function
name|char
modifier|*
name|Xalloc
parameter_list|(
name|amount
parameter_list|)
name|int
name|amount
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|amount
argument_list|)
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|Error
argument_list|(
literal|"Allocating"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* realloc wrap-around, to take care of the "no memory" case, since  * it would be difficult in many places to "back out" on failure.  */
end_comment

begin_function
name|char
modifier|*
name|Xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|amount
parameter_list|)
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|amount
decl_stmt|;
block|{
if|if
condition|(
name|ptr
condition|)
name|ptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
operator|(
name|unsigned
operator|)
name|amount
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|Error
argument_list|(
literal|"Allocating"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

end_unit

