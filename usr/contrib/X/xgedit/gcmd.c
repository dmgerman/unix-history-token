begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1984, 1985	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_gcmd_c
init|=
literal|"$Header: gcmd.c,v 10.6 86/02/01 16:18:44 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gedit.h"
end_include

begin_decl_stmt
name|int
name|mult
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command multiplier */
end_comment

begin_decl_stmt
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|ends
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used during select operation */
end_comment

begin_decl_stmt
name|int
name|redo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to one if arc cache should be recalculated */
end_comment

begin_decl_stmt
name|struct
name|prototype
modifier|*
name|previous
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last proto to be edited */
end_comment

begin_comment
comment|/* process command input from user -- return 1 if it's time to exit, 0 otherwise */
end_comment

begin_macro
name|command
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|ch
decl_stmt|;
name|fptr
name|cmd
decl_stmt|;
specifier|extern
name|char
name|mousechanged
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
while|while
condition|(
name|mousechanged
condition|)
block|{
name|ch
operator|=
name|track
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|&
operator|(
name|RECENTER
operator|+
name|REDISPLAY
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|&
name|RECENTER
condition|)
block|{
name|new_window
argument_list|(
operator|&
name|cur_state
argument_list|,
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|)
expr_stmt|;
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|redisplay
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|UserReady
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ch
operator|=
name|UserChar
argument_list|()
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0377
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cmd
operator|=
name|dispatch
index|[
name|ch
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|Beep
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unrecognized command: 0%o"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|msg
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
call|(
modifier|*
name|cmd
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|&
name|MULTIPLIER
operator|)
condition|)
name|mult
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|&
operator|(
name|RECENTER
operator|+
name|REDISPLAY
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|&
name|RECENTER
condition|)
block|{
name|new_window
argument_list|(
operator|&
name|cur_state
argument_list|,
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|)
expr_stmt|;
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|redisplay
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|&
name|DONE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* go back to editing last thing we were working on */
end_comment

begin_macro
name|editlast
argument_list|()
end_macro

begin_block
block|{
name|struct
name|prototype
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|previous
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|temp
operator|=
name|cur_state
operator|.
name|curobj
condition|)
name|temp
operator|->
name|recent
operator|=
name|cur_state
expr_stmt|;
name|cur_state
operator|=
name|previous
operator|->
name|recent
expr_stmt|;
name|previous
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|REDISPLAY
operator|)
return|;
block|}
end_block

begin_comment
comment|/* accept angle for SEGMENT */
end_comment

begin_macro
name|angle
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|editee
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|type
operator|!=
name|SEGMENT
condition|)
goto|goto
name|done
goto|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"angle = %d, new value (2048 units in a circle): "
argument_list|,
name|p
operator|->
name|s
operator|.
name|angle
argument_list|)
expr_stmt|;
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
name|buf
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|typein
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
name|p
operator|->
name|s
operator|.
name|angle
operator|=
name|atoi
argument_list|(
name|typein
argument_list|)
operator|&
literal|2047
expr_stmt|;
name|redo
operator|=
literal|1
expr_stmt|;
name|done
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* resize window and redisplay */
end_comment

begin_macro
name|fixwindow
argument_list|()
end_macro

begin_block
block|{
name|new_window
argument_list|(
operator|&
name|cur_state
argument_list|,
operator|(
name|cur_state
operator|.
name|worgx
operator|+
name|cur_state
operator|.
name|wmaxx
operator|)
operator|>>
literal|1
argument_list|,
operator|(
name|cur_state
operator|.
name|worgy
operator|+
name|cur_state
operator|.
name|wmaxy
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|REDISPLAY
operator|)
return|;
block|}
end_block

begin_comment
comment|/* recenter window at cursor position */
end_comment

begin_macro
name|setwindow
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|RECENTER
operator|)
return|;
block|}
end_block

begin_comment
comment|/* frob orient parameter of selected object */
end_comment

begin_macro
name|rotateobj
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
name|short
name|temp
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|editee
operator|)
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|p
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|SEGMENT
case|:
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|angle
operator|==
literal|0
condition|)
break|break;
name|temp
operator|=
name|p
operator|->
name|s
operator|.
name|x1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x1
operator|=
name|p
operator|->
name|s
operator|.
name|x2
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x2
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|p
operator|->
name|s
operator|.
name|y1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y1
operator|=
name|p
operator|->
name|s
operator|.
name|y2
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y2
operator|=
name|temp
expr_stmt|;
name|cur_state
operator|.
name|whichend
operator|=
literal|3
operator|-
name|cur_state
operator|.
name|whichend
expr_stmt|;
name|redo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LABEL
case|:
name|p
operator|->
name|l
operator|.
name|orient
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|l
operator|.
name|orient
operator|>
name|BR
condition|)
name|p
operator|->
name|l
operator|.
name|orient
operator|=
name|CC
expr_stmt|;
break|break;
case|case
name|OBJECT
case|:
name|p
operator|->
name|o
operator|.
name|orient
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|o
operator|.
name|orient
operator|>
name|RWEST
condition|)
name|p
operator|->
name|o
operator|.
name|orient
operator|=
name|NORTH
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* edit selected object */
end_comment

begin_macro
name|editobj
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|editee
operator|)
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|p
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|LABEL
case|:
if|if
condition|(
name|userinput
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|,
literal|"edit label: "
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|typein
argument_list|)
operator|<=
name|strlen
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|)
condition|)
name|strcpy
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|,
name|typein
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|l
operator|.
name|string
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|typein
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|,
name|typein
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OBJECT
case|:
name|cur_state
operator|.
name|curobj
operator|->
name|recent
operator|=
name|cur_state
expr_stmt|;
name|previous
operator|=
name|cur_state
operator|.
name|curobj
expr_stmt|;
name|cur_state
operator|=
name|p
operator|->
name|o
operator|.
name|proto
operator|->
name|recent
expr_stmt|;
return|return
operator|(
name|REDISPLAY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* rescale subpicture */
end_comment

begin_macro
name|rescale
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|in1
decl_stmt|,
name|in2
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|editee
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|o
operator|.
name|type
operator|!=
name|OBJECT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"subpicture scale = %d:%d, new scale: "
argument_list|,
name|p
operator|->
name|o
operator|.
name|mscale
argument_list|,
name|p
operator|->
name|o
operator|.
name|dscale
argument_list|)
expr_stmt|;
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ch
operator|=
name|sscanf
argument_list|(
name|typein
argument_list|,
literal|"%d:%d"
argument_list|,
operator|&
name|in1
argument_list|,
operator|&
name|in2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|1
condition|)
block|{
name|p
operator|->
name|o
operator|.
name|mscale
operator|=
name|in1
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|dscale
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|2
condition|)
block|{
name|p
operator|->
name|o
operator|.
name|mscale
operator|=
name|in1
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|dscale
operator|=
name|in2
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|REDISPLAY
operator|)
return|;
block|}
end_block

begin_comment
comment|/* delete object */
end_comment

begin_macro
name|delobj
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|editee
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|deselect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* abort current selection */
end_comment

begin_macro
name|quit
argument_list|()
end_macro

begin_block
block|{
name|deselect
argument_list|(
name|REDISPLAY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* drop current selection where cursor is */
end_comment

begin_macro
name|letgo
argument_list|()
end_macro

begin_block
block|{
name|deselect
argument_list|(
name|UPDATE
operator|+
name|REDISPLAY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* drop current selection with same offset as last time */
end_comment

begin_macro
name|lastgo
argument_list|()
end_macro

begin_block
block|{
name|deselect
argument_list|(
name|UPDATE
operator|+
name|USEOFFSET
operator|+
name|REDISPLAY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* select nearby object */
end_comment

begin_macro
name|selobj
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
specifier|register
name|int
name|in1
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|editee
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|curobj
operator|->
name|body
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|in1
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|in1
condition|)
block|{
name|in1
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|cur_state
operator|.
name|curobj
operator|->
name|body
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|cur_state
operator|.
name|editee
condition|)
break|break;
if|if
condition|(
name|nearby
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|selectobj
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* create a new line segment */
end_comment

begin_macro
name|newline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|gptr
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|segment
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|->
name|s
operator|.
name|type
operator|=
name|SEGMENT
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x2
operator|=
name|cur_state
operator|.
name|curx
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y2
operator|=
name|cur_state
operator|.
name|cury
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|angle
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|cache
operator|=
name|NULL
expr_stmt|;
name|newobj
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* finish creation of new object */
end_comment

begin_expr_stmt
name|newobj
argument_list|(
name|p
argument_list|)
specifier|register
name|gptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|->
name|s
operator|.
name|next
operator|=
name|cur_state
operator|.
name|curobj
operator|->
name|body
expr_stmt|;
name|cur_state
operator|.
name|curobj
operator|->
name|body
operator|=
name|p
expr_stmt|;
name|cur_state
operator|.
name|curobj
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|parent
operator|=
name|cur_state
operator|.
name|curobj
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x1
operator|=
name|cur_state
operator|.
name|curx
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y1
operator|=
name|cur_state
operator|.
name|cury
expr_stmt|;
name|dx
operator|=
name|dy
operator|=
literal|0
expr_stmt|;
name|ends
operator|=
literal|2
expr_stmt|;
name|selectobj
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* instantiate an object */
end_comment

begin_macro
name|instantiate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
specifier|register
name|struct
name|prototype
modifier|*
name|new
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
literal|"name of definition to instantiate: "
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|new
operator|=
name|read_def
argument_list|(
name|typein
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|body
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"definition for %s not found"
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
name|msg
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|retdef
label|:
name|free
argument_list|(
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
name|directory
operator|=
name|new
operator|->
name|next
expr_stmt|;
comment|/* remove dir entry */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|gptr
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|object
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
goto|goto
name|retdef
goto|;
block|}
name|p
operator|->
name|o
operator|.
name|type
operator|=
name|OBJECT
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|orient
operator|=
name|NORTH
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|proto
operator|=
name|new
expr_stmt|;
name|p
operator|->
name|o
operator|.
name|mscale
operator|=
name|p
operator|->
name|o
operator|.
name|dscale
operator|=
literal|1
expr_stmt|;
name|newobj
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* new label */
end_comment

begin_macro
name|newlabel
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
literal|"label: "
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|gptr
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|label
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|->
name|l
operator|.
name|type
operator|=
name|LABEL
expr_stmt|;
name|p
operator|->
name|l
operator|.
name|orient
operator|=
name|CC
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|l
operator|.
name|string
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|typein
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|,
name|typein
argument_list|)
expr_stmt|;
name|newobj
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* start editing new .def file */
end_comment

begin_macro
name|newin
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
literal|"name of definition to edit: "
argument_list|)
operator|||
name|typein
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|previous
operator|=
name|cur_state
operator|.
name|curobj
expr_stmt|;
name|cur_state
operator|.
name|curobj
operator|->
name|recent
operator|=
name|cur_state
expr_stmt|;
name|cur_state
operator|=
name|read_def
argument_list|(
name|typein
argument_list|)
operator|->
name|recent
expr_stmt|;
return|return
operator|(
name|REDISPLAY
operator|)
return|;
block|}
end_block

begin_comment
comment|/* write out current .def file */
end_comment

begin_macro
name|newout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|userinput
argument_list|(
name|cur_state
operator|.
name|curobj
operator|->
name|name
argument_list|,
literal|"name of output file: "
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|typein
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|typein
argument_list|,
name|cur_state
operator|.
name|curobj
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|typein
argument_list|)
operator|<=
name|strlen
argument_list|(
name|cur_state
operator|.
name|curobj
operator|->
name|name
argument_list|)
condition|)
name|strcpy
argument_list|(
name|cur_state
operator|.
name|curobj
operator|->
name|name
argument_list|,
name|typein
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|cur_state
operator|.
name|curobj
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_state
operator|.
name|curobj
operator|->
name|name
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|typein
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"out of room!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|cur_state
operator|.
name|curobj
operator|->
name|name
argument_list|,
name|typein
argument_list|)
expr_stmt|;
block|}
block|}
name|write_defn
argument_list|(
name|cur_state
operator|.
name|curobj
argument_list|)
expr_stmt|;
name|banner
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* snap cursor to grid */
end_comment

begin_macro
name|snap
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|remouse
argument_list|(
name|snap_coord
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|)
argument_list|,
name|snap_coord
argument_list|(
name|cur_state
operator|.
name|cury
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|snap_coord
argument_list|(
name|coord
argument_list|)
specifier|register
name|int
name|coord
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|mask
init|=
operator|~
operator|(
name|cur_state
operator|.
name|csize
operator|-
literal|1
operator|)
decl_stmt|;
name|coord
operator|+=
name|cur_state
operator|.
name|csize
operator|>>
literal|1
expr_stmt|;
name|coord
operator|&=
name|mask
expr_stmt|;
return|return
operator|(
name|coord
operator|)
return|;
block|}
end_block

begin_comment
comment|/* move cursor to the right */
end_comment

begin_macro
name|mright
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
operator|+
name|mult
operator|*
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* move cursor to the left */
end_comment

begin_macro
name|mleft
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
operator|-
name|mult
operator|*
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* move cursor up */
end_comment

begin_macro
name|mup
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|mult
operator|*
name|cur_state
operator|.
name|csize
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* move cursor down */
end_comment

begin_macro
name|mdown
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
operator|-
name|mult
operator|*
name|cur_state
operator|.
name|csize
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* make cursor larger */
end_comment

begin_macro
name|curup
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cur_state
operator|.
name|csize
operator|<
literal|128
condition|)
name|cur_state
operator|.
name|csize
operator|<<=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* make cursor smaller */
end_comment

begin_macro
name|curdown
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cur_state
operator|.
name|csize
operator|>
literal|1
condition|)
name|cur_state
operator|.
name|csize
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* multiply multiplier */
end_comment

begin_macro
name|multiplier
argument_list|()
end_macro

begin_block
block|{
name|mult
operator|<<=
literal|2
expr_stmt|;
return|return
operator|(
name|MULTIPLIER
operator|)
return|;
block|}
end_block

begin_comment
comment|/* rescale picture */
end_comment

begin_macro
name|scale
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|ch
decl_stmt|;
name|int
name|in1
decl_stmt|,
name|in2
decl_stmt|;
if|if
condition|(
name|userinput
argument_list|(
literal|""
argument_list|,
literal|"new scale (screen:defn): "
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ch
operator|=
name|sscanf
argument_list|(
name|typein
argument_list|,
literal|"%d:%d"
argument_list|,
operator|&
name|in1
argument_list|,
operator|&
name|in2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|1
condition|)
block|{
name|cur_state
operator|.
name|mscale
operator|=
name|in1
expr_stmt|;
name|cur_state
operator|.
name|dscale
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|2
condition|)
block|{
name|cur_state
operator|.
name|mscale
operator|=
name|in1
expr_stmt|;
name|cur_state
operator|.
name|dscale
operator|=
name|in2
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|RECENTER
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Scale picture up/down by factor of +n/-n:  */
end_comment

begin_macro
name|magnify
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|/* Make it smaller?		*/
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|cur_state
operator|.
name|mscale
operator|%
name|n
operator|)
operator|==
literal|0
condition|)
name|cur_state
operator|.
name|mscale
operator|/=
name|n
expr_stmt|;
else|else
name|cur_state
operator|.
name|dscale
operator|*=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cur_state
operator|.
name|dscale
operator|%
name|n
operator|)
operator|==
literal|0
condition|)
name|cur_state
operator|.
name|dscale
operator|/=
name|n
expr_stmt|;
else|else
name|cur_state
operator|.
name|mscale
operator|*=
name|n
expr_stmt|;
block|}
return|return
name|RECENTER
return|;
block|}
end_block

begin_macro
name|scaleup
argument_list|()
end_macro

begin_block
block|{
return|return
name|magnify
argument_list|(
literal|4
argument_list|)
return|;
block|}
end_block

begin_macro
name|scaledn
argument_list|()
end_macro

begin_block
block|{
return|return
name|magnify
argument_list|(
operator|-
literal|4
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* move origin */
end_comment

begin_macro
name|neworg
argument_list|()
end_macro

begin_block
block|{
name|adj_org
argument_list|(
name|cur_state
operator|.
name|curobj
argument_list|,
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|)
expr_stmt|;
name|cur_state
operator|.
name|curobj
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
name|remouse
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|RECENTER
operator|)
return|;
block|}
end_block

begin_comment
comment|/* move cursor to origin */
end_comment

begin_macro
name|home
argument_list|()
end_macro

begin_block
block|{
name|remouse
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|RECENTER
operator|)
return|;
block|}
end_block

begin_comment
comment|/* finished editing current picture */
end_comment

begin_macro
name|stop
argument_list|()
end_macro

begin_block
block|{
name|deselect
argument_list|(
name|UPDATE
operator|+
name|REDISPLAY
argument_list|)
expr_stmt|;
return|return
operator|(
name|DONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* toggle grid flag */
end_comment

begin_macro
name|toggle
argument_list|()
end_macro

begin_block
block|{
name|cur_state
operator|.
name|grid
operator|^=
literal|1
expr_stmt|;
return|return
operator|(
name|REDISPLAY
operator|)
return|;
block|}
end_block

begin_comment
comment|/* get some input from the user, leave in typein array.  Return 1  * if user aborted, 0 if he thinks there's something worth reading.  */
end_comment

begin_macro
name|userinput
argument_list|(
argument|seed
argument_list|,
argument|cue
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|seed
decl_stmt|,
modifier|*
name|cue
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|typein
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|,
name|save
index|[
literal|100
index|]
decl_stmt|;
name|int
name|curcol
decl_stmt|,
name|times
decl_stmt|,
name|mch
decl_stmt|;
name|strcpy
argument_list|(
name|typein
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
name|cue
argument_list|)
expr_stmt|;
name|prompt
operator|=
name|temp
expr_stmt|;
name|curcol
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|times
operator|=
literal|1
expr_stmt|;
name|mch
operator|=
name|mousechanged
expr_stmt|;
name|mousechanged
operator|=
literal|0
expr_stmt|;
goto|goto
name|redraw
goto|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|mousechanged
operator|||
name|UserReady
argument_list|()
condition|)
block|{
if|if
condition|(
name|mousechanged
condition|)
block|{
name|mch
operator|=
literal|1
expr_stmt|;
name|mousechanged
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|ch
operator|=
name|UserChar
argument_list|()
operator|&
literal|0xFF
condition|)
block|{
default|default:
name|times
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|' '
operator|||
name|ch
operator|>
literal|0177
condition|)
block|{
name|Beep
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
comment|/* char at end */
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|disp_char
argument_list|(
name|ch
argument_list|,
name|curcol
operator|*
name|chrwid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NORMAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curcol
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|save
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* insert char */
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
name|curcol
operator|+=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|save
argument_list|)
expr_stmt|;
goto|goto
name|redraw
goto|;
case|case
literal|'C'
operator|-
literal|0100
case|:
case|case
literal|'Q'
operator|-
literal|0100
case|:
case|case
literal|'G'
operator|-
literal|0100
case|:
name|prompt
operator|=
name|NULL
expr_stmt|;
name|clearprompt
argument_list|()
expr_stmt|;
name|mousechanged
operator|=
name|mch
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'A'
operator|-
literal|0100
case|:
name|p
operator|=
name|typein
expr_stmt|;
name|curcol
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|ctldone
label|:
name|times
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
operator|-
literal|0100
case|:
case|case
literal|'H'
operator|-
literal|0100
case|:
while|while
condition|(
name|p
operator|!=
name|typein
operator|&&
name|times
operator|>
literal|0
condition|)
block|{
name|times
operator|-=
literal|1
expr_stmt|;
name|p
operator|-=
literal|1
expr_stmt|;
name|curcol
operator|-=
literal|1
expr_stmt|;
block|}
goto|goto
name|ctldone
goto|;
case|case
literal|'D'
operator|-
literal|0100
case|:
while|while
condition|(
operator|*
name|p
operator|&&
name|times
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|times
operator|-=
literal|1
expr_stmt|;
block|}
goto|goto
name|redraw
goto|;
case|case
literal|'E'
operator|-
literal|0100
case|:
for|for
control|(
name|p
operator|=
name|prompt
operator|,
name|curcol
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|+=
literal|1
operator|,
name|curcol
operator|+=
literal|1
control|)
empty_stmt|;
for|for
control|(
name|p
operator|=
name|typein
init|;
operator|*
name|p
condition|;
name|p
operator|+=
literal|1
control|)
name|curcol
operator|+=
literal|1
expr_stmt|;
goto|goto
name|ctldone
goto|;
case|case
literal|'F'
operator|-
literal|0100
case|:
while|while
condition|(
operator|*
name|p
operator|&&
name|times
operator|>
literal|0
condition|)
block|{
name|times
operator|-=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
name|curcol
operator|+=
literal|1
expr_stmt|;
block|}
goto|goto
name|ctldone
goto|;
case|case
literal|'K'
operator|-
literal|0100
case|:
operator|*
name|p
operator|=
literal|0
expr_stmt|;
goto|goto
name|redraw
goto|;
case|case
literal|'Y'
operator|-
literal|0100
case|:
name|new_window
argument_list|(
operator|&
name|cur_state
argument_list|,
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|)
expr_stmt|;
case|case
literal|'L'
operator|-
literal|0100
case|:
name|redisplay
argument_list|()
expr_stmt|;
goto|goto
name|redraw
goto|;
case|case
literal|'U'
operator|-
literal|0100
case|:
name|times
operator|<<=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
literal|033
case|:
name|prompt
operator|=
name|NULL
expr_stmt|;
name|clearprompt
argument_list|()
expr_stmt|;
name|mousechanged
operator|=
name|mch
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0177
case|:
while|while
condition|(
name|p
operator|!=
name|typein
operator|&&
name|times
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|-=
literal|1
expr_stmt|;
name|curcol
operator|-=
literal|1
expr_stmt|;
name|times
operator|-=
literal|1
expr_stmt|;
block|}
goto|goto
name|redraw
goto|;
name|redraw
label|:
name|msg
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|incol
operator|+=
name|disp_str
argument_list|(
name|typein
argument_list|,
name|incol
operator|*
name|chrwid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NORMAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|times
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|incol
operator|=
name|curcol
expr_stmt|;
name|DpyUp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* given center, calculate various window coords */
end_comment

begin_expr_stmt
name|new_window
argument_list|(
name|s
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|)
specifier|register
expr|struct
name|state
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|wx
decl_stmt|,
name|wy
decl_stmt|;
comment|/* half-width of window in defn coords */
name|wx
operator|=
operator|(
name|wmaxx
operator|-
name|wminx
operator|)
operator|>>
literal|1
expr_stmt|;
name|wx
operator|*=
name|s
operator|->
name|dscale
expr_stmt|;
name|wx
operator|/=
name|s
operator|->
name|mscale
expr_stmt|;
comment|/* half-height of window in defn coords */
name|wy
operator|=
operator|(
name|wmaxy
operator|-
name|wminy
operator|)
operator|>>
literal|1
expr_stmt|;
name|wy
operator|*=
name|s
operator|->
name|dscale
expr_stmt|;
name|wy
operator|/=
name|s
operator|->
name|mscale
expr_stmt|;
name|s
operator|->
name|worgx
operator|=
name|cx
operator|-
name|wx
expr_stmt|;
name|s
operator|->
name|worgy
operator|=
name|cy
operator|-
name|wy
expr_stmt|;
name|s
operator|->
name|wmaxx
operator|=
name|cx
operator|+
name|wx
expr_stmt|;
name|s
operator|->
name|wmaxy
operator|=
name|cy
operator|+
name|wy
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|((x)< 0 ? -(x) : (x))
end_define

begin_comment
comment|/* see if an object is "near enough" to the cursor, sets dx, dy, ends */
end_comment

begin_expr_stmt
name|nearby
argument_list|(
name|p
argument_list|)
specifier|register
name|gptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|SEGMENT
case|:
name|dx
operator|=
name|p
operator|->
name|s
operator|.
name|x2
operator|-
name|cur_state
operator|.
name|curx
expr_stmt|;
name|dy
operator|=
name|p
operator|->
name|s
operator|.
name|y2
operator|-
name|cur_state
operator|.
name|cury
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|dx
argument_list|)
operator|<=
name|cur_state
operator|.
name|csize
operator|&&
name|abs
argument_list|(
name|dy
argument_list|)
operator|<=
name|cur_state
operator|.
name|csize
condition|)
block|{
name|ends
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
case|case
name|OBJECT
case|:
case|case
name|LABEL
case|:
name|dx
operator|=
name|p
operator|->
name|s
operator|.
name|x1
operator|-
name|cur_state
operator|.
name|curx
expr_stmt|;
name|dy
operator|=
name|p
operator|->
name|s
operator|.
name|y1
operator|-
name|cur_state
operator|.
name|cury
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|dx
argument_list|)
operator|<=
name|cur_state
operator|.
name|csize
operator|&&
name|abs
argument_list|(
name|dy
argument_list|)
operator|<=
name|cur_state
operator|.
name|csize
condition|)
block|{
name|ends
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* unselect currently selected object:  *	update& UPDATE		update object's info  *				+ USEOFFSET -- use lxoff, lyoff  *	update& REDISPLAY	redisplay when done  */
end_comment

begin_macro
name|deselect
argument_list|(
argument|update
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
init|=
name|cur_state
operator|.
name|editee
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|gptr
name|save
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
comment|/* nothing to do */
if|if
condition|(
name|update
operator|&
name|UPDATE
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|SEGMENT
case|:
if|if
condition|(
name|cur_state
operator|.
name|whichend
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|update
operator|&
name|USEOFFSET
condition|)
block|{
name|p
operator|->
name|s
operator|.
name|x2
operator|+=
name|cur_state
operator|.
name|lxoff
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y2
operator|+=
name|cur_state
operator|.
name|lyoff
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|xoff
expr_stmt|;
name|cur_state
operator|.
name|lxoff
operator|=
name|temp
operator|-
name|p
operator|->
name|s
operator|.
name|x2
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x2
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|yoff
expr_stmt|;
name|cur_state
operator|.
name|lyoff
operator|=
name|temp
operator|-
name|p
operator|->
name|s
operator|.
name|y2
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y2
operator|=
name|temp
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
case|case
name|LABEL
case|:
case|case
name|OBJECT
case|:
if|if
condition|(
name|update
operator|&
name|USEOFFSET
condition|)
block|{
name|p
operator|->
name|s
operator|.
name|x1
operator|+=
name|cur_state
operator|.
name|lxoff
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y1
operator|+=
name|cur_state
operator|.
name|lyoff
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|xoff
expr_stmt|;
name|cur_state
operator|.
name|lxoff
operator|=
name|temp
operator|-
name|p
operator|->
name|s
operator|.
name|x1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|x1
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|yoff
expr_stmt|;
name|cur_state
operator|.
name|lyoff
operator|=
name|temp
operator|-
name|p
operator|->
name|s
operator|.
name|y1
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|y1
operator|=
name|temp
expr_stmt|;
block|}
break|break;
block|}
name|cur_state
operator|.
name|curobj
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|type
operator|==
name|SEGMENT
condition|)
name|newalist
argument_list|(
operator|&
name|p
operator|->
name|s
argument_list|,
name|p
operator|->
name|s
operator|.
name|x1
argument_list|,
name|p
operator|->
name|s
operator|.
name|y1
argument_list|,
name|p
operator|->
name|s
operator|.
name|x2
argument_list|,
name|p
operator|->
name|s
operator|.
name|y2
argument_list|)
expr_stmt|;
name|cur_state
operator|.
name|editee
operator|=
name|NULL
expr_stmt|;
comment|/* to update display we only have to redraw selected object */
if|if
condition|(
name|update
operator|&
name|REDISPLAY
condition|)
block|{
name|save
operator|=
name|p
operator|->
name|s
operator|.
name|next
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|display
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NORTH
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NORMAL
argument_list|)
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|next
operator|=
name|save
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* update database to reflect newly selected object */
end_comment

begin_expr_stmt
name|selectobj
argument_list|(
name|p
argument_list|,
name|new
argument_list|)
specifier|register
name|gptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|deselect
argument_list|(
name|UPDATE
operator|+
name|REDISPLAY
argument_list|)
expr_stmt|;
name|cur_state
operator|.
name|editee
operator|=
name|p
expr_stmt|;
name|cur_state
operator|.
name|xoff
operator|=
literal|0
expr_stmt|;
name|cur_state
operator|.
name|yoff
operator|=
literal|0
expr_stmt|;
name|cur_state
operator|.
name|whichend
operator|=
name|ends
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
if|if
condition|(
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
operator|+
name|dx
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|dy
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|new_window
argument_list|(
operator|&
name|cur_state
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|dx
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|dy
argument_list|)
expr_stmt|;
name|remouse
argument_list|(
name|cur_state
operator|.
name|curx
argument_list|,
name|cur_state
operator|.
name|cury
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* redisplay entire screen */
end_comment

begin_macro
name|redisplay
argument_list|()
end_macro

begin_block
block|{
name|clearscreen
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur_state
operator|.
name|curobj
operator|!=
name|NULL
condition|)
block|{
name|display
argument_list|(
name|cur_state
operator|.
name|curobj
operator|->
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NORTH
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NORMAL
argument_list|)
expr_stmt|;
name|ctext
argument_list|(
literal|"*"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CC
argument_list|,
name|NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* grid points fall every csize points */
if|if
condition|(
name|cur_state
operator|.
name|grid
condition|)
name|disp_grid
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* return code when used as a command */
block|}
end_block

begin_comment
comment|/* return appropriately oriented x and y coords */
end_comment

begin_macro
name|xorient
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|orient
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|orient
condition|)
block|{
case|case
name|NORTH
case|:
return|return
operator|(
name|x
operator|)
return|;
case|case
name|EAST
case|:
return|return
operator|(
name|y
operator|)
return|;
case|case
name|SOUTH
case|:
return|return
operator|(
operator|-
name|x
operator|)
return|;
case|case
name|WEST
case|:
return|return
operator|(
operator|-
name|y
operator|)
return|;
case|case
name|RNORTH
case|:
return|return
operator|(
operator|-
name|x
operator|)
return|;
case|case
name|REAST
case|:
return|return
operator|(
operator|-
name|y
operator|)
return|;
case|case
name|RSOUTH
case|:
return|return
operator|(
name|x
operator|)
return|;
case|case
name|RWEST
case|:
return|return
operator|(
name|y
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_block

begin_macro
name|yorient
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|orient
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|orient
condition|)
block|{
case|case
name|NORTH
case|:
return|return
operator|(
name|y
operator|)
return|;
case|case
name|EAST
case|:
return|return
operator|(
operator|-
name|x
operator|)
return|;
case|case
name|SOUTH
case|:
return|return
operator|(
operator|-
name|y
operator|)
return|;
case|case
name|WEST
case|:
return|return
operator|(
name|x
operator|)
return|;
case|case
name|RNORTH
case|:
return|return
operator|(
name|y
operator|)
return|;
case|case
name|REAST
case|:
return|return
operator|(
operator|-
name|x
operator|)
return|;
case|case
name|RSOUTH
case|:
return|return
operator|(
operator|-
name|y
operator|)
return|;
case|case
name|RWEST
case|:
return|return
operator|(
name|x
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_block

begin_comment
comment|/* display objects with specified translation and rotation */
end_comment

begin_expr_stmt
name|display
argument_list|(
name|o
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|orient
argument_list|,
name|mscale
argument_list|,
name|dscale
argument_list|,
name|dflag
argument_list|)
specifier|register
name|gptr
name|o
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|short
name|tx
decl_stmt|,
name|ty
decl_stmt|;
name|short
name|ex
decl_stmt|,
name|ey
decl_stmt|;
while|while
condition|(
name|o
operator|!=
name|NULL
condition|)
block|{
name|tx
operator|=
name|xorient
argument_list|(
name|o
operator|->
name|l
operator|.
name|x
argument_list|,
name|o
operator|->
name|l
operator|.
name|y
argument_list|,
name|orient
argument_list|)
expr_stmt|;
name|tx
operator|*=
name|mscale
expr_stmt|;
name|tx
operator|/=
name|dscale
expr_stmt|;
name|tx
operator|+=
name|x
expr_stmt|;
name|ty
operator|=
name|yorient
argument_list|(
name|o
operator|->
name|l
operator|.
name|x
argument_list|,
name|o
operator|->
name|l
operator|.
name|y
argument_list|,
name|orient
argument_list|)
expr_stmt|;
name|ty
operator|*=
name|mscale
expr_stmt|;
name|ty
operator|/=
name|dscale
expr_stmt|;
name|ty
operator|+=
name|y
expr_stmt|;
if|if
condition|(
name|cur_state
operator|.
name|editee
operator|!=
name|o
condition|)
switch|switch
condition|(
name|o
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|LABEL
case|:
name|ctext
argument_list|(
name|o
operator|->
name|l
operator|.
name|string
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|lcomp
index|[
name|orient
index|]
index|[
name|o
operator|->
name|l
operator|.
name|orient
index|]
argument_list|,
name|dflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJECT
case|:
name|display
argument_list|(
name|o
operator|->
name|o
operator|.
name|proto
operator|->
name|body
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|ocomp
index|[
name|orient
index|]
index|[
name|o
operator|->
name|o
operator|.
name|orient
index|]
argument_list|,
name|mscale
operator|*
name|o
operator|->
name|o
operator|.
name|mscale
argument_list|,
name|dscale
operator|*
name|o
operator|->
name|o
operator|.
name|dscale
argument_list|,
name|dflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEGMENT
case|:
if|if
condition|(
name|o
operator|->
name|s
operator|.
name|cache
operator|!=
name|NULL
condition|)
block|{
name|display
argument_list|(
name|o
operator|->
name|s
operator|.
name|cache
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|orient
argument_list|,
name|mscale
argument_list|,
name|dscale
argument_list|,
name|dflag
argument_list|)
expr_stmt|;
break|break;
block|}
name|ex
operator|=
name|xorient
argument_list|(
name|o
operator|->
name|s
operator|.
name|x2
argument_list|,
name|o
operator|->
name|s
operator|.
name|y2
argument_list|,
name|orient
argument_list|)
expr_stmt|;
name|ex
operator|*=
name|mscale
expr_stmt|;
name|ex
operator|/=
name|dscale
expr_stmt|;
name|ex
operator|+=
name|x
expr_stmt|;
name|ey
operator|=
name|yorient
argument_list|(
name|o
operator|->
name|s
operator|.
name|x2
argument_list|,
name|o
operator|->
name|s
operator|.
name|y2
argument_list|,
name|orient
argument_list|)
expr_stmt|;
name|ey
operator|*=
name|mscale
expr_stmt|;
name|ey
operator|/=
name|dscale
expr_stmt|;
name|ey
operator|+=
name|y
expr_stmt|;
name|cline
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|,
name|ex
argument_list|,
name|ey
argument_list|,
name|dflag
argument_list|)
expr_stmt|;
break|break;
block|}
name|o
operator|=
name|o
operator|->
name|s
operator|.
name|next
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* output a message on the bottom-most line */
end_comment

begin_macro
name|msg
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|clearprompt
argument_list|()
expr_stmt|;
name|incol
operator|+=
name|disp_str
argument_list|(
name|string
argument_list|,
name|incol
operator|*
name|chrwid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NORMAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* display text string with proper orientation clipped by current window */
end_comment

begin_expr_stmt
name|ctext
argument_list|(
name|string
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|orient
argument_list|,
name|dflag
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|*
name|chrwid
operator|)
operator|>>
literal|1
decl_stmt|;
comment|/* first translate and scale to the window coord system */
name|y
operator|-=
name|cur_state
operator|.
name|worgy
expr_stmt|;
name|x
operator|-=
name|cur_state
operator|.
name|worgx
expr_stmt|;
name|y
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|y
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
name|x
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|x
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
comment|/* adjust for character orientation */
switch|switch
condition|(
name|orient
condition|)
block|{
case|case
name|CC
case|:
name|x
operator|-=
name|i
expr_stmt|;
name|y
operator|-=
operator|(
name|chrhgt
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|TC
case|:
name|x
operator|-=
name|i
expr_stmt|;
name|y
operator|-=
name|chrhgt
expr_stmt|;
break|break;
case|case
name|BC
case|:
name|x
operator|-=
name|i
expr_stmt|;
break|break;
case|case
name|CL
case|:
name|y
operator|-=
operator|(
name|chrhgt
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|TL
case|:
name|y
operator|-=
name|chrhgt
expr_stmt|;
break|break;
case|case
name|BL
case|:
break|break;
case|case
name|CR
case|:
name|x
operator|-=
name|i
operator|+
name|i
expr_stmt|;
name|y
operator|-=
operator|(
name|chrhgt
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|TR
case|:
name|x
operator|-=
name|i
operator|+
name|i
expr_stmt|;
name|y
operator|-=
name|chrhgt
expr_stmt|;
break|break;
case|case
name|BR
case|:
name|x
operator|-=
name|i
operator|+
name|i
expr_stmt|;
block|}
comment|/* only display chars that lie within current window */
name|x
operator|+=
name|wminx
expr_stmt|;
name|y
operator|+=
name|wminy
expr_stmt|;
if|if
condition|(
name|y
operator|<=
name|wmaxy
operator|&&
name|y
operator|+
name|chrhgt
operator|>=
name|wminy
operator|&&
name|x
operator|<=
name|wmaxx
operator|&&
name|x
operator|+
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|*
name|chrwid
operator|)
operator|>=
name|wminx
condition|)
name|disp_str
argument_list|(
name|string
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
name|dflag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* draw a clipped vector */
end_comment

begin_define
define|#
directive|define
name|code
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|((x<wminx ? 1 : x>wmaxx ? 2 : 0) + (y<wminy ? 4 : y>wmaxy ? 8 : 0))
end_define

begin_macro
name|cline
argument_list|(
argument|fx
argument_list|,
argument|fy
argument_list|,
argument|tx
argument_list|,
argument|ty
argument_list|,
argument|dflag
argument_list|)
end_macro

begin_block
block|{
comment|/* first translate and scale to the window coord system */
name|fx
operator|-=
name|cur_state
operator|.
name|worgx
expr_stmt|;
name|fy
operator|-=
name|cur_state
operator|.
name|worgy
expr_stmt|;
name|tx
operator|-=
name|cur_state
operator|.
name|worgx
expr_stmt|;
name|ty
operator|-=
name|cur_state
operator|.
name|worgy
expr_stmt|;
name|fy
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|fy
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
name|fx
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|fx
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
name|ty
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|ty
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
name|tx
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|tx
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
name|fx
operator|+=
name|wminx
expr_stmt|;
name|fy
operator|+=
name|wminy
expr_stmt|;
name|tx
operator|+=
name|wminx
expr_stmt|;
name|ty
operator|+=
name|wminy
expr_stmt|;
if|if
condition|(
operator|(
name|code
argument_list|(
name|fx
argument_list|,
name|fy
argument_list|)
operator|&
name|code
argument_list|(
name|tx
argument_list|,
name|ty
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|line
argument_list|(
name|fx
argument_list|,
name|fy
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|,
name|dflag
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* display grid points at csize intervals */
end_comment

begin_macro
name|disp_grid
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|incrx
decl_stmt|,
name|incry
decl_stmt|;
comment|/* find window coord of lower left grid point */
name|x
operator|=
name|cur_state
operator|.
name|worgx
operator|+
name|cur_state
operator|.
name|csize
operator|-
literal|1
expr_stmt|;
name|x
operator|&=
operator|~
operator|(
name|cur_state
operator|.
name|csize
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|-=
name|cur_state
operator|.
name|worgx
expr_stmt|;
name|x
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|x
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
name|y
operator|=
name|cur_state
operator|.
name|worgy
operator|+
name|cur_state
operator|.
name|csize
operator|-
literal|1
expr_stmt|;
name|y
operator|&=
operator|~
operator|(
name|cur_state
operator|.
name|csize
operator|-
literal|1
operator|)
expr_stmt|;
name|y
operator|-=
name|cur_state
operator|.
name|worgy
expr_stmt|;
name|y
operator|*=
name|cur_state
operator|.
name|mscale
expr_stmt|;
name|y
operator|/=
name|cur_state
operator|.
name|dscale
expr_stmt|;
name|x
operator|+=
name|wminx
expr_stmt|;
name|y
operator|=
name|wmaxy
operator|-
name|y
operator|-
name|wminy
expr_stmt|;
name|incrx
operator|=
operator|(
name|cur_state
operator|.
name|csize
operator|*
name|cur_state
operator|.
name|mscale
operator|)
operator|/
name|cur_state
operator|.
name|dscale
expr_stmt|;
if|if
condition|(
name|incrx
operator|<=
literal|0
condition|)
name|incrx
operator|=
literal|8
expr_stmt|;
else|else
while|while
condition|(
name|incrx
operator|<
literal|8
condition|)
name|incrx
operator|<<=
literal|1
expr_stmt|;
name|incry
operator|=
name|incrx
expr_stmt|;
name|drawgrid
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|incrx
argument_list|,
name|incry
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Xor drawing cursor and selected object */
end_comment

begin_macro
name|dcurxor
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|gptr
name|p
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|cur_state
operator|.
name|curobj
operator|==
name|NULL
condition|)
return|return;
comment|/* no object on screen */
if|if
condition|(
operator|(
name|p
operator|=
name|cur_state
operator|.
name|editee
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|type
operator|==
name|SEGMENT
operator|&&
operator|(
name|redo
operator|||
operator|(
name|p
operator|->
name|s
operator|.
name|angle
operator|!=
literal|0
operator|&&
operator|(
name|cur_state
operator|.
name|curx
operator|!=
name|cur_state
operator|.
name|oldx
operator|||
name|cur_state
operator|.
name|cury
operator|!=
name|cur_state
operator|.
name|oldy
operator|)
operator|)
operator|)
condition|)
block|{
name|cur_state
operator|.
name|oldx
operator|=
name|cur_state
operator|.
name|curx
expr_stmt|;
name|cur_state
operator|.
name|oldy
operator|=
name|cur_state
operator|.
name|cury
expr_stmt|;
name|redo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cur_state
operator|.
name|whichend
operator|==
literal|2
condition|)
name|newalist
argument_list|(
operator|&
name|p
operator|->
name|s
argument_list|,
name|p
operator|->
name|s
operator|.
name|x1
argument_list|,
name|p
operator|->
name|s
operator|.
name|y1
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|xoff
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|yoff
argument_list|)
expr_stmt|;
else|else
name|newalist
argument_list|(
operator|&
name|p
operator|->
name|s
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|xoff
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|yoff
argument_list|,
name|p
operator|->
name|s
operator|.
name|x2
argument_list|,
name|p
operator|->
name|s
operator|.
name|y2
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|SEGMENT
case|:
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|cache
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|cache
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|next
control|)
name|cline
argument_list|(
name|p
operator|->
name|s
operator|.
name|x1
argument_list|,
name|p
operator|->
name|s
operator|.
name|y1
argument_list|,
name|p
operator|->
name|s
operator|.
name|x2
argument_list|,
name|p
operator|->
name|s
operator|.
name|y2
argument_list|,
name|HIGHLIGHT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cur_state
operator|.
name|whichend
operator|==
literal|2
condition|)
block|{
name|x
operator|=
name|p
operator|->
name|s
operator|.
name|x1
expr_stmt|;
name|y
operator|=
name|p
operator|->
name|s
operator|.
name|y1
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|p
operator|->
name|s
operator|.
name|x2
expr_stmt|;
name|y
operator|=
name|p
operator|->
name|s
operator|.
name|y2
expr_stmt|;
block|}
name|cline
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|xoff
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|yoff
argument_list|,
name|HIGHLIGHT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL
case|:
name|ctext
argument_list|(
name|p
operator|->
name|l
operator|.
name|string
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|xoff
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|yoff
argument_list|,
name|p
operator|->
name|l
operator|.
name|orient
argument_list|,
name|HIGHLIGHT
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJECT
case|:
name|display
argument_list|(
name|p
operator|->
name|o
operator|.
name|proto
operator|->
name|body
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|xoff
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|yoff
argument_list|,
name|p
operator|->
name|o
operator|.
name|orient
argument_list|,
name|p
operator|->
name|o
operator|.
name|mscale
argument_list|,
name|p
operator|->
name|o
operator|.
name|dscale
argument_list|,
name|HIGHLIGHT
argument_list|)
expr_stmt|;
return|return;
comment|/* no cursor needed here */
block|}
block|}
comment|/* draw x-shaped graphic cursor */
name|cline
argument_list|(
name|cur_state
operator|.
name|curx
operator|-
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|cury
operator|-
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|csize
argument_list|,
name|HIGHLIGHT
argument_list|)
expr_stmt|;
name|cline
argument_list|(
name|cur_state
operator|.
name|curx
operator|-
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|cury
operator|+
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|curx
operator|+
name|cur_state
operator|.
name|csize
argument_list|,
name|cur_state
operator|.
name|cury
operator|-
name|cur_state
operator|.
name|csize
argument_list|,
name|HIGHLIGHT
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Help stuff */
end_comment

begin_macro
name|Help
argument_list|()
end_macro

begin_block
block|{
name|struct
name|prototype
modifier|*
name|help_proto
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|help_proto
operator|=
name|read_def
argument_list|(
name|HELPFILE
argument_list|)
expr_stmt|;
comment|/* Load the file, if any. */
if|if
condition|(
name|help_proto
operator|->
name|body
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Can't read '%s.DEF' -- NO HELP"
argument_list|,
name|HELPFILE
argument_list|)
expr_stmt|;
name|msg
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|previous
operator|=
name|cur_state
operator|.
name|curobj
expr_stmt|;
if|if
condition|(
name|cur_state
operator|.
name|curobj
condition|)
name|cur_state
operator|.
name|curobj
operator|->
name|recent
operator|=
name|cur_state
expr_stmt|;
name|cur_state
operator|=
name|help_proto
operator|->
name|recent
expr_stmt|;
return|return
name|REDISPLAY
return|;
block|}
end_block

begin_comment
comment|/* Adjust coordinates in body of an object by the origin of that object.  * This routine is called after an object is edited, so that an adjusted  * subpicture origin is reflected immediately in pictures which reference  * it.  */
end_comment

begin_expr_stmt
name|adj_org
argument_list|(
name|p
argument_list|,
name|adjx
argument_list|,
name|adjy
argument_list|)
specifier|register
expr|struct
name|prototype
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|gptr
name|o
decl_stmt|;
name|struct
name|prototype
name|temp
decl_stmt|;
for|for
control|(
name|o
operator|=
name|p
operator|->
name|body
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|s
operator|.
name|next
control|)
switch|switch
condition|(
name|o
operator|->
name|s
operator|.
name|type
condition|)
block|{
case|case
name|SEGMENT
case|:
name|o
operator|->
name|s
operator|.
name|x1
operator|-=
name|adjx
expr_stmt|;
name|o
operator|->
name|s
operator|.
name|y1
operator|-=
name|adjy
expr_stmt|;
name|o
operator|->
name|s
operator|.
name|x2
operator|-=
name|adjx
expr_stmt|;
name|o
operator|->
name|s
operator|.
name|y2
operator|-=
name|adjy
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|s
operator|.
name|cache
condition|)
block|{
name|temp
operator|.
name|body
operator|=
name|o
operator|->
name|s
operator|.
name|cache
expr_stmt|;
name|adj_org
argument_list|(
operator|&
name|temp
argument_list|,
name|adjx
argument_list|,
name|adjy
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LABEL
case|:
name|o
operator|->
name|l
operator|.
name|x
operator|-=
name|adjx
expr_stmt|;
name|o
operator|->
name|l
operator|.
name|y
operator|-=
name|adjy
expr_stmt|;
break|break;
case|case
name|OBJECT
case|:
name|o
operator|->
name|o
operator|.
name|x
operator|-=
name|adjx
expr_stmt|;
name|o
operator|->
name|o
operator|.
name|y
operator|-=
name|adjy
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

