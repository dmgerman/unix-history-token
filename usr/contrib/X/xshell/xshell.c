begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1985, Cognition Inc.  * This software is not supported by Cognition Inc. and is  * provided "as is".  To keep the X revolution growing, please forward   * enhancements and bug fixes to anyone who is interested.  */
end_comment

begin_comment
comment|/*  * XShell - a quick "shell" to allow you to cons up programs on the fly.  The  * program looks at Button and Key Pressed events and looks up Xshell.name in  * $HOME/.Xdefaults where name is:  *  *	LeftButton, MiddleButton, RightButton - on button events.  *	ascii (e.g. [aB^9]) - on key pressed events.  *	PF# and various special names - on special keys.  *  * The idea is that the user can define any set of key/button bindings which  * can be invoked by simply pressing in the XShell window.  This can be very  * useful for times when you have filled all of your windows with things that  * you don't want to (or can't) suspend.  *  * I find it useful to have a large and small terminal window, a dc, and   * sometimes an editor that I can pop up on demand.  This program was written  * because I was tired of getting into situations where I didn't have a window  * handy and I needed to run some little calculator or editor.  Since I use  * a small, terse window manager I didn't just stick a bag on the side of it,  * but wrote a separate program instead.  *  * Apologies to anyone who has the scallop shell as a trademark.  *  * Author:  Jim Fulton, Cognition Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_xshell_c
init|=
literal|"$Header: xshell.c,v 10.6 86/02/01 16:19:36 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X/Xkeyboard.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"scallopshell.h"
end_include

begin_include
include|#
directive|include
file|"largescallopshell.h"
end_include

begin_decl_stmt
specifier|extern
name|KeyMapEntry
name|StdMap
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|strneq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strncmp ((a), (b), strlen(a)) == 0)
end_define

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp ((a), (b)) == 0)
end_define

begin_define
define|#
directive|define
name|isopt
parameter_list|(
name|optname
parameter_list|)
value|(strneq(*argv, optname))
end_define

begin_comment
comment|/* does partial matching */
end_comment

begin_define
define|#
directive|define
name|hasarg
value|((argv[1] != (char *) NULL)&& (argv[1][0] != '-'))
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|DEFAULT_FONT
value|"helv12b"
end_define

begin_define
define|#
directive|define
name|micro2centi
value|(10000)
end_define

begin_comment
comment|/* microsecond to 1/100 second */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ProgramName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
name|ShellWindow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fg
init|=
name|BlackPixel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print bits in black */
end_comment

begin_decl_stmt
name|int
name|bg
init|=
name|WhitePixel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print background in white */
end_comment

begin_decl_stmt
name|int
name|bd
init|=
name|BlackPixel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print border in black */
end_comment

begin_decl_stmt
name|int
name|bw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no border */
end_comment

begin_decl_stmt
name|int
name|volume
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WindowInfo
name|RootWindowInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bitmap
name|IconBitmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Pixmap
name|IconPixmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XEvent
name|inputevent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nflash
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|delaytime
init|=
block|{
literal|0
block|,
literal|5
operator|*
name|micro2centi
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|icon_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icon_width
decl_stmt|,
name|icon_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|actionvector
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command table */
end_comment

begin_decl_stmt
name|char
name|actionfound
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see flags below */
end_comment

begin_define
define|#
directive|define
name|ACTION_NEW
value|((char) 0)
end_define

begin_define
define|#
directive|define
name|ACTION_FOUND
value|((char) 1)
end_define

begin_define
define|#
directive|define
name|ACTION_NOT_FOUND
value|((char) 2)
end_define

begin_decl_stmt
name|char
modifier|*
name|yes
index|[]
init|=
block|{
literal|"y"
block|,
literal|"yes"
block|,
literal|"YES"
block|,
literal|"on"
block|,
literal|"ON"
block|,
literal|"On"
block|,
literal|"t"
block|,
literal|"true"
block|,
literal|"TRUE"
block|,
literal|"True"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|small
index|[]
init|=
block|{
literal|"s"
block|,
literal|"S"
block|,
literal|"small"
block|,
literal|"SMALL"
block|,
literal|"Small"
block|,
literal|"sm"
block|,
literal|"SM"
block|,
literal|"Sm"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|IsMemberOf
parameter_list|(
name|list
parameter_list|,
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|list
index|[]
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|list
condition|;
name|list
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|string
argument_list|,
operator|*
name|list
argument_list|)
condition|)
return|return
operator|(
name|YES
operator|)
return|;
block|}
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_function

begin_macro
name|reapchild
argument_list|()
end_macro

begin_block
block|{
name|union
name|wait
name|status
decl_stmt|;
while|while
condition|(
name|wait3
argument_list|(
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
return|return;
block|}
end_block

begin_function
specifier|static
name|void
name|Error
parameter_list|(
name|msg
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  error with %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
operator|*
name|arg
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|Usage
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  error with \"%s\".  Usage is\n"
argument_list|,
name|ProgramName
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\t\t%s [-flags] [=WxH+X+Y] [host:displaynum]\n\n"
argument_list|,
name|ProgramName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"where -flags are:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-fg color       Foreground color.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-bg color       Background color.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-bd color       Border color.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-bw[idth]n      Border width in pixels.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-v[olume] n     Bell volume.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-fl[ash] n      Number of times to flash icon.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-d[elay] n      1/10ths of a second flashes.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-r[everse]      Reverse video.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-q[uiet]        Don\'t feep on errors.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-s[mall]        Use a small icon instead of a big one.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|quit
argument_list|()
end_macro

begin_block
block|{
name|XUnmapWindow
argument_list|(
name|ShellWindow
argument_list|)
expr_stmt|;
name|XCloseDisplay
argument_list|(
name|dpy
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|fgname
decl_stmt|,
modifier|*
name|bgname
decl_stmt|,
modifier|*
name|bdname
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|char
modifier|*
name|displayname
decl_stmt|;
name|Color
name|colorstruct
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|cbuf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|xoff
decl_stmt|,
name|yoff
decl_stmt|,
name|xsign
decl_stmt|,
name|ysign
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|quit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|quit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|reapchild
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* set program name for errors */
name|ProgramName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|ProgramName
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|ProgramName
operator|=
operator|++
name|cp
expr_stmt|;
comment|/* strip off directory name */
comment|/* Initialize variables */
name|fgname
operator|=
name|bgname
operator|=
name|bdname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|reverse
operator|=
name|NO
expr_stmt|;
name|displayname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|actionfound
argument_list|,
sizeof|sizeof
argument_list|(
name|actionfound
argument_list|)
argument_list|)
expr_stmt|;
name|icon_bits
operator|=
name|largescallopshell_bits
expr_stmt|;
name|width
operator|=
operator|-
literal|1
expr_stmt|;
name|height
operator|=
operator|-
literal|1
expr_stmt|;
name|icon_width
operator|=
name|largescallopshell_width
expr_stmt|;
name|icon_height
operator|=
name|largescallopshell_height
expr_stmt|;
comment|/* read in defaults from .Xdefaults */
name|fgname
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"Foreground"
argument_list|)
expr_stmt|;
name|bgname
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"Background"
argument_list|)
expr_stmt|;
name|bdname
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"Border"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"BorderWidth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|bw
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"Volume"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|volume
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"Flash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|nflash
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"Delay"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|delaytime
operator|.
name|tv_usec
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|*
name|micro2centi
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"ReverseVideo"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|IsMemberOf
argument_list|(
name|yes
argument_list|,
name|cp
argument_list|)
condition|)
name|reverse
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"Quiet"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|IsMemberOf
argument_list|(
name|yes
argument_list|,
name|cp
argument_list|)
condition|)
name|quiet
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"IconSize"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|IsMemberOf
argument_list|(
name|small
argument_list|,
name|cp
argument_list|)
condition|)
block|{
name|icon_bits
operator|=
name|scallopshell_bits
expr_stmt|;
name|icon_width
operator|=
name|scallopshell_width
expr_stmt|;
name|icon_height
operator|=
name|scallopshell_height
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
literal|"WindowGeometry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|!
name|XParse_Window_Geometry
argument_list|(
name|cp
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|xsign
argument_list|,
operator|&
name|xoff
argument_list|,
operator|&
name|ysign
argument_list|,
operator|&
name|yoff
argument_list|)
condition|)
name|Usage
argument_list|(
literal|"default =WxH+XOFF+YOFF"
argument_list|)
expr_stmt|;
block|}
comment|/* read command arguments */
name|argv
operator|++
expr_stmt|;
comment|/* advance past command name */
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
comment|/* iterate over arguments */
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|isopt
argument_list|(
literal|"-fg"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasarg
condition|)
block|{
name|fgname
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-fg foreground"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-bg"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasarg
condition|)
block|{
name|bgname
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-bg background"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-bd"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasarg
condition|)
block|{
name|bdname
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-bd border color"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-bwidth"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasarg
condition|)
block|{
name|bw
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-bwidth borderwidth"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-volume"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasarg
condition|)
block|{
name|volume
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-volume volume"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-flash"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasarg
condition|)
block|{
name|nflash
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-flash n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-delay"
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasarg
condition|)
block|{
name|delaytime
operator|.
name|tv_usec
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
operator|*
name|micro2centi
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-delay n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-reverse"
argument_list|)
condition|)
block|{
name|reverse
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-quiet"
argument_list|)
condition|)
block|{
name|quiet
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isopt
argument_list|(
literal|"-small"
argument_list|)
condition|)
block|{
name|icon_bits
operator|=
name|scallopshell_bits
expr_stmt|;
name|icon_width
operator|=
name|scallopshell_width
expr_stmt|;
name|icon_height
operator|=
name|scallopshell_height
expr_stmt|;
block|}
else|else
name|Usage
argument_list|(
literal|"-unknown flag"
argument_list|)
expr_stmt|;
comment|/* end if command line options */
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
operator|!
name|XParse_Window_Geometry
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|,
operator|&
name|xsign
argument_list|,
operator|&
name|xoff
argument_list|,
operator|&
name|ysign
argument_list|,
operator|&
name|yoff
argument_list|)
condition|)
name|Usage
argument_list|(
literal|"=WxH+XOFF+YOFF"
argument_list|)
expr_stmt|;
block|}
else|else
name|displayname
operator|=
operator|*
name|argv
expr_stmt|;
block|}
comment|/*end for*/
if|if
condition|(
name|width
operator|==
operator|-
literal|1
condition|)
name|width
operator|=
name|icon_width
expr_stmt|;
if|if
condition|(
name|height
operator|==
operator|-
literal|1
condition|)
name|height
operator|=
name|icon_height
expr_stmt|;
comment|/* okay, now set things up */
name|dpy
operator|=
name|XOpenDisplay
argument_list|(
name|displayname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dpy
condition|)
name|Error
argument_list|(
literal|"opening display"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XQueryWindow
argument_list|(
name|RootWindow
argument_list|,
operator|&
name|RootWindowInfo
argument_list|)
condition|)
name|Error
argument_list|(
literal|"query root"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsign
operator|<
literal|0
condition|)
name|xoff
operator|=
name|RootWindowInfo
operator|.
name|width
operator|-
name|xoff
operator|-
name|width
operator|-
literal|2
operator|*
name|bw
expr_stmt|;
if|if
condition|(
name|ysign
operator|<
literal|0
condition|)
name|yoff
operator|=
name|RootWindowInfo
operator|.
name|height
operator|-
name|yoff
operator|-
name|height
operator|-
literal|2
operator|*
name|bw
expr_stmt|;
comment|/* set the colors for the various parts */
define|#
directive|define
name|setcolor
parameter_list|(
name|colorname
parameter_list|,
name|colornum
parameter_list|)
define|\
value|if (colorname&& DisplayCells()> 2&&				\ 		XParseColor(colorname,&colorstruct)&& 		\ 		XGetHardwareColor(&colorstruct)) {			\ 	    colornum = colorstruct.pixel;				\ 	    reverse = NO;						\ 	}
name|setcolor
argument_list|(
name|fgname
argument_list|,
name|fg
argument_list|)
expr_stmt|;
name|setcolor
argument_list|(
name|bgname
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|setcolor
argument_list|(
name|bdname
argument_list|,
name|bd
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|setcolor
if|if
condition|(
name|reverse
condition|)
block|{
name|i
operator|=
name|fg
expr_stmt|;
name|fg
operator|=
name|bg
expr_stmt|;
name|bg
operator|=
name|i
expr_stmt|;
block|}
comment|/* now, make up the icon pixmap */
name|IconBitmap
operator|=
name|XStoreBitmap
argument_list|(
name|icon_width
argument_list|,
name|icon_height
argument_list|,
name|icon_bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IconBitmap
condition|)
name|Error
argument_list|(
literal|"storing icon bitmap"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|IconPixmap
operator|=
name|XMakePixmap
argument_list|(
name|IconBitmap
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IconPixmap
condition|)
name|Error
argument_list|(
literal|"storing icon pixmap"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* make the window */
name|ShellWindow
operator|=
name|XCreateWindow
argument_list|(
name|RootWindow
argument_list|,
name|xoff
argument_list|,
name|yoff
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|bw
argument_list|,
name|XMakeTile
argument_list|(
name|bd
argument_list|)
argument_list|,
name|XMakeTile
argument_list|(
name|bg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ShellWindow
condition|)
name|Error
argument_list|(
literal|"creating shell window"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* and store away the program name in the window */
name|XStoreName
argument_list|(
name|ShellWindow
argument_list|,
name|ProgramName
argument_list|)
expr_stmt|;
comment|/* select the window events */
name|XSelectInput
argument_list|(
name|ShellWindow
argument_list|,
name|KeyPressed
operator||
name|ButtonPressed
operator||
name|ExposeWindow
argument_list|)
expr_stmt|;
comment|/* and map it, this should generate an Expose event */
name|XMapWindow
argument_list|(
name|ShellWindow
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* loop forever */
name|XNextEvent
argument_list|(
operator|&
name|inputevent
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
operator|(
name|XKeyOrButtonEvent
operator|*
operator|)
operator|&
name|inputevent
operator|)
operator|->
name|detail
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|inputevent
operator|.
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
comment|/* repaint the icon */
if|if
condition|(
name|inputevent
operator|.
name|window
operator|==
name|ShellWindow
condition|)
name|XPixmapPut
argument_list|(
name|ShellWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|icon_width
argument_list|,
name|icon_height
argument_list|,
name|IconPixmap
argument_list|,
name|GXcopy
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeyPressed
case|:
name|c
operator|=
name|StdMap
index|[
name|code
operator|&
name|ValueMask
index|]
index|[
name|KeyState
argument_list|(
name|code
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|feep
argument_list|()
expr_stmt|;
break|break;
case|case
name|SHFT
case|:
name|perform
argument_list|(
literal|"SHIFT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTL
case|:
name|perform
argument_list|(
literal|"CONTROL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK
case|:
name|perform
argument_list|(
literal|"LOCK"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL
case|:
name|perform
argument_list|(
literal|"SYMBOL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYPAD
case|:
switch|switch
condition|(
name|code
operator|&
name|ValueMask
condition|)
block|{
case|case
name|KC_KEYPAD_0
case|:
name|perform
argument_list|(
literal|"KEYPAD0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_PERIOD
case|:
name|perform
argument_list|(
literal|"KEYPAD."
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_ENTER
case|:
name|perform
argument_list|(
literal|"ENTER"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_1
case|:
name|perform
argument_list|(
literal|"KEYPAD1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_2
case|:
name|perform
argument_list|(
literal|"KEYPAD2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_3
case|:
name|perform
argument_list|(
literal|"KEYPAD3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_4
case|:
name|perform
argument_list|(
literal|"KEYPAD4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_5
case|:
name|perform
argument_list|(
literal|"KEYPAD5"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_6
case|:
name|perform
argument_list|(
literal|"KEYPAD6"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_COMMA
case|:
name|perform
argument_list|(
literal|"KEYPAD,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_7
case|:
name|perform
argument_list|(
literal|"KEYPAD7"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_8
case|:
name|perform
argument_list|(
literal|"KEYPAD8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_9
case|:
name|perform
argument_list|(
literal|"KEYPAD9"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_KEYPAD_MINUS
case|:
name|perform
argument_list|(
literal|"KEYPAD-"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|feep
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*end switch*/
break|break;
case|case
name|CURSOR
case|:
switch|switch
condition|(
name|code
operator|&
name|ValueMask
condition|)
block|{
case|case
name|KC_CURSOR_LEFT
case|:
name|perform
argument_list|(
literal|"LEFTARROW"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_CURSOR_RIGHT
case|:
name|perform
argument_list|(
literal|"RIGHTARROW"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_CURSOR_DOWN
case|:
name|perform
argument_list|(
literal|"DOWNARROW"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KC_CURSOR_UP
case|:
name|perform
argument_list|(
literal|"UPARROW"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|feep
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PFX
case|:
switch|switch
condition|(
name|code
operator|&
name|ValueMask
condition|)
block|{
case|case
name|KC_PF1
case|:
name|perform
argument_list|(
literal|"PF1"
argument_list|)
expr_stmt|;
case|case
name|KC_PF2
case|:
name|perform
argument_list|(
literal|"PF2"
argument_list|)
expr_stmt|;
case|case
name|KC_PF3
case|:
name|perform
argument_list|(
literal|"PF3"
argument_list|)
expr_stmt|;
case|case
name|KC_PF4
case|:
name|perform
argument_list|(
literal|"PF4"
argument_list|)
expr_stmt|;
default|default:
name|feep
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FUNC1
case|:
name|perform
argument_list|(
literal|"FUNC1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC2
case|:
name|perform
argument_list|(
literal|"FUNC2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC3
case|:
name|perform
argument_list|(
literal|"FUNC3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC4
case|:
name|perform
argument_list|(
literal|"FUNC4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC5
case|:
name|perform
argument_list|(
literal|"FUNC5"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC6
case|:
name|perform
argument_list|(
literal|"FUNC6"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC7
case|:
name|perform
argument_list|(
literal|"FUNC7"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC8
case|:
name|perform
argument_list|(
literal|"FUNC8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC9
case|:
name|perform
argument_list|(
literal|"FUNC9"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC10
case|:
name|perform
argument_list|(
literal|"FUNC10"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC11
case|:
name|perform
argument_list|(
literal|"FUNC11"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC12
case|:
name|perform
argument_list|(
literal|"FUNC12"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC13
case|:
name|perform
argument_list|(
literal|"FUNC13"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC14
case|:
name|perform
argument_list|(
literal|"FUNC14"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC15
case|:
name|perform
argument_list|(
literal|"FUNC15"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC16
case|:
name|perform
argument_list|(
literal|"FUNC16"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC17
case|:
name|perform
argument_list|(
literal|"FUNC17"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC18
case|:
name|perform
argument_list|(
literal|"FUNC18"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC19
case|:
name|perform
argument_list|(
literal|"FUNC19"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC20
case|:
name|perform
argument_list|(
literal|"FUNC20"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1
case|:
name|perform
argument_list|(
literal|"E1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E2
case|:
name|perform
argument_list|(
literal|"E2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E3
case|:
name|perform
argument_list|(
literal|"E3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E4
case|:
name|perform
argument_list|(
literal|"E4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E5
case|:
name|perform
argument_list|(
literal|"E5"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E6
case|:
name|perform
argument_list|(
literal|"E6"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* must be ascii */
name|cbuf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|cbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|perform
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*end switch on keycode*/
break|break;
case|case
name|ButtonPressed
case|:
switch|switch
condition|(
name|code
operator|&
name|ValueMask
condition|)
block|{
case|case
name|LeftButton
case|:
name|perform
argument_list|(
literal|"LEFTBUTTON"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MiddleButton
case|:
name|perform
argument_list|(
literal|"MIDDLEBUTTON"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RightButton
case|:
name|perform
argument_list|(
literal|"RIGHTBUTTON"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|feep
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|feep
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/*end switch on event type*/
block|}
comment|/*end while forever getting input events*/
block|}
end_function

begin_comment
comment|/*end main*/
end_comment

begin_comment
comment|/****************************************************************************  * perform - This routine looks in its table to see if it already has a key  * code, else it does an XGetDefault of the keyname.  */
end_comment

begin_expr_stmt
specifier|static
name|perform
argument_list|(
argument|keyname
argument_list|)
name|char
operator|*
name|keyname
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|actionfound
index|[
name|code
index|]
operator|==
name|ACTION_NEW
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"action."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|cp
operator|=
name|XGetDefault
argument_list|(
name|ProgramName
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|actionfound
index|[
name|code
index|]
operator|=
name|ACTION_NOT_FOUND
expr_stmt|;
else|else
block|{
comment|/* else we have to parse the string */
name|parseaction
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*end if we have an action*/
block|}
comment|/*end if we needed to look up an action*/
if|if
condition|(
name|actionfound
index|[
name|code
index|]
operator|==
name|ACTION_FOUND
condition|)
block|{
if|if
condition|(
name|vfork
argument_list|()
operator|==
literal|0
condition|)
comment|/* in child, start program */
name|execvp
argument_list|(
name|actionvector
index|[
name|code
index|]
index|[
literal|0
index|]
argument_list|,
name|actionvector
index|[
name|code
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* in parent, flash icon */
name|flash
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|feep
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_expr_stmt
specifier|static
name|parseaction
argument_list|(
argument|actionstring
argument_list|)
name|char
operator|*
name|actionstring
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|wc
init|=
literal|0
decl_stmt|;
comment|/* word count */
specifier|register
name|int
name|inword
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|actionlist
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|inword
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|actionstring
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
comment|/* iterate over string */
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|inword
condition|)
name|inword
operator|=
literal|0
expr_stmt|;
comment|/* no longer in a word */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|inword
condition|)
block|{
comment|/* weren't in word */
name|inword
operator|=
literal|1
expr_stmt|;
comment|/* but now we are */
name|wc
operator|++
expr_stmt|;
comment|/* so increment counter */
block|}
block|}
block|}
comment|/* wc now contains the number of separate words */
name|actionlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|wc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|actionlist
condition|)
name|Error
argument_list|(
literal|"allocating memory for command list"
argument_list|,
name|actionstring
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|inword
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|actionstring
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|inword
condition|)
block|{
comment|/* were in a word */
name|inword
operator|=
literal|0
expr_stmt|;
comment|/* but now we're not */
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* and null out space */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|inword
condition|)
block|{
comment|/* weren't in a word */
name|inword
operator|=
literal|1
expr_stmt|;
comment|/* but now we are */
name|actionlist
index|[
name|i
operator|++
index|]
operator|=
name|cp
expr_stmt|;
comment|/* store pointer to start of word */
block|}
block|}
block|}
name|actionlist
index|[
name|wc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* execv wants this */
name|actionfound
index|[
name|code
index|]
operator|=
name|ACTION_FOUND
expr_stmt|;
name|actionvector
index|[
name|code
index|]
operator|=
name|actionlist
expr_stmt|;
comment|/* store the action */
return|return;
block|}
end_block

begin_comment
comment|/****************************************************************************  * feep - is designed to alert the user that something went wrong.  It could  * put up a dialog box if it were smart....  */
end_comment

begin_expr_stmt
specifier|static
name|feep
argument_list|()
block|{
name|XFeep
argument_list|(
name|volume
argument_list|)
block|;
name|XFlush
argument_list|()
block|;
return|return;
block|}
end_expr_stmt

begin_comment
comment|/****************************************************************************  * flash - this just flashes the shell box a couple of times  */
end_comment

begin_macro
name|flash
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nflash
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|XPixFill
argument_list|(
name|ShellWindow
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|BlackPixel
argument_list|,
operator|(
name|Bitmap
operator|)
literal|0
argument_list|,
name|GXinvert
argument_list|,
name|AllPlanes
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|delaytime
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_block

end_unit

