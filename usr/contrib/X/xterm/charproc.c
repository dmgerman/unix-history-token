begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright (c) 1985 Massachusetts Institute of Technology		*/
end_comment

begin_comment
comment|/* Copyright (c) 1985	Digital Equipment Corporation			*/
end_comment

begin_comment
comment|/* charproc.c */
end_comment

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|"ptyx.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"chartable.h"
end_include

begin_include
include|#
directive|include
file|"esctable.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_charproc_c
init|=
literal|"$Header: charproc.c,v 10.10 86/02/01 16:05:52 tony Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* CAUTION: getb "knows" that the variable "c" is receiving the result	*/
end_comment

begin_define
define|#
directive|define
name|getb
parameter_list|(
name|buf
parameter_list|)
value|(--buf_cnt>= 0 ? *buf_ptr++:				\ 	((c=fill(buf)), buf_cnt=buf->cnt, buf_ptr=buf->ptr, c))
end_define

begin_define
define|#
directive|define
name|peekb
parameter_list|(
name|buf
parameter_list|)
value|(buf_cnt>  0 ? *buf_ptr  : -1)
end_define

begin_define
define|#
directive|define
name|ANSIflush
parameter_list|()
value|{ arg = flushbuf(screen, term->flags, text_ptr);	\ 			buffermode = 0;					\ 			text_ptr = text_buf;				\ 			text_cnt = TEXT_BUF_SIZE; }
end_define

begin_define
define|#
directive|define
name|TEKflush
parameter_list|()
value|{	arg = TekFlushBuf(term, text_ptr);	\ 				buffermode = 0;				\ 				text_ptr = text_buf;			\ 				text_cnt = TEXT_BUF_SIZE;		\ 			}
end_define

begin_define
define|#
directive|define
name|TEXT_BUF_SIZE
value|256
end_define

begin_decl_stmt
specifier|extern
name|TekLink
modifier|*
name|tb_end_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tb_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|text_buf
index|[
name|TEXT_BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|nri
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|nlf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ctotal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ntotal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * in normal mode, buffer up as large a string of printing characters  * as possible before flushing the buffer.  buffer up LF's and RI's  * so these can be processed as a block.  */
end_comment

begin_macro
name|ANSInormal
argument_list|(
argument|term
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|text_ptr
decl_stmt|;
specifier|register
name|int
name|text_cnt
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|buf_ptr
decl_stmt|;
specifier|register
name|int
name|buf_cnt
decl_stmt|;
specifier|register
name|unsigned
name|buffermode
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|trmbuf
init|=
operator|&
name|term
operator|->
name|buf
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|buffermode
operator|=
literal|0
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|=
name|text_buf
expr_stmt|;
name|text_cnt
operator|=
name|TEXT_BUF_SIZE
expr_stmt|;
name|buf_cnt
operator|=
name|trmbuf
operator|->
name|cnt
expr_stmt|;
name|buf_ptr
operator|=
name|trmbuf
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|TekGMode
operator|||
name|screen
operator|->
name|TekAMode
condition|)
return|return
operator|(
name|TekMode
argument_list|(
name|term
argument_list|)
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * if special condition has occurred, c will already 		 * be set to EOF.  otherwise, pick up a new char. 		 */
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|c
operator|=
name|getb
argument_list|(
name|trmbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctable
index|[
name|c
index|]
operator|==
name|CPRINTING
condition|)
block|{
name|buffermode
operator|=
name|BUFFER_MODE
expr_stmt|;
if|if
condition|(
operator|--
name|text_cnt
operator|>=
literal|0
condition|)
operator|*
name|text_ptr
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|ANSIflush
argument_list|()
expr_stmt|;
operator|--
name|text_cnt
operator|,
operator|*
name|text_ptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
continue|continue;
block|}
switch|switch
condition|(
name|ctable
index|[
name|c
index|]
condition|)
block|{
case|case
name|CIGNORE
case|:
break|break;
case|case
name|CLINEFEED
case|:
if|if
condition|(
name|buffermode
operator|||
name|nri
condition|)
block|{
name|ANSIflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
operator|++
name|nlf
expr_stmt|;
break|break;
case|case
name|CRETURN
case|:
if|if
condition|(
name|buffermode
condition|)
block|{
name|ANSIflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
name|screen
operator|->
name|cur_col
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CRI
case|:
name|RI_kluge
label|:
if|if
condition|(
name|buffermode
operator|||
name|nlf
condition|)
block|{
name|ANSIflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
operator|++
name|nri
expr_stmt|;
break|break;
case|case
name|FLUSH
case|:
name|ANSIflush
argument_list|()
expr_stmt|;
name|trmbuf
operator|->
name|cnt
operator|=
name|buf_cnt
expr_stmt|;
name|trmbuf
operator|->
name|ptr
operator|=
name|buf_ptr
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
case|case
name|CESC
case|:
comment|/* try to intercept RI's so we can buffer them	*/
if|if
condition|(
name|peekb
argument_list|(
name|trmbuf
argument_list|)
operator|==
literal|'M'
condition|)
block|{
name|c
operator|=
name|getb
argument_list|(
name|trmbuf
argument_list|)
expr_stmt|;
goto|goto
name|RI_kluge
goto|;
block|}
comment|/* no RI detected; fall into default case	*/
default|default:
name|ANSIflush
argument_list|()
expr_stmt|;
name|docontrol
argument_list|(
name|term
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* 			 * if mode changes or event occurs, force a 			 * cleanup and return by setting char to EOF 			 */
if|if
condition|(
name|arg
operator|||
name|screen
operator|->
name|mode
operator|!=
name|ANSInormal
operator|||
name|screen
operator|->
name|TekGMode
operator|||
name|screen
operator|->
name|TekAMode
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * flush the buffer of printing characters.  first, process any LF's or  * RI's that have been buffered.  */
end_comment

begin_expr_stmt
name|flushbuf
argument_list|(
name|screen
argument_list|,
name|flags
argument_list|,
name|text_ptr
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|char
modifier|*
name|text_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|arg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nri
operator|!=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|screen
operator|->
name|display
operator|->
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|RevIndex
argument_list|(
name|screen
argument_list|,
name|nri
argument_list|)
expr_stmt|;
name|nri
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nlf
operator|!=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|screen
operator|->
name|display
operator|->
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|Index
argument_list|(
name|screen
argument_list|,
name|nlf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LINEFEED
condition|)
block|{
comment|/* do a carriage return	*/
name|screen
operator|->
name|cur_col
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
block|}
name|nlf
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|text_buf
expr_stmt|;
comment|/* 	 * if a single shift is in effect, process  	 * the one character it affects. 	 */
if|if
condition|(
name|screen
operator|->
name|curss
operator|!=
literal|0
operator|&&
name|s
operator|<
name|text_ptr
condition|)
block|{
name|dotext
argument_list|(
name|screen
argument_list|,
name|flags
argument_list|,
name|screen
operator|->
name|gsets
index|[
name|screen
operator|->
name|curss
index|]
argument_list|,
name|s
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
name|screen
operator|->
name|curss
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * characters with and without the high bit set must be processed 	 * separately (they select different character sets).  collect them 	 * into groups before processing for as much efficiency as possible. 	 */
while|while
condition|(
name|s
operator|<
name|text_ptr
condition|)
block|{
name|p
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|<
literal|0x80
condition|)
block|{
comment|/* character doesn't have high bit set	*/
while|while
condition|(
operator|*
name|s
operator|<
literal|0x80
operator|&&
name|s
operator|<
name|text_ptr
condition|)
operator|++
name|s
expr_stmt|;
name|dotext
argument_list|(
name|screen
argument_list|,
name|flags
argument_list|,
name|screen
operator|->
name|gsets
index|[
name|screen
operator|->
name|curgl
index|]
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* character has high bit set		*/
while|while
condition|(
operator|*
name|s
operator|>=
literal|0x80
operator|&&
name|s
operator|<
name|text_ptr
condition|)
block|{
operator|*
name|s
operator|&=
literal|0x7f
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|dotext
argument_list|(
name|screen
argument_list|,
name|flags
argument_list|,
name|screen
operator|->
name|gsets
index|[
name|screen
operator|->
name|curgr
index|]
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|arg
operator|||
name|screen
operator|->
name|display
operator|->
name|qlen
operator|!=
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * process a string of characters according to the character set indicated  * by charset.  worry about end of line conditions (wraparound if selected).  */
end_comment

begin_expr_stmt
name|dotext
argument_list|(
name|screen
argument_list|,
name|flags
argument_list|,
name|charset
argument_list|,
name|buf
argument_list|,
name|ptr
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|charset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|next_col
decl_stmt|;
switch|switch
condition|(
name|charset
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* United Kingdom set				*/
for|for
control|(
name|s
operator|=
name|buf
init|;
name|s
operator|<
name|ptr
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
operator|*
name|s
operator|=
literal|'\036'
expr_stmt|;
comment|/* UK pound sign	*/
break|break;
case|case
literal|'B'
case|:
comment|/* ASCII set					*/
break|break;
case|case
literal|'0'
case|:
comment|/* special graphics (line drawing)		*/
for|for
control|(
name|s
operator|=
name|buf
init|;
name|s
operator|<
name|ptr
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|>=
literal|0x5f
operator|&&
operator|*
name|s
operator|<=
literal|0x7e
condition|)
operator|*
name|s
operator|=
operator|*
name|s
operator|-
literal|0x5f
expr_stmt|;
break|break;
default|default:
comment|/* any character sets we don't recognize	*/
return|return;
block|}
name|len
operator|=
name|ptr
operator|-
name|buf
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|screen
operator|->
name|max_col
operator|-
name|screen
operator|->
name|cur_col
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|do_wrap
operator|&&
operator|(
name|flags
operator|&
name|WRAPAROUND
operator|)
condition|)
block|{
name|Index
argument_list|(
name|screen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|screen
operator|->
name|cur_col
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|do_wrap
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|screen
operator|->
name|max_col
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
name|n
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|next_col
operator|=
name|screen
operator|->
name|cur_col
operator|+
name|n
expr_stmt|;
name|WriteText
argument_list|(
name|screen
argument_list|,
name|ptr
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * the call to WriteText updates screen->cur_col. 		 * If screen->cur_col != next_col, we must have 		 * hit the right margin, so set the do_wrap flag. 		 */
name|screen
operator|->
name|do_wrap
operator|=
operator|(
name|screen
operator|->
name|cur_col
operator|<
name|next_col
operator|)
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
name|ptr
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * write a string str of length len onto the screen at  * the current cursor position.  update cursor position.  */
end_comment

begin_expr_stmt
name|WriteText
argument_list|(
name|screen
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
specifier|register
name|Screen
operator|*
name|screen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Font
name|fnt
decl_stmt|;
name|fnt
operator|=
operator|(
name|flags
operator|&
name|BOLD
condition|?
name|screen
operator|->
name|fnt_bold
else|:
name|screen
operator|->
name|fnt_norm
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INSERT
condition|)
name|InsertChar
argument_list|(
name|screen
argument_list|,
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
operator|!
operator|(
name|AddToRefresh
argument_list|(
name|screen
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
if|if
condition|(
name|flags
operator|&
name|INVERSE
condition|)
name|XText
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|fnt
argument_list|,
name|screen
operator|->
name|background
argument_list|,
name|screen
operator|->
name|foreground
argument_list|)
expr_stmt|;
else|else
name|XText
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|CursorX
argument_list|(
name|screen
argument_list|)
argument_list|,
name|CursorY
argument_list|(
name|screen
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|fnt
argument_list|,
name|screen
operator|->
name|foreground
argument_list|,
name|screen
operator|->
name|background
argument_list|)
expr_stmt|;
comment|/* 	 * the following statements compile data to compute the average  	 * number of characters written on each call to XText.  The data 	 * may be examined via the use of a "hidden" escape sequence. 	 */
name|ctotal
operator|+=
name|len
expr_stmt|;
operator|++
name|ntotal
expr_stmt|;
ifdef|#
directive|ifdef
name|JUMPSCROLL
block|}
endif|#
directive|endif
endif|JUMPSCROLL
name|ScreenWrite
argument_list|(
name|screen
argument_list|,
name|str
argument_list|,
name|flags
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CursorForward
argument_list|(
name|screen
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * in Tek mode (graphics or alpha), buffer up as large a string of printing  * characters as possible before flushing buffer.  in graphics mode the  * characters are plotted, in alpha mode they are printed.  */
end_comment

begin_macro
name|TekMode
argument_list|(
argument|term
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|text_ptr
decl_stmt|;
specifier|register
name|int
name|text_cnt
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|buf_ptr
decl_stmt|;
specifier|register
name|int
name|buf_cnt
decl_stmt|;
specifier|register
name|unsigned
name|buffermode
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|trmbuf
init|=
operator|&
name|term
operator|->
name|buf
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|buffermode
operator|=
literal|0
expr_stmt|;
name|text_ptr
operator|=
name|text_buf
expr_stmt|;
name|text_cnt
operator|=
name|TEXT_BUF_SIZE
expr_stmt|;
name|buf_cnt
operator|=
name|trmbuf
operator|->
name|cnt
expr_stmt|;
name|buf_ptr
operator|=
name|trmbuf
operator|->
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * if special condition has occurred, c will already 		 * be set to EOF.  otherwise, pick up a new char. 		 */
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|c
operator|=
name|getb
argument_list|(
name|trmbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|c
operator|&=
literal|0x7f
expr_stmt|;
if|if
condition|(
name|ctable
index|[
name|c
index|]
operator|==
name|CPRINTING
operator|||
operator|(
name|c
operator|==
name|DEL
operator|&&
name|screen
operator|->
name|TekGMode
operator|)
condition|)
block|{
name|buffermode
operator|=
name|BUFFER_MODE
expr_stmt|;
if|if
condition|(
operator|--
name|text_cnt
operator|>=
literal|0
condition|)
operator|*
name|text_ptr
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|TEKflush
argument_list|()
expr_stmt|;
operator|--
name|text_cnt
operator|,
operator|*
name|text_ptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
continue|continue;
block|}
switch|switch
condition|(
name|ctable
index|[
name|c
index|]
condition|)
block|{
case|case
name|CIGNORE
case|:
break|break;
case|case
name|CTEKINIT
case|:
if|if
condition|(
name|buffermode
condition|)
name|TEKflush
argument_list|()
expr_stmt|;
name|TekInit
argument_list|(
name|term
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
break|break;
case|case
name|FLUSH
case|:
name|TEKflush
argument_list|()
expr_stmt|;
name|trmbuf
operator|->
name|cnt
operator|=
name|buf_cnt
expr_stmt|;
name|trmbuf
operator|->
name|ptr
operator|=
name|buf_ptr
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
default|default:
comment|/* BEL, BS, HT, LF, VT, FF, CR, ESC, US	*/
comment|/* and also SI, SO, CAN, SUB		*/
name|TEKflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|TekGMode
condition|)
name|TekAlph
argument_list|(
name|term
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|docontrol
argument_list|(
name|term
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* 			 * if mode changes or event occurs, force a 			 * cleanup and return by setting char to EOF 			 */
if|if
condition|(
name|arg
operator|||
name|screen
operator|->
name|mode
operator|!=
name|ANSInormal
operator|||
operator|(
name|screen
operator|->
name|TekGMode
operator|==
literal|0
operator|&&
name|screen
operator|->
name|TekAMode
operator|==
literal|0
operator|)
condition|)
name|c
operator|=
name|EOF
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * flush the buffer of printing characters.  * use TekString, TekPoint, or TekPlot according to current mode.  */
end_comment

begin_macro
name|TekFlushBuf
argument_list|(
argument|term
argument_list|,
argument|text_ptr
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|char
modifier|*
name|text_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|text_buf
expr_stmt|;
if|if
condition|(
name|text_ptr
operator|!=
name|text_buf
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|TekGMode
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|TekIMode
condition|)
while|while
condition|(
name|s
operator|<
name|text_ptr
condition|)
block|{
name|TekBufPut
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|TekPoint
argument_list|(
name|term
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|s
operator|<
name|text_ptr
condition|)
block|{
name|TekBufPut
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|TekPlot
argument_list|(
name|term
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|TekString
argument_list|(
name|term
argument_list|,
name|text_buf
argument_list|,
name|text_ptr
operator|-
name|text_buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|screen
operator|->
name|display
operator|->
name|qlen
operator|!=
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * a string (DCS, OSC, PM, APC) has been encountered in ANSI mode.  * all printing characters are ignored until a string terminator  * is seen (other possible exits are CAN, SUB, ESC, and C1 controls).  */
end_comment

begin_macro
name|ANSIstring
argument_list|(
argument|term
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|trmbuf
init|=
operator|&
name|term
operator|->
name|buf
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|buf_ptr
decl_stmt|;
specifier|register
name|int
name|buf_cnt
decl_stmt|;
name|buf_cnt
operator|=
name|trmbuf
operator|->
name|cnt
expr_stmt|;
name|buf_ptr
operator|=
name|trmbuf
operator|->
name|ptr
expr_stmt|;
while|while
condition|(
name|screen
operator|->
name|mode
operator|==
name|ANSIstring
operator|&&
name|screen
operator|->
name|display
operator|->
name|qlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getb
argument_list|(
name|trmbuf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|c
operator|=
name|parseseq
argument_list|(
name|c
argument_list|,
operator|&
name|screen
operator|->
name|ansi
argument_list|,
name|screen
operator|->
name|TekEmu
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ctable
index|[
name|c
index|]
condition|)
block|{
case|case
name|CIGNORE
case|:
case|case
name|CPRINTING
case|:
break|break;
case|case
name|CESC
case|:
case|case
name|CCSI
case|:
name|screen
operator|->
name|mode
operator|=
name|ANSInormal
expr_stmt|;
name|procseq
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDCS
case|:
name|screen
operator|->
name|mode
operator|=
name|ANSIstring
expr_stmt|;
name|procseq
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
name|CCANCEL
case|:
name|screen
operator|->
name|mode
operator|=
name|ANSInormal
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|trmbuf
operator|->
name|cnt
operator|=
name|buf_cnt
expr_stmt|;
name|trmbuf
operator|->
name|ptr
operator|=
name|buf_ptr
expr_stmt|;
return|return
operator|(
name|screen
operator|->
name|display
operator|->
name|qlen
operator|!=
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * call parseseq with each new character until the sequence has been  * parsed.  once parsed, call procseq to process the sequence.  DEC  * standard says C0 controls in the middle of a sequence are acted  * on just as if they weren't in the middle of a sequence (ANSI says  * this is an error condition, but as always doesn't specify how to  * handle the error).  */
end_comment

begin_macro
name|ANSIparse
argument_list|(
argument|term
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|ch
decl_stmt|;
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|trmbuf
init|=
operator|&
name|term
operator|->
name|buf
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|buf_ptr
decl_stmt|;
specifier|register
name|int
name|buf_cnt
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|buf_cnt
operator|=
name|trmbuf
operator|->
name|cnt
expr_stmt|;
name|buf_ptr
operator|=
name|trmbuf
operator|->
name|ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * if special condition has occurred, c will already 		 * be set to EOF.  otherwise, pick up a new char. 		 */
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|c
operator|=
name|getb
argument_list|(
name|trmbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|trmbuf
operator|->
name|cnt
operator|=
name|buf_cnt
expr_stmt|;
name|trmbuf
operator|->
name|ptr
operator|=
name|buf_ptr
expr_stmt|;
return|return
operator|(
name|screen
operator|->
name|display
operator|->
name|qlen
operator|!=
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
name|parseseq
argument_list|(
name|c
argument_list|,
operator|&
name|screen
operator|->
name|ansi
argument_list|,
name|screen
operator|->
name|TekEmu
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ctable
index|[
name|ch
index|]
condition|)
block|{
case|case
name|CIGNORE
case|:
break|break;
case|case
name|CESC
case|:
case|case
name|CCSI
case|:
name|screen
operator|->
name|mode
operator|=
name|ANSInormal
expr_stmt|;
name|procseq
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDCS
case|:
name|screen
operator|->
name|mode
operator|=
name|ANSIstring
expr_stmt|;
name|procseq
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
default|default:
name|docontrol
argument_list|(
name|term
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * if mode changes or event occurs, force a 			 * cleanup and return by setting char to EOF 			 */
if|if
condition|(
name|screen
operator|->
name|mode
operator|!=
name|ANSIparse
operator|||
name|screen
operator|->
name|ansi
operator|.
name|a_type
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|EOF
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|mode
operator|==
name|ANSIparse
condition|)
name|screen
operator|->
name|mode
operator|=
name|ANSInormal
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_type
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_pintro
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_final
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|screen
operator|->
name|display
operator|->
name|qlen
operator|!=
literal|0
condition|)
empty_stmt|;
name|c
operator|=
name|EOF
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * some sort of ANSI sequence has been parsed.  look through the   * esctable to look for a match.  if found, apply default parameters  * and dispatch.  */
end_comment

begin_macro
name|procseq
argument_list|(
argument|term
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ANSI
modifier|*
name|ap
init|=
operator|&
name|term
operator|->
name|screen
operator|.
name|ansi
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
modifier|*
name|p
decl_stmt|;
specifier|register
name|long
name|a_funct
decl_stmt|;
define|#
directive|define
name|SEQKEY
value|p[0]
comment|/* type, private,& final in a long	*/
define|#
directive|define
name|INTERS
value|p[1]
comment|/* intermediate(s) in a long		*/
define|#
directive|define
name|SEQTYPE
value|p[2]
comment|/* sequence type (dispatch value)	*/
define|#
directive|define
name|NDEFLT
value|p[3]
comment|/* number of default parameters		*/
define|#
directive|define
name|DEFAULT
parameter_list|(
name|n
parameter_list|)
value|p[4+n]
comment|/* the n'th default parameter (0 origin)*/
define|#
directive|define
name|FIXEDLEN
value|4
comment|/* fixed (min) length of table entries	*/
comment|/* 	 * just return if any error encountered 	 */
if|if
condition|(
name|ap
operator|->
name|a_nastyf
operator|!=
literal|0
condition|)
return|return;
name|a_funct
operator|=
operator|(
name|ap
operator|->
name|a_final
operator|<<
literal|16
operator|)
operator||
operator|(
name|ap
operator|->
name|a_pintro
operator|<<
literal|8
operator|)
operator||
name|ap
operator|->
name|a_type
expr_stmt|;
comment|/* 	 * step through table, looking for an 	 * entry which matches the current sequence. 	 */
for|for
control|(
name|p
operator|=
name|esctable
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|+=
name|NDEFLT
operator|+
name|FIXEDLEN
control|)
block|{
if|if
condition|(
name|SEQKEY
operator|==
name|a_funct
operator|&&
operator|(
name|INTERS
operator|==
name|ap
operator|->
name|a_inters
operator|||
name|INTERS
operator|==
name|WILD
operator|)
condition|)
block|{
comment|/* 			 * we have a match. 			 * get default values from table. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDEFLT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_dflt
index|[
name|i
index|]
operator|||
name|i
operator|>=
name|ap
operator|->
name|a_nparam
condition|)
name|ap
operator|->
name|a_param
index|[
name|i
index|]
operator|=
name|DEFAULT
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_nparam
operator|<
name|NDEFLT
condition|)
name|ap
operator|->
name|a_nparam
operator|=
name|NDEFLT
expr_stmt|;
comment|/* 			 * ready to process the sequence. 			 */
name|doescape
argument_list|(
name|term
argument_list|,
name|SEQTYPE
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * this is a big switch of all the ANSI (and other) sequences  * we know how to handle.  the cases of the switch must  * have a corresponding entry in the esctable.  */
end_comment

begin_macro
name|doescape
argument_list|(
argument|term
argument_list|,
argument|kind
argument_list|,
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|kind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ANSI
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|row
operator|,
name|col
expr_stmt|;
specifier|register
name|i
operator|,
name|top
operator|,
name|bot
expr_stmt|;
name|ANSI
name|reply
decl_stmt|;
name|int
name|bitset
argument_list|()
decl_stmt|,
name|bitclr
argument_list|()
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|text_ptr
decl_stmt|;
specifier|register
name|int
name|text_cnt
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|DECKPAM
case|:
name|term
operator|->
name|keyboard
operator|.
name|flags
operator||=
name|KYPD_APL
expr_stmt|;
break|break;
case|case
name|DECKPNM
case|:
name|term
operator|->
name|keyboard
operator|.
name|flags
operator|&=
operator|~
name|KYPD_APL
expr_stmt|;
break|break;
case|case
name|DECTC1
case|:
name|screen
operator|->
name|rx8bit
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DECSC
case|:
name|screen
operator|->
name|sc
operator|.
name|row
operator|=
name|screen
operator|->
name|cur_row
expr_stmt|;
name|screen
operator|->
name|sc
operator|.
name|col
operator|=
name|screen
operator|->
name|cur_col
expr_stmt|;
name|screen
operator|->
name|sc
operator|.
name|flags
operator|=
name|term
operator|->
name|flags
expr_stmt|;
break|break;
case|case
name|DECAC1
case|:
name|screen
operator|->
name|rx8bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|S7C1T
case|:
name|screen
operator|->
name|tx8bit
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|S8C1T
case|:
name|screen
operator|->
name|tx8bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DECRC
case|:
name|term
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BOLD
operator||
name|INVERSE
operator|)
expr_stmt|;
name|term
operator|->
name|flags
operator||=
name|screen
operator|->
name|sc
operator|.
name|flags
operator|&
operator|(
name|BOLD
operator||
name|INVERSE
operator|)
expr_stmt|;
name|CursorSet
argument_list|(
name|screen
argument_list|,
name|screen
operator|->
name|sc
operator|.
name|row
argument_list|,
name|screen
operator|->
name|sc
operator|.
name|col
argument_list|,
name|term
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|LS2
case|:
name|screen
operator|->
name|curgl
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LS3
case|:
name|screen
operator|->
name|curgl
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|LS3R
case|:
name|screen
operator|->
name|curgr
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|LS2R
case|:
name|screen
operator|->
name|curgr
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LS1R
case|:
name|screen
operator|->
name|curgr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DESIGNATE
case|:
switch|switch
condition|(
name|ap
operator|->
name|a_inters
condition|)
block|{
case|case
literal|'('
case|:
name|screen
operator|->
name|gsets
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|a_final
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|screen
operator|->
name|gsets
index|[
literal|1
index|]
operator|=
name|ap
operator|->
name|a_final
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|screen
operator|->
name|gsets
index|[
literal|2
index|]
operator|=
name|ap
operator|->
name|a_final
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|screen
operator|->
name|gsets
index|[
literal|3
index|]
operator|=
name|ap
operator|->
name|a_final
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* special "hidden" sequence	*/
if|if
condition|(
name|ap
operator|->
name|a_final
operator|==
literal|'1'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"avg call = %d char\n"
argument_list|,
name|ctotal
operator|/
name|ntotal
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
break|break;
case|case
name|DA1
case|:
if|if
condition|(
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|reply
operator|.
name|a_type
operator|=
name|CSI
expr_stmt|;
name|reply
operator|.
name|a_pintro
operator|=
literal|'?'
expr_stmt|;
name|reply
operator|.
name|a_nparam
operator|=
literal|1
expr_stmt|;
name|reply
operator|.
name|a_param
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
comment|/* VT102	*/
name|reply
operator|.
name|a_inters
operator|=
literal|0
expr_stmt|;
name|reply
operator|.
name|a_final
operator|=
literal|'c'
expr_stmt|;
name|unparseseq
argument_list|(
operator|&
name|reply
argument_list|,
name|screen
operator|->
name|tx8bit
argument_list|,
name|screen
operator|->
name|respond
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TBC
case|:
if|if
condition|(
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|TabClear
argument_list|(
name|term
operator|->
name|tabs
argument_list|,
name|screen
operator|->
name|cur_col
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
operator|==
literal|3
condition|)
name|TabZonk
argument_list|(
name|term
operator|->
name|tabs
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|modes
argument_list|(
name|term
argument_list|,
name|bitset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECSET
case|:
name|dpmodes
argument_list|(
name|term
argument_list|,
name|bitset
argument_list|)
expr_stmt|;
break|break;
case|case
name|RST
case|:
name|modes
argument_list|(
name|term
argument_list|,
name|bitclr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECRST
case|:
name|dpmodes
argument_list|(
name|term
argument_list|,
name|bitclr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|a_nparam
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_param
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0
case|:
name|term
operator|->
name|flags
operator|&=
operator|~
operator|(
name|INVERSE
operator||
name|BOLD
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|4
case|:
comment|/* Underscore, really	*/
case|case
literal|5
case|:
comment|/* Blink, really.	*/
name|term
operator|->
name|flags
operator||=
name|BOLD
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|term
operator|->
name|flags
operator||=
name|INVERSE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CPR
case|:
if|if
condition|(
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
operator|==
literal|5
condition|)
block|{
name|reply
operator|.
name|a_type
operator|=
name|CSI
expr_stmt|;
name|reply
operator|.
name|a_pintro
operator|=
literal|0
expr_stmt|;
name|reply
operator|.
name|a_nparam
operator|=
literal|1
expr_stmt|;
name|reply
operator|.
name|a_param
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|reply
operator|.
name|a_inters
operator|=
literal|0
expr_stmt|;
name|reply
operator|.
name|a_final
operator|=
literal|'n'
expr_stmt|;
name|unparseseq
argument_list|(
operator|&
name|reply
argument_list|,
name|screen
operator|->
name|tx8bit
argument_list|,
name|screen
operator|->
name|respond
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
operator|==
literal|6
condition|)
block|{
name|reply
operator|.
name|a_type
operator|=
name|CSI
expr_stmt|;
name|reply
operator|.
name|a_pintro
operator|=
literal|0
expr_stmt|;
name|reply
operator|.
name|a_nparam
operator|=
literal|2
expr_stmt|;
name|reply
operator|.
name|a_param
index|[
literal|0
index|]
operator|=
name|screen
operator|->
name|cur_row
operator|+
literal|1
expr_stmt|;
name|reply
operator|.
name|a_param
index|[
literal|1
index|]
operator|=
name|screen
operator|->
name|cur_col
operator|+
literal|1
expr_stmt|;
name|reply
operator|.
name|a_inters
operator|=
literal|0
expr_stmt|;
name|reply
operator|.
name|a_final
operator|=
literal|'R'
expr_stmt|;
name|unparseseq
argument_list|(
operator|&
name|reply
argument_list|,
name|screen
operator|->
name|tx8bit
argument_list|,
name|screen
operator|->
name|respond
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DECSTBM
case|:
name|top
operator|=
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
expr_stmt|;
name|bot
operator|=
name|ap
operator|->
name|a_param
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|top
operator|<
literal|1
condition|)
name|top
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bot
operator|>
name|screen
operator|->
name|max_row
operator|+
literal|1
condition|)
name|bot
operator|=
name|screen
operator|->
name|max_row
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bot
operator|>
name|top
condition|)
block|{
ifdef|#
directive|ifdef
name|JUMPSCROLL
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|JUMPSCROLL
name|screen
operator|->
name|top_marg
operator|=
name|top
operator|-
literal|1
expr_stmt|;
name|screen
operator|->
name|bot_marg
operator|=
name|bot
operator|-
literal|1
expr_stmt|;
name|CursorSet
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|term
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ICH
case|:
name|InsertChar
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CUU
case|:
name|CursorUp
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CUD
case|:
name|CursorDown
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CUF
case|:
name|CursorForward
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CUB
case|:
name|CursorBack
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|HVP
case|:
case|case
name|CUP
case|:
name|row
operator|=
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
expr_stmt|;
name|col
operator|=
name|ap
operator|->
name|a_param
index|[
literal|1
index|]
expr_stmt|;
name|screen
operator|->
name|cur_x
operator|=
name|screen
operator|->
name|cur_y
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|TekAMode
operator|=
literal|0
expr_stmt|;
name|CursorSet
argument_list|(
name|screen
argument_list|,
name|row
operator|-
literal|1
argument_list|,
name|col
operator|-
literal|1
argument_list|,
name|term
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ED
case|:
switch|switch
condition|(
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|ClearBelow
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ClearAbove
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ClearScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|TekEmu
condition|)
name|TekErase
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EL
case|:
switch|switch
condition|(
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|ClearRight
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ClearLeft
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ClearLine
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IL
case|:
name|InsertLine
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DL
case|:
name|DeleteLine
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DCH
case|:
name|DeleteChar
argument_list|(
name|screen
argument_list|,
name|ap
operator|->
name|a_param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECALN
case|:
name|text_ptr
operator|=
name|text_buf
expr_stmt|;
name|text_cnt
operator|=
name|TEXT_BUF_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|--
name|text_cnt
operator|>=
literal|0
condition|)
operator|*
name|text_ptr
operator|++
operator|=
name|i
expr_stmt|;
else|else
block|{
name|flushbuf
argument_list|(
name|screen
argument_list|,
name|term
operator|->
name|flags
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
name|text_ptr
operator|=
name|text_buf
expr_stmt|;
name|text_cnt
operator|=
name|TEXT_BUF_SIZE
operator|-
literal|1
expr_stmt|;
operator|*
name|text_ptr
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
name|flushbuf
argument_list|(
name|screen
argument_list|,
name|term
operator|->
name|flags
argument_list|,
name|text_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEKESCFF
case|:
case|case
name|TEKCSIUS
case|:
name|CursorSet
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|term
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ClearScreen
argument_list|(
name|screen
argument_list|)
expr_stmt|;
name|TekErase
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEKESCSUB
case|:
name|TekCursor
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEKESCINQ
case|:
name|TekInq
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Panic
argument_list|(
literal|"unexpected dispatch (%d) encountered in doescape"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * this is a big switch of all the control characters we know how to handle.  * the cases of the switch have a corresponding entry in the ctable.  */
end_comment

begin_macro
name|docontrol
argument_list|(
argument|term
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
switch|switch
condition|(
name|ctable
index|[
name|c
index|]
condition|)
block|{
case|case
name|CIGNORE
case|:
break|break;
case|case
name|CBELL
case|:
name|XFeep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBACKSPACE
case|:
name|CursorBack
argument_list|(
name|screen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTAB
case|:
name|screen
operator|->
name|cur_col
operator|=
name|TabNext
argument_list|(
name|term
operator|->
name|tabs
argument_list|,
name|screen
operator|->
name|cur_col
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|cur_col
operator|>
name|screen
operator|->
name|max_col
condition|)
name|screen
operator|->
name|cur_col
operator|=
name|screen
operator|->
name|max_col
expr_stmt|;
break|break;
case|case
name|CLINEFEED
case|:
comment|/* actually both VT and LF map here	*/
case|case
name|CFORMFEED
case|:
if|if
condition|(
name|screen
operator|->
name|TekAMode
condition|)
name|TekReset
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|Index
argument_list|(
name|screen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|->
name|flags
operator|&
name|LINEFEED
condition|)
name|CarriageReturn
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRETURN
case|:
if|if
condition|(
name|screen
operator|->
name|TekAMode
condition|)
name|TekReset
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|CarriageReturn
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLS1
case|:
name|screen
operator|->
name|curgl
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CLS0
case|:
name|screen
operator|->
name|curgl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CCANCEL
case|:
name|screen
operator|->
name|mode
operator|=
name|ANSInormal
expr_stmt|;
break|break;
case|case
name|CESC
case|:
case|case
name|CDCS
case|:
case|case
name|CCSI
case|:
name|screen
operator|->
name|ansi
operator|.
name|a_type
operator|=
name|c
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_pintro
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_final
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_inters
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_nparam
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|ansi
operator|.
name|a_nastyf
operator|=
literal|0
expr_stmt|;
name|screen
operator|->
name|mode
operator|=
name|ANSIparse
expr_stmt|;
break|break;
case|case
name|CTEKINIT
case|:
comment|/* come here from FS, GS, or RS		*/
if|if
condition|(
name|screen
operator|->
name|TekEmu
condition|)
name|TekInit
argument_list|(
name|term
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTEKALPH
case|:
comment|/* US					*/
break|break;
comment|/* just ignore; can only get to alpha	*/
comment|/* mode from Tek graphics mode		*/
case|case
name|CIND
case|:
name|Index
argument_list|(
name|screen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNEL
case|:
name|Index
argument_list|(
name|screen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CarriageReturn
argument_list|(
name|screen
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRI
case|:
name|RevIndex
argument_list|(
name|screen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CSS2
case|:
name|screen
operator|->
name|curss
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CSS3
case|:
name|screen
operator|->
name|curss
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|Panic
argument_list|(
literal|"unexpected char (0x%x) encountered in docontrol"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * process ANSI modes set, reset  */
end_comment

begin_macro
name|modes
argument_list|(
argument|term
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|ANSI
modifier|*
name|ansi
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ansi
operator|=
operator|&
name|screen
operator|->
name|ansi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ansi
operator|->
name|a_nparam
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|ansi
operator|->
name|a_param
index|[
name|i
index|]
condition|)
block|{
case|case
literal|4
case|:
comment|/* IRM				*/
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|term
operator|->
name|flags
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|20
case|:
comment|/* LNM				*/
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|term
operator|->
name|flags
argument_list|,
name|LINEFEED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * process DEC private modes set, reset  */
end_comment

begin_macro
name|dpmodes
argument_list|(
argument|term
argument_list|,
argument|func
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
specifier|register
name|ANSI
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ap
operator|=
operator|&
name|screen
operator|->
name|ansi
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|a_nparam
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_param
index|[
name|i
index|]
condition|)
block|{
case|case
literal|1
case|:
comment|/* DECCKM			*/
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|term
operator|->
name|keyboard
operator|.
name|flags
argument_list|,
name|CURSOR_APL
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|JUMPSCROLL
case|case
literal|4
case|:
comment|/* DECSCLM (slow scroll)	*/
if|if
condition|(
name|func
operator|==
name|bitset
condition|)
block|{
name|screen
operator|->
name|jumpscroll
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|scroll_amt
condition|)
name|FlushScroll
argument_list|(
name|screen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|screen
operator|->
name|TekEmu
condition|)
name|screen
operator|->
name|jumpscroll
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|term
operator|->
name|flags
argument_list|,
name|SMOOTHSCROLL
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|JUMPSCROLL
case|case
literal|5
case|:
comment|/* DECSCNM			*/
name|i
operator|=
name|term
operator|->
name|flags
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|term
operator|->
name|flags
argument_list|,
name|REVERSE_VIDEO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|term
operator|->
name|flags
operator|^
name|i
operator|)
operator|&
name|REVERSE_VIDEO
condition|)
name|ReverseVideo
argument_list|(
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* DECOM			*/
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|term
operator|->
name|flags
argument_list|,
name|ORIGIN
argument_list|)
expr_stmt|;
name|CursorSet
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|term
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* DECAWM			*/
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|term
operator|->
name|flags
argument_list|,
name|WRAPAROUND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* MIT bogus sequence		*/
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|screen
operator|->
name|send_mouse_pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|38
case|:
comment|/* DECTEK			*/
call|(
modifier|*
name|func
call|)
argument_list|(
operator|&
name|screen
operator|->
name|TekEmu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * probably need to do some work here to get 			 * into or out of Tek emulation cleanly 			 */
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * set a bit in a word given a pointer to the word and a mask.  */
end_comment

begin_macro
name|bitset
argument_list|(
argument|p
argument_list|,
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|p
operator||=
name|mask
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * clear a bit in a word given a pointer to the word and a mask.  */
end_comment

begin_macro
name|bitclr
argument_list|(
argument|p
argument_list|,
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|p
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
end_block

begin_macro
name|ReverseVideo
argument_list|(
argument|term
argument_list|)
end_macro

begin_decl_stmt
name|Terminal
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Screen
modifier|*
name|screen
init|=
operator|&
name|term
operator|->
name|screen
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|XDefineCursor
argument_list|(
name|screen
operator|->
name|window
argument_list|,
operator|(
name|term
operator|->
name|flags
operator|&
name|REVERSE_VIDEO
operator|)
condition|?
name|screen
operator|->
name|rcurs
else|:
name|screen
operator|->
name|curs
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|screen
operator|->
name|background
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|cursorcolor
operator|==
name|screen
operator|->
name|foreground
condition|)
name|screen
operator|->
name|cursorcolor
operator|=
name|tmp
expr_stmt|;
name|screen
operator|->
name|background
operator|=
name|screen
operator|->
name|foreground
expr_stmt|;
name|screen
operator|->
name|foreground
operator|=
name|tmp
expr_stmt|;
name|XFreePixmap
argument_list|(
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
name|screen
operator|->
name|bgndtile
operator|=
name|XMakeTile
argument_list|(
name|screen
operator|->
name|background
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|borderwidth
operator|&&
name|screen
operator|->
name|background
operator|<
literal|2
operator|&&
name|screen
operator|->
name|foreground
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|screen
operator|->
name|bgndtile
operator|==
name|BlackPixmap
condition|)
name|screen
operator|->
name|bordertile
operator|=
name|WhitePixmap
expr_stmt|;
elseif|else
if|if
condition|(
name|screen
operator|->
name|bgndtile
operator|==
name|WhitePixmap
condition|)
name|screen
operator|->
name|bordertile
operator|=
name|BlackPixmap
expr_stmt|;
name|XChangeBorder
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|bordertile
argument_list|)
expr_stmt|;
block|}
name|XChangeBackground
argument_list|(
name|screen
operator|->
name|window
argument_list|,
name|screen
operator|->
name|bgndtile
argument_list|)
expr_stmt|;
name|XClear
argument_list|(
name|screen
operator|->
name|window
argument_list|)
expr_stmt|;
name|ScrnRefresh
argument_list|(
name|screen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|screen
operator|->
name|max_row
operator|+
literal|1
argument_list|,
name|screen
operator|->
name|max_col
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|screen
operator|->
name|TekEmu
condition|)
name|TekRefresh
argument_list|(
name|term
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

