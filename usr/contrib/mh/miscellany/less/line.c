begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines to manipulate the "line buffer".  * The line buffer holds a line of output as it is being built  * in preparation for output to the screen.  * We keep track of the PRINTABLE length of the line as it is being built.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|linebuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer which holds the current output line */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|curr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer into linebuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Printable length, accounting for 				   backspaces, etc. */
end_comment

begin_comment
comment|/*  * A ridiculously complex state machine takes care of backspaces   * when in BS_UNDERLINE mode.  The complexity arises from the attempt  * to deal with all cases, especially involving long lines with underlining.  * There are still some cases which will break it.  *  * There are four states:  *	UL_NORMAL is the normal state (not in underline mode).  *	UL_YES means we are in underline mode.  We expect to get  *		either a sequence like "_\bX" or "X\b_" to continue  *		underline mode, or just some ordinary characters  *		(no backspaces) to end underline mode.  *	UL_X means we are one character after UL_YES  *		(we have gotten the '_' in "_\bX" or the 'X' in "X\b_").  *	UL_XB means we are one character after UL_X   *		(we have gotten the backspace in "_\bX" or "X\b_";  *		we expect one more ordinary character,   *		which will put us back in state UL_YES).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ul_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently in underline mode? */
end_comment

begin_define
define|#
directive|define
name|UL_NORMAL
value|0
end_define

begin_comment
comment|/* Not in underline mode */
end_comment

begin_define
define|#
directive|define
name|UL_YES
value|1
end_define

begin_comment
comment|/* In underline, need next char */
end_comment

begin_define
define|#
directive|define
name|UL_X
value|2
end_define

begin_comment
comment|/* In underline, got char, need \b */
end_comment

begin_define
define|#
directive|define
name|UL_XB
value|3
end_define

begin_comment
comment|/* In underline, got char& \b, need one more */
end_comment

begin_decl_stmt
name|public
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the current line. 				   Usually points to linebuf. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tabstop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ul_width
decl_stmt|,
name|ue_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Rewind the line buffer.  */
end_comment

begin_function
name|public
name|void
name|prewind
parameter_list|()
block|{
name|line
operator|=
name|curr
operator|=
name|linebuf
expr_stmt|;
name|ul_state
operator|=
name|UL_NORMAL
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a character to the line buffer.  * Expand tabs into spaces, handle underlining.  * Returns 0 if ok, 1 if couldn't fit in buffer.  */
end_comment

begin_define
define|#
directive|define
name|NEW_COLUMN
parameter_list|(
name|newcol
parameter_list|)
value|if ((newcol) + ((ul_state)?ue_width:0)> sc_width) \ 					return (1); else column = (newcol)
end_define

begin_function
name|public
name|int
name|pappend
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Terminate underline mode, if necessary. 		 * Append a '\0' to the end of the line. 		 */
switch|switch
condition|(
name|ul_state
condition|)
block|{
case|case
name|UL_X
case|:
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|UE_CHAR
expr_stmt|;
name|curr
operator|++
expr_stmt|;
break|break;
case|case
name|UL_XB
case|:
case|case
name|UL_YES
case|:
operator|*
name|curr
operator|++
operator|=
name|UE_CHAR
expr_stmt|;
break|break;
block|}
name|ul_state
operator|=
name|UL_NORMAL
expr_stmt|;
operator|*
name|curr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|curr
operator|>
name|linebuf
operator|+
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|12
condition|)
comment|/* 		 * Almost out of room in the line buffer. 		 * Don't take any chances. 		 * {{ Linebuf is supposed to be big enough that this 		 *    will never happen, but may need to be made  		 *    bigger for wide screens or lots of backspaces. }} 		 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|bs_mode
operator|==
name|BS_UNDERLINE
condition|)
block|{
comment|/* 		 * Advance the state machine. 		 */
switch|switch
condition|(
name|ul_state
condition|)
block|{
case|case
name|UL_NORMAL
case|:
if|if
condition|(
name|curr
operator|<=
name|linebuf
operator|+
literal|1
operator|||
name|curr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\b'
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|'_'
operator|&&
name|curr
index|[
operator|-
literal|2
index|]
operator|!=
literal|'_'
condition|)
block|{
name|curr
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
comment|/* 			 * We have either "_\bX" or "X\b_" (including 			 * the current char).  Switch into underline mode. 			 */
if|if
condition|(
name|column
operator|+
name|ul_width
operator|+
name|ue_width
operator|+
literal|1
operator|>=
name|sc_width
condition|)
comment|/* 				 * Not enough room left on the screen to  				 * enter and exit underline mode. 				 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ul_width
operator|>
literal|0
operator|&&
name|curr
operator|>
name|linebuf
operator|+
literal|2
operator|&&
name|curr
index|[
operator|-
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* 				 * Special case for magic cookie terminals: 				 * if the previous char was a space, replace  				 * it with the "enter underline" sequence. 				 */
name|curr
index|[
operator|-
literal|3
index|]
operator|=
name|UL_CHAR
expr_stmt|;
name|column
operator|+=
name|ul_width
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|curr
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|2
index|]
operator|=
name|UL_CHAR
expr_stmt|;
name|column
operator|+=
name|ul_width
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
comment|/* Fall thru */
case|case
name|UL_XB
case|:
comment|/* 			 * Termination of a sequnce "_\bX" or "X\b_". 			 */
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
name|curr
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|curr
operator|-=
literal|2
expr_stmt|;
name|ul_state
operator|=
name|UL_YES
expr_stmt|;
break|break;
case|case
name|UL_YES
case|:
if|if
condition|(
name|column
operator|+
name|ue_width
operator|+
literal|1
operator|>=
name|sc_width
condition|)
comment|/* 				 * We have just barely enough room to  				 * exit underline mode.   				 */
return|return
operator|(
literal|1
operator|)
return|;
name|ul_state
operator|=
name|UL_X
expr_stmt|;
break|break;
case|case
name|UL_X
case|:
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|ul_state
operator|=
name|UL_XB
expr_stmt|;
else|else
block|{
comment|/* 				 * Exit underline mode. 				 * We have to shuffle the chars a bit 				 * to make this work. 				 */
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|UE_CHAR
expr_stmt|;
name|column
operator|+=
name|ue_width
expr_stmt|;
if|if
condition|(
name|ul_width
operator|>
literal|0
operator|&&
name|curr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
comment|/* 					 * Another special case for magic 					 * cookie terminals: if the next 					 * char is a space, replace it 					 * with the "exit underline" sequence. 					 */
name|column
operator|--
expr_stmt|;
else|else
name|curr
operator|++
expr_stmt|;
name|ul_state
operator|=
name|UL_NORMAL
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		 * Expand a tab into spaces. 		 */
do|do
block|{
name|NEW_COLUMN
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|column
operator|%
name|tabstop
operator|)
operator|!=
literal|0
condition|)
do|;
operator|*
name|curr
operator|++
operator|=
literal|'\t'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
if|if
condition|(
name|bs_mode
operator|==
name|BS_CONTROL
condition|)
block|{
comment|/* 			 * Treat backspace as a control char: output "^H". 			 */
name|NEW_COLUMN
argument_list|(
name|column
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|curr
operator|++
operator|=
operator|(
literal|'H'
operator||
literal|0200
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Output a real backspace. 			 */
name|column
operator|--
expr_stmt|;
operator|*
name|curr
operator|++
operator|=
literal|'\b'
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* 		 * Put a "^X" into the buffer. 		 * The 0200 bit is used to tell put_line() to prefix 		 * the char with a ^.  We don't actually put the ^ 		 * in the buffer because we sometimes need to move 		 * chars around, and such movement might separate  		 * the ^ from its following character. 		 */
name|NEW_COLUMN
argument_list|(
name|column
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|curr
operator|++
operator|=
operator|(
name|carat_char
argument_list|(
name|c
argument_list|)
operator||
literal|0200
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Ordinary character.  Just put it in the buffer. 	 */
name|NEW_COLUMN
argument_list|(
name|column
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|curr
operator|++
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Analogous to forw_line(), but deals with "raw lines":  * lines which are not split for screen width.  * {{ This is supposed to be more efficient than forw_line(). }}  */
end_comment

begin_function
name|public
name|POSITION
name|forw_raw_line
parameter_list|(
name|curr_pos
parameter_list|)
name|POSITION
name|curr_pos
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|POSITION
name|new_pos
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|ch_seek
argument_list|(
name|curr_pos
argument_list|)
operator|||
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|p
operator|=
name|linebuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|new_pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|>=
operator|&
name|linebuf
index|[
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
comment|/* 			 * Overflowed the input buffer. 			 * Pretend the line ended here. 			 * {{ The line buffer is supposed to be big 			 *    enough that this never happens. }} 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|line
operator|=
name|linebuf
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Analogous to back_line(), but deals with "raw lines".  * {{ This is supposed to be more efficient than back_line(). }}  */
end_comment

begin_function
name|public
name|POSITION
name|back_raw_line
parameter_list|(
name|curr_pos
parameter_list|)
name|POSITION
name|curr_pos
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|POSITION
name|new_pos
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|curr_pos
operator|<=
operator|(
name|POSITION
operator|)
literal|0
operator|||
name|ch_seek
argument_list|(
name|curr_pos
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|p
operator|=
operator|&
name|linebuf
index|[
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ch_back_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* 			 * This is the newline ending the previous line. 			 * We have hit the beginning of the line. 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* 			 * We have hit the beginning of the file. 			 * This must be the first line in the file. 			 * This must, of course, be the beginning of the line. 			 */
name|new_pos
operator|=
operator|(
name|POSITION
operator|)
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|<=
name|linebuf
condition|)
block|{
comment|/* 			 * Overflowed the input buffer. 			 * Pretend the line ended here. 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
operator|*
operator|--
name|p
operator|=
name|c
expr_stmt|;
block|}
name|line
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

end_unit

