begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Low level character input from the input file.  * We use these special purpose routines which optimize moving  * both forward and backward from the current read pointer.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_decl_stmt
name|public
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor of the input file */
end_comment

begin_comment
comment|/*  * Pool of buffers holding the most recently used blocks of the input file.  */
end_comment

begin_define
define|#
directive|define
name|BUFSIZ
value|1024
end_define

begin_struct
specifier|static
struct|struct
name|buf
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|long
name|block
decl_stmt|;
name|char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|buf
modifier|*
name|bufs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|nbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The buffer pool is kept as a doubly-linked circular list,  * in order from most- to least-recently used.  * The circular list is anchored by buf_anchor.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|buf_anchor
struct|;
end_struct

begin_define
define|#
directive|define
name|END_OF_CHAIN
value|((struct buf *)&buf_anchor)
end_define

begin_define
define|#
directive|define
name|buf_head
value|buf_anchor.next
end_define

begin_define
define|#
directive|define
name|buf_tail
value|buf_anchor.prev
end_define

begin_comment
comment|/*  * If we fail to allocate enough memory for buffers, we try to limp  * along with a minimum number of buffers.    */
end_comment

begin_define
define|#
directive|define
name|DEF_NBUFS
value|2
end_define

begin_comment
comment|/* Minimum number of buffers */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|clean_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current position in file.  * Stored as a block number and an offset into the block.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|ch_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ch_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Length of file, needed if input is a pipe.  */
end_comment

begin_decl_stmt
specifier|static
name|POSITION
name|ch_fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Largest block number read if input is standard input (a pipe).  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|last_piped_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get the character pointed to by the read pointer.  * ch_get() is a macro which is more efficient to call  * than fch_get (the function), in the usual case   * that the block desired is at the head of the chain.  */
end_comment

begin_define
define|#
directive|define
name|ch_get
parameter_list|()
value|((buf_head->block == ch_block) ? \ 			buf_head->data[ch_offset] : fch_get())
end_define

begin_function
specifier|static
name|int
name|fch_get
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|end
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
comment|/* 	 * Look for a buffer holding the desired block. 	 */
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|ch_block
condition|)
goto|goto
name|found
goto|;
comment|/* 	 * Block is not in a buffer.   	 * Take the least recently used buffer  	 * and read the desired block into it. 	 */
name|bp
operator|=
name|buf_tail
expr_stmt|;
name|bp
operator|->
name|block
operator|=
name|ch_block
expr_stmt|;
name|pos
operator|=
name|ch_block
operator|*
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|ispipe
condition|)
block|{
comment|/* 		 * The block requested should be one more than 		 * the last block read. 		 */
if|if
condition|(
name|ch_block
operator|!=
operator|++
name|last_piped_block
condition|)
block|{
comment|/* This "should not happen". */
name|char
name|message
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Pipe error: last %ld, want %ld\n"
argument_list|,
name|last_piped_block
operator|-
literal|1
argument_list|,
name|ch_block
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|lseek
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Read the block.  This may take several reads if the input 	 * is coming from standard input, due to the nature of pipes. 	 */
name|end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|file
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
name|end
index|]
argument_list|,
name|BUFSIZ
operator|-
name|end
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
operator|(
name|end
operator|+=
name|n
operator|)
operator|>=
name|BUFSIZ
condition|)
break|break;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"read error"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Set an EOF marker in the buffered data itself. 	 * Then ensure the data is "clean": there are no  	 * extra EOF chars in the data and that the "meta" 	 * bit (the 0200 bit) is reset in each char. 	 */
if|if
condition|(
name|end
operator|<
name|BUFSIZ
condition|)
block|{
name|ch_fsize
operator|=
name|pos
operator|+
name|end
expr_stmt|;
name|bp
operator|->
name|data
index|[
name|end
index|]
operator|=
name|EOF
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clean_data
condition|)
while|while
condition|(
operator|--
name|end
operator|>=
literal|0
condition|)
block|{
name|bp
operator|->
name|data
index|[
name|end
index|]
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|data
index|[
name|end
index|]
operator|==
name|EOF
condition|)
name|bp
operator|->
name|data
index|[
name|end
index|]
operator|=
literal|'@'
expr_stmt|;
block|}
name|found
label|:
comment|/* if (buf_head != bp) {this is guaranteed by the ch_get macro} */
block|{
comment|/* 		 * Move the buffer to the head of the buffer chain. 		 * This orders the buffer chain, most- to least-recently used. 		 */
name|bp
operator|->
name|next
operator|->
name|prev
operator|=
name|bp
operator|->
name|prev
expr_stmt|;
name|bp
operator|->
name|prev
operator|->
name|next
operator|=
name|bp
operator|->
name|next
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|buf_head
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|buf_head
operator|->
name|prev
operator|=
name|bp
expr_stmt|;
name|buf_head
operator|=
name|bp
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|->
name|data
index|[
name|ch_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if a specific block is currently in one of the buffers.  */
end_comment

begin_function
specifier|static
name|int
name|buffered
parameter_list|(
name|block
parameter_list|)
name|long
name|block
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to a specified position in the file.  * Return 0 if successful, non-zero if can't seek there.  */
end_comment

begin_function
name|public
name|int
name|ch_seek
parameter_list|(
name|pos
parameter_list|)
specifier|register
name|POSITION
name|pos
decl_stmt|;
block|{
name|long
name|new_block
decl_stmt|;
name|new_block
operator|=
name|pos
operator|/
name|BUFSIZ
expr_stmt|;
if|if
condition|(
operator|!
name|ispipe
operator|||
name|new_block
operator|==
name|last_piped_block
operator|+
literal|1
operator|||
name|buffered
argument_list|(
name|new_block
argument_list|)
condition|)
block|{
comment|/* 		 * Set read pointer. 		 */
name|ch_block
operator|=
name|new_block
expr_stmt|;
name|ch_offset
operator|=
name|pos
operator|%
name|BUFSIZ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to the end of the file.  */
end_comment

begin_function
name|public
name|int
name|ch_end_seek
parameter_list|()
block|{
if|if
condition|(
name|ispipe
condition|)
block|{
comment|/* 		 * Do it the slow way: read till end of data. 		 */
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ch_seek
argument_list|(
call|(
name|POSITION
call|)
argument_list|(
name|lseek
argument_list|(
name|file
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the length of the file, if known.  */
end_comment

begin_function
name|public
name|POSITION
name|ch_length
parameter_list|()
block|{
if|if
condition|(
name|ispipe
condition|)
return|return
operator|(
name|ch_fsize
operator|)
return|;
return|return
operator|(
call|(
name|POSITION
call|)
argument_list|(
name|lseek
argument_list|(
name|file
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current position in the file.  */
end_comment

begin_function
name|public
name|POSITION
name|ch_tell
parameter_list|()
block|{
return|return
operator|(
name|ch_block
operator|*
name|BUFSIZ
operator|+
name|ch_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current char and post-increment the read pointer.  */
end_comment

begin_function
name|public
name|int
name|ch_forw_get
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ch_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|++
name|ch_offset
operator|>=
name|BUFSIZ
condition|)
block|{
name|ch_offset
operator|=
literal|0
expr_stmt|;
name|ch_block
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-decrement the read pointer and get the new current char.  */
end_comment

begin_function
name|public
name|int
name|ch_back_get
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|--
name|ch_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ch_block
operator|<=
literal|0
operator|||
operator|(
name|ispipe
operator|&&
operator|!
name|buffered
argument_list|(
name|ch_block
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|ch_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
name|ch_offset
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
name|ch_block
operator|--
expr_stmt|;
block|}
name|c
operator|=
name|ch_get
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the buffer pool to all empty.  * Caller suggests that we use want_nbufs buffers.  */
end_comment

begin_function
name|public
name|void
name|ch_init
parameter_list|(
name|want_nbufs
parameter_list|)
name|int
name|want_nbufs
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
if|if
condition|(
name|nbufs
operator|<
name|want_nbufs
condition|)
block|{
comment|/* 		 * We don't have enough buffers.   		 * Free what we have (if any) and allocate some new ones. 		 */
if|if
condition|(
name|bufs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bufs
argument_list|)
expr_stmt|;
name|bufs
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|calloc
argument_list|(
name|want_nbufs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nbufs
operator|=
name|want_nbufs
expr_stmt|;
if|if
condition|(
name|bufs
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Couldn't get that many. 			 * Try for a small default number of buffers. 			 */
name|char
name|message
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cannot allocate %d buffers.  Using %d buffers."
argument_list|,
name|nbufs
argument_list|,
name|DEF_NBUFS
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|bufs
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|calloc
argument_list|(
name|DEF_NBUFS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nbufs
operator|=
name|DEF_NBUFS
expr_stmt|;
if|if
condition|(
name|bufs
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Couldn't even get the smaller number of bufs. 				 * Something is wrong here, don't continue. 				 */
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Cannot even allocate %d buffers!  Quitting.\n"
argument_list|,
name|DEF_NBUFS
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
block|}
comment|/* 	 * Initialize the buffers to empty. 	 * Set up the circular list. 	 */
for|for
control|(
name|bp
operator|=
operator|&
name|bufs
index|[
literal|0
index|]
init|;
name|bp
operator|<
operator|&
name|bufs
index|[
name|nbufs
index|]
condition|;
name|bp
operator|++
control|)
block|{
name|bp
operator|->
name|next
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|block
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bufs
index|[
literal|0
index|]
operator|.
name|prev
operator|=
name|bufs
index|[
name|nbufs
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|buf_head
operator|=
operator|&
name|bufs
index|[
literal|0
index|]
expr_stmt|;
name|buf_tail
operator|=
operator|&
name|bufs
index|[
name|nbufs
operator|-
literal|1
index|]
expr_stmt|;
name|last_piped_block
operator|=
operator|-
literal|1
expr_stmt|;
name|ch_fsize
operator|=
name|NULL_POSITION
expr_stmt|;
operator|(
name|void
operator|)
name|ch_seek
argument_list|(
operator|(
name|POSITION
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

