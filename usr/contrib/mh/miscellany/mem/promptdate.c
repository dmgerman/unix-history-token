begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* **	promptdate **	prompt user for a date specification which can be quite minimal **	and print it in a form suitable for parsing by MH */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|128
end_define

begin_decl_stmt
name|char
modifier|*
name|mname
index|[
literal|12
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dname
index|[
literal|7
index|]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tm
name|now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dayspast
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|monthlen
index|[
literal|2
index|]
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|defaultformat
init|=
literal|"%d %N %y 00:00"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|tm
name|then
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
comment|/* defined in getopt */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/* defined in getopt */
name|int
name|getopt
parameter_list|()
function_decl|;
name|long
name|secsfr70
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
name|defaultformat
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-f format] [datespec]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|finddate
argument_list|(
operator|&
name|now
argument_list|,
name|dayspast
operator|=
call|(
name|int
call|)
argument_list|(
name|secsfr70
argument_list|()
operator|/
literal|86400L
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
comment|/* get from user */
block|{
if|if
condition|(
operator|!
name|promptdate
argument_list|(
operator|&
name|then
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printdate
argument_list|(
operator|&
name|then
argument_list|,
name|defaultformat
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* get from command line */
block|{
if|if
condition|(
operator|!
name|decodedate
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|then
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printdate
argument_list|(
operator|&
name|then
argument_list|,
name|defaultformat
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|promptdate
parameter_list|(
name|when
parameter_list|)
name|struct
name|tm
modifier|*
name|when
decl_stmt|;
block|{
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
name|int
name|decodedate
parameter_list|()
function_decl|;
name|char
modifier|*
name|gets
parameter_list|()
function_decl|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"When? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|line
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|decodedate
argument_list|(
name|line
argument_list|,
name|when
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|int
name|decodedate
parameter_list|(
name|line
parameter_list|,
name|when
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|struct
name|tm
modifier|*
name|when
decl_stmt|;
comment|/* **	accept spec for date in several forms **	legal are: sun,mon,tue,wed,thu,fri,sat,today,tomorrow, **<date><month>,+<relative number of days> **<month> should be alpha **	upper case accepted too */
block|{
name|char
name|s
index|[
literal|4
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|targetdate
decl_stmt|;
name|int
name|tem
decl_stmt|;
specifier|register
name|char
modifier|*
name|lptr
decl_stmt|;
name|when
operator|->
name|tm_year
operator|=
name|now
operator|.
name|tm_year
expr_stmt|;
name|when
operator|->
name|tm_mon
operator|=
name|now
operator|.
name|tm_mon
expr_stmt|;
name|targetdate
operator|=
name|dayspast
expr_stmt|;
for|for
control|(
name|lptr
operator|=
name|line
init|;
name|isspace
argument_list|(
operator|*
name|lptr
argument_list|)
condition|;
name|lptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|lptr
argument_list|)
condition|)
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|lptr
argument_list|,
literal|"%d%3s%d"
argument_list|,
operator|&
name|when
operator|->
name|tm_mday
argument_list|,
name|s
argument_list|,
operator|&
name|tem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|3
case|:
name|when
operator|->
name|tm_year
operator|=
name|tem
expr_stmt|;
case|case
literal|2
case|:
name|fold
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|when
operator|->
name|tm_mon
operator|=
name|monthofyear
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|3
condition|)
break|break;
if|if
condition|(
name|when
operator|->
name|tm_mday
operator|!=
literal|0
operator|&&
name|when
operator|->
name|tm_mon
operator|!=
literal|0
operator|&&
name|daysfr70
argument_list|(
name|when
argument_list|)
operator|<
name|dayspast
condition|)
name|when
operator|->
name|tm_year
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|when
operator|->
name|tm_mday
operator|!=
literal|0
operator|&&
name|when
operator|->
name|tm_mday
operator|<
name|now
operator|.
name|tm_mday
condition|)
block|{
if|if
condition|(
operator|++
name|when
operator|->
name|tm_mon
operator|>
literal|12
condition|)
block|{
name|when
operator|->
name|tm_mon
operator|=
literal|1
expr_stmt|;
name|when
operator|->
name|tm_year
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|validate
argument_list|(
name|when
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|lptr
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|lptr
argument_list|,
literal|"%3s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fold
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tem
operator|=
name|dayofweek
argument_list|(
name|s
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|targetdate
operator|+=
operator|(
name|tem
operator|-=
name|now
operator|.
name|tm_wday
operator|)
operator|<=
literal|0
condition|?
name|tem
operator|+
literal|7
else|:
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"Tom"
argument_list|)
operator|==
literal|0
condition|)
name|targetdate
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"Tod"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
comment|/* mistake */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|lptr
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
operator|++
name|lptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|tem
argument_list|)
operator|==
literal|0
operator|||
name|tem
operator|<
literal|0
condition|)
comment|/* mistake */
return|return
operator|(
literal|0
operator|)
return|;
name|targetdate
operator|+=
name|tem
expr_stmt|;
block|}
else|else
comment|/* mistake by default */
return|return
operator|(
literal|0
operator|)
return|;
name|finddate
argument_list|(
name|when
argument_list|,
name|targetdate
argument_list|)
expr_stmt|;
return|return
operator|(
name|when
operator|->
name|tm_mday
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|validate
parameter_list|(
name|datetm
parameter_list|)
comment|/* **	check that a given date and month combination is legal **	datetm->tm_year must hold the year in question */
specifier|register
name|struct
name|tm
modifier|*
name|datetm
decl_stmt|;
block|{
return|return
operator|(
name|datetm
operator|->
name|tm_mday
operator|<=
name|monthlen
index|[
name|leapyear
argument_list|(
name|datetm
operator|->
name|tm_year
argument_list|)
index|]
index|[
name|datetm
operator|->
name|tm_mon
index|]
operator|&&
name|datetm
operator|->
name|tm_mday
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|finddate
argument_list|(
name|datetm
argument_list|,
name|df70
argument_list|)
comment|/* **	convert days from 1 jan 1970 to a date in struct datetm */
specifier|register
name|int
name|df70
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tm
modifier|*
name|datetm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tm
modifier|*
name|tdtm
decl_stmt|;
name|long
name|longtime
decl_stmt|;
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
name|longtime
operator|=
name|df70
operator|*
literal|86400L
expr_stmt|;
name|tdtm
operator|=
name|gmtime
argument_list|(
operator|&
name|longtime
argument_list|)
expr_stmt|;
name|datetm
operator|->
name|tm_yday
operator|=
name|tdtm
operator|->
name|tm_yday
expr_stmt|;
name|datetm
operator|->
name|tm_wday
operator|=
name|tdtm
operator|->
name|tm_wday
expr_stmt|;
name|datetm
operator|->
name|tm_year
operator|=
name|tdtm
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|datetm
operator|->
name|tm_mon
operator|=
name|tdtm
operator|->
name|tm_mon
expr_stmt|;
name|datetm
operator|->
name|tm_mday
operator|=
name|tdtm
operator|->
name|tm_mday
expr_stmt|;
name|datetm
operator|->
name|tm_hour
operator|=
name|tdtm
operator|->
name|tm_hour
expr_stmt|;
name|datetm
operator|->
name|tm_min
operator|=
name|tdtm
operator|->
name|tm_min
expr_stmt|;
name|datetm
operator|->
name|tm_sec
operator|=
name|tdtm
operator|->
name|tm_sec
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|fold
argument_list|(
name|s
argument_list|)
comment|/* **	convert first character to uppercase **	convert rest of string from uppercase to lower case */
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|+=
name|islower
argument_list|(
name|c
argument_list|)
condition|?
literal|'A'
operator|-
literal|'a'
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|+=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
literal|'a'
operator|-
literal|'A'
else|:
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|int
name|leapyear
parameter_list|(
name|y
parameter_list|)
comment|/* **	returns 1 if leapyear 0 otherwise */
specifier|register
name|int
name|y
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|y
operator|%
literal|4
operator|)
operator|==
literal|0
operator|&&
operator|(
name|y
operator|%
literal|100
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|y
operator|%
literal|400
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|daysfr70
parameter_list|(
name|datetm
parameter_list|)
comment|/* **	returns the number of days from 1 Jan 1970 **	no checking for illegal date at all */
specifier|register
name|struct
name|tm
modifier|*
name|datetm
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|totdays
decl_stmt|;
name|totdays
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1970
init|;
name|i
operator|<=
literal|2050
operator|&&
name|i
operator|<
name|datetm
operator|->
name|tm_year
condition|;
name|i
operator|++
control|)
comment|/* prevent overflow */
name|totdays
operator|+=
literal|365
operator|+
name|leapyear
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
operator|&&
name|i
operator|<
name|datetm
operator|->
name|tm_mon
condition|;
name|i
operator|++
control|)
name|totdays
operator|+=
name|monthlen
index|[
name|leapyear
argument_list|(
name|datetm
operator|->
name|tm_year
argument_list|)
index|]
index|[
name|i
index|]
expr_stmt|;
name|totdays
operator|+=
name|datetm
operator|->
name|tm_mday
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|totdays
operator|)
return|;
block|}
end_function

begin_function
name|int
name|monthofyear
parameter_list|(
name|s
parameter_list|)
comment|/* **	returns month of year in numeric form when given **	the first three letters */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fold
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|--
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|mname
index|[
name|i
index|]
argument_list|)
condition|;
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dayofweek
parameter_list|(
name|s
parameter_list|)
comment|/* **	sunday = 0,...,saturday = 6, nomatch = -1 */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fold
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|--
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|dname
index|[
name|i
index|]
argument_list|)
condition|;
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_macro
name|printdate
argument_list|(
argument|date
argument_list|,
argument|format
argument_list|)
end_macro

begin_comment
comment|/* **	print date in MH acceptable format **	kludge - general formats are not implemented */
end_comment

begin_decl_stmt
name|struct
name|tm
modifier|*
name|date
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%d %s %d 00:00\n"
argument_list|,
name|date
operator|->
name|tm_mday
argument_list|,
name|mname
index|[
name|date
operator|->
name|tm_mon
index|]
argument_list|,
name|date
operator|->
name|tm_year
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|long
name|secsfr70
parameter_list|()
comment|/* **	This is system dependent */
block|{
specifier|register
name|int
name|dst
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|dst
operator|=
name|localtime
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
operator|->
name|tm_isdst
expr_stmt|;
return|return
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|tz
operator|.
name|tz_minuteswest
operator|*
literal|60
operator|+
operator|(
name|dst
condition|?
literal|3600
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function

end_unit

