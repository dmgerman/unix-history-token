begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* slocal.c - MH style mailer to write to a local user's mailbox */
end_comment

begin_comment
comment|/* This program implements mail delivery in the MH/MMDF style.     Under SendMail, users should add the line  	"| /usr/local/lib/mh/slocal"     to their $HOME/.forward file.     Under MMDF-I, users should (symbolically) link /usr/local/lib/mh/slocal    to $HOME/bin/rcvmail.     Under stand-alone MH, post will automatically run this during local    delivery.     This program should be used ONLY if you have "mts sendmail" or "mts mh"    or "mts mmdf1" set in your MH configuration.  */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/rcvmail.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
endif|not V7
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_define
define|#
directive|define
name|NVEC
value|100
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|switches
index|[]
init|=
block|{
define|#
directive|define
name|ADDRSW
value|0
literal|"addr address"
block|,
literal|0
block|,
define|#
directive|define
name|USERSW
value|1
literal|"user name"
block|,
literal|0
block|,
define|#
directive|define
name|FILESW
value|2
literal|"file file"
block|,
literal|0
block|,
define|#
directive|define
name|SENDSW
value|3
literal|"sender address"
block|,
literal|0
block|,
define|#
directive|define
name|MBOXSW
value|4
literal|"mailbox file"
block|,
literal|0
block|,
define|#
directive|define
name|HOMESW
value|5
literal|"home directory"
block|,
literal|0
block|,
define|#
directive|define
name|MAILSW
value|6
literal|"maildelivery file"
block|,
literal|0
block|,
define|#
directive|define
name|VERBSW
value|7
literal|"verbose"
block|,
literal|0
block|,
define|#
directive|define
name|NVERBSW
value|8
literal|"noverbose"
block|,
literal|0
block|,
define|#
directive|define
name|DEBUGSW
value|9
literal|"debug"
block|,
literal|0
block|,
define|#
directive|define
name|HELPSW
value|10
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|globbed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parsed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|utmped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|addr
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|file
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sender
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mbox
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|home
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ddate
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tws
modifier|*
name|now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|myctx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
specifier|static
struct|struct
name|pair
block|{
name|char
modifier|*
name|p_name
decl_stmt|;
name|char
modifier|*
name|p_value
decl_stmt|;
name|char
name|p_flags
decl_stmt|;
define|#
directive|define
name|P_NIL
value|0x00
define|#
directive|define
name|P_ADR
value|0x01
define|#
directive|define
name|P_HID
value|0x02
define|#
directive|define
name|P_CHK
value|0x04
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|pair
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|pair
name|hdrs
index|[
name|NVEC
operator|+
literal|1
index|]
init|=
block|{
literal|"source"
block|,
name|NULL
block|,
name|P_HID
block|,
literal|"addr"
block|,
name|NULL
block|,
name|P_HID
block|,
literal|"Return-Path"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"Reply-To"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"From"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"Sender"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"To"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"cc"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"Resent-Reply-To"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"Resent-From"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"Resent-Sender"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"Resent-To"
block|,
name|NULL
block|,
name|P_ADR
block|,
literal|"Resent-cc"
block|,
name|NULL
block|,
name|P_ADR
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pair
name|vars
index|[]
init|=
block|{
literal|"sender"
block|,
name|NULL
block|,
name|P_NIL
block|,
literal|"address"
block|,
name|NULL
block|,
name|P_NIL
block|,
literal|"size"
block|,
name|NULL
block|,
name|P_NIL
block|,
literal|"reply-to"
block|,
name|NULL
block|,
name|P_CHK
block|,
literal|"info"
block|,
name|NULL
block|,
name|P_NIL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|adorn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|alrmser
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|SYS5
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|stdin
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|mdlvr
init|=
name|NULL
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|,
name|from
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mailbox
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
modifier|*
name|argp
init|=
name|argv
operator|+
literal|1
decl_stmt|;
name|invo_name
operator|=
name|r1bindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|m_foil
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|invo_name
argument_list|)
expr_stmt|;
comment|/*
comment|*/
while|while
condition|(
name|cp
operator|=
operator|*
name|argp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|switches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s unknown"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
case|case
name|HELPSW
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [switches] [address info sender]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|ADDRSW
case|:
if|if
condition|(
operator|!
operator|(
name|addr
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
comment|/* allow -xyz arguments */
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|USERSW
case|:
if|if
condition|(
operator|!
operator|(
name|user
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
comment|/* allow -xyz arguments */
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FILESW
case|:
if|if
condition|(
operator|!
operator|(
name|file
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|file
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SENDSW
case|:
if|if
condition|(
operator|!
operator|(
name|sender
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
comment|/* allow -xyz arguments */
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MBOXSW
case|:
if|if
condition|(
operator|!
operator|(
name|mbox
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|mbox
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|HOMESW
case|:
if|if
condition|(
operator|!
operator|(
name|home
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|home
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MAILSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdlvr
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"only one maildelivery file at a time!"
argument_list|)
expr_stmt|;
name|mdlvr
operator|=
name|cp
expr_stmt|;
continue|continue;
case|case
name|VERBSW
case|:
name|verbose
operator|++
expr_stmt|;
continue|continue;
case|case
name|NVERBSW
case|:
name|verbose
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|DEBUGSW
case|:
name|debug
operator|++
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|argp
operator|-
operator|(
name|argv
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|1
case|:
name|addr
operator|=
name|cp
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|info
operator|=
name|cp
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sender
operator|=
name|cp
expr_stmt|;
break|break;
block|}
block|}
comment|/*
comment|*/
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
name|addr
operator|=
name|getusr
argument_list|()
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
name|user
operator|=
operator|(
name|cp
operator|=
name|index
argument_list|(
name|addr
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|?
operator|++
name|cp
else|:
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no such local user as %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|==
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0077
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD41A
operator|(
name|void
operator|)
name|inigrp
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD41A
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
name|info
operator|=
literal|""
expr_stmt|;
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|copyfile
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|file
operator|=
name|tmpfil
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to create temporary file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"temporary file \"%s\" selected\n"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to access temporary file"
argument_list|)
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|from
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sender
operator|==
name|NULL
condition|)
name|copyinfo
argument_list|(
name|fp
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbox
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mailbox
argument_list|,
literal|"%s/%s"
argument_list|,
name|mmdfldir
index|[
literal|0
index|]
condition|?
name|mmdfldir
else|:
name|pw
operator|->
name|pw_dir
argument_list|,
name|mmdflfil
index|[
literal|0
index|]
condition|?
name|mmdflfil
else|:
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|mbox
operator|=
name|mailbox
expr_stmt|;
block|}
if|if
condition|(
name|home
operator|==
name|NULL
condition|)
name|home
operator|=
name|pw
operator|->
name|pw_dir
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|=
name|dtwstime
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to ascertain local time"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ddate
argument_list|,
literal|"Delivery-Date: %s\n"
argument_list|,
name|dtimenow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"addr=\"%s\" user=\"%s\" info=\"%s\" file=\"%s\"\n"
argument_list|,
name|addr
argument_list|,
name|user
argument_list|,
name|info
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sender=\"%s\" mbox=\"%s\" home=\"%s\" from=\"%s\"\n"
argument_list|,
name|sender
argument_list|,
name|mbox
argument_list|,
name|home
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ddate=\"%s\" now=%02d:%02d\n"
argument_list|,
name|ddate
argument_list|,
name|now
operator|->
name|tw_hour
argument_list|,
name|now
operator|->
name|tw_min
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|(
name|localmail
argument_list|(
name|fd
argument_list|,
name|from
argument_list|,
name|mdlvr
argument_list|)
operator|!=
name|NOTOK
condition|?
name|RCV_MOK
else|:
name|RCV_MBX
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|localmail
parameter_list|(
name|fd
parameter_list|,
name|from
parameter_list|,
name|mdlvr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|mdlvr
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|usr_delivery
argument_list|(
name|fd
argument_list|,
name|mdlvr
condition|?
name|mdlvr
else|:
literal|".maildelivery"
argument_list|,
literal|0
argument_list|)
operator|!=
name|NOTOK
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|usr_delivery
argument_list|(
name|fd
argument_list|,
name|maildelivery
argument_list|,
literal|1
argument_list|)
operator|!=
name|NOTOK
condition|)
return|return
name|OK
return|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"(invoking hook)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usr_hook
argument_list|(
name|fd
argument_list|,
name|mbox
argument_list|)
operator|!=
name|NOTOK
condition|)
return|return
name|OK
return|;
endif|#
directive|endif
endif|notdef
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"(trying normal delivery)\n"
argument_list|)
expr_stmt|;
return|return
name|usr_file
argument_list|(
name|fd
argument_list|,
name|mbox
argument_list|,
name|from
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|matches
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(stringdex (b, a)>= 0)
end_define

begin_function
specifier|static
name|int
name|usr_delivery
parameter_list|(
name|fd
parameter_list|,
name|delivery
parameter_list|,
name|su
parameter_list|)
name|int
name|fd
decl_stmt|,
name|su
decl_stmt|;
name|char
modifier|*
name|delivery
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|accept
decl_stmt|,
name|status
decl_stmt|,
name|won
decl_stmt|,
name|vecp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|action
decl_stmt|,
modifier|*
name|field
decl_stmt|,
modifier|*
name|pattern
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmpbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|NVEC
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|struct
name|pair
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|delivery
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
operator|||
operator|(
name|st
operator|.
name|st_uid
operator|!=
literal|0
operator|&&
operator|(
name|su
operator|||
name|st
operator|.
name|st_uid
operator|!=
name|pw
operator|->
name|pw_uid
operator|)
operator|)
operator|||
name|st
operator|.
name|st_mode
operator|&
literal|0022
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ownership/modes bad (%d, %d,%d,0%o)\n"
argument_list|,
name|delivery
argument_list|,
name|su
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|NOTOK
return|;
block|}
name|won
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|vecp
operator|=
name|split
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|)
operator|<
literal|5
condition|)
continue|continue;
if|if
condition|(
name|debug
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vec
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vec[%d]: \"%s\"\n"
argument_list|,
name|i
argument_list|,
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|field
operator|=
name|vec
index|[
literal|0
index|]
expr_stmt|;
name|pattern
operator|=
name|vec
index|[
literal|1
index|]
expr_stmt|;
name|action
operator|=
name|vec
index|[
literal|2
index|]
expr_stmt|;
switch|switch
condition|(
name|vec
index|[
literal|3
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'?'
case|:
if|if
condition|(
name|won
condition|)
continue|continue;
comment|/* else fall */
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|accept
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
default|default:
name|accept
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string
operator|=
name|vec
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|vecp
operator|>
literal|5
condition|)
block|{
if|if
condition|(
name|uleq
argument_list|(
name|vec
index|[
literal|5
index|]
argument_list|,
literal|"select"
argument_list|)
condition|)
block|{
if|if
condition|(
name|logged_in
argument_list|()
operator|!=
name|NOTOK
condition|)
continue|continue;
if|if
condition|(
name|vecp
operator|>
literal|7
operator|&&
name|timely
argument_list|(
name|vec
index|[
literal|6
index|]
argument_list|,
name|vec
index|[
literal|7
index|]
argument_list|)
operator|==
name|NOTOK
condition|)
continue|continue;
block|}
block|}
switch|switch
condition|(
operator|*
name|field
condition|)
block|{
case|case
literal|'*'
case|:
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|uleq
argument_list|(
name|field
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
name|won
condition|)
continue|continue;
break|break;
block|}
comment|/* else fall */
default|default:
if|if
condition|(
operator|!
name|parsed
operator|&&
name|parse
argument_list|(
name|fd
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|lookup
argument_list|(
name|hdrs
argument_list|,
name|field
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|matches
argument_list|(
name|p
operator|->
name|p_value
argument_list|,
name|pattern
argument_list|)
condition|)
continue|continue;
break|break;
block|}
switch|switch
condition|(
operator|*
name|action
condition|)
block|{
case|case
literal|'q'
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|action
argument_list|,
literal|"qpipe"
argument_list|)
condition|)
continue|continue;
comment|/* else fall */
case|case
literal|'^'
case|:
name|expand
argument_list|(
name|tmpbuf
argument_list|,
name|string
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
argument_list|(
name|tmpbuf
argument_list|,
name|vec
argument_list|)
operator|<
literal|1
condition|)
continue|continue;
name|status
operator|=
name|usr_pipe
argument_list|(
name|fd
argument_list|,
name|tmpbuf
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|,
name|vec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|action
argument_list|,
literal|"pipe"
argument_list|)
condition|)
continue|continue;
comment|/* else fall */
case|case
literal|'|'
case|:
name|vec
index|[
literal|2
index|]
operator|=
literal|"sh"
expr_stmt|;
name|vec
index|[
literal|3
index|]
operator|=
literal|"-c"
expr_stmt|;
name|expand
argument_list|(
name|tmpbuf
argument_list|,
name|string
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|vec
index|[
literal|4
index|]
operator|=
name|tmpbuf
expr_stmt|;
name|vec
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|usr_pipe
argument_list|(
name|fd
argument_list|,
name|tmpbuf
argument_list|,
literal|"/bin/sh"
argument_list|,
name|vec
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|action
argument_list|,
literal|"file"
argument_list|)
condition|)
continue|continue;
comment|/* else fall */
case|case
literal|'>'
case|:
name|status
operator|=
name|usr_file
argument_list|(
name|fd
argument_list|,
name|string
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|action
argument_list|,
literal|"destroy"
argument_list|)
condition|)
continue|continue;
name|status
operator|=
name|OK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|accept
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|NOTOK
condition|)
block|{
name|won
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|won
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|won
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|QUOTE
value|'\\'
end_define

begin_function
specifier|static
name|int
name|split
parameter_list|(
name|cp
parameter_list|,
name|vec
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|,
decl|*
modifier|*
name|vec
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
name|cp
init|;
name|i
operator|<=
name|NVEC
condition|;
control|)
block|{
name|vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|','
condition|)
operator|*
name|s
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|vec
index|[
name|i
operator|++
index|]
operator|=
operator|++
name|s
init|;
operator|*
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'"'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
name|QUOTE
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'"'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
operator|-
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
condition|)
operator|*
name|s
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|==
name|QUOTE
operator|&&
operator|*
operator|++
name|s
operator|!=
literal|'"'
condition|)
name|s
operator|--
expr_stmt|;
name|vec
index|[
name|i
operator|++
index|]
operator|=
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NULL
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|','
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|parse
parameter_list|(
name|fd
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|state
decl_stmt|;
name|int
name|fd1
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|char
name|name
index|[
name|NAMESZ
index|]
decl_stmt|,
name|field
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|pair
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
name|parsed
operator|++
condition|)
return|return
name|OK
return|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|(
name|in
operator|=
name|fdopen
argument_list|(
name|fd1
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|rewind
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|hdrs
argument_list|,
literal|"source"
argument_list|)
condition|)
name|p
operator|->
name|p_value
operator|=
name|getcpy
argument_list|(
name|sender
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|hdrs
argument_list|,
literal|"addr"
argument_list|)
condition|)
name|p
operator|->
name|p_value
operator|=
name|getcpy
argument_list|(
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|state
operator|=
name|FLD
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|field
argument_list|,
sizeof|sizeof
name|field
argument_list|,
name|in
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDEOF
case|:
case|case
name|FLDPLUS
case|:
name|lp
operator|=
name|add
argument_list|(
name|field
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|field
argument_list|,
sizeof|sizeof
name|field
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|lp
operator|=
name|add
argument_list|(
name|field
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|hdrs
init|;
name|p
operator|->
name|p_name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|p
operator|->
name|p_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flags
operator|&
name|P_HID
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|p
operator|->
name|p_value
condition|)
if|if
condition|(
name|p
operator|->
name|p_flags
operator|&
name|P_ADR
condition|)
block|{
name|dp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|'\n'
condition|)
operator|*
name|dp
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
literal|",\n\t"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|add
argument_list|(
literal|"\t"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_value
operator|=
name|add
argument_list|(
name|lp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|p_name
operator|==
name|NULL
operator|&&
name|i
operator|<
name|NVEC
condition|)
block|{
name|p
operator|->
name|p_name
operator|=
name|getcpy
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_value
operator|=
name|lp
expr_stmt|;
name|p
operator|->
name|p_flags
operator|=
name|P_NIL
expr_stmt|;
name|p
operator|++
operator|,
name|i
operator|++
expr_stmt|;
name|p
operator|->
name|p_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|FLDEOF
condition|)
continue|continue;
break|break;
case|case
name|BODY
case|:
case|case
name|BODYEOF
case|:
case|case
name|FILEEOF
case|:
break|break;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"format error in message"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|vars
argument_list|,
literal|"reply-to"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|lookup
argument_list|(
name|hdrs
argument_list|,
literal|"reply-to"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|q
operator|->
name|p_value
operator|==
name|NULL
condition|)
name|q
operator|=
name|lookup
argument_list|(
name|hdrs
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_value
operator|=
name|getcpy
argument_list|(
name|q
condition|?
name|q
operator|->
name|p_value
else|:
literal|""
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flags
operator|&=
operator|~
name|P_CHK
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vars[%d]: name=\"%s\" value=\"%s\"\n"
argument_list|,
name|p
operator|-
name|vars
argument_list|,
name|p
operator|->
name|p_name
argument_list|,
name|p
operator|->
name|p_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
for|for
control|(
name|p
operator|=
name|hdrs
init|;
name|p
operator|->
name|p_name
condition|;
name|p
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hdrs[%d]: name=\"%s\" value=\"%s\"\n"
argument_list|,
name|p
operator|-
name|hdrs
argument_list|,
name|p
operator|->
name|p_name
argument_list|,
name|p
operator|->
name|p_value
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|LPAREN
value|'('
end_define

begin_define
define|#
directive|define
name|RPAREN
value|')'
end_define

begin_expr_stmt
specifier|static
name|expand
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|fd
argument_list|)
specifier|register
name|char
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|pair
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|globbed
condition|)
name|glob
argument_list|(
name|fd
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
name|c
operator|!=
literal|'$'
operator|||
operator|*
name|s2
operator|!=
name|LPAREN
condition|)
operator|*
name|s1
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
for|for
control|(
name|cp
operator|=
operator|++
name|s2
init|;
operator|*
name|s2
operator|&&
operator|*
name|s2
operator|!=
name|RPAREN
condition|;
name|s2
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|s2
operator|!=
name|RPAREN
condition|)
block|{
name|s2
operator|=
operator|--
name|cp
expr_stmt|;
continue|continue;
block|}
operator|*
name|s2
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|vars
argument_list|,
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parsed
operator|&&
operator|(
name|p
operator|->
name|p_flags
operator|&
name|P_CHK
operator|)
condition|)
operator|(
name|void
operator|)
name|parse
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s1
argument_list|,
name|p
operator|->
name|p_value
argument_list|)
expr_stmt|;
name|s1
operator|+=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|s1
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|glob
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|struct
name|pair
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|globbed
operator|++
condition|)
return|return;
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|vars
argument_list|,
literal|"sender"
argument_list|)
condition|)
name|p
operator|->
name|p_value
operator|=
name|getcpy
argument_list|(
name|sender
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|vars
argument_list|,
literal|"address"
argument_list|)
condition|)
name|p
operator|->
name|p_value
operator|=
name|getcpy
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|vars
argument_list|,
literal|"size"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
else|:
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_value
operator|=
name|getcpy
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|=
name|lookup
argument_list|(
name|vars
argument_list|,
literal|"info"
argument_list|)
condition|)
name|p
operator|->
name|p_value
operator|=
name|getcpy
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
for|for
control|(
name|p
operator|=
name|vars
init|;
name|p
operator|->
name|p_name
condition|;
name|p
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vars[%d]: name=\"%s\" value=\"%s\"\n"
argument_list|,
name|p
operator|-
name|vars
argument_list|,
name|p
operator|->
name|p_name
argument_list|,
name|p
operator|->
name|p_value
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|pair
modifier|*
name|lookup
parameter_list|(
name|pairs
parameter_list|,
name|key
parameter_list|)
specifier|register
name|struct
name|pair
modifier|*
name|pairs
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
init|;
name|cp
operator|=
name|pairs
operator|->
name|p_name
condition|;
name|pairs
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|cp
argument_list|,
name|key
argument_list|)
condition|)
return|return
name|pairs
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|logged_in
parameter_list|()
block|{
name|struct
name|utmp
name|ut
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|uf
decl_stmt|;
if|if
condition|(
name|utmped
condition|)
return|return
name|utmped
return|;
if|if
condition|(
operator|(
name|uf
operator|=
name|fopen
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ut
argument_list|,
sizeof|sizeof
name|ut
argument_list|,
literal|1
argument_list|,
name|uf
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|ut
operator|.
name|ut_name
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|user
argument_list|,
name|ut
operator|.
name|ut_name
argument_list|,
sizeof|sizeof
name|ut
operator|.
name|ut_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|uf
argument_list|)
expr_stmt|;
return|return
operator|(
name|utmped
operator|=
name|DONE
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|uf
argument_list|)
expr_stmt|;
return|return
operator|(
name|utmped
operator|=
name|NOTOK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|timely
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|char
modifier|*
name|t1
decl_stmt|,
decl|*
name|t2
decl_stmt|;
end_function

begin_block
block|{
define|#
directive|define
name|check
parameter_list|(
name|t
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|if (t< a || t> b) return NOTOK
define|#
directive|define
name|cmpar
parameter_list|(
name|h1
parameter_list|,
name|m1
parameter_list|,
name|h2
parameter_list|,
name|m2
parameter_list|)
value|if (h1< h2 || (h1 == h2&& m1< m2)) return OK
name|int
name|t1hours
decl_stmt|,
name|t1mins
decl_stmt|,
name|t2hours
decl_stmt|,
name|t2mins
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|t1
argument_list|,
literal|"%d:%d"
argument_list|,
operator|&
name|t1hours
argument_list|,
operator|&
name|t1mins
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|NOTOK
return|;
name|check
argument_list|(
name|t1hours
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|t1mins
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|t2
argument_list|,
literal|"%d:%d"
argument_list|,
operator|&
name|t2hours
argument_list|,
operator|&
name|t2mins
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|NOTOK
return|;
name|check
argument_list|(
name|t2hours
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|t2mins
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|cmpar
argument_list|(
name|now
operator|->
name|tw_hour
argument_list|,
name|now
operator|->
name|tw_min
argument_list|,
name|t1hours
argument_list|,
name|t1mins
argument_list|)
expr_stmt|;
name|cmpar
argument_list|(
name|t2hours
argument_list|,
name|t2mins
argument_list|,
name|now
operator|->
name|tw_hour
argument_list|,
name|now
operator|->
name|tw_min
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|usr_file
parameter_list|(
name|fd
parameter_list|,
name|mailbox
parameter_list|,
name|from
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|mailbox
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_block
block|{
name|int
name|md
decl_stmt|,
name|mapping
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"\tdelivering to file \"%s\""
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|&&
operator|*
name|from
condition|)
block|{
operator|(
name|void
operator|)
name|mbx_uucp
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|" (uucp style)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s"
argument_list|,
name|from
argument_list|,
name|ddate
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|mapping
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|ddate
expr_stmt|;
name|mapping
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|mbx_open
argument_list|(
name|mailbox
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|,
name|m_gmprot
argument_list|()
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|adorn
argument_list|(
literal|""
argument_list|,
literal|"unable to open:"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx_copy
argument_list|(
name|mailbox
argument_list|,
name|md
argument_list|,
name|fd
argument_list|,
name|mapping
argument_list|,
name|bp
argument_list|,
name|verbose
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|adorn
argument_list|(
literal|""
argument_list|,
literal|"error writing to:"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|mailbox
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|", done.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
specifier|static
name|int
name|usr_hook
parameter_list|(
name|fd
parameter_list|,
name|mailbox
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|mailbox
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|vecp
decl_stmt|;
name|char
name|receive
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|NVEC
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|copyfile
argument_list|(
name|fd
argument_list|,
name|tmpfil
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|adorn
argument_list|(
literal|"unable to copy message; skipping hook\n"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|chown
argument_list|(
name|tmpfil
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|vecp
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|receive
argument_list|,
literal|"%s/.mh_receive"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|access
argument_list|(
name|receive
argument_list|,
literal|01
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|receive
argument_list|,
literal|"%s/bin/rcvmail"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|receive
argument_list|,
literal|01
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tnot present\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|NOTOK
return|;
block|}
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|addr
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|tmpfil
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|sender
expr_stmt|;
break|break;
default|default:
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|tmpfil
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|mailbox
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|home
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|addr
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|sender
expr_stmt|;
break|break;
block|}
name|vec
index|[
literal|0
index|]
operator|=
name|r1bindex
argument_list|(
name|receive
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|usr_pipe
argument_list|(
name|fd
argument_list|,
literal|"rcvmail"
argument_list|,
name|receive
argument_list|,
name|vec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|notdef
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|usr_pipe
parameter_list|(
name|fd
parameter_list|,
name|cmd
parameter_list|,
name|pgm
parameter_list|,
name|vec
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
decl|*
name|pgm
decl_stmt|,
modifier|*
modifier|*
name|vec
decl_stmt|;
end_function

begin_block
block|{
name|int
name|bytes
decl_stmt|,
name|i
decl_stmt|,
name|child_id
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"\tdelivering to pipe \"%s\""
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|fork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|adorn
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
if|if
condition|(
name|fd
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
literal|3
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|closefds
argument_list|(
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|TIOCNOTTY
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
operator|*
name|environ
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
literal|"USER"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
literal|"HOME"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
literal|"SHELL"
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|pgm
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
switch|switch
condition|(
name|setjmp
argument_list|(
name|myctx
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alrmser
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
else|:
literal|100
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
name|bytes
operator|=
literal|100
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|bytes
operator|*
literal|60
operator|+
literal|300
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|pidwait
argument_list|(
name|child_id
argument_list|,
name|OK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MMDFI
if|if
condition|(
name|status
operator|==
name|RP_MOK
operator|||
name|status
operator|==
name|RP_OK
condition|)
name|status
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|MMDFI
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|", wins.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
literal|0xff00
operator|)
operator|==
literal|0xff00
condition|)
name|printf
argument_list|(
literal|", system error\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|pidstatus
argument_list|(
name|status
argument_list|,
name|stdout
argument_list|,
literal|", loses"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|==
literal|0
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
default|default:
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|kill
argument_list|(
name|child_id
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
else|#
directive|else
else|BSD42
operator|(
name|void
operator|)
name|killpg
argument_list|(
name|child_id
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|", timed-out; terminated\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|NOTOK
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|alrmser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|myctx
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|copyinfo
argument_list|(
name|fp
argument_list|,
name|from
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|from
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|from
argument_list|,
literal|"From "
argument_list|,
name|i
operator|=
name|strlen
argument_list|(
literal|"From "
argument_list|)
argument_list|)
condition|)
block|{
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
name|from
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|from
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|cp
operator|-=
literal|24
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|buffer
condition|)
name|cp
operator|=
name|buffer
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|buffer
expr_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
init|;
name|cp
operator|>=
name|buffer
condition|;
name|cp
operator|--
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
else|else
break|break;
name|sender
operator|=
name|buffer
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|copyfile
parameter_list|(
name|qd
parameter_list|,
name|tmpfil
parameter_list|,
name|fold
parameter_list|)
name|int
name|qd
decl_stmt|,
name|fold
decl_stmt|;
specifier|register
name|char
modifier|*
name|tmpfil
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|qfp
decl_stmt|,
modifier|*
name|ffp
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|creat
argument_list|(
name|tmpfil
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|tmpfil
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|!
name|fold
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|qd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|fd1
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
name|you_lose
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
goto|goto
name|you_lose
goto|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd1
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fd1
return|;
block|}
if|if
condition|(
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|qd
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|qfp
operator|=
name|fdopen
argument_list|(
name|fd2
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|fd1
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|ffp
operator|=
name|fdopen
argument_list|(
name|fd2
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|i
operator|=
name|strlen
argument_list|(
literal|"From "
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|qfp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buffer
argument_list|,
literal|"From "
argument_list|,
name|i
argument_list|)
condition|)
name|putc
argument_list|(
literal|'>'
argument_list|,
name|ffp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|ffp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ffp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ffp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ffp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|qfp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd1
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fd1
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
specifier|static
name|void
name|adorn
parameter_list|(
name|what
parameter_list|,
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|cp
init|=
name|invo_name
decl_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
return|return;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|invo_name
operator|=
name|NULL
expr_stmt|;
name|advise
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|invo_name
operator|=
name|cp
expr_stmt|;
block|}
end_block

end_unit

