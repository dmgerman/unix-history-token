begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)spost.c	1.6 (Berkeley) 11/2/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* spost.c - feed messages to sendmail */
end_comment

begin_comment
comment|/*  * (This is a simpler, faster, replacement for "post" for use when "sendmail"  * is the transport system)   */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/aliasbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getfullname
argument_list|()
decl_stmt|,
modifier|*
name|getusr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|uptolow
parameter_list|(
name|c
parameter_list|)
value|(isupper (c) ? tolower (c) : c)
end_define

begin_define
define|#
directive|define
name|SENDMAIL
value|"/usr/lib/sendmail"
end_define

begin_define
define|#
directive|define
name|FCCS
value|10
end_define

begin_comment
comment|/* max number of fccs allowed */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
name|struct
name|swit
name|switches
index|[]
init|=
block|{
define|#
directive|define
name|FILTSW
value|0
literal|"filter filterfile"
block|,
literal|0
block|,
define|#
directive|define
name|NFILTSW
value|1
literal|"nofilter"
block|,
literal|0
block|,
define|#
directive|define
name|FRMTSW
value|2
literal|"format"
block|,
literal|0
block|,
define|#
directive|define
name|NFRMTSW
value|3
literal|"noformat"
block|,
literal|0
block|,
define|#
directive|define
name|REMVSW
value|4
literal|"remove"
block|,
literal|0
block|,
define|#
directive|define
name|NREMVSW
value|5
literal|"noremove"
block|,
literal|0
block|,
define|#
directive|define
name|VERBSW
value|6
literal|"verbose"
block|,
literal|0
block|,
define|#
directive|define
name|NVERBSW
value|7
literal|"noverbose"
block|,
literal|0
block|,
define|#
directive|define
name|WATCSW
value|8
literal|"watch"
block|,
literal|0
block|,
define|#
directive|define
name|NWATCSW
value|9
literal|"nowatch"
block|,
literal|0
block|,
define|#
directive|define
name|HELPSW
value|10
literal|"help"
block|,
literal|4
block|,
define|#
directive|define
name|DEBUGSW
value|11
literal|"debug"
block|,
operator|-
literal|5
block|,
define|#
directive|define
name|DISTSW
value|12
literal|"dist"
block|,
operator|-
literal|4
block|,
comment|/* interface from dist */
define|#
directive|define
name|BACKSW
value|13
literal|"backup"
block|,
literal|0
block|,
define|#
directive|define
name|NBACKSW
value|14
literal|"nobackup"
block|,
literal|0
block|,
define|#
directive|define
name|CHKSW
value|15
literal|"check"
block|,
operator|-
literal|5
block|,
comment|/* interface from whom */
define|#
directive|define
name|NCHKSW
value|16
literal|"nocheck"
block|,
operator|-
literal|7
block|,
comment|/* interface from whom */
define|#
directive|define
name|WHOMSW
value|17
literal|"whom"
block|,
operator|-
literal|4
block|,
comment|/* interface from whom */
define|#
directive|define
name|PUSHSW
value|18
comment|/* fork to sendmail then exit */
literal|"push"
block|,
operator|-
literal|4
block|,
define|#
directive|define
name|NPUSHSW
value|19
comment|/* exec sendmail */
literal|"nopush"
block|,
operator|-
literal|6
block|,
define|#
directive|define
name|ALIASW
value|20
literal|"alias aliasfile"
block|,
literal|0
block|,
define|#
directive|define
name|NALIASW
value|21
literal|"noalias"
block|,
literal|0
block|,
define|#
directive|define
name|WIDTHSW
value|22
literal|"width columns"
block|,
literal|0
block|,
define|#
directive|define
name|LIBSW
value|23
literal|"library directory"
block|,
operator|-
literal|7
block|,
define|#
directive|define
name|ANNOSW
value|24
literal|"idanno number"
block|,
operator|-
literal|6
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|headers
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|HNOP
value|0x0000
comment|/* just used to keep .set around */
define|#
directive|define
name|HBAD
value|0x0001
comment|/* bad header - don't let it through */
define|#
directive|define
name|HADR
value|0x0002
comment|/* header has an address field */
define|#
directive|define
name|HSUB
value|0x0004
comment|/* Subject: header */
define|#
directive|define
name|HTRY
value|0x0008
comment|/* try to send to addrs on header */
define|#
directive|define
name|HBCC
value|0x0010
comment|/* don't output this header */
define|#
directive|define
name|HMNG
value|0x0020
comment|/* mung this header */
define|#
directive|define
name|HNGR
value|0x0040
comment|/* no groups allowed in this header */
define|#
directive|define
name|HFCC
value|0x0080
comment|/* FCC: type header */
define|#
directive|define
name|HNIL
value|0x0100
comment|/* okay for this header not to have addrs */
define|#
directive|define
name|HIGN
value|0x0200
comment|/* ignore this header */
name|unsigned
name|int
name|set
decl_stmt|;
define|#
directive|define
name|MFRM
value|0x0001
comment|/* we've seen a From: */
define|#
directive|define
name|MDAT
value|0x0002
comment|/* we've seen a Date: */
define|#
directive|define
name|MRFM
value|0x0004
comment|/* we've seen a Resent-From: */
define|#
directive|define
name|MVIS
value|0x0008
comment|/* we've seen sighted addrs */
define|#
directive|define
name|MINV
value|0x0010
comment|/* we've seen blind addrs */
define|#
directive|define
name|MRDT
value|0x0020
comment|/* we've seen a Resent-Date: */
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|headers
name|NHeaders
index|[]
init|=
block|{
literal|"Return-Path"
block|,
name|HBAD
block|,
name|NULL
block|,
literal|"Received"
block|,
name|HBAD
block|,
name|NULL
block|,
literal|"Reply-To"
block|,
name|HADR
operator||
name|HNGR
block|,
name|NULL
block|,
literal|"From"
block|,
name|HADR
operator||
name|HNGR
block|,
name|MFRM
block|,
literal|"Sender"
block|,
name|HADR
operator||
name|HBAD
block|,
name|NULL
block|,
literal|"Date"
block|,
name|HNOP
block|,
name|MDAT
block|,
literal|"Subject"
block|,
name|HSUB
block|,
name|NULL
block|,
literal|"To"
block|,
name|HADR
operator||
name|HTRY
block|,
name|MVIS
block|,
literal|"cc"
block|,
name|HADR
operator||
name|HTRY
block|,
name|MVIS
block|,
literal|"Bcc"
block|,
name|HADR
operator||
name|HTRY
operator||
name|HBCC
operator||
name|HNIL
block|,
name|MINV
block|,
literal|"Message-Id"
block|,
name|HBAD
block|,
name|NULL
block|,
literal|"Fcc"
block|,
name|HFCC
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|headers
name|RHeaders
index|[]
init|=
block|{
literal|"Resent-Reply-To"
block|,
name|HADR
operator||
name|HNGR
block|,
name|NULL
block|,
literal|"Resent-From"
block|,
name|HADR
operator||
name|HNGR
block|,
name|MRFM
block|,
literal|"Resent-Sender"
block|,
name|HADR
operator||
name|HBAD
block|,
name|NULL
block|,
literal|"Resent-Date"
block|,
name|HNOP
block|,
name|MRDT
block|,
literal|"Resent-Subject"
block|,
name|HSUB
block|,
name|NULL
block|,
literal|"Resent-To"
block|,
name|HADR
operator||
name|HTRY
block|,
name|MVIS
block|,
literal|"Resent-cc"
block|,
name|HADR
operator||
name|HTRY
block|,
name|MVIS
block|,
literal|"Resent-Bcc"
block|,
name|HADR
operator||
name|HTRY
operator||
name|HBCC
block|,
name|MINV
block|,
literal|"Resent-Message-Id"
block|,
name|HBAD
block|,
name|NULL
block|,
literal|"Resent-Fcc"
block|,
name|HFCC
block|,
name|NULL
block|,
literal|"Reply-To"
block|,
name|HADR
block|,
name|NULL
block|,
literal|"Fcc"
block|,
name|HIGN
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|short
name|fccind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into fccfold[] */
end_comment

begin_decl_stmt
specifier|static
name|int
name|badmsg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* message has bad semantics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spell it out */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging post */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rmflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remove temporary file when done */
end_comment

begin_decl_stmt
specifier|static
name|int
name|watch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* watch the delivery process */
end_comment

begin_decl_stmt
specifier|static
name|int
name|backflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rename input file as *.bak when done */
end_comment

begin_decl_stmt
specifier|static
name|int
name|whomflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if just checking addresses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pushflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if going to fork to sendmail */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aliasflg
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if going to process aliases */
end_comment

begin_decl_stmt
specifier|static
name|int
name|outputlinelen
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|msgflags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what we've seen */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|normal
block|,
name|resent
block|}
name|msgstate
init|=
name|normal
enum|;
end_enum

begin_decl_stmt
specifier|static
name|char
name|tmpfil
index|[]
init|=
literal|"/tmp/pstXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|from
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* my network address */
end_comment

begin_decl_stmt
specifier|static
name|char
name|signature
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* my signature */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filter
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the filter for BCC'ing */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subject
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the subject field for BCC'ing */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fccfold
index|[
name|FCCS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* foldernames for FCC'ing */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|headers
modifier|*
name|hdrtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table for the message we're doing */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output (temp) file */
end_comment

begin_comment
comment|/*
comment|MAIN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|state
decl_stmt|,
name|i
decl_stmt|,
name|pid
decl_stmt|,
name|compnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|argp
init|=
name|argv
operator|+
literal|1
decl_stmt|,
modifier|*
name|sargv
index|[
literal|16
index|]
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|,
modifier|*
name|arguments
index|[
name|MAXARGS
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|invo_name
operator|=
name|r1bindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|invo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|invo_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|argp
operator|=
name|copyip
argument_list|(
name|brkstring
argument_list|(
name|cp
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|copyip
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|argp
operator|=
name|arguments
expr_stmt|;
block|}
comment|/*
comment|*/
while|while
condition|(
name|cp
operator|=
operator|*
name|argp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|switches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s unknown"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
case|case
name|HELPSW
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [switches] file"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|DEBUGSW
case|:
name|debug
operator|++
expr_stmt|;
continue|continue;
case|case
name|DISTSW
case|:
name|msgstate
operator|=
name|resent
expr_stmt|;
continue|continue;
case|case
name|WHOMSW
case|:
name|whomflg
operator|++
expr_stmt|;
continue|continue;
case|case
name|FILTSW
case|:
if|if
condition|(
operator|!
operator|(
name|filter
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|filter
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NFILTSW
case|:
name|filter
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|REMVSW
case|:
name|rmflg
operator|++
expr_stmt|;
continue|continue;
case|case
name|NREMVSW
case|:
name|rmflg
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|BACKSW
case|:
name|backflg
operator|++
expr_stmt|;
continue|continue;
case|case
name|NBACKSW
case|:
name|backflg
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|VERBSW
case|:
name|verbose
operator|++
expr_stmt|;
continue|continue;
case|case
name|NVERBSW
case|:
name|verbose
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|WATCSW
case|:
name|watch
operator|++
expr_stmt|;
continue|continue;
case|case
name|NWATCSW
case|:
name|watch
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|PUSHSW
case|:
name|pushflg
operator|++
expr_stmt|;
continue|continue;
case|case
name|NPUSHSW
case|:
name|pushflg
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|ALIASW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasflg
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|alias
argument_list|(
name|AliasFile
argument_list|)
expr_stmt|;
comment|/* load default aka's */
name|aliasflg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|=
name|alias
argument_list|(
name|cp
argument_list|)
operator|)
operator|!=
name|AK_OK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"aliasing error in file %s - %s"
argument_list|,
name|cp
argument_list|,
name|akerror
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NALIASW
case|:
name|aliasflg
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|WIDTHSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|outputlinelen
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputlinelen
operator|<=
literal|10
condition|)
name|outputlinelen
operator|=
literal|72
expr_stmt|;
continue|continue;
case|case
name|LIBSW
case|:
case|case
name|ANNOSW
case|:
comment|/* -library& -idanno switch ignored */
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|msg
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"only one message at a time!"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|cp
expr_stmt|;
block|}
comment|/*
comment|*/
if|if
condition|(
name|aliasflg
operator|<
literal|0
condition|)
name|alias
argument_list|(
name|AliasFile
argument_list|)
expr_stmt|;
comment|/* load default aka's */
if|if
condition|(
operator|!
name|msg
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [switches] file"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|msg
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|msg
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
name|start_headers
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|verbose
operator|++
expr_stmt|;
name|out
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|tmpfil
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to create"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tmpfil
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
name|hdrtab
operator|=
operator|(
name|msgstate
operator|==
name|normal
operator|)
condition|?
name|NHeaders
else|:
name|RHeaders
expr_stmt|;
for|for
control|(
name|compnum
operator|=
literal|1
operator|,
name|state
operator|=
name|FLD
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
name|compnum
operator|++
expr_stmt|;
name|putfmt
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FLDPLUS
case|:
name|compnum
operator|++
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|putfmt
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|BODY
case|:
name|finish_headers
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|whomflg
operator|==
literal|0
condition|)
while|while
condition|(
name|state
operator|==
name|BODY
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FILEEOF
case|:
name|finish_headers
argument_list|(
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"message format error in component #%d"
argument_list|,
name|compnum
argument_list|)
expr_stmt|;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"getfld() returned %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*
comment|*/
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|backflg
operator|&&
operator|!
name|whomflg
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|m_backup
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|msg
argument_list|,
name|buf
argument_list|)
operator|==
name|NOTOK
condition|)
name|advise
argument_list|(
name|buf
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|file
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
comment|/*      * re-open the temp file, unlink it and exec sendmail, giving it      * the msg temp file as std in.      */
if|if
condition|(
name|freopen
argument_list|(
name|tmpfil
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"can't reopen for sendmail"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmflg
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|argp
operator|=
name|sargv
expr_stmt|;
operator|*
name|argp
operator|++
operator|=
literal|"send-mail"
expr_stmt|;
operator|*
name|argp
operator|++
operator|=
literal|"-m"
expr_stmt|;
comment|/* send to me too */
operator|*
name|argp
operator|++
operator|=
literal|"-t"
expr_stmt|;
comment|/* read msg for recipients */
operator|*
name|argp
operator|++
operator|=
literal|"-i"
expr_stmt|;
comment|/* don't stop on "." */
if|if
condition|(
name|whomflg
condition|)
operator|*
name|argp
operator|++
operator|=
literal|"-bv"
expr_stmt|;
if|if
condition|(
name|watch
operator|||
name|verbose
condition|)
operator|*
name|argp
operator|++
operator|=
literal|"-v"
expr_stmt|;
operator|*
name|argp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pushflg
operator|&&
operator|!
operator|(
name|watch
operator|||
name|verbose
operator|)
condition|)
block|{
comment|/* fork to a child to run sendmail */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
name|NOTOK
case|:
name|fprintf
argument_list|(
name|verbose
condition|?
name|stdout
else|:
name|stderr
argument_list|,
literal|"%s: can't fork to %s\n"
argument_list|,
name|invo_name
argument_list|,
name|SENDMAIL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
comment|/* we're the child .. */
break|break;
default|default:
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|execv
argument_list|(
name|SENDMAIL
argument_list|,
name|sargv
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|SENDMAIL
argument_list|,
literal|"can't exec"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|DRAFT GENERATION */
end_comment

begin_expr_stmt
specifier|static
name|putfmt
argument_list|(
argument|name
argument_list|,
argument|str
argument_list|,
argument|out
argument_list|)
name|char
operator|*
name|name
operator|,
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|count
decl_stmt|,
name|grp
decl_stmt|,
name|i
decl_stmt|,
name|keep
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|qp
decl_stmt|,
name|namep
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|headers
modifier|*
name|hdr
decl_stmt|;
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
operator|||
operator|*
name|str
operator|==
literal|'\t'
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|get_header
argument_list|(
name|name
argument_list|,
name|hdrtab
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdr
operator|=
operator|&
name|hdrtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|HIGN
condition|)
return|return;
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|HBAD
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"illegal header line -- %s:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|badmsg
operator|++
expr_stmt|;
return|return;
block|}
name|msgflags
operator||=
name|hdr
operator|->
name|set
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|HSUB
condition|)
name|subject
operator|=
name|subject
condition|?
name|add
argument_list|(
name|str
argument_list|,
name|add
argument_list|(
literal|"\t"
argument_list|,
name|subject
argument_list|)
argument_list|)
else|:
name|getcpy
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|HFCC
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|pp
operator|=
name|str
init|;
name|cp
operator|=
name|index
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
condition|;
name|pp
operator|=
name|cp
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|NULL
expr_stmt|;
name|insert_fcc
argument_list|(
name|hdr
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
name|insert_fcc
argument_list|(
name|hdr
argument_list|,
name|pp
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|HBCC
condition|)
block|{
name|insert_bcc
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|notdef
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\n'
operator|&&
operator|*
name|str
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|aliasflg
operator|&&
name|hdr
operator|->
name|flags
operator|&
name|HTRY
condition|)
block|{
comment|/* this header contains address(es) that we have to do 	     * alias expansion on.  Because of the saved state in 	     * getname we have to put all the addresses into a list. 	     * We then let putadr munch on that list, possibly 	     * expanding aliases. 	     */
specifier|register
name|struct
name|mailname
modifier|*
name|f
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|mailname
modifier|*
name|mp
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|str
argument_list|)
condition|)
block|{
name|mp
operator|=
name|getm
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_HOST
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|mp
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_next
operator|=
name|f
operator|->
name|m_next
expr_stmt|;
name|f
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|f
operator|=
name|mp
expr_stmt|;
block|}
block|}
name|f
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|putadr
argument_list|(
name|name
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|start_headers
argument_list|()
block|{
name|char
operator|*
name|cp
block|;
name|char
name|sigbuf
index|[
name|BUFSIZ
index|]
block|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|from
argument_list|,
name|getusr
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getfullname
argument_list|()
operator|)
operator|&&
operator|*
name|cp
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sigbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|signature
argument_list|,
literal|"%s<%s>"
argument_list|,
name|sigbuf
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|signature
argument_list|,
literal|"%s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
end_else

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_macro
unit|static
name|finish_headers
argument_list|(
argument|out
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|msgstate
condition|)
block|{
case|case
name|normal
case|:
if|if
condition|(
operator|!
operator|(
name|msgflags
operator|&
name|MDAT
operator|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|dtimenow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgflags
operator|&
name|MFRM
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Sender: %s\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"From: %s\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|!
operator|(
name|msgflags
operator|&
name|MVIS
operator|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Bcc: Blind Distribution List: ;\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
break|break;
case|case
name|resent
case|:
if|if
condition|(
operator|!
operator|(
name|msgflags
operator|&
name|MRDT
operator|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Resent-Date: %s\n"
argument_list|,
name|dtimenow
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgflags
operator|&
name|MRFM
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Resent-Sender: %s\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Resent-From: %s\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|!
operator|(
name|msgflags
operator|&
name|MVIS
operator|)
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Resent-Bcc: Blind Re-Distribution List: ;\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
break|break;
block|}
if|if
condition|(
name|badmsg
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"re-format message and try again"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|get_header
parameter_list|(
name|header
parameter_list|,
name|table
parameter_list|)
name|char
modifier|*
name|header
decl_stmt|;
name|struct
name|headers
modifier|*
name|table
decl_stmt|;
block|{
name|struct
name|headers
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|table
init|;
name|h
operator|->
name|value
condition|;
name|h
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|header
argument_list|,
name|h
operator|->
name|value
argument_list|)
condition|)
return|return
operator|(
name|h
operator|-
name|table
operator|)
return|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* output the address list for header "name".  The address list  * is a linked list of mailname structs.  "nl" points to the head  * of the list.  Alias substitution should be done on nl.  */
end_comment

begin_expr_stmt
specifier|static
name|putadr
argument_list|(
argument|name
argument_list|,
argument|nl
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mailname
modifier|*
name|nl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp2
decl_stmt|;
specifier|register
name|int
name|linepos
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|linepos
operator|=
name|namelen
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|nl
init|;
name|mp
condition|;
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_nohost
condition|)
block|{
comment|/* a local name - see if it's an alias */
name|cp
operator|=
name|akvalue
argument_list|(
name|mp
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|mp
operator|->
name|m_mbox
condition|)
comment|/* wasn't an alias - use what the user typed */
name|linepos
operator|=
name|putone
argument_list|(
name|mp
operator|->
name|m_text
argument_list|,
name|linepos
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
else|else
comment|/* an alias - expand it */
while|while
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|mp2
operator|=
name|getm
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_HOST
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|akvisible
argument_list|()
condition|)
block|{
name|mp2
operator|->
name|m_pers
operator|=
name|getcpy
argument_list|(
name|mp
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
name|linepos
operator|=
name|putone
argument_list|(
name|adrformat
argument_list|(
name|mp2
argument_list|)
argument_list|,
name|linepos
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linepos
operator|=
name|putone
argument_list|(
name|mp2
operator|->
name|m_text
argument_list|,
name|linepos
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
name|mnfree
argument_list|(
name|mp2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not a local name - use what the user typed */
name|linepos
operator|=
name|putone
argument_list|(
name|mp
operator|->
name|m_text
argument_list|,
name|linepos
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
name|mp2
operator|=
name|mp
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
name|mnfree
argument_list|(
name|mp2
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|putone
parameter_list|(
name|adr
parameter_list|,
name|pos
parameter_list|,
name|indent
parameter_list|)
specifier|register
name|char
modifier|*
name|adr
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|adr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|len
operator|>
name|outputlinelen
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|",\n%*s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pos
operator|=
name|indent
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|>
name|indent
condition|)
block|{
name|fputs
argument_list|(
literal|", "
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
block|}
name|fputs
argument_list|(
name|adr
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
operator|(
name|pos
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|insert_fcc
argument_list|(
argument|hdr
argument_list|,
argument|pp
argument_list|)
expr|struct
name|headers
operator|*
name|hdr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|pp
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
for|for
control|(
name|pp
operator|+=
name|strlen
argument_list|(
name|pp
argument_list|)
operator|-
literal|1
init|;
name|pp
operator|>
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|pp
argument_list|)
condition|;
name|pp
operator|--
control|)
continue|continue;
if|if
condition|(
name|pp
operator|>=
name|cp
condition|)
operator|*
operator|++
name|pp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|fccind
operator|>=
name|FCCS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"too many %ss"
argument_list|,
name|hdr
operator|->
name|value
argument_list|)
expr_stmt|;
name|fccfold
index|[
name|fccind
operator|++
index|]
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*
comment|BCC GENERATION */
end_comment

begin_expr_stmt
specifier|static
name|make_bcc_file
argument_list|()
block|{
name|int
name|fd
block|,
name|i
block|,
name|child_id
block|,
name|status
block|;
name|char
operator|*
name|vec
index|[
literal|6
index|]
block|;
name|FILE
operator|*
name|in
block|,
operator|*
name|out
block|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|bccfil
argument_list|)
block|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|bccfil
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|bccfil
argument_list|,
literal|"unable to create"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|bccfil
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|dtimenow
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"From: %s\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|subject
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Subject: %s"
argument_list|,
name|subject
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"BCC:\n\n------- Blind-Carbon-Copy\n\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|filter
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmpfil
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to re-open"
argument_list|)
expr_stmt|;
name|cpydgst
argument_list|(
name|fd
argument_list|,
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|,
name|tmpfil
argument_list|,
name|bccfil
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vec
index|[
literal|0
index|]
operator|=
name|r1bindex
argument_list|(
name|mhlproc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"vfork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
name|dup2
argument_list|(
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|vec
index|[
name|i
operator|++
index|]
operator|=
literal|"-forward"
expr_stmt|;
name|vec
index|[
name|i
operator|++
index|]
operator|=
literal|"-form"
expr_stmt|;
name|vec
index|[
name|i
operator|++
index|]
operator|=
name|filter
expr_stmt|;
name|vec
index|[
name|i
operator|++
index|]
operator|=
name|tmpfil
expr_stmt|;
name|vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|execvp
argument_list|(
name|mhlproc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|mhlproc
argument_list|,
literal|"unable to exec"
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|status
operator|=
name|pidwait
argument_list|(
name|child_id
argument_list|,
name|OK
argument_list|)
condition|)
name|admonish
argument_list|(
name|NULL
argument_list|,
literal|"%s lost (status=0%o)"
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_if

begin_expr_stmt
name|fseek
argument_list|(
name|out
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n------- End of Blind-Carbon-Copy\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
endif|notdef
end_endif

begin_comment
comment|/*
comment|FCC INTERACTION */
end_comment

begin_macro
unit|static
name|file
argument_list|(
argument|path
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fccind
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fccind
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|whomflg
condition|)
name|printf
argument_list|(
literal|"Fcc: %s\n"
argument_list|,
name|fccfold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|fcc
argument_list|(
name|path
argument_list|,
name|fccfold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fcc
argument_list|(
argument|file
argument_list|,
argument|folder
argument_list|)
name|char
operator|*
name|file
operator|,
operator|*
name|folder
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|child_id
decl_stmt|,
name|status
decl_stmt|;
name|char
name|fold
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%sFcc: %s\n"
argument_list|,
name|msgstate
operator|==
name|resent
condition|?
literal|"Resent-"
else|:
literal|""
argument_list|,
name|folder
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
if|if
condition|(
operator|!
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %sFcc %s: "
argument_list|,
name|msgstate
operator|==
name|resent
condition|?
literal|"Resent-"
else|:
literal|""
argument_list|,
name|folder
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|verbose
condition|?
name|stdout
else|:
name|stderr
argument_list|,
literal|"no forks, so not ok\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fold
argument_list|,
literal|"%s%s"
argument_list|,
operator|*
name|folder
operator|==
literal|'+'
operator|||
operator|*
name|folder
operator|==
literal|'@'
condition|?
literal|""
else|:
literal|"+"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|fileproc
argument_list|,
name|r1bindex
argument_list|(
name|fileproc
argument_list|,
literal|'/'
argument_list|)
argument_list|,
literal|"-link"
argument_list|,
literal|"-file"
argument_list|,
name|file
argument_list|,
name|fold
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|status
operator|=
name|pidwait
argument_list|(
name|child_id
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %sFcc %s: "
argument_list|,
name|msgstate
operator|==
name|resent
condition|?
literal|"Resent-"
else|:
literal|""
argument_list|,
name|folder
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|verbose
condition|?
name|stdout
else|:
name|stderr
argument_list|,
literal|" errored (0%o)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|TERMINATION */
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_expr_stmt
specifier|static
name|die
argument_list|(
argument|what
argument_list|,
argument|fmt
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|)
name|char
operator|*
name|what
operator|,
operator|*
name|fmt
operator|,
operator|*
name|a
operator|,
operator|*
name|b
operator|,
operator|*
name|c
operator|,
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|adios
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

