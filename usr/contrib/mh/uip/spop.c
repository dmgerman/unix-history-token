begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|SPOP
end_ifndef

begin_comment
comment|/* sbboards.c - MH style mailer to write to a ZOTnet BBoard */
end_comment

begin_else
else|#
directive|else
else|SPOP
end_else

begin_comment
comment|/* spop.c - MH style mailer to write to a POP subscriber */
end_comment

begin_endif
endif|#
directive|endif
endif|SPOP
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SPOP
end_ifndef

begin_comment
comment|/* This program acts like the MMDF ch_bboards channel: it does local    delivery to a ZOTnet BBoard and/or addition re-distribution to other    recipients of the BBoard.  This program can function both as a SendMail    mailer and an MH .mh_receive file, depending on whether SENDMTS or    MHMTS is set.  Currently, the MHMTS version of this program does not do    re-distribution.     This program should be used ONLY if you have "bboards on" set in your    MH configuration, and if you have "mts sendmail" or "mts mh" set as well.  */
end_comment

begin_else
else|#
directive|else
else|SPOP
end_else

begin_comment
comment|/* This program acts like the MMDF-II ch_pop channel: it does local    delivery for non-local users.  These users are known as POP subscribers    and use the Post Office Protocol with a POP server in order to access    their maildrop.  */
end_comment

begin_endif
endif|#
directive|endif
endif|SPOP
end_endif

begin_undef
undef|#
directive|undef
name|DISTRIBUTE
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|SENDMTS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SPOP
end_ifndef

begin_define
define|#
directive|define
name|DISTRIBUTE
end_define

begin_endif
endif|#
directive|endif
endif|not SPOP
end_endif

begin_endif
endif|#
directive|endif
endif|SENDMTS
end_endif

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SPOP
end_ifndef

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_endif
endif|#
directive|endif
endif|not SPOP
end_endif

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/bboards.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SYS5
end_ifndef

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_else
else|#
directive|else
else|SYS5
end_else

begin_define
define|#
directive|define
name|EX_CANTCREAT
value|1
end_define

begin_define
define|#
directive|define
name|EX_IOERR
value|1
end_define

begin_define
define|#
directive|define
name|EX_NOINPUT
value|1
end_define

begin_define
define|#
directive|define
name|EX_NOUSER
value|1
end_define

begin_define
define|#
directive|define
name|EX_OK
value|0
end_define

begin_define
define|#
directive|define
name|EX_OSERR
value|1
end_define

begin_define
define|#
directive|define
name|EX_OSFILE
value|1
end_define

begin_define
define|#
directive|define
name|EX_UNAVAILABLE
value|1
end_define

begin_define
define|#
directive|define
name|EX_USAGE
value|1
end_define

begin_endif
endif|#
directive|endif
endif|SYS5
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DISTRIBUTE
end_ifdef

begin_include
include|#
directive|include
file|"../mts/sendmail/smail.h"
end_include

begin_endif
endif|#
directive|endif
endif|DISTRIBUTE
end_endif

begin_define
define|#
directive|define
name|NBB
value|100
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SPOP
end_ifndef

begin_define
define|#
directive|define
name|ENTITY
value|"bboard"
end_define

begin_else
else|#
directive|else
else|SPOP
end_else

begin_define
define|#
directive|define
name|ENTITY
value|"subscriber"
end_define

begin_endif
endif|#
directive|endif
endif|SPOP
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|bb_fderr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bb_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bb_gid
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|dst_rcpt
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SPOP
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|bb_from
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bb_head
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bb_home
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bb_time
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DISTRIBUTE
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|bb_rept
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DISTRIBUTE
end_endif

begin_else
else|#
directive|else
else|SPOP
end_else

begin_define
define|#
directive|define
name|bb_head
value|NULLCP
end_define

begin_endif
endif|#
directive|endif
endif|SPOP
end_endif

begin_decl_stmt
specifier|static
name|struct
name|bboard
modifier|*
name|bb
index|[
name|NBB
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|SYS5
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|envp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|char
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MHMTS
if|if
condition|(
name|argc
operator|!=
literal|5
condition|)
name|adios
argument_list|(
name|EX_USAGE
argument_list|,
name|NULL
argument_list|,
literal|"you lose really big"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MHMTS
name|arginit
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|fd
operator|=
name|copyfile
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|localmail
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DISTRIBUTE
name|distribute
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DISTRIBUTE
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|localmail
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|md
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bp
operator|=
name|bb
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bp
operator|->
name|bb_file
operator|&&
operator|*
name|bp
operator|->
name|bb_file
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SPOP
if|if
condition|(
operator|(
name|md
operator|=
name|mbx_open
argument_list|(
name|bp
operator|->
name|bb_file
argument_list|,
name|bb_uid
argument_list|,
name|bb_gid
argument_list|,
name|BBMODE
argument_list|)
operator|)
else|#
directive|else
else|SPOP
if|if
condition|(
operator|(
name|md
operator|=
name|mbx_open
argument_list|(
name|bp
operator|->
name|bb_file
argument_list|,
name|bb_uid
argument_list|,
name|bb_gid
argument_list|,
name|POMODE
argument_list|)
operator|)
endif|#
directive|endif
endif|SPOP
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|lose
argument_list|(
literal|"unable to open %s"
argument_list|,
name|bp
operator|->
name|bb_file
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|SPOP
if|if
condition|(
name|mbx_init
argument_list|(
name|bp
argument_list|)
operator|!=
name|NOTOK
condition|)
endif|#
directive|endif
endif|not SPOP
operator|(
name|void
operator|)
name|mbx_copy
argument_list|(
name|bp
operator|->
name|bb_file
argument_list|,
name|md
argument_list|,
name|fd
argument_list|,
literal|1
argument_list|,
name|bb_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|bp
operator|->
name|bb_file
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SPOP
end_ifndef

begin_function
specifier|static
name|int
name|mbx_init
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|bboard
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|clear
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|ip
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mbx_Xopen
argument_list|(
name|bp
operator|->
name|bb_info
argument_list|,
name|bb_uid
argument_list|,
name|bb_gid
argument_list|,
name|BBMODE
argument_list|,
operator|&
name|clear
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|lose
argument_list|(
literal|"unable to lock and open %s"
argument_list|,
name|bp
operator|->
name|bb_info
argument_list|)
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|bp
operator|->
name|bb_info
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|lose
argument_list|(
literal|"unable to fdopen %s"
argument_list|,
name|bp
operator|->
name|bb_info
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|ip
operator|=
name|getbbnam
argument_list|(
name|bp
operator|->
name|bb_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|fp
argument_list|,
name|bp
operator|->
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|lose
argument_list|(
literal|"unable to get information on BBoard %s"
argument_list|,
name|bp
operator|->
name|bb_name
argument_list|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bb_time
argument_list|,
name|dtimenow
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bb_head
argument_list|,
literal|"BBoard-ID: %d\nBB-Posted: %s\n"
argument_list|,
name|bp
operator|->
name|bb_maxima
operator|=
operator|++
name|ip
operator|->
name|bb_maxima
argument_list|,
name|bb_time
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n%s\n"
argument_list|,
name|bp
operator|->
name|bb_maxima
argument_list|,
name|bb_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|fp
argument_list|,
name|bp
operator|->
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|not SPOP
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DISTRIBUTE
end_ifdef

begin_expr_stmt
specifier|static
name|distribute
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bp
operator|=
name|bb
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bp
operator|->
name|bb_dist
operator|&&
operator|*
name|bp
operator|->
name|bb_dist
condition|)
break|break;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dst_init
argument_list|()
operator|==
name|NOTOK
condition|)
block|{
name|dst_lose
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bp
operator|=
name|bb
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bp
operator|->
name|bb_dist
operator|&&
operator|*
name|bp
operator|->
name|bb_dist
condition|)
if|if
condition|(
name|dst_adrs
argument_list|(
name|bp
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|dst_lose
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dst_text
argument_list|(
name|fd
argument_list|)
operator|==
name|NOTOK
operator|||
name|dst_end
argument_list|()
operator|==
name|NOTOK
condition|)
name|dst_lose
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dst_init
parameter_list|()
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|retval
operator|=
name|sm_init
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|rp_isbad
argument_list|(
name|retval
operator|=
name|sm_winit
argument_list|(
name|S_MAIL
argument_list|,
name|bb_from
argument_list|)
argument_list|)
condition|)
return|return
name|lose
argument_list|(
literal|"problem initializing SendMail; %s"
argument_list|,
name|rp_string
argument_list|(
name|retval
argument_list|)
argument_list|)
return|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dst_adrs
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|struct
name|bboard
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|getbbdist
argument_list|(
name|bp
argument_list|,
name|dst_rcpt
argument_list|)
condition|)
return|return
name|lose
argument_list|(
literal|"getbbdist failed: %s"
argument_list|,
name|getbberr
argument_list|()
argument_list|)
return|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dst_rcpt
parameter_list|(
name|mbox
parameter_list|,
name|host
parameter_list|)
specifier|register
name|char
modifier|*
name|mbox
decl_stmt|,
decl|*
name|host
decl_stmt|;
end_function

begin_block
block|{
name|int
name|retval
decl_stmt|;
switch|switch
condition|(
name|retval
operator|=
name|sm_wadr
argument_list|(
name|mbox
argument_list|,
name|host
argument_list|,
name|NULLCP
argument_list|)
condition|)
block|{
case|case
name|RP_OK
case|:
return|return
name|OK
return|;
case|case
name|RP_NO
case|:
case|case
name|RP_USER
case|:
operator|(
name|void
operator|)
name|lose
argument_list|(
literal|"%s@%s: loses; %s"
argument_list|,
name|mbox
argument_list|,
name|host
argument_list|,
name|rp_string
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
comment|/* fail-soft */
default|default:
return|return
name|lose
argument_list|(
literal|"%s@%s: unexpected response; %s"
argument_list|,
name|mbox
argument_list|,
name|host
argument_list|,
name|rp_string
argument_list|(
name|retval
argument_list|)
argument_list|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dst_text
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|retval
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|retval
operator|=
name|sm_waend
argument_list|()
argument_list|)
condition|)
return|return
name|lose
argument_list|(
literal|"problem ending addresses; %s"
argument_list|,
name|rp_string
argument_list|(
name|retval
argument_list|)
argument_list|)
return|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|rp_isbad
argument_list|(
name|retval
operator|=
name|sm_wtxt
argument_list|(
name|buffer
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|lose
argument_list|(
literal|"problem writing text; %s"
argument_list|,
name|rp_string
argument_list|(
name|retval
argument_list|)
argument_list|)
return|;
return|return
operator|(
name|i
operator|!=
name|NOTOK
condition|?
name|OK
else|:
name|lose
argument_list|(
literal|"error reading from file"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|dst_end
parameter_list|()
block|{
name|int
name|retval
decl_stmt|;
switch|switch
condition|(
name|retval
operator|=
name|sm_wtend
argument_list|()
condition|)
block|{
case|case
name|RP_OK
case|:
operator|(
name|void
operator|)
name|sm_end
argument_list|(
name|OK
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
case|case
name|RP_NO
case|:
case|case
name|RP_NDEL
case|:
return|return
name|lose
argument_list|(
literal|"posting failed; %s"
argument_list|,
name|rp_string
argument_list|(
name|retval
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|lose
argument_list|(
literal|"unexpected response; %s"
argument_list|,
name|rp_string
argument_list|(
name|retval
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|dst_lose
argument_list|()
block|{
operator|(
name|void
operator|)
name|sm_end
argument_list|(
name|NOTOK
argument_list|)
block|; }
comment|/*
comment|*/
comment|/* VARARGS1 */
specifier|static
name|int
name|lose
argument_list|(
argument|fmt
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|)
name|char
operator|*
name|fmt
operator|,
operator|*
name|a
operator|,
operator|*
name|b
operator|,
operator|*
name|c
operator|,
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|bb_fderr
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|EX_OSERR
argument_list|,
literal|"/dev/null"
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
name|bb_fderr
operator|=
name|copyfile
argument_list|(
name|fd
argument_list|,
name|bb_rept
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
operator|=
name|buffer
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|bp
operator|-
name|buffer
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|bb_fderr
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|adios
argument_list|(
name|EX_IOERR
argument_list|,
name|bb_rept
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|notify
argument_list|(
argument|fd
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|bb_fderr
operator|==
name|NOTOK
condition|)
return|return;
if|if
condition|(
name|rp_isbad
argument_list|(
name|sm_init
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|rp_isbad
argument_list|(
name|sm_winit
argument_list|(
name|S_MAIL
argument_list|,
name|bb_from
argument_list|)
argument_list|)
condition|)
goto|goto
name|sm_err
goto|;
switch|switch
condition|(
name|sm_wadr
argument_list|(
name|bb_from
argument_list|,
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
condition|)
block|{
case|case
name|RP_OK
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bb
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"local-%s-request"
argument_list|,
name|bb
index|[
name|i
index|]
operator|->
name|bb_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_wadr
argument_list|(
name|buffer
argument_list|,
name|LocalName
argument_list|()
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|sm_err
goto|;
block|}
if|if
condition|(
name|rp_isbad
argument_list|(
name|sm_waend
argument_list|()
argument_list|)
condition|)
goto|goto
name|sm_err
goto|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Date: %s\nFrom: %s\nTo: %s\nSubject: BBoards Failure\n\n"
argument_list|,
name|dtimenow
argument_list|()
argument_list|,
name|bb_from
argument_list|,
name|bb_from
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|sm_wtxt
argument_list|(
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|sm_err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bb
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"BBoard %s\n"
argument_list|,
name|bb
index|[
name|i
index|]
operator|->
name|bb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|sm_wtxt
argument_list|(
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|sm_err
goto|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|bb_fderr
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|bb_fderr
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|rp_isbad
argument_list|(
name|sm_wtxt
argument_list|(
name|buffer
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
goto|goto
name|sm_err
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"\n------- Forwarded Message\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|sm_wtxt
argument_list|(
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|)
operator|||
name|encap
argument_list|(
name|fd
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|sm_err
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
literal|"\n------- End of Forwarded Message\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|sm_wtxt
argument_list|(
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|sm_err
goto|;
switch|switch
condition|(
name|sm_wtend
argument_list|()
condition|)
block|{
case|case
name|RP_OK
case|:
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|bb_rept
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_end
argument_list|(
name|OK
argument_list|)
expr_stmt|;
return|return;
default|default:
name|sm_err
label|:
empty_stmt|;
name|adios
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
name|NULLCP
argument_list|,
literal|"failed and unable to post advisory, see %s for details"
argument_list|,
name|bb_rept
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* very similar to sbr/cpydgst.c */
end_comment

begin_define
define|#
directive|define
name|S1
value|0
end_define

begin_define
define|#
directive|define
name|S2
value|1
end_define

begin_define
define|#
directive|define
name|output
parameter_list|(
name|c
parameter_list|)
value|if (bp>= dp) flush (), *bp++ = c; else *bp++ = c
end_define

begin_define
define|#
directive|define
name|flush
parameter_list|()
value|if ((j = bp - outbuf) \&& rp_isbad (sm_wtxt (outbuf, j))) \ 			    return NOTOK; \ 			else \ 			    bp = outbuf
end_define

begin_function
specifier|static
name|int
name|encap
parameter_list|(
name|fd
parameter_list|)
specifier|register
name|int
name|fd
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|state
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|char
name|outbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|bp
operator|=
name|outbuf
operator|)
operator|+
sizeof|sizeof
name|outbuf
expr_stmt|;
for|for
control|(
name|state
operator|=
name|S1
init|;
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|;
control|)
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|buffer
operator|)
operator|+
name|i
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|S1
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|output
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|output
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|S2
expr_stmt|;
comment|/* fall */
case|case
name|S2
case|:
name|output
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|state
operator|=
name|S1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|flush
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|DISTRIBUTE
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DISTRIBUTE
end_ifndef

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
specifier|static
name|int
name|lose
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|,
decl|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_block
block|{
name|adios
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
name|NULLCP
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_endif
endif|#
directive|endif
endif|not DISTRIBUTE
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|arginit
argument_list|(
name|vec
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|vec
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|MHMTS
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
endif|#
directive|endif
endif|MHMTS
name|char
name|addr
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|invo_name
operator|=
name|r1bindex
argument_list|(
operator|*
name|vec
operator|++
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|m_foil
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|invo_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|BBOARDS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|EX_OSFILE
argument_list|,
name|NULLCP
argument_list|,
literal|"no entry for ~%s"
argument_list|,
name|BBOARDS
argument_list|)
expr_stmt|;
else|#
directive|else
else|SPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|POPUID
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|setpwinfo
argument_list|(
name|pw
argument_list|,
name|POPDB
argument_list|,
literal|1
argument_list|)
condition|)
name|adios
argument_list|(
name|EX_OSFILE
argument_list|,
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|pw
condition|?
name|getbberr
argument_list|()
else|:
literal|"POP user-id unknown"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SPOP
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|!=
name|geteuid
argument_list|()
condition|)
ifndef|#
directive|ifndef
name|SPOP
name|adios
argument_list|(
name|EX_OSERR
argument_list|,
name|NULLCP
argument_list|,
literal|"not running setuid to %s"
argument_list|,
name|BBOARDS
argument_list|)
expr_stmt|;
else|#
directive|else
else|SPOP
name|adios
argument_list|(
name|EX_OSERR
argument_list|,
name|NULLCP
argument_list|,
literal|"not running setuid to %s"
argument_list|,
name|POPUID
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SPOP
name|bb_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|bb_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
ifndef|#
directive|ifndef
name|SPOP
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bb_from
argument_list|,
name|adrsprintf
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|LocalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bb_home
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not SPOP
ifdef|#
directive|ifdef
name|MHMTS
name|vec
operator|+=
literal|3
expr_stmt|;
endif|#
directive|endif
endif|MHMTS
if|if
condition|(
operator|*
name|vec
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|EX_USAGE
argument_list|,
name|NULLCP
argument_list|,
literal|"usage: %s %s [%s ...]"
argument_list|,
name|invo_name
argument_list|,
name|ENTITY
argument_list|,
name|ENTITY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|MHMTS
if|if
condition|(
name|ap
operator|=
name|index
argument_list|(
operator|*
name|vec
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
name|vec
operator|=
operator|++
name|ap
expr_stmt|;
endif|#
directive|endif
endif|MHMTS
name|make_lower
argument_list|(
name|addr
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|getbbnam
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|bp
operator|=
name|getbbaka
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|EX_NOUSER
argument_list|,
name|NULLCP
argument_list|,
literal|"no such %s as %s"
argument_list|,
name|ENTITY
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
index|[
name|i
operator|++
index|]
operator|=
name|getbbcpy
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
name|NULLCP
argument_list|,
literal|"insufficient memory on %s"
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|NBB
operator|-
literal|1
condition|)
name|adios
argument_list|(
name|EX_USAGE
argument_list|,
name|NULLCP
argument_list|,
literal|"too many %ss, starting with %s"
argument_list|,
name|ENTITY
argument_list|,
operator|*
name|vec
argument_list|)
expr_stmt|;
block|}
name|bb
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0022
argument_list|)
expr_stmt|;
name|bb_fderr
operator|=
name|NOTOK
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|copyfile
parameter_list|(
name|qd
parameter_list|,
name|tmpfil
parameter_list|)
name|int
name|qd
decl_stmt|;
specifier|register
name|char
modifier|*
name|tmpfil
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|tmpfil
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|EX_CANTCREAT
argument_list|,
name|tmpfil
argument_list|,
literal|"unable to create"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tmpfil
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|EX_NOINPUT
argument_list|,
name|tmpfil
argument_list|,
literal|"unable to re-open"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|qd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|qd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|adios
argument_list|(
name|EX_IOERR
argument_list|,
name|tmpfil
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|EX_IOERR
argument_list|,
literal|"input"
argument_list|,
literal|"error reading"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* VARARGS3 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MHMTS
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
endif|MHMTS
end_endif

begin_function
specifier|static
name|void
name|adios
parameter_list|(
name|code
parameter_list|,
name|what
parameter_list|,
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|,
decl|*
name|fmt
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_function

begin_block
block|{
name|advise
argument_list|(
name|what
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SENDMTS
name|done
argument_list|(
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SENDMTS
ifdef|#
directive|ifdef
name|MHMTS
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MHMTS
block|}
end_block

end_unit

