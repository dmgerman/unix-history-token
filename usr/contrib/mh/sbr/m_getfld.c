begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* m_getfld.c - read/parse a message */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* This module has a long and checkered history.  First, it didn't burst    maildrops correctly because it considered two CTRL-A:s in a row to be    an inter-message delimiter.  It really is four CTRL-A:s followed by a    newline.  Unfortunately, MMDF will convert this delimiter *inside* a    message to a CTRL-B followed by three CTRL-A:s and a newline.  This    caused the old version of m_getfld() to declare eom prematurely.  The    fix was a lot slower than  		c == '\001'&& peekc (iob) == '\001'     but it worked, and to increase generality, UUCP style maildrops could    be parsed as well.  Unfortunately the speed issue finally caught up with    us since this routine is at the very heart of MH.     To speed things up considerably, the routine Eom() was made an auxilary    function called by the macro eom().  Unless we are bursting a maildrop,    the eom() macro returns FALSE saying we aren't at the end of the    message.     The next thing to do is to read the mtstailor file and initialize    delimiter[] and delimlen accordingly...     After mhl was made a built-in in msh, m_getfld() worked just fine    (using m_unknown() at startup).  Until one day: a message which was    the result of a bursting was shown. Then, since the burst boundaries    aren't CTRL-A:s, m_getfld() would blinding plunge on past the boundary.    Very sad.  The solution: introduce m_eomsbr().  This hook gets called    after the end of each line (since testing for eom involves an fseek()).    This worked fine, until one day: a message with no body portion arrived.    Then the  		   while (eom (c = Getc (iob), iob)) 			continue;     loop caused m_getfld() to return FMTERR.  So, that logic was changed to    check for (*eom_action) and act accordingly.     This worked fine, until one day: someone didn't use four CTRL:A's as    their delimiters.  So, the bullet got bit and we read mts.h and    continue to struggle on.  It's not that bad though, since the only time    the code gets executed is when inc (or msh) calls it, and both of these    have already called mts_init().     ------------------------    (Written by Van Jacobson for the mh6 m_getfld, January, 1986):     This routine was accounting for 60% of the cpu time used by most mh    programs.  I spent a bit of time tuning and it now accounts for<10%    of the time used.  Like any heavily tuned routine, it's a bit    complex and you want to be sure you understand everything that it's    doing before you start hacking on it.  Let me try to emphasize    that:  every line in this atrocity depends on every other line,    sometimes in subtle ways.  You should understand it all, in detail,    before trying to change any part.  If you do change it, test the    result thoroughly (I use a hand-constructed test file that exercises    all the ways a header name, header body, header continuation,    header-body separator, body line and body eom can align themselves    with respect to a buffer boundary).  "Minor" bugs in this routine    result in garbaged or lost mail.     If you hack on this and slow it down, I, my children and my    children's children will curse you.     This routine gets used on three different types of files: normal,    single msg files, "packed" unix or mmdf mailboxs (when used by inc)    and packed, directoried bulletin board files (when used by msh).    The biggest impact of different file types is in "eom" testing.  The    code has been carefully organized to test for eom at appropriate    times and at no other times (since the check is quite expensive).    I have tried to arrange things so that the eom check need only be    done on entry to this routine.  Since an eom can only occur after a    newline, this is easy to manage for header fields.  For the msg    body, we try to efficiently search the input buffer to see if    contains the eom delimiter.  If it does, we take up to the    delimiter, otherwise we take everything in the buffer.  (The change    to the body eom/copy processing produced the most noticeable    performance difference, particularly for "inc" and "show".)     There are three qualitatively different things this routine busts    out of a message: field names, field text and msg bodies.  Field    names are typically short (~8 char) and the loop that extracts them    might terminate on a colon, newline or max width.  I considered    using a Vax "scanc" to locate the end of the field followed by a    "bcopy" but the routine call overhead on a Vax is too large for this    to work on short names.  If Berkeley ever makes "inline" part of the    C optimiser (so things like "scanc" turn into inline instructions) a    change here would be worthwhile.     Field text is typically 60 - 100 characters so there's (barely)    a win in doing a routine call to something that does a "locc"    followed by a "bmove".  About 30% of the fields have continuations    (usually the 822 "received:" lines) and each continuation generates    another routine call.  "Inline" would be a big win here, as well.     Messages, as of this writing, seem to come in two flavors: small    (~1K) and long (>2K).  Most messages have 400 - 600 bytes of headers    so message bodies average at least a few hundred characters.    Assuming your system uses reasonably sized stdio buffers (1K or    more), this routine should be able to remove the body in large    (>500 byte) chunks.  The makes the cost of a call to "bcopy"    small but there is a premium on checking for the eom in packed    maildrops.  The eom pattern is always a simple string so we can    construct an efficient pattern matcher for it (e.g., a Vax "matchc"    instruction).  Some thought went into recognizing the start of    an eom that has been split across two buffers.     This routine wants to deal with large chunks of data so, rather    than "getc" into a local buffer, it uses stdio's buffer.  If    you try to use it on a non-buffered file, you'll get what you    deserve.  This routine "knows" that struct FILEs have a _ptr    and a _cnt to describe the current state of the buffer and    it knows that _filbuf ignores the _ptr& _cnt and simply fills    the buffer.  If stdio on your system doesn't work this way, you    may have to make small changes in this routine.        This routine also "knows" that an EOF indication on a stream is    "sticky" (i.e., you will keep getting EOF until you reposition the    stream).  If your system doesn't work this way it is broken and you    should complain to the vendor.  As a consequence of the sticky    EOF, this routine will never return any kind of EOF status when    there is data in "name" or "buf").   */
end_comment

begin_define
define|#
directive|define
name|Getc
parameter_list|(
name|iob
parameter_list|)
value|getc(iob)
end_define

begin_define
define|#
directive|define
name|eom
parameter_list|(
name|c
parameter_list|,
name|iob
parameter_list|)
value|(msg_style != MS_DEFAULT&& \ 			 (((c) == *msg_delim&& m_Eom(c,iob)) ||\ 			  (eom_action&& (*eom_action)(c))))
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|matchc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|locc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|pat_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msg_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* disgusting hack for "inc" so it can 			 * know how many characters were stuffed 			 * in the buffer on the last call (see 			 * comments in uip/scansbr.c) */
end_comment

begin_decl_stmt
name|int
name|msg_style
init|=
name|MS_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The "full" delimiter string for a packed maildrop consists  * of a newline followed by the actual delimiter.  E.g., the  * full string for a Unix maildrop would be: "\n\nFrom ".  * "Fdelim" points to the start of the full string and is used  * in the BODY case of the main routine to search the buffer for  * a possible eom.  Msg_delim points to the first character of  * the actual delim. string (i.e., fdelim+1).  Edelim  * points to the 2nd character of actual delimiter string.  It  * is used in m_Eom because the first character of the string  * has been read and matched before m_Eom is called.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|msg_delim
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fdelim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|delimend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fdelimlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|edelim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|edelimlen
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|eom_action
function_decl|)
parameter_list|()
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|m_getfld
argument_list|(
argument|state
argument_list|,
argument|name
argument_list|,
argument|buf
argument_list|,
argument|bufsz
argument_list|,
argument|iob
argument_list|)
end_macro

begin_decl_stmt
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bufsz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iob
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|msg_count
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
name|FILEEOF
return|;
block|}
if|if
condition|(
name|eom
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|eom_action
condition|)
block|{
comment|/* flush null messages */
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|eom
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
expr_stmt|;
block|}
name|msg_count
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
name|FILEEOF
return|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|FLDEOF
case|:
case|case
name|BODYEOF
case|:
case|case
name|FLD
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
comment|/* we hit the header/body separator */
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|eom
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|eom_action
condition|)
block|{
comment|/* flush null messages */
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|eom
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
expr_stmt|;
block|}
name|msg_count
operator|=
literal|0
expr_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
name|FILEEOF
return|;
block|}
name|state
operator|=
name|BODY
expr_stmt|;
goto|goto
name|body
goto|;
block|}
comment|/* 	     * get the name of this component.  take characters up 	     * to a ':', a newline or NAMESZ-1 characters, whichever 	     * comes first.   	     */
name|cp
operator|=
name|name
expr_stmt|;
name|i
operator|=
name|NAMESZ
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bp
operator|=
name|sp
operator|=
name|iob
operator|->
name|_ptr
operator|-
literal|1
expr_stmt|;
name|j
operator|=
operator|(
name|cnt
operator|=
name|iob
operator|->
name|_cnt
operator|+
literal|1
operator|)
operator|<
name|i
condition|?
name|cnt
else|:
name|i
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
operator|--
name|j
operator|>=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
name|j
operator|=
name|bp
operator|-
name|sp
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|-=
name|j
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|_filbuf
argument_list|(
name|iob
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|*
name|cp
operator|=
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"eof encountered in field \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FMTERR
return|;
block|}
block|}
else|else
block|{
name|iob
operator|->
name|_ptr
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|iob
operator|->
name|_cnt
operator|=
name|cnt
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
break|break;
comment|/* 		 * something went wrong.  possibilities are: 		 *  . hit a newline (error) 		 *  . got more than namesz chars. (error) 		 *  . hit the end of the buffer. (loop) 		 */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cp
operator|=
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"eol encountered in field \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|state
operator|=
name|FMTERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|-=
name|j
operator|)
operator|<=
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"field name \"%s\" exceeds %d bytes"
argument_list|,
name|name
argument_list|,
name|NAMESZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|state
operator|=
name|LENERR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
operator|&&
name|cp
operator|>=
name|name
condition|)
empty_stmt|;
operator|*
operator|++
name|cp
operator|=
name|NULL
expr_stmt|;
comment|/* fall through */
case|case
name|FLDPLUS
case|:
comment|/* 	     * get (more of) the text of a field.  take 	     * characters up to the end of this field (newline 	     * followed by non-blank) or bufsz-1 characters. 	     */
name|cp
operator|=
name|buf
expr_stmt|;
name|i
operator|=
name|bufsz
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnt
operator|=
name|iob
operator|->
name|_cnt
operator|++
expr_stmt|;
name|bp
operator|=
operator|--
name|iob
operator|->
name|_ptr
expr_stmt|;
name|c
operator|=
name|cnt
operator|<
name|i
condition|?
name|cnt
else|:
name|i
expr_stmt|;
while|while
condition|(
name|ep
operator|=
name|locc
argument_list|(
name|c
argument_list|,
name|bp
argument_list|,
literal|'\n'
argument_list|)
condition|)
block|{
comment|/* 		     * if we hit the end of this field, return. 		     */
if|if
condition|(
operator|(
name|j
operator|=
operator|*
operator|++
name|ep
operator|)
operator|!=
literal|' '
operator|&&
name|j
operator|!=
literal|'\t'
condition|)
block|{
name|j
operator|=
name|ep
operator|-
name|iob
operator|->
name|_ptr
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|iob
operator|->
name|_ptr
argument_list|,
name|cp
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|iob
operator|->
name|_ptr
operator|=
name|ep
expr_stmt|;
name|iob
operator|->
name|_cnt
operator|-=
name|j
expr_stmt|;
name|cp
operator|+=
name|j
expr_stmt|;
name|state
operator|=
name|FLD
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|c
operator|-=
name|ep
operator|-
name|bp
expr_stmt|;
name|bp
operator|=
name|ep
expr_stmt|;
block|}
comment|/* 		 * end of input or dest buffer - copy what we've found. 		 */
name|c
operator|+=
name|bp
operator|-
name|iob
operator|->
name|_ptr
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|iob
operator|->
name|_ptr
argument_list|,
name|cp
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|i
operator|-=
name|c
expr_stmt|;
name|cp
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
comment|/* the dest buffer is full */
name|iob
operator|->
name|_cnt
operator|-=
name|c
expr_stmt|;
name|iob
operator|->
name|_ptr
operator|+=
name|c
expr_stmt|;
name|state
operator|=
name|FLDPLUS
expr_stmt|;
break|break;
block|}
comment|/*  		 * There's one character left in the input buffer. 		 * Copy it& fill the buffer.  If the last char 		 * was a newline and the next char is not whitespace, 		 * this is the end of the field.  Otherwise loop. 		 */
operator|--
name|i
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|j
operator|=
operator|*
operator|(
name|iob
operator|->
name|_ptr
operator|+
name|c
operator|)
expr_stmt|;
name|c
operator|=
name|_filbuf
argument_list|(
name|iob
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|'\n'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
operator|--
name|iob
operator|->
name|_ptr
operator|,
operator|++
name|iob
operator|->
name|_cnt
expr_stmt|;
name|state
operator|=
name|FLD
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|BODY
case|:
name|body
label|:
comment|/* 	     * get the message body up to bufsz characters or the 	     * end of the message.  Sleazy hack: if bufsz is negative 	     * we assume that we were called to copy directly into 	     * the output buffer and we don't add an eos. 	     */
name|i
operator|=
operator|(
name|bufsz
operator|<
literal|0
operator|)
condition|?
operator|-
name|bufsz
else|:
name|bufsz
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
operator|--
name|iob
operator|->
name|_ptr
expr_stmt|;
name|cnt
operator|=
operator|++
name|iob
operator|->
name|_cnt
expr_stmt|;
name|c
operator|=
operator|(
name|cnt
operator|<
name|i
condition|?
name|cnt
else|:
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|msg_style
operator|!=
name|MS_DEFAULT
operator|&&
name|c
operator|>
literal|1
condition|)
block|{
comment|/* 		 * packed maildrop - only take up to the (possible) 		 * start of the next message.  This "matchc" should 		 * probably be a Boyer-Moore matcher for non-vaxen, 		 * particularly since we have the alignment table 		 * all built for the end-of-buffer test (next). 		 * But our vax timings indicate that the "matchc" 		 * instruction is 50% faster than a carefully coded 		 * B.M. matcher for most strings.  (So much for elegant 		 * algorithms vs. brute force.)  Since I (currently) 		 * run MH on a vax, we use the matchc instruction. --vj 		 */
if|if
condition|(
name|ep
operator|=
name|matchc
argument_list|(
name|fdelimlen
argument_list|,
name|fdelim
argument_list|,
name|c
argument_list|,
name|bp
argument_list|)
condition|)
name|c
operator|=
name|ep
operator|-
name|bp
operator|+
literal|1
expr_stmt|;
else|else
block|{
comment|/* 		     * There's no delim in the buffer but there may be 		     * a partial one at the end.  If so, we want to leave 		     * it so the "eom" check on the next call picks it up. 		     * Use a modified Boyer-Moore matcher to make this 		     * check relatively cheap.  The first "while" figures 		     * out what position in the pattern matches the last 		     * character in the buffer.  The inner "while" matches 		     * the pattern against the buffer, backwards starting 		     * at that position.  Note that unless the buffer 		     * ends with one of the characters in the pattern 		     * (excluding the first and last), we do only one test. 		     */
name|sp
operator|=
name|delimend
expr_stmt|;
name|ep
operator|=
name|bp
operator|+
name|c
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|pat_map
index|[
operator|*
name|ep
index|]
operator|)
operator|<
name|sp
condition|)
block|{
name|ep
operator|=
name|bp
operator|+
name|c
operator|-
literal|1
expr_stmt|;
name|sp
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|ep
operator|==
operator|*
operator|--
name|cp
operator|&&
name|cp
operator|>
name|fdelim
condition|)
empty_stmt|;
if|if
condition|(
name|cp
operator|==
name|fdelim
condition|)
block|{
if|if
condition|(
operator|*
name|ep
operator|==
operator|*
name|cp
operator|&&
name|ep
operator|>
name|bp
condition|)
name|c
operator|=
operator|(
name|ep
operator|-
name|bp
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|iob
operator|->
name|_cnt
operator|-=
name|c
expr_stmt|;
name|iob
operator|->
name|_ptr
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|bufsz
operator|<
literal|0
condition|)
block|{
name|msg_count
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
name|cp
operator|=
name|buf
operator|+
name|c
expr_stmt|;
break|break;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"m_getfld() called with bogus state of %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
empty_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|msg_count
operator|=
name|cp
operator|-
name|buf
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RPATHS
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|unixbuf
index|[
name|BUFSIZ
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RPATHS
end_endif

begin_function
name|void
name|m_unknown
parameter_list|(
name|iob
parameter_list|)
specifier|register
name|FILE
modifier|*
name|iob
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
name|char
name|text
index|[
literal|10
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|msg_style
operator|=
name|MS_UNKNOWN
expr_stmt|;
comment|/* Figure out what the message delimitter string is for this      * maildrop.  (This used to be part of m_Eom but I didn't like      * the idea of an "if" statement that could only succeed on the      * first call to m_Eom getting executed on each call, i.e., at      * every newline in the message).      *      * If the first line of the maildrop is a Unix "from" line, we say the      * style is UUCP and eat the rest of the line.  Otherwise we say the style      * is MMDF& look for the delimiter string specified when MH was built      * (or from the mtstailor file).      */
name|pos
operator|=
name|ftell
argument_list|(
name|iob
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|text
argument_list|,
sizeof|sizeof
expr|*
name|text
argument_list|,
literal|5
argument_list|,
name|iob
argument_list|)
operator|==
literal|5
operator|&&
name|strncmp
argument_list|(
name|text
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msg_style
operator|=
name|MS_UUCP
expr_stmt|;
name|fdelim
operator|=
literal|"\n\nFrom "
expr_stmt|;
ifndef|#
directive|ifndef
name|RPATHS
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|>=
literal|0
condition|)
empty_stmt|;
else|#
directive|else
else|RPATHS
name|cp
operator|=
name|unixbuf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
endif|RPATHS
block|}
else|else
block|{
comment|/* not a Unix style maildrop */
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|iob
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmdlm2
operator|==
name|NULLCP
operator|||
operator|*
name|mmdlm2
operator|==
name|NULL
condition|)
name|mmdlm2
operator|=
literal|"\001\001\001\001\n"
expr_stmt|;
name|fdelim
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|mmdlm2
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|fdelim
operator|=
literal|'\n'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fdelim
operator|+
literal|1
argument_list|,
name|mmdlm2
argument_list|)
expr_stmt|;
name|msg_style
operator|=
name|MS_MMDF
expr_stmt|;
block|}
name|fdelimlen
operator|=
name|strlen
argument_list|(
name|fdelim
argument_list|)
expr_stmt|;
name|msg_delim
operator|=
name|fdelim
operator|+
literal|1
expr_stmt|;
name|edelim
operator|=
name|msg_delim
operator|+
literal|1
expr_stmt|;
name|edelimlen
operator|=
name|fdelimlen
operator|-
literal|2
expr_stmt|;
name|delimend
operator|=
name|msg_delim
operator|+
name|edelimlen
expr_stmt|;
if|if
condition|(
name|edelimlen
operator|<=
literal|1
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"maildrop delimiter must be at least 2 bytes"
argument_list|)
expr_stmt|;
comment|/*      * build a Boyer-Moore end-position map for the matcher in m_getfld.      * N.B. - we don't match just the first char (since it's the newline      * separator) or the last char (since the matchc would have found it      * if it was a real delim).      */
name|pat_map
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|256
init|;
name|c
operator|--
condition|;
control|)
name|pat_map
index|[
name|c
index|]
operator|=
name|delimend
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|fdelim
operator|+
literal|1
init|;
name|cp
operator|<
name|delimend
condition|;
name|cp
operator|++
control|)
name|pat_map
index|[
operator|*
name|cp
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|msg_style
operator|==
name|MS_MMDF
condition|)
block|{
comment|/* flush extra msg hdrs */
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|eom
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|iob
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
name|void
name|m_eomsbr
function_decl|(
name|action
function_decl|)
name|int
argument_list|(
argument|*action
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|eom_action
operator|=
name|action
condition|)
block|{
name|msg_style
operator|=
name|MS_MSH
expr_stmt|;
operator|*
name|msg_delim
operator|=
literal|0
expr_stmt|;
name|fdelimlen
operator|=
literal|1
expr_stmt|;
name|delimend
operator|=
name|fdelim
expr_stmt|;
block|}
else|else
block|{
name|msg_style
operator|=
name|MS_MMDF
expr_stmt|;
name|msg_delim
operator|=
name|fdelim
operator|+
literal|1
expr_stmt|;
name|fdelimlen
operator|=
name|strlen
argument_list|(
name|fdelim
argument_list|)
expr_stmt|;
name|delimend
operator|=
name|msg_delim
operator|+
name|edelimlen
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* test for msg delimiter string */
end_comment

begin_function
name|int
name|m_Eom
parameter_list|(
name|c
parameter_list|,
name|iob
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|iob
decl_stmt|;
block|{
specifier|register
name|long
name|pos
init|=
literal|0L
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|text
index|[
literal|10
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|RPATHS
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
endif|#
directive|endif
endif|RPATHS
name|pos
operator|=
name|ftell
argument_list|(
name|iob
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|text
argument_list|,
sizeof|sizeof
expr|*
name|text
argument_list|,
name|edelimlen
argument_list|,
name|iob
argument_list|)
operator|)
operator|!=
name|edelimlen
operator|||
name|strncmp
argument_list|(
name|text
argument_list|,
name|edelim
argument_list|,
name|edelimlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|msg_style
operator|==
name|MS_UUCP
condition|)
comment|/* the final newline in the (brain damaged) unix-format 	     * maildrop is part of the delimitter - delete it. 	     */
return|return
literal|1
return|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|iob
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|msg_style
operator|==
name|MS_UUCP
condition|)
block|{
ifndef|#
directive|ifndef
name|RPATHS
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|<
literal|0
condition|)
break|break;
else|#
directive|else
else|RPATHS
name|cp
operator|=
name|unixbuf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|iob
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|>=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
endif|RPATHS
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RPATHS
end_ifdef

begin_function
name|char
modifier|*
name|unixline
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
specifier|static
name|char
name|unixfrom
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|pp
operator|=
name|unixfrom
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|dp
operator|=
name|index
argument_list|(
name|unixbuf
argument_list|,
literal|' '
argument_list|)
condition|)
block|{
while|while
condition|(
name|cp
operator|=
name|index
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'r'
argument_list|)
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"remote from "
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|"%s!"
argument_list|,
name|cp
operator|+
literal|12
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|unixbuf
operator|+
name|strlen
argument_list|(
name|unixbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|-=
literal|25
operator|)
operator|>=
name|dp
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|"%s\n"
argument_list|,
name|unixbuf
argument_list|)
expr_stmt|;
name|unixbuf
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|unixfrom
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|RPATHS
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_if
if|#
directive|if
operator|(
name|vax
operator|&&
operator|!
name|lint
operator|)
end_if

begin_asm
asm|asm(".align 1");
end_asm

begin_asm
asm|asm("_matchc: .word 0");
end_asm

begin_asm
asm|asm("	movq 4(ap),r0");
end_asm

begin_asm
asm|asm("	movq 12(ap),r2");
end_asm

begin_asm
asm|asm("	matchc  r0,(r1),r2,(r3)");
end_asm

begin_asm
asm|asm("	beql 1f");
end_asm

begin_asm
asm|asm("	movl 4(ap),r3");
end_asm

begin_asm
asm|asm("1:	subl3  4(ap),r3,r0");
end_asm

begin_asm
asm|asm("	ret");
end_asm

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|char
modifier|*
name|matchc
parameter_list|(
name|patln
parameter_list|,
name|pat
parameter_list|,
name|strln
parameter_list|,
name|str
parameter_list|)
name|int
name|patln
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
name|int
name|strln
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|es
init|=
name|str
operator|+
name|strln
operator|-
name|patln
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
init|=
name|pat
operator|+
name|patln
decl_stmt|;
specifier|register
name|char
name|pc
init|=
operator|*
name|pat
operator|++
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|pc
operator|!=
operator|*
name|str
operator|++
condition|)
if|if
condition|(
name|str
operator|>
name|es
condition|)
return|return
literal|0
return|;
name|sp
operator|=
name|str
expr_stmt|;
name|pp
operator|=
name|pat
expr_stmt|;
while|while
condition|(
name|pp
operator|<
name|ep
operator|&&
operator|*
name|sp
operator|++
operator|==
operator|*
name|pp
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|pp
operator|>=
name|ep
condition|)
return|return
operator|(
operator|--
name|str
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * Locate character "term" in the next "cnt" characters of "src".  * If found, return its address, otherwise return 0.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|vax
operator|&&
operator|!
name|lint
operator|)
end_if

begin_asm
asm|asm(".align 1");
end_asm

begin_asm
asm|asm("_locc: .word 0");
end_asm

begin_asm
asm|asm("	movq  4(ap),r0");
end_asm

begin_asm
asm|asm("	locc  12(ap),r0,(r1)");
end_asm

begin_asm
asm|asm("	beql  1f");
end_asm

begin_asm
asm|asm("	movl  r1,r0");
end_asm

begin_asm
asm|asm("1:	ret");
end_asm

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|char
modifier|*
name|locc
parameter_list|(
name|cnt
parameter_list|,
name|src
parameter_list|,
name|term
parameter_list|)
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
name|term
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|src
operator|++
operator|!=
name|term
operator|&&
operator|--
name|cnt
operator|>
literal|0
condition|)
empty_stmt|;
return|return
operator|(
name|cnt
operator|>
literal|0
condition|?
operator|--
name|src
else|:
name|NULLCP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bcopy
argument_list|)
end_if

begin_function
name|int
name|bcmp
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b1
decl_stmt|,
decl|*
name|b2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|b1
operator|++
operator|!=
operator|*
name|b2
operator|++
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
name|bcopy
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|,
name|length
argument_list|)
specifier|register
name|char
operator|*
name|b1
operator|,
operator|*
name|b2
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|bzero
argument_list|(
name|b
argument_list|,
name|length
argument_list|)
specifier|register
name|char
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|not BSD42 or SYS5
end_endif

end_unit

