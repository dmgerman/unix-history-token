begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* addrsbr.c - parse addresses 822-style */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/mf.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BERK
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
endif|BERK
end_endif

begin_comment
comment|/* High level parsing of addresses:     The routines in zotnet/mf/mf.c parse the syntactic representations of    addresses.  The routines in uip/addrsbr.c associate semantics with those    addresses.       If #ifdef BERK is in effect, the routines in mf.c aren't called and only    the most rudimentary syntax parse is done.  The parse is not 822-conformant.    This causes problems as there is no semantics associated with the address    at all--it's just a string. (the author of the BERK code disagrees with    the preceding, of course.  BERK solves problems for incoming mail    because it will accept damn near any address.  BERK was intended to be    used when spost is the interface to the mail delivery system which means    all outgoing address interpretation is left to sendmail.  It is possible,    though unlikely, for BERK address parsing to interact poorly with     "post". - van@monet.berkeley.edu).     Instead, if #ifdef DUMB is in effect, a full 822-style parser is called    for syntax recongition.  This breaks each address into its components.    Note however that no semantics are assumed about the parts or their    totality.  This means that implicit hostnames aren't made explicit,    and explicit hostnames aren't expanded to their "official" represenations.     If neither BERK nor DUMB is in effect, then this module does some    high-level thinking about what the addresses are.  If #ifdef MF is in    effect, then MH will deduce UUCP-style addressing masquerading as    822-style addresses.     1. for MMDF systems:  	string%<uucp>@<local>	->	string     2. for non-MMDF systems:  	string@host.<uucp>	->	host!string     3. for any system, an address interpreted relative to the local host:  	string@<uucp>		->	string     For cases (1) and (3) above, the leftmost host is extracted.  If it's not    present, the local host is used.  If #ifdef MF is not in effect or the    tests above fail, the address is considered to be a real 822-style address.     If an explicit host is not present, then MH checks for a bang to indicate    an explicit UUCP-style address.  If so, this is noted.  If not, the host is    defaulted, typically to the local host.  The lack of an explict host is    also noted.     If an explicit 822-style host is present, then MH checks to see if it    can expand this to the official name for the host.  If the hostname is    unknown, the address is so typed.     To summarize, when we're all done, here's what MH knows about the address:     BERK	-	type: 	local 		nohost:	set if no '@' or '!' in mailbox 		text:	exact copy of address 		mbox:	lowercase version of mailbox     DUMB	-	type:	local, uucp, or network 		host:	not locally defaulted, not explicitly expanded 		everything else     other -	type:	local, uucp, network, unknown 		everything else  */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DUMB
argument_list|)
operator|&&
name|defined
argument_list|(
name|SENDMTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BANG
argument_list|)
end_if

begin_define
define|#
directive|define
name|MF
end_define

begin_define
define|#
directive|define
name|UucpChan
parameter_list|()
value|"UUCP"
end_define

begin_endif
endif|#
directive|endif
endif|MF
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BERK
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|adrtext
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|not BERK
end_else

begin_decl_stmt
specifier|static
name|int
name|ingrp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mbox
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|route
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|grp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|note
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|err
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not BERK
end_endif

begin_decl_stmt
specifier|static
name|char
name|adr
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getusr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|char
modifier|*
name|getname
parameter_list|(
name|addrs
parameter_list|)
specifier|register
name|char
modifier|*
name|addrs
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BERK
comment|/*      * Berkeley uses a very simple parser since Sendmail does all the work.      * The only thing that does address parsing if BERK is defined is the      * routine "ismybox" used by "scan"& "repl" to identify the current      * users maildrop.      *      * This routine does essentially the same address interpretation as the      * routine "prescan" in "sendmail".  The intent is that MH should       * make minimum assumptions about address forms since it doesn't      * have access to the information in the sendmail config file      * (God forbid that anything but sendmail has to deal with a sendmail      * config file) and, therefore, hasn't the faintest idea of what will      * or won't be a legal address.      *      * Since this parse is only used by "ismybox" and repl, it just does      * two things: split multiple addr on a line into separate addresses and       * locate the "mailbox" portion of an address.  The parse uses rfc-822      * metacharacters and quoting but is much less restrictive that rfc-822.      * In detail, `,' or eos terminate addresses.  "Empty" addresses      * (e.g., `,,') are ignored.  Double quote ("), backslash, left& right      * paren and left and right angle brackets are metacharacters.  Left&      * right parens must balance as must left& right angle brackets.  Any      * metacharacter may be escaped by preceding it with a backslash.      * Any text between parens is considered a comment and ignored (i.e.,      * only `(', `)' and `\' are metacharacters following a `(').  Text      * between double quotes is considered escaped (i.e., only `"' and      * `\' are metacharacters following a `"').  The `mailbox' portion      * of an address is the non-comment text between angle-brackets if      * the address contains any angle brackets.  Otherwise, it is all the      * non-comment text.  Blanks, tabs& newlines will not be included      * in the mailbox portion of an address unless they are escaped.      */
comment|/* Scanner states */
define|#
directive|define
name|NORMAL
value|(0<<8)
define|#
directive|define
name|QS
value|(1<<8)
comment|/* in quoted string */
define|#
directive|define
name|COM
value|(2<<8)
comment|/* in comment (...) */
define|#
directive|define
name|ERR
value|(3<<8)
comment|/* found an error */
define|#
directive|define
name|EOA
value|(4<<8)
comment|/* end of address */
specifier|static
name|char
modifier|*
name|saved_addr
init|=
name|NULL
decl_stmt|;
comment|/* saved address line ptr */
specifier|static
name|char
modifier|*
name|adr_ptr
init|=
name|NULL
decl_stmt|;
comment|/* where to start looking for 					   next address on line */
specifier|register
name|char
modifier|*
name|nxtout
init|=
name|adr
decl_stmt|;
comment|/* where to put next character of 					   `mailbox' part of address */
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|state
init|=
name|NORMAL
decl_stmt|;
specifier|register
name|char
modifier|*
name|adrcopy
init|=
name|adrtext
decl_stmt|;
comment|/* where to put next character of 					   address */
specifier|register
name|int
name|lbcnt
init|=
literal|0
decl_stmt|;
comment|/* number of unmatched "(" */
specifier|register
name|int
name|lpcnt
init|=
literal|0
decl_stmt|;
comment|/* number of unmatched "<" */
name|err
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|addrs
condition|)
block|{
name|adr_ptr
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|adr_ptr
condition|)
name|addrs
operator|=
name|adr_ptr
expr_stmt|;
else|else
name|addrs
operator|=
name|saved_addr
operator|=
name|getcpy
argument_list|(
name|addrs
argument_list|)
expr_stmt|;
comment|/* skip any leading whitespace or commas. */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|addrs
operator|++
operator|)
operator|==
literal|','
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
empty_stmt|;
operator|*
name|nxtout
operator|=
operator|*
name|adrcopy
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|state
operator|!=
name|EOA
condition|)
block|{
operator|*
name|adrcopy
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|COM
condition|)
operator|*
name|nxtout
operator|++
operator|=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
switch|switch
condition|(
name|state
operator|+
name|c
condition|)
block|{
case|case
name|NORMAL
operator|+
literal|'\n'
case|:
comment|/* discard newlines */
case|case
name|QS
operator|+
literal|'\n'
case|:
case|case
name|COM
operator|+
literal|'\n'
case|:
case|case
name|ERR
operator|+
literal|'\n'
case|:
operator|--
name|nxtout
expr_stmt|;
operator|--
name|adrcopy
expr_stmt|;
break|break;
case|case
name|NORMAL
operator|+
literal|' '
case|:
comment|/* skip unquoted whitespace */
case|case
name|NORMAL
operator|+
literal|'\t'
case|:
operator|--
name|nxtout
expr_stmt|;
break|break;
case|case
name|NORMAL
operator|+
literal|'"'
case|:
comment|/* start quoted string */
name|state
operator|=
name|QS
expr_stmt|;
break|break;
case|case
name|QS
operator|+
literal|'"'
case|:
comment|/* end quoted string */
name|state
operator|=
name|NORMAL
expr_stmt|;
break|break;
case|case
name|NORMAL
operator|+
literal|'<'
case|:
name|nxtout
operator|=
name|adr
expr_stmt|;
comment|/* start over accumulating address */
name|lbcnt
operator|++
expr_stmt|;
break|break;
case|case
name|NORMAL
operator|+
literal|'>'
case|:
operator|--
name|lbcnt
expr_stmt|;
if|if
condition|(
name|lbcnt
operator|<
literal|0
condition|)
block|{
name|state
operator|=
name|ERR
expr_stmt|;
name|err
operator|=
literal|"extra>"
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|nxtout
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|NORMAL
operator|+
literal|'('
case|:
name|state
operator|=
name|COM
expr_stmt|;
operator|--
name|nxtout
expr_stmt|;
case|case
name|COM
operator|+
literal|'('
case|:
name|lpcnt
operator|++
expr_stmt|;
break|break;
case|case
name|COM
operator|+
literal|')'
case|:
operator|--
name|lpcnt
expr_stmt|;
if|if
condition|(
name|lpcnt
operator|<
literal|0
condition|)
block|{
name|state
operator|=
name|ERR
expr_stmt|;
name|err
operator|=
literal|"extra )"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lpcnt
operator|==
literal|0
condition|)
name|state
operator|=
name|NORMAL
expr_stmt|;
break|break;
case|case
name|NORMAL
operator|+
literal|'\\'
case|:
case|case
name|QS
operator|+
literal|'\\'
case|:
case|case
name|COM
operator|+
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|addrs
operator|++
operator|)
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
name|state
operator|=
name|EOA
expr_stmt|;
name|err
operator|=
literal|"illegal \\"
expr_stmt|;
block|}
operator|*
name|adrcopy
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|nxtout
operator|++
operator|=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
break|break;
case|case
name|NORMAL
operator|+
literal|','
case|:
case|case
name|ERR
operator|+
literal|','
case|:
case|case
name|NORMAL
operator|+
literal|'\0'
case|:
case|case
name|ERR
operator|+
literal|'\0'
case|:
name|state
operator|=
name|EOA
expr_stmt|;
if|if
condition|(
name|lbcnt
condition|)
name|err
operator|=
literal|"missing>"
expr_stmt|;
break|break;
case|case
name|COM
operator|+
literal|'\0'
case|:
name|state
operator|=
name|EOA
expr_stmt|;
name|err
operator|=
literal|"missing )"
expr_stmt|;
if|if
condition|(
name|nxtout
operator|==
name|adr
condition|)
name|nxtout
operator|++
expr_stmt|;
break|break;
case|case
name|QS
operator|+
literal|'\0'
case|:
name|state
operator|=
name|EOA
expr_stmt|;
name|err
operator|=
literal|"missing \""
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
name|addrs
operator|++
expr_stmt|;
block|}
comment|/*      * at this point adr contains the `mailbox' part of the address      * in lower case& minus any comment or unquoted whitespace.      * adrtext contains an exact copy of the address and      * addr points to where we should start scanning next time.      */
operator|*
operator|(
name|nxtout
operator|-
literal|1
operator|)
operator|=
operator|*
operator|(
name|adrcopy
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|adr
operator|&&
operator|!
name|err
condition|)
block|{
name|adr_ptr
operator|=
name|addrs
operator|-
literal|1
expr_stmt|;
return|return
name|adrtext
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|saved_addr
argument_list|)
expr_stmt|;
name|adr_ptr
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
else|not BERK
specifier|register
name|struct
name|adrx
modifier|*
name|ap
decl_stmt|;
name|pers
operator|=
name|mbox
operator|=
name|host
operator|=
name|route
operator|=
name|grp
operator|=
name|note
operator|=
name|NULL
expr_stmt|;
name|err
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|=
name|getadrx
argument_list|(
name|addrs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|adr
argument_list|,
name|ap
operator|->
name|text
argument_list|)
expr_stmt|;
name|pers
operator|=
name|ap
operator|->
name|pers
expr_stmt|;
name|mbox
operator|=
name|ap
operator|->
name|mbox
expr_stmt|;
name|host
operator|=
name|ap
operator|->
name|host
expr_stmt|;
name|route
operator|=
name|ap
operator|->
name|path
expr_stmt|;
name|grp
operator|=
name|ap
operator|->
name|grp
expr_stmt|;
name|ingrp
operator|=
name|ap
operator|->
name|ingrp
expr_stmt|;
name|note
operator|=
name|ap
operator|->
name|note
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|err
operator|&&
operator|*
name|ap
operator|->
name|err
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|err
argument_list|,
name|ap
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|adr
return|;
endif|#
directive|endif
endif|not BERK
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BERK
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
endif|BERK
end_endif

begin_function
name|struct
name|mailname
modifier|*
name|getm
parameter_list|(
name|str
parameter_list|,
name|dfhost
parameter_list|,
name|dftype
parameter_list|,
name|wanthost
parameter_list|,
name|eresult
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|eresult
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|dfhost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dftype
decl_stmt|,
name|wanthost
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|BERK
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
ifndef|#
directive|ifndef
name|DUMB
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
endif|#
directive|endif
endif|not DUMB
ifdef|#
directive|ifdef
name|MF
name|char
modifier|*
name|up
init|=
name|UucpChan
argument_list|()
decl_stmt|;
endif|#
directive|endif
endif|MF
endif|#
directive|endif
endif|not BERK
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|eresult
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|eresult
argument_list|,
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wanthost
operator|==
name|AD_HOST
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"bad address '%s' - %s"
argument_list|,
name|str
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|BERK
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
operator|*
name|str
operator|==
literal|'\0'
condition|)
block|{
else|#
directive|else
else|not BERK
if|if
condition|(
name|pers
operator|==
name|NULL
operator|&&
name|mbox
operator|==
name|NULL
operator|&&
name|host
operator|==
name|NULL
operator|&&
name|route
operator|==
name|NULL
operator|&&
name|grp
operator|==
name|NULL
condition|)
block|{
endif|#
directive|endif
endif|not BERK
if|if
condition|(
name|eresult
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|eresult
argument_list|,
literal|"null address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wanthost
operator|==
name|AD_HOST
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"null address '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|BERK
if|if
condition|(
name|mbox
operator|==
name|NULL
operator|&&
name|grp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|eresult
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|eresult
argument_list|,
literal|"no mailbox in address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wanthost
operator|==
name|AD_HOST
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"no mailbox in address '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|dfhost
operator|==
name|NULL
condition|)
block|{
name|dfhost
operator|=
name|LocalName
argument_list|()
expr_stmt|;
name|dftype
operator|=
name|LOCALHOST
expr_stmt|;
block|}
endif|#
directive|endif
endif|not BERK
name|mp
operator|=
operator|(
expr|struct
name|mailname
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|eresult
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|eresult
argument_list|,
literal|"insufficient memory to represent address"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wanthost
operator|==
name|AD_HOST
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"insufficient memory to represent address"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mp
operator|->
name|m_text
operator|=
name|getcpy
argument_list|(
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BERK
name|mp
operator|->
name|m_type
operator|=
name|LOCALHOST
expr_stmt|;
name|mp
operator|->
name|m_mbox
operator|=
name|getcpy
argument_list|(
name|adr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
argument_list|(
name|adr
argument_list|,
literal|'@'
argument_list|)
operator|&&
operator|!
name|index
argument_list|(
name|adr
argument_list|,
literal|'!'
argument_list|)
condition|)
name|mp
operator|->
name|m_nohost
operator|=
literal|1
expr_stmt|;
else|#
directive|else
else|not BERK
if|if
condition|(
name|pers
condition|)
name|mp
operator|->
name|m_pers
operator|=
name|getcpy
argument_list|(
name|pers
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbox
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|m_type
operator|=
name|BADHOST
expr_stmt|;
name|mp
operator|->
name|m_nohost
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|m_ingrp
operator|=
name|ingrp
expr_stmt|;
name|mp
operator|->
name|m_gname
operator|=
name|getcpy
argument_list|(
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|mp
operator|->
name|m_note
operator|=
name|getcpy
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return
name|mp
return|;
block|}
comment|/*
comment|*/
if|if
condition|(
name|host
condition|)
block|{
ifdef|#
directive|ifdef
name|MF
ifdef|#
directive|ifdef
name|MMDFMTS
if|if
condition|(
name|up
operator|&&
name|uleq
argument_list|(
name|host
argument_list|,
name|LocalName
argument_list|()
argument_list|)
operator|&&
operator|(
name|pp
operator|=
name|rindex
argument_list|(
name|mbox
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|&&
name|uleq
argument_list|(
name|up
argument_list|,
name|pp
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* uucpaddr%<uucp>@<local> */
operator|*
name|pp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|get_uucp
goto|;
block|}
else|#
directive|else
else|not MMDFMTS
if|if
condition|(
name|up
operator|&&
operator|(
name|pp
operator|=
name|index
argument_list|(
name|host
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
name|uleq
argument_list|(
name|up
argument_list|,
name|pp
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* uucpaddr@host.<uucp> */
operator|*
name|pp
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_host
operator|=
name|getcpy
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_mbox
operator|=
name|getcpy
argument_list|(
name|mbox
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_type
operator|=
name|UUCPHOST
expr_stmt|;
goto|goto
name|got_host
goto|;
block|}
endif|#
directive|endif
endif|not MMDFMTS
if|if
condition|(
name|up
operator|&&
name|uleq
argument_list|(
name|dfhost
argument_list|,
name|LocalName
argument_list|()
argument_list|)
operator|&&
name|uleq
argument_list|(
name|up
argument_list|,
name|host
argument_list|)
condition|)
block|{
comment|/* uucpaddr@<uucp> [local] */
if|if
condition|(
name|pp
operator|=
name|index
argument_list|(
name|mbox
argument_list|,
literal|'!'
argument_list|)
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_host
operator|=
name|getcpy
argument_list|(
name|mbox
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_mbox
operator|=
name|getcpy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_host
operator|=
name|getcpy
argument_list|(
name|SystemName
argument_list|()
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_mbox
operator|=
name|getcpy
argument_list|(
name|mbox
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_type
operator|=
name|UUCPHOST
expr_stmt|;
goto|goto
name|got_host
goto|;
block|}
endif|#
directive|endif
endif|MF
name|mp
operator|->
name|m_mbox
operator|=
name|getcpy
argument_list|(
name|mbox
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_host
operator|=
name|getcpy
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pp
operator|=
name|index
argument_list|(
name|mbox
argument_list|,
literal|'!'
argument_list|)
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_mbox
operator|=
name|getcpy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_host
operator|=
name|getcpy
argument_list|(
name|mbox
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_type
operator|=
name|UUCPHOST
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_nohost
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|m_mbox
operator|=
name|getcpy
argument_list|(
name|mbox
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMB
if|if
condition|(
name|route
operator|==
name|NULL
operator|&&
name|dftype
operator|==
name|LOCALHOST
condition|)
block|{
name|mp
operator|->
name|m_host
operator|=
name|NULLCP
expr_stmt|;
name|mp
operator|->
name|m_type
operator|=
name|dftype
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|DUMB
block|{
name|mp
operator|->
name|m_host
operator|=
name|route
condition|?
name|NULLCP
else|:
name|getcpy
argument_list|(
name|dfhost
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_type
operator|=
name|route
condition|?
name|NETHOST
else|:
name|dftype
expr_stmt|;
block|}
block|}
goto|goto
name|got_host
goto|;
block|}
comment|/*
comment|*/
if|if
condition|(
name|wanthost
operator|==
name|AD_NHST
condition|)
name|mp
operator|->
name|m_type
operator|=
name|uleq
argument_list|(
name|LocalName
argument_list|()
argument_list|,
name|mp
operator|->
name|m_host
argument_list|)
condition|?
name|LOCALHOST
else|:
name|NETHOST
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMB
else|else
name|mp
operator|->
name|m_type
operator|=
name|uleq
argument_list|(
name|LocalName
argument_list|()
argument_list|,
name|mp
operator|->
name|m_host
argument_list|)
condition|?
name|LOCALHOST
else|:
name|NETHOST
expr_stmt|;
else|#
directive|else
else|not DUMB
elseif|else
if|if
condition|(
name|pp
operator|=
name|OfficialName
argument_list|(
name|mp
operator|->
name|m_host
argument_list|)
condition|)
block|{
name|got_real_host
label|:
empty_stmt|;
name|free
argument_list|(
name|mp
operator|->
name|m_host
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_host
operator|=
name|getcpy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_type
operator|=
name|uleq
argument_list|(
name|LocalName
argument_list|()
argument_list|,
name|mp
operator|->
name|m_host
argument_list|)
condition|?
name|LOCALHOST
else|:
name|NETHOST
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|=
name|index
argument_list|(
name|mp
operator|->
name|m_host
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
operator|*
name|dp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pp
operator|=
name|OfficialName
argument_list|(
name|mp
operator|->
name|m_host
argument_list|)
condition|)
goto|goto
name|got_real_host
goto|;
operator|*
name|dp
operator|=
literal|'.'
expr_stmt|;
block|}
name|mp
operator|->
name|m_type
operator|=
name|BADHOST
expr_stmt|;
block|}
endif|#
directive|endif
endif|not DUMB
name|got_host
label|:
empty_stmt|;
if|if
condition|(
name|route
condition|)
name|mp
operator|->
name|m_path
operator|=
name|getcpy
argument_list|(
name|route
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_ingrp
operator|=
name|ingrp
expr_stmt|;
if|if
condition|(
name|grp
condition|)
name|mp
operator|->
name|m_gname
operator|=
name|getcpy
argument_list|(
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|mp
operator|->
name|m_note
operator|=
name|getcpy
argument_list|(
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not BERK
return|return
name|mp
return|;
block|}
comment|/*
comment|*/
name|void
name|mnfree
parameter_list|(
name|mp
parameter_list|)
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|mp
condition|)
return|return;
if|if
condition|(
name|mp
operator|->
name|m_text
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_pers
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_pers
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_mbox
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_host
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_path
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_gname
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_note
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_note
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MHMTS
if|if
condition|(
name|mp
operator|->
name|m_aka
condition|)
name|free
argument_list|(
name|mp
operator|->
name|m_aka
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MHMTS
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
name|char
modifier|*
name|auxformat
parameter_list|(
name|mp
parameter_list|,
name|extras
parameter_list|)
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|;
name|int
name|extras
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BERK
ifdef|#
directive|ifdef
name|MF
name|char
modifier|*
name|up
init|=
name|UucpChan
argument_list|()
decl_stmt|;
endif|#
directive|endif
endif|MF
specifier|static
name|char
name|addr
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
endif|not BERK
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|BERK
comment|/* this "if" is a crufty hack to handle "visible" aliases */
if|if
condition|(
name|mp
operator|->
name|m_pers
operator|&&
operator|!
name|extras
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s<%s>"
argument_list|,
name|mp
operator|->
name|m_pers
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|mp
operator|->
name|m_text
argument_list|)
expr_stmt|;
else|#
directive|else
else|not BERK
ifdef|#
directive|ifdef
name|MF
if|if
condition|(
name|up
operator|&&
name|mp
operator|->
name|m_type
operator|==
name|UUCPHOST
condition|)
ifdef|#
directive|ifdef
name|MMDFMTS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
literal|"%s!%s%%%s@%s"
argument_list|,
name|mp
operator|->
name|m_host
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|up
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
else|not MMDFMTS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
literal|"%s@%s.%s"
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|mp
operator|->
name|m_host
argument_list|,
name|up
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not MMDFMTS
elseif|else
endif|#
directive|endif
endif|MF
ifdef|#
directive|ifdef
name|DUMB
if|if
condition|(
name|mp
operator|->
name|m_nohost
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|addr
argument_list|,
name|mp
operator|->
name|m_mbox
condition|?
name|mp
operator|->
name|m_mbox
else|:
literal|""
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
endif|DUMB
ifndef|#
directive|ifndef
name|BANG
if|if
condition|(
name|mp
operator|->
name|m_type
operator|!=
name|UUCPHOST
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
name|mp
operator|->
name|m_host
condition|?
literal|"%s%s@%s"
else|:
literal|"%s%s"
argument_list|,
name|mp
operator|->
name|m_path
condition|?
name|mp
operator|->
name|m_path
else|:
literal|""
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|mp
operator|->
name|m_host
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|not BANG
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
literal|"%s!%s"
argument_list|,
name|mp
operator|->
name|m_host
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extras
condition|)
return|return
name|addr
return|;
if|if
condition|(
name|mp
operator|->
name|m_pers
operator|||
name|mp
operator|->
name|m_path
condition|)
if|if
condition|(
name|mp
operator|->
name|m_note
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %s<%s>"
argument_list|,
name|legal_person
argument_list|(
name|mp
operator|->
name|m_pers
condition|?
name|mp
operator|->
name|m_pers
else|:
name|mp
operator|->
name|m_mbox
argument_list|)
argument_list|,
name|mp
operator|->
name|m_note
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s<%s>"
argument_list|,
name|legal_person
argument_list|(
name|mp
operator|->
name|m_pers
condition|?
name|mp
operator|->
name|m_pers
else|:
name|mp
operator|->
name|m_mbox
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_note
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %s"
argument_list|,
name|addr
argument_list|,
name|mp
operator|->
name|m_note
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not BERK
return|return
name|buffer
return|;
block|}
comment|/*
comment|*/
if|#
directive|if
name|defined
argument_list|(
name|BERK
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|DUMB
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MMDFMTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMTP
argument_list|)
operator|)
define|#
directive|define
name|REALLYDUMB
else|#
directive|else
undef|#
directive|undef
name|REALLYDUMB
endif|#
directive|endif
name|char
modifier|*
name|adrsprintf
parameter_list|(
name|local
parameter_list|,
name|domain
parameter_list|)
name|char
modifier|*
name|local
decl_stmt|,
decl|*
name|domain
decl_stmt|;
block|{
specifier|static
name|char
name|addr
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|local
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|REALLYDUMB
return|return
name|getusr
argument_list|()
return|;
else|else
endif|#
directive|endif
endif|REALLYDUMB
name|local
operator|=
name|getusr
argument_list|()
expr_stmt|;
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|REALLYDUMB
return|return
name|local
return|;
else|else
endif|#
directive|endif
endif|REALLYDUMB
name|domain
operator|=
name|LocalName
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|BANG
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
literal|"%s@%s"
argument_list|,
name|local
argument_list|,
name|domain
argument_list|)
expr_stmt|;
else|#
directive|else
else|BANG
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
literal|"%s!%s"
argument_list|,
name|domain
argument_list|,
name|local
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BANG
return|return
name|addr
return|;
block|}
comment|/*
comment|*/
define|#
directive|define
name|W_NIL
value|0x0000
define|#
directive|define
name|W_MBEG
value|0x0001
define|#
directive|define
name|W_MEND
value|0x0002
define|#
directive|define
name|W_MBOX
value|(W_MBEG | W_MEND)
define|#
directive|define
name|W_HBEG
value|0x0004
define|#
directive|define
name|W_HEND
value|0x0008
define|#
directive|define
name|W_HOST
value|(W_HBEG | W_HEND)
define|#
directive|define
name|WBITS
value|"\020\01MBEG\02MEND\03HBEG\04HEND"
name|int
name|ismymbox
parameter_list|(
name|np
parameter_list|)
specifier|register
name|struct
name|mailname
modifier|*
name|np
decl_stmt|;
block|{
name|int
name|oops
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
ifndef|#
directive|ifndef
name|BERK
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
endif|not BERK
specifier|register
name|struct
name|mailname
modifier|*
name|mp
decl_stmt|;
specifier|static
name|char
modifier|*
name|am
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|mailname
name|mq
decl_stmt|;
comment|/* if this is the first call, init. alternate mailboxes list */
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
block|{
name|mq
operator|.
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mq
operator|.
name|m_mbox
operator|=
name|getusr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|am
operator|=
name|m_find
argument_list|(
literal|"alternate-mailboxes"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|am
operator|=
name|getusr
argument_list|()
expr_stmt|;
else|else
block|{
name|mp
operator|=
operator|&
name|mq
expr_stmt|;
name|oops
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|am
argument_list|)
condition|)
if|if
condition|(
operator|(
name|mp
operator|->
name|m_next
operator|=
name|getm
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_NAME
argument_list|,
name|NULLCP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"illegal address: %s"
argument_list|,
name|cp
argument_list|)
operator|,
name|oops
operator|++
expr_stmt|;
else|else
block|{
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
name|mp
operator|->
name|m_type
operator|=
name|W_NIL
expr_stmt|;
ifdef|#
directive|ifdef
name|BERK
comment|/* check for wildcards on the mailbox name and 		       set m_type accordingly. */
name|mp
operator|->
name|m_ingrp
operator|=
name|strlen
argument_list|(
name|mp
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|mp
operator|->
name|m_mbox
operator|)
operator|==
literal|'*'
condition|)
block|{
name|mp
operator|->
name|m_type
operator||=
name|W_MBEG
expr_stmt|;
name|mp
operator|->
name|m_mbox
operator|++
expr_stmt|;
operator|--
name|mp
operator|->
name|m_ingrp
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_mbox
index|[
name|mp
operator|->
name|m_ingrp
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|mp
operator|->
name|m_type
operator||=
name|W_MEND
expr_stmt|;
name|mp
operator|->
name|m_ingrp
operator|--
expr_stmt|;
name|mp
operator|->
name|m_mbox
index|[
name|mp
operator|->
name|m_ingrp
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
else|not BERK
comment|/* owing to screwy munging, wildcarding is a great idea 		       even under #ifndef BERK, so... */
name|mp
operator|->
name|m_type
operator|=
name|W_NIL
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|->
name|m_mbox
operator|==
literal|'*'
condition|)
name|mp
operator|->
name|m_type
operator||=
name|W_MBEG
operator|,
name|mp
operator|->
name|m_mbox
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|mp
operator|->
name|m_mbox
operator|+
name|strlen
argument_list|(
name|mp
operator|->
name|m_mbox
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'*'
condition|)
name|mp
operator|->
name|m_type
operator||=
name|W_MEND
operator|,
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_host
condition|)
block|{
if|if
condition|(
operator|*
name|mp
operator|->
name|m_host
operator|==
literal|'*'
condition|)
name|mp
operator|->
name|m_type
operator||=
name|W_HBEG
operator|,
name|mp
operator|->
name|m_host
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|mp
operator|->
name|m_host
operator|+
name|strlen
argument_list|(
name|mp
operator|->
name|m_host
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'*'
condition|)
name|mp
operator|->
name|m_type
operator||=
name|W_HEND
operator|,
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MHWDEBUG"
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mbox=\"%s\" host=\"%s\" %s\n"
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|mp
operator|->
name|m_host
argument_list|,
name|sprintb
argument_list|(
name|buffer
argument_list|,
operator|(
name|unsigned
operator|)
name|mp
operator|->
name|m_type
argument_list|,
name|WBITS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not BERK
block|}
if|if
condition|(
name|oops
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"please fix the %s: entry in your %s file"
argument_list|,
literal|"alternate-mailboxes"
argument_list|,
name|mh_profile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
comment|/* XXX */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|BERK
name|cp
operator|=
name|np
operator|->
name|m_mbox
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|mq
operator|.
name|m_mbox
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|#
directive|else
else|not BERK
switch|switch
condition|(
name|np
operator|->
name|m_type
condition|)
block|{
case|case
name|NETHOST
case|:
name|len
operator|=
name|strlen
argument_list|(
name|cp
operator|=
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|uprf
argument_list|(
name|np
operator|->
name|m_host
argument_list|,
name|cp
argument_list|)
operator|||
name|np
operator|->
name|m_host
index|[
name|len
index|]
operator|!=
literal|'.'
condition|)
break|break;
goto|goto
name|local_test
goto|;
case|case
name|UUCPHOST
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|np
operator|->
name|m_host
argument_list|,
name|SystemName
argument_list|()
argument_list|)
condition|)
break|break;
comment|/* fall */
case|case
name|LOCALHOST
case|:
name|local_test
label|:
empty_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|np
operator|->
name|m_mbox
argument_list|,
name|mq
operator|.
name|m_text
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
endif|not BERK
ifdef|#
directive|ifdef
name|BERK
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|mq
init|;
name|mp
operator|=
name|mp
operator|->
name|m_next
condition|;
control|)
if|if
condition|(
name|len
operator|>=
name|mp
operator|->
name|m_ingrp
condition|)
switch|switch
condition|(
name|mp
operator|->
name|m_type
condition|)
block|{
case|case
name|W_NIL
case|:
comment|/* no wildcards */
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|W_MBEG
case|:
comment|/* wildcard at beginning */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|cp
index|[
name|len
operator|-
name|mp
operator|->
name|m_ingrp
index|]
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|W_MEND
case|:
comment|/* wildcard at end */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|mp
operator|->
name|m_ingrp
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|W_MBEG
operator||
name|W_MEND
case|:
comment|/* wildcard at beginning& end */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|len
operator|-
name|mp
operator|->
name|m_ingrp
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|cp
index|[
name|i
index|]
argument_list|,
name|mp
operator|->
name|m_mbox
argument_list|,
name|mp
operator|->
name|m_ingrp
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|#
directive|else
else|not BERK
for|for
control|(
name|mp
operator|=
operator|&
name|mq
init|;
name|mp
operator|=
name|mp
operator|->
name|m_next
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|cp
operator|=
name|np
operator|->
name|m_mbox
argument_list|)
operator|)
operator|<
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|pp
operator|=
name|mp
operator|->
name|m_mbox
argument_list|)
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|mp
operator|->
name|m_type
operator|&
name|W_MBOX
condition|)
block|{
case|case
name|W_NIL
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|W_MBEG
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|cp
operator|+
name|len
operator|-
name|i
argument_list|,
name|pp
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|W_MEND
case|:
if|if
condition|(
operator|!
name|uprf
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|W_MBEG
operator||
name|W_MEND
case|:
if|if
condition|(
name|stringdex
argument_list|(
name|pp
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|mp
operator|->
name|m_nohost
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|cp
operator|=
name|np
operator|->
name|m_host
argument_list|)
operator|)
operator|<
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|pp
operator|=
name|mp
operator|->
name|m_host
argument_list|)
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|mp
operator|->
name|m_type
operator|&
name|W_HOST
condition|)
block|{
case|case
name|W_NIL
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|W_HBEG
case|:
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|cp
operator|+
name|len
operator|-
name|i
argument_list|,
name|pp
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|W_HEND
case|:
if|if
condition|(
operator|!
name|uprf
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|W_HBEG
operator||
name|W_HEND
case|:
if|if
condition|(
name|stringdex
argument_list|(
name|pp
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
break|break;
block|}
return|return
literal|1
return|;
block|}
endif|#
directive|endif
endif|not BERK
return|return
literal|0
return|;
block|}
end_block

end_unit

