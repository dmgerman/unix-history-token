begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* popser.c - the POP service */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/bboards.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|NVEC
value|4
end_define

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|myhost
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_enum
specifier|static
enum|enum
name|state
block|{
name|auth1
block|,
name|auth2
block|,
name|trans
block|,
name|update
block|,
name|halt
block|,
name|error
block|}
name|mystate
enum|;
end_enum

begin_decl_stmt
name|int
name|user
argument_list|()
decl_stmt|,
name|pass
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RPOP
end_ifdef

begin_function_decl
name|int
name|rpop
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|RPOP
end_endif

begin_decl_stmt
name|int
name|status
argument_list|()
decl_stmt|,
name|list
argument_list|()
decl_stmt|,
name|retrieve
argument_list|()
decl_stmt|,
name|delete
argument_list|()
decl_stmt|,
name|reset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|top
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_function_decl
name|int
name|xtnd
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|BPOP
end_endif

begin_function_decl
name|int
name|quit
parameter_list|()
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
name|vector
block|{
name|char
modifier|*
name|v_cmd
decl_stmt|;
name|int
name|v_min
decl_stmt|,
name|v_max
decl_stmt|;
name|int
function_decl|(
modifier|*
name|v_vec
function_decl|)
parameter_list|()
function_decl|;
name|enum
name|state
name|v_valid
decl_stmt|;
name|enum
name|state
name|v_win
decl_stmt|,
name|v_lose
decl_stmt|;
block|}
name|vectors
index|[]
init|=
block|{
literal|"user"
block|,
literal|1
block|,
literal|1
block|,
name|user
block|,
name|auth1
block|,
name|auth2
block|,
name|auth1
block|,
literal|"pass"
block|,
literal|1
block|,
literal|1
block|,
name|pass
block|,
name|auth2
block|,
name|trans
block|,
name|auth1
block|,
ifdef|#
directive|ifdef
name|RPOP
literal|"rpop"
block|,
literal|1
block|,
literal|1
block|,
name|rpop
block|,
name|auth2
block|,
name|trans
block|,
name|auth1
block|,
endif|#
directive|endif
endif|RPOP
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|auth1
block|,
name|halt
block|,
name|halt
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|auth2
block|,
name|halt
block|,
name|halt
block|,
literal|"stat"
block|,
literal|0
block|,
literal|0
block|,
name|status
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"list"
block|,
literal|0
block|,
literal|1
block|,
name|list
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"retr"
block|,
literal|1
block|,
literal|1
block|,
name|retrieve
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"dele"
block|,
literal|1
block|,
literal|1
block|,
name|delete
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"noop"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"rset"
block|,
literal|0
block|,
literal|0
block|,
name|reset
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"top"
block|,
literal|2
block|,
literal|2
block|,
name|top
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
ifdef|#
directive|ifdef
name|BPOP
literal|"xtnd"
block|,
literal|1
block|,
literal|2
block|,
name|xtnd
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
endif|#
directive|endif
endif|BPOP
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|quit
block|,
name|trans
block|,
name|halt
block|,
name|halt
block|,
name|NULL
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|vector
modifier|*
name|getvector
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DPOP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pop_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pop_gid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DPOP
end_endif

begin_decl_stmt
specifier|static
name|int
name|rproto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|server
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|username
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|maildrop
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|mtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|xtnded
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|guest_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|guest_gid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bboard
modifier|*
name|BBhead
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bboard
modifier|*
name|BBtail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|BBtime
init|=
literal|0L
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|bboard
modifier|*
name|getbbaux
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|BPOP
end_endif

begin_struct
struct|struct
name|Msg
block|{
comment|/* Msgs[0] contains info for entire maildrop */
name|struct
name|drop
name|m_drop
decl_stmt|;
define|#
directive|define
name|m_id
value|m_drop.d_id
define|#
directive|define
name|m_size
value|m_drop.d_size
define|#
directive|define
name|m_start
value|m_drop.d_start
define|#
directive|define
name|m_stop
value|m_drop.d_stop
name|unsigned
name|m_flags
decl_stmt|;
define|#
directive|define
name|MNULL
value|0x00
define|#
directive|define
name|MDELE
value|0x01
define|#
directive|define
name|MREAD
value|0x02
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|nMsgs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Msg
modifier|*
name|Msgs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nmsgs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dmsgs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRM
value|"."
end_define

begin_define
define|#
directive|define
name|TRMLEN
value|(sizeof TRM - 1)
end_define

begin_define
define|#
directive|define
name|IAC
value|255
end_define

begin_function_decl
name|int
name|pipeser
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|padvise
argument_list|()
decl_stmt|,
name|padios
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|popinit
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BPOP
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_INFO
argument_list|,
literal|"initialize list of BBoards"
argument_list|)
expr_stmt|;
name|BBhead
operator|=
name|BBtail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|getbbaux
argument_list|(
name|NULLCP
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
endif|BPOP
block|}
end_block

begin_macro
name|popassert
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BPOP
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|BBtime
operator|==
name|getbbtime
argument_list|()
condition|)
return|return;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_INFO
argument_list|,
literal|"list of BBoards has changed"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|BBhead
init|;
name|bb
condition|;
name|bb
operator|=
name|bp
control|)
block|{
name|bp
operator|=
name|bb
operator|->
name|bb_next
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_name
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_file
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_archive
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_info
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_map
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_passwd
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_date
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_addr
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_request
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_relay
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_relay
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bb
operator|->
name|bb_aka
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
operator|->
name|bb_aka
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bb
operator|->
name|bb_leader
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
operator|->
name|bb_leader
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bb
operator|->
name|bb_dist
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
operator|->
name|bb_dist
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
argument_list|)
expr_stmt|;
block|}
name|BBhead
operator|=
name|BBtail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|getbbaux
argument_list|(
name|NULLCP
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
endif|BPOP
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|pop
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|priv
argument_list|,
argument|rhost
argument_list|)
end_macro

begin_decl_stmt
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|priv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rhost
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|NVEC
operator|+
literal|1
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DPOP
argument_list|)
operator|||
name|defined
argument_list|(
name|BPOP
argument_list|)
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
endif|defined (DPOP) || defined (BPOP)
specifier|register
name|struct
name|vector
modifier|*
name|v
decl_stmt|;
name|m_foil
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|rproto
operator|=
name|priv
expr_stmt|;
name|hostname
operator|=
name|rhost
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|server
argument_list|,
literal|"%s %s server"
argument_list|,
name|myhost
argument_list|,
name|priv
condition|?
literal|"RPOP"
else|:
literal|"POP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input
operator|=
name|fdopen
argument_list|(
name|in
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|output
operator|=
name|fdopen
argument_list|(
name|out
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* you lose big */
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"%s loses on initialization"
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipeser
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|POPUID
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|setpwinfo
argument_list|(
name|pw
argument_list|,
name|POPDB
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"%s loses on DB initialization -- %s"
argument_list|,
name|server
argument_list|,
name|pw
condition|?
name|getbberr
argument_list|()
else|:
literal|"POP user-id unknown"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pop_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|pop_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
endif|#
directive|endif
endif|DPOP
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|popbbuser
argument_list|)
operator|)
operator|&&
name|pw
operator|->
name|pw_uid
condition|)
block|{
name|guest_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|guest_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
block|}
else|else
name|guest_uid
operator|=
name|guest_gid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|BPOP
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s ready (Comments to: PostMaster@%s)"
argument_list|,
name|server
argument_list|,
name|myhost
argument_list|)
expr_stmt|;
for|for
control|(
name|mystate
operator|=
name|auth1
init|;
name|mystate
operator|!=
name|halt
operator|&&
name|mystate
operator|!=
name|error
condition|;
control|)
switch|switch
condition|(
name|getline
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|input
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
if|if
condition|(
operator|(
name|v
operator|=
name|getvector
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|mystate
operator|=
operator|(
name|v
operator|->
name|v_vec
condition|?
call|(
name|v
operator|->
name|v_vec
call|)
argument_list|(
name|vec
argument_list|)
else|:
name|respond
argument_list|(
name|OK
argument_list|,
name|NULLCP
argument_list|)
operator|)
operator|==
name|OK
condition|?
name|v
operator|->
name|v_win
else|:
name|v
operator|->
name|v_lose
expr_stmt|;
break|break;
case|case
name|NOTOK
case|:
case|case
name|DONE
case|:
name|mystate
operator|=
name|error
expr_stmt|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"%s signing off"
argument_list|,
name|server
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|user
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|make_lower
argument_list|(
name|username
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"password required for %s"
argument_list|,
name|username
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|pass
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|guest
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|DPOP
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
else|#
directive|else
else|DPOP
specifier|register
name|struct
name|bboard
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
endif|DPOP
ifndef|#
directive|ifndef
name|DPOP
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|isguest
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
specifier|static
name|passwd
name|gw
decl_stmt|;
name|gw
operator|.
name|pw_name
operator|=
name|popbbuser
expr_stmt|;
name|gw
operator|.
name|pw_uid
operator|=
name|guest_uid
expr_stmt|;
name|pw
operator|=
operator|&
name|gw
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
name|guest
operator|=
literal|1
expr_stmt|;
goto|goto
name|anonymous
goto|;
block|}
endif|#
directive|endif
endif|BPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|pw
operator|->
name|pw_passwd
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|pw
condition|?
name|pw
operator|->
name|pw_name
else|:
name|username
argument_list|,
name|pw
operator|&&
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
literal|"pop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
else|#
directive|else
else|DPOP
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|isguest
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
specifier|static
name|bboard
name|gw
decl_stmt|;
name|gw
operator|.
name|bb_name
operator|=
name|popbbuser
expr_stmt|;
name|pw
operator|=
operator|&
name|gw
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
name|guest
operator|=
literal|1
expr_stmt|;
goto|goto
name|anonymous
goto|;
block|}
endif|#
directive|endif
endif|BPOP
if|if
condition|(
operator|(
operator|(
name|pw
operator|=
name|getbbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getbbaka
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|*
name|pw
operator|->
name|bb_passwd
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
name|pw
operator|->
name|bb_passwd
argument_list|)
argument_list|,
name|pw
operator|->
name|bb_passwd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|pw
condition|?
name|pw
operator|->
name|bb_name
else|:
name|username
argument_list|,
literal|0
argument_list|,
literal|"pop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
endif|#
directive|endif
endif|DPOP
ifdef|#
directive|ifdef
name|BPOP
name|anonymous
label|:
empty_stmt|;
endif|#
directive|endif
endif|BPOP
ifdef|#
directive|ifdef
name|TRUSTED
if|if
condition|(
name|trusted
argument_list|(
literal|1
argument_list|,
name|hostname
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|myhost
argument_list|,
ifndef|#
directive|ifndef
name|DPOP
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
else|#
directive|else
else|DPOP
name|pw
operator|->
name|bb_name
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
endif|DPOP
literal|"pop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|setup
argument_list|(
name|pw
argument_list|,
name|guest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_expr_stmt
specifier|static
name|isguest
argument_list|()
block|{
name|int
name|i
block|;
specifier|register
name|char
operator|*
name|cp
block|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|;
specifier|register
name|FILE
operator|*
name|fp
block|;
if|if
condition|(
name|strcmp
argument_list|(
name|username
argument_list|,
name|popbbuser
argument_list|)
operator|||
operator|!
name|guest_uid
condition|)
return|return
name|FALSE
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|popbblist
operator|==
name|NULL
operator|||
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|popbblist
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
end_if

begin_expr_stmt
name|i
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|hostname
condition|)
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|hostname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|i
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
endif|BPOP
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RPOP
end_ifdef

begin_function
unit|static
name|int
name|rpop
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DPOP
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
else|#
directive|else
else|DPOP
specifier|register
name|int
name|hostok
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
endif|DPOP
ifndef|#
directive|ifndef
name|DPOP
if|if
condition|(
operator|!
name|rproto
operator|||
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|username
argument_list|,
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|==
name|NOTOK
operator|&&
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no remote directory"
argument_list|)
return|;
if|if
condition|(
name|ruserok
argument_list|(
name|hostname
argument_list|,
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
name|username
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
block|}
else|#
directive|else
else|DPOP
if|if
condition|(
operator|!
name|rproto
operator|||
operator|(
operator|(
name|pw
operator|=
name|getbbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getbbaka
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|username
argument_list|,
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
comment|/*  * hacked by Dave Cohrs Tue Feb  4 14:12:15 CST 1986  *   to allow the hostname to be a list: user@host1,user@host2  *   NOTE: the separator must be a comma -- no spaces are allowed  */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s@%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|pw
operator|->
name|bb_addr
init|;
name|bp
condition|;
name|bp
operator|=
name|cp
control|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|bp
argument_list|,
literal|','
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|hostok
operator|=
name|strcmp
argument_list|(
name|bp
argument_list|,
name|buffer
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|hostok
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|hostok
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|pw
operator|->
name|bb_name
argument_list|,
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
block|}
endif|#
directive|endif
endif|DPOP
ifdef|#
directive|ifdef
name|TRUSTED
if|if
condition|(
name|trusted
argument_list|(
literal|1
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|username
argument_list|,
ifndef|#
directive|ifndef
name|DPOP
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
else|#
directive|else
else|DPOP
literal|0
argument_list|,
endif|#
directive|endif
endif|DPOP
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
endif|#
directive|endif
endif|TRUSTED
return|return
name|setup
argument_list|(
name|pw
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|RPOP
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|setup
parameter_list|(
name|pw
parameter_list|,
name|guest
parameter_list|)
ifndef|#
directive|ifndef
name|DPOP
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
else|#
directive|else
else|DPOP
specifier|register
name|struct
name|bboard
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
endif|DPOP
name|int
name|guest
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|guest
condition|)
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|guest_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|popbbuser
argument_list|,
name|guest_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|guest_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
endif|BPOP
ifndef|#
directive|ifndef
name|DPOP
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
else|#
directive|else
else|DPOP
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|pop_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|POPUID
argument_list|,
name|pop_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|pop_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DPOP
ifdef|#
directive|ifdef
name|BPOP
block|}
endif|#
directive|endif
endif|BPOP
ifndef|#
directive|ifndef
name|DPOP
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|maildrop
argument_list|,
literal|"%s/%s"
argument_list|,
name|mmdfldir
operator|&&
operator|*
name|mmdfldir
condition|?
name|mmdfldir
else|:
name|pw
operator|->
name|pw_dir
argument_list|,
name|mmdflfil
operator|&&
operator|*
name|mmdflfil
condition|?
name|mmdflfil
else|:
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|#
directive|else
else|DPOP
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|maildrop
argument_list|,
name|pw
operator|->
name|bb_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DPOP
if|if
condition|(
name|setupaux
argument_list|(
name|guest
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
name|nmsgs
condition|?
literal|"maildrop has %d message%s (%d octets)"
else|:
literal|"maildrop empty"
argument_list|,
name|nmsgs
argument_list|,
name|nmsgs
operator|!=
literal|1
condition|?
literal|"s"
else|:
name|NULL
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|setupaux
parameter_list|(
name|readonly
parameter_list|)
name|int
name|readonly
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|msgp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|BPOP
name|xtnded
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|BPOP
if|if
condition|(
operator|(
name|dp
operator|=
name|readonly
condition|?
name|fopen
argument_list|(
name|maildrop
argument_list|,
literal|"r"
argument_list|)
else|:
name|lkfopen
argument_list|(
name|maildrop
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|m_gMsgs
argument_list|(
name|msgp
operator|=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|no_mail
goto|;
default|default:
name|nmsgs
operator|=
name|dmsgs
operator|=
literal|0
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to %s maildrop: \"%s\""
argument_list|,
name|readonly
condition|?
literal|"read"
else|:
literal|"lock"
argument_list|,
name|maildrop
argument_list|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|mode
operator|=
call|(
name|int
call|)
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
operator|,
name|mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|msgp
operator|=
name|read_map
argument_list|(
name|maildrop
argument_list|,
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
literal|0600
operator|,
name|mtime
operator|=
literal|0
expr_stmt|;
name|msgp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|msgp
operator|=
name|read_file
argument_list|(
name|msgp
condition|?
name|Msgs
index|[
name|msgp
index|]
operator|.
name|m_stop
else|:
literal|0L
argument_list|,
name|msgp
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|m_gMsgs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|no_mail
label|:
empty_stmt|;
name|dmsgs
operator|=
literal|0
expr_stmt|;
name|nmsgs
operator|=
name|msgp
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_flags
operator|=
name|readonly
condition|?
name|MREAD
else|:
name|MNULL
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
operator|==
literal|0
condition|)
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
operator|=
name|mbx_size
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|+=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|=
name|MNULL
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_map
parameter_list|(
name|file
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|long
name|pos
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|msgp
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|pp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|struct
name|drop
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"read_map (%s, %ld)"
argument_list|,
name|file
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|map_read
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
operator|&
name|rp
argument_list|,
name|debug
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|m_gMsgs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|msgp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|rp
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|msgp
operator|++
operator|,
name|pp
operator|++
control|)
block|{
name|mp
operator|=
operator|&
name|Msgs
index|[
name|msgp
index|]
operator|.
name|m_drop
expr_stmt|;
name|mp
operator|->
name|d_id
operator|=
name|pp
operator|->
name|d_id
expr_stmt|;
name|mp
operator|->
name|d_size
operator|=
name|pp
operator|->
name|d_size
expr_stmt|;
name|mp
operator|->
name|d_start
operator|=
name|pp
operator|->
name|d_start
expr_stmt|;
name|mp
operator|->
name|d_stop
operator|=
name|pp
operator|->
name|d_stop
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|msgp
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_file
parameter_list|(
name|pos
parameter_list|,
name|msgp
parameter_list|)
specifier|register
name|long
name|pos
decl_stmt|;
specifier|register
name|int
name|msgp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|pp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|struct
name|drop
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"read_file (%ld, %d)"
argument_list|,
name|pos
argument_list|,
name|msgp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|mbx_read
argument_list|(
name|dp
argument_list|,
name|pos
argument_list|,
operator|&
name|rp
argument_list|,
name|debug
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|msgp
operator|-
literal|1
operator|)
return|;
name|m_gMsgs
argument_list|(
operator|(
name|msgp
operator|-
literal|1
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|rp
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|msgp
operator|++
operator|,
name|pp
operator|++
control|)
block|{
name|mp
operator|=
operator|&
name|Msgs
index|[
name|msgp
index|]
operator|.
name|m_drop
expr_stmt|;
name|mp
operator|->
name|d_id
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|d_size
operator|=
name|pp
operator|->
name|d_size
expr_stmt|;
name|mp
operator|->
name|d_start
operator|=
name|pp
operator|->
name|d_start
expr_stmt|;
name|mp
operator|->
name|d_stop
operator|=
name|pp
operator|->
name|d_stop
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|msgp
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|m_gMsgs
argument_list|(
argument|n
argument_list|)
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"m_gMsgs (%d) 0x%x %d"
argument_list|,
name|n
argument_list|,
name|Msgs
argument_list|,
name|nMsgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
operator|==
name|NULL
condition|)
block|{
name|nMsgs
operator|=
name|n
operator|+
name|MAXFOLDER
operator|/
literal|2
expr_stmt|;
name|Msgs
operator|=
operator|(
expr|struct
name|Msg
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|nMsgs
operator|+
literal|2
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|Msgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
operator|==
name|NULL
condition|)
name|padios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate Msgs structure"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nMsgs
operator|>=
name|n
condition|)
return|return;
name|nMsgs
operator|=
name|n
operator|+
name|MAXFOLDER
operator|/
literal|2
expr_stmt|;
name|Msgs
operator|=
operator|(
expr|struct
name|Msg
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Msgs
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|nMsgs
operator|+
literal|2
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|Msgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
operator|==
name|NULL
condition|)
name|padios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to reallocate Msgs structure"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|mbx_size
parameter_list|(
name|m
parameter_list|)
specifier|register
name|int
name|m
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|Msgs
index|[
name|m
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
name|Msgs
index|[
name|m
index|]
operator|.
name|m_stop
operator|-
name|Msgs
index|[
name|m
index|]
operator|.
name|m_start
init|;
name|pos
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|pos
operator|--
control|)
if|if
condition|(
name|fgetc
argument_list|(
name|dp
argument_list|)
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|status
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d %d"
argument_list|,
name|nmsgs
operator|-
name|dmsgs
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vec
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
ifndef|#
directive|ifndef
name|BPOP
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
return|;
else|#
directive|else
else|BPOP
return|return
name|respond
argument_list|(
name|OK
argument_list|,
name|xtnded
condition|?
literal|"%d %d %d"
else|:
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_id
argument_list|)
return|;
endif|#
directive|endif
endif|BPOP
block|}
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d message%s (%d octets)"
argument_list|,
name|nmsgs
operator|-
name|dmsgs
argument_list|,
name|nmsgs
operator|-
name|dmsgs
operator|!=
literal|1
condition|?
literal|"s"
else|:
name|NULL
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
operator|)
condition|)
ifndef|#
directive|ifndef
name|BPOP
name|multiline
argument_list|(
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
expr_stmt|;
else|#
directive|else
else|BPOP
name|multiline
argument_list|(
name|xtnded
condition|?
literal|"%d %d %d"
else|:
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BPOP
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|retrieve
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d octets"
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|pos
operator|=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|dp
argument_list|)
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
condition|;
name|pos
operator|+=
call|(
name|long
call|)
argument_list|(
name|cp
operator|-
name|buffer
operator|+
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|delete
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_flags
operator|&
name|MREAD
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"maildrop is read-only"
argument_list|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator||=
name|MDELE
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|-=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
expr_stmt|;
name|dmsgs
operator|++
expr_stmt|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"message %d deleted (%d octets)"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reset
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
block|{
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&=
operator|~
name|MDELE
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|+=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
expr_stmt|;
name|dmsgs
operator|--
expr_stmt|;
block|}
return|return
name|status
argument_list|(
name|vec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|top
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|body
decl_stmt|,
name|lines
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
if|if
condition|(
operator|(
name|j
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"bad number: \"%s\""
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|body
operator|=
name|lines
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|pos
operator|=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|dp
argument_list|)
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
condition|;
name|pos
operator|+=
call|(
name|long
call|)
argument_list|(
name|cp
operator|-
name|buffer
operator|+
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|body
condition|)
block|{
if|if
condition|(
name|lines
operator|++
operator|>=
name|j
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|==
name|NULL
condition|)
name|body
operator|++
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_function
specifier|static
name|int
name|xtnd
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|make_lower
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"bboards"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"archive"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xtnd1
argument_list|(
name|vec
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"x-bboards"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xtnd2
argument_list|(
name|vec
argument_list|)
return|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown XTND command: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xtnd1
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|;
if|if
condition|(
name|vec
index|[
literal|2
index|]
condition|)
block|{
name|make_lower
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|getbbaux
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown BBoard: \"%s\""
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
return|;
if|if
condition|(
name|quitaux
argument_list|(
name|NULLVP
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|maildrop
argument_list|,
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"bboards"
argument_list|)
condition|?
name|bb
operator|->
name|bb_archive
else|:
name|bb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|setupaux
argument_list|(
name|TRUE
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|xtnded
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s %d"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"bboards"
argument_list|)
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too few arguments to XTND \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|BBhead
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|bb_next
control|)
block|{
name|getbbmax
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|bb_flags
operator|&
name|BB_INVIS
operator|)
condition|)
name|multiline
argument_list|(
literal|"%s %d"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|bb
operator|=
name|getbbaux
argument_list|(
name|NULLCP
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|bb_flags
operator|&
name|BB_INVIS
operator|)
condition|)
name|multiline
argument_list|(
literal|"%s %d"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
block|}
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|xtnd2
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|;
if|if
condition|(
name|vec
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too few arguments to XTND \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
name|make_lower
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|getbbaux
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown BBoard: \"%s\""
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|bb
operator|->
name|bb_aka
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
name|cp
operator|!=
name|buffer
condition|?
literal|" %s"
else|:
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_archive
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_map
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_passwd
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|bb
operator|->
name|bb_leader
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
name|cp
operator|!=
name|buffer
condition|?
literal|" %s"
else|:
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_addr
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_request
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_relay
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|bb
operator|->
name|bb_dist
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
name|cp
operator|!=
name|buffer
condition|?
literal|" %s"
else|:
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|getbbmax
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"0%o %d"
argument_list|,
name|bb
operator|->
name|bb_flags
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|bboard
modifier|*
name|getbbaux
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|BBhead
operator|==
name|NULL
condition|)
if|if
condition|(
name|setbbinfo
argument_list|(
name|BBOARDS
argument_list|,
name|BBDB
argument_list|,
literal|1
argument_list|)
condition|)
name|BBtime
operator|=
name|getbbtime
argument_list|()
expr_stmt|;
else|else
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|!=
name|NULLCP
condition|)
for|for
control|(
name|bb
operator|=
name|BBhead
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|bb_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bb
operator|->
name|bb_name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"getbbaux: \"%s\" from cache"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
name|getbbmax
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
while|while
condition|(
name|bb
operator|=
name|getbbent
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|bb
operator|=
name|getbbcpy
argument_list|(
name|bb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|access
argument_list|(
name|bb
operator|->
name|bb_file
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|bb
operator|->
name|bb_flags
operator||=
name|BB_INVIS
expr_stmt|;
name|bb
operator|->
name|bb_mtime
operator|=
name|stat
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
name|st
operator|.
name|st_mtime
else|:
literal|0L
expr_stmt|;
if|if
condition|(
name|BBtail
operator|!=
name|NULL
condition|)
name|BBtail
operator|->
name|bb_next
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|BBhead
operator|==
name|NULL
condition|)
name|BBhead
operator|=
name|bb
expr_stmt|;
name|BBtail
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|bb
operator|->
name|bb_name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|&&
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"getbbaux: \"%s\" from scratch"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|getbbmax
argument_list|(
name|bb
argument_list|)
specifier|register
expr|struct
name|bboard
operator|*
name|bb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"getbbmax: \"%s\", 0%o, %d, %s"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_flags
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|,
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|bb_flags
operator|&
name|BB_INVIS
operator|)
operator|&&
name|access
argument_list|(
name|bb
operator|->
name|bb_file
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|bb
operator|->
name|bb_flags
operator||=
name|BB_INVIS
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
operator|||
name|bb
operator|->
name|bb_mtime
operator|==
name|st
operator|.
name|st_mtime
operator|||
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|bb
operator|->
name|bb_mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|bb
operator|->
name|bb_maxima
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|bb
operator|->
name|bb_date
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|bb
operator|->
name|bb_date
operator|=
name|getcpy
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"updated: \"%s\", 0%o, %d, %s"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_flags
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|,
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|BPOP
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|quit
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|d
decl_stmt|,
name|n
decl_stmt|;
name|d
operator|=
name|dmsgs
operator|,
name|n
operator|=
name|nmsgs
expr_stmt|;
if|if
condition|(
name|quitaux
argument_list|(
name|vec
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|xtnded
condition|)
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s signing off"
argument_list|,
name|server
argument_list|)
return|;
endif|#
directive|endif
endif|BPOP
if|if
condition|(
name|n
operator|==
name|d
condition|)
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s signing off (maildrop empty)"
argument_list|,
name|server
argument_list|)
return|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
name|n
condition|?
literal|"%s signing off (%d message%s, %d octets left)"
else|:
literal|"%s signing off (maildrop empty)"
argument_list|,
name|server
argument_list|,
name|n
operator|-
name|d
argument_list|,
name|n
operator|-
name|d
operator|!=
literal|1
condition|?
literal|"s"
else|:
name|NULL
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|quitaux
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
name|i
operator|=
name|quitfile
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|nmsgs
operator|=
name|dmsgs
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|dp
argument_list|,
name|maildrop
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|quitfile
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|md
decl_stmt|;
name|char
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|map1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|map2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|dmsgs
operator|==
literal|0
operator|||
operator|(
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_flags
operator|&
name|MREAD
operator|)
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to stat file"
argument_list|)
return|;
if|if
condition|(
name|mtime
operator|!=
name|st
operator|.
name|st_mtime
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"new messages have arrived, no update"
argument_list|)
return|;
name|mode
operator|=
call|(
name|int
call|)
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmsgs
operator|==
name|dmsgs
condition|)
block|{
name|i
operator|=
name|truncate
argument_list|(
name|maildrop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|map_name
argument_list|(
name|maildrop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to zero %s"
argument_list|,
name|maildrop
argument_list|)
return|;
return|return
name|OK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_backup
argument_list|(
name|maildrop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|mbx_open
argument_list|(
name|tmpfil
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|st
operator|.
name|st_gid
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to create temporary file"
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
operator|)
operator|&&
name|mbx_write
argument_list|(
name|tmpfil
argument_list|,
name|md
argument_list|,
name|dp
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_id
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
argument_list|,
name|TRUE
argument_list|,
name|debug
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|tmpfil
argument_list|,
name|md
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"error writing temporary file"
argument_list|)
return|;
block|}
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|tmpfil
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|rename
argument_list|(
name|tmpfil
argument_list|,
name|maildrop
argument_list|)
operator|)
operator|==
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|map1
argument_list|,
name|map_name
argument_list|(
name|tmpfil
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|map2
argument_list|,
name|map_name
argument_list|(
name|maildrop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|map1
argument_list|,
name|map2
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|map1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|map2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to rename maildrop"
argument_list|)
return|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|vector
modifier|*
name|getvector
parameter_list|(
name|bp
parameter_list|,
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
decl|*
modifier|*
name|vec
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|vector
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVEC
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
name|NULL
condition|)
block|{
name|vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|vec
index|[
name|i
index|]
operator|=
name|bp
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|vec
index|[
name|NVEC
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too many arguments"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|vec
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"null command"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|make_lower
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|vectors
init|;
name|v
operator|->
name|v_cmd
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|v
operator|->
name|v_cmd
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|v
operator|->
name|v_valid
operator|==
name|mystate
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|v
operator|->
name|v_min
operator|||
name|v
operator|->
name|v_max
operator|<
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too %s arguments to \"%s\""
argument_list|,
name|i
operator|<
name|v
operator|->
name|v_min
condition|?
literal|"few"
else|:
literal|"many"
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|v
return|;
block|}
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown command: \"%s\""
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
specifier|static
name|int
name|respond
parameter_list|(
name|code
parameter_list|,
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|,
decl|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s%s"
argument_list|,
name|code
operator|==
name|OK
condition|?
literal|"+OK"
else|:
literal|"-ERR"
argument_list|,
name|fmt
condition|?
literal|" "
else|:
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
name|bp
operator|+=
name|strlen
argument_list|(
name|sprintf
argument_list|(
name|bp
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|buffer
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_expr_stmt
specifier|static
name|multiline
argument_list|(
argument|fmt
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|)
name|char
operator|*
name|fmt
operator|,
operator|*
name|a
operator|,
operator|*
name|b
operator|,
operator|*
name|c
operator|,
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
operator|+
name|TRMLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|TRM
argument_list|)
expr_stmt|;
name|cp
operator|=
name|sprintf
argument_list|(
name|buffer
operator|+
name|TRMLEN
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|TRM
argument_list|,
name|TRMLEN
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|=
name|buffer
expr_stmt|;
name|putline
argument_list|(
name|cp
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|multiend
argument_list|()
block|{
name|putline
argument_list|(
name|TRM
argument_list|,
name|output
argument_list|)
block|; }
comment|/*
comment|*/
specifier|static
name|int
name|getline
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|iop
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|iop
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
while|while
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
operator|(
name|void
operator|)
name|fgetc
argument_list|(
name|iop
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|c
operator|)
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|iop
argument_list|)
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|p
operator|==
name|s
condition|)
return|return
name|DONE
return|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"<--- %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|putline
argument_list|(
name|s
argument_list|,
name|iop
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|iop
argument_list|,
literal|"%s\r\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"---> %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pipeser
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|sc
parameter_list|)
name|int
name|sig
decl_stmt|;
name|long
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_WARNING
argument_list|,
literal|"lost connection"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

